<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≥üèª üèöÔ∏è üï¶ Criando Tower Defense na Unidade: Inimigos ü§¥üèæ üëÜüèΩ ‚ò™Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ Primeira parte: lado a lado e encontrando o caminho ] 



- Coloca√ß√£o de pontos de cria√ß√£o do inimigo. 
- A apar√™ncia dos inimigos e seu movimento p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Criando Tower Defense na Unidade: Inimigos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452756/">  <i>[ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Primeira parte: lado a lado e encontrando o caminho</a> ]</i> <br><br><ul><li>  Coloca√ß√£o de pontos de cria√ß√£o do inimigo. </li><li>  A apar√™ncia dos inimigos e seu movimento pelo campo. </li><li>  Criando movimento suave a uma velocidade constante. </li><li>  Mude o tamanho, velocidade e posicionamento dos inimigos. </li></ul><br>  Esta √© a segunda parte de um tutorial sobre um jogo simples de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">defesa de torre</a> .  Ele examina o processo de cria√ß√£o de inimigos e seu movimento para o ponto final mais pr√≥ximo. <br><br>  Este tutorial √© feito no Unity 2018.3.0f2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2db/cf3/311/2dbcf331117740aa403cb12a757ae6fd.jpg" width="512" height="256"></div><br>  <i>Inimigos no caminho para o ponto final.</i> <br><a name="habracut"></a><br><h2>  Pontos de cria√ß√£o inimiga (spawn) </h2><br>  Antes de come√ßarmos a criar inimigos, precisamos decidir onde coloc√°-los em campo.  Para fazer isso, criaremos pontos de desova. <br><br><h3>  Conte√∫do em bloco </h3><br>  Um ponto de desova √© outro tipo de conte√∫do de bloco, portanto, adicione uma entrada no <code>GameTileContentType</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination, Wall, SpawnPoint }</code> </pre> <br>  E ent√£o crie uma pr√©-fabricada para visualiz√°-la.  Uma duplicata da pr√©-fabricada do ponto de partida √© bastante adequada para n√≥s, basta alterar seu tipo de conte√∫do e fornecer outro material.  Eu fiz laranja. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e39/522/28d/e3952228dacd6801a6f5d2fb53826cc2.png" width="320" height="104"></div><br>  <i>Configura√ß√£o do ponto de gera√ß√£o.</i> <br><br>  Adicione suporte ao ponto de reprodu√ß√£o √† f√°brica de conte√∫do e vincule-o √† pr√©-fabricada. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent spawnPointPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Destination: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(destinationPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Empty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(emptyPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Wall: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(wallPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.SpawnPoint: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(spawnPointPrefab); } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported type: "</span></span> + type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10f/036/a17/10f036a17ae271cf7b7f7c9694e01782.png" width="320" height="142"></div><br>  <i>F√°brica com suporte para pontos de desova.</i> <br><br><h3>  Ativar ou desativar pontos de reprodu√ß√£o </h3><br>  O m√©todo para mudar o estado do ponto de desova, como outros m√©todos de troca, adicionaremos ao <code>GameBoard</code> .  Mas os pontos de reprodu√ß√£o n√£o afetam a pesquisa do caminho, portanto, ap√≥s a altera√ß√£o, n√£o precisamos procurar novos caminhos. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleSpawnPoint</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.SpawnPoint) { tile.Content = contentFactory.Get(GameTileContentType.Empty); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.SpawnPoint); } }</code> </pre> <br>  O jogo s√≥ faz sentido se tivermos inimigos e eles precisarem de pontos de reprodu√ß√£o.  Portanto, o campo de jogo deve conter pelo menos um ponto de reprodu√ß√£o.  Tamb√©m precisaremos de acesso aos pontos de desova no futuro, quando adicionarmos inimigos, ent√£o vamos usar a lista para rastrear todas as pe√ßas com esses pontos.  Atualizaremos a lista ao mudar o estado do ponto de desova e impediremos a remo√ß√£o do √∫ltimo ponto de desova. <br><br><pre> <code class="cs hljs"> List&lt;GameTile&gt; spawnPoints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;GameTile&gt;(); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleSpawnPoint</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.SpawnPoint) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spawnPoints.Count &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { spawnPoints.Remove(tile); tile.Content = contentFactory.Get(GameTileContentType.Empty); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.SpawnPoint); spawnPoints.Add(tile); } }</code> </pre> <br>  O m√©todo <code>Initialize</code> agora deve definir o ponto de desova para criar o estado correto inicial do campo.  Vamos apenas incluir o primeiro bloco, que fica no canto inferior esquerdo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ ToggleDestination(tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>]); ToggleSpawnPoint(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br>  Vamos fazer o toque alternativo agora mudar o estado dos pontos de reprodu√ß√£o, mas quando voc√™ pressiona a tecla Shift esquerda (a combina√ß√£o de teclas √© verificada pelo m√©todo <code>Input.GetKey</code> ), o estado do ponto final muda <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleAlternativeTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { board.ToggleDestination(tile); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { board.ToggleSpawnPoint(tile); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f9/cd6/22b/2f9cd622bf1aa41023e5204e1f4caa9a.png" width="230" height="230"></div><br>  <i>Campo com pontos de desova.</i> <br><br><h3>  Obtenha acesso aos pontos de desova </h3><br>  O campo lida com todos os seus ladrilhos, mas os inimigos n√£o s√£o de sua responsabilidade.  <code>GetSpawnPoint</code> poss√≠vel acessar seus pontos de <code>GetSpawnPoint</code> atrav√©s do m√©todo <code>GetSpawnPoint</code> comum com um par√¢metro index. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSpawnPoint</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> spawnPoints[index]; }</code> </pre> <br>  Para saber quais √≠ndices est√£o corretos, s√£o necess√°rias informa√ß√µes sobre o n√∫mero de pontos de reprodu√ß√£o, portanto, tornaremos geral usando a propriedade getter geral. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SpawnPointCount =&gt; spawnPoints.Count;</code> </pre> <br><h2>  Apari√ß√£o inimiga </h2><br>  Gerar um inimigo √© um pouco semelhante √† cria√ß√£o do conte√∫do de uma pe√ßa.  Criamos uma inst√¢ncia pr√©-fabricada atrav√©s da f√°brica, que depois colocamos no campo. <br><br><h3>  F√°bricas </h3><br>  Criaremos uma f√°brica de inimigos que colocar√° tudo o que criar em seu pr√≥prio palco.  Essa funcionalidade √© comum na f√°brica que j√° possu√≠mos, ent√£o vamos colocar o c√≥digo na classe base comum <code>GameObjectFactory</code> .  Vamos precisar apenas de um m√©todo <code>CreateGameObjectInstance</code> com um par√¢metro de prefab comum, que cria e retorna uma inst√¢ncia e tamb√©m gerencia toda a cena.  Tornamos o m√©todo <code>protected</code> , ou seja, ele estar√° dispon√≠vel apenas para a classe e todos os tipos que herdam dela.  √â tudo o que a classe faz: n√£o se destina a ser usada como uma f√°brica totalmente funcional.  Portanto, marcamos como <code>abstract</code> , o que n√£o nos permitir√° criar inst√¢ncias de seus objetos. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.SceneManagement; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameObjectFactory</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { Scene scene; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> T CreateGameObjectInstance&lt;T&gt; (T prefab) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : MonoBehaviour { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!scene.isLoaded) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Application.isEditor) { scene = SceneManager.GetSceneByName(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!scene.isLoaded) { scene = SceneManager.CreateScene(name); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { scene = SceneManager.CreateScene(name); } } T instance = Instantiate(prefab); SceneManager.MoveGameObjectToScene(instance.gameObject, scene); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } }</code> </pre> <br>  Altere o <code>GameTileContentFactory</code> para que ele <code>GameTileContentFactory</code> esse tipo de f√°brica e use <code>CreateGameObjectInstance</code> no m√©todo <code>Get</code> e remova o c√≥digo de controle da cena. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContentFactory</span></span> : <span class="hljs-title"><span class="hljs-title">GameObjectFactory</span></span> { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">//Scene contentScene; ‚Ä¶ GameTileContent Get (GameTileContent prefab) { GameTileContent instance = CreateGameObjectInstance(prefab); instance.OriginFactory = this; //MoveToFactoryScene(instance.gameObject); return instance; } //void MoveToFactoryScene (GameObject o) { // ‚Ä¶ //} }</span></span></code> </pre> <br>  Depois disso, crie um novo tipo <code>EnemyFactory</code> que crie uma inst√¢ncia de uma pr√©-fabricada <code>Enemy</code> usando o m√©todo <code>Get</code> , juntamente com o m√©todo de <code>Reclaim</code> o acompanha. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyFactory</span></span> : <span class="hljs-title"><span class="hljs-title">GameObjectFactory</span></span> { [SerializeField] Enemy prefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy instance = CreateGameObjectInstance(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reclaim</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Enemy enemy</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(enemy.OriginFactory == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"Wrong factory reclaimed!"</span></span>); Destroy(enemy.gameObject); } }</code> </pre> <br>  O novo tipo de <code>Enemy</code> inicialmente tinha apenas que acompanhar sua f√°brica original. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Enemy</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { EnemyFactory originFactory; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EnemyFactory OriginFactory { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; originFactory; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Debug.Assert(originFactory == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined origin factory!"</span></span>); originFactory = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } }</code> </pre> <br><h3>  Prefab </h3><br>  Os inimigos precisam de visualiza√ß√£o, que pode ser qualquer coisa - um rob√¥, uma aranha, um fantasma, algo mais simples, por exemplo, um cubo, que usamos.  Mas, em geral, o inimigo tem um modelo 3D de qualquer complexidade.  Para garantir seu suporte conveniente, usaremos o objeto raiz para a hierarquia pr√©-fabricada inimiga, √† qual apenas o componente <code>Enemy</code> est√° anexado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c6/348/428/7c6348428b50732e0a13efcdadfc9fff.png" width="320" height="160"></div><br>  <i>Raiz pr√©-fabricada</i> <br><br>  Vamos criar esse objeto como o √∫nico elemento filho, que ser√° a raiz do modelo.  Ele deve ter valores de unidade de transforma√ß√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce7/691/330/ce7691330dd6c6813d2a64398c582c2a.png" width="320" height="120"></div><br>  <i>A raiz do modelo.</i> <br><br>  A tarefa dessa raiz do modelo √© posicionar o modelo 3D em rela√ß√£o ao ponto de origem local das coordenadas do inimigo, para que ele o considere como um ponto de refer√™ncia sobre o qual o inimigo est√° ou trava.  No nosso caso, o modelo ser√° um cubo padr√£o de meio tamanho, ao qual darei uma cor azul escura.  Tornamos um filho da raiz do modelo e configuramos a posi√ß√£o Y para 0,25, para que ela fique no ch√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65b/7a3/808/65b7a3808f469e2723b344afccd94f8f.png" width="320" height="206"></div><br>  <i>Modelo de cubo</i> <br><br>  Assim, a pr√©-fabricada do inimigo consiste em tr√™s objetos aninhados: a raiz da pr√©-fabricada, a raiz do modelo e o cubo.  Pode parecer um fracasso para um cubo simples, mas esse sistema permite mover e animar qualquer inimigo sem se preocupar com seus recursos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/0c9/abb/62a0c9abb59605150235ba6cec73eeb2.png" width="225" height="74"></div><br>  <i>A hierarquia pr√©-fabricada do inimigo.</i> <br><br>  Vamos criar uma f√°brica inimiga e atribuir uma pr√©-fabricada a ela. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae3/ee2/345/ae3ee23456931ac6f989a763deb8b7b1.png" width="320" height="88"></div><br>  <i>F√°brica de ativos.</i> <br><br><h3>  Colocando inimigos no campo </h3><br>  Para colocar inimigos em campo, o <code>Game</code> deve receber um link para a f√°brica de inimigos.  Como precisamos de muitos inimigos, adicionaremos uma op√ß√£o de configura√ß√£o para ajustar a velocidade da desova, expressa no n√∫mero de inimigos por segundo.  Um intervalo aceit√°vel √© de 0,1 a 10 com um valor padr√£o de 1. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] EnemyFactory enemyFactory = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [SerializeField, Range(<span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> spawnSpeed = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/201/56b/338/20156b3384b45ab95d7aef5ed5397480.png" width="320" height="144"></div><br>  <i>Jogo com uma f√°brica inimiga e velocidade de desova 4.</i> <br><br>  N√≥s rastrearemos a progress√£o da desova no <code>Update</code> , aumentando a velocidade dos tempos delta.  Se o valor de prggress exceder 1, ent√£o o decrementamos e <code>SpawnEnemy</code> o inimigo usando o novo m√©todo <code>SpawnEnemy</code> .  Continuamos fazendo isso at√© o progresso exceder 1, caso a velocidade seja muito alta e o tempo de exibi√ß√£o seja muito longo, para que v√°rios inimigos n√£o sejam criados ao mesmo tempo. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> spawnProgress; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ spawnProgress += spawnSpeed * Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (spawnProgress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { spawnProgress -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; SpawnEnemy(); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">N√£o √© necess√°rio atualizar o progresso no FixedUpdate?</b> <div class="spoiler_text">  Sim, √© poss√≠vel, mas n√£o s√£o necess√°rios hor√°rios precisos para o jogo de defesa.  Vamos simplesmente atualizar o estado do jogo a cada quadro e faz√™-lo funcionar bem o suficiente para qualquer delta de tempo. </div></div><br>  Deixe <code>SpawnEnemy</code> obter um ponto de desova aleat√≥rio no campo e criar um inimigo nesse ladrilho.  Vamos fornecer ao m√©todo <code>SpawnOn</code> o <code>Enemy</code> para se <code>SpawnOn</code> corretamente. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnEnemy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile spawnPoint = board.GetSpawnPoint(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, board.SpawnPointCount)); Enemy enemy = enemyFactory.Get(); enemy.SpawnOn(spawnPoint); }</code> </pre> <br>  Por enquanto, tudo o que o <code>SpawnOn</code> precisa fazer √© definir sua pr√≥pria posi√ß√£o igual ao centro do bloco.  Como o modelo pr√©-fabricado est√° posicionado corretamente, o cubo inimigo estar√° no topo desse bloco. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnOn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { transform.localPosition = tile.transform.localPosition; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b5/74a/ce9/8b574ace93bd2c7f7829d41f9208a138.png" width="230" height="230"></div><br>  <i>Os inimigos aparecem nos pontos de desova.</i> <br><br><h2>  Movendo inimigos </h2><br>  Depois que o inimigo aparecer, ele deve come√ßar a se mover ao longo do caminho at√© o ponto final mais pr√≥ximo.  Para conseguir isso, voc√™ precisa animar os inimigos.  Come√ßamos com um simples deslizamento suave de ladrilho em ladrilho e depois dificultamos o movimento. <br><br><h3>  Cole√ß√£o de inimigos </h3><br>  Para atualizar o status dos inimigos, usaremos a mesma abordagem usada na s√©rie de tutoriais sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gerenciamento de objetos</a> .  Adicionamos ao <code>Enemy</code> m√©todo <code>GameUpdate</code> geral, que retorna informa√ß√µes sobre se ele est√° vivo, o que, nesta fase, sempre ser√° verdadeiro.  Por enquanto, basta faz√™-lo avan√ßar de acordo com o delta do tempo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localPosition += Vector3.forward * Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Al√©m disso, precisamos manter uma lista de inimigos vivos e atualizar todos eles, removendo-os da lista de inimigos mortos.  Podemos colocar todo esse c√≥digo em um <code>Game</code> , mas isol√°-lo e criar um tipo de <code>EnemyCollection</code> .  Esta √© uma classe serializ√°vel que n√£o herda de nada.  Damos a ele um m√©todo geral para adicionar um inimigo e outro m√©todo para atualizar toda a cole√ß√£o. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyCollection</span></span> { List&lt;Enemy&gt; enemies = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Enemy&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Enemy enemy</span></span></span><span class="hljs-function">)</span></span> { enemies.Add(enemy); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; enemies.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!enemies[i].GameUpdate()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = enemies.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; enemies[i] = enemies[lastIndex]; enemies.RemoveAt(lastIndex); i -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } }</code> </pre> <br>  Agora o <code>Game</code> ser√° suficiente para criar apenas uma dessas cole√ß√µes, em cada quadro atualize-a e adicione inimigos criados a ela.  Atualizaremos os inimigos imediatamente ap√≥s a poss√≠vel gera√ß√£o de um novo inimigo, para que a atualiza√ß√£o ocorra instantaneamente. <br><br><pre> <code class="cs hljs"> EnemyCollection enemies = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnemyCollection(); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ enemies.GameUpdate(); } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnEnemy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ enemies.Add(enemy); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25f/eb8/dc6/25feb8dc6f0d3a5a66be43f311cd7818.png" width="230" height="230"></div><br>  <i>Os inimigos est√£o avan√ßando.</i> <br><br><h3>  Movimento ao longo do caminho </h3><br>  Os inimigos j√° est√£o se movendo, mas at√© agora n√£o seguem o caminho.  Para fazer isso, eles precisam saber para onde ir a seguir.  Portanto, vamos dar ao <code>GameTile</code> propriedade getter comum para obter o pr√≥ximo bloco no caminho. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTile NextTileOnPath =&gt; nextOnPath;</code> </pre> <br>  Conhecendo o bloco do qual voc√™ deseja sair e o bloco no qual voc√™ precisa entrar, os inimigos podem determinar os pontos inicial e final para mover um bloco.  O inimigo pode interpolar a posi√ß√£o entre esses dois pontos, rastreando seus movimentos.  Ap√≥s a conclus√£o da movimenta√ß√£o, esse processo √© repetido para o pr√≥ximo bloco.  Mas os caminhos podem mudar a qualquer momento.  Em vez de determinar para onde ir mais longe no processo de movimento, simplesmente continuamos a percorrer a rota planejada e verific√°-la, atingindo o pr√≥ximo bloco. <br><br>  Deixe o <code>Enemy</code> rastrear os dois blocos para que n√£o sejam afetados por uma mudan√ßa no caminho.  Ele tamb√©m rastrear√° as posi√ß√µes para que n√£o precisemos receb√™-las em cada quadro e acompanhar√° o processo de mudan√ßa. <br><br><pre> <code class="cs hljs"> GameTile tileFrom, tileTo; Vector3 positionFrom, positionTo; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> progress;</code> </pre> <br>  Inicialize esses campos no <code>SpawnOn</code> .  O primeiro ponto √© o bloco do qual o inimigo est√° se movendo, e o ponto final √© o pr√≥ximo bloco no caminho.  Isso pressup√µe que o pr√≥ximo bloco exista, a menos que o inimigo tenha sido criado no ponto final, o que deve ser imposs√≠vel.  Em seguida, armazenamos em cache as posi√ß√µes dos blocos e redefinimos o progresso.  N√£o precisamos definir a posi√ß√£o do inimigo aqui, porque o m√©todo <code>GameUpdate</code> chamado no mesmo quadro. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnOn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//transform.localPosition = tile.transform.localPosition; Debug.Assert(tile.NextTileOnPath != null, "Nowhere to go!", this); tileFrom = tile; tileTo = tile.NextTileOnPath; positionFrom = tileFrom.transform.localPosition; positionTo = tileTo.transform.localPosition; progress = 0f; }</span></span></code> </pre> <br>  O incremento de progresso ser√° realizado no <code>GameUpdate</code> .  Vamos adicionar um delta de tempo constante para que os inimigos se movam a uma velocidade de um bloco por segundo.  Quando o progresso est√° completo, alteramos os dados para que <code>To</code> se torne o valor <code>From</code> e o novo <code>To</code> seja o pr√≥ximo bloco no caminho.  Ent√£o diminu√≠mos o progresso.  Quando os dados se tornam relevantes, interpolamos a posi√ß√£o do inimigo entre <code>From</code> e <code>To</code> .  Como o interpolador √© progresso, seu valor est√° necessariamente no intervalo de 0 e 1, para que possamos usar s <code>Vector3.LerpUnclamped</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { tileFrom = tileTo; tileTo = tileTo.NextTileOnPath; positionFrom = positionTo; positionTo = tileTo.transform.localPosition; progress -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } transform.localPosition = Vector3.LerpUnclamped(positionFrom, positionTo, progress); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Isso for√ßa os inimigos a seguirem o caminho, mas n√£o agem ao atingir o ponto final.  Portanto, antes de alterar as posi√ß√µes de <code>From</code> e <code>To</code> , voc√™ precisa comparar o pr√≥ximo bloco no caminho com <code>null</code> .  Nesse caso, chegamos ao ponto final e o inimigo terminou o movimento.  Executamos a Reclaim e retornamos <code>false</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { tileFrom = tileTo; tileTo = tileTo.NextTileOnPath; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileTo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { OriginFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } positionFrom = positionTo; positionTo = tileTo.transform.localPosition; progress -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; }</code> </pre> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Os inimigos seguem o caminho mais curto.</i> <br><br>  Agora os inimigos est√£o se movendo do centro de um bloco para outro.  Vale a pena considerar que eles mudam seu estado de movimento apenas no centro dos ladrilhos, portanto, n√£o podem responder imediatamente √†s mudan√ßas no campo.  Isso significa que, √†s vezes, os inimigos se movem pelas paredes que acabamos de definir.  Uma vez que eles come√ßaram a se mover em dire√ß√£o √† c√©lula, nada os impedia.  √â por isso que as paredes tamb√©m precisam de caminhos reais. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Os inimigos reagem √† mudan√ßa de caminhos.</i> <br><br><h3>  Movimento de borda a borda </h3><br>  O movimento entre os centros dos ladrilhos e uma mudan√ßa acentuada de dire√ß√£o parece normal para um jogo abstrato no qual os inimigos est√£o movendo cubos, mas geralmente o movimento suave parece mais bonito.  O primeiro passo para sua implementa√ß√£o n√£o √© mover-se pelos centros, mas pelas bordas dos ladrilhos. <br><br>  O ponto da aresta entre os blocos adjacentes pode ser encontrado pela m√©dia de suas posi√ß√µes.  Em vez de calcul√°-lo a cada passo de cada inimigo, s√≥ o calcularemos quando alterar o caminho em <code>GameTile.GrowPathTo</code> .  Torne-o dispon√≠vel usando a propriedade <code>ExitPoint</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 ExitPoint { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ neighbor.ExitPoint = (neighbor.transform.localPosition + transform.localPosition) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor.Content.Type != GameTileContentType.Wall ? neighbor : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  O √∫nico caso especial √© a c√©lula final, cujo ponto de sa√≠da ser√° o seu centro. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BecomeDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; nextOnPath = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; ExitPoint = transform.localPosition; }</code> </pre> <br>  Troque o <code>Enemy</code> para que ele use pontos de sa√≠da, n√£o centros de lado a lado. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { ‚Ä¶ positionTo = tileFrom.ExitPoint; progress -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } transform.localPosition = Vector3.Lerp(positionFrom, positionTo, progress); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnOn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ positionTo = tileFrom.ExitPoint; progress = <span class="hljs-number"><span class="hljs-number">0f</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Os inimigos se movem entre as bordas.</i> <br><br>  Um efeito colateral dessa mudan√ßa √© que, quando os inimigos se viram devido a uma mudan√ßa no caminho, eles permanecem im√≥veis por um segundo. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Ao virar, os inimigos param.</i> <br><br><h3>  Orienta√ß√£o </h3><br>  Embora os inimigos se movam pelos caminhos at√© mudar de orienta√ß√£o.  Para que possam olhar na dire√ß√£o do movimento, precisam saber a dire√ß√£o do caminho que est√£o seguindo.  Tamb√©m determinaremos isso durante a busca de maneiras, para que isso n√£o precise ser feito pelos inimigos. <br><br>  Temos quatro dire√ß√µes: norte, leste, sul e oeste.  Vamos enumer√°-los. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Direction { North, East, South, West }</code> </pre> <br>  Em seguida, fornecemos a propriedade <code>GameTile</code> para armazenar a dire√ß√£o do seu caminho. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Direction PathDirection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Adicione um par√¢metro de dire√ß√£o ao <code>GrowTo</code> , que define a propriedade.  Como estamos desenvolvendo um caminho do come√ßo ao fim, a dire√ß√£o ser√° oposta √† de onde estamos desenvolvendo o caminho. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathNorth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(north, Direction.South); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathEast</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(east, Direction.West); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathSouth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(south, Direction.North); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathWest</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(west, Direction.East); <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor, Direction direction</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ neighbor.PathDirection = direction; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor.Content.Type != GameTileContentType.Wall ? neighbor : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Precisamos converter as dire√ß√µes em curvas expressas como quaternions.  Seria conveniente se pud√©ssemos chamar <code>GetRotation</code> para a dire√ß√£o, ent√£o vamos fazer isso criando um m√©todo de extens√£o.  Adicione o m√©todo est√°tico geral <code>DirectionExtensions</code> , forne√ßa uma matriz para armazenar em cache os quaternions necess√°rios, bem como o m√©todo <code>GetRotation</code> para retornar o valor de dire√ß√£o correspondente.  Nesse caso, faz sentido colocar a classe de extens√£o no mesmo arquivo que o tipo de enumera√ß√£o. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Direction { North, East, South, West } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DirectionExtensions</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Quaternion[] rotations = { Quaternion.identity, Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">180f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">270f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Quaternion </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Direction direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rotations[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">O que √© um m√©todo de extens√£o?</b> <div class="spoiler_text">  Um m√©todo de extens√£o √© um m√©todo est√°tico dentro de uma classe est√°tica que se comporta como um m√©todo de inst√¢ncia de algum tipo.  Esse tipo pode ser uma classe, interface, estrutura, valor primitivo ou enumera√ß√£o.  O primeiro argumento para o m√©todo de extens√£o deve ter a <code>this</code> .  Ele define o valor do tipo e inst√¢ncia com os quais o m√©todo funcionar√°.  Essa abordagem significa que as propriedades de expans√£o n√£o s√£o poss√≠veis. <br><br>  Isso permite que voc√™ adicione m√©todos a alguma coisa?  Sim, assim como voc√™ pode escrever qualquer m√©todo est√°tico cujo par√¢metro seja qualquer tipo. </div></div><br>  Agora podemos girar o <code>Enemy</code> ao gerar e toda vez que entramos em um novo bloco.  Depois de atualizar os dados, o bloco <code>From</code> fornece orienta√ß√£o. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { ‚Ä¶ transform.localRotation = tileFrom.PathDirection.GetRotation(); progress -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } transform.localPosition = Vector3.LerpUnclamped(positionFrom, positionTo, progress); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnOn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ transform.localRotation = tileFrom.PathDirection.GetRotation(); progress = <span class="hljs-number"><span class="hljs-number">0f</span></span>; }</code> </pre> <br><h3>  Mudan√ßa de dire√ß√£o </h3><br>  Em vez de mudar instantaneamente de dire√ß√£o, √© melhor interpolar valores entre as curvas, semelhante √† maneira como interpolamos entre posi√ß√µes.  Para passar de uma orienta√ß√£o para outra, precisamos saber a mudan√ßa de dire√ß√£o que precisa ser feita: sem virar, virar √† direita, virar √† esquerda ou voltar.  Adicionamos para isso uma enumera√ß√£o, que novamente pode ser colocada no mesmo arquivo que a <code>Direction</code> , porque elas s√£o pequenas e est√£o intimamente relacionadas. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Direction { North, East, South, West } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> DirectionChange { None, TurnRight, TurnLeft, TurnAround }</code> </pre> <br>  Adicione outro m√©todo de extens√£o, desta vez <code>GetDirectionChangeTo</code> , que retorna uma mudan√ßa de dire√ß√£o da dire√ß√£o atual para a pr√≥xima.  Se as dire√ß√µes coincidirem, n√£o haver√° mudan√ßa.  Se o pr√≥ximo for mais do que o atual, ent√£o esta √© uma curva para a direita.  Por√©m, como as instru√ß√µes s√£o repetidas, a mesma situa√ß√£o ocorrer√° quando a pr√≥xima for tr√™s a menos que a atual.  Com uma curva √† esquerda, ser√° a mesma, apenas adi√ß√£o e subtra√ß√£o mudar√£o de lugar.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O √∫nico caso restante √© uma volta. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> DirectionChange </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDirectionChangeTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Direction current, Direction next </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == next) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DirectionChange.None; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current + <span class="hljs-number"><span class="hljs-number">1</span></span> == next || current - <span class="hljs-number"><span class="hljs-number">3</span></span> == next) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DirectionChange.TurnRight; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current - <span class="hljs-number"><span class="hljs-number">1</span></span> == next || current + <span class="hljs-number"><span class="hljs-number">3</span></span> == next) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DirectionChange.TurnLeft; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DirectionChange.TurnAround; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como fazemos uma rota√ß√£o em apenas uma dimens√£o, a interpola√ß√£o linear de √¢ngulos ser√° suficiente para n√≥s. </font><font style="vertical-align: inherit;">Adicione outro m√©todo de expans√£o que obtenha o √¢ngulo de dire√ß√£o em graus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAngle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Direction direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)direction * <span class="hljs-number"><span class="hljs-number">90f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora voc√™ </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve acompanhar a dire√ß√£o, a mudan√ßa de dire√ß√£o e os √¢ngulos entre os quais voc√™ precisa executar a interpola√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> Direction direction; DirectionChange directionChange; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> directionAngleFrom, directionAngleTo;</code> </pre> <br> <code>SpawnOn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ficando mais dif√≠cil, ent√£o vamos mudar o c√≥digo de prepara√ß√£o do estado para outro m√©todo. </font><font style="vertical-align: inherit;">Designaremos o estado inicial do inimigo como um estado introdut√≥rio, assim o chamaremos </font></font><code>PrepareIntro</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nesse estado, o inimigo se move do centro para a borda do seu ladrilho inicial, para que n√£o haja mudan√ßa de dire√ß√£o. </font><font style="vertical-align: inherit;">Os √¢ngulos </font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o mesmo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnOn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(tile.NextTileOnPath != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Nowhere to go!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); tileFrom = tile; tileTo = tile.NextTileOnPath; <span class="hljs-comment"><span class="hljs-comment">//positionFrom = tileFrom.transform.localPosition; //positionTo = tileFrom.ExitPoint; //transform.localRotation = tileFrom.PathDirection.GetRotation(); progress = 0f; PrepareIntro(); } void PrepareIntro () { positionFrom = tileFrom.transform.localPosition; positionTo = tileFrom.ExitPoint; direction = tileFrom.PathDirection; directionChange = DirectionChange.None; directionAngleFrom = directionAngleTo = direction.GetAngle(); transform.localRotation = direction.GetRotation(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta fase, criamos algo como uma pequena m√°quina de estado. </font><font style="vertical-align: inherit;">Para simplificar </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mova o c√≥digo de status para um novo m√©todo </font></font><code>PrepareNextState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Vamos deixar apenas as trocas das pe√ßas </font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque as usamos aqui para verificar se o inimigo terminou o caminho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">//positionFrom = positionTo; //positionTo = tileFrom.ExitPoint; //transform.localRotation = tileFrom.PathDirection.GetRotation(); progress -= 1f; PrepareNextState(); } ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao fazer a transi√ß√£o para um novo estado, voc√™ sempre precisa mudar de posi√ß√£o, encontrar uma mudan√ßa de dire√ß√£o, atualizar a dire√ß√£o atual e mudar o √¢ngulo </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">J√° n√£o marcamos uma curva.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareNextState</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { positionFrom = positionTo; positionTo = tileFrom.ExitPoint; directionChange = direction.GetDirectionChangeTo(tileFrom.PathDirection); direction = tileFrom.PathDirection; directionAngleFrom = directionAngleTo; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outras a√ß√µes dependem de uma mudan√ßa de dire√ß√£o. </font><font style="vertical-align: inherit;">Vamos adicionar um m√©todo para cada op√ß√£o. </font><font style="vertical-align: inherit;">No caso de avan√ßarmos, o √¢ngulo </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coincide com a dire√ß√£o do caminho da c√©lula atual. </font><font style="vertical-align: inherit;">Al√©m disso, precisamos definir a rota√ß√£o para que o inimigo esteja olhando para a frente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareForward</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localRotation = direction.GetRotation(); directionAngleTo = direction.GetAngle(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No caso de uma virada, n√£o viramos instantaneamente. </font><font style="vertical-align: inherit;">Precisamos interpolar para um √¢ngulo diferente: 90 ¬∞ mais para virar √† direita, 90 ¬∞ menos para virar √† esquerda e 180 ¬∞ mais para voltar. </font><font style="vertical-align: inherit;">Para evitar girar na dire√ß√£o errada devido a uma altera√ß√£o nos valores de √¢ngulo de 359 ¬∞ a 0 ¬∞, o √¢ngulo </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve ser indicado em rela√ß√£o √† dire√ß√£o atual. </font><font style="vertical-align: inherit;">N√£o precisamos nos preocupar que o √¢ngulo fique abaixo de 0 ¬∞ ou mais de 360 ‚Äã‚Äã¬∞, porque podemos </font></font><code>Quaternion.Euler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lidar com isso.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">90f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom - <span class="hljs-number"><span class="hljs-number">90f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">180f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No final, </font></font><code>PrepareNextState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">podemos usar </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para alterar as dire√ß√µes para decidir qual dos quatro m√©todos chamar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareNextState</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (directionChange) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DirectionChange.None: PrepareForward(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DirectionChange.TurnRight: PrepareTurnRight(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DirectionChange.TurnLeft: PrepareTurnLeft(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: PrepareTurnAround(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, no final </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, precisamos verificar se a dire√ß√£o mudou. </font><font style="vertical-align: inherit;">Nesse caso, interpole entre os dois cantos e defina a rota√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ transform.localPosition = Vector3.LerpUnclamped(positionFrom, positionTo, progress); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (directionChange != DirectionChange.None) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Mathf.LerpUnclamped( directionAngleFrom, directionAngleTo, progress ); transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, angle, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os inimigos est√£o virando.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimento de curva </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos melhorar o movimento fazendo com que os inimigos se movam ao longo de uma curva ao girar. </font><font style="vertical-align: inherit;">Em vez de caminhar de uma ponta a outra dos ladrilhos, deixe-os andar um quarto de c√≠rculo. </font><font style="vertical-align: inherit;">O centro deste c√≠rculo fica em um canto comum aos ladrilhos </font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na mesma borda ao longo da qual o inimigo entrou no ladrilho </font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d7/8a6/3a5/1d78a63a58d34a1d8cc9ff56a0b23cc3.png" width="256" height="256"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma rota√ß√£o de quarto de c√≠rculo para virar √† direita. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos perceber isso movendo o inimigo em um arco usando trigonometria, enquanto ao mesmo tempo o giramos. </font><font style="vertical-align: inherit;">Mas isso pode ser simplificado usando apenas rota√ß√£o, movendo temporariamente a origem local das coordenadas do inimigo para o centro do c√≠rculo. </font><font style="vertical-align: inherit;">Para fazer isso, precisamos mudar a posi√ß√£o do modelo inimigo, para fornecer um </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link para esse modelo, acess√≠vel atrav√©s do campo de configura√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform model = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72b/13c/28e/72b13c28ed9d6a8d34f3e17536e964cd.png" width="320" height="56"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inimigo com refer√™ncia ao modelo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em prepara√ß√£o para avan√ßar ou recuar, o modelo deve passar para a posi√ß√£o padr√£o, para a origem local das coordenadas do inimigo. </font><font style="vertical-align: inherit;">Caso contr√°rio, o modelo deve ser deslocado pela metade da unidade de medida - o raio do c√≠rculo de rota√ß√£o, longe do ponto de virada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareForward</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localRotation = direction.GetRotation(); directionAngleTo = direction.GetAngle(); model.localPosition = Vector3.zero; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom - <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">180f</span></span>; model.localPosition = Vector3.zero; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, o pr√≥prio inimigo precisa ser movido para o ponto de virada. </font><font style="vertical-align: inherit;">Para fazer isso, tamb√©m deve ser movido metade da unidade de medida, mas o deslocamento exato depende da dire√ß√£o. </font><font style="vertical-align: inherit;">Vamos adicionar </font></font><code>Direction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um m√©todo de extens√£o auxiliar a isso </font></font><code>GetHalfVector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Vector3[] halfVectors = { Vector3.forward * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, Vector3.right * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, Vector3.back * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, Vector3.left * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> }; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHalfVector</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Direction direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> halfVectors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicione o vetor correspondente ao girar para a direita ou esquerda. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom + direction.GetHalfVector(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom - <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom + direction.GetHalfVector(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E ao voltar, a posi√ß√£o deve ser o ponto de partida habitual. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">180f</span></span>; model.localPosition = Vector3.zero; transform.localPosition = positionFrom; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, ao calcular o ponto de sa√≠da, podemos usar </font></font><code>GameTile.GrowPathTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metade do vetor para n√£o precisar de acesso √†s duas posi√ß√µes dos blocos.</font></font><br><br><pre> <code class="cs hljs"> neighbor.ExitPoint = neighbor.transform.localPosition + direction.GetHalfVector();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, ao mudar de dire√ß√£o, n√£o precisamos interpolar a posi√ß√£o </font></font><code>Enemy.GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque a rota√ß√£o est√° envolvida no movimento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (directionChange == DirectionChange.None) { transform.localPosition = Vector3.LerpUnclamped(positionFrom, positionTo, progress); } <span class="hljs-comment"><span class="hljs-comment">//if (directionChange != DirectionChange.None) { else { float angle = Mathf.LerpUnclamped( directionAngleFrom, directionAngleTo, progress ); transform.localRotation = Quaternion.Euler(0f, angle, 0f); } return true; }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os inimigos se dobram suavemente nos cantos.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Velocidade constante </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© esse ponto, a velocidade dos inimigos sempre foi igual a um bloco por segundo, independentemente de como eles se movem dentro do bloco. </font><font style="vertical-align: inherit;">Mas a dist√¢ncia que eles cobrem depende de sua condi√ß√£o; portanto, sua velocidade, expressa em unidades por segundo, varia. </font><font style="vertical-align: inherit;">Para que essa velocidade seja constante, precisamos alterar a velocidade do progresso, dependendo do estado. </font><font style="vertical-align: inherit;">Portanto, adicione o campo multiplicador de progresso e use-o para dimensionar o delta </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> progress, progressFactor; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime * progressFactor; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas se o progresso mudar dependendo do estado, o valor restante do progresso n√£o poder√° ser usado diretamente para o pr√≥ximo estado. </font><font style="vertical-align: inherit;">Portanto, antes de nos preparar para um novo estado, precisamos normalizar o progresso e aplicar o novo multiplicador j√° em um novo estado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime * progressFactor; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">//progress -= 1f; progress = (progress - 1f) / progressFactor; PrepareNextState(); progress *= progressFactor; } ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avan√ßar n√£o requer mudan√ßas, portanto, usa um fator de 1. Ao virar para a direita ou para a esquerda, o inimigo passa um quarto de c√≠rculo com um raio de ¬Ω, ent√£o a dist√¢ncia percorrida √© ¬ºœÄ. </font></font><code>progress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">igual a um dividido por esse valor. </font><font style="vertical-align: inherit;">Voltar n√£o deve demorar muito, portanto, dobre o progresso para que demore meio segundo. </font><font style="vertical-align: inherit;">Finalmente, o movimento introdut√≥rio cobre apenas metade da pe√ßa, portanto, para manter uma velocidade constante, seu progresso tamb√©m precisa ser dobrado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareForward</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareIntro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que a dist√¢ncia √© igual a 1/4 * pi?</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A circunfer√™ncia √© 2œÄ vezes o raio. </font><font style="vertical-align: inherit;">Girar para a direita ou esquerda cobre apenas um quarto desse comprimento, e o raio √© ¬Ω, ent√£o a dist√¢ncia √© ¬ΩœÄ √ó ¬Ω.</font></font></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estado final </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como temos um estado introdut√≥rio, vamos adicionar um final. </font><font style="vertical-align: inherit;">No momento, os inimigos est√£o desaparecendo imediatamente ap√≥s atingir o ponto final, mas vamos adiar o desaparecimento deles at√© chegarem ao centro do bloco final. </font><font style="vertical-align: inherit;">Vamos criar um m√©todo para isso </font></font><code>PrepareOutro</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, defina o movimento para frente, mas apenas para o centro do bloco com progresso duplicado para manter uma velocidade constante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareOutro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { positionTo = tileFrom.transform.localPosition; directionChange = DirectionChange.None; directionAngleTo = direction.GetAngle(); model.localPosition = Vector3.zero; transform.localRotation = direction.GetRotation(); progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o destruir o inimigo muito cedo, removeremos a mudan√ßa de lado a lado. </font><font style="vertical-align: inherit;">Ele far√° isso agora </font></font><code>PrepareNextState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Assim, a verifica√ß√£o de </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retornos </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">somente ap√≥s o final do estado final.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime * progressFactor; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//tileFrom = tileTo; //tileTo = tileTo.NextTileOnPath; if (tileTo == null) { OriginFactory.Reclaim(this); return false; } ‚Ä¶ } ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em </font></font><code>PrepareNextState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vamos come√ßar com a mudan√ßa de pe√ßas. </font><font style="vertical-align: inherit;">Depois de definir a posi√ß√£o </font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas antes de definir a posi√ß√£o, </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verificaremos se o bloco √© igual ao </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nesse caso, prepare o estado final e pule o restante do m√©todo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareNextState</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { tileFrom = tileTo; tileTo = tileTo.NextTileOnPath; positionFrom = positionTo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileTo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { PrepareOutro(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } positionTo = tileFrom.ExitPoint; ‚Ä¶ }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inimigos com velocidade constante e estado final.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variabilidade Inimiga </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temos um fluxo de inimigos, e eles s√£o todos do mesmo cubo, movendo-se na mesma velocidade. </font><font style="vertical-align: inherit;">O resultado √© mais como uma cobra longa do que inimigos individuais. </font><font style="vertical-align: inherit;">Vamos torn√°-los mais diferentes, randomizando seu tamanho, deslocamento e velocidade.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Faixa de valor flutuante </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mudaremos os par√¢metros dos inimigos, escolhendo aleatoriamente suas caracter√≠sticas na faixa de valores. </font><font style="vertical-align: inherit;">A estrutura </font></font><code>FloatRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que criamos no artigo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gerenciamento de objetos, Configurando formas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ser√° √∫til aqui </font><font style="vertical-align: inherit;">, ent√£o vamos copi√°-la. </font><font style="vertical-align: inherit;">As √∫nicas altera√ß√µes foram adicionar um construtor com um par√¢metro e abrir o acesso ao m√≠nimo e ao m√°ximo usando propriedades readonly, para que o intervalo fosse imut√°vel.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> FloatRange { [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> min, max; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Min =&gt; min; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Max =&gt; max; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> RandomValueInRange { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Random.Range(min, max); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FloatRange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { min = max = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FloatRange</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> min, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> max</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.min = min; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.max = max &lt; min ? min : max; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tamb√©m copiamos o atributo definido para limitar seu intervalo. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FloatRangeSliderAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">PropertyAttribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Min { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Max { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FloatRangeSliderAttribute</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> min, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> max</span></span></span><span class="hljs-function">)</span></span> { Min = min; Max = max &lt; min ? min : max; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos apenas da visualiza√ß√£o do controle deslizante, ent√£o copie-o </font></font><code>FloatRangeSliderDrawer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para a pasta </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CustomPropertyDrawer(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(FloatRangeSliderAttribute))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FloatRangeSliderDrawer</span></span> : <span class="hljs-title"><span class="hljs-title">PropertyDrawer</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnGUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Rect position, SerializedProperty property, GUIContent label </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalIndentLevel = EditorGUI.indentLevel; EditorGUI.BeginProperty(position, label, property); position = EditorGUI.PrefixLabel( position, GUIUtility.GetControlID(FocusType.Passive), label ); EditorGUI.indentLevel = <span class="hljs-number"><span class="hljs-number">0</span></span>; SerializedProperty minProperty = property.FindPropertyRelative(<span class="hljs-string"><span class="hljs-string">"min"</span></span>); SerializedProperty maxProperty = property.FindPropertyRelative(<span class="hljs-string"><span class="hljs-string">"max"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> minValue = minProperty.floatValue; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> maxValue = maxProperty.floatValue; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fieldWidth = position.width / <span class="hljs-number"><span class="hljs-number">4f</span></span> - <span class="hljs-number"><span class="hljs-number">4f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sliderWidth = position.width / <span class="hljs-number"><span class="hljs-number">2f</span></span>; position.width = fieldWidth; minValue = EditorGUI.FloatField(position, minValue); position.x += fieldWidth + <span class="hljs-number"><span class="hljs-number">4f</span></span>; position.width = sliderWidth; FloatRangeSliderAttribute limit = attribute <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> FloatRangeSliderAttribute; EditorGUI.MinMaxSlider( position, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> minValue, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> maxValue, limit.Min, limit.Max ); position.x += sliderWidth + <span class="hljs-number"><span class="hljs-number">4f</span></span>; position.width = fieldWidth; maxValue = EditorGUI.FloatField(position, maxValue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minValue &lt; limit.Min) { minValue = limit.Min; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxValue &lt; minValue) { maxValue = minValue; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxValue &gt; limit.Max) { maxValue = limit.Max; } minProperty.floatValue = minValue; maxProperty.floatValue = maxValue; EditorGUI.EndProperty(); EditorGUI.indentLevel = originalIndentLevel; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escala do modelo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Come√ßaremos mudando a escala do inimigo. </font><font style="vertical-align: inherit;">Adicione </font></font><code>EnemyFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as configura√ß√µes de escala </font><font style="vertical-align: inherit;">√† </font><font style="vertical-align: inherit;">op√ß√£o. </font><font style="vertical-align: inherit;">O intervalo de escala n√£o deve ser muito grande, mas suficiente para criar variedades em miniatura e gigantescas de inimigos. </font><font style="vertical-align: inherit;">Qualquer coisa dentro de 0,5‚Äì2 com um valor padr√£o de 1. Vamos escolher uma escala aleat√≥ria nesse intervalo </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e pass√°-la ao inimigo atrav√©s de um novo m√©todo </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, FloatRangeSlider(0.5f, 2f)</span></span>] FloatRange scale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy instance = CreateGameObjectInstance(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; instance.Initialize(scale.RandomValueInRange); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O m√©todo </font></font><code>Enemy.Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplesmente define a escala do modelo que √© a mesma em todas as dimens√µes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale</span></span></span><span class="hljs-function">)</span></span> { model.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(scale, scale, scale); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a7/cc3/f08/1a7cc3f082406d5c8672125ceb94913c.png" width="320" height="60" alt="inspetor"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/396/7cf/ffe3967cfcfb6391269a5a7691317c60.png" width="230" height="230" alt="cena"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O intervalo de escalas √© de 0,5 a 1,5.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Deslocamento do caminho </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para destruir ainda mais a uniformidade do fluxo de inimigos, podemos mudar sua posi√ß√£o relativa dentro dos ladrilhos. Eles avan√ßam, ent√£o a mudan√ßa nessa dire√ß√£o altera apenas o tempo de seus movimentos, o que n√£o √© muito percept√≠vel. Portanto, vamos desloc√°-los para o lado, longe do caminho ideal que passa pelos centros dos ladrilhos. Adicione um </font></font><code>EnemyFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deslocamento de caminho </font><font style="vertical-align: inherit;">ao </font><font style="vertical-align: inherit;">intervalo e passe o deslocamento aleat√≥rio para o m√©todo </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. O deslocamento pode ser negativo ou positivo, mas nunca superior a ¬Ω, porque isso moveria o inimigo para um bloco vizinho. Al√©m disso, n√£o queremos que os inimigos ultrapassem os ladrilhos que seguem, portanto, o intervalo ser√° menor, por exemplo, 0,4, mas os verdadeiros limites dependem do tamanho do inimigo.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, FloatRangeSlider(-0.4f, 0.4f)</span></span>] FloatRange pathOffset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy instance = CreateGameObjectInstance(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; instance.Initialize( scale.RandomValueInRange, pathOffset.RandomValueInRange ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o deslocamento do caminho afeta o caminho percorrido, </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© necess√°rio rastre√°-lo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pathOffset; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { model.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(scale, scale, scale); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pathOffset = pathOffset; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao mover exatamente em linha reta (durante o movimento de introdu√ß√£o, final ou normal), simplesmente aplicamos o deslocamento diretamente no modelo. </font><font style="vertical-align: inherit;">A mesma coisa acontece quando voc√™ volta. </font><font style="vertical-align: inherit;">Com uma curva √† direita ou √† esquerda, j√° deslocamos o modelo, que se torna relativo ao deslocamento do caminho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareForward</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localRotation = direction.GetRotation(); directionAngleTo = direction.GetAngle(); model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset, <span class="hljs-number"><span class="hljs-number">0f</span></span>); progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom + direction.GetHalfVector(); progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom - <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset + <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom + direction.GetHalfVector(); progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">180f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom; progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareIntro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localRotation = direction.GetRotation(); progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareOutro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localRotation = direction.GetRotation(); progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o deslocamento do caminho durante a rota√ß√£o altera o raio, precisamos alterar o processo de c√°lculo do multiplicador de progresso. </font><font style="vertical-align: inherit;">O deslocamento do caminho deve ser subtra√≠do de ¬Ω para obter o raio da curva para a direita e adicionado no caso de uma curva para a esquerda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> - pathOffset)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> + pathOffset)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamb√©m obtemos o raio de viragem ao girar 180 ¬∞. Nesse caso, cobrimos metade do c√≠rculo com um raio igual ao deslocamento do caminho, portanto a dist√¢ncia √© œÄ vezes o deslocamento. No entanto, isso n√£o funciona quando o deslocamento √© zero e, em pequenos deslocamentos, as curvas s√£o muito r√°pidas. Para evitar curvas instant√¢neas, podemos for√ßar o raio m√≠nimo para calcular a velocidade, digamos 0,2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + (pathOffset &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? <span class="hljs-number"><span class="hljs-number">180f</span></span> : <span class="hljs-number"><span class="hljs-number">-180f</span></span>); model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom; progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * Mathf.Max(Mathf.Abs(pathOffset), <span class="hljs-number"><span class="hljs-number">0.2f</span></span>)); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1db/8b2/b16/1db8b2b164cba05ff6f8fe7ffa0eed71.png" width="320" height="40" alt="inspetor"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O deslocamento do caminho est√° no intervalo de -0,25 a 0,25.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Note que agora os inimigos nunca mudam seu deslocamento relativo, mesmo quando est√£o girando. Portanto, o comprimento total do caminho para cada inimigo tem o seu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para impedir que os inimigos cheguem a ladrilhos vizinhos, √© preciso tamb√©m levar em considera√ß√£o a escala m√°xima poss√≠vel. Limitei apenas o tamanho a um valor m√°ximo de 1; portanto, o deslocamento m√°ximo permitido para o cubo √© de 0,25. Se o tamanho m√°ximo fosse 1,5, o deslocamento m√°ximo dever√° ser reduzido para 0,125.</font></font><br><br><h3>  Velocidade </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A √∫ltima coisa que randomizamos √© a velocidade dos inimigos. </font><font style="vertical-align: inherit;">N√≥s adicionamos mais um intervalo para ele </font></font><code>EnemyFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e transferiremos valor para a c√≥pia criada do inimigo. </font><font style="vertical-align: inherit;">Vamos torn√°-lo o segundo argumento para o m√©todo </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Os inimigos n√£o devem ser muito lentos ou r√°pidos para que o jogo n√£o se torne trivialmente simples ou imposs√≠vel. </font><font style="vertical-align: inherit;">Vamos limitar o intervalo para 0,2-5. </font><font style="vertical-align: inherit;">A velocidade √© expressa em unidades por segundo, que corresponde a blocos por segundo apenas quando avan√ßar.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, FloatRangeSlider(0.2f, 5f)</span></span>] FloatRange speed = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">1f</span></span>); [SerializeField, FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">-0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>)] FloatRange pathOffset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy instance = CreateGameObjectInstance(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; instance.Initialize( scale.RandomValueInRange, speed.RandomValueInRange, pathOffset.RandomValueInRange ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora eu </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tenho que rastrear e acelerar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { model.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(scale, scale, scale); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.speed = speed; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pathOffset = pathOffset; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quando n√£o definimos a velocidade explicitamente, simplesmente sempre usamos o valor 1. Agora, apenas precisamos criar a depend√™ncia do multiplicador de progresso na velocidade. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareForward</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = speed; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = speed / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> - pathOffset)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = speed / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> + pathOffset)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = speed / (Mathf.PI * Mathf.Max(Mathf.Abs(pathOffset), <span class="hljs-number"><span class="hljs-number">0.2f</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareIntro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span> * speed; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareOutro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span> * speed; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b8/e55/eeb/0b8e55eeb25d36349f606f0da60d3720.png" width="320" height="60"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Velocidade na faixa de 0,75 a 1,25. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, temos um belo fluxo de inimigos se movendo para o ponto final. </font><font style="vertical-align: inherit;">No pr√≥ximo tutorial, aprenderemos como lidar com eles. </font><font style="vertical-align: inherit;">Quer saber quando ser√° lan√ßado? </font><font style="vertical-align: inherit;">Siga minha p√°gina no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">artigo em PDF do </font></a></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reposit√≥rio</font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt452756/">https://habr.com/ru/post/pt452756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt452746/index.html">O livro "A Arte da Programa√ß√£o em R. Imers√£o em Big Data"</a></li>
<li><a href="../pt452748/index.html">Princ√≠pios do desenvolvimento de aplicativos modernos da NGINX. Parte 1</a></li>
<li><a href="../pt452750/index.html">Nextcloud dentro e fora do OpenLiteSpeed: configurar proxy reverso</a></li>
<li><a href="../pt452752/index.html">BigData caseiro. Parte 1. Pr√°tica de Spark Streaming em um cluster da AWS</a></li>
<li><a href="../pt452754/index.html">19% das imagens mais populares do Docker n√£o possuem uma senha root</a></li>
<li><a href="../pt452760/index.html">Vitamina D. Beber ou n√£o beber, eis a quest√£o. (Ou uma hist√≥ria sobre como passei em uma an√°lise que n√£o foi prescrita)</a></li>
<li><a href="../pt452762/index.html">MVCC-7. Limpeza autom√°tica</a></li>
<li><a href="../pt452764/index.html">[Peter] Encontro do JUG.ru com Sergey Melnikov - Cria√ß√£o de perfil com velocidade superluminal: teoria e pr√°tica</a></li>
<li><a href="../pt452766/index.html">Tecnologia Progressive Streaming, ou como assistir a v√≠deos em 4K na rede, sem frisos</a></li>
<li><a href="../pt452768/index.html">Como projetar um produto se voc√™ decidir entrar no mercado externo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>