<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘® ğŸ˜™ ğŸ–•ğŸ½ Organisasi pengujian yang aman dalam produksi. Bagian 2 ğŸƒ ğŸ¦ ğŸ‘¨ğŸ¼â€ğŸ³</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada bagian artikel ini, kami akan terus mempertimbangkan berbagai jenis pengujian dalam produksi. Mereka yang melewatkan bagian pertama dapat membaca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Organisasi pengujian yang aman dalam produksi. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/418329/"><img src="https://habrastorage.org/webt/ht/ra/sh/htrashsucmi8c4a6nok7rihdoay.png"><br><br>  Pada bagian artikel ini, kami akan terus mempertimbangkan berbagai jenis pengujian dalam produksi.  Mereka yang melewatkan bagian pertama dapat membacanya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Untuk yang lainnya - selamat datang di kucing. <br><a name="habracut"></a><br><h2>  Pengujian Produksi: Rilis </h2><br>  Setelah menguji layanan setelah <i>penyebaran</i> , harus disiapkan untuk <i>rilis</i> . <br>  Penting untuk dicatat bahwa pada tahap ini kemunduran perubahan hanya mungkin terjadi dalam situasi kegagalan <i>berkelanjutan</i> , misalnya: <br><br><ul><li>  perulangan kegagalan layanan; </li><li>  melebihi waktu tunggu untuk sejumlah besar koneksi di hulu, menyebabkan peningkatan kuat dalam frekuensi kesalahan; </li><li>  perubahan konfigurasi yang tidak dapat diterima, misalnya, kurangnya kunci rahasia dalam variabel lingkungan yang menyebabkan kegagalan fungsi layanan (variabel lingkungan umumnya lebih baik untuk dihindari, tetapi ini adalah topik untuk diskusi lain). </li></ul><br>  Pengujian menyeluruh pada tahap <i>penempatan</i> memungkinkan saya untuk meminimalkan atau menghindari kejutan yang tidak menyenangkan pada tahap <i>rilis</i> .  Namun, ada sejumlah rekomendasi untuk melepaskan kode baru dengan aman. <br><br><h3>  Penempatan Canary </h3><br>  <i>Penempatan kenari</i> adalah <i>pelepasan</i> sebagian <i>dari</i> layanan dalam produksi.  Ketika pemeriksaan kesehatan dasar berlalu, bagian kecil dari lalu lintas lingkungan produksi saat ini dikirim ke bagian yang dirilis.  Hasil dari bagian-bagian layanan dipantau saat lalu lintas diproses, indikator dibandingkan dengan yang referensi (tidak terkait dengan yang kenari), dan jika mereka berada di luar nilai ambang batas yang dapat diterima, kemunduran ke keadaan sebelumnya dilakukan.  Meskipun pendekatan ini biasanya digunakan ketika merilis perangkat lunak server, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengujian kenari perangkat lunak klien</a> juga menjadi lebih umum. <br><br>  Berbagai faktor mempengaruhi lalu lintas apa yang akan digunakan untuk penyebaran kenari.  Di sejumlah perusahaan, bagian layanan yang dirilis pertama hanya menerima lalu lintas pengguna internal (disebut dogfooding).  Jika tidak ada kesalahan yang diamati, maka sebagian kecil dari lalu lintas lingkungan produksi ditambahkan, setelah itu penyebaran penuh dilakukan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Disarankan agar Anda</a> memutar kembali ke keadaan sebelumnya jika hasil penyebaran kenari tidak valid <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara otomatis</a> , dan alat-alat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spinnaker</a> memiliki dukungan bawaan untuk analisis otomatis dan fungsi rollback. <br><br>  Ada beberapa masalah dengan pengujian kenari, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://">artikel ini</a> memberikan gambaran yang cukup lengkap tentang mereka. <br><br><h3>  Pemantauan </h3><br>  Pemantauan adalah prosedur yang mutlak diperlukan pada <i>setiap</i> tahap penyebaran produk dalam produksi, tetapi fungsi ini akan sangat penting pada tahap <i>rilis</i> .  Pemantauan sangat cocok untuk mendapatkan informasi tentang tingkat umum kinerja sistem.  Tetapi memantau segala sesuatu di dunia mungkin bukan solusi terbaik.  Pemantauan yang <i>efektif</i> dilakukan secara searah, yang memungkinkan Anda untuk mengidentifikasi serangkaian kecil mode kegagalan berkelanjutan dari sistem atau serangkaian indikator dasar.  Contoh mode kegagalan tersebut dapat: <br><br><ul><li>  peningkatan tingkat kesalahan; </li><li>  penurunan kecepatan pemrosesan permintaan secara keseluruhan di seluruh layanan, pada titik akhir tertentu, atau, bahkan lebih buruk, penghentian total pekerjaan; </li><li>  peningkatan keterlambatan. </li></ul><br>  Pengamatan dari salah satu mode kegagalan berkelanjutan ini adalah dasar untuk rollback langsung ke keadaan sebelumnya atau rollback versi perangkat lunak baru yang <i>dirilis</i> .  Penting untuk diingat bahwa pemantauan pada tahap ini tidak mungkin lengkap dan indikatif.  Banyak yang percaya bahwa jumlah sinyal ideal yang dipantau selama pemantauan adalah dari 3 hingga 5, tetapi <i>jelas</i> tidak lebih dari 7-10.  Buku putih Facebook Kraken menawarkan solusi berikut: <br><br>  <i>"Masalahnya diselesaikan dengan bantuan komponen pemantauan yang mudah dikonfigurasi, yang melaporkan dua indikator dasar (persentil ke-99 dari waktu respons server web dan frekuensi terjadinya kesalahan HTTP fatal) yang secara objektif menggambarkan kualitas interaksi pengguna."</i> <br><br>  Rangkaian indikator sistem dan aplikasi yang dipantau selama fase rilis paling baik ditentukan selama desain sistem. <br><br><h3>  Pelacakan pengecualian </h3><br>  Kita berbicara tentang melacak pengecualian pada tahap rilis, meskipun mungkin terlihat bahwa pada tahap <i>penyebaran</i> dan setelah rilis ini tidak akan terlalu berguna.  Alat pelacak pengecualian seringkali tidak menjamin ketelitian, keakuratan, dan jangkauan massa yang sama dengan beberapa alat pemantauan sistem lainnya, tetapi mereka masih bisa sangat berguna. <br><br>  Alat open source (seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sentry</a> ) menampilkan informasi lanjutan tentang permintaan yang masuk dan membuat tumpukan data jejak dan variabel lokal, yang sangat menyederhanakan proses debugging, yang biasanya terdiri dari melihat log peristiwa.  Pelacakan pengecualian juga berguna ketika menyortir dan memprioritaskan masalah yang tidak memerlukan rollback penuh ke keadaan sebelumnya (misalnya, kasus garis batas yang melempar pengecualian). <br><br><h3>  Pembentukan lalu lintas </h3><br>  Membentuk traffic (traffic redistribution) bukanlah bentuk pengujian independen sebagai alat untuk mendukung pendekatan kenari dan rilis bertahap kode baru.  Bahkan, pembentukan traffic dipastikan dengan memperbarui konfigurasi load balancer, yang memungkinkan Anda untuk secara bertahap mengarahkan lebih banyak lalu lintas ke versi yang baru <i>dirilis</i> . <br><br>  Metode ini juga berguna untuk penyebaran bertahap perangkat lunak baru (terpisah dari penyebaran reguler).  Pertimbangkan sebuah contoh.  Imgix perlu menggunakan arsitektur infrastruktur baru yang fundamental pada Juni 2016.  Setelah pengujian pertama infrastruktur baru dengan sejumlah lalu lintas gelap, mereka mulai mengerahkan produksi, awalnya mengarahkan sekitar 1% lalu lintas lingkungan produksi ke tumpukan baru.  Kemudian, selama beberapa minggu, volume data yang tiba di tumpukan baru meningkat (menyelesaikan masalah di sepanjang jalan), hingga mulai memproses 100% dari lalu lintas. <br><br>  Popularitas arsitektur mesh layanan telah memicu lonjakan baru dalam minat pada server proxy.  Akibatnya, proksi lama (nginx, HAProxy) dan yang baru (Utusan, Conduit) menambahkan dukungan untuk fungsi-fungsi baru dalam upaya untuk menyalip pesaing.  Tampak bagi saya bahwa masa depan, di mana redistribusi lalu lintas dari 0 hingga 100% pada tahap rilis produk dilakukan secara otomatis, sudah dekat. <br><br><h2>  Pengujian Produksi: Setelah Rilis </h2><br>  Pengujian pasca rilis dilakukan sebagai pemeriksaan yang dilakukan <i>setelah</i> <i>pelepasan</i> kode yang berhasil.  Pada tahap ini, Anda dapat yakin bahwa kode secara keseluruhan sudah benar, telah berhasil <i>dirilis</i> dalam produksi dan memproses lalu lintas dengan benar.  Kode yang digunakan secara langsung atau tidak langsung digunakan dalam kondisi nyata, melayani pelanggan nyata atau melakukan tugas yang memiliki dampak signifikan pada bisnis. <br><br>  Tujuan dari setiap pengujian pada tahap ini adalah untuk memverifikasi operabilitas sistem, dengan mempertimbangkan berbagai kemungkinan beban dan pola lalu lintas.  Cara terbaik untuk melakukan ini adalah mengumpulkan bukti dokumenter tentang segala sesuatu yang terjadi dalam produksi dan menggunakannya baik untuk debugging dan untuk mendapatkan gambaran lengkap dari sistem. <br><br><h3>  Penandaan Fitur, atau Peluncuran Gelap </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://">Publikasi tertua</a> tentang keberhasilan penggunaan flag fitur yang saya temukan diterbitkan hampir sepuluh tahun yang lalu.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Featureflags.io</a> menyediakan panduan paling komprehensif untuk ini. <br><br>  <i>â€œFitur penandaan adalah metode yang digunakan oleh pengembang untuk menandai fungsi baru menggunakan pernyataan if-then, yang memungkinkan lebih banyak kontrol atas rilisnya.</i>  <i>Dengan menandai suatu fungsi dan mengisolasinya dengan cara ini, pengembang mendapatkan kemampuan untuk menghidupkan dan mematikan fungsi ini terlepas dari status penyebaran.</i>  <i>Ini secara efektif memisahkan pelepasan fungsi dari penyebaran kode. "</i> <br><br>  Dengan menandai kode baru, Anda dapat menguji kinerjanya dan kinerjanya dalam produksi sesuai kebutuhan.  Penandaan fitur adalah salah satu jenis pengujian yang diterima secara umum dalam produksi, telah dikenal luas dan sering <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dijelaskan</a> dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbagai sumber</a> .  Fakta bahwa metode ini dapat digunakan dalam proses pengujian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">transfer database</a> atau perangkat lunak untuk sistem pribadi jauh kurang dikenal. <br><br>  Apa yang jarang ditulis oleh penulis artikel adalah metode terbaik untuk mengembangkan dan menggunakan flag fungsi.  Penggunaan flag yang tidak terkontrol bisa menjadi masalah serius.  Kurangnya disiplin dalam hal menghapus bendera yang tidak digunakan setelah jangka waktu tertentu kadang-kadang mengarah pada fakta bahwa Anda harus melakukan audit penuh dan menghapus bendera usang yang diakumulasikan selama berbulan-bulan (jika tidak lebih dari tahun) pekerjaan. <br><br><h3>  Pengujian A / B </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengujian A / B</a> sering dilakukan sebagai bagian dari analisis eksperimental dan tidak dianggap sebagai pengujian dalam produksi.  Untuk alasan ini, tes A / B tidak hanya digunakan secara luas (kadang-kadang bahkan dengan cara yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">meragukan</a> ), tetapi juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://">dipelajari</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dijelaskan</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara aktif</a> (termasuk artikel tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apa yang menentukan kartu skor yang efektif</a> untuk eksperimen online).  Jauh lebih jarang, tes A / B digunakan untuk menguji berbagai konfigurasi perangkat keras atau mesin virtual.  Mereka sering disebut "tuning" (misalnya, tuning JVM), tetapi mereka tidak diklasifikasikan sebagai tes A / B khas (meskipun tuning dapat dianggap sebagai jenis tes A / B dilakukan dengan tingkat kekakuan yang sama ketika datang ke pengukuran) . <br><br><h3>  Log, acara, indikator, dan penelusuran </h3><br>  Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat membaca</a> tentang apa yang disebut "tiga paus yang dapat diamati" - log, indikator, dan penelusuran yang didistribusikan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h3>  Pembuatan profil </h3><br>  Dalam beberapa kasus, untuk mendiagnosis masalah kinerja, perlu menggunakan profil aplikasi dalam produksi.  Bergantung pada bahasa dan runtime yang didukung, pembuatan profil dapat menjadi prosedur yang cukup sederhana, yang melibatkan penambahan hanya satu baris kode ke aplikasi ( <code>import _ "net/http/pprof"</code> untuk Go).  Di sisi lain, mungkin memerlukan penggunaan banyak alat atau menguji proses dengan metode kotak hitam dan memeriksa hasilnya menggunakan alat-alat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">flamegraphs</a> . <br><br><h3>  Tes tee </h3><br>  Banyak orang menganggap pengujian semacam itu seperti duplikasi bayangan data, karena dalam kedua kasus lalu lintas lingkungan produksi dikirim ke cluster atau proses non-produksi.  Menurut pendapat saya, perbedaannya adalah bahwa penggunaan lalu lintas untuk tujuan <i>pengujian</i> agak berbeda dari penggunaannya untuk tujuan <i>debugging</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://">Etsy menulis di blognya</a> tentang menggunakan tes tee sebagai alat verifikasi (contoh ini benar-benar menyerupai duplikasi bayangan data). <br>  <i>â€œDi sini <b>tee</b> dapat dipahami sebagai perintah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tee</a> di baris perintah.</i>  <i>Kami menulis aturan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://devcentral.f5.com/articles/">iRule</a> berdasarkan penyeimbang beban F5 yang ada untuk mengkloning lalu lintas HTTP yang diarahkan ke salah satu kumpulan dan mengarahkannya ke kumpulan lain.</i>  <i>Dengan demikian, kami dapat menggunakan lalu lintas lingkungan produksi yang diarahkan ke cluster API kami dan mengirimkan salinannya ke cluster HHVM eksperimental, serta ke cluster PHP yang terisolasi untuk perbandingan.</i> <i><br></i>  <i>Teknik ini telah terbukti sangat efektif.</i>  <i>Dia mengizinkan kami untuk membandingkan kinerja kedua konfigurasi menggunakan profil lalu lintas yang identik. "</i> <br><br>  Namun, kadang-kadang tes tee berdasarkan lalu lintas lingkungan produksi dalam sistem otonom diperlukan untuk <i>debugging</i> .  Dalam kasus seperti itu, sistem otonom dapat diubah untuk mengkonfigurasi output informasi diagnostik tambahan atau prosedur kompilasi lainnya (misalnya, menggunakan alat pembersih aliran), yang sangat menyederhanakan proses pemecahan masalah.  Dalam kasus seperti itu, tee-test harus dipertimbangkan, bukan, <i>alat debugging</i> , daripada <i>verifikasi</i> . <br><br>  Sebelumnya, jenis debugging seperti itu relatif jarang di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IMGIX</a> , tetapi mereka masih digunakan, terutama ketika datang ke masalah dengan aplikasi debugging yang sensitif terhadap penundaan. <br><br>  Sebagai contoh, berikut ini adalah deskripsi analitis dari salah satu insiden yang terjadi pada tahun 2015.  Kesalahan 400 terjadi sangat jarang sehingga hampir tidak terlihat ketika mencoba mereproduksi masalah.  Dia muncul hanya dalam beberapa kasus dari satu miliar.  Ada sangat sedikit dari mereka di siang hari.  Akibatnya, ternyata tidak mungkin mereproduksi masalah dengan andal, sehingga perlu melakukan debugging menggunakan lalu lintas kerja agar memiliki kesempatan untuk melacak terjadinya kesalahan ini.  Inilah yang ditulis mantan kolega saya tentang ini: <br><br>  <i>â€œSaya memilih perpustakaan yang seharusnya internal, tetapi pada akhirnya saya harus membuat perpustakaan sendiri berdasarkan perpustakaan yang disediakan oleh sistem.</i>  <i>Dalam versi yang disediakan oleh sistem, terjadi kesalahan secara berkala yang tidak muncul dengan cara apa pun saat jumlah lalu lintas kecil.</i>  <i>Namun, nama terpotong dalam judul adalah masalah sebenarnya.</i> <i><br><br></i>  <i>Selama dua hari berikutnya, saya mempelajari secara detail masalah yang terkait dengan peningkatan frekuensi kesalahan palsu 400. Kesalahan itu terwujud dalam sejumlah kecil permintaan, dan masalah jenis ini sulit didiagnosis.</i>  <i>Semua ini tampak seperti jarum terkenal di tumpukan jerami: masalahnya ditemukan dalam satu kasus per miliar.</i> <i><br><br></i>  <i>Langkah pertama dalam menemukan sumber kesalahan adalah untuk mendapatkan semua data permintaan HTTP mentah yang menghasilkan respons yang salah.</i>  <i>Untuk melakukan uji coba trafik masuk ketika terhubung ke soket, saya menambahkan titik akhir soket domain Unix ke server render.</i>  <i>Idenya adalah untuk memungkinkan kita dengan cepat dan mudah menghidupkan dan mematikan arus lalu lintas yang gelap dan melakukan pengujian langsung di komputer pengembang.</i>  <i>Untuk menghindari masalah dalam produksi, perlu memutuskan koneksi jika ada masalah tekanan balik.</i>  <i>Yaitu</i>  <i>jika duplikat tidak dapat mengatasi tugas, itu terputus.</i>  <i>Soket ini sangat berguna dalam beberapa kasus selama pengembangan.</i>  <i>Namun, kali ini, kami menggunakannya untuk mengumpulkan lalu lintas masuk pada server yang dipilih, berharap mendapatkan cukup permintaan untuk mengidentifikasi pola yang menyebabkan munculnya kesalahan palsu 400. Menggunakan dsh dan netcat, saya dapat relatif mudah menghasilkan lalu lintas yang masuk ke file lokal .</i> <i><br><br></i>  <i>Sebagian besar lingkungan dihabiskan untuk mengumpulkan data ini.</i>  <i>Segera setelah kami memiliki cukup data, saya dapat menggunakan netcat untuk memutarnya di sistem lokal, konfigurasi yang diubah untuk menampilkan sejumlah besar informasi debug.</i>  <i>Dan semuanya berjalan dengan sempurna.</i>  <i>Langkah selanjutnya adalah memutar data dengan kecepatan setinggi mungkin.</i>  <i>Dalam kasus ini, loop dengan cek kondisi mengirim permintaan mentah satu per satu.</i>  <i>Setelah sekitar dua jam, saya berhasil mencapai hasil yang diinginkan.</i>  <i>Data dalam log menunjukkan kurangnya tajuk!</i> <i><br><br></i>  <i>Saya menggunakan kayu merah-hitam untuk menyampaikan header.</i>  <i>Struktur semacam itu mempertimbangkan komparabilitas sebagai identitas, yang dengan sendirinya sangat berguna ketika ada persyaratan khusus untuk kunci: dalam kasus kami, header HTTP tidak peka terhadap huruf besar-kecil.</i>  <i>Pada awalnya kami berpikir bahwa masalahnya ada pada simpul daun dari perpustakaan yang digunakan.</i>  <i>Urutan penambahan benar-benar memengaruhi urutan konstruksi pohon dasar, dan menyeimbangkan pohon merah-hitam adalah proses yang agak rumit.</i>  <i>Dan meskipun situasi ini tidak mungkin, itu bukan tidak mungkin.</i>  <i>Saya beralih ke implementasi ebony merah lainnya.</i>  <i>Itu diperbaiki beberapa tahun yang lalu, jadi saya memutuskan untuk menanamkannya langsung di sumber untuk mendapatkan versi yang dibutuhkan.</i>  <i>Namun demikian, majelis memilih versi yang berbeda, dan karena saya mengandalkan versi yang lebih baru, pada akhirnya saya mendapatkan perilaku yang salah.</i> <i><br><br></i>  <i>Karena itu, sistem visualisasi menghasilkan 500 kesalahan, yang menyebabkan gangguan siklus.</i>  <i>Inilah sebabnya mengapa kesalahan hanya terjadi seiring waktu.</i>  <i>Setelah pemrosesan siklis dari beberapa majelis, lalu lintas dari mereka dialihkan ke rute yang berbeda, yang meningkatkan skala masalah pada server ini.</i>  <i>Asumsi saya bahwa masalahnya ada di perpustakaan ternyata salah, dan saklar balik menyelesaikan 500 kesalahan.</i> <i><br><br></i>  <i>Saya kembali ke 400 kesalahan: masih ada masalah dengan kesalahan, yang membutuhkan waktu sekitar dua jam untuk mendeteksi.</i>  <i>Mengubah perpustakaan, jelas, tidak menyelesaikan masalah, tetapi saya yakin bahwa perpustakaan yang dipilih cukup andal.</i>  <i>Tidak menyadari kekeliruan pilihan, saya tidak mengubah apa pun.</i>  <i>Setelah mempelajari situasinya secara lebih rinci, saya menyadari bahwa nilai yang benar disimpan dalam header karakter tunggal (misalnya, "h: 12345").</i>  <i>Akhirnya saya sadar bahwa h adalah karakter tambahan dari header Content-Length.</i>  <i>Melihat data lagi, saya menyadari bahwa header Panjang Konten kosong.</i> <i><br><br></i>  <i>Akibatnya, semuanya menjadi kesalahan bias ketika membaca header.</i>  <i>Penganalisa HTTP nginx / joyent membuat data parsial, dan setiap kali bidang header parsial satu karakter lebih pendek dari yang diperlukan, saya mengirim header tanpa nilai dan kemudian menerima bidang header satu karakter yang berisi nilai yang benar.</i>  <i>Ini adalah kombinasi yang agak jarang, sehingga operasinya membutuhkan waktu yang lama.</i>  <i>Jadi saya meningkatkan jumlah pengumpulan data setiap kali header satu karakter muncul, menerapkan perbaikan yang diusulkan dan berhasil menjalankan skrip selama beberapa jam.</i> <i><br></i>  <i>Tentu saja, beberapa jebakan lain dengan kerusakan perpustakaan yang disebutkan bisa dideteksi, tetapi kedua kesalahan itu diperbaiki. â€</i> <i><br></i> <br><br>  Insinyur yang terlibat dalam pengembangan aplikasi yang sensitif terhadap penundaan memerlukan kemampuan untuk debug menggunakan lalu lintas dinamis yang ditangkap, karena sering terjadi kesalahan yang tidak dapat direproduksi selama pengujian unit atau terdeteksi menggunakan alat pemantauan (terutama jika ada penundaan serius dalam logging). <br><br><h3>  Pendekatan Rekayasa Kekacauan </h3><br>  <i>Chaos Engineering adalah pendekatan yang didasarkan pada eksperimen pada sistem terdistribusi untuk mengkonfirmasi kemampuannya dalam menahan kondisi kacau lingkungan produksi.</i> <br><br>  Metode Chaos Engineering, pertama kali dipopulerkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chaos Monkey</a> dari Netflix, kini telah menjadi disiplin yang independen.  Istilah Chaos Engineering muncul baru-baru ini, tetapi pengujian kesalahan adalah praktik lama. <br><br>  Istilah "pengujian kacau" mengacu pada teknik berikut: <br><br><ul><li>  nonaktifkan node sembarang untuk menentukan seberapa tahan sistem terhadap kegagalan; </li><li>  memperkenalkan kesalahan (misalnya, meningkatkan penundaan) untuk mengkonfirmasi bahwa sistem memprosesnya dengan benar; </li><li>  pelanggaran paksa jaringan untuk menentukan respons layanan. </li></ul><br>  Sebagian besar perusahaan menggunakan lingkungan operasi yang tidak cukup kompleks dan berjenjang untuk secara efektif melakukan pengujian kacau.  Penting untuk menekankan bahwa pengenalan kesalahan dalam sistem sebaiknya dilakukan setelah menetapkan fungsi dasar toleransi kesalahan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Buku putih</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GREMLIN</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> memberikan deskripsi yang cukup komprehensif tentang prinsip-prinsip pengujian kacau, serta instruksi untuk mempersiapkan prosedur ini. <br><br>  <i>â€œYang terpenting adalah fakta bahwa Chaos Engineering dianggap sebagai disiplin ilmu.</i>  <i>Dalam disiplin ini, proses rekayasa presisi tinggi diterapkan.</i> <i><br></i>  <i>Tugas Chaos Engineering adalah <b>memberi tahu</b> pengguna sesuatu yang baru tentang kerentanan sistem dengan melakukan eksperimen di atasnya.</i>  <i>Penting untuk mengidentifikasi semua masalah tersembunyi yang dapat muncul dalam produksi, bahkan sebelum mereka menyebabkan kegagalan besar.</i>  <i>Hanya setelah itu Anda dapat secara efektif menghilangkan semua kelemahan dalam sistem dan membuatnya benar-benar toleran terhadap kesalahan. "</i> <br><br><h2>  Kesimpulan </h2><br>  Tujuan pengujian dalam produksi bukan untuk sepenuhnya <i>menghilangkan</i> semua kemungkinan kegagalan dalam sistem.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">John Allspaw</a> mengatakan: <br>  <i>â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kami melihat bahwa</a> sistem menjadi lebih toleran terhadap kesalahan - dan itu hebat.</i>  <i>Tetapi kita harus mengakui: "semakin banyak" tidak sama dengan "mutlak."</i>  <i>Dalam sistem kompleks apa pun, kegagalan dapat terjadi (dan akan terjadi) dengan cara yang paling tidak terduga. "</i> <i><br></i> <br>  Pengujian dalam produksi pada pandangan pertama mungkin tampak seperti tugas yang agak rumit, jauh melampaui kompetensi sebagian besar perusahaan teknik.  Dan meskipun pengujian seperti itu <i>bukanlah</i> tugas yang <i>mudah</i> , terkait dengan beberapa risiko, jika Anda mengikutinya dengan semua aturan, itu akan membantu untuk mencapai keandalan sistem terdistribusi kompleks yang ditemukan di mana-mana saat ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418329/">https://habr.com/ru/post/id418329/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418317/index.html">2048 dilarang. Bukan RosKomNadzor</a></li>
<li><a href="../id418319/index.html">Lampu LED Gauss 2017-2018</a></li>
<li><a href="../id418321/index.html">Photon random number generator: enkripsi paling andal?</a></li>
<li><a href="../id418323/index.html">Sedikit tentang atribut host, keyboard, kode, dan SCS dalam seri "World of the Wild West" (Westworld)</a></li>
<li><a href="../id418327/index.html">Pembuat sepatu dengan sepatu bot: yang dipilih oleh para ahli smartphone untuk mereka sendiri</a></li>
<li><a href="../id418331/index.html">Master server dan jaringan - selamat berlibur</a></li>
<li><a href="../id418333/index.html">Robot Uber kembali ke jalan, tetapi orang-orang akan mengendarainya</a></li>
<li><a href="../id418335/index.html">Konfrontasi di Positive Hack Days 8: parsing rantai serangan</a></li>
<li><a href="../id418337/index.html">Panas, Musim Panas DataGrip 2018.2</a></li>
<li><a href="../id418339/index.html">Manipulasi "manual"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>