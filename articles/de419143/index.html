<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíáüèø üö∑ üêä Erstellen eines Emulator-Arcade-Automaten. Teil 4 üõåüèø üîè üïç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teile des ersten , zweiten , dritten . 

 Der Rest der Maschine 
 Der Code, den wir f√ºr die Emulation des 8080-Prozessors geschrieben haben, ist recht...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen eines Emulator-Arcade-Automaten. Teil 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419143/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6eb/735/b99/6eb735b9990860a94f9ef0a18ba46a82.jpg" alt="Bild"></div><br>  Teile des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiten</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dritten</a> . <br><br><h2>  Der Rest der Maschine </h2><br>  Der Code, den wir f√ºr die Emulation des 8080-Prozessors geschrieben haben, ist recht allgemein gehalten und kann problemlos an jeden Computer mit dem C-Compiler angepasst werden. Um das Spiel selbst zu spielen, m√ºssen wir jedoch mehr tun.  Wir m√ºssen die Ausr√ºstung des gesamten Arcade-Automaten emulieren und Code schreiben, der die spezifischen Funktionen unserer Computerumgebung auf den Emulator klebt. <br><br>  (M√∂glicherweise m√∂chten Sie sich den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schaltplan der</a> Maschine ansehen.) <br><a name="habracut"></a><br><h2>  Timings </h2><br>  Das Spiel l√§uft auf dem 2 MHz 8080. Ihr Computer ist viel schneller.  Um dies zu ber√ºcksichtigen, m√ºssen wir uns einen Mechanismus ausdenken. <br><br><h2>  Unterbrechungen </h2><br>  Interrupts sind so konzipiert, dass der Prozessor Aufgaben mit pr√§zisen Ausf√ºhrungszeiten wie E / A verarbeiten kann.  Der Prozessor kann das Programm ausf√ºhren, und wenn der Interrupt-Pin ausgel√∂st wird, beendet er die Ausf√ºhrung des aktuellen Programms und f√ºhrt etwas anderes aus. <br><br>  Wir m√ºssen simulieren, wie ein Arcade-Automat Interrupts erzeugt. <br><br><h2>  Grafik </h2><br>  Space Invaders zeichnet Grafiken im Adressbereich 0x2400 in seinen Speicher.  Ein echter Hardware-Videocontroller w√ºrde RAM lesen und eine CRT-Anzeige steuern.  Unser Programm muss dieses Verhalten emulieren, indem es ein Bild des Spiels in einem Fenster rendert. <br><br><h2>  Kn√∂pfe </h2><br>  Das Spiel verf√ºgt √ºber physische Tasten, die das Programm mit dem IN-Befehl des 8080-Prozessors liest. Unser Emulator muss die Tastatureingabe an diese IN-Befehle binden. <br><br><h2>  ROM und RAM </h2><br>  Ich muss zugeben: Wir ‚Äûschneiden die Ecke ab‚Äú, indem wir einen 16-Kilobyte-Speicherpuffer erstellen, der die unteren 16 KB der Prozessorspeicherzuordnung enth√§lt.  Tats√§chlich sind die ersten 2 KB der Speicherzuweisung ein echter Nur-Lese-Speicher (ROM).  Wir m√ºssen Schreiboperationen im Speicher in eine Funktion einf√ºgen, damit es nicht m√∂glich ist, in ein ROM zu schreiben. <br><br><h2>  Ton </h2><br>  Bisher haben wir nichts √ºber Klang gesagt.  Space Invaders verf√ºgt √ºber ein niedliches analoges Soundschema, das einen von 8 Sounds wiedergibt, die vom OUT-Befehl gesteuert werden und an einen der Ports √ºbertragen werden.  Wir m√ºssen diese OUT-Befehle konvertieren, um Soundbeispiele auf unserer Plattform abzuspielen. <br><br>  Es mag wie viel Arbeit erscheinen, aber es ist nicht so schlimm und wir k√∂nnen uns schrittweise bewegen.  Als erstes m√∂chten wir den Bildschirm sehen, f√ºr den wir Interrupts, Grafiken und einen Teil der Verarbeitung der IN- und OUT-Befehle ben√∂tigen. <br><br><h2>  Zeigt und aktualisiert </h2><br><h3>  Die Grundlagen </h3><br>  Sie sind wahrscheinlich mit den Komponenten eines Videoanzeigesystems vertraut.  Irgendwo im System befindet sich eine Art RAM, der ein Bild zur Anzeige auf dem Bildschirm enth√§lt.  Bei analogen Ger√§ten gibt es Ger√§te, die diesen RAM lesen und die Bytes in analoge Spannung umwandeln, die an den Monitor √ºbertragen wird. <br><br>  Ein tieferes Verst√§ndnis des Systems hilft uns bei der Analyse des Zwecks der Speicherzuweisung und der Codefunktionalit√§t. <br><br>  Analoge Anzeigen stellen Anforderungen an Bildwiederholraten und Timings.  Zu jedem Zeitpunkt verf√ºgt die Anzeige √ºber ein aktualisiertes spezifisches Pixel.  Das auf den Bildschirm √ºbertragene Bild wird Punkt f√ºr Punkt ausgef√ºllt, beginnend von der oberen linken Ecke und oben rechts, dann vom ersten Punkt der zweiten Zeile, vom letzten Punkt der zweiten Zeile usw.  Nachdem die letzte Linie auf dem Bildschirm gezeichnet wurde, kann der Videocontroller einen vertikalen Leerzeichen-Interrupt (auch als VBI oder VBL bezeichnet) erzeugen. <br><br>  Um eine reibungslose Animation zu gew√§hrleisten, kann das vom Videocontroller verarbeitete Bild im RAM nicht ge√§ndert werden.  Wenn die RAM-Aktualisierung in der Mitte des Frames erfolgt ist, sieht der Betrachter Teile von zwei Bildern.  Dies f√ºhrt zu einem "Riss" -Effekt, wenn ein Bild, das sich vom unteren Bild unterscheidet, oben auf dem Bildschirm angezeigt wird.  Wenn Sie jemals einen Zeilenumbruch gesehen haben, wissen Sie, wie er aussieht. <br><br>  Um L√ºcken zu vermeiden, muss die Software etwas tun, um zu vermeiden, dass der Speicherort der Bildschirmaktualisierung √ºbertragen wird.  Und daf√ºr gibt es nur einen Weg. <br><br>  VBL wird nach dem Ende der letzten Zeile generiert. In der Regel dauert es eine gewisse Zeit, bis die erste Zeile erneut gezeichnet wird.  (Dies ist die vertikale Leerzeit und kann etwa 1 Millisekunde betragen.) <br><br>  Wenn VBL empfangen wird, beginnt das Programm, den Bildschirm von oben zu rendern. <br><br>  Jede Linie wird vor dem Frame-Scan-Umkehrvorgang gezeichnet. <br><br>  Die CPU ist dem Return Hot immer voraus und vermeidet daher Zeilenumbr√ºche. <br><br><div style="text-align:center;"><img src="http://www.emulator101.com/images/verticalretrace.jpg" alt="Bild"></div><br><h2>  Space Invaders Videosystem </h2><br>  Eine sehr informative <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Seite</a> sagt uns, dass Space Invaders zwei Video-Interrupts haben.  Eine ist f√ºr das Ende des Frames, erzeugt aber auch einen Interrupt in der Mitte des Bildschirms.  Die Seite beschreibt das Bildschirmaktualisierungssystem - das Spiel zeichnet Grafiken in der oberen H√§lfte des Bildschirms, wenn es eine Unterbrechung in der Mitte des Bildschirms erh√§lt, und Grafiken im unteren Teil des Bildschirms, wenn es eine Unterbrechung am Ende des Rahmens empf√§ngt.  Dies ist eine ziemlich clevere Methode, um Zeilenumbr√ºche zu vermeiden, und ein gutes Beispiel daf√ºr, was erreicht werden kann, wenn Sie gleichzeitig Hardware und Software entwickeln. <br><br>  Wir m√ºssen die Emulation unserer Maschine erzwingen, um solche Interrupts zu erzeugen.  Wenn wir sie mit einer Frequenz von 60 Hz sowie die Space Invaders-Maschine erzeugen, wird das Spiel mit der richtigen Frequenz gezeichnet. <br><br>  Im n√§chsten Abschnitt werden wir √ºber die Mechanik von Interrupts sprechen und dar√ºber nachdenken, wie sie emuliert werden k√∂nnen. <br><br><h2>  Tasten und Anschl√ºsse </h2><br>  Der 8080 implementiert E / A mithilfe der Anweisungen IN und OUT.  Es hat 8 separate IN- und OUT-Ports - der Port wird durch das Datenbyte des Befehls bestimmt.  Zum Beispiel setzt <code>IN 3</code> den Wert von Port 3 in Register A und <code>OUT 2</code> sendet A an Port 2. <br><br>  Ich habe Informationen zum Zweck jedes Ports von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Computer Archaeology-</a> Website abgerufen.  Wenn diese Informationen nicht verf√ºgbar w√§ren, m√ºssten wir sie durch Studieren des Schaltplans sowie durch Lesen und schrittweise Codeausf√ºhrung erhalten. <br><br> <code>: <br>  1 <br>  0  (0,  ) <br> 1  Start   <br> 2  Start   <br> 3 ? <br> 4     <br> 5     <br> 6     <br> 7 ? <br> <br>  2 <br>  0,1 DIP-   (0:3,1:4,2:5,3:6) <br> 2 ""  <br> 3 DIP-  , 1:1000,0:1500 <br> 4     <br> 5     <br> 6     <br> 7    DIP-, 1:,0: <br> <br>  3    <br> <br>  2     ( 0,1,2) <br>  3    <br>  4    <br>  5    <br>  6  "" ? ,     , <br>       (0=a,1=b,2=c  ..) <br> <br> (  3,5,6      1=$01  2=$00 <br>    ,       (attract mode))</code> <br> <br>  Es gibt drei M√∂glichkeiten, E / A in unserem Software-Stack zu implementieren (der aus einem 8080-Emulator, Maschinencode und Plattformcode besteht). <br><br><ol><li>  Betten Sie Maschinenwissen in unseren 8080-Emulator ein </li><li>  Betten Sie das 8080-Emulatorwissen in den Maschinencode ein </li><li>  Erfinden Sie eine formale Schnittstelle zwischen den drei Teilen des Codes, um den Informationsaustausch √ºber die API zu erm√∂glichen </li></ol><br>  Ich habe die erste Option ausgeschlossen - es ist ziemlich offensichtlich, dass sich der Emulator ganz unten in dieser Aufrufkette befindet und getrennt bleiben sollte.  (Stellen Sie sich vor, Sie m√ºssen den Emulator f√ºr ein anderes Spiel wiederverwenden, und Sie werden verstehen, was ich meine.) Im Allgemeinen ist das √úbertragen von Datenstrukturen auf hoher Ebene auf niedrigere Ebenen eine schlechte architektonische L√∂sung. <br><br>  Ich habe Option 2 gew√§hlt. Lassen Sie mich zuerst den Code anzeigen: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!done) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> opcode = state-&gt;memory[state-&gt;pc]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*opcode == <span class="hljs-number"><span class="hljs-number">0xdb</span></span>) <span class="hljs-comment"><span class="hljs-comment">//machine specific handling for IN { uint8_t port = opcode[1]; state-&gt;a = MachineIN(state, port); state-&gt;pc++; } else if (*opcode == 0xd3) //OUT { uint8_t port = opcode[1]; MachineOUT(state, port); state-&gt;pc++; } else Emulate8080Op(state); }</span></span></code> </pre> <br>  Dieser Code implementiert die Verarbeitung von Opcodes f√ºr IN und OUT in derselben Schicht erneut, wodurch der Emulator f√ºr den Rest der Befehle aufgerufen wird.  Meiner Meinung nach macht dies den Code sauberer.  Dies √§hnelt einer √úberschreibung oder Unterklasse f√ºr die beiden Befehle, die sich auf eine Automatenebene bezieht. <br><br>  Der Nachteil ist, dass wir die Emulation von Opcodes an zwei Stellen √ºbertragen.  Ich werde Sie nicht beschuldigen, die dritte Option gew√§hlt zu haben.  Bei der zweiten Option ist weniger Code erforderlich, aber Option 3 ist ‚Äûsauberer‚Äú, aber der Preis erh√∂ht die Komplexit√§t.  Dies ist eine Frage der Stilwahl. <br><br><h2>  Schieberegister </h2><br>  Die Space Invaders-Maschine verf√ºgt √ºber eine interessante Hardwarel√∂sung, die einen Bitverschiebungsbefehl implementiert.  Der 8080 verf√ºgt √ºber Befehle f√ºr eine 1-Bit-Verschiebung, aber Dutzende von 8080-Befehlen werden ben√∂tigt, um eine Mehrbit- / Multibyte-Verschiebung zu implementieren. Spezielle Hardware erm√∂glicht es dem Spiel, diese Operationen in nur wenigen Anweisungen auszuf√ºhren.  Mit seiner Hilfe wird jedes Bild auf dem Spielfeld gezeichnet, dh es wird mehrmals pro Bild verwendet. <br><br>  Ich glaube nicht, dass ich es besser erkl√§ren kann als die hervorragende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Analyse der</a> Computerarch√§ologie: <br><br> <code>; 16- : <br> ; f 0  <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ;    4  x  y,     x, : <br> ; $0000, <br> ; write $aa -&gt; $aa00, <br> ; write $ff -&gt; $ffaa, <br> ; write $12 -&gt; $12ff, .. <br> ; <br> ;    2 ( 0,1,2)    8- , : <br> ; offset 0: <br> ; rrrrrrrr result=xxxxxxxx <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ; offset 2: <br> ; rrrrrrrr result=xxxxxxyy <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ; offset 7: <br> ; rrrrrrrr result=xyyyyyyy <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ;    3   .</code> <br> <br>  Beim Befehl OUT wird beim Schreiben in Port 2 der Verschiebungsbetrag und beim Schreiben in Port 4 die Daten in den Schieberegistern festgelegt.  Das Lesen mit IN 3 gibt Daten zur√ºck, die um den Verschiebungsbetrag verschoben sind.  In meiner Maschine ist dies folgenderma√üen implementiert: <br><br><pre> <code class="cpp hljs"> -(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) MachineIN(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> port) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(port) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> v = (shift1&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>) | shift0; a = ((v &gt;&gt; (<span class="hljs-number"><span class="hljs-number">8</span></span>-shift_offset)) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } -(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) MachineOUT(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> port, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> value) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(port) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: shift_offset = value &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: shift0 = shift1; shift1 = value; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><h2>  Tastatur </h2><br>  Um die Antwort der Maschine zu erhalten, m√ºssen wir Tastatureingaben daran binden.  Die meisten Plattformen bieten die M√∂glichkeit, Tastenanschl√§ge zu empfangen und Ereignisse freizugeben.  Der Plattformcode f√ºr die Schaltfl√§chen sieht folgenderma√üen aus: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(PeekMessage(&amp;msg,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,PM_REMOVE)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg.message==WM_KEYDOWN ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( msg.wParam == VK_LEFT ) MachineKeyDown(LEFT); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg.message==WM_KEYUP ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( msg.wParam == VK_LEFT ) MachineKeyUp(LEFT); } }</code> </pre> <br>  Der Maschinencode, der den Plattformcode auf den Emulatorcode klebt, sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="cpp hljs"> MachineKeyDown(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> key) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(key) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LEFT: port[<span class="hljs-number"><span class="hljs-number">1</span></span>] |= <span class="hljs-number"><span class="hljs-number">0x20</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Set bit 5 of port 1 break; case RIGHT: port[1] |= 0x40; //Set bit 6 of port 1 break; /*....*/ } } PlatformKeyUp(char key) { switch(key) { case LEFT: port[1] &amp;= 0xDF //Clear bit 5 of port 1 break; case RIGHT: port[1] &amp;= 0xBF //Clear bit 6 of port 1 break; /*....*/ } }</span></span></code> </pre> <br>  Wenn Sie m√∂chten, k√∂nnen Sie den Code der Maschine und der Plattform beliebig kombinieren - dies ist die Wahl der Implementierung.  Ich werde dies nicht tun, da ich die Maschine auf mehrere verschiedene Plattformen portieren werde. <br><br><h2>  Unterbrechungen </h2><br>  Nachdem ich das Handbuch studiert hatte, stellte ich fest, dass der 8080 Interrupts wie folgt behandelt: <br><br><ol><li>  Die Interruptquelle (au√üerhalb der CPU) setzt den CPU-Interrupt-Pin. </li><li>  Wenn die CPU best√§tigt, dass der Interrupt empfangen wurde, kann die Quelle des Interrupts einen beliebigen Opcode an den Bus senden und die CPU sieht ihn.  (Meistens verwenden sie den Befehl RST.) </li><li>  Die CPU f√ºhrt diesen Befehl aus.  Wenn es sich um RST handelt, ist dies ein Analogon des CALL-Befehls f√ºr eine feste Adresse am unteren Rand des Speichers.  Es schiebt den aktuellen PC auf den Stapel. </li><li>  Der Code in der unteren Speicheradresse verarbeitet, was der Interrupt dem Programm mitteilen m√∂chte.  Nach Abschluss der Verarbeitung wird RST mit einem Aufruf von RET beendet. </li></ol><br>  Die Videoausr√ºstung des Spiels erzeugt zwei Interrupts, die wir programmgesteuert emulieren m√ºssen: das Ende des Frames und die Mitte des Frames.  Beide werden mit 60 Hz (60 Mal pro Sekunde) ausgef√ºhrt.  1/60 Sekunde ist 16,6667 Millisekunden. <br><br>  Um die Arbeit mit Interrupts zu vereinfachen, werde ich dem 8080-Emulator eine Funktion hinzuf√ºgen: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> interrupt_num)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//perform "PUSH PC" Push(state, (state-&gt;pc &amp; 0xFF00) &gt;&gt; 8, (state-&gt;pc &amp; 0xff)); //Set the PC to the low memory vector. //This is identical to an "RST interrupt_num" instruction. state-&gt;pc = 8 * interrupt_num; }</span></span></code> </pre> <br>  Der Plattformcode muss einen Timer implementieren, den wir aufrufen k√∂nnen (im Moment nenne ich ihn einfach time ()).  Der Maschinencode leitet damit einen Interrupt an den 8080-Emulator weiter.  Wenn der Timer im Maschinencode abl√§uft, rufe ich GenerateInterrupt auf: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!done) { Emulate8080Op(state); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( time() - lastInterrupt &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//1/60 second has elapsed { //only do an interrupt if they are enabled if (state-&gt;int_enable) { GenerateInterrupt(state, 2); //interrupt 2 //Save the time we did this lastInterrupt = time(); } } }</span></span></code> </pre> <br>  Es gibt einige Details dar√ºber, wie der 8080 tats√§chlich Interrupts verarbeitet, die wir nicht emulieren werden.  Ich glaube, dass eine solche Verarbeitung f√ºr unsere Zwecke ausreichen wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419143/">https://habr.com/ru/post/de419143/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419131/index.html">Der vorl√§ufige Starttermin des Mondmoduls SpaceIL wurde bekannt gegeben</a></li>
<li><a href="../de419133/index.html">Freitag Webinare: Lernen, kostenlos zu programmieren</a></li>
<li><a href="../de419135/index.html">Freitag JS: 0-Zeilen-JS- und CSS-Spiel</a></li>
<li><a href="../de419137/index.html">Aktivit√§tsprotokollierung mit der Web Beacon-API</a></li>
<li><a href="../de419141/index.html">Sex Phishing gewinnt in den USA zunehmend an Bedeutung</a></li>
<li><a href="../de419145/index.html">Fintech Digest: Apples Kapitalisierung √ºberstieg 1 Billion US-Dollar. AI half eBay dabei, den Umsatz um Milliarden zu steigern</a></li>
<li><a href="../de419147/index.html">1000-dimensionaler W√ºrfel: Ist es heute m√∂glich, ein Rechenmodell des menschlichen Ged√§chtnisses zu erstellen?</a></li>
<li><a href="../de419149/index.html">Leitfaden f√ºr Mikrotik RoMON</a></li>
<li><a href="../de419151/index.html">Smart Home: Eine neue Dimension des Komforts und das Streben nach Spitzenleistungen. Teil zwei</a></li>
<li><a href="../de419153/index.html">Cyborg Rights Memorandum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>