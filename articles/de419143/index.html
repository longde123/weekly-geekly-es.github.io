<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💇🏿 🚷 🐊 Erstellen eines Emulator-Arcade-Automaten. Teil 4 🛌🏿 🔏 🕍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teile des ersten , zweiten , dritten . 

 Der Rest der Maschine 
 Der Code, den wir für die Emulation des 8080-Prozessors geschrieben haben, ist recht...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen eines Emulator-Arcade-Automaten. Teil 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419143/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6eb/735/b99/6eb735b9990860a94f9ef0a18ba46a82.jpg" alt="Bild"></div><br>  Teile des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiten</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dritten</a> . <br><br><h2>  Der Rest der Maschine </h2><br>  Der Code, den wir für die Emulation des 8080-Prozessors geschrieben haben, ist recht allgemein gehalten und kann problemlos an jeden Computer mit dem C-Compiler angepasst werden. Um das Spiel selbst zu spielen, müssen wir jedoch mehr tun.  Wir müssen die Ausrüstung des gesamten Arcade-Automaten emulieren und Code schreiben, der die spezifischen Funktionen unserer Computerumgebung auf den Emulator klebt. <br><br>  (Möglicherweise möchten Sie sich den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schaltplan der</a> Maschine ansehen.) <br><a name="habracut"></a><br><h2>  Timings </h2><br>  Das Spiel läuft auf dem 2 MHz 8080. Ihr Computer ist viel schneller.  Um dies zu berücksichtigen, müssen wir uns einen Mechanismus ausdenken. <br><br><h2>  Unterbrechungen </h2><br>  Interrupts sind so konzipiert, dass der Prozessor Aufgaben mit präzisen Ausführungszeiten wie E / A verarbeiten kann.  Der Prozessor kann das Programm ausführen, und wenn der Interrupt-Pin ausgelöst wird, beendet er die Ausführung des aktuellen Programms und führt etwas anderes aus. <br><br>  Wir müssen simulieren, wie ein Arcade-Automat Interrupts erzeugt. <br><br><h2>  Grafik </h2><br>  Space Invaders zeichnet Grafiken im Adressbereich 0x2400 in seinen Speicher.  Ein echter Hardware-Videocontroller würde RAM lesen und eine CRT-Anzeige steuern.  Unser Programm muss dieses Verhalten emulieren, indem es ein Bild des Spiels in einem Fenster rendert. <br><br><h2>  Knöpfe </h2><br>  Das Spiel verfügt über physische Tasten, die das Programm mit dem IN-Befehl des 8080-Prozessors liest. Unser Emulator muss die Tastatureingabe an diese IN-Befehle binden. <br><br><h2>  ROM und RAM </h2><br>  Ich muss zugeben: Wir „schneiden die Ecke ab“, indem wir einen 16-Kilobyte-Speicherpuffer erstellen, der die unteren 16 KB der Prozessorspeicherzuordnung enthält.  Tatsächlich sind die ersten 2 KB der Speicherzuweisung ein echter Nur-Lese-Speicher (ROM).  Wir müssen Schreiboperationen im Speicher in eine Funktion einfügen, damit es nicht möglich ist, in ein ROM zu schreiben. <br><br><h2>  Ton </h2><br>  Bisher haben wir nichts über Klang gesagt.  Space Invaders verfügt über ein niedliches analoges Soundschema, das einen von 8 Sounds wiedergibt, die vom OUT-Befehl gesteuert werden und an einen der Ports übertragen werden.  Wir müssen diese OUT-Befehle konvertieren, um Soundbeispiele auf unserer Plattform abzuspielen. <br><br>  Es mag wie viel Arbeit erscheinen, aber es ist nicht so schlimm und wir können uns schrittweise bewegen.  Als erstes möchten wir den Bildschirm sehen, für den wir Interrupts, Grafiken und einen Teil der Verarbeitung der IN- und OUT-Befehle benötigen. <br><br><h2>  Zeigt und aktualisiert </h2><br><h3>  Die Grundlagen </h3><br>  Sie sind wahrscheinlich mit den Komponenten eines Videoanzeigesystems vertraut.  Irgendwo im System befindet sich eine Art RAM, der ein Bild zur Anzeige auf dem Bildschirm enthält.  Bei analogen Geräten gibt es Geräte, die diesen RAM lesen und die Bytes in analoge Spannung umwandeln, die an den Monitor übertragen wird. <br><br>  Ein tieferes Verständnis des Systems hilft uns bei der Analyse des Zwecks der Speicherzuweisung und der Codefunktionalität. <br><br>  Analoge Anzeigen stellen Anforderungen an Bildwiederholraten und Timings.  Zu jedem Zeitpunkt verfügt die Anzeige über ein aktualisiertes spezifisches Pixel.  Das auf den Bildschirm übertragene Bild wird Punkt für Punkt ausgefüllt, beginnend von der oberen linken Ecke und oben rechts, dann vom ersten Punkt der zweiten Zeile, vom letzten Punkt der zweiten Zeile usw.  Nachdem die letzte Linie auf dem Bildschirm gezeichnet wurde, kann der Videocontroller einen vertikalen Leerzeichen-Interrupt (auch als VBI oder VBL bezeichnet) erzeugen. <br><br>  Um eine reibungslose Animation zu gewährleisten, kann das vom Videocontroller verarbeitete Bild im RAM nicht geändert werden.  Wenn die RAM-Aktualisierung in der Mitte des Frames erfolgt ist, sieht der Betrachter Teile von zwei Bildern.  Dies führt zu einem "Riss" -Effekt, wenn ein Bild, das sich vom unteren Bild unterscheidet, oben auf dem Bildschirm angezeigt wird.  Wenn Sie jemals einen Zeilenumbruch gesehen haben, wissen Sie, wie er aussieht. <br><br>  Um Lücken zu vermeiden, muss die Software etwas tun, um zu vermeiden, dass der Speicherort der Bildschirmaktualisierung übertragen wird.  Und dafür gibt es nur einen Weg. <br><br>  VBL wird nach dem Ende der letzten Zeile generiert. In der Regel dauert es eine gewisse Zeit, bis die erste Zeile erneut gezeichnet wird.  (Dies ist die vertikale Leerzeit und kann etwa 1 Millisekunde betragen.) <br><br>  Wenn VBL empfangen wird, beginnt das Programm, den Bildschirm von oben zu rendern. <br><br>  Jede Linie wird vor dem Frame-Scan-Umkehrvorgang gezeichnet. <br><br>  Die CPU ist dem Return Hot immer voraus und vermeidet daher Zeilenumbrüche. <br><br><div style="text-align:center;"><img src="http://www.emulator101.com/images/verticalretrace.jpg" alt="Bild"></div><br><h2>  Space Invaders Videosystem </h2><br>  Eine sehr informative <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Seite</a> sagt uns, dass Space Invaders zwei Video-Interrupts haben.  Eine ist für das Ende des Frames, erzeugt aber auch einen Interrupt in der Mitte des Bildschirms.  Die Seite beschreibt das Bildschirmaktualisierungssystem - das Spiel zeichnet Grafiken in der oberen Hälfte des Bildschirms, wenn es eine Unterbrechung in der Mitte des Bildschirms erhält, und Grafiken im unteren Teil des Bildschirms, wenn es eine Unterbrechung am Ende des Rahmens empfängt.  Dies ist eine ziemlich clevere Methode, um Zeilenumbrüche zu vermeiden, und ein gutes Beispiel dafür, was erreicht werden kann, wenn Sie gleichzeitig Hardware und Software entwickeln. <br><br>  Wir müssen die Emulation unserer Maschine erzwingen, um solche Interrupts zu erzeugen.  Wenn wir sie mit einer Frequenz von 60 Hz sowie die Space Invaders-Maschine erzeugen, wird das Spiel mit der richtigen Frequenz gezeichnet. <br><br>  Im nächsten Abschnitt werden wir über die Mechanik von Interrupts sprechen und darüber nachdenken, wie sie emuliert werden können. <br><br><h2>  Tasten und Anschlüsse </h2><br>  Der 8080 implementiert E / A mithilfe der Anweisungen IN und OUT.  Es hat 8 separate IN- und OUT-Ports - der Port wird durch das Datenbyte des Befehls bestimmt.  Zum Beispiel setzt <code>IN 3</code> den Wert von Port 3 in Register A und <code>OUT 2</code> sendet A an Port 2. <br><br>  Ich habe Informationen zum Zweck jedes Ports von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Computer Archaeology-</a> Website abgerufen.  Wenn diese Informationen nicht verfügbar wären, müssten wir sie durch Studieren des Schaltplans sowie durch Lesen und schrittweise Codeausführung erhalten. <br><br> <code>: <br>  1 <br>  0  (0,  ) <br> 1  Start   <br> 2  Start   <br> 3 ? <br> 4     <br> 5     <br> 6     <br> 7 ? <br> <br>  2 <br>  0,1 DIP-   (0:3,1:4,2:5,3:6) <br> 2 ""  <br> 3 DIP-  , 1:1000,0:1500 <br> 4     <br> 5     <br> 6     <br> 7    DIP-, 1:,0: <br> <br>  3    <br> <br>  2     ( 0,1,2) <br>  3    <br>  4    <br>  5    <br>  6  "" ? ,     , <br>       (0=a,1=b,2=c  ..) <br> <br> (  3,5,6      1=$01  2=$00 <br>    ,       (attract mode))</code> <br> <br>  Es gibt drei Möglichkeiten, E / A in unserem Software-Stack zu implementieren (der aus einem 8080-Emulator, Maschinencode und Plattformcode besteht). <br><br><ol><li>  Betten Sie Maschinenwissen in unseren 8080-Emulator ein </li><li>  Betten Sie das 8080-Emulatorwissen in den Maschinencode ein </li><li>  Erfinden Sie eine formale Schnittstelle zwischen den drei Teilen des Codes, um den Informationsaustausch über die API zu ermöglichen </li></ol><br>  Ich habe die erste Option ausgeschlossen - es ist ziemlich offensichtlich, dass sich der Emulator ganz unten in dieser Aufrufkette befindet und getrennt bleiben sollte.  (Stellen Sie sich vor, Sie müssen den Emulator für ein anderes Spiel wiederverwenden, und Sie werden verstehen, was ich meine.) Im Allgemeinen ist das Übertragen von Datenstrukturen auf hoher Ebene auf niedrigere Ebenen eine schlechte architektonische Lösung. <br><br>  Ich habe Option 2 gewählt. Lassen Sie mich zuerst den Code anzeigen: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!done) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> opcode = state-&gt;memory[state-&gt;pc]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*opcode == <span class="hljs-number"><span class="hljs-number">0xdb</span></span>) <span class="hljs-comment"><span class="hljs-comment">//machine specific handling for IN { uint8_t port = opcode[1]; state-&gt;a = MachineIN(state, port); state-&gt;pc++; } else if (*opcode == 0xd3) //OUT { uint8_t port = opcode[1]; MachineOUT(state, port); state-&gt;pc++; } else Emulate8080Op(state); }</span></span></code> </pre> <br>  Dieser Code implementiert die Verarbeitung von Opcodes für IN und OUT in derselben Schicht erneut, wodurch der Emulator für den Rest der Befehle aufgerufen wird.  Meiner Meinung nach macht dies den Code sauberer.  Dies ähnelt einer Überschreibung oder Unterklasse für die beiden Befehle, die sich auf eine Automatenebene bezieht. <br><br>  Der Nachteil ist, dass wir die Emulation von Opcodes an zwei Stellen übertragen.  Ich werde Sie nicht beschuldigen, die dritte Option gewählt zu haben.  Bei der zweiten Option ist weniger Code erforderlich, aber Option 3 ist „sauberer“, aber der Preis erhöht die Komplexität.  Dies ist eine Frage der Stilwahl. <br><br><h2>  Schieberegister </h2><br>  Die Space Invaders-Maschine verfügt über eine interessante Hardwarelösung, die einen Bitverschiebungsbefehl implementiert.  Der 8080 verfügt über Befehle für eine 1-Bit-Verschiebung, aber Dutzende von 8080-Befehlen werden benötigt, um eine Mehrbit- / Multibyte-Verschiebung zu implementieren. Spezielle Hardware ermöglicht es dem Spiel, diese Operationen in nur wenigen Anweisungen auszuführen.  Mit seiner Hilfe wird jedes Bild auf dem Spielfeld gezeichnet, dh es wird mehrmals pro Bild verwendet. <br><br>  Ich glaube nicht, dass ich es besser erklären kann als die hervorragende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Analyse der</a> Computerarchäologie: <br><br> <code>; 16- : <br> ; f 0  <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ;    4  x  y,     x, : <br> ; $0000, <br> ; write $aa -&gt; $aa00, <br> ; write $ff -&gt; $ffaa, <br> ; write $12 -&gt; $12ff, .. <br> ; <br> ;    2 ( 0,1,2)    8- , : <br> ; offset 0: <br> ; rrrrrrrr result=xxxxxxxx <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ; offset 2: <br> ; rrrrrrrr result=xxxxxxyy <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ; offset 7: <br> ; rrrrrrrr result=xyyyyyyy <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ;    3   .</code> <br> <br>  Beim Befehl OUT wird beim Schreiben in Port 2 der Verschiebungsbetrag und beim Schreiben in Port 4 die Daten in den Schieberegistern festgelegt.  Das Lesen mit IN 3 gibt Daten zurück, die um den Verschiebungsbetrag verschoben sind.  In meiner Maschine ist dies folgendermaßen implementiert: <br><br><pre> <code class="cpp hljs"> -(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) MachineIN(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> port) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(port) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> v = (shift1&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>) | shift0; a = ((v &gt;&gt; (<span class="hljs-number"><span class="hljs-number">8</span></span>-shift_offset)) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } -(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) MachineOUT(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> port, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> value) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(port) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: shift_offset = value &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: shift0 = shift1; shift1 = value; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><h2>  Tastatur </h2><br>  Um die Antwort der Maschine zu erhalten, müssen wir Tastatureingaben daran binden.  Die meisten Plattformen bieten die Möglichkeit, Tastenanschläge zu empfangen und Ereignisse freizugeben.  Der Plattformcode für die Schaltflächen sieht folgendermaßen aus: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(PeekMessage(&amp;msg,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,PM_REMOVE)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg.message==WM_KEYDOWN ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( msg.wParam == VK_LEFT ) MachineKeyDown(LEFT); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg.message==WM_KEYUP ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( msg.wParam == VK_LEFT ) MachineKeyUp(LEFT); } }</code> </pre> <br>  Der Maschinencode, der den Plattformcode auf den Emulatorcode klebt, sieht ungefähr so ​​aus: <br><br><pre> <code class="cpp hljs"> MachineKeyDown(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> key) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(key) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LEFT: port[<span class="hljs-number"><span class="hljs-number">1</span></span>] |= <span class="hljs-number"><span class="hljs-number">0x20</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Set bit 5 of port 1 break; case RIGHT: port[1] |= 0x40; //Set bit 6 of port 1 break; /*....*/ } } PlatformKeyUp(char key) { switch(key) { case LEFT: port[1] &amp;= 0xDF //Clear bit 5 of port 1 break; case RIGHT: port[1] &amp;= 0xBF //Clear bit 6 of port 1 break; /*....*/ } }</span></span></code> </pre> <br>  Wenn Sie möchten, können Sie den Code der Maschine und der Plattform beliebig kombinieren - dies ist die Wahl der Implementierung.  Ich werde dies nicht tun, da ich die Maschine auf mehrere verschiedene Plattformen portieren werde. <br><br><h2>  Unterbrechungen </h2><br>  Nachdem ich das Handbuch studiert hatte, stellte ich fest, dass der 8080 Interrupts wie folgt behandelt: <br><br><ol><li>  Die Interruptquelle (außerhalb der CPU) setzt den CPU-Interrupt-Pin. </li><li>  Wenn die CPU bestätigt, dass der Interrupt empfangen wurde, kann die Quelle des Interrupts einen beliebigen Opcode an den Bus senden und die CPU sieht ihn.  (Meistens verwenden sie den Befehl RST.) </li><li>  Die CPU führt diesen Befehl aus.  Wenn es sich um RST handelt, ist dies ein Analogon des CALL-Befehls für eine feste Adresse am unteren Rand des Speichers.  Es schiebt den aktuellen PC auf den Stapel. </li><li>  Der Code in der unteren Speicheradresse verarbeitet, was der Interrupt dem Programm mitteilen möchte.  Nach Abschluss der Verarbeitung wird RST mit einem Aufruf von RET beendet. </li></ol><br>  Die Videoausrüstung des Spiels erzeugt zwei Interrupts, die wir programmgesteuert emulieren müssen: das Ende des Frames und die Mitte des Frames.  Beide werden mit 60 Hz (60 Mal pro Sekunde) ausgeführt.  1/60 Sekunde ist 16,6667 Millisekunden. <br><br>  Um die Arbeit mit Interrupts zu vereinfachen, werde ich dem 8080-Emulator eine Funktion hinzufügen: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> interrupt_num)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//perform "PUSH PC" Push(state, (state-&gt;pc &amp; 0xFF00) &gt;&gt; 8, (state-&gt;pc &amp; 0xff)); //Set the PC to the low memory vector. //This is identical to an "RST interrupt_num" instruction. state-&gt;pc = 8 * interrupt_num; }</span></span></code> </pre> <br>  Der Plattformcode muss einen Timer implementieren, den wir aufrufen können (im Moment nenne ich ihn einfach time ()).  Der Maschinencode leitet damit einen Interrupt an den 8080-Emulator weiter.  Wenn der Timer im Maschinencode abläuft, rufe ich GenerateInterrupt auf: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!done) { Emulate8080Op(state); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( time() - lastInterrupt &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//1/60 second has elapsed { //only do an interrupt if they are enabled if (state-&gt;int_enable) { GenerateInterrupt(state, 2); //interrupt 2 //Save the time we did this lastInterrupt = time(); } } }</span></span></code> </pre> <br>  Es gibt einige Details darüber, wie der 8080 tatsächlich Interrupts verarbeitet, die wir nicht emulieren werden.  Ich glaube, dass eine solche Verarbeitung für unsere Zwecke ausreichen wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419143/">https://habr.com/ru/post/de419143/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419131/index.html">Der vorläufige Starttermin des Mondmoduls SpaceIL wurde bekannt gegeben</a></li>
<li><a href="../de419133/index.html">Freitag Webinare: Lernen, kostenlos zu programmieren</a></li>
<li><a href="../de419135/index.html">Freitag JS: 0-Zeilen-JS- und CSS-Spiel</a></li>
<li><a href="../de419137/index.html">Aktivitätsprotokollierung mit der Web Beacon-API</a></li>
<li><a href="../de419141/index.html">Sex Phishing gewinnt in den USA zunehmend an Bedeutung</a></li>
<li><a href="../de419145/index.html">Fintech Digest: Apples Kapitalisierung überstieg 1 Billion US-Dollar. AI half eBay dabei, den Umsatz um Milliarden zu steigern</a></li>
<li><a href="../de419147/index.html">1000-dimensionaler Würfel: Ist es heute möglich, ein Rechenmodell des menschlichen Gedächtnisses zu erstellen?</a></li>
<li><a href="../de419149/index.html">Leitfaden für Mikrotik RoMON</a></li>
<li><a href="../de419151/index.html">Smart Home: Eine neue Dimension des Komforts und das Streben nach Spitzenleistungen. Teil zwei</a></li>
<li><a href="../de419153/index.html">Cyborg Rights Memorandum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>