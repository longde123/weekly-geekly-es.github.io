<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👏🏻 👰🏾 🌒 Démontage du moteur de roman visuel Qlie 🎉 🕳️ 🍒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Une traduction amateur d'histoires courtes visuelles, par rapport aux traductions d'autres jeux, a un certain nombre de fonctionnalités et implique de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Démontage du moteur de roman visuel Qlie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426431/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/bb/sq/zf/bbsqzfse3pqjvnyef8jnfv3lecy.png"></div><br><br>  Une traduction amateur d'histoires courtes visuelles, par rapport aux traductions d'autres jeux, a un certain nombre de fonctionnalités et implique de travailler avec beaucoup de texte.  Peut-être que la grande majorité de tous les romans visuels ont été publiés en japonais, seuls quelques-uns ont été traduits en anglais (officiellement ou par des amateurs), et encore moins ont été traduits dans d'autres langues. <br><br>  Par conséquent, lorsque vous travaillez avec la traduction, vous devez traiter avec des moteurs japonais, dont beaucoup ne sont pas très conviviaux pour les localisateurs.  Pour cette raison, on se rend rapidement compte que la présence de compétences en traduction, la connaissance de la langue, un grand enthousiasme et du temps libre ne signifie pas que la version traduite du jeu verra bientôt le jour. <br><a name="habracut"></a><br>  En gros, le processus de traduction de n'importe quel jeu (et pas seulement des nouvelles visuelles) implique: <br><br><ul><li>  Déballage des ressources du jeu (si elles ne sont pas dans le domaine public) </li><li>  Traduction des pièces nécessaires </li><li>  Transfert emballage inverse </li></ul><br>  Cependant, dans le cas des nouvelles visuelles japonaises, cela ressemble généralement à ceci: <br><br><ul><li>  Déballage des ressources du jeu </li><li>  Traduction de la partie texte du jeu (script du jeu) </li><li>  Traduction de la partie graphique du jeu </li><li>  Transfert emballage inverse </li><li>  Modification du moteur pour le faire fonctionner avec du contenu traduit </li></ul><br>  J'espère que notre expérience sera utile à quelqu'un. <br><br>  En 2013 (et peut-être plus tôt), j'ai décidé de traduire du japonais le roman visuel Bishoujo Mangekyou-Norowareshi Densetsu no Shoujo- (美 少女 万 華 鏡 - 呪 わ れ し 伝 説 の 少女 -).  J'avais déjà de l'expérience dans la traduction de jeux, mais auparavant je ne devais traduire que des nouvelles sur des moteurs relativement simples et bien connus comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kirikiri</a> . <br><br>  Ici, notre équipe de traducteurs a dû ouvrir le moteur de cette nouvelle, avant même que nous arrivions au texte lui-même. <br><br>  Commençons par une description du fichier .exe, où les mots QLIE et IMOSURUME sont mentionnés.  Le fichier lui-même contient la ligne FastMM Borland Edition 2004, 2005 Pierre le Riche, ce qui signifie que le moteur est très probablement écrit en Delphi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kx/ss/sg/kxsssg_foyhzeykfu1e4s5pneok.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zo/ge/zc/zogezc8m47t1cflh-yqpzl85fby.png"></div><br>  Une recherche rapide sur Google révèle que Qlie est le nom du moteur de roman visuel publié par Warmth Entertainment.  Apparemment, IMOSURUME est le nom interne du moteur de script et Qlie est le nom commercial.  Il existe un site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qlie.net</a> , qui répertorie les jeux sortis sur ce moteur et le site officiel de Warmth Entertainment. <br><br>  Mais nulle part dans le domaine public, il n'y a ni outils officiels pour travailler avec le moteur, ni documentation pour celui-ci, ce qui est attendu. <br><br>  Par conséquent, vous devez gérer le jeu vous-même, en vous appuyant sur des utilitaires non officiels.  Pour commencer, vous devriez trouver toutes les parties du jeu qui doivent être traduites. <br><br>  Les archives de jeu se trouvent dans les fichiers data0.pack, data1.pack et data7.pack dans le sous-dossier \ GameData.  Les économiseurs d'écran se trouvent dans le dossier \ GameData \ Movie, mais vous pouvez toujours les laisser seuls. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gr/fh/on/grfhont7xq1rascbvzu8v1mhkec.png"></div><br>  L'éditeur hexadécimal montre qu'il n'y a pas d'en-têtes reconnaissables pour les archives du jeu .pack, mais à la fin du fichier, il y a un morceau similaire à la table des matières et à l'étiquette FilePackVer3.0 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yf/qd/1q/yfqd1qyy7ozx0ygvq_bj_tmkms4.png"></div><br>  Heureusement, pour ce format, il existe déjà un déballeur et même pas un.  Nous avons utilisé la console exfp3_v3 de asmodean. <br><br>  Le déballage n'est pas aussi simple qu'il y paraît.  Étant donné que le moteur prend en charge plusieurs formats d'archive (FilePackVer1.0, FilePackVer1.0, FilePackVer3.0), et dans ce cas, FilePackVer3.0 est utilisé, pour le décompactage correct, vous aurez également besoin d'un fichier de clé spécial key.fkey, qui a chiffré l'archive.  Il se trouve dans le sous-dossier \ Dll <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fa/fq/qe/fafqqeqgfwisqr1ijhg9qpcmsm4.png"></div><br>  De plus, exfp3_v3 devrait clarifier l'archive de quel jeu il est en train de déballer. <br>  Par conséquent, vous devez également spécifier le numéro de jeu dans la liste proposée par le décompresseur (les jeux de la série Bishoujo Mangekyou sont là sous le numéro 15), ou spécifier le fichier exécutable du jeu comme troisième paramètre du décompresseur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9r/nr/-z/9rnr-zngqxajz8pysxwv3v8u8gk.png"></div><br>  Déjà après avoir déballé les fichiers du jeu, une pensée logique est apparue: comment à l'avenir comment remballer le jeu avec une traduction prête?  Après tout, le déballeur ne prend pas en charge l'opération inverse. <br>  À notre demande, w8m (merci beaucoup pour cela) a ajouté la possibilité de compresser les archives du jeu dans son programme arc_conv.exe.  Il suffit de regrouper tous les fichiers modifiés dans une nouvelle archive (par exemple, data8.pack), de le placer dans le dossier GameData, et ils se lanceront automatiquement dans le jeu. <br><br>  Retour aux ressources décompressées.  Les fichiers de script de jeu de l'archive data0.pack se trouvent dans le sous-dossier \ scenario \ ks_01 \ <br><br>  Tous les fichiers de script avec l'extension .s sont encodés loin de l'encodage Shift Jis le plus pratique, et le moteur ne prend en charge aucun encodage Unicode.  Les lignes de la traduction ressemblent approximativement à celles-ci: <br><br><pre><code class="python hljs">【キリエ】 ％<span class="hljs-number"><span class="hljs-number">1</span></span>_kiri1478％ 「へえ……分かっているじゃない」 私が献上したロシアンティーを見て、キリエは嬉しそうに目を細める。 ^cface,,赤目微笑<span class="hljs-number"><span class="hljs-number">01</span></span> 【キリエ】 ％<span class="hljs-number"><span class="hljs-number">1</span></span>_kiri1479％ 「日本人は、ジャムを紅茶に入れて飲むのが、ロシアンティーだと勘違いしている人が多いのだけれど……」</code> </pre> <br>  Vous remarquerez peut-être que chaque phrase en japonais est précédée du nom du héros entre parenthèses japonaises.  (【】), Qui prononce cette phrase (dans le jeu elle s'affiche en haut de la fenêtre avec du texte).  Ou, si ce sont les mots de l'auteur, le nom n'est pas ajouté. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ws/d_/dz/wsd_dzwzrz-sjk_0shl7zw3ov5k.png"></div><br>  Mais il reste des équipes de service. <br><br>  Les commandes du moteur dans le script rappellent quelque peu le langage de balisage TeX, mais sont beaucoup plus intuitives et peu pratiques par rapport aux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commandes</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kirikiri</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RenPy</a> . <br><br>  En voici quelques uns: <br><br>  <code>@@@</code> est un triple chien.  Souvent, les fichiers de script commencent par cette commande.  Apparemment, le chargement des définitions à partir de fichiers tiers. <br><br>  Par exemple: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@@@Library\Avg\header.s</span></span></code> </pre> <br>  <code>@@</code> est un chien double.  L'étiquette dans le fichier de script.  Vous pourrez y accéder ultérieurement. <br><br>  <code>％1_kiri1478％</code> - lire le fichier vocal.  Ces commandes sont insérées entre le nom du héros et le texte qui s'affiche à l'écran.  "1_kiri1478" - dans ce cas, le nom du fichier du dossier \ voice \ du fichier data1.pack Il est intéressant que l'équipe utilise le pourcentage japonais (％), plutôt que le pourcentage habituel. <br><br>  <code>^savedate, ^saveroute, ^savescene,</code> - trois équipes les plus susceptibles d'être utilisées dans le système de sauvegarde du jeu et qui doivent saisir des informations sur le lieu et l'heure à laquelle le joueur a été enregistré dans la sauvegarde. <br><br>  Par exemple: <br><br><pre> <code class="python hljs">^savedate,<span class="hljs-string"><span class="hljs-string">"現在"</span></span> ^saveroute,<span class="hljs-string"><span class="hljs-string">"美少女万華鏡－１－"</span></span> ^savescene,<span class="hljs-string"><span class="hljs-string">"呪われし伝説の少女 オープニング"</span></span></code> </pre> <br>  C'est-à-dire, date: présent, branche: Bishoujo Mangekyou -1-, scène: Norowareshi Densetsu no Shoujo Opening.  Ces données auraient dû être affichées dans la fente de sauvegarde, mais apparemment, les développeurs ont décidé de l'abandonner.  Par conséquent, <code>^saveroute</code> dans toutes les parties du script, <code>^savedate</code> change du "moment présent" en "rêves" et dans <code>^savescene</code> jours de jeu (ou plutôt les nuits) changent. <br><br>  <code>^facewindow,</code> - état de la zone de texte avec le texte affiché à l'écran.  (Montré - 1 ou pas - 0) <br><br>  <code>^sload,</code> - jouez les sons du jeu depuis le dossier \ sound \ sur le canal correspondant. <br><br><pre> <code class="python hljs">sload,Env1,◆セミ<span class="hljs-number"><span class="hljs-number">01</span></span>アブラゼミ</code> </pre> <br>  Jouer des cigales sur Env1 <br><br>  L'équipe a deux paramètres facultatifs, le premier est responsable de la boucle du son, et le second reste un mystère, mais il est rarement utilisé dans le jeu. <br><br><pre> <code class="python hljs">^sload,SE1,■クチュ音<span class="hljs-number"><span class="hljs-number">01</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Lecture du son de bouclage sur le canal SE1. <br><br>  <code>^eeffect</code> - affiche un effet spécial sur l'écran pendant un certain nombre de secondes.  Apparemment, il prend en charge la sortie séquentielle de plusieurs effets. <br><br><pre> <code class="python hljs">^eeffect,WhiteFlash</code> </pre> <br>  L'effet d'un flash blanc. <br><br>  <code>^ffade</code> - effet de transition lors du changement d'écran. <br>  Il a tout un tas de paramètres supplémentaires, mais seuls quelques-uns sont vraiment utiles: le nom de l'effet de transition, une image supplémentaire, si nécessaire, et le temps d'achèvement de la transition. <br><br><pre> <code class="python hljs">^ffade,Overlap,,<span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> <br>  Dissoudre une image dans une autre, en 1 seconde. <br><br>  <code>^iload</code> - charge l'image d'arrière-plan sur l'écran.  L'image peut se voir attribuer un identifiant auquel se référer à l'avenir. <br><br><pre> <code class="python hljs">^iload,BG1,<span class="hljs-number"><span class="hljs-number">0</span></span>_black.png</code> </pre> <br>  Fichier de sortie 0_black.png en arrière-plan avec l'ID BG1 <br><br>  <code>^we</code> et <code>^wd</code> - activer et désactiver l'image dans la fenêtre. <br><br>  <code>^facewindow,1</code> et <code>^facewindow,0</code> Active et désactive l'image du héros dans la boîte de dialogue. <br><br>  <code>^mload</code> - lire de la musique sur un canal spécifique. <br><br><pre> <code class="python hljs">^mload,BGM1,nbgm13</code> </pre> <br>  Lecture de la piste nbgm13 sur le canal BGM1 <br><br>  Quelques-unes des équipes les plus importantes: <br>  <code>\jmp</code> - saute à l'étiquette avec le nom spécifié. <br><br>  <code>^select</code> - affiche une fenêtre de sélection sur l'écran où le joueur doit sélectionner l'une des options. <br><br>  Par exemple: <br><br><pre> <code class="python hljs">^select, ,  \jmp,<span class="hljs-string"><span class="hljs-string">"@@route01a"</span></span>+ResultBtnInt[<span class="hljs-number"><span class="hljs-number">0</span></span>] @@route01a0</code> </pre> <br>  Ici, la transition sera effectuée après la réponse à la question et le numéro de réponse (0 ou 1) est renvoyé par ResultBtnInt [0].  Par conséquent, <code>\jmp</code> déplacera l'histoire vers le libellé @@ route01a + numéro de réponse.  Autrement dit, @@ route01a0 ou @@ route01a1 <br><br>  Une caractéristique désagréable est que la virgule habituelle dans ces commandes sert de séparateur et ne peut pas être utilisée dans les options de réponse elles-mêmes.  Les Japonais n'ont pas un tel problème, ils utilisent la virgule japonaise (、).  Dans ce cas, nous pouvons remplacer la virgule par ‚(U + 201A SINGLE LOW-9 QUOTATION MARK). <br><br>  Par exemple: <br><br><pre> <code class="python hljs">^select, ‚  , ‚ </code> </pre> <br>  Les équipes restantes ne sont pas si importantes en première approximation. <br><br>  Bien sûr, avant de traduire le script, vous devez le transcoder en quelque chose de plus pratique, par exemple en UTF-8, afin de combiner des caractères cyrilliques et japonais. <br><br>  Après avoir changé le moteur (à propos de cette partie suivante), le jeu perçoit à la fois le texte russe et le japonais.  Mais pour l'instant, pour des raisons de compatibilité, vous devez coder les caractères japonais dans Shift Jis et les caractères cyrilliques dans le codage cp1251. <br><br>  Nous avons rapidement esquissé un programme en Python pour le transcodage en tenant compte de l'alphabet cyrillique: <br><br><div class="spoiler">  <b class="spoiler_title">UTF8 à cp1251 et ShiftJIS</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # UTF8 to cp1251 and ShiftJIS recoder # by Chtobi and Nazon, 2016 import codecs import argparse from os import path JAPANESE_CODEPAGE = 'shift_jis' UTF_CODEPAGE = 'utf-8' RUS_CODEPAGE = 'cp1251' def nonrus_handler(e): if e.object[e.start:e.end] == '～': # UTF-8: 0xEFBD9E -&gt; SHIFT-JIS: 0x8160 japstr_byte = b'\x81\x60' elif e.object[e.start:e.end] == '－': # UTF-8: 0xEFBC8D -&gt; SHIFT-JIS: 0x817C japstr_byte = b'\x81\x7c' else: japstr_byte = (e.object[e.start:e.end]).encode(JAPANESE_CODEPAGE) return japstr_byte, e.end if __name__ == '__main__': arg_parser = argparse.ArgumentParser(prog="Recode to cp1251 and ShiftJIS", description="Program to encode UTF8 text file to " "cp1251 for all cyrillic symbols and ShiftJIS for others. " "Output file will be inputfilename.s", usage="recode_to_cp1251_shiftjis.py file_name") arg_parser.add_argument('file_name', nargs=1, type=argparse.FileType(mode='r', bufsize=-1), help="Input text file name. Only files coded in UTF8 are allowed.\n") codecs.register_error('nonrus_handler', nonrus_handler) input_name = arg_parser.parse_args().file_name[0].name output_name = path.splitext(input_name)[0] + ".s" with open(input_name, 'rt', encoding=UTF_CODEPAGE) as input_file: with open(output_name, 'wb') as output_file: for line in input_file: for char1 in line: bytes_out = bytes(line, UTF_CODEPAGE) output_file.write(char1.encode(RUS_CODEPAGE, "nonrus_handler")) print("Done.")</span></span></code> </pre><br></div></div><br>  Cependant, il y a eu quelques problèmes.  Le programme, en essayant de recoder le symbole «tilde» U (U + FF5E FULLWIDTH TILDE), a généré une erreur «UnicodeEncodeError: le codec« Shift Jis »ne peut pas coder le caractère« \ uff5e »en position 0: séquence multi-octets illégale» <br><br>  Au début, j'ai péché sur Python, mais à la fin j'ai découvert une nuance plutôt inhabituelle.  Il existe une ambiguïté entre les méthodes de corrélation des codages japonais Unicode et non Unicode selon l'implémentation spécifique. <br><br>  Par conséquent, Windows associe le caractère Shift Jis au code 0x8160 avec l'unicode ～ (U + FF5E FULLWIDTH TILDE), et d'autres transcodeurs (par exemple, l'utilitaire iconv) corrèlent le même caractère avec 〜 (U + 301C WAVE DASH), selon le tableau de rapport Unicode officiel - <a href="">ftp://ftp.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/JIS/SHIFT JIS.TXT</a> <br><br>  Pour déterminer la correspondance entre les personnages, Microsoft a apparemment décidé d'utiliser les schémas de leur encodage cp932, qui est une version étendue de Shift Jis. <br><br>  La même situation se produit avec le code de caractère 0x817C, qui est codé en UTF8 en tant que - (U + FF0D FULLWIDTH HYPHEN-MOINS) sous Windows, ou en tant que - (U + 2212 SIGNE MOINS) dans iconv. <br><br>  Étant donné que tous les fichiers de script ont été convertis pour la première fois de Shift Jis en UTF8 à l'aide de Notepad ++ (et il utilise la table de correspondance adoptée dans Windows), lors de la reconversion d'UTF8 en Shift Jis via notre programme Python, l'erreur de conversion notoire est apparue. <br><br>  Par conséquent, il était nécessaire de prendre en compte la survenue de conditions ～ et - distinctes. <br><br>  Il y avait d'autres défauts mineurs - par exemple, les ellipses ... (U + 2026 ELLIPSIS HORIZONTAL) a été remplacé par les ellipses cyrilliques de cp1251, et non les japonais de Shift Jis. <br><br>  Après avoir traduit le texte, vous pouvez continuer à travailler avec les graphiques du jeu. <br><br>  Les fichiers graphiques du jeu sont dans les mêmes archives de pack, mais après le déballage, ils doivent encore travailler dur.  Par exemple, presque toutes les images png sont décompressées sous forme de fichiers du type sample + DPNG000 + x32y0.png En d'autres termes, les images png sont découpées en bandes horizontales de 88 cm d'épaisseur et chaque bande est écrite dans un fichier séparé.  Le nom du fichier indique le numéro de série de la bande (DPNG000 ... 009) et les coordonnées x, y. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gj/ak/x_/gjakx_76ep3syu_gf9qfobolmj8.png"></div><br>  Je me demande toujours pourquoi c'était nécessaire.  Si pour la difficulté d'extraire des ressources du jeu, ce n'est clairement pas la meilleure méthode. <br><br>  Pour coller les fichiers png coupés, un petit script merge_dpng sur Pearl d'Asmodeus, qui utilise ImageMagick, a été créé à un moment donné.  Malheureusement, il a eu des problèmes avec lui.  Tout d'abord, j'avais besoin de Pearl, que je n'ai pas utilisé, et même après l'avoir installé, il s'est avéré que le script ne fonctionnait pas correctement. <br><br>  Pour cette raison, nous avons écrit un programme similaire en python: <br><br><div class="spoiler">  <b class="spoiler_title">Fusion de fichiers dpng du moteur Qlie</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # Qlie engine dpng files merger # by Chtobi and Nazon, 2016 # Requires ImageMagick magick.exe on the path. import os import glob import re import argparse import subprocess IMGMAGIC = os.path.dirname(os.path.abspath(__file__)) + '\\' + 'magick.exe' IMGMAGIC_PARAMS1 = ['-background', 'rgba(0,0,0,0)'] IMGMAGIC_PARAMS2 = ['-mosaic'] INPUT_FILES_MASK = '*+DPNG[0-9][0-9][0-9]+*.png' SPLIT_MASK = '+DPNG' x_y_ajusts_re = re.compile('(.+)\+DPNG[0-9][0-9][0-9]\+x(\d+)y(\d+)\.') if __name__ == '__main__': arg_parser = argparse.ArgumentParser(prog="DPNG Merger\n" "Program to merge sliced png files from QLIE engine. " "All files with mask *+DPNG[0-9][0-9][0-9]+*.png" "into the input directory will be merged and copied to the" "output directory.\n", usage="connect_png.py input_dir [output_dir]\n") arg_parser.add_argument("input_dir_param", nargs=1, help="Full path to the input directory.\n") arg_parser.add_argument("output_dir_param", nargs='?', default=os.path.dirname(os.path.abspath(__file__)), help="Full path to the output directory. " "It would be a script parent directory if not specified.\n") input_dir = arg_parser.parse_args().input_dir_param[0] output_dir = arg_parser.parse_args().output_dir_param[0] os.chdir(input_dir) all_append_files = glob.glob(INPUT_FILES_MASK) # Select only files with DPNG prep_bunches = [] for file_in_dir in all_append_files: # Check all files and put all splices that should be connected in separate list for num, bunch in enumerate(prep_bunches): name_first_part = bunch[0].partition(SPLIT_MASK)[0] # Part of the filename before +DPNG should be unique if name_first_part == file_in_dir.partition(SPLIT_MASK)[0]: prep_bunches[num].append(file_in_dir) break else: prep_bunches.append([file_in_dir]) os.chdir(os.path.dirname(os.path.abspath(__file__))) # Go to the script parent dir for prepared_bunch in prep_bunches: sorted_bunch = sorted(prepared_bunch) # Prepare -page params for imgmagic png_pages_params = [["(", "-page", "+{0}+{1}".format(*[(x_y_ajusts_re.match(part_file).group(2)), x_y_ajusts_re.match(part_file).group(3)]), input_dir+part_file, ")"] for part_file in sorted_bunch] connect_png_list = \ [imgmagick_page for imgmagick_pages in png_pages_params for imgmagick_page in imgmagick_pages] output_file = output_dir + sorted_bunch[0].partition(SPLIT_MASK)[0] + ".png" subprocess.check_output([IMGMAGIC] + IMGMAGIC_PARAMS1 + connect_png_list + IMGMAGIC_PARAMS2 + [output_file])</span></span></code> </pre> <br></div></div><br>  Il semblerait que nous ayons maintenant l'ensemble des images qui apparaissent dans le jeu?  Pas du tout - si vous regardez toutes les images connectées de toutes les archives, vous constaterez toujours que certaines sont manquantes, bien qu'elles soient dans le jeu.  Le fait est qu'il existe un autre type de fichier dans le moteur - avec l'extension .b.  C'est un peu une animation avec des images et des sons enregistrés à l'intérieur. <br><br>  Il est assez facile d'obtenir les ressources stockées à l'intérieur, mais, hélas, aucun des décompresseurs de fichiers .b prêts à l'emploi n'a fonctionné dans notre cas comme il se doit.  Soit certains fichiers sont restés décompressés, soit il y a eu des erreurs dues à des noms japonais, et je ne voulais pas démarrer à partir des paramètres régionaux japonais. <br><br>  Ici encore, notre script a été utile.  Depuis lors, nous ne connaissions pas quelque chose comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kaitai Struct</a> , nous avons dû agir presque à partir de zéro. <br><br>  Le format des fichiers .b s'est avéré être simple et, de plus, notre décompresseur devait pouvoir décompresser les ressources uniquement de ce jeu.  Dans d'autres jeux sur le moteur Qlie, des types de ressources supplémentaires sont apparus dans les fichiers .b, mais nous ne nous attarderons pas sur eux en détail. <br><br>  Alors, ouvrez n'importe quel fichier .b dans un éditeur hexadécimal et regardez au début.  Avant d'évaluer, notez que l'ordre des octets de toutes les valeurs numériques sera Little-endian. <br><br><ul><li>  En-tête de fichier ABMP12 </li><li>  Dix octets 0x00 </li><li>  Le titre de la première section abdata12 avec des informations supplémentaires. </li><li>  Huit octets 0x00 </li><li>  Taille de section abdata12, entier de quatre octets.  Vous pouvez le sauter en toute sécurité. </li><li>  En-tête de section Abimage10 </li><li>  Sept octets 0x00 </li><li>  Nombre de fichiers dans une section, entier sur un octet.  Dans ce cas, il y a un fichier dans la section. </li><li>  En-tête de section abgimgdat13 </li><li>  Six octets 0x00 </li><li>  La longueur du nom de fichier à l'intérieur de la section, un entier sur deux octets.  Dans ce cas, la longueur est de 4 octets. </li><li>  Nom de fichier encodé Shift Jis </li><li>  Longueur d'enregistrement de la somme de contrôle du fichier, entier sur deux octets. </li><li>  Somme de contrôle du fichier lui-même. </li><li>  L'octet inconnu semble toujours être 0x03 ou 0x02 </li><li>  Douze octets inconnus, probablement liés à l'animation </li><li>  La taille du fichier png à l'intérieur de la section est un entier de quatre octets. </li></ul><br>  Et enfin, le fichier png lui-même. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/64/v4/yc/64v4ycd37hyu-pyqsxyb2g1ahqa.png"></div><br>  La section absound est de structure similaire à abimage. <br><br><div class="spoiler">  <b class="spoiler_title">Extracteur BMP animé</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # Extract b # AnimatedBMP extractor for Bishoujo Mangekyou game files # by Chtobi and Nazon, 2016 import glob import os import struct import argparse from collections import namedtuple b_hdr = b'abmp12'+bytes(10) signa_len = 16 b_abdata = (b'abdata10'+bytes(8), b'abdata11'+bytes(8), b'abdata12'+bytes(8), b'abdata13'+bytes(8)) b_imgdat = (b'abimgdat10'+bytes(6), b'abimgdat11'+bytes(6), b'abimgdat14'+bytes(6)) b_img = (b'abimage10'+bytes(7), b'abimage11'+bytes(7), b'abimage12'+bytes(7), b'abimage13'+bytes(7), b'abimage14'+bytes(7)) b_sound = (b'absound10'+bytes(7), b'absound11'+bytes(7), b'absound12'+bytes(7)) # not sure about structure of sound11 and sound12 b_snd = (b'absnddat11'+bytes(7), b'absnddat10'+bytes(7), b'absnddat12'+bytes(7)) Abimgdat13_pattern = namedtuple('Abimgdat13', ['signa', 'name_size_len', 'hash_size_len', 'unknown1_len', 'unknown2_len', 'data_size_len']) Abimgdat13 = Abimgdat13_pattern(signa=b'abimgdat13'+bytes(6), name_size_len=2, hash_size_len=2, unknown1_len=1, unknown2_len=12, data_size_len=4) Abimgdat14_pattern = namedtuple('Abimgdat14', ['signa', 'name_size_len', 'hash_size_len', 'unknown1_len', 'data_size_len']) Abimgdat14 = Abimgdat14_pattern(signa=b'abimgdat14'+bytes(6), name_size_len=2, hash_size_len=2, unknown1_len=77, data_size_len=4) Abimgdat_pattern = namedtuple('Abimgdat', ['name_size_len', 'hash_size_len', 'unknown1_len', 'data_size_len']) # probably, abimgdat10,abimgdat11 and others Other_imgdat = Abimgdat_pattern(name_size_len=2, hash_size_len=2, unknown1_len=1, data_size_len=4) Absnddat11_pattern = namedtuple('Absnddat11', ['signa', 'name_size_len', 'hash_size_len', 'unknown1_len', 'data_size_len']) Absnddat11 = Absnddat11_pattern(signa=b'absnddat11'+bytes(7), name_size_len=2, hash_size_len=2, unknown1_len=1, data_size_len=4) def create_parser(): arg_parser = argparse.ArgumentParser(prog='AnimatedBMP extractor\n', usage='extract_b input_file_name output_dir\n', description='AnimatedBMP extractor for QLIE engine *.b files.\n') arg_parser.add_argument('input_file_name', nargs='+', help="Input file with full path(wildcards are supported).\n") arg_parser.add_argument('output_dir', nargs=1, help="Output directory.\n") return arg_parser def check_type(file_buf): if file_buf.startswith(b'\x89' + b'PNG'): return '.png' elif file_buf.startswith(b'BM'): return '.bmp' elif file_buf.startswith(b'JFIF', 6): return '.jpg' elif file_buf.startswith(b'IMOAVI'): return '.imoavi' elif file_buf.startswith(b'OggS'): return '.ogg' elif file_buf.startswith(b'RIFF'): return '.wav' else: return '' def bytes_shiftjis_to_utf8(shiftjis_bytes): shiftjis_str = shiftjis_bytes.decode('shift_jis', 'strict') utf_str = shiftjis_str.encode('utf-8', 'strict').decode('utf-8', 'strict') return utf_str def check_signa(f_buffer): if f_buffer.endswith(b_abdata): return 'abdata' elif f_buffer.endswith(b_img): return 'abimgdat' elif f_buffer.endswith(b_sound): return 'absound' def prepare_filename(out_file_name, out_dir, postfix=''): ready_name = out_dir + os.path.basename(out_file_name) + postfix return ready_name def create_file(file_name_hndl, out_buffer): if len(out_buffer) != 0: with open(file_name_hndl, 'wb') as ext_file: ext_file.write(out_buffer) else: print("Zero file. Skipped.") def check_file_header(file_handle, bytes_num): file_handle.seek(0) readed_bytes = file_handle.read(bytes_num) if readed_bytes == b_hdr: print("File is valid abmp") return True else: print("Can't read header. Probably, wrong file...") return False if __name__ == '__main__': parser = create_parser() arguments = parser.parse_args() all_b_files = glob.glob(arguments.input_file_name[0]) output_dir = arguments.output_dir[0] for b_file in all_b_files: file_buffer = bytearray(b'') with open(b_file, 'rb') as bfile_h: check_file_header(bfile_h, len(b_hdr)) read_byte = bfile_h.read(1) file_buffer.extend(read_byte) while read_byte: read_byte = bfile_h.read(1) file_buffer.extend(read_byte) # Finding content sections signature check_result = check_signa(file_buffer) if check_result: if check_result == 'abdata': file_buffer = bytearray(b'') read_length = bfile_h.read(4) size = struct.unpack('&lt;L', read_length)[0] file_buffer.extend(bfile_h.read(size)) # Adding _abdata to separate from other parts outfile_name = prepare_filename(b_file, output_dir, '_abdata') create_file(outfile_name, file_buffer) elif check_result == 'abimgdat': images_number = struct.unpack('B', bfile_h.read(1))[0] # Number of pictures in section for i1 in range(images_number): file_buffer = bytearray(b'') file_name = '' imgsec_hdr = bfile_h.read(signa_len) if imgsec_hdr == Abimgdat13.signa: file_name_size = struct.unpack('&lt;H', bfile_h.read(Abimgdat13.name_size_len))[0] # Decode filename to utf8 file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) # CRC size hash_size = struct.unpack('&lt;H', bfile_h.read(Abimgdat13.hash_size_len))[0] # Picture CRC (don't need it) pic_hash = bfile_h.read(hash_size) unknown1 = bfile_h.read(Abimgdat13.unknown1_len) unknown2 = bfile_h.read(Abimgdat13.unknown2_len) pic_size = struct.unpack('&lt;L', bfile_h.read(Abimgdat13.data_size_len))[0] print("pic_size:", pic_size) file_buffer.extend(bfile_h.read(pic_size)) elif imgsec_hdr == Abimgdat14.signa: file_name_size = struct.unpack('&lt;H', bfile_h.read(Abimgdat14.name_size_len))[0] file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) hash_size = struct.unpack('&lt;H', bfile_h.read(Abimgdat14.hash_size_len))[0] pic_hash = bfile_h.read(hash_size) bfile_h.seek(Abimgdat14.unknown1_len, os.SEEK_CUR) pic_size = struct.unpack('&lt;L', bfile_h.read(Abimgdat14.data_size_len))[0] file_buffer.extend(bfile_h.read(pic_size)) else: # probably abimgdat10, abimgdat11... file_name_size = struct.unpack('&lt;H', bfile_h.read(Other_imgdat.name_size_len))[0] file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) hash_size = struct.unpack('&lt;H', bfile_h.read(Other_imgdat.hash_size_len))[0] pic_hash = bfile_h.read(hash_size) bfile_h.seek(Other_imgdat.unknown1_len, os.SEEK_CUR) pic_size = struct.unpack('&lt;L', bfile_h.read(Other_imgdat.data_size_len))[0] file_buffer.extend(bfile_h.read(pic_size)) for i, letter in enumerate(file_name): # Replace any unusable symbols from filename with _ if letter == '&lt;' or letter == '&gt;' or letter == '*' or letter == '/': file_name = file_name.replace(letter, "_") # Checking file signature and adding proper extension outfile_name = prepare_filename(b_file, output_dir, '_' + file_name + check_type(file_buffer)) create_file(outfile_name, file_buffer) file_buffer = bytearray(b'') elif check_result == 'absound': sound_files_number = struct.unpack('B', bfile_h.read(1))[0] for i2 in range(sound_files_number): file_buffer = bytearray(b'') file_name = '' sndsec_hdr = bfile_h.read(signa_len) if sndsec_hdr == Absnddat11.signa: file_name_size = struct.unpack('&lt;H', bfile_h.read(Absnddat11.name_size_len))[0] file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) hash_size = struct.unpack('&lt;H', bfile_h.read(Absnddat11.hash_size_len))[0] snd_hash = bfile_h.read(hash_size) unknown1 = bfile_h.read(Absnddat11.unknown1_len) snd_size = struct.unpack('&lt;L', bfile_h.read(Absnddat11.data_size_len))[0] file_buffer.extend(bfile_h.read(snd_size)) else: file_name_size = struct.unpack('&lt;H', bfile_h.read(Absnddat11.name_size_len))[0] file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) hash_size = struct.unpack('&lt;H', bfile_h.read(Absnddat11.hash_size_len))[0] snd_hash = bfile_h.read(hash_size) unknown1 = bfile_h.read(Absnddat11.unknown1_len) snd_size = struct.unpack('&lt;L', bfile_h.read(Absnddat11.data_size_len))[0] file_buffer.extend(bfile_h.read(snd_size)) for i, letter in enumerate(file_name): if letter == '&lt;' or letter == '&gt;' or letter == '*' or letter == '/': file_name[i] = '_' outfile_name = prepare_filename(b_file, output_dir, '_' + file_name + check_type(file_buffer)) print("create absound") create_file(outfile_name, file_buffer) file_buffer = bytearray(b'')</span></span></code> </pre><br></div></div><br>  Le script devrait décompresser automatiquement les fichiers png, jpg, bmp, ogg et wav trouvés.  Mais en plus de cela, des fichiers imoavi inconnus se trouvent également à l'intérieur. <br><br>  L'essentiel est que dans le jeu, toutes les animations sont faites soit sous forme de vidéo à part entière au format ogv, soit sous forme d'images animées par le moteur qui sont enregistrées dans des fichiers .b, ou sous forme de séquences animées de fichiers jpg au format imoavi. <br><br>  Dans ce cas, nous étions également intéressés par les images jpg, nous avons donc dû les gérer également. <br><br>  Il y a deux sections dans imoavi: SOUND et MOVIE.  Dans la section MOVIE, 47 octets après l'en-tête, il y a quatre octets de la taille du fichier jpg.  Les fichiers sont écrits les uns après les autres dans leur forme d'origine, séparés par une séquence de 19 octets, où la taille du fichier suivant est enregistrée. <br><br>  L'imoavi exprimé dans le jeu n'a pas été rencontré, donc la section SON est toujours vide. <br><br>  Eh bien, depuis que nous avons commencé à retirer toutes les ressources du jeu, en même temps, un petit script a été écrit pour retirer jpg d'imoavi. <br><br><div class="spoiler">  <b class="spoiler_title">Extracteur Imoavi</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # Extract imoavi # Imoavi extractor for Bishoujo Mangekyou game files # by Chtobi and Nazon, 2016 import glob import os import struct import argparse imoavi_hdr = b'IMOAVI' hdr_len = len(imoavi_hdr) def create_file(file_name, out_buffer, wr_mode='wb'): if len(out_buffer) != 0: with open(file_name, wr_mode) as ext_file: ext_file.write(out_buffer) else: print("Zero file. Skipped.") def prepare_filename(file_name, out_dir, postfix=''): ready_name = out_dir + os.path.basename(file_name) + postfix return ready_name def create_parser(): arg_parser = argparse.ArgumentParser(prog='Imoavi extractor\n', usage='extract_imoavi input_file_name output_dir\n', description='Imoavi extractor for QLIE engine *.imoavi files.\n') arg_parser.add_argument('input_file_name', nargs='+', help="Input file with full path(wildcards are supported).\n") arg_parser.add_argument('output_dir', nargs='+', help="Output directory.\n") return arg_parser if __name__ == '__main__': parser = create_parser() arguments = parser.parse_args() all_imoavi = glob.glob(arguments.input_file_name[0]) output_dir = arguments.output_dir[0] for imoavi_f in all_imoavi: file_buffer = bytearray(b'') with open(imoavi_f, 'rb') as imoavi_h: # Read imoavi file header imoavi_h.read(hdr_len) imoavi_h.seek(2, os.SEEK_CUR) # 0x00 imoavi_h.seek(1, os.SEEK_CUR) # 0x64 imoavi_h.seek(3, os.SEEK_CUR) # 0x00 imoavi_h.seek(5, os.SEEK_CUR) # SOUND imoavi_h.seek(3, os.SEEK_CUR) # 0x00 imoavi_h.seek(1, os.SEEK_CUR) # 0x64 imoavi_h.seek(11, os.SEEK_CUR) imoavi_h.seek(5, os.SEEK_CUR) # Movie imoavi_h.seek(3, os.SEEK_CUR) # 00 ?? imoavi_h.seek(1, os.SEEK_CUR) # 0x64 imoavi_h.seek(3, os.SEEK_CUR) # 0x00 ?? imoavi_h.seek(4, os.SEEK_CUR) # ?? imoavi_h.seek(1, os.SEEK_CUR) # Number of jpg files in section imoavi_h.seek(4, os.SEEK_CUR) # 0x00 imoavi_h.seek(1, os.SEEK_CUR) # 0x05 ??? imoavi_h.seek(2, os.SEEK_CUR) # 0x00 ?? imoavi_h.seek(4, os.SEEK_CUR) # 720 ?? imoavi_h.seek(4, os.SEEK_CUR) # Full size without header? to_next_size = struct.unpack('&lt;L', imoavi_h.read(4))[0] # Bytes till next header imoavi_h.seek(16, os.SEEK_CUR) # 0x00 jpg_size = struct.unpack('&lt;L', imoavi_h.read(4))[0] imoavi_h.seek(4, os.SEEK_CUR) # 0x00 file_num = 0 file_buffer.extend(imoavi_h.read(jpg_size)) outfile_name = prepare_filename(imoavi_f, output_dir, '_' + (str(file_num)).zfill(3) + '.jpg') create_file(outfile_name, file_buffer) while to_next_size != 0: file_buffer = bytearray(b'') to_next_size = struct.unpack('&lt;L', imoavi_h.read(4))[0] if to_next_size == 24: # 0x1C header for index part file_buffer.extend(imoavi_h.read(to_next_size)) outfile_name = prepare_filename(imoavi_f, output_dir, '_' + '.index') create_file(outfile_name, file_buffer, 'ab') # concatenate with index file else: imoavi_h.seek(2, os.SEEK_CUR) # unknown imoavi_h.seek(2, os.SEEK_CUR) # Unknown, almost always FF FF or FF FE file_num = struct.unpack('B', imoavi_h.read(1))[0] # File number imoavi_h.seek(11, os.SEEK_CUR) # 0x00 jpg_size = struct.unpack('&lt;L', imoavi_h.read(4))[0] imoavi_h.seek(4, os.SEEK_CUR) # 0x00 file_buffer.extend(imoavi_h.read(jpg_size)) outfile_name = prepare_filename(imoavi_f, output_dir, '_' + (str(file_num)).zfill(3) + '.jpg') create_file(outfile_name, file_buffer)</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Après le déballage, vous pouvez vous assurer que l'animation de l'écran de démarrage dans le menu est stockée uniquement dans le fichier 1_ タ イ ト ル 画面 ム ー ビ ー .b au format imoavi. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/81/_r/lo81_rlqvf55nia7relrkbsckey.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est tout avec les ressources du jeu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malheureusement, le processus de traduction a révélé plusieurs nuances plus désagréables qui n'ont pas pu être surmontées. Le jeu, comme je l'ai déjà écrit, ne prend pas en charge les encodages Unicode. Par conséquent, tout le texte traduit est affiché avec le mauvais espacement des lettres. Il y a eu quelques problèmes supplémentaires avec le backpacking des fichiers et le démarrage d'un jeu sans changer l'encodage système en japonais. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À un moment donné, nous (ou plutôt, celui qui était responsable de la partie technique de la traduction dans notre équipe) avons pensé: peut-être ne devrions-nous pas rester avec l'ancien moteur, mais porter le roman sur le moteur Renpy, tout en obtenant une plateforme multiplateforme? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peut-être étions-nous pressés, mais à un moment donné, c'était dommage de quitter ce que nous avions commencé et il ne restait plus qu'à terminer la traduction.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'avons-nous rencontré lors du portage? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À ce sujet dans la deuxième partie. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liens: </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos scripts bitbucket </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À propos de la </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">table de codage Shift </font></font></a> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">Jis du moteur Qlie japonais En </font></a></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">savoir plus sur le problème du transcodage de Shift Jis vers UTF-8 </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asmodean exfp3_v3</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426431/">https://habr.com/ru/post/fr426431/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426421/index.html">EHCI humainement en russe</a></li>
<li><a href="../fr426423/index.html">mmWave sur smartphones: comment Qualcomm a rendu possible l'impossible</a></li>
<li><a href="../fr426425/index.html">Toute la vérité sur RTOS. Article # 14. Sections de mémoire: introduction et services de base</a></li>
<li><a href="../fr426427/index.html">Des trucs utiles pour "bourrer": une petite sélection à petits prix</a></li>
<li><a href="../fr426429/index.html">Installation de FreeSWITCH 1.8 sur Debian 9 (Raspbian Stretch, l'image de base du système Smart Home de MajorDoMo sur Rasbperri Pi)</a></li>
<li><a href="../fr426433/index.html">Délicieux SMM pour le restaurant</a></li>
<li><a href="../fr426435/index.html">Les meilleurs spécialistes sont ceux que j'ai préparés moi-même: un cours de test de jeu par des experts du groupe Mail.Ru</a></li>
<li><a href="../fr426437/index.html">Comment la reconnaissance faciale vous aide à trouver des téléphones de test</a></li>
<li><a href="../fr426439/index.html">Falsification de graphiques, substitution de cotations et manipulation de prix: comment pirater des applications pour le trading en bourse</a></li>
<li><a href="../fr426441/index.html">Mail.Ru Group 20 ans: points de contrôle code et technologie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>