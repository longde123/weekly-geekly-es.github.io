<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëèüèª üë∞üèæ üåí D√©montage du moteur de roman visuel Qlie üéâ üï≥Ô∏è üçí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Une traduction amateur d'histoires courtes visuelles, par rapport aux traductions d'autres jeux, a un certain nombre de fonctionnalit√©s et implique de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©montage du moteur de roman visuel Qlie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426431/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/bb/sq/zf/bbsqzfse3pqjvnyef8jnfv3lecy.png"></div><br><br>  Une traduction amateur d'histoires courtes visuelles, par rapport aux traductions d'autres jeux, a un certain nombre de fonctionnalit√©s et implique de travailler avec beaucoup de texte.  Peut-√™tre que la grande majorit√© de tous les romans visuels ont √©t√© publi√©s en japonais, seuls quelques-uns ont √©t√© traduits en anglais (officiellement ou par des amateurs), et encore moins ont √©t√© traduits dans d'autres langues. <br><br>  Par cons√©quent, lorsque vous travaillez avec la traduction, vous devez traiter avec des moteurs japonais, dont beaucoup ne sont pas tr√®s conviviaux pour les localisateurs.  Pour cette raison, on se rend rapidement compte que la pr√©sence de comp√©tences en traduction, la connaissance de la langue, un grand enthousiasme et du temps libre ne signifie pas que la version traduite du jeu verra bient√¥t le jour. <br><a name="habracut"></a><br>  En gros, le processus de traduction de n'importe quel jeu (et pas seulement des nouvelles visuelles) implique: <br><br><ul><li>  D√©ballage des ressources du jeu (si elles ne sont pas dans le domaine public) </li><li>  Traduction des pi√®ces n√©cessaires </li><li>  Transfert emballage inverse </li></ul><br>  Cependant, dans le cas des nouvelles visuelles japonaises, cela ressemble g√©n√©ralement √† ceci: <br><br><ul><li>  D√©ballage des ressources du jeu </li><li>  Traduction de la partie texte du jeu (script du jeu) </li><li>  Traduction de la partie graphique du jeu </li><li>  Transfert emballage inverse </li><li>  Modification du moteur pour le faire fonctionner avec du contenu traduit </li></ul><br>  J'esp√®re que notre exp√©rience sera utile √† quelqu'un. <br><br>  En 2013 (et peut-√™tre plus t√¥t), j'ai d√©cid√© de traduire du japonais le roman visuel Bishoujo Mangekyou-Norowareshi Densetsu no Shoujo- (Áæé Â∞ëÂ•≥ ‰∏á ËèØ Èè° - Âë™ „Çè „Çå „Åó ‰ºù Ë™¨ „ÅÆ Â∞ëÂ•≥ -).  J'avais d√©j√† de l'exp√©rience dans la traduction de jeux, mais auparavant je ne devais traduire que des nouvelles sur des moteurs relativement simples et bien connus comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kirikiri</a> . <br><br>  Ici, notre √©quipe de traducteurs a d√ª ouvrir le moteur de cette nouvelle, avant m√™me que nous arrivions au texte lui-m√™me. <br><br>  Commen√ßons par une description du fichier .exe, o√π les mots QLIE et IMOSURUME sont mentionn√©s.  Le fichier lui-m√™me contient la ligne FastMM Borland Edition 2004, 2005 Pierre le Riche, ce qui signifie que le moteur est tr√®s probablement √©crit en Delphi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kx/ss/sg/kxsssg_foyhzeykfu1e4s5pneok.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zo/ge/zc/zogezc8m47t1cflh-yqpzl85fby.png"></div><br>  Une recherche rapide sur Google r√©v√®le que Qlie est le nom du moteur de roman visuel publi√© par Warmth Entertainment.  Apparemment, IMOSURUME est le nom interne du moteur de script et Qlie est le nom commercial.  Il existe un site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qlie.net</a> , qui r√©pertorie les jeux sortis sur ce moteur et le site officiel de Warmth Entertainment. <br><br>  Mais nulle part dans le domaine public, il n'y a ni outils officiels pour travailler avec le moteur, ni documentation pour celui-ci, ce qui est attendu. <br><br>  Par cons√©quent, vous devez g√©rer le jeu vous-m√™me, en vous appuyant sur des utilitaires non officiels.  Pour commencer, vous devriez trouver toutes les parties du jeu qui doivent √™tre traduites. <br><br>  Les archives de jeu se trouvent dans les fichiers data0.pack, data1.pack et data7.pack dans le sous-dossier \ GameData.  Les √©conomiseurs d'√©cran se trouvent dans le dossier \ GameData \ Movie, mais vous pouvez toujours les laisser seuls. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gr/fh/on/grfhont7xq1rascbvzu8v1mhkec.png"></div><br>  L'√©diteur hexad√©cimal montre qu'il n'y a pas d'en-t√™tes reconnaissables pour les archives du jeu .pack, mais √† la fin du fichier, il y a un morceau similaire √† la table des mati√®res et √† l'√©tiquette FilePackVer3.0 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yf/qd/1q/yfqd1qyy7ozx0ygvq_bj_tmkms4.png"></div><br>  Heureusement, pour ce format, il existe d√©j√† un d√©balleur et m√™me pas un.  Nous avons utilis√© la console exfp3_v3 de asmodean. <br><br>  Le d√©ballage n'est pas aussi simple qu'il y para√Æt.  √âtant donn√© que le moteur prend en charge plusieurs formats d'archive (FilePackVer1.0, FilePackVer1.0, FilePackVer3.0), et dans ce cas, FilePackVer3.0 est utilis√©, pour le d√©compactage correct, vous aurez √©galement besoin d'un fichier de cl√© sp√©cial key.fkey, qui a chiffr√© l'archive.  Il se trouve dans le sous-dossier \ Dll <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fa/fq/qe/fafqqeqgfwisqr1ijhg9qpcmsm4.png"></div><br>  De plus, exfp3_v3 devrait clarifier l'archive de quel jeu il est en train de d√©baller. <br>  Par cons√©quent, vous devez √©galement sp√©cifier le num√©ro de jeu dans la liste propos√©e par le d√©compresseur (les jeux de la s√©rie Bishoujo Mangekyou sont l√† sous le num√©ro 15), ou sp√©cifier le fichier ex√©cutable du jeu comme troisi√®me param√®tre du d√©compresseur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9r/nr/-z/9rnr-zngqxajz8pysxwv3v8u8gk.png"></div><br>  D√©j√† apr√®s avoir d√©ball√© les fichiers du jeu, une pens√©e logique est apparue: comment √† l'avenir comment remballer le jeu avec une traduction pr√™te?  Apr√®s tout, le d√©balleur ne prend pas en charge l'op√©ration inverse. <br>  √Ä notre demande, w8m (merci beaucoup pour cela) a ajout√© la possibilit√© de compresser les archives du jeu dans son programme arc_conv.exe.  Il suffit de regrouper tous les fichiers modifi√©s dans une nouvelle archive (par exemple, data8.pack), de le placer dans le dossier GameData, et ils se lanceront automatiquement dans le jeu. <br><br>  Retour aux ressources d√©compress√©es.  Les fichiers de script de jeu de l'archive data0.pack se trouvent dans le sous-dossier \ scenario \ ks_01 \ <br><br>  Tous les fichiers de script avec l'extension .s sont encod√©s loin de l'encodage Shift Jis le plus pratique, et le moteur ne prend en charge aucun encodage Unicode.  Les lignes de la traduction ressemblent approximativement √† celles-ci: <br><br><pre><code class="python hljs">„Äê„Ç≠„É™„Ç®„Äë ÔºÖ<span class="hljs-number"><span class="hljs-number">1</span></span>_kiri1478ÔºÖ „Äå„Å∏„Åà‚Ä¶‚Ä¶ÂàÜ„Åã„Å£„Å¶„ÅÑ„Çã„Åò„ÇÉ„Å™„ÅÑ„Äç ÁßÅ„ÅåÁåÆ‰∏ä„Åó„Åü„É≠„Ç∑„Ç¢„É≥„ÉÜ„Ç£„Éº„ÇíË¶ã„Å¶„ÄÅ„Ç≠„É™„Ç®„ÅØÂ¨â„Åó„Åù„ÅÜ„Å´ÁõÆ„ÇíÁ¥∞„ÇÅ„Çã„ÄÇ ^cface,,Ëµ§ÁõÆÂæÆÁ¨ë<span class="hljs-number"><span class="hljs-number">01</span></span> „Äê„Ç≠„É™„Ç®„Äë ÔºÖ<span class="hljs-number"><span class="hljs-number">1</span></span>_kiri1479ÔºÖ „ÄåÊó•Êú¨‰∫∫„ÅØ„ÄÅ„Ç∏„É£„É†„ÇíÁ¥ÖËå∂„Å´ÂÖ•„Çå„Å¶È£≤„ÇÄ„ÅÆ„Åå„ÄÅ„É≠„Ç∑„Ç¢„É≥„ÉÜ„Ç£„Éº„Å†„Å®ÂãòÈÅï„ÅÑ„Åó„Å¶„ÅÑ„Çã‰∫∫„ÅåÂ§ö„ÅÑ„ÅÆ„Å†„Åë„Çå„Å©‚Ä¶‚Ä¶„Äç</code> </pre> <br>  Vous remarquerez peut-√™tre que chaque phrase en japonais est pr√©c√©d√©e du nom du h√©ros entre parenth√®ses japonaises.  („Äê„Äë), Qui prononce cette phrase (dans le jeu elle s'affiche en haut de la fen√™tre avec du texte).  Ou, si ce sont les mots de l'auteur, le nom n'est pas ajout√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ws/d_/dz/wsd_dzwzrz-sjk_0shl7zw3ov5k.png"></div><br>  Mais il reste des √©quipes de service. <br><br>  Les commandes du moteur dans le script rappellent quelque peu le langage de balisage TeX, mais sont beaucoup plus intuitives et peu pratiques par rapport aux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commandes</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kirikiri</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RenPy</a> . <br><br>  En voici quelques uns: <br><br>  <code>@@@</code> est un triple chien.  Souvent, les fichiers de script commencent par cette commande.  Apparemment, le chargement des d√©finitions √† partir de fichiers tiers. <br><br>  Par exemple: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@@@Library\Avg\header.s</span></span></code> </pre> <br>  <code>@@</code> est un chien double.  L'√©tiquette dans le fichier de script.  Vous pourrez y acc√©der ult√©rieurement. <br><br>  <code>ÔºÖ1_kiri1478ÔºÖ</code> - lire le fichier vocal.  Ces commandes sont ins√©r√©es entre le nom du h√©ros et le texte qui s'affiche √† l'√©cran.  "1_kiri1478" - dans ce cas, le nom du fichier du dossier \ voice \ du fichier data1.pack Il est int√©ressant que l'√©quipe utilise le pourcentage japonais (ÔºÖ), plut√¥t que le pourcentage habituel. <br><br>  <code>^savedate, ^saveroute, ^savescene,</code> - trois √©quipes les plus susceptibles d'√™tre utilis√©es dans le syst√®me de sauvegarde du jeu et qui doivent saisir des informations sur le lieu et l'heure √† laquelle le joueur a √©t√© enregistr√© dans la sauvegarde. <br><br>  Par exemple: <br><br><pre> <code class="python hljs">^savedate,<span class="hljs-string"><span class="hljs-string">"ÁèæÂú®"</span></span> ^saveroute,<span class="hljs-string"><span class="hljs-string">"ÁæéÂ∞ëÂ•≥‰∏áËèØÈè°ÔºçÔºëÔºç"</span></span> ^savescene,<span class="hljs-string"><span class="hljs-string">"Âë™„Çè„Çå„Åó‰ºùË™¨„ÅÆÂ∞ëÂ•≥ „Ç™„Éº„Éó„Éã„É≥„Ç∞"</span></span></code> </pre> <br>  C'est-√†-dire, date: pr√©sent, branche: Bishoujo Mangekyou -1-, sc√®ne: Norowareshi Densetsu no Shoujo Opening.  Ces donn√©es auraient d√ª √™tre affich√©es dans la fente de sauvegarde, mais apparemment, les d√©veloppeurs ont d√©cid√© de l'abandonner.  Par cons√©quent, <code>^saveroute</code> dans toutes les parties du script, <code>^savedate</code> change du "moment pr√©sent" en "r√™ves" et dans <code>^savescene</code> jours de jeu (ou plut√¥t les nuits) changent. <br><br>  <code>^facewindow,</code> - √©tat de la zone de texte avec le texte affich√© √† l'√©cran.  (Montr√© - 1 ou pas - 0) <br><br>  <code>^sload,</code> - jouez les sons du jeu depuis le dossier \ sound \ sur le canal correspondant. <br><br><pre> <code class="python hljs">sload,Env1,‚óÜ„Çª„Éü<span class="hljs-number"><span class="hljs-number">01</span></span>„Ç¢„Éñ„É©„Çº„Éü</code> </pre> <br>  Jouer des cigales sur Env1 <br><br>  L'√©quipe a deux param√®tres facultatifs, le premier est responsable de la boucle du son, et le second reste un myst√®re, mais il est rarement utilis√© dans le jeu. <br><br><pre> <code class="python hljs">^sload,SE1,‚ñ†„ÇØ„ÉÅ„É•Èü≥<span class="hljs-number"><span class="hljs-number">01</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Lecture du son de bouclage sur le canal SE1. <br><br>  <code>^eeffect</code> - affiche un effet sp√©cial sur l'√©cran pendant un certain nombre de secondes.  Apparemment, il prend en charge la sortie s√©quentielle de plusieurs effets. <br><br><pre> <code class="python hljs">^eeffect,WhiteFlash</code> </pre> <br>  L'effet d'un flash blanc. <br><br>  <code>^ffade</code> - effet de transition lors du changement d'√©cran. <br>  Il a tout un tas de param√®tres suppl√©mentaires, mais seuls quelques-uns sont vraiment utiles: le nom de l'effet de transition, une image suppl√©mentaire, si n√©cessaire, et le temps d'ach√®vement de la transition. <br><br><pre> <code class="python hljs">^ffade,Overlap,,<span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> <br>  Dissoudre une image dans une autre, en 1 seconde. <br><br>  <code>^iload</code> - charge l'image d'arri√®re-plan sur l'√©cran.  L'image peut se voir attribuer un identifiant auquel se r√©f√©rer √† l'avenir. <br><br><pre> <code class="python hljs">^iload,BG1,<span class="hljs-number"><span class="hljs-number">0</span></span>_black.png</code> </pre> <br>  Fichier de sortie 0_black.png en arri√®re-plan avec l'ID BG1 <br><br>  <code>^we</code> et <code>^wd</code> - activer et d√©sactiver l'image dans la fen√™tre. <br><br>  <code>^facewindow,1</code> et <code>^facewindow,0</code> Active et d√©sactive l'image du h√©ros dans la bo√Æte de dialogue. <br><br>  <code>^mload</code> - lire de la musique sur un canal sp√©cifique. <br><br><pre> <code class="python hljs">^mload,BGM1,nbgm13</code> </pre> <br>  Lecture de la piste nbgm13 sur le canal BGM1 <br><br>  Quelques-unes des √©quipes les plus importantes: <br>  <code>\jmp</code> - saute √† l'√©tiquette avec le nom sp√©cifi√©. <br><br>  <code>^select</code> - affiche une fen√™tre de s√©lection sur l'√©cran o√π le joueur doit s√©lectionner l'une des options. <br><br>  Par exemple: <br><br><pre> <code class="python hljs">^select, ,  \jmp,<span class="hljs-string"><span class="hljs-string">"@@route01a"</span></span>+ResultBtnInt[<span class="hljs-number"><span class="hljs-number">0</span></span>] @@route01a0</code> </pre> <br>  Ici, la transition sera effectu√©e apr√®s la r√©ponse √† la question et le num√©ro de r√©ponse (0 ou 1) est renvoy√© par ResultBtnInt [0].  Par cons√©quent, <code>\jmp</code> d√©placera l'histoire vers le libell√© @@ route01a + num√©ro de r√©ponse.  Autrement dit, @@ route01a0 ou @@ route01a1 <br><br>  Une caract√©ristique d√©sagr√©able est que la virgule habituelle dans ces commandes sert de s√©parateur et ne peut pas √™tre utilis√©e dans les options de r√©ponse elles-m√™mes.  Les Japonais n'ont pas un tel probl√®me, ils utilisent la virgule japonaise („ÄÅ).  Dans ce cas, nous pouvons remplacer la virgule par ‚Äö(U + 201A SINGLE LOW-9 QUOTATION MARK). <br><br>  Par exemple: <br><br><pre> <code class="python hljs">^select, ‚Äö  , ‚Äö </code> </pre> <br>  Les √©quipes restantes ne sont pas si importantes en premi√®re approximation. <br><br>  Bien s√ªr, avant de traduire le script, vous devez le transcoder en quelque chose de plus pratique, par exemple en UTF-8, afin de combiner des caract√®res cyrilliques et japonais. <br><br>  Apr√®s avoir chang√© le moteur (√† propos de cette partie suivante), le jeu per√ßoit √† la fois le texte russe et le japonais.  Mais pour l'instant, pour des raisons de compatibilit√©, vous devez coder les caract√®res japonais dans Shift Jis et les caract√®res cyrilliques dans le codage cp1251. <br><br>  Nous avons rapidement esquiss√© un programme en Python pour le transcodage en tenant compte de l'alphabet cyrillique: <br><br><div class="spoiler">  <b class="spoiler_title">UTF8 √† cp1251 et ShiftJIS</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # UTF8 to cp1251 and ShiftJIS recoder # by Chtobi and Nazon, 2016 import codecs import argparse from os import path JAPANESE_CODEPAGE = 'shift_jis' UTF_CODEPAGE = 'utf-8' RUS_CODEPAGE = 'cp1251' def nonrus_handler(e): if e.object[e.start:e.end] == 'ÔΩû': # UTF-8: 0xEFBD9E -&gt; SHIFT-JIS: 0x8160 japstr_byte = b'\x81\x60' elif e.object[e.start:e.end] == 'Ôºç': # UTF-8: 0xEFBC8D -&gt; SHIFT-JIS: 0x817C japstr_byte = b'\x81\x7c' else: japstr_byte = (e.object[e.start:e.end]).encode(JAPANESE_CODEPAGE) return japstr_byte, e.end if __name__ == '__main__': arg_parser = argparse.ArgumentParser(prog="Recode to cp1251 and ShiftJIS", description="Program to encode UTF8 text file to " "cp1251 for all cyrillic symbols and ShiftJIS for others. " "Output file will be inputfilename.s", usage="recode_to_cp1251_shiftjis.py file_name") arg_parser.add_argument('file_name', nargs=1, type=argparse.FileType(mode='r', bufsize=-1), help="Input text file name. Only files coded in UTF8 are allowed.\n") codecs.register_error('nonrus_handler', nonrus_handler) input_name = arg_parser.parse_args().file_name[0].name output_name = path.splitext(input_name)[0] + ".s" with open(input_name, 'rt', encoding=UTF_CODEPAGE) as input_file: with open(output_name, 'wb') as output_file: for line in input_file: for char1 in line: bytes_out = bytes(line, UTF_CODEPAGE) output_file.write(char1.encode(RUS_CODEPAGE, "nonrus_handler")) print("Done.")</span></span></code> </pre><br></div></div><br>  Cependant, il y a eu quelques probl√®mes.  Le programme, en essayant de recoder le symbole ¬´tilde¬ª U (U + FF5E FULLWIDTH TILDE), a g√©n√©r√© une erreur ¬´UnicodeEncodeError: le codec¬´ Shift Jis ¬ªne peut pas coder le caract√®re¬´ \ uff5e ¬ªen position 0: s√©quence multi-octets ill√©gale¬ª <br><br>  Au d√©but, j'ai p√©ch√© sur Python, mais √† la fin j'ai d√©couvert une nuance plut√¥t inhabituelle.  Il existe une ambigu√Øt√© entre les m√©thodes de corr√©lation des codages japonais Unicode et non Unicode selon l'impl√©mentation sp√©cifique. <br><br>  Par cons√©quent, Windows associe le caract√®re Shift Jis au code 0x8160 avec l'unicode ÔΩû (U + FF5E FULLWIDTH TILDE), et d'autres transcodeurs (par exemple, l'utilitaire iconv) corr√®lent le m√™me caract√®re avec „Äú (U + 301C WAVE DASH), selon le tableau de rapport Unicode officiel - <a href="">ftp://ftp.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/JIS/SHIFT JIS.TXT</a> <br><br>  Pour d√©terminer la correspondance entre les personnages, Microsoft a apparemment d√©cid√© d'utiliser les sch√©mas de leur encodage cp932, qui est une version √©tendue de Shift Jis. <br><br>  La m√™me situation se produit avec le code de caract√®re 0x817C, qui est cod√© en UTF8 en tant que - (U + FF0D FULLWIDTH HYPHEN-MOINS) sous Windows, ou en tant que - (U + 2212 SIGNE MOINS) dans iconv. <br><br>  √âtant donn√© que tous les fichiers de script ont √©t√© convertis pour la premi√®re fois de Shift Jis en UTF8 √† l'aide de Notepad ++ (et il utilise la table de correspondance adopt√©e dans Windows), lors de la reconversion d'UTF8 en Shift Jis via notre programme Python, l'erreur de conversion notoire est apparue. <br><br>  Par cons√©quent, il √©tait n√©cessaire de prendre en compte la survenue de conditions ÔΩû et - distinctes. <br><br>  Il y avait d'autres d√©fauts mineurs - par exemple, les ellipses ... (U + 2026 ELLIPSIS HORIZONTAL) a √©t√© remplac√© par les ellipses cyrilliques de cp1251, et non les japonais de Shift Jis. <br><br>  Apr√®s avoir traduit le texte, vous pouvez continuer √† travailler avec les graphiques du jeu. <br><br>  Les fichiers graphiques du jeu sont dans les m√™mes archives de pack, mais apr√®s le d√©ballage, ils doivent encore travailler dur.  Par exemple, presque toutes les images png sont d√©compress√©es sous forme de fichiers du type sample + DPNG000 + x32y0.png En d'autres termes, les images png sont d√©coup√©es en bandes horizontales de 88 cm d'√©paisseur et chaque bande est √©crite dans un fichier s√©par√©.  Le nom du fichier indique le num√©ro de s√©rie de la bande (DPNG000 ... 009) et les coordonn√©es x, y. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gj/ak/x_/gjakx_76ep3syu_gf9qfobolmj8.png"></div><br>  Je me demande toujours pourquoi c'√©tait n√©cessaire.  Si pour la difficult√© d'extraire des ressources du jeu, ce n'est clairement pas la meilleure m√©thode. <br><br>  Pour coller les fichiers png coup√©s, un petit script merge_dpng sur Pearl d'Asmodeus, qui utilise ImageMagick, a √©t√© cr√©√© √† un moment donn√©.  Malheureusement, il a eu des probl√®mes avec lui.  Tout d'abord, j'avais besoin de Pearl, que je n'ai pas utilis√©, et m√™me apr√®s l'avoir install√©, il s'est av√©r√© que le script ne fonctionnait pas correctement. <br><br>  Pour cette raison, nous avons √©crit un programme similaire en python: <br><br><div class="spoiler">  <b class="spoiler_title">Fusion de fichiers dpng du moteur Qlie</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # Qlie engine dpng files merger # by Chtobi and Nazon, 2016 # Requires ImageMagick magick.exe on the path. import os import glob import re import argparse import subprocess IMGMAGIC = os.path.dirname(os.path.abspath(__file__)) + '\\' + 'magick.exe' IMGMAGIC_PARAMS1 = ['-background', 'rgba(0,0,0,0)'] IMGMAGIC_PARAMS2 = ['-mosaic'] INPUT_FILES_MASK = '*+DPNG[0-9][0-9][0-9]+*.png' SPLIT_MASK = '+DPNG' x_y_ajusts_re = re.compile('(.+)\+DPNG[0-9][0-9][0-9]\+x(\d+)y(\d+)\.') if __name__ == '__main__': arg_parser = argparse.ArgumentParser(prog="DPNG Merger\n" "Program to merge sliced png files from QLIE engine. " "All files with mask *+DPNG[0-9][0-9][0-9]+*.png" "into the input directory will be merged and copied to the" "output directory.\n", usage="connect_png.py input_dir [output_dir]\n") arg_parser.add_argument("input_dir_param", nargs=1, help="Full path to the input directory.\n") arg_parser.add_argument("output_dir_param", nargs='?', default=os.path.dirname(os.path.abspath(__file__)), help="Full path to the output directory. " "It would be a script parent directory if not specified.\n") input_dir = arg_parser.parse_args().input_dir_param[0] output_dir = arg_parser.parse_args().output_dir_param[0] os.chdir(input_dir) all_append_files = glob.glob(INPUT_FILES_MASK) # Select only files with DPNG prep_bunches = [] for file_in_dir in all_append_files: # Check all files and put all splices that should be connected in separate list for num, bunch in enumerate(prep_bunches): name_first_part = bunch[0].partition(SPLIT_MASK)[0] # Part of the filename before +DPNG should be unique if name_first_part == file_in_dir.partition(SPLIT_MASK)[0]: prep_bunches[num].append(file_in_dir) break else: prep_bunches.append([file_in_dir]) os.chdir(os.path.dirname(os.path.abspath(__file__))) # Go to the script parent dir for prepared_bunch in prep_bunches: sorted_bunch = sorted(prepared_bunch) # Prepare -page params for imgmagic png_pages_params = [["(", "-page", "+{0}+{1}".format(*[(x_y_ajusts_re.match(part_file).group(2)), x_y_ajusts_re.match(part_file).group(3)]), input_dir+part_file, ")"] for part_file in sorted_bunch] connect_png_list = \ [imgmagick_page for imgmagick_pages in png_pages_params for imgmagick_page in imgmagick_pages] output_file = output_dir + sorted_bunch[0].partition(SPLIT_MASK)[0] + ".png" subprocess.check_output([IMGMAGIC] + IMGMAGIC_PARAMS1 + connect_png_list + IMGMAGIC_PARAMS2 + [output_file])</span></span></code> </pre> <br></div></div><br>  Il semblerait que nous ayons maintenant l'ensemble des images qui apparaissent dans le jeu?  Pas du tout - si vous regardez toutes les images connect√©es de toutes les archives, vous constaterez toujours que certaines sont manquantes, bien qu'elles soient dans le jeu.  Le fait est qu'il existe un autre type de fichier dans le moteur - avec l'extension .b.  C'est un peu une animation avec des images et des sons enregistr√©s √† l'int√©rieur. <br><br>  Il est assez facile d'obtenir les ressources stock√©es √† l'int√©rieur, mais, h√©las, aucun des d√©compresseurs de fichiers .b pr√™ts √† l'emploi n'a fonctionn√© dans notre cas comme il se doit.  Soit certains fichiers sont rest√©s d√©compress√©s, soit il y a eu des erreurs dues √† des noms japonais, et je ne voulais pas d√©marrer √† partir des param√®tres r√©gionaux japonais. <br><br>  Ici encore, notre script a √©t√© utile.  Depuis lors, nous ne connaissions pas quelque chose comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kaitai Struct</a> , nous avons d√ª agir presque √† partir de z√©ro. <br><br>  Le format des fichiers .b s'est av√©r√© √™tre simple et, de plus, notre d√©compresseur devait pouvoir d√©compresser les ressources uniquement de ce jeu.  Dans d'autres jeux sur le moteur Qlie, des types de ressources suppl√©mentaires sont apparus dans les fichiers .b, mais nous ne nous attarderons pas sur eux en d√©tail. <br><br>  Alors, ouvrez n'importe quel fichier .b dans un √©diteur hexad√©cimal et regardez au d√©but.  Avant d'√©valuer, notez que l'ordre des octets de toutes les valeurs num√©riques sera Little-endian. <br><br><ul><li>  En-t√™te de fichier ABMP12 </li><li>  Dix octets 0x00 </li><li>  Le titre de la premi√®re section abdata12 avec des informations suppl√©mentaires. </li><li>  Huit octets 0x00 </li><li>  Taille de section abdata12, entier de quatre octets.  Vous pouvez le sauter en toute s√©curit√©. </li><li>  En-t√™te de section Abimage10 </li><li>  Sept octets 0x00 </li><li>  Nombre de fichiers dans une section, entier sur un octet.  Dans ce cas, il y a un fichier dans la section. </li><li>  En-t√™te de section abgimgdat13 </li><li>  Six octets 0x00 </li><li>  La longueur du nom de fichier √† l'int√©rieur de la section, un entier sur deux octets.  Dans ce cas, la longueur est de 4 octets. </li><li>  Nom de fichier encod√© Shift Jis </li><li>  Longueur d'enregistrement de la somme de contr√¥le du fichier, entier sur deux octets. </li><li>  Somme de contr√¥le du fichier lui-m√™me. </li><li>  L'octet inconnu semble toujours √™tre 0x03 ou 0x02 </li><li>  Douze octets inconnus, probablement li√©s √† l'animation </li><li>  La taille du fichier png √† l'int√©rieur de la section est un entier de quatre octets. </li></ul><br>  Et enfin, le fichier png lui-m√™me. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/64/v4/yc/64v4ycd37hyu-pyqsxyb2g1ahqa.png"></div><br>  La section absound est de structure similaire √† abimage. <br><br><div class="spoiler">  <b class="spoiler_title">Extracteur BMP anim√©</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # Extract b # AnimatedBMP extractor for Bishoujo Mangekyou game files # by Chtobi and Nazon, 2016 import glob import os import struct import argparse from collections import namedtuple b_hdr = b'abmp12'+bytes(10) signa_len = 16 b_abdata = (b'abdata10'+bytes(8), b'abdata11'+bytes(8), b'abdata12'+bytes(8), b'abdata13'+bytes(8)) b_imgdat = (b'abimgdat10'+bytes(6), b'abimgdat11'+bytes(6), b'abimgdat14'+bytes(6)) b_img = (b'abimage10'+bytes(7), b'abimage11'+bytes(7), b'abimage12'+bytes(7), b'abimage13'+bytes(7), b'abimage14'+bytes(7)) b_sound = (b'absound10'+bytes(7), b'absound11'+bytes(7), b'absound12'+bytes(7)) # not sure about structure of sound11 and sound12 b_snd = (b'absnddat11'+bytes(7), b'absnddat10'+bytes(7), b'absnddat12'+bytes(7)) Abimgdat13_pattern = namedtuple('Abimgdat13', ['signa', 'name_size_len', 'hash_size_len', 'unknown1_len', 'unknown2_len', 'data_size_len']) Abimgdat13 = Abimgdat13_pattern(signa=b'abimgdat13'+bytes(6), name_size_len=2, hash_size_len=2, unknown1_len=1, unknown2_len=12, data_size_len=4) Abimgdat14_pattern = namedtuple('Abimgdat14', ['signa', 'name_size_len', 'hash_size_len', 'unknown1_len', 'data_size_len']) Abimgdat14 = Abimgdat14_pattern(signa=b'abimgdat14'+bytes(6), name_size_len=2, hash_size_len=2, unknown1_len=77, data_size_len=4) Abimgdat_pattern = namedtuple('Abimgdat', ['name_size_len', 'hash_size_len', 'unknown1_len', 'data_size_len']) # probably, abimgdat10,abimgdat11 and others Other_imgdat = Abimgdat_pattern(name_size_len=2, hash_size_len=2, unknown1_len=1, data_size_len=4) Absnddat11_pattern = namedtuple('Absnddat11', ['signa', 'name_size_len', 'hash_size_len', 'unknown1_len', 'data_size_len']) Absnddat11 = Absnddat11_pattern(signa=b'absnddat11'+bytes(7), name_size_len=2, hash_size_len=2, unknown1_len=1, data_size_len=4) def create_parser(): arg_parser = argparse.ArgumentParser(prog='AnimatedBMP extractor\n', usage='extract_b input_file_name output_dir\n', description='AnimatedBMP extractor for QLIE engine *.b files.\n') arg_parser.add_argument('input_file_name', nargs='+', help="Input file with full path(wildcards are supported).\n") arg_parser.add_argument('output_dir', nargs=1, help="Output directory.\n") return arg_parser def check_type(file_buf): if file_buf.startswith(b'\x89' + b'PNG'): return '.png' elif file_buf.startswith(b'BM'): return '.bmp' elif file_buf.startswith(b'JFIF', 6): return '.jpg' elif file_buf.startswith(b'IMOAVI'): return '.imoavi' elif file_buf.startswith(b'OggS'): return '.ogg' elif file_buf.startswith(b'RIFF'): return '.wav' else: return '' def bytes_shiftjis_to_utf8(shiftjis_bytes): shiftjis_str = shiftjis_bytes.decode('shift_jis', 'strict') utf_str = shiftjis_str.encode('utf-8', 'strict').decode('utf-8', 'strict') return utf_str def check_signa(f_buffer): if f_buffer.endswith(b_abdata): return 'abdata' elif f_buffer.endswith(b_img): return 'abimgdat' elif f_buffer.endswith(b_sound): return 'absound' def prepare_filename(out_file_name, out_dir, postfix=''): ready_name = out_dir + os.path.basename(out_file_name) + postfix return ready_name def create_file(file_name_hndl, out_buffer): if len(out_buffer) != 0: with open(file_name_hndl, 'wb') as ext_file: ext_file.write(out_buffer) else: print("Zero file. Skipped.") def check_file_header(file_handle, bytes_num): file_handle.seek(0) readed_bytes = file_handle.read(bytes_num) if readed_bytes == b_hdr: print("File is valid abmp") return True else: print("Can't read header. Probably, wrong file...") return False if __name__ == '__main__': parser = create_parser() arguments = parser.parse_args() all_b_files = glob.glob(arguments.input_file_name[0]) output_dir = arguments.output_dir[0] for b_file in all_b_files: file_buffer = bytearray(b'') with open(b_file, 'rb') as bfile_h: check_file_header(bfile_h, len(b_hdr)) read_byte = bfile_h.read(1) file_buffer.extend(read_byte) while read_byte: read_byte = bfile_h.read(1) file_buffer.extend(read_byte) # Finding content sections signature check_result = check_signa(file_buffer) if check_result: if check_result == 'abdata': file_buffer = bytearray(b'') read_length = bfile_h.read(4) size = struct.unpack('&lt;L', read_length)[0] file_buffer.extend(bfile_h.read(size)) # Adding _abdata to separate from other parts outfile_name = prepare_filename(b_file, output_dir, '_abdata') create_file(outfile_name, file_buffer) elif check_result == 'abimgdat': images_number = struct.unpack('B', bfile_h.read(1))[0] # Number of pictures in section for i1 in range(images_number): file_buffer = bytearray(b'') file_name = '' imgsec_hdr = bfile_h.read(signa_len) if imgsec_hdr == Abimgdat13.signa: file_name_size = struct.unpack('&lt;H', bfile_h.read(Abimgdat13.name_size_len))[0] # Decode filename to utf8 file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) # CRC size hash_size = struct.unpack('&lt;H', bfile_h.read(Abimgdat13.hash_size_len))[0] # Picture CRC (don't need it) pic_hash = bfile_h.read(hash_size) unknown1 = bfile_h.read(Abimgdat13.unknown1_len) unknown2 = bfile_h.read(Abimgdat13.unknown2_len) pic_size = struct.unpack('&lt;L', bfile_h.read(Abimgdat13.data_size_len))[0] print("pic_size:", pic_size) file_buffer.extend(bfile_h.read(pic_size)) elif imgsec_hdr == Abimgdat14.signa: file_name_size = struct.unpack('&lt;H', bfile_h.read(Abimgdat14.name_size_len))[0] file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) hash_size = struct.unpack('&lt;H', bfile_h.read(Abimgdat14.hash_size_len))[0] pic_hash = bfile_h.read(hash_size) bfile_h.seek(Abimgdat14.unknown1_len, os.SEEK_CUR) pic_size = struct.unpack('&lt;L', bfile_h.read(Abimgdat14.data_size_len))[0] file_buffer.extend(bfile_h.read(pic_size)) else: # probably abimgdat10, abimgdat11... file_name_size = struct.unpack('&lt;H', bfile_h.read(Other_imgdat.name_size_len))[0] file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) hash_size = struct.unpack('&lt;H', bfile_h.read(Other_imgdat.hash_size_len))[0] pic_hash = bfile_h.read(hash_size) bfile_h.seek(Other_imgdat.unknown1_len, os.SEEK_CUR) pic_size = struct.unpack('&lt;L', bfile_h.read(Other_imgdat.data_size_len))[0] file_buffer.extend(bfile_h.read(pic_size)) for i, letter in enumerate(file_name): # Replace any unusable symbols from filename with _ if letter == '&lt;' or letter == '&gt;' or letter == '*' or letter == '/': file_name = file_name.replace(letter, "_") # Checking file signature and adding proper extension outfile_name = prepare_filename(b_file, output_dir, '_' + file_name + check_type(file_buffer)) create_file(outfile_name, file_buffer) file_buffer = bytearray(b'') elif check_result == 'absound': sound_files_number = struct.unpack('B', bfile_h.read(1))[0] for i2 in range(sound_files_number): file_buffer = bytearray(b'') file_name = '' sndsec_hdr = bfile_h.read(signa_len) if sndsec_hdr == Absnddat11.signa: file_name_size = struct.unpack('&lt;H', bfile_h.read(Absnddat11.name_size_len))[0] file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) hash_size = struct.unpack('&lt;H', bfile_h.read(Absnddat11.hash_size_len))[0] snd_hash = bfile_h.read(hash_size) unknown1 = bfile_h.read(Absnddat11.unknown1_len) snd_size = struct.unpack('&lt;L', bfile_h.read(Absnddat11.data_size_len))[0] file_buffer.extend(bfile_h.read(snd_size)) else: file_name_size = struct.unpack('&lt;H', bfile_h.read(Absnddat11.name_size_len))[0] file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) hash_size = struct.unpack('&lt;H', bfile_h.read(Absnddat11.hash_size_len))[0] snd_hash = bfile_h.read(hash_size) unknown1 = bfile_h.read(Absnddat11.unknown1_len) snd_size = struct.unpack('&lt;L', bfile_h.read(Absnddat11.data_size_len))[0] file_buffer.extend(bfile_h.read(snd_size)) for i, letter in enumerate(file_name): if letter == '&lt;' or letter == '&gt;' or letter == '*' or letter == '/': file_name[i] = '_' outfile_name = prepare_filename(b_file, output_dir, '_' + file_name + check_type(file_buffer)) print("create absound") create_file(outfile_name, file_buffer) file_buffer = bytearray(b'')</span></span></code> </pre><br></div></div><br>  Le script devrait d√©compresser automatiquement les fichiers png, jpg, bmp, ogg et wav trouv√©s.  Mais en plus de cela, des fichiers imoavi inconnus se trouvent √©galement √† l'int√©rieur. <br><br>  L'essentiel est que dans le jeu, toutes les animations sont faites soit sous forme de vid√©o √† part enti√®re au format ogv, soit sous forme d'images anim√©es par le moteur qui sont enregistr√©es dans des fichiers .b, ou sous forme de s√©quences anim√©es de fichiers jpg au format imoavi. <br><br>  Dans ce cas, nous √©tions √©galement int√©ress√©s par les images jpg, nous avons donc d√ª les g√©rer √©galement. <br><br>  Il y a deux sections dans imoavi: SOUND et MOVIE.  Dans la section MOVIE, 47 octets apr√®s l'en-t√™te, il y a quatre octets de la taille du fichier jpg.  Les fichiers sont √©crits les uns apr√®s les autres dans leur forme d'origine, s√©par√©s par une s√©quence de 19 octets, o√π la taille du fichier suivant est enregistr√©e. <br><br>  L'imoavi exprim√© dans le jeu n'a pas √©t√© rencontr√©, donc la section SON est toujours vide. <br><br>  Eh bien, depuis que nous avons commenc√© √† retirer toutes les ressources du jeu, en m√™me temps, un petit script a √©t√© √©crit pour retirer jpg d'imoavi. <br><br><div class="spoiler">  <b class="spoiler_title">Extracteur Imoavi</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # Extract imoavi # Imoavi extractor for Bishoujo Mangekyou game files # by Chtobi and Nazon, 2016 import glob import os import struct import argparse imoavi_hdr = b'IMOAVI' hdr_len = len(imoavi_hdr) def create_file(file_name, out_buffer, wr_mode='wb'): if len(out_buffer) != 0: with open(file_name, wr_mode) as ext_file: ext_file.write(out_buffer) else: print("Zero file. Skipped.") def prepare_filename(file_name, out_dir, postfix=''): ready_name = out_dir + os.path.basename(file_name) + postfix return ready_name def create_parser(): arg_parser = argparse.ArgumentParser(prog='Imoavi extractor\n', usage='extract_imoavi input_file_name output_dir\n', description='Imoavi extractor for QLIE engine *.imoavi files.\n') arg_parser.add_argument('input_file_name', nargs='+', help="Input file with full path(wildcards are supported).\n") arg_parser.add_argument('output_dir', nargs='+', help="Output directory.\n") return arg_parser if __name__ == '__main__': parser = create_parser() arguments = parser.parse_args() all_imoavi = glob.glob(arguments.input_file_name[0]) output_dir = arguments.output_dir[0] for imoavi_f in all_imoavi: file_buffer = bytearray(b'') with open(imoavi_f, 'rb') as imoavi_h: # Read imoavi file header imoavi_h.read(hdr_len) imoavi_h.seek(2, os.SEEK_CUR) # 0x00 imoavi_h.seek(1, os.SEEK_CUR) # 0x64 imoavi_h.seek(3, os.SEEK_CUR) # 0x00 imoavi_h.seek(5, os.SEEK_CUR) # SOUND imoavi_h.seek(3, os.SEEK_CUR) # 0x00 imoavi_h.seek(1, os.SEEK_CUR) # 0x64 imoavi_h.seek(11, os.SEEK_CUR) imoavi_h.seek(5, os.SEEK_CUR) # Movie imoavi_h.seek(3, os.SEEK_CUR) # 00 ?? imoavi_h.seek(1, os.SEEK_CUR) # 0x64 imoavi_h.seek(3, os.SEEK_CUR) # 0x00 ?? imoavi_h.seek(4, os.SEEK_CUR) # ?? imoavi_h.seek(1, os.SEEK_CUR) # Number of jpg files in section imoavi_h.seek(4, os.SEEK_CUR) # 0x00 imoavi_h.seek(1, os.SEEK_CUR) # 0x05 ??? imoavi_h.seek(2, os.SEEK_CUR) # 0x00 ?? imoavi_h.seek(4, os.SEEK_CUR) # 720 ?? imoavi_h.seek(4, os.SEEK_CUR) # Full size without header? to_next_size = struct.unpack('&lt;L', imoavi_h.read(4))[0] # Bytes till next header imoavi_h.seek(16, os.SEEK_CUR) # 0x00 jpg_size = struct.unpack('&lt;L', imoavi_h.read(4))[0] imoavi_h.seek(4, os.SEEK_CUR) # 0x00 file_num = 0 file_buffer.extend(imoavi_h.read(jpg_size)) outfile_name = prepare_filename(imoavi_f, output_dir, '_' + (str(file_num)).zfill(3) + '.jpg') create_file(outfile_name, file_buffer) while to_next_size != 0: file_buffer = bytearray(b'') to_next_size = struct.unpack('&lt;L', imoavi_h.read(4))[0] if to_next_size == 24: # 0x1C header for index part file_buffer.extend(imoavi_h.read(to_next_size)) outfile_name = prepare_filename(imoavi_f, output_dir, '_' + '.index') create_file(outfile_name, file_buffer, 'ab') # concatenate with index file else: imoavi_h.seek(2, os.SEEK_CUR) # unknown imoavi_h.seek(2, os.SEEK_CUR) # Unknown, almost always FF FF or FF FE file_num = struct.unpack('B', imoavi_h.read(1))[0] # File number imoavi_h.seek(11, os.SEEK_CUR) # 0x00 jpg_size = struct.unpack('&lt;L', imoavi_h.read(4))[0] imoavi_h.seek(4, os.SEEK_CUR) # 0x00 file_buffer.extend(imoavi_h.read(jpg_size)) outfile_name = prepare_filename(imoavi_f, output_dir, '_' + (str(file_num)).zfill(3) + '.jpg') create_file(outfile_name, file_buffer)</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apr√®s le d√©ballage, vous pouvez vous assurer que l'animation de l'√©cran de d√©marrage dans le menu est stock√©e uniquement dans le fichier 1_ „Çø „Ç§ „Éà „É´ ÁîªÈù¢ „É† „Éº „Éì „Éº .b au format imoavi. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/81/_r/lo81_rlqvf55nia7relrkbsckey.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est tout avec les ressources du jeu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malheureusement, le processus de traduction a r√©v√©l√© plusieurs nuances plus d√©sagr√©ables qui n'ont pas pu √™tre surmont√©es. Le jeu, comme je l'ai d√©j√† √©crit, ne prend pas en charge les encodages Unicode. Par cons√©quent, tout le texte traduit est affich√© avec le mauvais espacement des lettres. Il y a eu quelques probl√®mes suppl√©mentaires avec le backpacking des fichiers et le d√©marrage d'un jeu sans changer l'encodage syst√®me en japonais. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä un moment donn√©, nous (ou plut√¥t, celui qui √©tait responsable de la partie technique de la traduction dans notre √©quipe) avons pens√©: peut-√™tre ne devrions-nous pas rester avec l'ancien moteur, mais porter le roman sur le moteur Renpy, tout en obtenant une plateforme multiplateforme? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peut-√™tre √©tions-nous press√©s, mais √† un moment donn√©, c'√©tait dommage de quitter ce que nous avions commenc√© et il ne restait plus qu'√† terminer la traduction.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'avons-nous rencontr√© lors du portage? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä ce sujet dans la deuxi√®me partie. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liens: </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos scripts bitbucket </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä propos de la </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">table de codage Shift </font></font></a> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">Jis du moteur Qlie japonais En </font></a></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">savoir plus sur le probl√®me du transcodage de Shift Jis vers UTF-8 </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asmodean exfp3_v3</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426431/">https://habr.com/ru/post/fr426431/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426421/index.html">EHCI humainement en russe</a></li>
<li><a href="../fr426423/index.html">mmWave sur smartphones: comment Qualcomm a rendu possible l'impossible</a></li>
<li><a href="../fr426425/index.html">Toute la v√©rit√© sur RTOS. Article # 14. Sections de m√©moire: introduction et services de base</a></li>
<li><a href="../fr426427/index.html">Des trucs utiles pour "bourrer": une petite s√©lection √† petits prix</a></li>
<li><a href="../fr426429/index.html">Installation de FreeSWITCH 1.8 sur Debian 9 (Raspbian Stretch, l'image de base du syst√®me Smart Home de MajorDoMo sur Rasbperri Pi)</a></li>
<li><a href="../fr426433/index.html">D√©licieux SMM pour le restaurant</a></li>
<li><a href="../fr426435/index.html">Les meilleurs sp√©cialistes sont ceux que j'ai pr√©par√©s moi-m√™me: un cours de test de jeu par des experts du groupe Mail.Ru</a></li>
<li><a href="../fr426437/index.html">Comment la reconnaissance faciale vous aide √† trouver des t√©l√©phones de test</a></li>
<li><a href="../fr426439/index.html">Falsification de graphiques, substitution de cotations et manipulation de prix: comment pirater des applications pour le trading en bourse</a></li>
<li><a href="../fr426441/index.html">Mail.Ru Group 20 ans: points de contr√¥le code et technologie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>