<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸 ✋🏿 ⏭️ 测试与 类型-Rust版本 🍳 👈🏿 👢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="几天前， 0xd34df00d发布了该文章的译文，描述了如果我们将某些功能用作“黑匣子”而不是尝试阅读其实现的功能的可能信息。 当然，这些信息因语言而异。 在原始文章中，考虑了四种情况： 


- Python-动态类型，几乎没有来自签名的信息，测试可以得到一些提示； 
- C-弱静态类型，更多信息...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>测试与 类型-Rust版本</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468271/"><p>几天前， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">0xd34df00d</a>发布了该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a>的译文，描述了如果我们将某些功能用作“黑匣子”而不是尝试阅读其实现的功能的可能信息。 当然，这些信息因语言而异。 在原始文章中，考虑了四种情况： </p><br><ul><li>  Python-动态类型，几乎没有来自签名的信息，测试可以得到一些提示； </li><li>  C-弱静态类型，更多信息； </li><li>  Haskell-强静态类型，默认情况下具有纯函数，提供更多信息； </li><li>  Idris-依赖类型，编译器可以证明函数的正确性。 </li></ul><br><p>  “这里是C，还有Haskell，Rust呢？”  -这是以下讨论中的第一个问题。 答复在这里。 </p><a name="habracut"></a><br><p> 让我们首先回顾一下任务： </p><br><blockquote> 给定一个值列表和一个值，请返回该值在列表中的索引或表示该值不存在于列表中。 </blockquote><p> 如果不想让所有人都读完这本书， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rust操场</a>上提供了代码示例。 <br> 否则，让我们开始吧！ </p><br><h4 id="simple-search"> 简单搜索 </h4><br><p> 第一种方法是几乎天真的签名，仅在某些惯用元素上与C代码不同： </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(x: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>], y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p> 我们对该功能了解多少？ 好吧，事实上-不是很多。 当然，将<code>Option&lt;usize&gt;</code>作为返回值比C提供的功能有了很大的改进，但是没有有关函数语义的信息。 特别是，我们不能保证没有副作用，也无法以某种方式检查所需的行为。 </p><br><p> 测试可以改善这一点吗？ 看这里： </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-literal"><span class="hljs-literal">None</span></span>); }</code> </pre> <br><p> 似乎仅此而已-所有这些检查在Python中可能都是一样的（而且，预期测试对整篇文章没有多大帮助）。 </p><br><h4 id="use-the-generics-luke"> 使用通用名称，卢克！ </h4><br><p> 但是仅使用32位带符号的数字有什么好处？ 解决方法： </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p> 好吧，那是什么！ 现在我们可以进行任何切片，包括任何可比较类型的元素。 显式多态几乎总是比隐式（hello，Python）好，根本没有多态（hello，C）。 </p><br><p> 虽然，此函数可能会意外通过此测试： </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refl</span></span></span></span>&lt;El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Copy</span></span>&gt;(el: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { foo(&amp;[el], el) <span class="hljs-comment"><span class="hljs-comment">// should always return Some(0), right? } #[test] fn dont_find_nan() { assert_eq!(refl(std::f64::NAN), None); }</span></span></code> </pre> <br><p> 这暗示了一个缺失点，因为规范实际上希望<code>refl</code>函数始终返回<code>Some(0)</code> 。 当然，这全都归因于部分等效类型的一般行为，尤其是浮点数。 <br> 也许我们想摆脱这个问题？ 因此，我们将简单地限制El类型的界限： </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p> 现在，我们不仅要求类型具有可比性，还要求这种比较是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">等价的</a> 。 当然，这限制了此功能可以使用的类型，但是现在签名和测试都表明行为应符合规范。 </p><br><div class="spoiler">  <b class="spoiler_title">旁注：我们想更通用！</b> <div class="spoiler_text"><p> 这个案例与最初的任务无关，但这似乎是一个众所周知的原则的很好的例子：“对接受的东西持自由态度，对所做的事情持保守态度”。 换句话说：如果您可以在不损害人体工程学和性能的情况下概括输入类型，则可能应该这样做。 </p><br><p> 现在，我们将检查以下内容： </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, El: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(x: <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">IntoIterator</span></span>&lt;Item = &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> El&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p> 现在我们对该功能了解多少？ 总的来说，它们都是一样的，但是现在它不仅接受切片或列表，还接受一些任意对象，这些对象可以产生对类型El的引用，以便我们将其与所讨论的对象进行比较。 例如，如果我没记错的话，在Java中，这种类型将是<code>Iterable&lt;Comparable&gt;</code> 。 </p></div></div><br><h4 id="like-before-but-a-bit-more-strict"> 像以前一样，但是更加严格 </h4><br><p> 但是现在，也许我们需要更多保证。 或者我们想在堆栈上工作（因此不能使用<code>Vec</code> ），但是需要针对每种可能的数组大小归纳我们的代码。 或者我们要编译针对每种具体数组大小优化的函数。 </p><br><p> 无论如何，我们需要一个通用数组-Rust中有一个板条箱， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">正是</a>提供<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了这一点</a> 。 </p><br><p> 现在，这是我们的代码： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{GenericArray, ArrayLength}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p> 我们从中知道什么？ 我们知道函数将采用某个特定大小的数组，并在其类型中反映出来（并且将针对每个此类大小独立编译）。 目前，这几乎没有什么-以前的实现在运行时提供了相同的保证。 </p><br><p> 但是我们可以走得更远。 </p><br><h4 id="type-level-arithmetic"> 类型级算术 </h4><br><p> 最初的文章提到了Idris提供的一些保证，而其他语言则无法获得这些保证。 其中之一-可能是最简单的，因为它不涉及任何证明或测试，只是类型略有变化，-声明返回值（如果不是<code>Nothing</code> ）将始终小于列表长度。 </p><br><p> 看起来依赖类型（或类似的类型）对于这种保证是必需的，我们不能从Rust获得相同的信息，对吗？ </p><br><p> 符合<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">typenum</a> 。 使用它，我们可以通过以下方式编写函数： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{ArrayLength, GenericArray}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> typenum::{IsLess, Unsigned, B1}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsignedLessThan</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;Less, More&gt; UnsignedLessThan&lt;More&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Less <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> Less: IsLess&lt;More, Output = B1&gt;, Less: Unsigned, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { &lt;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Unsigned&gt;::USIZE } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn UnsignedLessThan&lt;Size&gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  “这是什么黑魔法？！”  -你可以问。 而且您是对的：typenum <em>是</em>一个黑魔法，任何使用它的尝试都更加神奇。 <br><br> 但是此功能签名是相当具体的。 </p><br><ul><li> 它需要一组长度为Size的El's和另一个El。 </li><li> 它返回一个Option，如果为Some， <br><ul><li> 拥有一个基于<code>UnsignedLessThan&lt;Size&gt;</code>特征的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">特征对象</a> ； </li><li> 并且在实现<code>Unsigned</code>和<code>IsLess&lt;T&gt;</code>任何地方都实现了<code>Unsigned</code> <code>IsLess&lt;T&gt;</code> ，而<code>IsLess&lt;T&gt;</code>返回B1，即true。 </li></ul></li></ul><br><p> 换句话说， <em>保证</em>此函数返回<em>小于</em>数组大小的无符号整数（严格来说，它返回trait对象，但是我们可以调用<code>as_usize</code>方法来获取整数）。 </p><br><p> 我现在可以说两个主要警告： </p><br><ol><li> 我们会损失性能。 如果此函数以某种方式位于程序的“热门”路径上，则恒定的动态调度可能会减慢整个过程。 实际上，这可能不是一个大问题，但是还有另一个问题： </li><li> 为了编译该函数，我们必须在其内部编写其正确性证明，或者使用一些<code>unsafe</code>欺骗类型系统。 前者相当复杂，而后者只是作弊。 </li></ol><br><h4 id="conclusion"> 结论 </h4><br><p> 当然，在实践中，我们通常将使用第二种方法（具有通用切片）或扰流器中的方法（具有迭代器）。 随后的所有讨论可能都没有任何实际意义，在这里仅是对类型的练习。 </p><br><p> 无论如何，就我而言，Rust类型系统可以从更强大的Idris类型系统中模拟功能这一事实本身就给人留下了深刻的印象。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN468271/">https://habr.com/ru/post/zh-CN468271/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN468253/index.html">CSS和Javascript中的简单图像滑块</a></li>
<li><a href="../zh-CN468259/index.html">阿姆斯特丹2019头盔峰会的五大亮点</a></li>
<li><a href="../zh-CN468261/index.html">在Three.js上拥有旧气氛的新游戏</a></li>
<li><a href="../zh-CN468263/index.html">向新的Visual Studio终端问好</a></li>
<li><a href="../zh-CN468267/index.html">加强Alistair Coburn书中给出的UseCase方法</a></li>
<li><a href="../zh-CN468277/index.html">程序员的工作艰辛吗？从心理生理学的角度来看</a></li>
<li><a href="../zh-CN468285/index.html">面向企业和初创企业的顶级软件开发公司</a></li>
<li><a href="../zh-CN468287/index.html">C＃属性：关于所有方面</a></li>
<li><a href="../zh-CN468289/index.html">上午</a></li>
<li><a href="../zh-CN468291/index.html">马克·高尔斯顿（Mark Gaulston）的书“我能听见你的经历”的摘要</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>