<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🎓 🔛 🦏 Création du jeu «Like Coins» sur Godot Engine. 2e partie 👆 🥀 👩🏻‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'espère que vous en avez assez d'attendre la deuxième partie de l'article, qui traite des aspects du développement de jeux en utilisant le moteur God...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Création du jeu «Like Coins» sur Godot Engine. 2e partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430800/"><p>  J'espère que vous en avez assez d'attendre la deuxième partie de l'article, qui traite des aspects du développement de jeux en utilisant le moteur Godot, en utilisant l'exemple du jeu Like Coins?  Beaucoup de tout «savoureux» et «sain» a été préparé à l'ordre du jour.  Faites immédiatement une réservation pour que dans cet article nous terminions le jeu démarré précédemment, dont vous pouvez lire le début ici - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Création du jeu "Like Coins" sur le moteur Godot.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> , mais la série d'articles se poursuivra, car  il y avait tellement de matériel qui m'a fait en mettre de côté, mais nous y reviendrons certainement plus tard.  Que le "gamedev" commence! </p><a name="habracut"></a><br><h3 id="scena-main">  Scène "Main" </h3><br><p> Dans la partie précédente de l'article, nous nous sommes arrêtés sur la scène principale ( <code>Main</code> ), et à partir de là, nous continuerons peut-être.  Nous supprimons tout ce qui a été ajouté plus tôt (si vous avez ajouté quelque chose bien sûr pour vérifier comment tout fonctionne), si rien n'a été chargé dans la scène, alors nous devrions ajouter <code>Node</code> , qui sera le parent des nœuds répertoriés ci-dessous, qui à son tour devrait également être ajouté à la scène: </p><br><p>  <code>ColorRect</code> ("Arrière-plan") - remplissez la couleur d'arrière-plan; <br>  <code>Player</code> - l'objet "Player" (j'espère que vous n'êtes pas confus parce que j'appelle la scène <code>Player</code> un objet?); <br>  <code>Node</code> ("Container") - "container" pour le stockage temporaire des pièces; <br>  <code>Position2D</code> ("PlayerStart") - au début du jeu définit la position initiale de l'objet "Player"; <br>  <code>Timer</code> ("GameTimer") - compteur de limite de temps; </p><br><p>  Sélectionnez <code>ColorRect</code> et dans la barre d'outils, sélectionnez: <code>Layout -&gt; Full Rect</code> pour l'étirer sur toute la zone de l'écran (à l'avenir, nous recourrons souvent à cette fonction, je vous conseille donc d'étudier vous-même d'autres opérations spécifiées dans la liste des <code>Layout</code> ), pour ce nœud, dans la propriété "Couleur", spécifiez la couleur de remplissage souhaitée.  Vous pouvez faire de même avec <code>TextureRect</code> , mais au lieu de remplir, vous devrez charger l'image via la propriété "Texture".  Pour <code>Position2D</code> , dans la propriété "position", spécifiez les valeurs de "x" et "y" - cela servira de position initiale pour le <code>Player</code> .  Bien sûr, avec l'aide du script, vous pouvez définir les valeurs de positionnement directement dans le <code>Player</code> lui-même, mais nous apprenons non seulement à développer des jeux, mais aussi à étudier "Godot", par conséquent, l'examen de différentes options pour résoudre un problème ne sera pas superflu. </p><br><h4 id="skript-dlya-main">  Script pour "Main" </h4><br><p>  Ajoutez un script pour <code>Node</code> et imprimez ce qui suit: </p><br><pre> <code class="python hljs">extends Node <span class="hljs-comment"><span class="hljs-comment">#PackedScene        export (PackedScene) var Coin export (int) var playtime var level #  var score # var left_time #     var window_size #   var playing = false #   </span></span></code> </pre> <br><p>  Les propriétés "Coin" et "playtime" seront affichées dans l' <code>Inspector</code> .  Faites glisser la scène "Coin.tscn" vers la propriété "Coin" et réglez "playtime" sur "40" (la durée du jeu en secondes). </p><br><p>  Lorsque le jeu démarre, chaque fois il doit y avoir une initialisation - préparation au travail, détermination des paramètres requis pour un fonctionnement de haute qualité et sans erreur de l'application.  Il s'agit d'une étape obligatoire, vous devez donc vous en occuper en premier. </p><br><pre> <code class="python hljs">func _ready(): randomize() <span class="hljs-comment"><span class="hljs-comment">#        window_size = get_viewport().get_visible_rect().size #    $Player.window_size = window_size #    "" $Player.hide() #  </span></span></code> </pre> <br><p>  Notez que lorsque vous spécifiez le nom de l'objet <code>Player</code> , le symbole «$» est utilisé - il s'agit de «sucre syntaxique» qui vous permet d'accéder directement au nœud dans la scène actuelle, une bonne alternative à la <code>get_node("Node1")</code> (bien que l'utilisation de ce dernier ne soit pas interdite).  Si "Node1" a un descendant de "Node2", vous pouvez également utiliser cette méthode - <code>$Node1/Node2</code> .  Notez que le remplissage automatique fonctionne très bien dans Godot, alors ne le négligez pas.  L'utilisation d'un espace dans les noms des nœuds n'est pas souhaitable, mais reste valide, dans ce cas, utilisez des guillemets - <code>$"My best Node1"</code> . </p><br><h4 id="novaya-igra">  Nouveau jeu </h4><br><p>  Pour démarrer une nouvelle partie, nous allons déterminer la fonction correspondante pour cela, que nous pouvons ensuite appeler, par exemple, en appuyant sur un bouton. </p><br><pre> <code class="python hljs">func new_game(): playing = true <span class="hljs-comment"><span class="hljs-comment">#   level = 1 score = 0 time_left = playtime $Player.start($PlayerStart.position) $Player.show() $GameTimer.start() #    spawn_coins() # </span></span></code> </pre> <br><p>  La fonction "start ()" dont l'argument est <code>$PlayerStart.position</code> déplacera le joueur à l'emplacement de départ, et la fonction "spawn_coins ()" est responsable, comme vous pouvez le deviner, de générer des pièces sur le terrain de jeu. </p><br><pre> <code class="python hljs">func spawn_coins(): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">4</span></span> + level): var c = Coin.instance() $CoinContainer.add_child(c) c.window_size = window_size c.position = Vector2(rand_range(<span class="hljs-number"><span class="hljs-number">0</span></span>, window_size.x), rand_range(<span class="hljs-number"><span class="hljs-number">0</span></span>, window_size.y))</code> </pre> <br><p>  La fonction <code>range(4 + level)</code> renverra un tableau avec une gamme donnée dont la valeur est égale à la somme du nombre de pièces et de la valeur du niveau actuel.  Une plage peut contenir un argument, comme dans notre cas, soit deux arguments soit trois arguments (le troisième argument sera une étape de tableau).  Dans cette fonction, nous créons plusieurs instances de l'objet "Coin" et ajoutons <code>CoinContainer</code> comme éléments enfants (j'espère que vous n'avez pas oublié que nous avons déjà accès à l'objet, grâce à <code>PackedScene</code> ).  N'oubliez pas que chaque fois que vous créez une instance d'un nouveau nœud (la méthode <code>instance()</code> ), elle doit être ajoutée à l'arborescence à l'aide de <code>add_child()</code> .  Ensuite, nous définissons la zone pour une éventuelle apparition de pièces afin qu'elles n'apparaissent pas accidentellement derrière l'écran, puis attribuons une position au hasard.  La dernière ligne ne semble pas un peu esthétique, je suggère donc de la simplifier en recourant au Singleton. </p><br><h3 id="singltony">  Singleton </h3><br><p>  Le deuxième prénom du Singleton est «Startup».  Déjà suggestif, non?  Je vous le dis, un singleton fonctionne comme suit: un script dans lequel nous pouvons écrire tout ce que nous voulons (à partir de la déclaration de variables et se terminant par des "commutateurs" de scènes, y compris leur chargement et leur déchargement) est chargé en premier, avec l'application en cours d'exécution, et tout son contenu est accessible depuis n'importe quel points de projet.  D'une certaine manière, il s'agit d'une sorte de référentiel global personnalisé de «tout» disponible à tout moment. </p><br><blockquote>  Notez que le projet a son propre référentiel global, dont nous pouvons également utiliser le contenu, et vous pouvez y accéder en utilisant <code>ProjectSettings.get_setting(name)</code> , où <code>name</code> est le nom du paramètre requis. </blockquote><p>  Maintenant, pour utiliser quelque chose du référentiel "_G", il suffit de l'appeler par son nom, puis de spécifier la méthode à appeler, ou tout ce que nous avons là.  Donc, créez un script vide et écrivez-y la fonction indiquée ci-dessous: </p><br><pre> <code class="python hljs">extends Node func rand(): var rrand = Vector2(rand_range(<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">760</span></span>), rand_range(<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">540</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rrand <span class="hljs-comment"><span class="hljs-comment">#  </span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/qm/te/or/qmteord9ofi1wxjimdhwqm-kexi.png"></p><br><p>  Ensuite, enregistrez-le et accédez aux paramètres du projet: <code>Project -&gt; Project Settings -&gt; AutoLoad</code> .  Nous sélectionnons notre script nouvellement créé, lui donnons un nom, par exemple, "_G", et retournons à la fonction "spawn_coins ()" pour ajuster légèrement le délai, en le remplaçant par le code suivant: </p><br><pre> <code class="python hljs"> ... c.position = _G.rand()</code> </pre> <br><p>  Maintenant, il vaut la peine de vérifier ce qui s'est passé en plaçant "spawn_coins ()" dans le bloc "_ready ()" et en exécutant l'application sur F5.  Et n'oubliez pas de sélectionner <code>Main.tscn</code> comme scène principale, si pour une raison quelconque vous avez fait une erreur de choix, vous pouvez changer la scène principale manuellement, pour cela, vous devez aller dans les paramètres du projet: <code>General -&gt; Run -&gt; MainScene</code> .  Ça marche?  Continuez ensuite. </p><br><h4 id="skolko-monet-ostalos">  Combien de pièces reste-t-il? </h4><br><p>  Continuons.  Ensuite, vous devez vérifier combien il reste de pièces pour transférer le joueur au niveau suivant, lui donner un petit «bonus» sous la forme d'une augmentation de temps de 5 secondes, puis réapparaître les pièces. </p><br><pre> <code class="python hljs">func _process(delta): <span class="hljs-comment"><span class="hljs-comment">#   ?     ? if playing and $CoinContainer.get_child_count() == 0: #    level += 1 # ""   time_left += 5 #  spawn_coins()</span></span></code> </pre> <br><h3 id="polzovatelskiy-interfeys">  Interface utilisateur </h3><br><p>  Toute notre interface sera composée des éléments suivants: indicateur de score, niveau actuel, heure, nom du jeu et un bouton qui déclenchera le lancement du jeu.  Créez une scène ( <code>HUD.tscn</code> ) avec un parent <code>CanvasLayer</code> (vous permet de dessiner une interface utilisateur au-dessus du terrain de jeu).  Pour l'avenir, je dirai qu'il n'est pas très pratique de gérer les éléments de l'interface utilisateur, du moins pour moi, c'est vrai, mais une liste assez large d'éléments et un développement actif inspirent une atmosphère positive dans un avenir radieux pour le développement de cet aspect du moteur. </p><br><p><img src="https://habrastorage.org/webt/id/ql/pj/idqlpjnvonb1aegarnbxj1_zzpg.png"></p><br><p>  Dans Godot, il existe des "nœuds de contrôle" qui vous permettent de formater automatiquement les éléments enfants par rapport aux paramètres spécifiés du parent.  Chaque type de "nœuds de contrôle" possède des propriétés spéciales qui contrôlent la façon dont ils contrôlent l'emplacement de leurs descendants.  Un représentant vivant de ce type est <code>MarginContainer</code> , qui doit être ajouté à la scène.  En utilisant <code>Layout -&gt; Top Wide</code> étirez-le en haut de la fenêtre et dans les propriétés de cet objet, dans la section <code>Margin</code> , spécifiez les retraits à partir des bords: gauche, haut et droite.  <code>MarginContainer</code> doit avoir trois <code>Label</code> enfants avec les noms suivants: <code>ScoreLabel</code> , <code>LevelLabel</code> et <code>TimeLabel</code> .  Ajoutez-les à la scène.  À l'aide de la propriété <code>Align</code> , alignez-les à gauche, au centre et à droite.  Il reste à ajouter un autre <code>Label</code> ( <code>Messagelabel</code> ), en le plaçant au centre, le tout aussi à l'aide de <code>Layout</code> , et un peu plus bas le bouton ( <code>StartButton</code> ). </p><br><p><img src="https://habrastorage.org/webt/2i/qd/2i/2iqd2ir5i51-kzycvac2mr-mmk8.png"></p><br><p>  Maintenant, rendons l'interface réactive, nous devons mettre à jour l'heure, le nombre de pièces collectées et mettre en évidence le niveau actuel.  Ajoutez un script pour le nœud <code>HUD</code> . </p><br><pre> <code class="python hljs">extends CanvasLayer signal start_game func update_score(value): $MarginContainer/ScoreLabel.text = str(value) func update_level(value): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(str(value)) == <span class="hljs-number"><span class="hljs-number">1</span></span>: $MarginContainer/TimeLabel.text = <span class="hljs-string"><span class="hljs-string">"0: 0"</span></span> + str(value) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: $MarginContainer/TimeLabel.text = <span class="hljs-string"><span class="hljs-string">"0: "</span></span> + str(value) func update_timer(value): $MarginContainer/TimeLabel.txt = str(value)</code> </pre> <br><p>  Pour <code>MessageLabel</code> nous avons besoin d'une minuterie afin de changer le texte du message pendant une courte période.  Ajoutez un nœud <code>Timer</code> et remplacez son nom par <code>MessageTimer</code> .  Dans l'inspecteur, définissez le temps d'attente sur 2 secondes et cochez la case dans le champ <code>One Shot</code> .  Cela garantit que la minuterie ne s'exécute qu'une seule fois au démarrage. </p><br><pre> <code class="python hljs">func show_message(text): $MessageLabel.text = text $MessageLabel.show() $MessageTimer.start()</code> </pre> <br><p>  Connectez le signal <code>timeout()</code> à "MessageTimer" et ajoutez ce qui suit: </p><br><pre> <code class="python hljs">func _on_MessageTimer_timeout(): $MessageLabel.hide()</code> </pre> <br><p>  Sur l'onglet "Node" pour <code>StartButton</code> , connectez le signal <code>pressed()</code> .  Lorsque vous cliquez sur le bouton <code>StartButton</code> il devrait disparaître avec <code>MessageLabel</code> , puis envoyer un signal à la scène principale, où nous réussirons ensuite à l'intercepter en même temps en glissant la fonction à exécuter - "new_game ()".  Nous implémentons cela en utilisant le code ci-dessous.  N'oubliez pas que le bouton de la propriété <code>Text</code> de définir tout appel de texte pour démarrer le jeu. </p><br><pre> <code class="python hljs">func _on_StartButton_pressed(): $StartButton.hide() $MessageLabel.hide() emit_signal(<span class="hljs-string"><span class="hljs-string">"start_game"</span></span>)</code> </pre> <br><p>  Pour finir enfin avec l'interface, nous allons écrire la dernière fonction finale - la fonction d'afficher un message sur la fin du jeu.  Dans cette fonction, nous avons besoin que l'inscription "Game Over" soit affichée pendant pas plus de deux secondes, puis disparaisse, ce qui est possible grâce à la fonction "show_message ()".  Cependant, vous devez à nouveau afficher le bouton de démarrage d'un nouveau jeu, dès qu'un message vous informant que le jeu est terminé disparaît.  <code>yield()</code> suspendra l'exécution de la fonction jusqu'à ce qu'un signal de <code>MessageTimer</code> soit reçu, et la réception d'un signal de <code>MessageTimer</code> concernant son exécution, la fonction continuera à s'exécuter, nous ramenant à son état d'origine afin que nous puissions recommencer une nouvelle partie. </p><br><pre> <code class="python hljs">func show_game_over(): show_message(<span class="hljs-string"><span class="hljs-string">"Game Over"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>($MessageTimer, <span class="hljs-string"><span class="hljs-string">"timeout"</span></span>) $StartButton.show() $MessageLabel.text = <span class="hljs-string"><span class="hljs-string">"LIKE COINS!"</span></span> $MessageLabel.show()</code> </pre> <br><h3 id="ending">  Fin? </h3><br><p>  Configurons la rétroaction entre le <code>HUD</code> et le <code>Main</code> .  Ajoutez la scène <code>HUD</code> à la scène principale et connectez le signal <code>GameTimer</code> via <code>timeout()</code> sur la scène principale en ajoutant ce qui suit: </p><br><pre> <code class="python hljs">func _on_GameTimer_timeout(): time_left -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">#  $HUD.update_timer(time_left) #   if time_left &lt;= 0: game_over() #    </span></span></code> </pre> <br><p>  Connectez ensuite les signaux <code>pickup()</code> et <code>die()</code> du lecteur. </p><br><pre> <code class="python hljs">func _on_Player_pickup(): score += <span class="hljs-number"><span class="hljs-number">1</span></span> $HUD.update_score(score) func _on_Player_die(): game_over()</code> </pre> <br><p>  À la fin du jeu, plusieurs autres choses devraient se produire qui ne devraient pas être négligées.  Écrivez le code suivant et je vais vous expliquer. </p><br><pre> <code class="python hljs">func game_over(): playing = false $GameTimer.stop() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> coin <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $CoinContainer.get_children(): coin.queue_free() $HUD.show_game_over() $Player.die()</code> </pre> <br><p>  Cette fonction arrêtera le jeu, puis les pièces restantes seront <code>show_game_over()</code> et les pièces restantes seront <code>show_game_over()</code> , puis <code>show_game_over()</code> sera appelé pour le <code>HUD</code> .  L'étape suivante consiste à démarrer l'animation et à arrêter le processus d'exécution du nœud <code>Player</code> . </p><br><p>  Enfin, vous devez activer <code>StartButton</code> , qui doit être connecté à la fonction <code>new_game()</code> .  Cliquez sur le nœud <code>HUD</code> et dans la boîte de dialogue de connexion, vous devez cliquer sur <code>Make Function to Off</code> (cela empêchera la création d'une nouvelle fonction) et dans le champ <code>Method In Node</code> , spécifiez le nom de la fonction à connecter - <code>new_game</code> .  Cela connectera le signal à une fonction existante, plutôt que d'en créer une nouvelle. </p><br><p>  La touche finale consiste à supprimer <code>new_game()</code> de la fonction <code>_ready()</code> et à ajouter les deux lignes suivantes à la fonction <code>new_game()</code> : </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>$HUD.update_score(score) $HUD.update_timer(time_left)</code> </pre> <br><p>  Maintenant, nous pouvons dire avec confiance que le jeu est prêt, maintenant il est assez «jouable», mais sans effets.  Nous examinerons ce dernier dans le prochain article, en accordant une attention énorme à diverses «décorations» afin de diversifier le gameplay et d'explorer davantage les possibilités de «Godot».  Par conséquent, n'oubliez pas de suivre la sortie des articles.  Bonne chance! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430800/">https://habr.com/ru/post/fr430800/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430788/index.html">Mon historique d'entretiens chez IB IT (développeur Java, banque d'investissement) à Londres avec des exemples de tâches typiques</a></li>
<li><a href="../fr430790/index.html">Ledger Nano S: la clé de la pièce où peuvent se trouver 710 tokens et crypto-monnaies</a></li>
<li><a href="../fr430792/index.html">Création d'un plan sur LWRP dans Unity</a></li>
<li><a href="../fr430794/index.html">L'histoire des cours</a></li>
<li><a href="../fr430798/index.html">Onduleur Li-ion: quel type de batterie choisir, LMO ou LFP?</a></li>
<li><a href="../fr430802/index.html">PMI RU: Etude des salaires des chefs de projets en Russie pour 2017</a></li>
<li><a href="../fr430804/index.html">Les batteries Tesla / Panasonic sont les batteries de véhicules électriques les plus abordables du marché</a></li>
<li><a href="../fr430806/index.html">Nous avons commencé à apprendre l'anglais - écrit une application: EWM - expérience dans la création d'un projet de formation</a></li>
<li><a href="../fr430808/index.html">Théorie des conférenciers: 16 documents sur le fonctionnement des conférenciers et des conférenciers</a></li>
<li><a href="../fr430810/index.html">Test de charge avec criquet. 2e partie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>