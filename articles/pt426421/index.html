<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòü üë©üèº‚Äçü§ù‚Äçüë®üèø üîê EHCI humanamente em russo ü§∂üèæ üò† üíÉüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 Congratulo-me com todos. Hoje, quero compartilhar minha experi√™ncia e ainda, na minha opini√£o, explicar claramente sobre tal, √† primei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EHCI humanamente em russo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426421/"><img src="https://habrastorage.org/webt/kk/0o/he/kk0ohepnkx9kfrbmht7mtec5pr4.jpeg" alt="imagem"><br><br><h3>  <b>1. Introdu√ß√£o</b> </h3><br>  Congratulo-me com todos.  Hoje, quero compartilhar minha experi√™ncia e ainda, na minha opini√£o, explicar claramente sobre tal, √† primeira vista, um padr√£o simples para o controlador host USB 2.0. <br><br>  Inicialmente, voc√™ pode imaginar que uma porta USB 2.0 tem apenas 4 pinos, dois dos quais simplesmente transmitem dados (como, por exemplo, uma porta COM), mas, na verdade, nem tudo √© assim, e at√© o contr√°rio.  O controlador USB, em princ√≠pio, n√£o nos permite transferir dados como atrav√©s de uma porta COM comum.  O EHCI √© um padr√£o bastante complexo que permite a transfer√™ncia r√°pida e confi√°vel de dados do software para o pr√≥prio dispositivo e na dire√ß√£o oposta. <br><br>  Voc√™ pode achar este artigo √∫til se, por exemplo, voc√™ n√£o tiver habilidades suficientes de escrita para drivers e leitura de documenta√ß√£o para um hardware.  Um exemplo simples: voc√™ deseja gravar seu sistema operacional para um mini PC, para que algumas distribui√ß√µes Windows ou Linux n√£o fa√ßam o download de hardware e voc√™ use toda a sua energia exclusivamente para seus pr√≥prios fins. <br><a name="habracut"></a><br><h3>  <b>O que √© EHCI?</b> </h3><br>  Bem, vamos come√ßar.  O EHCI - Enhanced Host Controller Interface, foi projetado para transferir dados e controlar solicita√ß√µes para dispositivos USB, e em outra dire√ß√£o, e em 99% dos casos, √© um link entre qualquer software e um dispositivo f√≠sico.  O EHCI funciona como um dispositivo PCI e, portanto, usa o MMIO (IO mapeado na mem√≥ria) para controlar o controlador (sim, eu sei que alguns dispositivos PCI usam portas, mas aqui generalizei tudo).  A documenta√ß√£o da Intel descreve apenas o princ√≠pio de opera√ß√£o e n√£o h√° dicas para todos os algoritmos escritos pelo menos em pseudo-c√≥digo.  O EHCI possui 2 tipos de registradores MMIO: Capacidade e Operacional.  Os primeiros servem para obter as caracter√≠sticas do controlador, enquanto os √∫ltimos servem para control√°-lo.  Na verdade, anexarei a ess√™ncia da conex√£o entre o software e o controlador EHCI: <br><br><img src="https://habrastorage.org/webt/rh/px/zr/rhpxzre1s167jv51xhcz_shffsu.jpeg" alt="imagem"><br><br>  Cada controlador EHCI possui v√°rias portas, cada uma das quais pode ser conectada a qualquer dispositivo USB.  Al√©m disso, observe que o EHCI √© uma vers√£o aprimorada do UHCI, que tamb√©m foi desenvolvida pela Intel alguns anos antes.  Para compatibilidade com vers√µes anteriores, qualquer controlador UHCI / OHCI que tenha uma vers√£o menor que o EHCI ser√° um companheiro para o EHCI.  Por exemplo, voc√™ tem um teclado USB (e a maioria dos teclados do ano at√© agora tem sido assim) que funciona no USB 1.1 (observe que a velocidade m√°xima do USB 1.1 √© de 12 megabits por segundo, e o FullSpeed ‚Äã‚ÄãUSB 2.0 tem largura de banda 480 Mbps) e voc√™ possui um computador com uma porta USB 2.0. Ao conectar o teclado ao computador, o controlador host EHCI funcionar√° de alguma forma com o USB 1.1.  Este modelo √© mostrado no diagrama a seguir: <br><br><img src="https://habrastorage.org/webt/61/mg/lf/61mglfeajk5ivpcqmwjkazxniwy.jpeg" alt="imagem"><br><br>  Al√©m disso, no futuro, quero avisar imediatamente que seu driver pode n√£o funcionar corretamente devido a uma situa√ß√£o t√£o absurda: voc√™ inicializou o UHCI e o EHCI, ao adicionar dois dispositivos id√™nticos, defina o bit Port Owner Control como o registro da porta e, em seguida, O UHCI parou de funcionar, devido ao fato de o EHCI arrastar automaticamente a porta para si mesma e a porta no UHCI parar de responder, essa situa√ß√£o precisa ser monitorada. <br><br>  Al√©m disso, vejamos um diagrama mostrando a arquitetura EHCI: <br><br><img src="https://habrastorage.org/webt/vq/t-/nt/vqt-ntbqnrcrz4k8he1uzngwyyo.jpeg" alt="imagem"><br><br>  √Ä direita est√° escrito sobre a fila - sobre eles um pouco mais tarde. <br><br><h2>  Registradores do controlador EHCI </h2><br>  Para come√ßar, quero esclarecer mais uma vez que atrav√©s desses registros voc√™ controlar√° seu dispositivo, portanto eles s√£o muito importantes - e sem eles a programa√ß√£o EHCI √© imposs√≠vel. <br><br>  Primeiro, voc√™ precisa obter o endere√ßo MMIO que √© dado a este controlador, no deslocamento + 0x10 ser√° o endere√ßo dos nossos t√£o aguardados registradores.  H√° uma coisa: primeiro, os registros do Capability v√£o, e somente depois deles - Operacional, portanto, no deslocamento 0 (do endere√ßo anterior, que recebemos no deslocamento 0x10 em rela√ß√£o ao in√≠cio do MMIO do nosso EHCI), h√° um byte - o comprimento dos registros do Capability. <br><br><h3>  <b>Registros de capacidade</b> </h3><br>  No deslocamento 2, o registro <b>HCIVERSION</b> est√° <b>localizado</b> - o n√∫mero de revis√£o deste HC, que ocupa 2 bytes e cont√©m a vers√£o BCD da revis√£o (o que o BCD pode ser encontrado na Wikipedia). <br>  No deslocamento +4, o registro <b>HCSPARAMS</b> est√° <b>localizado</b> , seu tamanho √© 2 palavras, cont√©m os par√¢metros estruturais do dispositivo e seus bits mostram o seguinte: <br><br><ul><li>  Bit 16 - Indicadores de porta - LEDs dispon√≠veis para dispositivos USB conectados. </li><li>  Bits 15:12 - o n√∫mero do controlador associado que est√° atribu√≠do a este controlador </li><li>  Bits 11: 8 - o n√∫mero de portas no controlador complementar </li><li>  Bit 7 - Port Routing Rules - mostra como essas portas s√£o mapeadas para portas complementares </li><li>  Bit 4 - Port Power Control - indica se √© necess√°rio ligar a energia de cada porta, 0 - a energia √© fornecida automaticamente </li><li>  Bits 3: 0 - o n√∫mero de portas para este controlador. </li><li>  No deslocamento +8 est√° o registro HCCPARAMS - mostra par√¢metros de compatibilidade, seus bits significam o seguinte: </li><li>  Bit 2 - disponibilidade de fila ass√≠ncrona, </li><li>  Bit 1 - disponibilidade da fila peri√≥dica (sequencial) </li><li>  Compatibilidade com bits 0 - 64 bits </li></ul><br><h3>  <b>Registros de opera√ß√£o</b> </h3><br>  No deslocamento 0, o registro <b>USBCMD</b> √© o registro de comando do controlador, seus bits significam o seguinte: <br><br><ul><li>  Bits 23:16 - Controle de limite de interrup√ß√£o - mostra quantos micro-quadros ser√£o usados ‚Äã‚Äãpara um quadro regular.  Quanto maior, mais r√°pido, mas se for maior que 8, os micro-frames ser√£o processados ‚Äã‚Äãna mesma velocidade que para 8. </li><li>  Bit 6 - interrompa ap√≥s cada transa√ß√£o na fila ass√≠ncrona, </li><li>  Bit 5 - √© a fila ass√≠ncrona usada </li><li>  Bit 4 - uso de fila seq√ºencial, </li><li>  Bits 3: 2 - o tamanho de FrameList'a (mais sobre isso mais tarde).  0 significa 1024 elementos, 1 - 512, 2 - 256, 3 - reservados </li><li>  Bit 1 - Configure para redefinir o controlador host. </li><li>  Bit 0 - Executar / Parar </li></ul>  . <br>  Em seguida, no deslocamento +4, h√° o registro <b>USBSTS</b> - o status do controlador host, <br><br><ul><li>  O bit 15 indica se uma fila ass√≠ncrona est√° sendo usada. </li><li>  O bit 14 indica se uma fila seq√ºencial est√° sendo usada, </li><li>  Bit 13 - indica que uma fila ass√≠ncrona vazia foi detectada, </li><li>  O bit 12 √© definido como 1, se ocorrer um erro ao processar a transa√ß√£o, o controlador host interromper√° todas as filas. </li><li>  O bit 4 √© definido como 1; se ocorrer um erro grave, o controlador host interromper√° todas as filas. </li><li>  Bit 3 Rollover FrameList (Register) - definido como 1 quando o controlador host processou o frameList inteiro. </li><li>  Bit 1 - USB Error Interrupt - Eu gero uma interrup√ß√£o de erro? </li><li>  Bit 0 - USB Interrupt - definido ap√≥s o processamento bem-sucedido da transa√ß√£o, se o IOC foi instalado no TD </li></ul><br>  N√£o est√° cansado?  Voc√™ pode derramar uma gaivota forte e trazer o f√≠gado, estamos no come√ßo! <br><br>  No deslocamento +8, h√° um registro <b>USBINTR</b> - o registro de ativa√ß√£o de interrup√ß√£o <br>  Para n√£o escrever por muito tempo, e mais ainda, para voc√™ n√£o ler por muito tempo, os valores dos bits desse registro podem ser encontrados na especifica√ß√£o, um link para ele ser√° deixado abaixo.  Aqui eu apenas escrevo 0, porque  N√£o tenho absolutamente nenhum desejo de escrever manipuladores, interrup√ß√µes de mapas etc., ent√£o acho que isso √© quase completamente in√∫til. <br><br>  No deslocamento +12 (0x0C), o registro <b>FRINDEX</b> est√° <b>localizado</b> , no qual o n√∫mero do quadro atual simplesmente se encontra, e quero observar que os √∫ltimos 4 bits mostram o n√∫mero do micro-quadro, nos 28 bits superiores o n√∫mero do quadro (o valor tamb√©m n√£o √© necessariamente menor que o tamanho do quadro Mas se voc√™ precisar de um √≠ndice, √© melhor us√°-lo com uma m√°scara de 0x3FF (ou 0x1FF, etc.). <br><br>  O registro <b>CTRLDSSEGMENT</b> est√° no deslocamento + 0x10; mostra ao controlador host os 32 bits mais significativos do endere√ßo da folha de quadros. <br><br>  O registro <b>PERIODICLISTBASE</b> possui um deslocamento de + 0x14; voc√™ pode inserir os 32 bits inferiores da folha de quadros, observe que o endere√ßo deve estar alinhado ao tamanho da p√°gina de mem√≥ria (4096). <br><br>  O registro <b>ASYNCLISTADDR</b> tem um deslocamento de + 0x18, voc√™ pode colocar o endere√ßo da fila ass√≠ncrona, observe que ele deve estar alinhado no limite de 32 bytes, enquanto deve estar nos primeiros quatro gigabytes de mem√≥ria f√≠sica. <br><br>  O registro <b>CONFIGFLAG</b> indica se o dispositivo est√° configurado.  Voc√™ deve definir o bit 0 ap√≥s concluir a configura√ß√£o do dispositivo, pois possui um deslocamento de + 0x40. <br><br>  Vamos para os registros de portas.  Cada porta tem seu pr√≥prio registro de status de comando, cada registro de porta √© compensado <b>+ 0x44 + (PortNumber - 1) * 4</b> , seus bits significam o seguinte: <br><br><ul><li>  Bit 12 - energia da porta, 1 - energia √© fornecida, 0 - n√£o. </li><li>  O Bit 8 - Port Rest - est√° definido para redefinir o dispositivo. </li><li>  Bit 3 - Port Enable / Disable Change - defina ao alterar o status da "inclus√£o" da porta. </li><li>  Bit 2 - porta ligada / desligada. </li><li>  Bit 1 - Altere o status da conex√£o, √© definido como 1, por exemplo, se voc√™ conectou ou desconectou um dispositivo USB. </li><li>  Bit 0 - status da conex√£o, 1 - conectado, 0 - n√£o. </li></ul><br>  Agora vamos ao suco em si. <br><br><h2>  Transfer√™ncia de dados e estruturas de consulta </h2><br>  A organiza√ß√£o de uma estrutura para processar solicita√ß√µes inclui filas e descritores de transfer√™ncia (TDs). <br><br>  No momento, consideraremos apenas tr√™s estruturas. <br><br><h3>  Lista sequencial </h3><br>  A lista sequencial (Peri√≥dica, Pereodic) est√° organizada da seguinte maneira: <br><br><img src="https://habrastorage.org/webt/hv/2h/23/hv2h23mnmv5uks1ffugte6ycpcu.jpeg" alt="imagem"><br><br>  Como voc√™ pode ver no diagrama, o processamento come√ßa com a obten√ß√£o do quadro desejado a partir do quadro da folha, cada um de seus elementos ocupa 4 bytes e possui a seguinte estrutura: <br><br><img src="https://habrastorage.org/webt/o_/m7/ic/o_m7icnqm0ifgvnfpfycwahilwy.jpeg" alt="imagem"><br><br>  Como voc√™ pode ver na figura, a transfer√™ncia do endere√ßo da fila / descritor est√° alinhada no limite de 32 bytes; o bit 0 significa que o controlador host n√£o processar√° esse elemento; os bits 3: 1 indicam o tipo de processamento do controlador host: 0 - TD isoss√≠ncrono (iTD), 1 turno, 2 e 3 neste artigo, n√£o considerarei. <br><br><h3>  Fila ass√≠ncrona </h3><br>  O controlador host processa essa fila apenas quando o quadro seq√ºencial est√° vazio ou o controlador host processou a lista serial inteira. <br><br>  Uma fila ass√≠ncrona √© um ponteiro para uma fila que cont√©m outras filas que precisam de processamento.  Esquema: <br><br><img src="https://habrastorage.org/webt/rz/sv/4s/rzsv4sqoyqegzwqoij9vl7qpt14.jpeg" alt="imagem"><br><br><h3>  qTD (Descritor de transfer√™ncia de elementos da fila) </h3><br>  Este TD tem a seguinte estrutura: <br><br><img src="https://habrastorage.org/webt/hf/gq/g5/hfgqg5fvujkx2bv8piy6i3gijyu.jpeg" alt="imagem"><br><br>  <b>Pr√≥ximo ponteiro qTD</b> - um ponteiro para a continua√ß√£o da fila para processamento (para execu√ß√£o horizontal), bit 0 O pr√≥ximo ponteiro qTD indica que n√£o h√° mais fila. <br>  <b>qTD Token</b> - token TD, mostra os par√¢metros de transfer√™ncia de dados: <br><br><ul><li>  Bit 31 - Altern√¢ncia de dados (mais sobre isso mais tarde) </li><li>  Bits 30:16 - a quantidade de dados a serem transferidos, ap√≥s a conclus√£o da transa√ß√£o, seu valor diminui pela quantidade de dados transferidos. </li><li>  Bit 15 - IOC - Interrupt On Complete - causa interrup√ß√£o ap√≥s a conclus√£o do processamento do descritor. </li><li>  Os bits 14:12 mostram o n√∫mero do buffer atual para o qual os dados s√£o trocados, mais sobre isso posteriormente. </li><li>  Bits 11:10 - o n√∫mero de erros permitido.  Esta tabela mostra quando a contagem de erros diminui: <br><br><img src="https://habrastorage.org/webt/ko/hz/ia/kohzia9y2vxtrd1tepp-h5qokgm.jpeg" alt="imagem"><br><br>  Nota de rodap√© 1 - a detec√ß√£o de Babble ou Stall interrompe automaticamente a execu√ß√£o do cabe√ßalho da fila.  Nota de rodap√© 3 - Erros no buffer de dados s√£o problemas com o host.  Eles n√£o consideram novas tentativas do dispositivo. </li><li>  9: 8 - C√≥digo PID - tipo de token: 0 - token para a entrada (do host para o dispositivo), 1 - token para a sa√≠da (do dispositivo para o host), 2 - token ‚ÄúSETUP‚Äù </li><li>  Os bits 7: 0 indicam o status do TD: <br>  O bit 7 indica que o TD est√° em um estado ativo (ou seja, o controlador host processa esse TD) <br>  Bit 6 - Halted - indica que ocorreu um erro e a execu√ß√£o do TD foi interrompida. <br>  Bit 4 - Babble Detected - a quantidade de dados que enviamos ao dispositivo, ou por rota√ß√£o, √© menor do que a que transmitimos, ou seja, por exemplo, o dispositivo nos enviou 100 bytes de dados, e lemos apenas 50 bytes e depois outros 50 O bit interrompido tamb√©m ser√° definido se esse bit estiver definido como 1. <br>  Bit 3 - Erro de transa√ß√£o - Ocorreu um erro durante a transa√ß√£o. </li></ul><br>  <b>qTD Buffer Page Pointer List</b> - qualquer um dos 5 buffers.  Ele cont√©m um link para o local em que a transa√ß√£o deve ser realizada na mem√≥ria (enviar dados ao dispositivo / receber dados do dispositivo); todos os endere√ßos nos buffers, exceto o primeiro, devem estar alinhados ao tamanho da p√°gina (4096 bytes). <br><br><h3>  Chefe de linha </h3><br>  O cabe√ßalho da fila tem a seguinte estrutura: <br><br><img src="https://habrastorage.org/webt/9m/ob/l7/9mobl76mr1drsddxbgndgbgoneo.jpeg" alt="imagem"><br><br>  <b>Ponteiro de link horizontal da cabe√ßa da fila</b> - ponteiro para a pr√≥xima fila, os bits 2: 1 t√™m os seguintes valores, dependendo do tipo de fila: <br><br><img src="https://habrastorage.org/webt/bu/gw/sa/bugwsap9snr11blm5ifggvhei60.jpeg" alt="imagem"><br><br>  <b>Recursos / caracter√≠sticas do terminal</b> - caracter√≠sticas da fila: <br><br><ul><li>  Os bits 26:16 cont√™m o tamanho m√°ximo de pacote para transmiss√£o </li><li>  Bit 14: Controle de altern√¢ncia de dados - mostra onde o controlador host deve receber o valor inicial de altern√¢ncia de dados, 0 - ignora o bit DT em qTD, salva o bit DT para o cabe√ßalho da fila. </li><li>  Bit 13:12 - caracter√≠sticas da taxa de transmiss√£o: <img src="https://habrastorage.org/webt/gk/tb/sd/gktbsdm7kys5kcgk6e3uewkgf1q.jpeg" alt="imagem"></li><li>  Bits 11: 8 - o n√∫mero do terminal no qual a solicita√ß√£o √© feita </li><li>  Bits 6: 0 - endere√ßo do dispositivo </li></ul><br>  <b>Recursos do terminal: Cabe√ßalho da fila DWord 2</b> - continua√ß√£o da palavra dupla anterior: <br><br><ul><li>  Bits 29:23 - N√∫mero do cubo </li><li>  Bits 22:16 - Endere√ßo do hub </li></ul><br>  <b>Ponteiro de Link qTD atual</b> - ponteiro para o qTD atual. <br><br>  Passamos para o mais interessante. <br><br><h2>  Driver EHCI </h2><br>  Vamos come√ßar com as consultas que o EHCI pode atender.  Existem 2 tipos de solicita√ß√µes: Controle - a la command e Bulk - para terminais, para troca de dados, por exemplo, a grande maioria das unidades flash USB (USB MassStorage) usa o tipo de transfer√™ncia de dados Bulk / Bulk / Bulk.  O mouse e o teclado tamb√©m usam solicita√ß√µes em massa para transfer√™ncia de dados. <br><br>  Inicialize o EHCI e configure filas ass√≠ncronas e seq√ºenciais: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Base I/O Address PciBar bar; PciGetBar(&amp;bar, id, 0); EhciController *hc = VMAlloc(sizeof(EhciController)); hc-&gt;capRegs = (EhciCapRegs *)(uintptr_t)bar.u.address; hc-&gt;opRegs = (EhciOpRegs *)(uintptr_t)(bar.u.address + hc-&gt;capRegs-&gt;capLength); // Read the Command register //    uint cmd = ROR(usbCmdO); // Write it back, setting bit 2 (the Reset bit) //   ,   2(Reset) // and making sure the two schedule Enable bits are clear. //  ,  2   WOR(usbCmdO, 2 | cmd &amp; ~(CMD_ASE | CMD_PSE)); // A small delay here would be good. You don't want to read //     ,     // the register before it has a chance to actually set the bit //   ,         ROR(usbCmdO); // Now wait for the controller to clear the reset bit. //      Reset while (ROR(usbCmdO) &amp; 2); // Again, a small delay here would be good to allow the // reset to actually become complete. //   ROR(usbCmdO); // wait for the halted bit to become set //    Halted    while (!(ROR(usbStsO) &amp; STS_HCHALTED)); //     ,        // ,           128  hc-&gt;frameList = (u32 *)VMAlloc(1024 * sizeof(u32) + 8192 * 4); hc-&gt;frameList = (((uint)hc-&gt;frameList) / 16384) * 16384 + 16384; hc-&gt;qhPool = (EhciQH *)VMAlloc(sizeof(EhciQH) * MAX_QH + 8192 * 4); hc-&gt;tdPool = (EhciTD *)VMAlloc(sizeof(EhciTD) * MAX_TD + 8192 * 4); hc-&gt;qhPool = (((uint)hc-&gt;qhPool) / 16384) * 16384 + 16384; hc-&gt;tdPool = (((uint)hc-&gt;tdPool) / 16384) * 16384 + 16384; // Asynchronous queue setup //    EhciQH *qh = EhciAllocQH(hc); //     ,      // ,    qh-&gt;qhlp = (u32)(uintptr_t)qh | PTR_QH; //  ,  ,     qh-&gt;ch = QH_CH_H; qh-&gt;caps = 0; qh-&gt;curLink = 0; qh-&gt;nextLink = PTR_TERMINATE; qh-&gt;altLink = 0; qh-&gt;token = 0; //    for (uint i = 0; i &lt; 5; ++i) { qh-&gt;buffer[i] = 0; qh-&gt;extBuffer[i] = 0; } hc-&gt;asyncQH = qh; // Periodic list queue setup //    qh = EhciAllocQH(hc); //     qh-&gt;qhlp = PTR_TERMINATE; qh-&gt;ch = 0; qh-&gt;caps = 0; qh-&gt;curLink = 0; qh-&gt;nextLink = PTR_TERMINATE; qh-&gt;altLink = 0; qh-&gt;token = 0; //   for (uint i = 0; i &lt; 5; ++i) { qh-&gt;buffer[i] = 0; qh-&gt;extBuffer[i] = 0; } qh-&gt;transfer = 0; qh-&gt;qhLink.prev = &amp;qh-&gt;qhLink; qh-&gt;qhLink.next = &amp;qh-&gt;qhLink; hc-&gt;periodicQH = qh; //        for (uint i = 0; i &lt; 1024; ++i) hc-&gt;frameList[i] = PTR_QH | (u32)(uintptr_t)qh; kprintf("FrameList filled. Turning off Legacy BIOS support..."); // Check extended capabilities //  BIOS Legacy support uint eecp = (RCR(hccParamsO) &amp; HCCPARAMS_EECP_MASK) &gt;&gt; HCCPARAMS_EECP_SHIFT; if (eecp &gt;= 0x40) { // Disable BIOS legacy support uint legsup = PciRead32(id, eecp + USBLEGSUP); kprintf("."); if (legsup &amp; USBLEGSUP_HC_BIOS) { PciWrite32(id, eecp + USBLEGSUP, legsup | USBLEGSUP_HC_OS); kprintf("."); for (;;) { legsup = PciRead32(id, eecp + USBLEGSUP); kprintf("."); if (~legsup &amp; USBLEGSUP_HC_BIOS &amp;&amp; legsup &amp; USBLEGSUP_HC_OS) { break; } } } } kprintf("Done\n"); // Disable interrupts //   //hc-&gt;opRegs-&gt;usbIntr = 0; MWIR(ehcibase, usbIntrO, 0); // Setup frame list //     //hc-&gt;opRegs-&gt;frameIndex = 0; WOR(frameIndexO, 0); //hc-&gt;opRegs-&gt;periodicListBase = (u32)(uintptr_t)hc-&gt;frameList; WOR(periodicListBaseO, (u32)(uintptr_t)hc-&gt;frameList); //       //hc-&gt;opRegs-&gt;asyncListAddr = (u32)(uintptr_t)hc-&gt;asyncQH; WOR(asyncListAddrO, (u32)(uintptr_t)hc-&gt;asyncQH); //    0 //hc-&gt;opRegs-&gt;ctrlDsSegment = 0; WOR(ctrlDsSegmentO, 0); // Clear status //   //hc-&gt;opRegs-&gt;usbSts = ~0; WOR(usbStsO, ~0); // Enable controller //  , 8 -,  //     //hc-&gt;opRegs-&gt;usbCmd = (8 &lt;&lt; CMD_ITC_SHIFT) | CMD_PSE | CMD_ASE | CMD_RS; WOR(usbCmdO, (8 &lt;&lt; CMD_ITC_SHIFT) | CMD_PSE | CMD_ASE | CMD_RS); while (ROR(usbStsO)&amp;STS_HCHALTED); // Configure all devices to be managed by the EHCI // ,   //hc-&gt;opRegs-&gt;configFlag = 1; WOR(configFlagO, 1);\ // Probe devices //   EhciProbe(hc);</span></span></code> </pre> <br>  Na verdade, o c√≥digo para redefinir a porta para seu estado original: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> u32 *reg = &amp;hc-&gt;opRegs-&gt;ports[port]; <span class="hljs-comment"><span class="hljs-comment">//    ,  100 *reg|=(1&lt;&lt;12)|(1&lt;&lt;20); Wait(100); //  ,  50  EhciPortSet(reg, PORT_RESET | (1&lt;&lt;12) | (1&lt;&lt;20) | (1&lt;&lt;6)); Wait(50); EhciPortClr(reg, PORT_RESET); // Wait 100ms for port to enable (TODO - what is appropriate length of time?) //  100    ,   , //  100    uint status = 0; for (uint i = 0; i &lt; 10; ++i) { // Delay Wait(10); // Get current status //    status = *reg; // Check if device is attached to port //      if (~status &amp; PORT_CONNECTION) break; // Acknowledge change in status //    -    if (status &amp; (PORT_ENABLE_CHANGE | PORT_CONNECTION_CHANGE)) { EhciPortClr(reg, PORT_ENABLE_CHANGE | PORT_CONNECTION_CHANGE); continue; } // Check if device is enabled //    ,    if (status &amp; PORT_ENABLE) break; } return status;</span></span></code> </pre><br>  Solicita√ß√£o de controle para o dispositivo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EhciDevControl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UsbDevice *dev, UsbTransfer *t)</span></span></span><span class="hljs-function"> </span></span>{ EhciController *hc = (EhciController *)dev-&gt;hc; UsbDevReq *req = t-&gt;req; <span class="hljs-comment"><span class="hljs-comment">// Determine transfer properties //    uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint maxSize = dev-&gt;maxPacketSize; uint type = req-&gt;type; uint len = req-&gt;len; // Create queue of transfer descriptors //   TDs EhciTD *td = EhciAllocTD(hc); if (!td) return; EhciTD *head = td; EhciTD *prev = 0; // Setup packet //   uint toggle = 0; uint packetType = USB_PACKET_SETUP; uint packetSize = sizeof(UsbDevReq); EhciInitTD(td, prev, toggle, packetType, packetSize, req); prev = td; // Data in/out packets packetType = type &amp; RT_DEV_TO_HOST ? USB_PACKET_IN : USB_PACKET_OUT; u8 *it = (u8 *)t-&gt;data; u8 *end = it + len; //EhciPrintTD(td); while (it &lt; end) { td = EhciAllocTD(hc); if (!td) return; toggle ^= 1; packetSize = end - it; if (packetSize &gt; maxSize) packetSize = maxSize; EhciInitTD(td, prev, toggle, packetType, packetSize, it); it += packetSize; prev = td; } // Status packet //   td = EhciAllocTD(hc); if (!td) return; toggle = 1; packetType = type &amp; RT_DEV_TO_HOST ? USB_PACKET_OUT : USB_PACKET_IN; EhciInitTD(td, prev, toggle, packetType, 0, 0); // Initialize queue head //   : EhciQH *qh = EhciAllocQH(hc); EhciInitQH(qh, t, head, dev-&gt;parent, false, speed, addr, 0, maxSize); // Wait until queue has been processed //       EhciInsertAsyncQH(hc-&gt;asyncQH, qh); EhciWaitForQH(hc, qh); }</span></span></code> </pre><br>  C√≥digo de processamento da fila: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_HALTED) { t-&gt;success = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; t-&gt;complete = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;nextLink &amp; PTR_TERMINATE) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (~qh-&gt;token &amp; TD_TOK_ACTIVE) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_DATABUFFER) kprintf(<span class="hljs-string"><span class="hljs-string">" Data Buffer Error\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_BABBLE) kprintf(<span class="hljs-string"><span class="hljs-string">" Babble Detected\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_XACT) kprintf(<span class="hljs-string"><span class="hljs-string">" Transaction Error\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_MMF) kprintf(<span class="hljs-string"><span class="hljs-string">" Missed Micro-Frame\n"</span></span>); t-&gt;success = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; t-&gt;complete = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t-&gt;complete) ....</code> </pre><br>  E agora a solicita√ß√£o de terminal (solicita√ß√£o em massa) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EhciDevIntr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UsbDevice *dev, UsbTransfer *t)</span></span></span><span class="hljs-function"> </span></span>{ EhciController *hc = (EhciController *)dev-&gt;hc; <span class="hljs-comment"><span class="hljs-comment">// Determine transfer properties //    uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint maxSize = t-&gt;endp-&gt;desc-&gt;maxPacketSize; uint endp = t-&gt;endp-&gt;desc-&gt;addr &amp; 0xf; EhciTD *td = EhciAllocTD(hc); if (!td) { t-&gt;success = false; t-&gt;complete = true; return; } EhciTD *head = td; EhciTD *prev = 0; // Data in/out packets uint toggle = t-&gt;endp-&gt;toggle; uint packetType = t-&gt;endp-&gt;desc-&gt;addr &amp; 0x80 ? USB_PACKET_IN : USB_PACKET_OUT; uint packetSize = t-&gt;len; EhciInitTD(td, prev, toggle, packetType, packetSize, t-&gt;data); // Initialize queue head //    EhciQH *qh = EhciAllocQH(hc); EhciInitQH(qh, t, head, dev-&gt;parent, true, speed, addr, endp, maxSize); //printQh(qh); // Schedule queue //    EhciInsertPeriodicQH(hc-&gt;periodicQH, qh); }</span></span></code> </pre><br>  Eu acho que o t√≥pico √© bastante interessante, na Internet em russo quase n√£o h√° documenta√ß√£o, descri√ß√µes e artigos sobre esse t√≥pico, e se houver, √© muito emba√ßado.  Se o t√≥pico de trabalhar com o desenvolvimento de hardware e sistema operacional for interessante, h√° muito a dizer. <br><br>  Docas: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Especifica√ß√£o</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt426421/">https://habr.com/ru/post/pt426421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt426411/index.html">Desenvolvendo Classes de Descritores C ++ / CLI</a></li>
<li><a href="../pt426413/index.html">Princ√≠pios do SOLID que todo desenvolvedor deve conhecer</a></li>
<li><a href="../pt426415/index.html">Fintech-digest: controle de digitaliza√ß√£o pelo Banco Central, sal√°rio de criptomoeda, cart√£o Mir em forma de pulseiras e chaveiros</a></li>
<li><a href="../pt426417/index.html">Pavel 2.0: consultor reptil√≥ide em JS, node.js com soquetes e telefonia</a></li>
<li><a href="../pt426419/index.html">M√©todos de sobrecarga ou ponte proibidos em Java</a></li>
<li><a href="../pt426423/index.html">mmWave em smartphones: como a Qualcomm tornou poss√≠vel o imposs√≠vel</a></li>
<li><a href="../pt426425/index.html">Toda a verdade sobre o RTOS. Artigo 14. Se√ß√µes de mem√≥ria: introdu√ß√£o e servi√ßos b√°sicos</a></li>
<li><a href="../pt426427/index.html">Coisas √∫teis para "coisas": uma pequena sele√ß√£o com pre√ßos baixos</a></li>
<li><a href="../pt426429/index.html">Instalando o FreeSWITCH 1.8 no Debian 9 (Raspbian Stretch, a imagem b√°sica do sistema Smart Home do MajorDoMo no Rasbperri Pi)</a></li>
<li><a href="../pt426431/index.html">Desmontando o mecanismo de romance visual Qlie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>