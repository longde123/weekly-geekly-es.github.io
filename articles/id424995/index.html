<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§œ ğŸ•¥ ğŸ›’ Sistem partikel lain. Post mortem ğŸ¤¶ğŸ¼ ğŸ” ğŸ¤™ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada bulan September tahun ini, game mobile Titan World dari Unstoppable, kantor Mlu mobile Glu, akan dirilis. Proyek itu dibatalkan tepat sebelum ril...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistem partikel lain. Post mortem</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424995/"><img src="https://habrastorage.org/webt/mr/k9/jt/mrk9jtkw0lnm7z8b6gh-hkxmwru.png" alt="gambar"><br><br>  <b>Pada bulan September tahun ini, game mobile Titan World dari Unstoppable, kantor Mlu mobile Glu, akan dirilis.</b>  <b>Proyek itu dibatalkan tepat sebelum rilis dunia.</b>  <b>Tetapi prestasi tetap, dan yang paling menarik dari mereka, dengan izin baik dari kepala studio Dennis Zdonov dan Alex Paley, saya ingin berbagi dengan publik.</b> <br><a name="habracut"></a><br>  Pada bulan Maret 2018, pemimpin tim dan saya mengadakan pertemuan di mana kami membahas apa yang harus dilakukan selanjutnya: kode render selesai, dan tidak ada fitur baru dan efek khusus dalam rencana.  Rasanya seperti pilihan logis untuk menulis ulang sistem partikel dari awal - menurut semua tes, ini memberikan penurunan terbesar dalam produktivitas, ditambah itu membuat desainer gila dengan antarmuka (file konfigurasi teks) dan kemampuan yang sangat sedikit. <br><br>  Perlu dicatat bahwa sebagian besar waktu tim bekerja pada permainan dalam mode "besok rilis", jadi saya menulis semua subsistem, pertama, berusaha untuk tidak merusak apa yang sudah bekerja, dan kedua, dengan siklus pengembangan pendek.  Secara khusus, sebagian besar efek yang tidak mampu dilakukan oleh sistem reguler dilakukan dalam fragmen shader tanpa mempengaruhi kode utama. <br><br>  Pembatasan jumlah partikel (matriks transformasi untuk setiap partikel dibentuk pada cpu, kesimpulannya adalah melalui installer dari ios gl-extensible), misalnya, perlu untuk menulis shader yang "ditiru" array besar partikel berdasarkan pada representasi analitik dari bentuk benda dan ditambah dengan ruang. palm off data palsu ke dalam buffer kedalaman. <br><br>  Koordinat-z dari fragmen dihitung untuk partikel bidang, seolah-olah kita sedang menggambar bola, dan jari-jari bola ini dimodulasi oleh sinus kebisingan Perlin dengan mempertimbangkan waktu: <br><br><pre><code class="hljs pgsql">r=<span class="hljs-number"><span class="hljs-number">.5</span></span>+<span class="hljs-number"><span class="hljs-number">.5</span></span>*sin(perlin(specialUV)+<span class="hljs-type"><span class="hljs-type">time</span></span>)</code> </pre> <br>  Penjelasan lengkap tentang rekonstruksi kedalaman bola dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ÃÃ±igo QuÃ­lez</a> , tetapi saya menggunakan kode yang disederhanakan dan lebih cepat.  Tentu saja, ia adalah perkiraan kasar, tetapi pada bentuk geometris yang kompleks (asap, ledakan) ia memberikan gambaran yang cukup baik. <br><br><img src="https://habrastorage.org/webt/tt/un/lw/ttunlwe3v4wj0snsxkjt-drx_fi.png" alt="gambar"><br>  <i>Tangkapan layar gameplay.</i>  <i>"Rok" asap dibuat dalam satu bagian kecil, beberapa lagi tertinggal di bagian utama ledakan.</i>  <i>Tentu saja, itu terlihat paling spektakuler "dari tanah", ketika asap dengan lembut menyelimuti bangunan dan unit, namun, proposal untuk mengubah posisi kamera selama ledakan tidak masuk ke produksi.</i> <br><br><h4>  Pernyataan masalah </h4><br>  Apa yang ingin Anda dapatkan di jalan keluar?  Kami pergi, lebih tepatnya, dari batasan-batasan yang membuat kami tersiksa pada sistem partikel sebelumnya.  Situasi ini diperburuk oleh fakta bahwa anggaran frame hampir habis, dan pada perangkat yang lemah (seperti ipad air), kedua pixel dan pipa vertex terisi penuh.  Oleh karena itu, saya ingin mendapatkan sistem yang paling produktif sebagai hasilnya, walaupun saya sedikit membatasi fungsionalitas. <br><br>  Desainer menyusun daftar fitur dan menggambar sketsa UI berdasarkan pengalaman dan praktik mereka sendiri dengan kesatuan, tidak nyata dan setelah efek. <br><br><h4>  Teknologi yang tersedia </h4><br>  Karena warisan dan pembatasan yang diberlakukan oleh kantor pusat, kami terbatas pada peluang 2. Oleh karena itu, teknologi seperti mengubah umpan balik yang digunakan dalam sistem partikel modern tidak tersedia. <br><br>  Apa yang tersisa?  Gunakan vertex tekstur untuk mengambil dan menyimpan posisi / akselerasi dalam tekstur?  Pilihan yang berfungsi, tetapi ingatannya juga hampir berakhir, kinerja solusi semacam itu bukanlah yang paling optimal, dan hasilnya tidak berbeda dalam keindahan arsitektur. <br><br>  Pada saat ini, saya telah membaca banyak artikel tentang penerapan sistem partikel pada GPU.  Sebagian besar berisi judul yang cerah ("jutaan partikel di gpu seluler, dengan preferensi dan penyair"), namun, implementasi datang ke contoh sederhana, meskipun penghibur / penarik yang tampak lucu, dan secara umum hampir tidak berguna untuk penggunaan nyata dalam permainan. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel ini</a> membawa manfaat maksimal: penulis memecahkan masalah nyata, dan tidak melakukan "partikel bola dalam ruang hampa".  Angka-angka patokan dari artikel ini dan hasil profiling menghemat banyak waktu pada tahap desain. <br><br><h4>  Cari pendekatan </h4><br>  Saya mulai dengan mengklasifikasikan masalah yang diselesaikan oleh sistem partikel dan mencari kasus-kasus tertentu.  Ternyata kira-kira berikut ini (sepotong dermaga nyata dari konsep dari korespondensi dengan pemimpin tim): <br><blockquote>  â€œ- Partikel / susunan jala dengan gerakan siklik.  Tidak ada posisi pemrosesan, semua melalui persamaan gerak.  Aplikasi - asap dari pipa, uap di atas air, salju / hujan, kabut volumetrik, pohon yang bergoyang, penggunaan parsial pada efek non-siklik dari ledakan alias dimungkinkan. <br><br>  - Kaset.  Pembentukan vb oleh acara, hanya memproses pada GPU (tembakan oleh sinar, penerbangan sepanjang lintasan tetap (?) Dengan jejak).  Mungkin varian dengan transfer koordinat start-finish ke seragam dan konstruksi pita oleh vertexID akan lepas landas.  dengan t.z.  render silang dengan fresnel seperti pada directlights + uvscroll. <br><br>  - Pembuatan partikel dan pemrosesan kecepatan.  Opsi paling fleksibel dan paling sulit / paling lambat, lihat pemrosesan gerak teknologi. " </blockquote><br>  Singkatnya: ada efek partikel yang berbeda, dan beberapa di antaranya dapat diimplementasikan lebih mudah daripada yang lain. <br><br>  Kami memutuskan untuk membagi tugas menjadi beberapa iterasi - dari yang sederhana ke yang kompleks.  Prototyping dilakukan pada engine / editor saya di bawah windows / directx11 karena fakta bahwa kecepatan pengembangan tersebut beberapa kali lipat lebih tinggi.  Proyek ini dikompilasi dalam beberapa detik, dan shader sepenuhnya diedit dengan cepat dan dikompilasi di latar belakang, menampilkan hasilnya secara real time dan tanpa memerlukan gerakan tambahan seperti menekan tombol.  Siapa pun yang membangun proyek besar dengan banyak macbook / xcode, saya pikir, akan memahami alasan keputusan ini. <br><br>  Semua contoh kode akan diambil dari prototipe windows. <br><br><img src="https://habrastorage.org/webt/of/p6/pi/ofp6pi_sus1zqlyamxxkb8-zoem.png" alt="gambar"><br>  <i>Lingkungan pengembangan untuk windows.</i> <br><br><h4>  Implementasi </h4><br>  Tahap pertama adalah output statis dari array partikel.  Tidak ada yang rumit: mulai vertex bufffer, isi dengan paha depan (tulis uv yang benar untuk setiap quad), dan jahit id simpul ke dalam uv "tambahan".  Setelah itu, di shader, dengan id titik berdasarkan pengaturan emitor, kami membentuk posisi partikel, dan dengan uv kami mengembalikan koordinat layar. <br><br>  Jika vertex_id tersedia secara native, Anda dapat sepenuhnya melakukannya tanpa buffer dan tanpa uv untuk mengembalikan koordinat layar (sebagai akibatnya dilakukan dalam versi windows). <br><br>  Shader: <br><br><pre> <code class="hljs pgsql">struct VS_INPUT { â€¦ uint v_id:SV_VertexID; â€¦ } //<span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.uv2.x/<span class="hljs-number"><span class="hljs-number">6.0</span></span>;// vertex_id   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = floor(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.v_id/<span class="hljs-number"><span class="hljs-number">6.0</span></span>);// vertex_id float2 map[<span class="hljs-number"><span class="hljs-number">6</span></span>]={<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}; float2 quaduv=map[frac(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.v_id/<span class="hljs-number"><span class="hljs-number">6.0</span></span>)*<span class="hljs-number"><span class="hljs-number">6</span></span>];</code> </pre> <br>  Setelah itu, Anda dapat menerapkan skenario sederhana dengan jumlah kode yang sangat kecil, misalnya, gerakan siklik dengan penyimpangan kecil cocok untuk efek salju.  Namun, tujuan kami adalah untuk memberikan kontrol terhadap perilaku partikel ke sisi para seniman, dan mereka, seperti yang Anda tahu, jarang tahu bagaimana cara shader.  Opsi dengan preset perilaku dan parameter pengeditan melalui slider juga tidak menarik - beralih shader atau bercabang di dalam, mengalikan opsi preset, kurangnya kontrol penuh. <br><br>  Tugas selanjutnya adalah mengimplementasikan fade in / fade out untuk sistem seperti itu.  Partikel seharusnya tidak muncul entah dari mana dan menghilang ke mana-mana.  Dalam implementasi klasik dari sistem partikel, kami memproses buffer secara terprogram menggunakan cpu, membuat partikel baru dan menghilangkan yang lama.  Bahkan, untuk mendapatkan kinerja yang baik, Anda perlu menulis manajer memori yang cerdas.  Tapi apa yang terjadi jika Anda tidak menggambar partikel "mati"? <br><br>  Misalkan (sebagai permulaan) bahwa interval waktu dari emisi partikel dan masa hidup suatu partikel adalah konstan dalam satu emitor tunggal. <br><br><img src="https://habrastorage.org/webt/96/bp/du/96bpdunpa_v6apnh6gqeoyh-7yq.jpeg" alt="gambar"><br>  Kemudian kita dapat secara spekulatif menyajikan buffer kita (yang hanya berisi id titik) sebagai lingkaran dan menentukan ukuran maksimumnya sebagai berikut: <br><br><pre> <code class="cpp hljs">pCount = round (prtPerSec * LifeTime / <span class="hljs-number"><span class="hljs-number">60.0</span></span>); pCountT = <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span> (prtPerSec * EmissionEndTime / <span class="hljs-number"><span class="hljs-number">60.0</span></span>); pCount=min (pCount, pCountT);</code> </pre> <br>  dan di shader, hitung waktu berdasarkan indeks dan waktu (waktu berlalu sejak awal efek) <br><br><pre> <code class="cpp hljs">pTime=time-index/prtPerSec;</code> </pre> <br>  Jika emitor berada dalam fase siklik (semua partikel dipancarkan dan sekarang mati dan dilahirkan secara serempak), kita membuat frac dari waktu partikel dan dengan demikian mendapatkan loop. <br><br>  Kita tidak perlu menggambar partikel dengan pTime kurang dari nol - mereka belum dilahirkan.  Hal yang sama berlaku untuk partikel di mana jumlah masa pakai dan waktu saat ini melebihi waktu akhir emisi.  Dalam kedua kasus, kami tidak akan menggambar apa pun dengan membatalkan ukuran partikel dan / atau menjatuhkannya di belakang layar.  Pendekatan ini akan memberikan overhead kecil dalam fase fadein / fadeout, sambil mempertahankan kinerja maksimum dalam fase berkelanjutan. <br><br>  Algoritma dapat sedikit ditingkatkan dengan mengirimkan hanya bagian dari buffer verteks yang berisi partikel hidup untuk rendering.  Karena kenyataan bahwa emisi terjadi secara berurutan, partikel-partikel hidup akan tersegmentasi paling banyak sekali, yaitu.  diperlukan dua drawcall. <br><br>  Sekarang, mengetahui waktu saat ini dari setiap partikel, Anda dapat mengatur kecepatan, akselerasi (dan, secara umum, parameter lainnya) untuk menulis persamaan gerak, menghasilkan koordinat di ruang dunia. <br><br>  Menggunakan dipulihkan dari vertex_id uv, kita sudah akan mendapatkan empat poin (lebih tepatnya, kita akan memindahkan masing-masing titik quad ke arah yang kita butuhkan), di mana vertex shader, setelah menyelesaikan proyeksi, akan menyelesaikan pekerjaannya. <br><br><pre> <code class="hljs">p.xy+=(quaduv-.5);</code> </pre><br>  Dengan bonus gratis, kami mendapat kesempatan tidak hanya untuk menjeda emitor, tetapi juga untuk memundurkan waktu bolak-balik dengan akurasi ke frame.  Fitur ini ternyata sangat berguna dalam desain efek kompleks. <br><br><h4>  Kami meningkatkan fungsionalitasnya </h4><br>  Iterasi berikutnya dalam pengembangan adalah solusi untuk masalah emitor bergerak.  Sistem khusus kami tidak tahu apa-apa tentang posisinya, dan ketika emitor bergerak, seluruh efek bergerak secara serempak di belakangnya.  Untuk asap dari pipa knalpot dan efek serupa, itu terlihat lebih dari aneh. <br><br>  Idenya adalah untuk merekam posisi emitor dalam buffer verteks ketika partikel baru lahir.  Karena jumlah partikel tersebut kecil, overhead seharusnya minimal. <br><br>  Seorang kolega menyarankan bahwa ketika mengembangkan UI-nya sendiri, ia menggunakan map / unmap hanya bagian dari vertex buffer dan cukup senang dengan kinerja solusi ini.  Saya melakukan tes, dan ternyata pendekatan ini benar-benar berfungsi dengan baik pada platform desktop dan mobile. <br><br>  Kesulitan muncul dengan sinkronisasi waktu pada cpu dan gpu.  Itu perlu untuk memastikan bahwa pembaruan buffer dibuat tepat ketika partikel "baru" yang dilingkarkan berada di posisi awal.  Artinya, sehubungan dengan buffer cincin, perlu untuk menyinkronkan batas-batas wilayah pembaruan dengan waktu operasi emitor. <br><br>  Saya mentransfer kode hlsl ke C ++, untuk pengujian saya menulis emitor bergerak di sekitar Lissajous, dan semua ini tiba-tiba berhasil.  Namun, dari waktu ke waktu, sistem "meludah" satu partikel atau lebih, menembakkannya ke arah yang sewenang-wenang, tidak mengeluarkannya tepat waktu, atau membuat yang baru di tempat yang sewenang-wenang. <br><br>  Masalahnya diselesaikan dengan mengaudit keakuratan menghitung waktu di mesin dan secara bersamaan memeriksa delta waktu saat merekam posisi emitor baru - sehingga seluruh bagian buffer yang tidak terpengaruh oleh iterasi sebelumnya diperbarui.  Sistem ini juga diperlukan untuk bekerja dalam kondisi desync yang dipaksakan - penarikan tiba-tiba fps tidak boleh merusak efeknya, terutama karena untuk perangkat yang berbeda permainan kami mencatat fps yang berbeda sesuai dengan kinerja - 60/30/20. <br><br>  Kode metode telah berkembang cukup banyak (buffer cincin sulit untuk diproses secara elegan), namun, setelah memperhitungkan semua kondisi, sistem bekerja dengan benar dan stabil. <br><br>  Sekitar waktu ini, mitra sudah membuat "ikan" dari editor, cukup untuk menguji sistem, dan menulis templat / api untuk mengintegrasikan sistem ke mesin kami. <br><br>  Saya porting semua kode ke ios / opengl, terintegrasi dan akhirnya membuat tes efek nyata pada perangkat nyata.  Menjadi jelas bahwa sistem tidak hanya berfungsi, tetapi juga cocok untuk produksi.  Tetap menyelesaikan editor UI dan memoles kode ke negara "itu tidak menakutkan untuk memberikannya untuk rilis besok". <br><br>  Kami bahkan sudah siap untuk menulis manajer memori agar tidak mengalokasikan / menghancurkan buffer (yang akhirnya disimpan vertex_id, uv, posisi dan vektor partikel awal) untuk setiap efek baru dengan emitor dinamis, ketika ide lain datang ke kepala saya. <br><br>  Fakta keberadaan buffer vertex dalam sistem ini menghantuiku.  Dia jelas melihat dalam arkaismenya, "warisan zaman kegelapan dari conveyor tetap."  Ketika membuat efek pengujian pada prototipe windows, saya berpikir bahwa gerakan emitor selalu mulus dan selalu jauh lebih lambat daripada gerakan partikel.  Selain itu, dengan sejumlah besar partikel, memperbarui posisi mengarah pada fakta bahwa ratusan partikel merekam data yang sama.  Solusinya ternyata sederhana: kami memperkenalkan array tetap ke mana "sejarah" posisi emitor, dinormalisasi oleh masa hidup partikel, akan jatuh.  Dan pada GPU kami akan menginterpolasi data.  Setelah itu, kebutuhan buffer dinamis menghilang dalam versi ios / gles2 (hanya statis umum yang tersisa untuk mengimplementasikan vertex_id), dan pada versi windows / dx11 buffer menghilang sama sekali karena vertex_id asli dan kemampuan d3d api untuk menerima null alih-alih menghubungkan ke buffer vertex. <br><br>  Dengan demikian, versi-menang dari sistem, dengan standar modern, tidak mengkonsumsi memori sama sekali, tidak peduli berapa banyak partikel yang ingin kita tampilkan.  Hanya penyangga konstan kecil dengan parameter, penyangga posisi / pangkalan (60 pasang vektor ternyata cukup, dengan margin, untuk setiap kasus), dan, jika perlu, tekstur.  Pengukuran kinerja menunjukkan kecepatan yang dekat dengan tes sintetis. <br><br>  Selain itu, "ekor" dalam efek seperti bunga api mulai terlihat jauh lebih alami, karena interpolasi memungkinkan untuk menghapus diskritisasi dengan bingkai dan dengan cara ini emitor mengubah posisinya dengan lancar, seolah-olah menggambar panggilan dilakukan dengan frekuensi ratusan hertz. <br><br><h4>  Fitur </h4><br>  Selain fungsi dasar dari penerbangan partikel (kecepatan, akselerasi, gravitasi, ketahanan medium), kami membutuhkan sejumlah "lemak" fungsional. <br>  Akibatnya, gerakan kabur (peregangan partikel di sepanjang vektor gerakan), orientasi partikel melintasi vektor gerakan (ini memungkinkan, misalnya, untuk membuat bola partikel), mengubah ukuran partikel sesuai dengan waktu saat ini dalam hidupnya, dan lusinan hal kecil lainnya dilaksanakan. <br><br>  Kompleksitas muncul dengan bidang vektor: karena sistem tidak menyimpan keadaannya (posisi, akselerasi, dll.) Untuk setiap partikel, tetapi menghitungnya setiap kali melalui persamaan gerak, sejumlah efek (seperti pergerakan busa saat mengaduk kopi) pada prinsipnya tidak mungkin.  Namun, modulasi sederhana kecepatan dan akselerasi oleh suara perlin memberikan hasil yang terlihat cukup modern.  Perhitungan noise real-time untuk begitu banyak partikel ternyata terlalu mahal (bahkan dengan batas lima oktaf), sehingga tekstur dihasilkan dari mana vertex shader kemudian akan sampel.  Untuk meningkatkan efek bidang vektor palsu, pergeseran kecil koordinat sampel ditambahkan tergantung pada waktu saat emitor. <br><br><img src="https://habrastorage.org/webt/sq/vu/xs/sqvuxsyjwxocojucmja_ynqtnjc.png" alt="gambar"><br>  <i>Tes asap rokok bekerja dengan mendistribusikan kecepatan awal dan akselerasi terhadap kebisingan perlin.</i> <br><br><h4>  Konveyor piksel </h4><br>  Awalnya, kami hanya berencana untuk mengubah warna / transparansi partikel tergantung pada waktunya.  Saya menambahkan beberapa algoritma ke pixel shader. <br><br>  Rotasi warna tekstur - disederhanakan, sin (warna + waktu).  Memungkinkan sampai batas tertentu meniru efek permutasi dari AfterEffects. <br><br>  Pencahayaan palsu - modulasi warna partikel oleh gradien dalam koordinat dunia, terlepas dari sudut rotasi partikel. <br><br>  Evolusi perbatasan - ketika sebuah partikel bergerak di ruang angkasa, perbatasannya (saluran alpha) dimodulasi oleh kombinasi sorotan dan suara perlin, yang memberikan dinamika alirannya, sangat mirip dengan awan, asap, dan efek cairan lainnya. <br><br>  Kode Pseudo Shader: <br><br><pre> <code class="hljs lisp">b=perlin(<span class="hljs-name"><span class="hljs-name">uv</span></span>)<span class="hljs-comment"><span class="hljs-comment">;// , uv      a=saturate(1-length(input.uv.xy-.5)*2);//     a-=abs(ab);//â€â€,  </span></span></code> </pre> <br>  Dalam versi yang sedikit rumit, shader ini bisa menggambar perbatasan dengan kelembutan yang sewenang-wenang dan dengan highlight kontur, yang menambahkan efek "eksplosif" ke realisme. <br><br><img src="https://habrastorage.org/webt/fz/sp/lf/fzsplfbanmnupkdppk2gqj3mlcy.png" alt="gambar"><br>  <i>Eksperimen pertama dengan evolusi batas.</i> <br><br><h4>  Apa selanjutnya </h4><br>  Meskipun editor, sudah siap untuk bekerja dan terintegrasi ke dalam mesin, para perancang tidak punya waktu untuk membuat efek tunggal di atasnya - proyek ditutup.  Namun demikian, tidak ada hambatan untuk menggunakan praktik-praktik ini di tempat lain - misalnya, untuk melakukan pekerjaan pada Demo Revisi. <br><br>  Dari sudut pandang teknologi, ada juga ruang untuk bergerak - sekarang, misalnya, beberapa efek penghancuran objek kerangka kawat sedang beroperasi: <br><br><img src="https://habrastorage.org/webt/g7/-0/ab/g7-0abs_dlath0s8dxewlrgs1ju.png" alt="gambar"><br><br>  Pertanyaan tentang penyortiran partikel untuk alpha-blending tetap terbuka sejauh ini: karena semuanya dianggap analitis dalam shader, sebenarnya tidak ada data input untuk disortir.  Tetapi ada bidang besar untuk eksperimen! <br><br>  Selama pengembangan Titan World, banyak trik diterapkan di bagian grafis permainan, tetapi lebih banyak tentang itu di waktu berikutnya. <br><br>  NB Anda dapat menggali mesin sumber alpha di <a href="">sini</a> .  Contohnya ada di folder rilis / sampel, tombol kontrol utama adalah ruang, alt | control + mouse.  Shader terletak langsung di file fxp, kode mereka tersedia melalui jendela editor. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424995/">https://habr.com/ru/post/id424995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424985/index.html">Dalam preseden yudisial yang penting, badan intelijen AS tidak dapat menyadap panggilan di utusan</a></li>
<li><a href="../id424987/index.html">Pulihkan gambar yang buram dan tidak fokus menggunakan filter Wiener. Implementasi dalam C ++ OpenCV</a></li>
<li><a href="../id424989/index.html">Proses desain: 7 langkah menuju proyek yang sempurna</a></li>
<li><a href="../id424991/index.html">Ketika metode lama tidak berhasil: Vasily Mazin - pada pendekatan hybrid untuk pengembangan AI</a></li>
<li><a href="../id424993/index.html">Praktik Pemasaran Produk di Konferensi Pertumbuhan Epik</a></li>
<li><a href="../id424997/index.html">â€œAplikasi VKontakte iOS memiliki ambang masuk yang tinggiâ€: wawancara dengan Alexei Savin</a></li>
<li><a href="../id425001/index.html">Validasi parameter generik di pengontrol Spring</a></li>
<li><a href="../id425003/index.html">Bandingkan pembelian perangkat keras TCO dan penyewaan cloud</a></li>
<li><a href="../id425005/index.html">Rust News # 1 (September 2018)</a></li>
<li><a href="../id425007/index.html">Iridium dan Jeff Bezos AWS bekerja sama untuk mengembangkan proyek Internet satelit global untuk IoT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>