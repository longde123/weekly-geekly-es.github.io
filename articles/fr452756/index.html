<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëßüèΩ üçó üèûÔ∏è Cr√©ation de Tower Defense dans Unity: Enemies üê∞ üëèüèø üõåüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ Premi√®re partie: tuiles et trouver le chemin ] 



- Placement des points de cr√©ation ennemis. 
- L'apparition des ennemis et leur mouvement √† trave...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cr√©ation de Tower Defense dans Unity: Enemies</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452756/">  <i>[ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Premi√®re partie: tuiles et trouver le chemin</a> ]</i> <br><br><ul><li>  Placement des points de cr√©ation ennemis. </li><li>  L'apparition des ennemis et leur mouvement √† travers le champ. </li><li>  Cr√©er un mouvement fluide √† vitesse constante. </li><li>  Modifiez la taille, la vitesse et l'emplacement des ennemis. </li></ul><br>  Ceci est la deuxi√®me partie d'un tutoriel sur un jeu de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tower defense</a> simple.  Il examine le processus de cr√©ation d'ennemis et leur mouvement vers le point final le plus proche. <br><br>  Ce didacticiel est r√©alis√© dans Unity 2018.3.0f2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2db/cf3/311/2dbcf331117740aa403cb12a757ae6fd.jpg" width="512" height="256"></div><br>  <i>Ennemis sur le chemin du point final.</i> <br><a name="habracut"></a><br><h2>  Points de cr√©ation (apparition) ennemis </h2><br>  Avant de commencer √† cr√©er des ennemis, nous devons d√©cider o√π les placer sur le terrain.  Pour ce faire, nous allons cr√©er des points d'apparition. <br><br><h3>  Contenu des tuiles </h3><br>  Un point d'apparition est un autre type de contenu de tuile, alors ajoutez-y une entr√©e dans <code>GameTileContentType</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination, Wall, SpawnPoint }</code> </pre> <br>  Et puis cr√©ez un pr√©fabriqu√© pour le visualiser.  Un doublon du pr√©fabriqu√© du point de d√©part nous convient tout √† fait, il suffit de changer son type de contenu et de lui donner un autre mat√©riau.  Je l'ai fait orange. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e39/522/28d/e3952228dacd6801a6f5d2fb53826cc2.png" width="320" height="104"></div><br>  <i>Configuration du point d'apparition.</i> <br><br>  Ajoutez la prise en charge des points d'apparition √† la fabrique de contenu et donnez-lui un lien vers le pr√©fabriqu√©. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent spawnPointPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Destination: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(destinationPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Empty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(emptyPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Wall: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(wallPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.SpawnPoint: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(spawnPointPrefab); } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported type: "</span></span> + type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10f/036/a17/10f036a17ae271cf7b7f7c9694e01782.png" width="320" height="142"></div><br>  <i>Usine avec prise en charge des points d'apparition.</i> <br><br><h3>  Activer ou d√©sactiver les points d'apparition </h3><br>  La m√©thode pour changer l'√©tat du point d' <code>GameBoard</code> , comme les autres m√©thodes de commutation, nous ajouterons au <code>GameBoard</code> .  Mais les points d'apparition n'affectent pas la recherche du chemin, donc apr√®s le changement, nous n'avons pas besoin de chercher de nouveaux chemins. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleSpawnPoint</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.SpawnPoint) { tile.Content = contentFactory.Get(GameTileContentType.Empty); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.SpawnPoint); } }</code> </pre> <br>  Le jeu n'a de sens que si nous avons des ennemis et qu'ils ont besoin de points d'apparition.  Par cons√©quent, le champ de jeu doit contenir au moins un point d'apparition.  Nous aurons √©galement besoin d'acc√©der aux points d'apparition √† l'avenir, lorsque nous ajouterons des ennemis, alors utilisons la liste pour suivre toutes les tuiles avec ces points.  Nous mettrons √† jour la liste lors du changement d'√©tat du point d'apparition et emp√™cherons la suppression du dernier point d'apparition. <br><br><pre> <code class="cs hljs"> List&lt;GameTile&gt; spawnPoints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;GameTile&gt;(); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleSpawnPoint</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.SpawnPoint) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spawnPoints.Count &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { spawnPoints.Remove(tile); tile.Content = contentFactory.Get(GameTileContentType.Empty); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.SpawnPoint); spawnPoints.Add(tile); } }</code> </pre> <br>  La m√©thode <code>Initialize</code> doit maintenant d√©finir le point d'apparition pour cr√©er l'√©tat correct initial du champ.  Disons simplement inclure la premi√®re tuile, qui est dans le coin inf√©rieur gauche. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ ToggleDestination(tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>]); ToggleSpawnPoint(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br>  Nous allons faire le toucher alternatif maintenant changer l'√©tat des points d'apparition, mais lorsque vous maintenez la touche Maj gauche (la frappe est v√©rifi√©e par la m√©thode <code>Input.GetKey</code> ), l'√©tat du point final changera <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleAlternativeTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { board.ToggleDestination(tile); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { board.ToggleSpawnPoint(tile); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f9/cd6/22b/2f9cd622bf1aa41023e5204e1f4caa9a.png" width="230" height="230"></div><br>  <i>Champ avec des points d'apparition.</i> <br><br><h3>  Acc√©dez aux points d'apparition </h3><br>  Le terrain s'occupe de toutes ses tuiles, mais les ennemis ne sont pas de sa responsabilit√©.  Nous allons permettre d'acc√©der √† ses points d' <code>GetSpawnPoint</code> via la m√©thode <code>GetSpawnPoint</code> commune avec un param√®tre d'index. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSpawnPoint</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> spawnPoints[index]; }</code> </pre> <br>  Pour savoir quels indices sont corrects, des informations sont n√©cessaires sur le nombre de points d'apparition, nous allons donc le rendre g√©n√©ral en utilisant la propri√©t√© getter g√©n√©rale. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SpawnPointCount =&gt; spawnPoints.Count;</code> </pre> <br><h2>  Apparition de l'ennemi </h2><br>  L'apparition d'un ennemi est quelque peu similaire √† la cr√©ation du contenu d'une tuile.  Nous cr√©ons une instance pr√©fabriqu√©e via l'usine, que nous pla√ßons ensuite sur le terrain. <br><br><h3>  Usines </h3><br>  Nous allons cr√©er une usine pour les ennemis qui mettra tout ce qu'elle cr√©e sur sa propre sc√®ne.  Cette fonctionnalit√© est commune √† l'usine que nous avons d√©j√†, alors mettons le code pour elle dans la classe de base commune <code>GameObjectFactory</code> .  Nous <code>CreateGameObjectInstance</code> besoin que d'une <code>CreateGameObjectInstance</code> m√©thode <code>CreateGameObjectInstance</code> avec un param√®tre pr√©fabriqu√© commun, qui cr√©e et renvoie une instance, et g√®re √©galement la sc√®ne enti√®re.  Nous rendons la m√©thode <code>protected</code> , c'est-√†-dire qu'elle ne sera disponible que pour la classe et tous les types qui en h√©riteront.  C'est tout ce que fait la classe; elle n'est pas destin√©e √† √™tre utilis√©e comme une usine enti√®rement fonctionnelle.  Par cons√©quent, nous le marquons comme <code>abstract</code> , ce qui ne nous permettra pas de cr√©er des instances de ses objets. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.SceneManagement; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameObjectFactory</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { Scene scene; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> T CreateGameObjectInstance&lt;T&gt; (T prefab) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : MonoBehaviour { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!scene.isLoaded) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Application.isEditor) { scene = SceneManager.GetSceneByName(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!scene.isLoaded) { scene = SceneManager.CreateScene(name); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { scene = SceneManager.CreateScene(name); } } T instance = Instantiate(prefab); SceneManager.MoveGameObjectToScene(instance.gameObject, scene); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } }</code> </pre> <br>  Modifiez le <code>GameTileContentFactory</code> afin qu'il <code>GameTileContentFactory</code> ce type de fabrique et utilise <code>CreateGameObjectInstance</code> dans sa m√©thode <code>Get</code> , puis supprimez-en le code de contr√¥le de sc√®ne. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContentFactory</span></span> : <span class="hljs-title"><span class="hljs-title">GameObjectFactory</span></span> { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">//Scene contentScene; ‚Ä¶ GameTileContent Get (GameTileContent prefab) { GameTileContent instance = CreateGameObjectInstance(prefab); instance.OriginFactory = this; //MoveToFactoryScene(instance.gameObject); return instance; } //void MoveToFactoryScene (GameObject o) { // ‚Ä¶ //} }</span></span></code> </pre> <br>  Apr√®s cela, cr√©ez un nouveau type <code>EnemyFactory</code> qui cr√©e une instance d'un pr√©fabriqu√© <code>Enemy</code> √† l'aide de la m√©thode <code>Get</code> avec la m√©thode <code>Reclaim</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyFactory</span></span> : <span class="hljs-title"><span class="hljs-title">GameObjectFactory</span></span> { [SerializeField] Enemy prefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy instance = CreateGameObjectInstance(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reclaim</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Enemy enemy</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(enemy.OriginFactory == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"Wrong factory reclaimed!"</span></span>); Destroy(enemy.gameObject); } }</code> </pre> <br>  Au d√©part, le nouveau type <code>Enemy</code> n'avait qu'√† garder une trace de son usine d'origine. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Enemy</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { EnemyFactory originFactory; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EnemyFactory OriginFactory { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; originFactory; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Debug.Assert(originFactory == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined origin factory!"</span></span>); originFactory = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } }</code> </pre> <br><h3>  Pr√©fabriqu√© </h3><br>  Les ennemis ont besoin de visualisation, ce qui peut √™tre n'importe quoi - un robot, une araign√©e, un fant√¥me, quelque chose de plus simple, par exemple, un cube, que nous utilisons.  Mais en g√©n√©ral, l'ennemi a un mod√®le 3D de toute complexit√©.  Pour assurer son support pratique, nous utiliserons l'objet racine pour la hi√©rarchie pr√©fabriqu√©e ennemie, √† laquelle seul le composant <code>Enemy</code> est attach√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c6/348/428/7c6348428b50732e0a13efcdadfc9fff.png" width="320" height="160"></div><br>  <i>Racine pr√©fabriqu√©e</i> <br><br>  Cr√©ons cet objet le seul √©l√©ment enfant, qui sera la racine du mod√®le.  Il doit avoir des valeurs unitaires de transformation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce7/691/330/ce7691330dd6c6813d2a64398c582c2a.png" width="320" height="120"></div><br>  <i>La racine du mod√®le.</i> <br><br>  La t√¢che de cette racine de mod√®le est de positionner le mod√®le 3D par rapport au point d'origine local des coordonn√©es de l'ennemi, afin qu'il le consid√®re comme un point de r√©f√©rence sur lequel l'ennemi se tient ou se bloque.  Dans notre cas, le mod√®le sera un cube demi-taille standard, auquel je donnerai une couleur bleu fonc√©.  Nous en faisons un enfant de la racine du mod√®le et d√©finissons la position Y √† 0,25 pour qu'il se tienne au sol. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65b/7a3/808/65b7a3808f469e2723b344afccd94f8f.png" width="320" height="206"></div><br>  <i>Mod√®le de cube</i> <br><br>  Ainsi, le pr√©fabriqu√© ennemi se compose de trois objets imbriqu√©s: la racine pr√©fabriqu√©e, la racine du mod√®le et le cube.  Cela peut sembler √™tre un buste pour un simple cube, mais un tel syst√®me vous permet de d√©placer et d'animer n'importe quel ennemi sans vous soucier de ses fonctionnalit√©s. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/0c9/abb/62a0c9abb59605150235ba6cec73eeb2.png" width="225" height="74"></div><br>  <i>La hi√©rarchie pr√©fabriqu√©e de l'ennemi.</i> <br><br>  Cr√©ons une usine ennemie et affectons-lui un pr√©fabriqu√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae3/ee2/345/ae3ee23456931ac6f989a763deb8b7b1.png" width="320" height="88"></div><br>  <i>Usine d'actifs.</i> <br><br><h3>  Placer des ennemis sur le terrain </h3><br>  Pour mettre des ennemis sur le terrain, le <code>Game</code> doit recevoir un lien vers l'usine des ennemis.  √âtant donn√© que nous avons besoin de beaucoup d'ennemis, nous ajouterons une option de configuration pour ajuster la vitesse d'apparition, exprim√©e en nombre d'ennemis par seconde.  Une plage acceptable est de 0,1 √† 10 avec une valeur par d√©faut de 1. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] EnemyFactory enemyFactory = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [SerializeField, Range(<span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> spawnSpeed = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/201/56b/338/20156b3384b45ab95d7aef5ed5397480.png" width="320" height="144"></div><br>  <i>Jeu avec une usine ennemie et une vitesse de reproduction 4.</i> <br><br>  Nous suivrons la progression du frai dans <code>Update</code> , en l'augmentant de la vitesse multipli√©e par le temps delta.  Si la valeur prggress d√©passe 1, alors nous la d√©cr√©mentons et engendrons l'ennemi en utilisant la nouvelle m√©thode <code>SpawnEnemy</code> .  Nous continuons √† le faire jusqu'√† ce que la progression d√©passe 1 au cas o√π la vitesse est trop √©lev√©e et le temps de trame est tr√®s long afin que plusieurs ennemis ne soient pas cr√©√©s en m√™me temps. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> spawnProgress; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ spawnProgress += spawnSpeed * Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (spawnProgress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { spawnProgress -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; SpawnEnemy(); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">N'est-il pas n√©cessaire de mettre √† jour la progression dans FixedUpdate?</b> <div class="spoiler_text">  Oui, c'est possible, mais ces horaires pr√©cis ne sont pas n√©cessaires pour le jeu de tower defense.  Nous allons simplement mettre √† jour l'√©tat du jeu √† chaque image et le faire fonctionner suffisamment bien pour tout delta de temps. </div></div><br>  Laissez <code>SpawnEnemy</code> obtenir un point d' <code>SpawnEnemy</code> al√©atoire sur le terrain et cr√©ez un ennemi sur cette tuile.  Nous donnerons √† l' <code>Enemy</code> la m√©thode <code>SpawnOn</code> pour se <code>SpawnOn</code> correctement. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnEnemy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile spawnPoint = board.GetSpawnPoint(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, board.SpawnPointCount)); Enemy enemy = enemyFactory.Get(); enemy.SpawnOn(spawnPoint); }</code> </pre> <br>  Pour l'instant, tout ce que <code>SpawnOn</code> a √† faire est de d√©finir sa propre position √©gale au centre de la tuile.  Puisque le mod√®le pr√©fabriqu√© est correctement positionn√©, le cube ennemi sera au-dessus de cette tuile. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnOn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { transform.localPosition = tile.transform.localPosition; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b5/74a/ce9/8b574ace93bd2c7f7829d41f9208a138.png" width="230" height="230"></div><br>  <i>Les ennemis apparaissent aux points d'apparition.</i> <br><br><h2>  D√©placer les ennemis </h2><br>  Apr√®s que l'ennemi soit apparu, il doit commencer √† se d√©placer le long du chemin vers le point d'arriv√©e le plus proche.  Pour ce faire, vous devez animer les ennemis.  Nous commen√ßons par une simple glisse lisse d'une tuile √† l'autre, puis rendons leur mouvement plus difficile. <br><br><h3>  Collection d'ennemis </h3><br>  Pour mettre √† jour le statut des ennemis, nous utiliserons la m√™me approche que celle utilis√©e dans la s√©rie de didacticiels sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gestion d'objets</a> .  Nous ajoutons √† <code>Enemy</code> m√©thode g√©n√©rale de <code>GameUpdate</code> , qui retourne des informations sur s'il est vivant, ce qui √† ce stade sera toujours vrai.  Pour l'instant, faites-le simplement avancer en fonction du delta du temps. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localPosition += Vector3.forward * Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  De plus, nous devons maintenir une liste des ennemis vivants et les mettre √† jour tous, en les supprimant de la liste des ennemis morts.  Nous pouvons mettre tout ce code dans un <code>Game</code> , mais au lieu de cela, isolez-le et cr√©ez un type <code>EnemyCollection</code> .  Il s'agit d'une classe s√©rialisable qui n'h√©rite de rien.  Nous lui donnons une m√©thode g√©n√©rale pour ajouter un ennemi et une autre m√©thode pour mettre √† jour la collection enti√®re. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyCollection</span></span> { List&lt;Enemy&gt; enemies = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Enemy&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Enemy enemy</span></span></span><span class="hljs-function">)</span></span> { enemies.Add(enemy); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; enemies.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!enemies[i].GameUpdate()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = enemies.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; enemies[i] = enemies[lastIndex]; enemies.RemoveAt(lastIndex); i -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } }</code> </pre> <br>  Maintenant, le <code>Game</code> sera suffisant pour cr√©er une seule collection de ce type, dans chaque image, mettez-la √† jour et ajoutez-y des ennemis cr√©√©s.  Nous mettrons √† jour les ennemis imm√©diatement apr√®s l'apparition possible d'un nouvel ennemi afin que la mise √† jour ait lieu instantan√©ment. <br><br><pre> <code class="cs hljs"> EnemyCollection enemies = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnemyCollection(); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ enemies.GameUpdate(); } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnEnemy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ enemies.Add(enemy); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25f/eb8/dc6/25feb8dc6f0d3a5a66be43f311cd7818.png" width="230" height="230"></div><br>  <i>Les ennemis avancent.</i> <br><br><h3>  Mouvement le long du chemin </h3><br>  Les ennemis se d√©placent d√©j√†, mais jusqu'√† pr√©sent ne suivent pas le chemin.  Pour ce faire, ils doivent savoir o√π aller ensuite.  Par cons√©quent, donnons √† <code>GameTile</code> propri√©t√© getter commune pour obtenir la prochaine tuile sur le chemin. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTile NextTileOnPath =&gt; nextOnPath;</code> </pre> <br>  Connaissant la tuile dont vous voulez sortir et la tuile dans laquelle vous devez entrer, les ennemis peuvent d√©terminer les points de d√©part et d'arriv√©e pour d√©placer une tuile.  L'ennemi peut interpoler la position entre ces deux points, en suivant leur mouvement.  Une fois le d√©placement termin√©, ce processus est r√©p√©t√© pour la tuile suivante.  Mais les chemins peuvent changer √† tout moment.  Au lieu de d√©terminer o√π aller plus loin dans le processus de mouvement, nous continuons simplement √† nous d√©placer le long de l'itin√©raire pr√©vu et √† le v√©rifier, en atteignant la tuile suivante. <br><br>  Laissez l' <code>Enemy</code> suivre les deux tuiles afin qu'elles ne soient pas affect√©es par un changement de chemin.  Il suivra √©galement les positions afin que nous n'ayons pas √† les recevoir dans chaque image et suivra le processus de d√©placement. <br><br><pre> <code class="cs hljs"> GameTile tileFrom, tileTo; Vector3 positionFrom, positionTo; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> progress;</code> </pre> <br>  Initialisez ces champs dans <code>SpawnOn</code> .  Le premier point est la tuile √† partir de laquelle l'ennemi se d√©place, et le point final est la prochaine tuile sur le chemin.  Cela suppose que la tuile suivante existe, sauf si l'ennemi a √©t√© cr√©√© au point final, ce qui devrait √™tre impossible.  Ensuite, nous mettons en cache les positions des tuiles et r√©initialisons la progression.  Nous n'avons pas besoin de d√©finir la position de l'ennemi ici, car sa m√©thode <code>GameUpdate</code> appel√©e dans le m√™me cadre. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnOn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//transform.localPosition = tile.transform.localPosition; Debug.Assert(tile.NextTileOnPath != null, "Nowhere to go!", this); tileFrom = tile; tileTo = tile.NextTileOnPath; positionFrom = tileFrom.transform.localPosition; positionTo = tileTo.transform.localPosition; progress = 0f; }</span></span></code> </pre> <br>  L'incr√©ment de progression sera effectu√© dans <code>GameUpdate</code> .  Ajoutons un delta de temps constant pour que les ennemis se d√©placent √† une vitesse d'une tuile par seconde.  Une fois la progression termin√©e, nous d√©pla√ßons les donn√©es afin que <code>To</code> devienne la valeur <code>From</code> et que le nouveau <code>To</code> soit la tuile suivante sur le chemin.  Ensuite, nous d√©cr√©mentons la progression.  Lorsque les donn√©es deviennent pertinentes, nous interpolons la position de l'ennemi entre <code>From</code> et <code>To</code> .  Puisque l'interpolateur est une progression, sa valeur est n√©cessairement comprise entre 0 et 1, nous pouvons donc utiliser s <code>Vector3.LerpUnclamped</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { tileFrom = tileTo; tileTo = tileTo.NextTileOnPath; positionFrom = positionTo; positionTo = tileTo.transform.localPosition; progress -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } transform.localPosition = Vector3.LerpUnclamped(positionFrom, positionTo, progress); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Cela oblige les ennemis √† suivre le chemin, mais n'agit pas lorsqu'ils atteignent le point final.  Par cons√©quent, avant de modifier les positions <code>From</code> et <code>To</code> , vous devez comparer la tuile suivante du chemin avec <code>null</code> .  Si oui, alors nous avons atteint le point final et l'ennemi a termin√© le mouvement.  Nous ex√©cutons Reclaim pour cela et retournons <code>false</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { tileFrom = tileTo; tileTo = tileTo.NextTileOnPath; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileTo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { OriginFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } positionFrom = positionTo; positionTo = tileTo.transform.localPosition; progress -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; }</code> </pre> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Les ennemis suivent le chemin le plus court.</i> <br><br>  Les ennemis se d√©placent d√©sormais du centre d'une tuile √† une autre.  Il vaut la peine de consid√©rer qu'ils ne changent leur √©tat de mouvement qu'au centre des tuiles, ils ne peuvent donc pas r√©pondre imm√©diatement aux changements sur le terrain.  Cela signifie que parfois les ennemis se d√©placent √† travers les murs qui viennent d'√™tre d√©finis.  Une fois qu'ils ont commenc√© √† se d√©placer vers la cellule, rien ne les arr√™tera.  C'est pourquoi les murs ont √©galement besoin de vrais chemins. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Les ennemis r√©agissent aux changements de trajectoire.</i> <br><br><h3>  Mouvement bord √† bord </h3><br>  Le mouvement entre les centres des tuiles et un changement brusque de direction semble normal pour un jeu abstrait dans lequel les ennemis d√©placent des cubes, mais g√©n√©ralement le mouvement fluide est plus beau.  La premi√®re √©tape de sa mise en ≈ìuvre n'est pas de se d√©placer le long des centres, mais le long des bords des carreaux. <br><br>  Le point de bord entre les tuiles adjacentes peut √™tre trouv√© en faisant la moyenne de leurs positions.  Au lieu de le calculer √† chaque √©tape pour chaque ennemi, nous le calculerons uniquement lors du changement de chemin dans <code>GameTile.GrowPathTo</code> .  Rendez-le disponible √† l'aide de la propri√©t√© <code>ExitPoint</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 ExitPoint { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ neighbor.ExitPoint = (neighbor.transform.localPosition + transform.localPosition) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor.Content.Type != GameTileContentType.Wall ? neighbor : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Le seul cas particulier est la cellule finale, dont le point de sortie sera son centre. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BecomeDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; nextOnPath = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; ExitPoint = transform.localPosition; }</code> </pre> <br>  Changez l' <code>Enemy</code> pour qu'il utilise des points de sortie, pas des centres de tuiles. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { ‚Ä¶ positionTo = tileFrom.ExitPoint; progress -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } transform.localPosition = Vector3.Lerp(positionFrom, positionTo, progress); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnOn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ positionTo = tileFrom.ExitPoint; progress = <span class="hljs-number"><span class="hljs-number">0f</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Les ennemis se d√©placent entre les bords.</i> <br><br>  Un effet secondaire de ce changement est que lorsque les ennemis se retournent en raison d'un changement de trajectoire, ils restent immobiles pendant une seconde. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>En tournant, les ennemis s'arr√™tent.</i> <br><br><h3>  Orientation </h3><br>  Bien que les ennemis se d√©placent le long des chemins jusqu'√† ce qu'ils changent d'orientation.  Pour pouvoir regarder dans la direction du mouvement, ils doivent conna√Ætre la direction du chemin qu'ils suivent.  Nous le d√©terminerons √©galement lors de la recherche de voies, afin que cela ne soit pas fait par les ennemis. <br><br>  Nous avons quatre directions: nord, est, sud et ouest.  √ânum√©rons-les. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Direction { North, East, South, West }</code> </pre> <br>  Ensuite, nous donnons la propri√©t√© <code>GameTile</code> pour stocker la direction de son chemin. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Direction PathDirection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Ajoutez un param√®tre de direction √† <code>GrowTo</code> , qui d√©finit la propri√©t√©.  Puisque nous d√©veloppons un chemin de la fin au d√©but, la direction sera oppos√©e √† celle √† partir de laquelle nous d√©veloppons le chemin. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathNorth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(north, Direction.South); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathEast</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(east, Direction.West); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathSouth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(south, Direction.North); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathWest</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(west, Direction.East); <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor, Direction direction</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ neighbor.PathDirection = direction; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor.Content.Type != GameTileContentType.Wall ? neighbor : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Nous devons convertir les directions en virages exprim√©s en quaternions.  Ce serait pratique si nous pouvions simplement appeler <code>GetRotation</code> pour la direction, alors faisons-le en cr√©ant une m√©thode d'extension.  Ajoutez la m√©thode statique g√©n√©rale <code>DirectionExtensions</code> , donnez-lui un tableau pour mettre en cache les quaternions n√©cessaires, ainsi que la m√©thode <code>GetRotation</code> pour renvoyer la valeur de direction correspondante.  Dans ce cas, il est judicieux de placer la classe d'extension dans le m√™me fichier que le type d'√©num√©ration. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Direction { North, East, South, West } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DirectionExtensions</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Quaternion[] rotations = { Quaternion.identity, Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">180f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">270f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Quaternion </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Direction direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rotations[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce qu'une m√©thode d'extension?</b> <div class="spoiler_text">  Une m√©thode d'extension est une m√©thode statique √† l'int√©rieur d'une classe statique qui se comporte comme une m√©thode d'instance d'un certain type.  Ce type peut √™tre une classe, une interface, une structure, une valeur primitive ou une √©num√©ration.  Le premier argument de la m√©thode d'extension doit avoir le <code>this</code> .  Il d√©finit la valeur du type et de l'instance avec lesquels la m√©thode fonctionnera.  Cette approche signifie que l'expansion des propri√©t√©s n'est pas possible. <br><br>  Cela vous permet-il d'ajouter des m√©thodes √† quelque chose?  Oui, tout comme vous pouvez √©crire n'importe quelle m√©thode statique dont le param√®tre est de n'importe quel type. </div></div><br>  Maintenant, nous pouvons faire tourner l' <code>Enemy</code> lors de la ponte et chaque fois que nous entrons dans une nouvelle tuile.  Apr√®s la mise √† jour des donn√©es, la vignette <code>From</code> nous donne une direction. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { ‚Ä¶ transform.localRotation = tileFrom.PathDirection.GetRotation(); progress -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } transform.localPosition = Vector3.LerpUnclamped(positionFrom, positionTo, progress); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnOn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ transform.localRotation = tileFrom.PathDirection.GetRotation(); progress = <span class="hljs-number"><span class="hljs-number">0f</span></span>; }</code> </pre> <br><h3>  Changement de direction </h3><br>  Au lieu de changer instantan√©ment de direction, il est pr√©f√©rable d'interpoler les valeurs entre les virages, de la m√™me mani√®re que nous avons interpol√© entre les positions.  Pour passer d'une orientation √† une autre, il faut conna√Ætre le changement de direction qu'il faut faire: sans tourner, tourner √† droite, tourner √† gauche ou revenir en arri√®re.  Nous ajoutons pour cela une √©num√©ration, qui √† nouveau peut √™tre plac√©e dans le m√™me fichier que la <code>Direction</code> , car elles sont petites et √©troitement li√©es. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Direction { North, East, South, West } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> DirectionChange { None, TurnRight, TurnLeft, TurnAround }</code> </pre> <br>  Ajoutez une autre m√©thode d'extension, cette fois <code>GetDirectionChangeTo</code> , qui renvoie un changement de direction de la direction actuelle √† la suivante.  Si les directions co√Øncident, il n'y a pas de d√©calage.  Si le suivant est plus que le courant, alors c'est un virage √† droite.  Mais puisque les directions se r√©p√®tent, la m√™me situation se pr√©sentera lorsque la suivante sera de trois fois inf√©rieure √† l'actuelle.  Avec un virage √† gauche, ce sera la m√™me chose, seules l'addition et la soustraction changeront de place.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le seul cas restant est un retour en arri√®re. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> DirectionChange </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDirectionChangeTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Direction current, Direction next </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == next) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DirectionChange.None; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current + <span class="hljs-number"><span class="hljs-number">1</span></span> == next || current - <span class="hljs-number"><span class="hljs-number">3</span></span> == next) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DirectionChange.TurnRight; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current - <span class="hljs-number"><span class="hljs-number">1</span></span> == next || current + <span class="hljs-number"><span class="hljs-number">3</span></span> == next) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DirectionChange.TurnLeft; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DirectionChange.TurnAround; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous faisons une rotation dans une seule dimension, donc une interpolation lin√©aire des angles nous suffira. </font><font style="vertical-align: inherit;">Ajoutez une autre m√©thode d'expansion qui obtient l'angle de direction en degr√©s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAngle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Direction direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)direction * <span class="hljs-number"><span class="hljs-number">90f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous devez maintenant </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">suivre la direction, le changement de direction et les angles entre lesquels vous devez effectuer l'interpolation.</font></font><br><br><pre> <code class="cs hljs"> Direction direction; DirectionChange directionChange; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> directionAngleFrom, directionAngleTo;</code> </pre> <br> <code>SpawnOn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devient plus difficile, nous allons donc d√©placer le code de pr√©paration de l'√©tat vers une autre m√©thode. </font><font style="vertical-align: inherit;">Nous d√©signerons l'√©tat initial de l'ennemi comme un √©tat d'introduction, nous l'appellerons donc </font></font><code>PrepareIntro</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans cet √©tat, l'ennemi se d√©place du centre vers le bord de sa tuile initiale, il n'y a donc pas de changement de direction. </font><font style="vertical-align: inherit;">Les angles </font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les m√™mes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnOn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(tile.NextTileOnPath != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Nowhere to go!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); tileFrom = tile; tileTo = tile.NextTileOnPath; <span class="hljs-comment"><span class="hljs-comment">//positionFrom = tileFrom.transform.localPosition; //positionTo = tileFrom.ExitPoint; //transform.localRotation = tileFrom.PathDirection.GetRotation(); progress = 0f; PrepareIntro(); } void PrepareIntro () { positionFrom = tileFrom.transform.localPosition; positionTo = tileFrom.ExitPoint; direction = tileFrom.PathDirection; directionChange = DirectionChange.None; directionAngleFrom = directionAngleTo = direction.GetAngle(); transform.localRotation = direction.GetRotation(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä ce stade, nous cr√©ons quelque chose comme une petite machine d'√©tat. </font><font style="vertical-align: inherit;">Pour simplifier les choses </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, d√©placez le code d'√©tat vers une nouvelle m√©thode </font></font><code>PrepareNextState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous ne laisserons que les changements de tuiles </font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, parce que nous les utilisons ici pour v√©rifier si l'ennemi a termin√© le chemin.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">//positionFrom = positionTo; //positionTo = tileFrom.ExitPoint; //transform.localRotation = tileFrom.PathDirection.GetRotation(); progress -= 1f; PrepareNextState(); } ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la transition vers un nouvel √©tat, vous devez toujours changer de position, trouver un changement de direction, mettre √† jour la direction actuelle et d√©placer l'angle </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur </font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous ne d√©finissons plus de virage.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareNextState</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { positionFrom = positionTo; positionTo = tileFrom.ExitPoint; directionChange = direction.GetDirectionChangeTo(tileFrom.PathDirection); direction = tileFrom.PathDirection; directionAngleFrom = directionAngleTo; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'autres actions d√©pendent d'un changement de direction. </font><font style="vertical-align: inherit;">Ajoutons une m√©thode pour chaque option. </font><font style="vertical-align: inherit;">Dans le cas o√π nous avan√ßons, l'angle </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">co√Øncide avec la direction du chemin de la cellule actuelle. </font><font style="vertical-align: inherit;">De plus, nous devons r√©gler la rotation de sorte que l'ennemi regarde droit devant.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareForward</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localRotation = direction.GetRotation(); directionAngleTo = direction.GetAngle(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le cas d'un virage, nous ne tournons pas instantan√©ment. </font><font style="vertical-align: inherit;">Nous devons interpoler sous un angle diff√©rent: 90 ¬∞ de plus pour tourner √† droite, 90 ¬∞ de moins pour tourner √† gauche et 180 ¬∞ de plus pour revenir en arri√®re. </font><font style="vertical-align: inherit;">Pour √©viter de tourner dans la mauvaise direction en raison d'un changement des valeurs d'angle de 359 ¬∞ √† 0 ¬∞, l'angle </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit √™tre indiqu√© par rapport √† la direction actuelle. </font><font style="vertical-align: inherit;">Nous n'avons pas √† nous inqui√©ter que l'angle devienne inf√©rieur √† 0 ¬∞ ou sup√©rieur √† 360 ¬∞, car nous </font></font><code>Quaternion.Euler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pouvons le g√©rer.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">90f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom - <span class="hljs-number"><span class="hljs-number">90f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">180f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fin de compte, </font></font><code>PrepareNextState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous pouvons utiliser </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour changer de direction afin de d√©cider laquelle des quatre m√©thodes appeler.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareNextState</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (directionChange) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DirectionChange.None: PrepareForward(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DirectionChange.TurnRight: PrepareTurnRight(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DirectionChange.TurnLeft: PrepareTurnLeft(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: PrepareTurnAround(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, √† la fin, </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous devons v√©rifier si la direction a chang√©. </font><font style="vertical-align: inherit;">Si tel est le cas, interpolez entre les deux coins et d√©finissez la rotation.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ transform.localPosition = Vector3.LerpUnclamped(positionFrom, positionTo, progress); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (directionChange != DirectionChange.None) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Mathf.LerpUnclamped( directionAngleFrom, directionAngleTo, progress ); transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, angle, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les ennemis tournent.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mouvement de courbe </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons am√©liorer le mouvement en faisant bouger les ennemis le long d'une courbe en tournant. </font><font style="vertical-align: inherit;">Au lieu de marcher d'un bord √† l'autre des tuiles, laissez-les marcher d'un quart de cercle. </font><font style="vertical-align: inherit;">Le centre de ce cercle se trouve dans un coin commun aux tuiles </font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur le m√™me bord le long duquel l'ennemi est entr√© dans la tuile </font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d7/8a6/3a5/1d78a63a58d34a1d8cc9ff56a0b23cc3.png" width="256" height="256"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une rotation d'un quart de cercle pour tourner √† droite. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons le r√©aliser en d√©pla√ßant l'ennemi dans un arc en utilisant la trigonom√©trie, tout en le tournant. </font><font style="vertical-align: inherit;">Mais cela peut √™tre simplifi√© en utilisant uniquement la rotation, en d√©pla√ßant temporairement l'origine locale des coordonn√©es de l'ennemi au centre du cercle. </font><font style="vertical-align: inherit;">Pour ce faire, nous devons changer la position du mod√®le ennemi, nous allons donc donner un </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lien vers ce mod√®le, accessible via le champ de configuration.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform model = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72b/13c/28e/72b13c28ed9d6a8d34f3e17536e964cd.png" width="320" height="56"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ennemi en r√©f√©rence au mod√®le. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour se pr√©parer √† avancer ou √† reculer, le mod√®le doit se d√©placer vers la position standard, √† l'origine locale des coordonn√©es de l'ennemi. </font><font style="vertical-align: inherit;">Sinon, le mod√®le doit √™tre d√©cal√© de la moiti√© de l'unit√© de mesure - le rayon du cercle de rotation, loin du point de retournement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareForward</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localRotation = direction.GetRotation(); directionAngleTo = direction.GetAngle(); model.localPosition = Vector3.zero; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom - <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">180f</span></span>; model.localPosition = Vector3.zero; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, l'ennemi lui-m√™me doit √™tre d√©plac√© au tournant. </font><font style="vertical-align: inherit;">Pour ce faire, il doit √©galement √™tre d√©plac√© de la moiti√© de l'unit√© de mesure, mais le d√©calage exact d√©pend de la direction. </font><font style="vertical-align: inherit;">Ajoutons √† cela </font></font><code>Direction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une m√©thode d'extension auxiliaire </font></font><code>GetHalfVector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Vector3[] halfVectors = { Vector3.forward * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, Vector3.right * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, Vector3.back * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, Vector3.left * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> }; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHalfVector</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Direction direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> halfVectors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajoutez le vecteur correspondant en tournant √† droite ou √† gauche. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom + direction.GetHalfVector(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom - <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom + direction.GetHalfVector(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et lorsque vous reculez, la position doit √™tre le point de d√©part habituel. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">180f</span></span>; model.localPosition = Vector3.zero; transform.localPosition = positionFrom; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, lors du calcul du point de sortie, nous pouvons utiliser la </font></font><code>GameTile.GrowPathTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">moiti√© du vecteur afin de ne pas avoir besoin d'acc√©der aux deux positions des tuiles.</font></font><br><br><pre> <code class="cs hljs"> neighbor.ExitPoint = neighbor.transform.localPosition + direction.GetHalfVector();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, lors du changement de direction, nous n'avons pas √† interpoler la position </font></font><code>Enemy.GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car la rotation est engag√©e dans le mouvement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (directionChange == DirectionChange.None) { transform.localPosition = Vector3.LerpUnclamped(positionFrom, positionTo, progress); } <span class="hljs-comment"><span class="hljs-comment">//if (directionChange != DirectionChange.None) { else { float angle = Mathf.LerpUnclamped( directionAngleFrom, directionAngleTo, progress ); transform.localRotation = Quaternion.Euler(0f, angle, 0f); } return true; }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les ennemis se plient en douceur autour des coins.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vitesse constante </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† ce point, la vitesse des ennemis a toujours √©t√© √©gale √† une tuile par seconde, quelle que soit la fa√ßon dont ils se d√©placent √† l'int√©rieur de la tuile. </font><font style="vertical-align: inherit;">Mais la distance qu'ils parcourent d√©pend de leur condition, donc leur vitesse, exprim√©e en unit√©s par seconde, varie. </font><font style="vertical-align: inherit;">Pour que cette vitesse soit constante, nous devons changer la vitesse de progression en fonction de l'√©tat. </font><font style="vertical-align: inherit;">Par cons√©quent, ajoutez le champ du multiplicateur de progression et utilisez-le pour mettre le delta √† l'√©chelle </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> progress, progressFactor; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime * progressFactor; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais si la progression change en fonction de l'√©tat, la valeur de progression restante ne peut pas √™tre utilis√©e directement pour l'√©tat suivant. </font><font style="vertical-align: inherit;">Par cons√©quent, avant de pr√©parer un nouvel √©tat, nous devons normaliser les progr√®s et appliquer le nouveau multiplicateur d√©j√† dans un nouvel √©tat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime * progressFactor; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">//progress -= 1f; progress = (progress - 1f) / progressFactor; PrepareNextState(); progress *= progressFactor; } ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avancer ne n√©cessite pas de changements, par cons√©quent, il utilise un facteur de 1. En tournant √† droite ou √† gauche, l'ennemi passe un quart de cercle avec un rayon de ¬Ω, donc la distance parcourue est de ¬ºœÄ. </font></font><code>progress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©gal √† un divis√© par cette valeur. </font><font style="vertical-align: inherit;">Le retour en arri√®re ne devrait pas prendre trop de temps, alors doublez la progression pour que cela prenne une demi-seconde. </font><font style="vertical-align: inherit;">Enfin, le mouvement d'introduction ne couvre que la moiti√© de la tuile, par cons√©quent, pour maintenir une vitesse constante, sa progression doit √©galement √™tre doubl√©e.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareForward</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareIntro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi la distance est-elle √©gale √† 1/4 * pi?</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La circonf√©rence est 2œÄ fois le rayon. </font><font style="vertical-align: inherit;">Tourner vers la droite ou la gauche ne couvre qu'un quart de cette longueur, et le rayon est ¬Ω, donc la distance est ¬ΩœÄ √ó ¬Ω.</font></font></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âtat final </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque nous avons un √©tat d'introduction, ajoutons un dernier. </font><font style="vertical-align: inherit;">Les ennemis disparaissent actuellement imm√©diatement apr√®s avoir atteint le point d'extr√©mit√©, mais reportons leur disparition jusqu'√† ce qu'ils atteignent le centre de la tuile d'extr√©mit√©. </font><font style="vertical-align: inherit;">Cr√©ons une m√©thode pour cela </font></font><code>PrepareOutro</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, d√©finissons le mouvement vers l'avant, mais uniquement au centre de la tuile avec une progression doubl√©e pour maintenir une vitesse constante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareOutro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { positionTo = tileFrom.transform.localPosition; directionChange = DirectionChange.None; directionAngleTo = direction.GetAngle(); model.localPosition = Vector3.zero; transform.localRotation = direction.GetRotation(); progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afin de </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne pas d√©truire l'ennemi trop t√¥t, nous allons lui retirer le d√©calage de tuile. </font><font style="vertical-align: inherit;">Il va le faire maintenant </font></font><code>PrepareNextState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ainsi, v√©rifier les </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retours </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uniquement apr√®s la fin de l'√©tat final.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime * progressFactor; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//tileFrom = tileTo; //tileTo = tileTo.NextTileOnPath; if (tileTo == null) { OriginFactory.Reclaim(this); return false; } ‚Ä¶ } ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans </font></font><code>PrepareNextState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous commencerons par le d√©placement des tuiles. </font><font style="vertical-align: inherit;">Ensuite, apr√®s avoir d√©fini la position </font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais avant de d√©finir la position, </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous v√©rifierons si la tuile est √©gale √† la </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si c'est le cas, pr√©parez l'√©tat final et ignorez le reste de la m√©thode.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareNextState</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { tileFrom = tileTo; tileTo = tileTo.NextTileOnPath; positionFrom = positionTo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileTo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { PrepareOutro(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } positionTo = tileFrom.ExitPoint; ‚Ä¶ }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ennemis avec une vitesse constante et un √©tat final.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variabilit√© ennemie </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons un flux d'ennemis, et ils sont tous le m√™me cube, se d√©pla√ßant √† la m√™me vitesse. </font><font style="vertical-align: inherit;">Le r√©sultat ressemble plus √† un long serpent qu'√† des ennemis individuels. </font><font style="vertical-align: inherit;">Rendons-les plus diff√©rents en randomisant leur taille, leur d√©placement et leur vitesse.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plage de valeurs flottantes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons changer les param√®tres des ennemis, en choisissant al√©atoirement leurs caract√©ristiques dans la plage de valeurs. </font><font style="vertical-align: inherit;">La structure </font></font><code>FloatRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que nous avons cr√©√©e dans l'article </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gestion des objets, Configuration des formes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sera utile ici </font><font style="vertical-align: inherit;">, alors copions-la. </font><font style="vertical-align: inherit;">Les seuls changements consistaient √† ajouter un constructeur avec un param√®tre et √† ouvrir l'acc√®s au minimum et au maximum √† l'aide des propri√©t√©s en lecture seule, de sorte que l'intervalle √©tait immuable.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> FloatRange { [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> min, max; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Min =&gt; min; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Max =&gt; max; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> RandomValueInRange { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Random.Range(min, max); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FloatRange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { min = max = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FloatRange</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> min, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> max</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.min = min; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.max = max &lt; min ? min : max; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous copions √©galement l'attribut qui lui est attribu√© afin de limiter son intervalle. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FloatRangeSliderAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">PropertyAttribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Min { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Max { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FloatRangeSliderAttribute</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> min, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> max</span></span></span><span class="hljs-function">)</span></span> { Min = min; Max = max &lt; min ? min : max; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous n'avons besoin que de la visualisation du curseur, alors copiez-le </font></font><code>FloatRangeSliderDrawer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le dossier </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CustomPropertyDrawer(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(FloatRangeSliderAttribute))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FloatRangeSliderDrawer</span></span> : <span class="hljs-title"><span class="hljs-title">PropertyDrawer</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnGUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Rect position, SerializedProperty property, GUIContent label </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalIndentLevel = EditorGUI.indentLevel; EditorGUI.BeginProperty(position, label, property); position = EditorGUI.PrefixLabel( position, GUIUtility.GetControlID(FocusType.Passive), label ); EditorGUI.indentLevel = <span class="hljs-number"><span class="hljs-number">0</span></span>; SerializedProperty minProperty = property.FindPropertyRelative(<span class="hljs-string"><span class="hljs-string">"min"</span></span>); SerializedProperty maxProperty = property.FindPropertyRelative(<span class="hljs-string"><span class="hljs-string">"max"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> minValue = minProperty.floatValue; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> maxValue = maxProperty.floatValue; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fieldWidth = position.width / <span class="hljs-number"><span class="hljs-number">4f</span></span> - <span class="hljs-number"><span class="hljs-number">4f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sliderWidth = position.width / <span class="hljs-number"><span class="hljs-number">2f</span></span>; position.width = fieldWidth; minValue = EditorGUI.FloatField(position, minValue); position.x += fieldWidth + <span class="hljs-number"><span class="hljs-number">4f</span></span>; position.width = sliderWidth; FloatRangeSliderAttribute limit = attribute <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> FloatRangeSliderAttribute; EditorGUI.MinMaxSlider( position, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> minValue, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> maxValue, limit.Min, limit.Max ); position.x += sliderWidth + <span class="hljs-number"><span class="hljs-number">4f</span></span>; position.width = fieldWidth; maxValue = EditorGUI.FloatField(position, maxValue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minValue &lt; limit.Min) { minValue = limit.Min; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxValue &lt; minValue) { maxValue = minValue; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxValue &gt; limit.Max) { maxValue = limit.Max; } minProperty.floatValue = minValue; maxProperty.floatValue = maxValue; EditorGUI.EndProperty(); EditorGUI.indentLevel = originalIndentLevel; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âchelle du mod√®le </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous commencerons par changer l'√©chelle de l'ennemi. </font><font style="vertical-align: inherit;">Ajoutez </font></font><code>EnemyFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les param√®tres d'√©chelle </font><font style="vertical-align: inherit;">√† l' </font><font style="vertical-align: inherit;">option. </font><font style="vertical-align: inherit;">L'intervalle d'√©chelle ne doit pas √™tre trop grand, mais suffisant pour cr√©er des vari√©t√©s miniatures et gigantesques d'ennemis. </font><font style="vertical-align: inherit;">Tout ce qui se situe entre 0,5 et 2 avec une valeur standard de 1. Nous choisirons une √©chelle al√©atoire dans cet intervalle </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et la passerons √† l'ennemi par une nouvelle m√©thode </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, FloatRangeSlider(0.5f, 2f)</span></span>] FloatRange scale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy instance = CreateGameObjectInstance(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; instance.Initialize(scale.RandomValueInRange); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La m√©thode </font></font><code>Enemy.Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©finit simplement l'√©chelle de son mod√®le qui est la m√™me dans toutes les dimensions.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale</span></span></span><span class="hljs-function">)</span></span> { model.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(scale, scale, scale); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a7/cc3/f08/1a7cc3f082406d5c8672125ceb94913c.png" width="320" height="60" alt="inspecteur"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/396/7cf/ffe3967cfcfb6391269a5a7691317c60.png" width="230" height="230" alt="sc√®ne"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La gamme d'√©chelles est de 0,5 √† 1,5.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©calage du chemin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour d√©truire davantage l'uniformit√© du flux d'ennemis, nous pouvons changer leur position relative √† l'int√©rieur des tuiles. Ils avancent, donc le changement dans cette direction ne fait que modifier le moment de leur mouvement, ce qui n'est pas tr√®s visible. Par cons√©quent, nous allons les d√©placer sur le c√¥t√©, loin du chemin id√©al passant par les centres des carreaux. Ajoutez un </font></font><code>EnemyFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©calage de chemin </font><font style="vertical-align: inherit;">√† l' </font><font style="vertical-align: inherit;">intervalle et passez le d√©calage al√©atoire √† la m√©thode </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Le d√©calage peut √™tre n√©gatif ou positif, mais jamais sup√©rieur √† ¬Ω, car cela d√©placerait l'ennemi vers une tuile voisine. De plus, nous ne voulons pas que les ennemis d√©passent les tuiles qu'ils suivent, donc en fait l'intervalle sera moindre, par exemple 0,4, mais les vraies limites d√©pendent de la taille de l'ennemi.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, FloatRangeSlider(-0.4f, 0.4f)</span></span>] FloatRange pathOffset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy instance = CreateGameObjectInstance(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; instance.Initialize( scale.RandomValueInRange, pathOffset.RandomValueInRange ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque le d√©placement du chemin affecte le chemin parcouru, </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il est n√©cessaire de le suivre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pathOffset; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { model.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(scale, scale, scale); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pathOffset = pathOffset; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous vous d√©placez exactement droit (pendant le mouvement d'introduction, final ou normal vers l'avant), nous appliquons simplement le d√©calage directement au mod√®le. </font><font style="vertical-align: inherit;">La m√™me chose se produit lorsque vous revenez en arri√®re. </font><font style="vertical-align: inherit;">Avec un virage √† droite ou √† gauche, on d√©place d√©j√† le mod√®le, qui devient relatif au d√©placement du chemin.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareForward</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localRotation = direction.GetRotation(); directionAngleTo = direction.GetAngle(); model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset, <span class="hljs-number"><span class="hljs-number">0f</span></span>); progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom + direction.GetHalfVector(); progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom - <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset + <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom + direction.GetHalfVector(); progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">180f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom; progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareIntro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localRotation = direction.GetRotation(); progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareOutro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localRotation = direction.GetRotation(); progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque le d√©placement du chemin pendant la rotation change le rayon, nous devons changer le processus de calcul du multiplicateur de progression. </font><font style="vertical-align: inherit;">Le d√©calage de trajectoire doit √™tre soustrait de ¬Ω pour obtenir le rayon du virage √† droite, et ajout√© dans le cas d'un virage √† gauche.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> - pathOffset)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> + pathOffset)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous obtenons √©galement le rayon de braquage en tournant √† 180 ¬∞. Dans ce cas, nous couvrons la moiti√© du cercle avec un rayon √©gal au d√©calage du chemin, donc la distance est œÄ fois le d√©calage. Cependant, cela ne fonctionne pas lorsque le d√©placement est nul, et pour les petits d√©placements, les virages sont trop rapides. Pour √©viter les virages instantan√©s, nous pouvons forcer le rayon minimum √† calculer la vitesse, disons 0,2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + (pathOffset &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? <span class="hljs-number"><span class="hljs-number">180f</span></span> : <span class="hljs-number"><span class="hljs-number">-180f</span></span>); model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom; progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * Mathf.Max(Mathf.Abs(pathOffset), <span class="hljs-number"><span class="hljs-number">0.2f</span></span>)); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1db/8b2/b16/1db8b2b164cba05ff6f8fe7ffa0eed71.png" width="320" height="40" alt="inspecteur"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le d√©calage de chemin est compris entre ‚àí0,25 et 0,25. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que d√©sormais, les ennemis ne modifient jamais leur d√©placement relatif, m√™me en tournant. </font><font style="vertical-align: inherit;">Par cons√©quent, la longueur totale du chemin pour chaque ennemi a la sienne. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour emp√™cher les ennemis d'atteindre les tuiles voisines, il faut √©galement tenir compte de leur √©chelle maximale possible. </font><font style="vertical-align: inherit;">Je viens de limiter la taille √† une valeur maximale de 1, donc le d√©calage maximal autoris√© pour le cube est de 0,25. </font><font style="vertical-align: inherit;">Si la taille maximale √©tait de 1,5, le d√©placement maximal devrait √™tre r√©duit √† 0,125.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La vitesse </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La derni√®re chose que nous randomisons est la vitesse des ennemis. </font><font style="vertical-align: inherit;">Nous ajoutons un intervalle de plus pour cela </font></font><code>EnemyFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et nous transf√©rerons de la valeur √† la copie cr√©√©e de l'ennemi. </font><font style="vertical-align: inherit;">Faisons-en le deuxi√®me argument de la m√©thode </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Les ennemis ne doivent pas √™tre trop lents ou rapides pour que le jeu ne devienne pas trivialement simple ou impossible difficile. </font><font style="vertical-align: inherit;">Limitons l'intervalle √† 0,2‚Äì5. </font><font style="vertical-align: inherit;">La vitesse est exprim√©e en unit√©s par seconde, ce qui correspond aux tuiles par seconde uniquement lorsque vous avancez.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, FloatRangeSlider(0.2f, 5f)</span></span>] FloatRange speed = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">1f</span></span>); [SerializeField, FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">-0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>)] FloatRange pathOffset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy instance = CreateGameObjectInstance(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; instance.Initialize( scale.RandomValueInRange, speed.RandomValueInRange, pathOffset.RandomValueInRange ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, je </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dois suivre et acc√©l√©rer.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { model.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(scale, scale, scale); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.speed = speed; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pathOffset = pathOffset; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lorsque nous n'avons pas d√©fini la vitesse de mani√®re explicite, nous avons simplement toujours utilis√© la valeur 1. Il suffit maintenant de cr√©er la d√©pendance du multiplicateur de progression sur la vitesse. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareForward</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = speed; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = speed / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> - pathOffset)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = speed / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> + pathOffset)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = speed / (Mathf.PI * Mathf.Max(Mathf.Abs(pathOffset), <span class="hljs-number"><span class="hljs-number">0.2f</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareIntro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span> * speed; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareOutro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span> * speed; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b8/e55/eeb/0b8e55eeb25d36349f606f0da60d3720.png" width="320" height="60"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vitesse comprise entre 0,75 et 1,25. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donc, nous avons eu un beau flux d'ennemis se d√©pla√ßant vers le point final. </font><font style="vertical-align: inherit;">Dans le prochain tutoriel, nous apprendrons comment les g√©rer. </font><font style="vertical-align: inherit;">Vous voulez savoir quand il sortira? </font><font style="vertical-align: inherit;">Suivez ma page sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©f√©rentiel </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article PDF</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr452756/">https://habr.com/ru/post/fr452756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr452746/index.html">Le livre "L'art de la programmation dans R. Immerger dans le Big Data"</a></li>
<li><a href="../fr452748/index.html">Principes de d√©veloppement d'applications modernes √† partir de NGINX. Partie 1</a></li>
<li><a href="../fr452750/index.html">Nextcloud √† l'int√©rieur et √† l'ext√©rieur d'OpenLiteSpeed: configurer le proxy inverse</a></li>
<li><a href="../fr452752/index.html">BigData fait maison. Partie 1. Pratique Spark Streaming sur un cluster AWS</a></li>
<li><a href="../fr452754/index.html">19% des images Docker les plus populaires n'ont pas de mot de passe root</a></li>
<li><a href="../fr452760/index.html">Vitamine D. Boire ou ne pas boire, telle est la question. (Ou une histoire sur la fa√ßon dont j'ai r√©ussi une analyse qui ne m'a pas √©t√© prescrite)</a></li>
<li><a href="../fr452762/index.html">MVCC-7. Nettoyage auto</a></li>
<li><a href="../fr452764/index.html">[Peter] Rencontre JUG.ru avec Sergei Melnikov - Profilage √† la vitesse supraluminique: th√©orie et pratique</a></li>
<li><a href="../fr452766/index.html">La technologie de streaming progressif, ou comment regarder des vid√©os 4k sur le r√©seau, sans frises</a></li>
<li><a href="../fr452768/index.html">Comment concevoir un produit si vous d√©cidez d'entrer sur le march√© √©tranger</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>