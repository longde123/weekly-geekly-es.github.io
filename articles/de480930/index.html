<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêï üë®‚Äçüë®‚Äçüë¶ üôãüèª Gib alles ein üîå üë©‚Äçüîß üëåüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 


 Wir haben bereits einen Artikel √ºber die Entwicklung des Schreibens in Ostrovok.ru . Es erkl√§rt, warum wir von pyContracts zu ty...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gib alles ein</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ostrovok/blog/480930/"><p>  Hallo allerseits! </p><br><p>  Wir haben bereits <a href="https://habr.com/ru/company/ostrovok/blog/443470/">einen Artikel</a> √ºber die Entwicklung des Schreibens in <a href="https://www.habr.com/%3Futm_source%3Dhabr%26utm_medium%3Dpr%26utm_campaign%3Dbogdanova_dec19%26utm_content%3Darticle">Ostrovok.ru</a> .  Es erkl√§rt, warum wir von pyContracts zu typeguard wechseln, warum wir zu typeguard wechseln und womit wir enden.  Und heute werde ich Ihnen mehr dar√ºber erz√§hlen, wie dieser √úbergang stattfindet. </p><br><img src="https://habrastorage.org/webt/xk/gm/wn/xkgmwnrl0mygmpduhrg879p-nhe.jpeg"><a name="habracut"></a><br><p>  Eine Funktionsdeklaration mit pyContracts sieht im Allgemeinen so aus: </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> contracts <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> new_contract <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime @new_contract <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isinstance(x, User) @new_contract <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dt_datetime</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isinstance(x, datetime.datetime) @contract <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user_list, amount, dt=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" :type user_list: list(User) :type amount: int|float :type dt: dt_datetime|None :rtype: bool """</span></span> ‚Ä¶</code> </pre> <br><p>  Dies ist ein abstraktes Beispiel, da ich in unserem Projekt keine Definition einer Funktion gefunden habe, die in Bezug auf die Anzahl der F√§lle f√ºr die Typpr√ºfung kurz und aussagekr√§ftig ist.  In der Regel werden Definitionen f√ºr pyContracts in Dateien gespeichert, die keine andere Logik enthalten.  Beachten Sie, dass hier Benutzer eine bestimmte Benutzerklasse ist und nicht direkt importiert wird. </p><br><p>  Und das ist das gew√ºnschte Ergebnis mit typeguard: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typechecked <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> typechecked <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> List, Optional, Union <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime @typechecked <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user_list: List[User], amount: Union[int, float], dt: Optional[datetime.datetime]=None)</span></span></span><span class="hljs-function"> -&gt; bool:</span></span> ...</code> </pre> <br><p>  Im Allgemeinen gibt es im Projekt so viele Funktionen und Methoden mit Typpr√ºfung, dass Sie den Mond erreichen k√∂nnen, wenn Sie sie in einem Stapel stapeln.  Eine manuelle √úbersetzung von pyContracts in typeguard ist also nicht m√∂glich (ich habe es versucht!).  Also habe ich beschlossen, ein Drehbuch zu schreiben. </p><br><p>  Das Skript ist in zwei Teile unterteilt: Der eine Teil speichert die Importe neuer Vertr√§ge und der zweite Teil befasst sich mit dem Code-Refactoring. </p><br><p>  Ich m√∂chte darauf hinweisen, dass weder das eine noch das andere Skript den Anspruch erhebt, universell zu sein.  Wir wollten kein Tool schreiben, um alle erforderlichen F√§lle zu l√∂sen.  Daher habe ich h√§ufig auf die automatische Bearbeitung einiger Sonderf√§lle verzichtet. Wenn sie im Projekt selten vorkommen, ist es schneller, sie von Hand zu beheben.  Beispielsweise hat das Skript zum Generieren von Mapping-Vertr√§gen und Importen 90% der Werte gesammelt, die restlichen 10% sind handgefertigte Mappings. </p><br><p>  Die Logik des Skripts zum Generieren des Mappings: </p><br><p>  Schritt 1. Durchsuchen Sie alle Dateien des Projekts und lesen Sie sie.  F√ºr jede Datei: </p><br><ul><li>  Wenn die Unterzeichenfolge "@new_contract" nicht vorhanden ist, √ºberspringen Sie diese Datei. </li><li>  Wenn dies der Fall ist, teilen Sie die Datei durch die Zeile "@new_contract".  F√ºr jeden Artikel: <br>  - Analyse f√ºr Definition und Import, <br>  - bei Erfolg in die Erfolgsdatei schreiben, <br>  - Wenn nicht, schreiben Sie in die Fehlerdatei. </li></ul><br><p>  Schritt 2. Fehler manuell verarbeiten </p><br><p>  Nachdem wir nun die Namen aller von pyContracts verwendeten Typen (die mit dem Dekorator new_contract definiert wurden) und alle erforderlichen Importe haben, k√∂nnen wir Code f√ºr das Refactoring schreiben.  W√§hrend ich manuell von pyContracts nach typeguard √ºbersetzte, wurde mir klar, was ich aus dem Skript brauchte: </p><br><ol><li>  Dies ist ein Befehl, der einen Modulnamen als Argument verwendet (es k√∂nnen mehrere verwendet werden), in dem die Syntax der Funktionsanmerkungen ersetzt werden muss. </li><li>  Sehen Sie sich alle Moduldateien an und lesen Sie sie.  F√ºr jede Datei: <br><ul><li>  Wenn keine Unterzeichenfolge "@contract" vorhanden ist, √ºberspringen Sie diese Datei. </li><li>  wenn ja, verwandle den Code in ast (abstrakter Syntaxbaum); </li><li>  finden Sie alle Funktionen, die unter dem Vertrag Dekorator f√ºr jeden sind: <br><ul><li>  Dockstring abrufen, analysieren, dann l√∂schen, </li><li>  Erstellen Sie ein W√∂rterbuch der Form {arg_name: arg_type}. Verwenden Sie es, um die Funktionsanmerkung zu ersetzen. </li><li>  Erinnern Sie sich an neue Importe, </li></ul></li><li>  schreibe den modifizierten Baum durch astunparse in eine Datei; </li><li>  F√ºgen Sie neue Importe am Anfang der Datei hinzu. </li><li>  Ersetzen Sie die Zeilen "@contract" durch "@typechecked", da dies einfacher ist als durch ast. </li></ul></li></ol><br><p>  L√∂sen Sie die Frage "Ist dieser Name bereits in diese Datei importiert?"  Das hatte ich von Anfang an nicht vor: Mit diesem Problem werden wir einen zus√§tzlichen Durchlauf der Isort-Bibliothek bew√§ltigen. </p><br><p>  Nachdem die erste Version des Skripts ausgef√ºhrt wurde, stellten sich jedoch Fragen, die noch gel√∂st werden mussten.  Es stellte sich heraus, dass 1) ast nicht allm√§chtig ist, 2) astunparse allm√§chtiger ist, als wir m√∂chten.  Dies zeigte sich im Folgenden: </p><br><ul><li>  Beim √úbergang zum Syntaxbaum verschwinden alle einzeiligen Kommentare aus dem Code. </li><li>  leere Zeilen verschwinden ebenfalls; </li><li>  ast unterscheidet nicht zwischen Funktionen und Methoden der Klasse, wir mussten Logik hinzuf√ºgen; </li><li>  Umgekehrt werden beim Wechsel von einem Baum zu einem Code mehrzeilige Kommentare in dreifachen Anf√ºhrungszeichen in einfache Anf√ºhrungszeichen geschrieben und belegen eine Zeile. Neue Zeilenumbr√ºche werden durch \ n ersetzt. </li><li>  Es erscheinen unn√∂tige Klammern, wenn beispielsweise A und B und C oder D zu if ((A und B und C) oder D) werden. </li></ul><br><p>  Der Code, der durch ast und astunparse geleitet wird, funktioniert weiterhin, die Lesbarkeit ist jedoch eingeschr√§nkt. </p><br><p>  Der schwerwiegendste Nachteil ist das Verschwinden von einzeiligen Kommentaren (in anderen F√§llen verlieren wir nichts, sondern nur Gewinn - zum Beispiel Klammern).  Die Horast-Bibliothek, die auf ast, astunparse und tokenize basiert, verspricht, dies herauszufinden.  Verspricht und tut. </p><br><p>  Nun die leeren Zeilen.  Es gab zwei m√∂gliche L√∂sungen: </p><br><ol><li>  tokenize wei√ü, wie man den "Sprachteil" einer Python bestimmt, und horast nutzt ihn aus, wenn er Kommentartoken erh√§lt.  Aber tokenize hat auch Token wie NewLine und NL.  Sie m√ºssen also sehen, wie Horast Kommentare wiederherstellt und kopiert, wobei der Tokentyp ersetzt wird. <br>  <em>- schlug Anya vor, Erfahrung in der Entwicklung von 2 Monaten</em> </li><li>  Da Horast Kommentare wiederherstellen kann, ersetzen wir zuerst alle leeren Zeilen durch einen bestimmten Kommentar, √ºberspringen dann Horast und ersetzen unseren Kommentar durch eine leere Zeile. <br>  <em>- kam mit Eugene, Erfahrung in der Entwicklung von 8 Jahren</em> </li></ol><br><p>  In den Kommentaren werde ich auf die dreifachen Anf√ºhrungszeichen eingehen. Es war recht einfach, zus√§tzliche Klammern einzuf√ºgen, zumal einige von ihnen durch automatische Formatierung entfernt werden. </p><br><p>  In horast verwenden wir zwei Funktionen: parse und unparse, aber beide sind nicht ideal - parse enth√§lt seltsame interne Fehler, in seltenen F√§llen kann es den Quellcode nicht analysieren und unparse kann nichts schreiben, das type hat (so einen Typ, der Es stellt sich heraus, ob Sie tippen (any_other_type)). </p><br><p>  Ich habe mich gegen das Parsen entschieden, weil die Logik der Arbeit ziemlich verwirrend ist und Ausnahmen selten sind - das Prinzip der Nichtuniversalit√§t funktioniert hier. </p><br><p>  Aber unparese wirkt sehr √ºbersichtlich und recht elegant.  Die Funktion unparse erstellt eine Instanz der Unparser-Klasse, die in <strong>init</strong> den Baum verarbeitet und dann in eine Datei schreibt.  Horast.Unparser wird sukzessive von vielen anderen Unparsern geerbt, wobei die Basisklasse astunparse.Unparser ist.  Alle abgeleiteten Klassen erweitern einfach die Funktionalit√§t der Basisklasse, aber die Logik der Arbeit bleibt gleich. Betrachten Sie also astunparse.Unparser.  Es gibt f√ºnf wichtige Methoden: </p><br><ol><li>  Schreiben - schreibt einfach etwas in eine Datei. </li><li>  fill - verwendet Write basierend auf der Anzahl der Einr√ºckungen (die Anzahl der Einr√ºckungen wird als Klassenfeld gespeichert). </li><li>  enter - erh√∂ht den Einzug. </li><li>  leave - verkleinert den Einzug. </li><li>  dispatch - bestimmt den Typ des Knotens des Baums (sagen wir T), ruft die entsprechende Methode mit dem Namen des Knotentyps auf, jedoch mit einem Unterstrich (d. h. _T).  Dies ist eine Metamethode. </li></ol><br><p>  Alle anderen Methoden sind Methoden der Form _T, z. B. _Module oder _Str.  In jeder dieser Methoden kann sie: 1) rekursiv f√ºr Teilbaumknoten versenden oder 2) den Inhalt des Knotens mit write schreiben oder Zeichen und Schl√ºsselw√∂rter hinzuf√ºgen, sodass das Ergebnis ein g√ºltiger Ausdruck in Python ist. </p><br><p>  Wir sind zum Beispiel auf einen Knoten vom Typ arg gesto√üen, in dem ast den Argumentnamen und den Annotationsknoten speichert.  Dann ruft dispatch die _arg-Methode auf, die zuerst den Namen des Arguments schreibt, dann den Doppelpunkt schreibt und dispatch f√ºr den Annotationsknoten ausf√ºhrt, wobei der Annotationsteilbaum analysiert wird und dispatch und write weiterhin f√ºr diesen Teilbaum aufgerufen werden. </p><br><p>  Kehren wir zu unserem Problem der Unm√∂glichkeit der Art der Verarbeitung zur√ºck.  Nachdem Sie nun verstanden haben, wie unspezifisch funktioniert, ist das Erstellen Ihres Typs ganz einfach.  Lassen Sie uns einen Typ erstellen: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewType</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, t)</span></span></span><span class="hljs-function">:</span></span> self.s = ts</code> </pre> <br><p>  Es speichert einen String in sich und nicht nur so: Wir m√ºssen Funktionsargumente typisieren und wir erhalten die Argumenttypen in Form von Strings aus dem Andocken.  Ersetzen Sie Argumentanmerkungen daher nicht durch die von uns ben√∂tigten Typen, sondern durch ein NewType-Objekt, in dem nur der Name des gew√ºnschten Typs gespeichert ist. </p><br><p>  Dazu erweitern Sie horast.Unparser - schreiben Sie Ihr UnparserWithType, das von horast.Unparser erbt, und f√ºgen Sie die Verarbeitung unseres neuen Typs hinzu. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnparserWithType</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(horast.Unparser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_NewType</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, t)</span></span></span><span class="hljs-function">:</span></span> self.write(ts)</code> </pre> <br><p>  Dies verbindet sich mit dem Geist der Bibliothek.  Die Namen der Variablen sind im Stil von ast erstellt, und deshalb bestehen sie aus einem Buchstaben, und nicht, weil ich mir keine Namen vorstellen kann.  Ich denke, dass t f√ºr tree und s f√ºr string steht.  NewType ist √ºbrigens keine Zeichenfolge.  Wenn wir wollten, dass es als Zeichenfolgentyp interpretiert wird, m√ºssten wir vor und nach dem Schreibaufruf Anf√ºhrungszeichen schreiben. </p><br><p>  Und jetzt <del>  die Magie </del>  affen patch: ersetze horast.Unparser durch unseren UnparserWithType. </p><br><p>  So funktioniert es jetzt: Wir haben einen Syntaxbaum, er hat eine Funktion, Funktionen haben Argumente, Argumente haben Typanmerkungen, eine Nadel ist in der Typanmerkung versteckt und Koshcheevs Tod ist darin versteckt.  Bisher gab es √ºberhaupt keine Anmerkungsknoten, wir haben sie erstellt, und jeder dieser Knoten ist eine Instanz von NewType.  Wir nennen die Funktion unparse f√ºr unseren Baum und f√ºr jeden Knoten, den er dispatch nennt, die diesen Knoten klassifiziert und seine entsprechende Funktion aufruft.  Sobald die dispatch-Funktion den Node des Arguments empf√§ngt, schreibt sie den Namen des Arguments und pr√ºft, ob eine Annotation vorhanden ist (fr√ºher war es None, aber wir setzen NewType dort ein). Wenn dies der Fall ist, schreibt sie einen Doppelpunkt und ruft dispatch f√ºr die Annotation auf, die unser _NewType aufruft, welches Schreibt einfach die Zeichenfolge, die darin gespeichert ist - dies ist der Typname.  Als Ergebnis erhalten wir das schriftliche Argument: type. </p><br><p>  Eigentlich ist das nicht ganz legal.  Aus der Sicht des Compilers haben wir die Annotationen der Argumente mit einigen W√∂rtern niedergeschrieben, die nirgendwo definiert sind. Wenn unsparse seine Arbeit beendet, erhalten wir den falschen Code: Wir brauchen Importe.  Ich bilde einfach eine Zeile des richtigen Formats und f√ºge sie am Anfang der Datei ein. Anschlie√üend h√§nge ich das Ergebnis an "unparse" an, obwohl ich dem Syntaxbaum Importe als Knoten hinzuf√ºgen k√∂nnte, da ast Import- und ImportFrom-Knoten unterst√ºtzt. </p><br><p>  Das Problem der dreifachen Anf√ºhrungszeichen zu l√∂sen ist nicht schwieriger als das Hinzuf√ºgen eines neuen Typs.  Wir werden die StrType-Klasse und die _StrType-Methode erstellen.  Die Methode unterscheidet sich nicht von der _NewType-Methode, die zum Kommentieren von Typen verwendet wird, aber die Definition der Klasse hat sich ge√§ndert: Wir speichern nicht nur die Zeichenfolge selbst, sondern auch die Registerebene, auf der sie geschrieben werden soll.  Die Anzahl der Einr√ºckungen ist wie folgt definiert: Wenn diese Zeile in einer Funktion vorkommt, dann eine, wenn in einer Methode, dann zwei, und es gibt keine F√§lle, in denen die Funktion im Hauptteil einer anderen Funktion definiert ist und gleichzeitig in unserem Projekt dekoriert wird. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrType</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, s, indent)</span></span></span><span class="hljs-function">:</span></span> self.s = s self.indent = indent <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'"""\n'</span></span> + self.s + <span class="hljs-string"><span class="hljs-string">'\n'</span></span> + <span class="hljs-string"><span class="hljs-string">' '</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span> * self.indent + <span class="hljs-string"><span class="hljs-string">'"""\n'</span></span></code> </pre> <br><p>  In <strong>repr</strong> definieren wir, wie unsere Linie aussehen soll.  Ich denke, das ist bei weitem nicht die einzige L√∂sung, aber es funktioniert.  Man k√∂nnte mit astunparse.fill und astunparse.Unparser.indent experimentieren, dann w√§re es universeller, aber diese Idee kam mir schon beim Schreiben dieses Artikels in den Sinn. </p><br><p>  Damit enden gel√∂ste Schwierigkeiten.  Nach dem Ausf√ºhren meines Skripts tritt manchmal das Problem des zyklischen Imports auf, dies ist jedoch eine Frage der Architektur.  Ich habe keine fertige L√∂sung von Drittanbietern gefunden, und es scheint eine ernsthafte Komplikation der Aufgabe zu sein, solche F√§lle im Rahmen meines Skripts zu behandeln.  Mit Hilfe von ast ist es wahrscheinlich m√∂glich, zyklische Importe zu erkennen und aufzul√∂sen, aber diese Idee muss separat betrachtet werden.  Im Allgemeinen erlaubte mir die vernachl√§ssigbare Anzahl solcher Vorf√§lle in unserem Projekt, sie nicht automatisch zu verarbeiten. </p><br><p>  Eine andere Schwierigkeit, auf die ich gesto√üen bin, war der Mangel an Ausdrucksverarbeitung in Astroimport, da ein vorsichtiger Leser bereits wei√ü, dass das Affenpflaster das Heilmittel f√ºr alle Krankheiten ist.  Lassen Sie dies seine Hausaufgabe f√ºr ihn sein, aber ich habe mich dazu entschlossen: F√ºgen Sie einfach solche Importe zur Zuordnungsdatei hinzu, da diese Konstruktion normalerweise verwendet wird, um den Namenskonflikt zu umgehen, und wir haben nur wenige davon. </p><br><p>  Trotz der festgestellten Unvollkommenheiten macht das Skript das, was es beabsichtigt hatte.  Was ist das Ergebnis: </p><br><ol><li>  Die Zeit, f√ºr die das Projekt gestartet wird, wurde von 10 auf 3 Sekunden verringert. </li><li>  Die Anzahl der Dateien hat sich aufgrund des Entfernens der new_contract-Definitionen verringert.  Die Dateien selbst wurden verkleinert: Ich habe nicht gemessen, aber im Durchschnitt summierte sich das Git auf n hinzugef√ºgte und 2n gel√∂schte Zeilen. </li><li>  Smart IDEs begannen, andere Hinweise zu geben, denn jetzt sind es keine Kommentare, sondern ehrliche Importe; </li><li>  Die Lesbarkeit wurde verbessert. </li><li>  Irgendwo tauchten Klammern auf. </li></ol><br><p>  Vielen Dank! </p><br><p>  N√ºtzliche Links: </p><br><ol><li>  <a href="https://docs.python.org/3/library/ast.html">Ast</a> </li><li>  <a href="https://pypi.org/project/horast/">Horast</a> </li><li>  <a href="https://greentreesnakes.readthedocs.io/en/latest/nodes.html">Alle Arten von Astknoten und was in ihnen gespeichert ist</a> </li><li>  <a href="https://python-ast-explorer.com/">Zeigt sch√∂n den Syntaxbaum</a> </li><li>  <a href="https://pypi.org/project/isort/">Isort</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480930/">https://habr.com/ru/post/de480930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480920/index.html">Test von TP-Link Switches mit Long Range PoE. Und ein bisschen √ºber Upgrades alter Modelle</a></li>
<li><a href="../de480922/index.html">Evgeny Usvitsky: ‚ÄûJeder auf der Welt wei√ü, wo er Geodaten frei bekommen kann - nur in OSM‚Äú</a></li>
<li><a href="../de480924/index.html">Wie und warum haben die Macher des Remakes von MediEvil den Kult-Boss des Spiels neu gestaltet</a></li>
<li><a href="../de480926/index.html">Wahrscheinlichkeitstheorie f√ºr physikalisch genaues Rendern</a></li>
<li><a href="../de480928/index.html">Apache Hadoop Code Qualit√§t: Produktion VS Test</a></li>
<li><a href="../de480936/index.html">Schnelle Konvertierung von UPPER_CASE nach camelCase</a></li>
<li><a href="../de480938/index.html">Kryptow√§hrung aus Sicht russischer Richter</a></li>
<li><a href="../de480940/index.html">F√ºhren Sie einen browser√ºbergreifenden UI-Test mit Cucumber und Selenoid in Gitlab CI mit Allure-Bericht aus</a></li>
<li><a href="../de480944/index.html">Top 5 Trends im E-Mail-Marketing im Jahr 2020</a></li>
<li><a href="../de480946/index.html">Protokolle in Kubernetes (und nicht nur) heute: Erwartungen und Realit√§t</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>