<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐕 👨‍👨‍👦 🙋🏻 Gib alles ein 🔌 👩‍🔧 👌🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 


 Wir haben bereits einen Artikel über die Entwicklung des Schreibens in Ostrovok.ru . Es erklärt, warum wir von pyContracts zu ty...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gib alles ein</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ostrovok/blog/480930/"><p>  Hallo allerseits! </p><br><p>  Wir haben bereits <a href="https://habr.com/ru/company/ostrovok/blog/443470/">einen Artikel</a> über die Entwicklung des Schreibens in <a href="https://www.habr.com/%3Futm_source%3Dhabr%26utm_medium%3Dpr%26utm_campaign%3Dbogdanova_dec19%26utm_content%3Darticle">Ostrovok.ru</a> .  Es erklärt, warum wir von pyContracts zu typeguard wechseln, warum wir zu typeguard wechseln und womit wir enden.  Und heute werde ich Ihnen mehr darüber erzählen, wie dieser Übergang stattfindet. </p><br><img src="https://habrastorage.org/webt/xk/gm/wn/xkgmwnrl0mygmpduhrg879p-nhe.jpeg"><a name="habracut"></a><br><p>  Eine Funktionsdeklaration mit pyContracts sieht im Allgemeinen so aus: </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> contracts <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> new_contract <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime @new_contract <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isinstance(x, User) @new_contract <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dt_datetime</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isinstance(x, datetime.datetime) @contract <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user_list, amount, dt=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" :type user_list: list(User) :type amount: int|float :type dt: dt_datetime|None :rtype: bool """</span></span> …</code> </pre> <br><p>  Dies ist ein abstraktes Beispiel, da ich in unserem Projekt keine Definition einer Funktion gefunden habe, die in Bezug auf die Anzahl der Fälle für die Typprüfung kurz und aussagekräftig ist.  In der Regel werden Definitionen für pyContracts in Dateien gespeichert, die keine andere Logik enthalten.  Beachten Sie, dass hier Benutzer eine bestimmte Benutzerklasse ist und nicht direkt importiert wird. </p><br><p>  Und das ist das gewünschte Ergebnis mit typeguard: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typechecked <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> typechecked <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> List, Optional, Union <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime @typechecked <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user_list: List[User], amount: Union[int, float], dt: Optional[datetime.datetime]=None)</span></span></span><span class="hljs-function"> -&gt; bool:</span></span> ...</code> </pre> <br><p>  Im Allgemeinen gibt es im Projekt so viele Funktionen und Methoden mit Typprüfung, dass Sie den Mond erreichen können, wenn Sie sie in einem Stapel stapeln.  Eine manuelle Übersetzung von pyContracts in typeguard ist also nicht möglich (ich habe es versucht!).  Also habe ich beschlossen, ein Drehbuch zu schreiben. </p><br><p>  Das Skript ist in zwei Teile unterteilt: Der eine Teil speichert die Importe neuer Verträge und der zweite Teil befasst sich mit dem Code-Refactoring. </p><br><p>  Ich möchte darauf hinweisen, dass weder das eine noch das andere Skript den Anspruch erhebt, universell zu sein.  Wir wollten kein Tool schreiben, um alle erforderlichen Fälle zu lösen.  Daher habe ich häufig auf die automatische Bearbeitung einiger Sonderfälle verzichtet. Wenn sie im Projekt selten vorkommen, ist es schneller, sie von Hand zu beheben.  Beispielsweise hat das Skript zum Generieren von Mapping-Verträgen und Importen 90% der Werte gesammelt, die restlichen 10% sind handgefertigte Mappings. </p><br><p>  Die Logik des Skripts zum Generieren des Mappings: </p><br><p>  Schritt 1. Durchsuchen Sie alle Dateien des Projekts und lesen Sie sie.  Für jede Datei: </p><br><ul><li>  Wenn die Unterzeichenfolge "@new_contract" nicht vorhanden ist, überspringen Sie diese Datei. </li><li>  Wenn dies der Fall ist, teilen Sie die Datei durch die Zeile "@new_contract".  Für jeden Artikel: <br>  - Analyse für Definition und Import, <br>  - bei Erfolg in die Erfolgsdatei schreiben, <br>  - Wenn nicht, schreiben Sie in die Fehlerdatei. </li></ul><br><p>  Schritt 2. Fehler manuell verarbeiten </p><br><p>  Nachdem wir nun die Namen aller von pyContracts verwendeten Typen (die mit dem Dekorator new_contract definiert wurden) und alle erforderlichen Importe haben, können wir Code für das Refactoring schreiben.  Während ich manuell von pyContracts nach typeguard übersetzte, wurde mir klar, was ich aus dem Skript brauchte: </p><br><ol><li>  Dies ist ein Befehl, der einen Modulnamen als Argument verwendet (es können mehrere verwendet werden), in dem die Syntax der Funktionsanmerkungen ersetzt werden muss. </li><li>  Sehen Sie sich alle Moduldateien an und lesen Sie sie.  Für jede Datei: <br><ul><li>  Wenn keine Unterzeichenfolge "@contract" vorhanden ist, überspringen Sie diese Datei. </li><li>  wenn ja, verwandle den Code in ast (abstrakter Syntaxbaum); </li><li>  finden Sie alle Funktionen, die unter dem Vertrag Dekorator für jeden sind: <br><ul><li>  Dockstring abrufen, analysieren, dann löschen, </li><li>  Erstellen Sie ein Wörterbuch der Form {arg_name: arg_type}. Verwenden Sie es, um die Funktionsanmerkung zu ersetzen. </li><li>  Erinnern Sie sich an neue Importe, </li></ul></li><li>  schreibe den modifizierten Baum durch astunparse in eine Datei; </li><li>  Fügen Sie neue Importe am Anfang der Datei hinzu. </li><li>  Ersetzen Sie die Zeilen "@contract" durch "@typechecked", da dies einfacher ist als durch ast. </li></ul></li></ol><br><p>  Lösen Sie die Frage "Ist dieser Name bereits in diese Datei importiert?"  Das hatte ich von Anfang an nicht vor: Mit diesem Problem werden wir einen zusätzlichen Durchlauf der Isort-Bibliothek bewältigen. </p><br><p>  Nachdem die erste Version des Skripts ausgeführt wurde, stellten sich jedoch Fragen, die noch gelöst werden mussten.  Es stellte sich heraus, dass 1) ast nicht allmächtig ist, 2) astunparse allmächtiger ist, als wir möchten.  Dies zeigte sich im Folgenden: </p><br><ul><li>  Beim Übergang zum Syntaxbaum verschwinden alle einzeiligen Kommentare aus dem Code. </li><li>  leere Zeilen verschwinden ebenfalls; </li><li>  ast unterscheidet nicht zwischen Funktionen und Methoden der Klasse, wir mussten Logik hinzufügen; </li><li>  Umgekehrt werden beim Wechsel von einem Baum zu einem Code mehrzeilige Kommentare in dreifachen Anführungszeichen in einfache Anführungszeichen geschrieben und belegen eine Zeile. Neue Zeilenumbrüche werden durch \ n ersetzt. </li><li>  Es erscheinen unnötige Klammern, wenn beispielsweise A und B und C oder D zu if ((A und B und C) oder D) werden. </li></ul><br><p>  Der Code, der durch ast und astunparse geleitet wird, funktioniert weiterhin, die Lesbarkeit ist jedoch eingeschränkt. </p><br><p>  Der schwerwiegendste Nachteil ist das Verschwinden von einzeiligen Kommentaren (in anderen Fällen verlieren wir nichts, sondern nur Gewinn - zum Beispiel Klammern).  Die Horast-Bibliothek, die auf ast, astunparse und tokenize basiert, verspricht, dies herauszufinden.  Verspricht und tut. </p><br><p>  Nun die leeren Zeilen.  Es gab zwei mögliche Lösungen: </p><br><ol><li>  tokenize weiß, wie man den "Sprachteil" einer Python bestimmt, und horast nutzt ihn aus, wenn er Kommentartoken erhält.  Aber tokenize hat auch Token wie NewLine und NL.  Sie müssen also sehen, wie Horast Kommentare wiederherstellt und kopiert, wobei der Tokentyp ersetzt wird. <br>  <em>- schlug Anya vor, Erfahrung in der Entwicklung von 2 Monaten</em> </li><li>  Da Horast Kommentare wiederherstellen kann, ersetzen wir zuerst alle leeren Zeilen durch einen bestimmten Kommentar, überspringen dann Horast und ersetzen unseren Kommentar durch eine leere Zeile. <br>  <em>- kam mit Eugene, Erfahrung in der Entwicklung von 8 Jahren</em> </li></ol><br><p>  In den Kommentaren werde ich auf die dreifachen Anführungszeichen eingehen. Es war recht einfach, zusätzliche Klammern einzufügen, zumal einige von ihnen durch automatische Formatierung entfernt werden. </p><br><p>  In horast verwenden wir zwei Funktionen: parse und unparse, aber beide sind nicht ideal - parse enthält seltsame interne Fehler, in seltenen Fällen kann es den Quellcode nicht analysieren und unparse kann nichts schreiben, das type hat (so einen Typ, der Es stellt sich heraus, ob Sie tippen (any_other_type)). </p><br><p>  Ich habe mich gegen das Parsen entschieden, weil die Logik der Arbeit ziemlich verwirrend ist und Ausnahmen selten sind - das Prinzip der Nichtuniversalität funktioniert hier. </p><br><p>  Aber unparese wirkt sehr übersichtlich und recht elegant.  Die Funktion unparse erstellt eine Instanz der Unparser-Klasse, die in <strong>init</strong> den Baum verarbeitet und dann in eine Datei schreibt.  Horast.Unparser wird sukzessive von vielen anderen Unparsern geerbt, wobei die Basisklasse astunparse.Unparser ist.  Alle abgeleiteten Klassen erweitern einfach die Funktionalität der Basisklasse, aber die Logik der Arbeit bleibt gleich. Betrachten Sie also astunparse.Unparser.  Es gibt fünf wichtige Methoden: </p><br><ol><li>  Schreiben - schreibt einfach etwas in eine Datei. </li><li>  fill - verwendet Write basierend auf der Anzahl der Einrückungen (die Anzahl der Einrückungen wird als Klassenfeld gespeichert). </li><li>  enter - erhöht den Einzug. </li><li>  leave - verkleinert den Einzug. </li><li>  dispatch - bestimmt den Typ des Knotens des Baums (sagen wir T), ruft die entsprechende Methode mit dem Namen des Knotentyps auf, jedoch mit einem Unterstrich (d. h. _T).  Dies ist eine Metamethode. </li></ol><br><p>  Alle anderen Methoden sind Methoden der Form _T, z. B. _Module oder _Str.  In jeder dieser Methoden kann sie: 1) rekursiv für Teilbaumknoten versenden oder 2) den Inhalt des Knotens mit write schreiben oder Zeichen und Schlüsselwörter hinzufügen, sodass das Ergebnis ein gültiger Ausdruck in Python ist. </p><br><p>  Wir sind zum Beispiel auf einen Knoten vom Typ arg gestoßen, in dem ast den Argumentnamen und den Annotationsknoten speichert.  Dann ruft dispatch die _arg-Methode auf, die zuerst den Namen des Arguments schreibt, dann den Doppelpunkt schreibt und dispatch für den Annotationsknoten ausführt, wobei der Annotationsteilbaum analysiert wird und dispatch und write weiterhin für diesen Teilbaum aufgerufen werden. </p><br><p>  Kehren wir zu unserem Problem der Unmöglichkeit der Art der Verarbeitung zurück.  Nachdem Sie nun verstanden haben, wie unspezifisch funktioniert, ist das Erstellen Ihres Typs ganz einfach.  Lassen Sie uns einen Typ erstellen: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewType</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, t)</span></span></span><span class="hljs-function">:</span></span> self.s = ts</code> </pre> <br><p>  Es speichert einen String in sich und nicht nur so: Wir müssen Funktionsargumente typisieren und wir erhalten die Argumenttypen in Form von Strings aus dem Andocken.  Ersetzen Sie Argumentanmerkungen daher nicht durch die von uns benötigten Typen, sondern durch ein NewType-Objekt, in dem nur der Name des gewünschten Typs gespeichert ist. </p><br><p>  Dazu erweitern Sie horast.Unparser - schreiben Sie Ihr UnparserWithType, das von horast.Unparser erbt, und fügen Sie die Verarbeitung unseres neuen Typs hinzu. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnparserWithType</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(horast.Unparser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_NewType</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, t)</span></span></span><span class="hljs-function">:</span></span> self.write(ts)</code> </pre> <br><p>  Dies verbindet sich mit dem Geist der Bibliothek.  Die Namen der Variablen sind im Stil von ast erstellt, und deshalb bestehen sie aus einem Buchstaben, und nicht, weil ich mir keine Namen vorstellen kann.  Ich denke, dass t für tree und s für string steht.  NewType ist übrigens keine Zeichenfolge.  Wenn wir wollten, dass es als Zeichenfolgentyp interpretiert wird, müssten wir vor und nach dem Schreibaufruf Anführungszeichen schreiben. </p><br><p>  Und jetzt <del>  die Magie </del>  affen patch: ersetze horast.Unparser durch unseren UnparserWithType. </p><br><p>  So funktioniert es jetzt: Wir haben einen Syntaxbaum, er hat eine Funktion, Funktionen haben Argumente, Argumente haben Typanmerkungen, eine Nadel ist in der Typanmerkung versteckt und Koshcheevs Tod ist darin versteckt.  Bisher gab es überhaupt keine Anmerkungsknoten, wir haben sie erstellt, und jeder dieser Knoten ist eine Instanz von NewType.  Wir nennen die Funktion unparse für unseren Baum und für jeden Knoten, den er dispatch nennt, die diesen Knoten klassifiziert und seine entsprechende Funktion aufruft.  Sobald die dispatch-Funktion den Node des Arguments empfängt, schreibt sie den Namen des Arguments und prüft, ob eine Annotation vorhanden ist (früher war es None, aber wir setzen NewType dort ein). Wenn dies der Fall ist, schreibt sie einen Doppelpunkt und ruft dispatch für die Annotation auf, die unser _NewType aufruft, welches Schreibt einfach die Zeichenfolge, die darin gespeichert ist - dies ist der Typname.  Als Ergebnis erhalten wir das schriftliche Argument: type. </p><br><p>  Eigentlich ist das nicht ganz legal.  Aus der Sicht des Compilers haben wir die Annotationen der Argumente mit einigen Wörtern niedergeschrieben, die nirgendwo definiert sind. Wenn unsparse seine Arbeit beendet, erhalten wir den falschen Code: Wir brauchen Importe.  Ich bilde einfach eine Zeile des richtigen Formats und füge sie am Anfang der Datei ein. Anschließend hänge ich das Ergebnis an "unparse" an, obwohl ich dem Syntaxbaum Importe als Knoten hinzufügen könnte, da ast Import- und ImportFrom-Knoten unterstützt. </p><br><p>  Das Problem der dreifachen Anführungszeichen zu lösen ist nicht schwieriger als das Hinzufügen eines neuen Typs.  Wir werden die StrType-Klasse und die _StrType-Methode erstellen.  Die Methode unterscheidet sich nicht von der _NewType-Methode, die zum Kommentieren von Typen verwendet wird, aber die Definition der Klasse hat sich geändert: Wir speichern nicht nur die Zeichenfolge selbst, sondern auch die Registerebene, auf der sie geschrieben werden soll.  Die Anzahl der Einrückungen ist wie folgt definiert: Wenn diese Zeile in einer Funktion vorkommt, dann eine, wenn in einer Methode, dann zwei, und es gibt keine Fälle, in denen die Funktion im Hauptteil einer anderen Funktion definiert ist und gleichzeitig in unserem Projekt dekoriert wird. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrType</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, s, indent)</span></span></span><span class="hljs-function">:</span></span> self.s = s self.indent = indent <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'"""\n'</span></span> + self.s + <span class="hljs-string"><span class="hljs-string">'\n'</span></span> + <span class="hljs-string"><span class="hljs-string">' '</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span> * self.indent + <span class="hljs-string"><span class="hljs-string">'"""\n'</span></span></code> </pre> <br><p>  In <strong>repr</strong> definieren wir, wie unsere Linie aussehen soll.  Ich denke, das ist bei weitem nicht die einzige Lösung, aber es funktioniert.  Man könnte mit astunparse.fill und astunparse.Unparser.indent experimentieren, dann wäre es universeller, aber diese Idee kam mir schon beim Schreiben dieses Artikels in den Sinn. </p><br><p>  Damit enden gelöste Schwierigkeiten.  Nach dem Ausführen meines Skripts tritt manchmal das Problem des zyklischen Imports auf, dies ist jedoch eine Frage der Architektur.  Ich habe keine fertige Lösung von Drittanbietern gefunden, und es scheint eine ernsthafte Komplikation der Aufgabe zu sein, solche Fälle im Rahmen meines Skripts zu behandeln.  Mit Hilfe von ast ist es wahrscheinlich möglich, zyklische Importe zu erkennen und aufzulösen, aber diese Idee muss separat betrachtet werden.  Im Allgemeinen erlaubte mir die vernachlässigbare Anzahl solcher Vorfälle in unserem Projekt, sie nicht automatisch zu verarbeiten. </p><br><p>  Eine andere Schwierigkeit, auf die ich gestoßen bin, war der Mangel an Ausdrucksverarbeitung in Astroimport, da ein vorsichtiger Leser bereits weiß, dass das Affenpflaster das Heilmittel für alle Krankheiten ist.  Lassen Sie dies seine Hausaufgabe für ihn sein, aber ich habe mich dazu entschlossen: Fügen Sie einfach solche Importe zur Zuordnungsdatei hinzu, da diese Konstruktion normalerweise verwendet wird, um den Namenskonflikt zu umgehen, und wir haben nur wenige davon. </p><br><p>  Trotz der festgestellten Unvollkommenheiten macht das Skript das, was es beabsichtigt hatte.  Was ist das Ergebnis: </p><br><ol><li>  Die Zeit, für die das Projekt gestartet wird, wurde von 10 auf 3 Sekunden verringert. </li><li>  Die Anzahl der Dateien hat sich aufgrund des Entfernens der new_contract-Definitionen verringert.  Die Dateien selbst wurden verkleinert: Ich habe nicht gemessen, aber im Durchschnitt summierte sich das Git auf n hinzugefügte und 2n gelöschte Zeilen. </li><li>  Smart IDEs begannen, andere Hinweise zu geben, denn jetzt sind es keine Kommentare, sondern ehrliche Importe; </li><li>  Die Lesbarkeit wurde verbessert. </li><li>  Irgendwo tauchten Klammern auf. </li></ol><br><p>  Vielen Dank! </p><br><p>  Nützliche Links: </p><br><ol><li>  <a href="https://docs.python.org/3/library/ast.html">Ast</a> </li><li>  <a href="https://pypi.org/project/horast/">Horast</a> </li><li>  <a href="https://greentreesnakes.readthedocs.io/en/latest/nodes.html">Alle Arten von Astknoten und was in ihnen gespeichert ist</a> </li><li>  <a href="https://python-ast-explorer.com/">Zeigt schön den Syntaxbaum</a> </li><li>  <a href="https://pypi.org/project/isort/">Isort</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480930/">https://habr.com/ru/post/de480930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480920/index.html">Test von TP-Link Switches mit Long Range PoE. Und ein bisschen über Upgrades alter Modelle</a></li>
<li><a href="../de480922/index.html">Evgeny Usvitsky: „Jeder auf der Welt weiß, wo er Geodaten frei bekommen kann - nur in OSM“</a></li>
<li><a href="../de480924/index.html">Wie und warum haben die Macher des Remakes von MediEvil den Kult-Boss des Spiels neu gestaltet</a></li>
<li><a href="../de480926/index.html">Wahrscheinlichkeitstheorie für physikalisch genaues Rendern</a></li>
<li><a href="../de480928/index.html">Apache Hadoop Code Qualität: Produktion VS Test</a></li>
<li><a href="../de480936/index.html">Schnelle Konvertierung von UPPER_CASE nach camelCase</a></li>
<li><a href="../de480938/index.html">Kryptowährung aus Sicht russischer Richter</a></li>
<li><a href="../de480940/index.html">Führen Sie einen browserübergreifenden UI-Test mit Cucumber und Selenoid in Gitlab CI mit Allure-Bericht aus</a></li>
<li><a href="../de480944/index.html">Top 5 Trends im E-Mail-Marketing im Jahr 2020</a></li>
<li><a href="../de480946/index.html">Protokolle in Kubernetes (und nicht nur) heute: Erwartungen und Realität</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>