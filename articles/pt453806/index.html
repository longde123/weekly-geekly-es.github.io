<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏮 🕊️ 👩🏿‍🚀 Tratamento de erros no Go 🍽️ 👌🏾 🆘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá, cidadãos de Habrovsk! O curso Golang Developer já está começando no OTUS hoje e consideramos uma ótima ocasião para compartilhar outro post útil ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tratamento de erros no Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/453806/">  Olá, cidadãos de Habrovsk!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O</a> curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Golang Developer</a> já está começando no OTUS hoje e consideramos uma ótima ocasião para compartilhar outro post útil sobre o assunto.  Hoje vamos falar sobre a abordagem da Go aos erros.  Vamos começar! <br><br><img src="https://habrastorage.org/webt/mr/8i/ch/mr8ichd887jvkbuzbf3dh_h5oc0.png"><br><br><h3>  Dominar o tratamento pragmático de erros no seu código Go </h3><br><img src="https://habrastorage.org/webt/gp/i3/ff/gpi3ffckknhyvkcqyfyk1dnbltc.png"><br><br>  <i>Esta postagem faz parte da série <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Antes de</a> Começar, onde exploramos o mundo de Golang, compartilhamos dicas e idéias que você deve saber ao escrever código no Go, para que você não precise preencher seus próprios inchaços.</i> <br><br>  Suponho que você já tenha pelo menos uma experiência básica com o Go, mas se, em algum momento, encontrou um material de discussão desconhecido, não hesite em fazer uma pausa, explorar o tópico e voltar. <br><br>  Agora que abrimos o caminho, vamos lá! <a name="habracut"></a><br><br>  A abordagem da Go ao tratamento de erros é um dos recursos mais controversos e mal utilizados.  Neste artigo, você aprenderá a abordagem dos erros de Go e entenderá como eles funcionam "sob o capô".  Você aprenderá algumas abordagens diferentes, examinará o código-fonte Go e a biblioteca padrão para descobrir como os erros são tratados e como trabalhar com eles.  Você aprenderá por que as asserções de tipo desempenham um papel importante no tratamento delas e verá as próximas alterações no tratamento de erros que planeja introduzir no Go 2. <br><br><img src="https://habrastorage.org/webt/e3/0t/gk/e30tgk9zbbofawpffxugwstrhow.png"><br><br><h2>  Entrada </h2><br>  Primeiras coisas primeiro: erros no Go não são excepção.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dave Cheney</a> escreveu um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">post épico no blog</a> sobre isso, então eu o refiro e resumo: em outros idiomas, você não pode ter certeza se uma função pode gerar uma exceção ou não.  Em vez de lançar exceções, as funções Go suportam <b>vários valores de retorno</b> e, por convenção, esse recurso geralmente é usado para retornar o resultado de uma função junto com uma variável de erro. <br><br><img src="https://habrastorage.org/webt/p5/nl/dw/p5nldwpihop5qjmlgz4f0h0v_yi.png"><br><br>  Se, por algum motivo, sua função falhar, provavelmente você deve retornar o tipo de <code>error</code> declarado anteriormente.  Por convenção, retornar um erro sinaliza ao chamador sobre o problema e retornar zero não é considerado um erro.  Assim, você fará com que o chamador entenda que um problema surgiu e ele precisa lidar com isso: quem chama sua função, ele sabe que não deve confiar no resultado antes de verificar se há um erro.  Se o erro não for nulo, ele é obrigado a verificá-lo e processá-lo (registrar, retornar, manter, chamar algum tipo de mecanismo de nova tentativa / limpeza, etc.). <br><br><img src="https://habrastorage.org/webt/l2/u-/05/l2u-05npjr4ptcwn7woqyb20usg.png"><br>  <i>(3 // tratamento de erros</i> <i><br></i>  <i>5 // continuação)</i> <br><br>  Esses snippets são muito comuns no Go, e alguns os consideram como código padrão.  O compilador trata variáveis ​​não utilizadas como erros de compilação; portanto, se você não deseja verificar se há erros, deve atribuí-los a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um identificador vazio</a> .  Porém, por mais conveniente que seja, os erros não devem ser ignorados. <br><br><img src="https://habrastorage.org/webt/fm/pq/rv/fmpqrvcl6_eh4tvwhq0ebxmd4qo.png"><br>  <i>(4 // ignorar erros não é seguro e você não deve confiar no resultado antes de verificar se há erros)</i> <br>  <i><b>o resultado não pode ser confiável até a verificação de erros</b></i> <br><br>  O retorno do erro junto com os resultados, junto com o sistema estrito do tipo Go, complica bastante a gravação do código marcado.  Você sempre deve assumir que o valor de uma função está corrompido, a menos que tenha verificado o erro que ela retornou e, ao atribuir o erro a um identificador vazio, ignora explicitamente que o valor da sua função pode estar corrompido. <br><br><img src="https://habrastorage.org/webt/lm/xj/uh/lmxjuhxt8v8sdvillwvsbbuct5o.png"><br>  <b><i>O id vazio é escuro e cheio de horrores.</i></b> <br><br>  O Go possui mecanismos de <code>panic</code> e <code>recover</code> , que também são descritos em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">outra postagem detalhada do blog do Go</a> .  Mas eles não pretendem simular exceções.  De acordo com Dave, <i>"quando você entra em pânico no Go, você realmente entra em pânico: isso não é problema de outra pessoa, ele já é um jogador".</i>  Eles são fatais e levam a uma falha no seu programa.  Rob Pike cunhou o ditado "Não entre em pânico", que fala por si: você provavelmente deve evitar esses mecanismos e retornar erros. <br><br><blockquote>  "Erros são os significados." <br>  "Não apenas verifique se há erros, mas lide com eles com elegância." <br>  "Não entre em pânico" <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">todas as palavras de Rob Pike</a> <br></blockquote><br><h2>  Sob o capô </h2><br>  <b>Interface de erro</b> <br><br>  Sob o capô, o tipo de erro é uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interface simples com um método</a> , e se você não estiver familiarizado com ele, recomendo ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esta postagem</a> no blog oficial do Go. <br><br><img src="https://habrastorage.org/webt/n_/c3/ip/n_c3iptfnwohofkgwwhhxc-cwda.png"><br>  <b><i>interface de erro da fonte</i></b> <br><br>  Cometer seus próprios erros não é difícil.  Existem várias abordagens para estruturas de usuário que implementam o método de <code>string</code> <code>Error()</code> .  Qualquer estrutura que implemente esse método único é considerada um valor de erro válido e pode ser retornada como tal. <br><br>  Vejamos algumas dessas abordagens. <br><br><h3>  Estrutura errorString interna </h3><br>  A implementação mais comum e amplamente usada da interface de erro é a estrutura <code>errorString</code> .  Essa é a implementação mais fácil que você pode imaginar. <br><br><img src="https://habrastorage.org/webt/uv/hj/by/uvhjbyzjh8cmovqpjdkda0ww5_c.png"><br>  Fonte: <a href="">código fonte Go</a> <br><br>  Você pode ver sua implementação simplificada <a href="">aqui</a> .  Tudo o que faz é conter uma <code>string</code> e essa sequência é retornada pelo método <code>Error</code> .  Esse erro de string pode ser formatado por nós com base em alguns dados, digamos, usando <code>fmt.Sprintf</code> .  Mas, além disso, ele não contém outros recursos.  Se você aplicou <a href="">errors.New</a> ou <a href="">fmt.Errorf</a> , você já o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">usou</a> . <br><br><img src="https://habrastorage.org/webt/br/6h/g5/br6hg5p3lozppuf98ry0g2ptsw4.png"><br>  <i>(13 // saída :)</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tentar</a> <br><br><h3>  github.com/pkg/errors </h3><br>  Outro exemplo simples é o <a href="">pacote pkg / errors</a> .  Para não ser confundido com o pacote de <code>errors</code> interno que você aprendeu anteriormente, este pacote fornece recursos importantes adicionais, como quebra de erros, expansão, formatação e gravação de rastreamento de pilha.  Você pode instalar o pacote executando <code>go get github.com/pkg/errors</code> . <br><br><img src="https://habrastorage.org/webt/bo/vs/f7/bovsf7dn4l2gvaesqbepogmjxrw.png"><br><br>  Nos casos em que você precisa anexar o rastreamento de pilha ou as informações de depuração necessárias aos seus erros, o uso das <code>Errorf</code> <code>New</code> ou <code>Errorf</code> deste pacote fornece erros que já foram gravados no rastreamento de pilha e você também pode anexar metadados simples usando-os recursos de formatação.  <code>Errorf</code> implementa a interface <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fmt.Formatter</a> , ou seja, você pode formatá-la usando as runas do pacote <code>fmt</code> ( <code>%s</code> , <code>%v</code> , <code>%+v</code> , etc.). <br><br><img src="https://habrastorage.org/webt/tz/r6/if/tzr6if2llu8ayda0lrnl1zblkju.png"><br>  <i>(// 6 ou alternativa)</i> <br><br>  Este pacote também apresenta as <code>errors.Wrapf</code> e <code>errors.Wrapf</code> .  Essas funções adicionam contexto ao erro usando uma mensagem e um rastreamento de pilha no local em que foram chamados.  Portanto, em vez de simplesmente retornar o erro, você pode envolvê-lo com contexto e dados importantes de depuração. <br><br><img src="https://habrastorage.org/webt/pa/pz/3t/papz3tu-dlhtdcb4r8lmldfxazu.png"><br><br>  Os invólucros de erro de outros erros suportam o método de <code>Cause() error</code> , que retorna seu erro interno.  Além disso, eles podem ser usados ​​com <code>errors.Cause(err error) error</code> Função de <code>errors.Cause(err error) error</code> , que extrai o principal erro interno do erro de <code>errors.Cause(err error) error</code> . <br><br><h2>  Tratamento de erros </h2><br><h3>  Homologação de tipo </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">As</a> asserções de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tipo</a> desempenham um papel importante ao lidar com erros.  Você os usará para extrair informações do valor da interface e, como o tratamento de erros está associado às implementações do usuário na interface de <code>error</code> , a implementação de instruções de <code>error</code> é uma ferramenta muito conveniente. <br><br>  Sua sintaxe é a mesma para todos os fins - <code>x.(T)</code> se <code>x</code> tiver um tipo de interface.  <code>x.(T)</code> afirma que <code>x</code> não <code>x</code> <code>nil</code> e que o valor armazenado em <code>x</code> é do tipo <code>T</code>  Nas próximas seções, consideraremos duas maneiras de usar instruções de tipo - com um tipo específico <code>T</code> e com uma interface do tipo <code>T</code> <br><br><img src="https://habrastorage.org/webt/tb/fd/e2/tbfde2ne-8parkmkbsthfamc_ym.png"><br>  <i>(2 // sintaxe abreviada pulando a variável booleana ok</i> <i><br></i>  <i>3 // panic: conversão de interface: interface {} é nula, não string</i> <i><br></i>  <i>6 // sintaxe estendida com booleano ok</i> <i><br></i>  <i>8 // não entra em pânico; em vez disso, define ok false quando a instrução é false</i> <i><br></i>  <i>9 // agora podemos usar s como uma string)</i> <br><br>  <b><i>sandbox: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pânico com sintaxe abreviada</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sintaxe estendida segura</a></i></b> <br><br><blockquote>  <i>Nota adicional sobre sintaxe: uma asserção de tipo pode ser usada com uma sintaxe abreviada (que entra em pânico quando uma instrução falha) ou com uma sintaxe estendida (que usa o valor lógico OK para indicar sucesso ou falha).</i>  <i>Eu sempre recomendo tomar alongado em vez de encurtado, pois prefiro verificar a variável OK e não lidar com pânico.</i> </blockquote><br><br><h3>  Aprovação do tipo T </h3><br>  Uma declaração do tipo <code>x.(T)</code> com uma interface do tipo <code>T</code> confirma que <code>x</code> implementa a interface de <code>T</code>  Assim, você pode garantir que o valor da interface implemente a interface e, somente se for o caso, poderá usar seus métodos. <br><br><img src="https://habrastorage.org/webt/jl/ps/k7/jlpsk7f8m1bj-7jhwbgmzigsqea.png"><br>  <i>(5 ... // afirma que x implementa a interface do resolvedor</i> <i><br></i>  <i>6 ... // aqui já podemos usar esse método com segurança)</i> <br><br>  Para entender como isso pode ser usado, vamos dar uma olhada no <code>pkg/errors</code> novamente.  Você já conhece esse pacote de erros, então vamos nos aprofundar na função de <code>errors.Cause(err error) error</code> . <br><br>  Essa função recebe um erro e extrai o erro mais interno que ele sofre (aquele que não serve mais como invólucro para outro erro).  Isso pode parecer primitivo, mas há muitas coisas excelentes que você pode aprender com esta implementação: <br><br><img src="https://habrastorage.org/webt/kj/uy/rm/kjuyrm3rxxgtqt-8a6_cd1bvsqg.png"><br>  fonte: <a href="">pkg / errors</a> <br><br>  A função recebe o valor do erro e não pode assumir que o argumento <code>err</code> que recebe é um erro de wrapper (suportado pelo método <code>Cause</code> ).  Portanto, antes de chamar o método <code>Cause</code> , você precisa verificar se está lidando com um erro que implementa esse método.  Ao executar uma instrução de tipo em cada iteração do loop for, você pode garantir que a variável de <code>cause</code> dê suporte ao método <code>Cause</code> e continue a extrair erros internos até encontrar um erro que não tenha <code>Cause</code> . <br><br>  Criando uma interface local simples que contém apenas os métodos necessários e aplicando asserções, seu código é separado de outras dependências.  O argumento que você recebeu não precisa ser uma estrutura conhecida, apenas um erro.  Qualquer tipo que implemente os métodos <code>Error</code> e <code>Cause</code> funcionará.  Portanto, se você implementar o método <code>Cause</code> no seu tipo de erro, poderá usar esta função com ele sem lentidão. <br><br>  No entanto, há uma pequena desvantagem a ser lembrada: as interfaces podem mudar, portanto, você deve manter cuidadosamente o código para que suas instruções não sejam violadas.  Não se esqueça de definir suas interfaces onde você as usa, para mantê-las esbeltas e organizadas, e você ficará bem. <br><br>  Finalmente, se você precisar de apenas um método, às vezes é mais conveniente fazer uma declaração em uma interface anônima que contenha apenas o método em que você confia, ou seja <code>v, ok := x.(interface{ F() (int, error) })</code> .  O uso de interfaces anônimas pode ajudar a separar seu código de possíveis dependências e protegê-lo de possíveis alterações nas interfaces. <br><br><h3>  Aprovação do tipo T e do comutador de tipo </h3><br><br>  Eu prefácio esta seção introduzindo dois padrões semelhantes de tratamento de erros que sofrem de várias falhas e armadilhas.  Isso não significa que eles não sejam comuns.  Ambos podem ser ferramentas convenientes em pequenos projetos, mas não são bem dimensionados. <br><br>  A primeira é a segunda versão da asserção de tipo: uma asserção do tipo <code>x.(T)</code> com um tipo específico <code>T</code> é executada.  Ele afirma que o valor de <code>x</code> é do tipo <code>T</code> ou pode ser convertido para o tipo <code>T</code> <br><br><img src="https://habrastorage.org/webt/mh/c5/qy/mhc5qyqfrrnhpct7wyfzhhpflju.png"><br>  <i>(2 // podemos usar v como mypkg.SomeErrorType)</i> <br><br>  Outro é o padrão de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">troca de tipo</a> .  A opção Type Switch combina uma instrução switch com uma instrução type usando a palavra-chave <code>type</code> reservada.  Eles são especialmente comuns no tratamento de erros, onde o conhecimento do tipo básico de um erro variável pode ser muito útil. <br><br><img src="https://habrastorage.org/webt/on/iz/ji/onizji38uqjzltxqord4icmmvoq.png"><br>  <i>(3 // processando ...</i> <i><br></i>  <i>5 // processando ...)</i> <br><br>  A grande desvantagem de ambas as abordagens é que ambas levam à ligação de código com suas dependências.  Ambos os exemplos devem estar familiarizados com a estrutura <code>SomeErrorType</code> (que obviamente deve ser exportada) e deve importar o pacote <code>mypkg</code> . <br>  Nas duas abordagens, ao manipular seus erros, você deve estar familiarizado com o tipo e importar seu pacote.  A situação é agravada quando você lida com erros em wrappers, nos quais a causa do erro pode ser um erro decorrente de uma dependência interna que você não conhece e não deve conhecer. <br><br><img src="https://habrastorage.org/webt/vz/xz/zq/vzxzzqe6qajcsroflsuy0mjt5jk.png"><br>  <i>(7 // processando ...</i> <i><br></i>  <i>9 // processando ...)</i> <br><br>  A opção Tipo alterna entre <code>*MyStruct</code> e <code>MyStruct</code> .  Portanto, se você não tiver certeza se está lidando com um ponteiro ou uma instância real de uma estrutura, precisará fornecer as duas opções.  Além disso, como no caso de comutadores regulares, os casos no comutador de tipo não falham, mas, diferentemente do comutador de tipo usual, o uso de <code>fallthrough</code> proibido no comutador de tipo, portanto, você deve usar uma vírgula e fornecer as duas opções, o que é fácil de esquecer. <br><br><img src="https://habrastorage.org/webt/pe/1y/g7/pe1yg7one8orth5kvcdguqtpteo.png"><br><br><h2>  Resumir </h2><br>  Isso é tudo!  Agora você está familiarizado com os erros e deve estar preparado para corrigir quaisquer erros que seu aplicativo Go possa lançar (ou realmente retornar) ao seu caminho! <br>  Os dois pacotes de <code>errors</code> fornecem abordagens simples, mas importantes, dos erros do Go e, se atenderem às suas necessidades, serão uma ótima opção.  Você pode implementar facilmente suas próprias estruturas de erro e tirar proveito do tratamento de erros Go combinando-os com <code>pkg/errors</code> . <br><br>  Quando você dimensiona erros simples, o uso correto de instruções de tipo pode ser uma ótima ferramenta para lidar com vários erros.  Usando o Type Switch, ou validando o comportamento do erro e verificando as interfaces que ele implementa. <br><br><h2>  O que vem a seguir? </h2><br>  O tratamento de erros no Go agora é muito relevante.  Agora que você já conhece o básico, pode estar se perguntando o que temos pela frente para lidarmos com os erros do Go! <br><br>  A próxima versão do Go 2 presta muita atenção a isso, e você já pode dar uma olhada na <a href="">versão preliminar</a> .  Além disso, durante o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dotGo 2019,</a> Marcel van Lojuizen teve uma excelente conversa sobre um tópico que eu simplesmente não posso deixar de recomendar - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">“GO 2 valores de erro hoje”</a> . <br><br>  Obviamente, existem muitas outras abordagens, dicas e truques, e não posso incluí-las todas em um post!  Apesar disso, espero que tenham gostado, e até o próximo episódio <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de Antes de começar</a></i> ! <br><br>  E agora tradicionalmente aguardando seus comentários. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt453806/">https://habr.com/ru/post/pt453806/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt453790/index.html">"O cliente se foi - é para sempre?" Como contar a rotatividade de clientes em SaaS e o que há de errado nas métricas básicas</a></li>
<li><a href="../pt453792/index.html">Sistemas de recomendação: idéias, abordagens, tarefas</a></li>
<li><a href="../pt453796/index.html">As pessoas precisam de matemática?</a></li>
<li><a href="../pt453800/index.html">Como resolver o "Campo Minado" (e torná-lo melhor)</a></li>
<li><a href="../pt453804/index.html">O livro "Competitividade e simultaneidade na plataforma .NET. Padrões de design eficazes ”</a></li>
<li><a href="../pt453808/index.html">Desmontamos o modelo de negócios da Viking</a></li>
<li><a href="../pt453810/index.html">Feedback biométrico</a></li>
<li><a href="../pt453812/index.html">Temas, estilos e outros</a></li>
<li><a href="../pt453816/index.html">Encefalite transmitida por carrapatos: um perigo negligenciado</a></li>
<li><a href="../pt453818/index.html">GitLab 11.11: vários responsáveis ​​por solicitações de mesclagem e melhorias para contêineres</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>