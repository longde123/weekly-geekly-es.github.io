<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòÄ üéñÔ∏è üë©üèΩ‚Äçü§ù‚Äçüë©üèº Test de mutation en PHP: une mesure qualitative pour la couverture du code üë©‚Äç‚öïÔ∏è ü•à ü•¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comment √©valuer la qualit√© des tests? Beaucoup s'appuient sur la mesure la plus populaire connue de tous: la couverture du code. Mais il s'agit d'une ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Test de mutation en PHP: une mesure qualitative pour la couverture du code</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/462709/">  Comment √©valuer la qualit√© des tests?  Beaucoup s'appuient sur la mesure la plus populaire connue de tous: la couverture du code.  Mais il s'agit d'une m√©trique quantitative et non qualitative.  Il montre combien de votre code est couvert par des tests, mais pas comment ces tests sont bien √©crits. <br><br>  Une fa√ßon de comprendre cela est de tester les mutations.  Cet outil, apportant des modifications mineures au code source et relan√ßant les tests par la suite, vous permet d'identifier les tests inutiles et la couverture de faible qualit√©. <br><br>  Lors du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Meetup Badoo PHP en mars,</a> j'ai parl√© de la fa√ßon d'organiser les tests mutationnels pour le code PHP et des probl√®mes que vous pourriez rencontrer.  La vid√©o est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , et pour la version texte, bienvenue √† cat. <br><br><img src="https://habrastorage.org/webt/qc/xz/fi/qcxzfinlil5-p8zjwtafifv2mqu.jpeg"><br><a name="habracut"></a><br><h2>  Qu'est-ce que le test de mutation </h2><br>  Pour expliquer ce que je veux dire, je vais vous montrer quelques exemples.  Ils sont simples, exag√©r√©s par endroits et peuvent sembler √©vidents (bien que les exemples r√©els soient g√©n√©ralement assez complexes et ne peuvent pas √™tre vus avec leurs yeux). <br><br>  Consid√©rez la situation: nous avons une fonction √©l√©mentaire qui pr√©tend √™tre un adulte, et il y a un test qui la teste.  Le test a un fournisseur de donn√©es, c'est-√†-dire qu'il teste deux cas: 17 ans et 19 ans.  Je pense qu'il est √©vident pour beaucoup d'entre vous que isAdult a une couverture √† 100%.  La seule ligne.  Le test est effectu√©.  Tout est magnifique. <br><br><img src="https://habrastorage.org/webt/w2/qq/ag/w2qqagnuajffn5ubmkgwnbsubpg.png"><br><br>  Mais un examen plus approfondi r√©v√®le que notre fournisseur est mal √©crit et ne teste pas les conditions aux limites: l'√¢ge de 18 ans en tant que condition aux limites n'est pas test√©.  Vous pouvez remplacer le signe&gt; par&gt; =, et le test ne d√©tectera pas une telle modification. <br><br>  Un autre exemple, un peu plus compliqu√©.  Il existe une fonction qui construit un objet simple contenant des setters et des getters.  Nous avons trois champs que nous d√©finissons, et il y a un test qui v√©rifie que la fonction buildPromoBlock collecte vraiment l'objet que nous attendons. <br><br><img src="https://habrastorage.org/webt/a6/mr/eq/a6mreqjphzfwflq35qxf5skwfle.png"><br><br>  Si vous regardez attentivement, nous avons √©galement setSomething, qui d√©finit une propri√©t√© sur true.  Mais dans le test, nous n'avons pas une telle affirmation.  Autrement dit, nous pouvons supprimer cette ligne de buildPromoBlock - et notre test ne d√©tectera pas ce changement.  Dans le m√™me temps, nous avons une couverture de 100% dans la fonction buildPromoBlock, car les trois lignes ont √©t√© ex√©cut√©es pendant le test. <br><br>  Ces deux exemples nous conduisent √† ce qu'est le test de mutation. <br><br>  Avant de d√©monter l'algorithme, je donnerai une courte d√©finition.  Le test de mutation est un m√©canisme qui nous permet, en apportant des modifications mineures au code, d'imiter les actions du mal Pinocchio ou du junior Vasya, qui est venu et a commenc√© √† le casser d√©lib√©r√©ment, remplacer les signes&gt; par &lt;, = par! =, Etc.  Pour chacune de ces modifications que nous apportons √† de bonnes fins, nous ex√©cutons des tests qui doivent couvrir la ligne modifi√©e. <br><br>  Si les tests ne nous ont rien montr√©, s'ils ne sont pas tomb√©s, alors ils ne sont probablement pas assez efficaces.  Ils ne testent pas les cas limites, ne contiennent pas d'assertions: ils doivent peut-√™tre √™tre am√©lior√©s.  Si les tests √©chouent, alors ils sont cool.  Ils prot√®gent vraiment contre de tels changements.  Par cons√©quent, notre code est plus difficile √† briser. <br><br>  Analysons maintenant l'algorithme.  C'est assez simple.  La premi√®re chose que nous faisons pour effectuer des tests de mutation est de prendre le code source.  Ensuite, nous obtenons une couverture de code pour savoir quels tests ex√©cuter pour quelle cha√Æne.  Apr√®s cela, nous passons en revue le code source et g√©n√©rons les soi-disant mutants. <br><br>  Un mutant est un changement de code unique.  Autrement dit, nous prenons une certaine fonction o√π il y avait un signe&gt; en comparaison, si, nous changeons ce signe en&gt; = - et nous obtenons un mutant.  Apr√®s cela, nous ex√©cutons les tests.  Voici un exemple de mutation (nous avons remplac√©&gt; par&gt; =): <br><br><img src="https://habrastorage.org/webt/tu/fe/rm/tufermumemlipcqjluus2h-bzmm.png"><br><br>  Dans ce cas, les mutations ne sont pas faites au hasard, mais selon certaines r√®gles.  La r√©ponse du test de mutation est idempotente.  Peu importe le nombre de fois o√π nous ex√©cutons des tests de mutation sur le m√™me code, ils produisent les m√™mes r√©sultats. <br><br>  La derni√®re chose que nous faisons est d'ex√©cuter les tests qui couvrent la ligne mut√©e.  Sortez-le de la couverture.  Il existe des outils non optimaux qui pilotent tous les tests.  Mais un bon outil ne chassera que ceux qui sont n√©cessaires. <br><br>  Apr√®s cela, nous √©valuons le r√©sultat.  Les tests ont √©chou√© - alors tout va bien.  S'ils ne sont pas tomb√©s, ils ne sont pas tr√®s efficaces. <br><br><h2>  Mesures </h2><br>  Quelles mesures les tests de mutation nous fournissent-ils?  Il en ajoute trois autres √† la couverture du code, dont nous parlerons maintenant. <br><br>  Mais d'abord, analysons la terminologie. <br><br><img width="400" src="https://habrastorage.org/webt/_6/pu/yz/_6puyzoefm_yith6s0ep8yzwqao.png"><br><br>  Il y a le concept de mutants tu√©s: ce sont les mutants que nos tests ont ¬´clou√©s¬ª (c'est-√†-dire qu'ils les ont captur√©s). <br><br><img width="400" src="https://habrastorage.org/webt/3b/7o/it/3b7oitf-byu91zv3jbooogylvna.png"><br><br>  Il y a le concept de mutant √©chapp√© (mutants survivants).  Ce sont les mutants qui ont r√©ussi √† √©viter la punition (c'est-√†-dire que les tests ne les ont pas d√©tect√©s). <br><br><img width="400" src="https://habrastorage.org/webt/dw/8a/ye/dw8ayeaxuwut_6rcbdchfdm0cfg.png"><br><br>  Et il y a des concepts couverts par un mutant - un mutant couvert par des tests et un mutant d√©couvert en face de lui, qui n'est couvert par aucun test (c'est-√†-dire que nous avons du code, il a une logique m√©tier, nous pouvons le changer, mais pas un seul test ne v√©rifie pas les modifications). <br><br>  Le principal indicateur que le test de mutation nous donne est le MSI (indicateur de score de mutation), le rapport du nombre de mutants tu√©s √† leur nombre total. <br><br>  Le deuxi√®me indicateur est la couverture du code de mutation.  C'est juste qualitatif, pas quantitatif, car il montre combien de logique m√©tier vous pouvez briser et le faire r√©guli√®rement, nos tests sont pris. <br><br>  Et la derni√®re m√©trique est le MSI couvert, c'est-√†-dire un MSI plus doux.  Dans ce cas, nous calculons MSI uniquement pour les mutants qui ont √©t√© couverts par des tests. <br><br><h2>  Probl√®mes de test de mutation </h2><br>  Pourquoi moins de la moiti√© des programmeurs ont entendu parler de cet outil?  Pourquoi n'est-il pas utilis√© partout? <br><br><h3>  Basse vitesse </h3><br>  Le premier probl√®me (l'un des principaux) est la vitesse des tests de mutation.  Dans le code, si nous avons des dizaines d'op√©rateurs de mutation, m√™me pour la classe la plus simple, nous pouvons g√©n√©rer des centaines de mutations.  Pour chaque mutation, vous devrez ex√©cuter des tests.  Si nous avons, disons, 5 000 tests unitaires qui durent dix minutes, le test mutationnel peut prendre des heures. <br><br>  Que peut-on faire pour niveler cela?  Ex√©cutez des tests en parall√®le, dans plusieurs threads.  Jetez des flux dans plusieurs voitures.  √áa marche. <br><br>  La deuxi√®me fa√ßon est les ex√©cutions incr√©mentielles.  Il n'est pas n√©cessaire de compter les indicateurs mutationnels pour la branche enti√®re √† chaque fois - vous pouvez prendre la diff√©rence de branche.  Si vous utilisez des brunchs de fonctionnalit√©s, il vous sera facile de le faire: ex√©cutez des tests uniquement sur les fichiers qui ont chang√© et voyez ce qui se passe dans l'assistant, comparez, analysez. <br><br>  La prochaine chose que vous pouvez faire est le r√©glage des mutations.  √âtant donn√© que les op√©rateurs de mutation peuvent √™tre modifi√©s, vous pouvez d√©finir certaines r√®gles selon lesquelles ils fonctionnent, puis vous pouvez arr√™ter certaines mutations si elles entra√Ænent sciemment des probl√®mes. <br><br>  Un point important: le test mutationnel ne convient qu'aux tests unitaires.  Malgr√© le fait qu'il puisse √™tre ex√©cut√© pour des tests d'int√©gration, c'est √©videmment une id√©e rat√©e, car les tests d'int√©gration (comme de bout en bout) s'ex√©cutent beaucoup plus lentement et affectent beaucoup plus de code.  Vous n'attendrez tout simplement jamais les r√©sultats.  En principe, ce m√©canisme a √©t√© invent√© et d√©velopp√© exclusivement pour les tests unitaires. <br><br><h3>  Mutants sans fin </h3><br>  Le deuxi√®me probl√®me qui peut survenir avec les tests de mutation est celui des mutants dits sans fin.  Par exemple, il y a du code simple, une boucle for simple: <br><br><img src="https://habrastorage.org/webt/no/tr/az/notrazetuv221u41t1g8rfbkmlc.png"><br><br>  Si vous remplacez i ++ par i--, le cycle se transformera en infini.  Votre code restera longtemps.  Et les tests mutationnels g√©n√®rent assez souvent de telles mutations. <br><br>  La premi√®re chose que vous pouvez faire est de r√©gler la mutation.  √âvidemment, changer i ++ en i-- dans une boucle for est une tr√®s mauvaise id√©e: dans 99% des cas, nous nous retrouverons avec une boucle infinie.  Par cons√©quent, nous avons interdit de le faire dans notre outil. <br><br>  La deuxi√®me chose et la plus importante qui vous prot√®ge contre de tels probl√®mes est le d√©lai d'attente pour la course.  Par exemple, le m√™me PHPUnit a la possibilit√© de terminer un test de d√©lai d'expiration quel que soit l'endroit o√π il est bloqu√©.  PHPUnit via PCNTL raccroche les rappels et calcule le temps lui-m√™me.  Si le test √©choue pendant une certaine p√©riode, il le cloue simplement et un tel cas est consid√©r√© comme un mutant tu√©, car le code qui a g√©n√©r√© les mutations est vraiment v√©rifi√© par le test, qui d√©tecte vraiment le probl√®me, indiquant que le code est devenu inop√©rant. <br><br><h3>  Mutants identiques </h3><br>  Ce probl√®me existe dans la th√©orie des tests de mutation.  En pratique, il n'est pas souvent rencontr√©, mais vous devez le savoir. <br><br>  Prenons un exemple classique qui l'illustre.  Nous avons une multiplication de la variable A par -1 et une division de A par -1.  Dans le cas g√©n√©ral, ces op√©rations conduisent au m√™me r√©sultat.  Nous changeons le signe de A. En cons√©quence, nous avons une mutation qui permet √† deux signes de changer entre eux.  La logique du programme par une telle mutation n'est pas viol√©e.  Les tests et ne doivent pas l'attraper, ne doivent pas tomber.  En raison de ces mutants identiques, certaines difficult√©s surviennent. <br><br>  Il n'y a pas de solution universelle - chacun r√©sout ce probl√®me √† sa mani√®re.  Peut-√™tre qu'une sorte de syst√®me d'enregistrement mutant pourrait aider.  Chez Badoo, nous pensons √† quelque chose de similaire maintenant, nous allons les imiter. <br><br><h2>  Ceci est une th√©orie.  Et PHP? </h2><br>  Il existe deux outils bien connus pour le test mutationnel: Humbug et Infection.  Lorsque je pr√©parais l'article, je voulais parler de celui qui est le meilleur et en venir √† la conclusion qu'il s'agit d'une infection. <br>  Mais quand je suis all√© √† la page Humbug, j'ai vu ce qui suit: Humbug s'est d√©clar√© obsol√®te en faveur de l'infection.  Par cons√©quent, une partie de mon article s'est av√©r√©e vide de sens.  L'infection est donc un tr√®s bon outil.  Je dois dire merci √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">borNfree</a> de Minsk, qui l'a cr√©√©.  Il travaille vraiment cool.  Vous pouvez le prendre directement dans la bo√Æte, le passer par le compositeur et le d√©marrer. <br><br>  Nous avons vraiment aim√© Infection.  Nous voulions l'utiliser.  Mais ils ne le pouvaient pas pour deux raisons.  L'infection n√©cessite une couverture de code pour ex√©cuter des tests pour les mutants correctement et pr√©cis√©ment.  Ici, nous avons deux fa√ßons.  Nous pouvons le calculer directement en runtime (mais nous avons 100 000 tests unitaires).  Ou nous pouvons le calculer pour le ma√Ætre actuel (mais construire sur notre nuage de dix machines tr√®s puissantes dans plusieurs threads prend une heure et demie).  Si nous le faisons √† chaque ex√©cution de mutation, l'outil ne fonctionnera probablement pas. <br><br>  Il existe une option pour alimenter le fichier fini, mais au format PHPUnit, il s'agit d'un tas de fichiers XML.  Outre le fait qu'ils contiennent des informations pr√©cieuses, ils font glisser un tas de structure, des crochets et d'autres choses.  Je me suis dit qu'en g√©n√©ral, notre couverture de code p√®serait environ 30 Go, et nous devons la faire glisser sur toutes les machines cloud, en lecture constante depuis le disque.  En g√©n√©ral, l'id√©e est moyenne. <br>  Le deuxi√®me probl√®me √©tait encore plus important.  Nous avons une merveilleuse biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SoftMocks</a> .  Il nous permet de g√©rer le code h√©rit√©, qui est difficile √† tester, et d'√©crire avec succ√®s des tests pour celui-ci.  Nous l'utilisons activement et n'allons pas le refuser dans un proche avenir, malgr√© le fait que nous √©crivons du nouveau code afin de ne pas avoir besoin de SoftMocks.  Donc, cette biblioth√®que est incompatible avec Infection, car ils utilisent presque la m√™me approche pour modifier les changements. <br><br>  Comment fonctionnent les SoftMocks?  Ils interceptent les inclusions de fichiers et les remplacent par des modifications, c'est-√†-dire qu'au lieu d'ex√©cuter la classe A, SoftMocks cr√©e la classe A √† un endroit diff√©rent et en connecte une autre au lieu de l'original.  L'infection agit exactement de la m√™me mani√®re, seulement elle fonctionne via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stream_wrapper_register ()</a> , qui fait la m√™me chose, mais au niveau du syst√®me.  Par cons√©quent, SoftMocks ou Infection peuvent fonctionner pour nous.  Les SoftMocks √©tant n√©cessaires √† nos tests, il est tr√®s difficile de se faire des amis avec ces deux outils.  C'est probablement possible, mais dans ce cas, nous entrons tellement dans l'infection que la signification de ces changements est tout simplement perdue. <br><br>  Surmontant les difficult√©s, nous avons √©crit notre petit instrument.  Nous avons emprunt√© des op√©rateurs de mutation √† Infection (ils sont bien √©crits et tr√®s faciles √† utiliser).  Au lieu de d√©marrer des mutations via stream_wrapper_register (), nous les ex√©cutons via SoftMocks, c'est-√†-dire que nous utilisons notre outil de la bo√Æte.  Notre toolza est ami avec notre service de couverture de code interne.  Autrement dit, √† la demande, il peut recevoir la couverture d'un fichier ou d'une ligne sans ex√©cuter tous les tests, ce qui se produit tr√®s rapidement.  Mais c'est simple.  Si Infection poss√®de un tas d'outils et de fonctionnalit√©s de toutes sortes (par exemple, le lancement dans plusieurs threads), alors le n√¥tre ne l'est pas.  Mais nous utilisons notre infrastructure interne pour compenser cette lacune.  Par exemple, nous ex√©cutons la m√™me ex√©cution de test dans plusieurs threads via notre cloud. <br><br>  Comment utilisons-nous cela? <br><br>  La premi√®re est une ex√©cution manuelle.  C'est la premi√®re chose √† faire.  Tous les tests que vous √©crivez sont v√©rifi√©s manuellement par des tests de mutation.  Cela ressemble √† ceci: <br><br><img src="https://habrastorage.org/webt/-5/xc/t1/-5xct1pygkkjfkxsvr8rhcf-rpc.png"><br><br>  J'ai ex√©cut√© un test de mutation pour un fichier.  J'ai obtenu le r√©sultat: 16 mutants.  Parmi ceux-ci, 15 ont √©t√© tu√©s par des tests, et un est tomb√© avec une erreur.  Je n'ai pas dit que les mutations peuvent g√©n√©rer des d√©c√®s.  Nous pouvons facilement changer quelque chose: rendre le type de retour invalide, ou autre chose.  C'est possible, il est consid√©r√© comme un mutant tu√©, car notre test commencera √† tomber. <br><br>  N√©anmoins, Infection distingue ces mutants dans une cat√©gorie distincte pour la raison qu'il vaut parfois la peine d'accorder une attention particuli√®re aux erreurs.  Il arrive que quelque chose d'√©trange se produise - et le mutant n'est pas correctement consid√©r√© comme tu√©. <br><br>  La deuxi√®me chose que nous utilisons est le rapport sur le ma√Ætre.  Une fois par jour, la nuit, lorsque notre infrastructure de d√©veloppement est inactive, nous g√©n√©rons un rapport de couverture de code.  Apr√®s cela, nous faisons le m√™me rapport de test de mutation.  Cela ressemble √† ceci: <br><br><img src="https://habrastorage.org/webt/gf/br/oc/gfbroc92o5cn5xe7a1q3fmwcofm.png"><br><br>  Si vous avez d√©j√† regard√© le rapport sur la couverture du code de PHPUnit, vous avez probablement remarqu√© que l'interface est similaire, car nous avons fait notre outil par analogie.  Il a simplement calcul√© tous les indicateurs cl√©s d'un fichier particulier dans un r√©pertoire.  Nous avons √©galement d√©fini certains objectifs (en fait, nous les avons pris du plafond et ne nous conformons pas encore, car nous n'avons pas encore d√©cid√© quels objectifs devraient √™tre guid√©s par chaque m√©trique, mais ils existent de sorte qu'il est facile de cr√©er des rapports √† l'avenir). <br><br>  Et la derni√®re chose, la plus importante, qui est une cons√©quence des deux autres.  Les programmeurs sont des gens paresseux.  Je suis paresseux: j'aime que tout fonctionne et je n'ai pas √† faire de gestes suppl√©mentaires.  Nous avons fait en sorte que lorsqu'un d√©veloppeur pousse sa propre branche, les indicateurs de sa branche et de son ma√Ætre de brunch soient automatiquement compt√©s de mani√®re incr√©mentielle. <br><br><img src="https://habrastorage.org/webt/k2/i6/mu/k2i6murvfrlvwfjx-fklewrj2so.png"><br><br>  Par exemple, j'ai ex√©cut√© deux fichiers et obtenu ce r√©sultat.  Dans le ma√Ætre j'avais 548 mutants, 400 ont √©t√© tu√©s. Selon un autre dossier - 147 contre 63. Dans ma branche, le nombre de mutants dans les deux cas a augment√©.  Mais dans le premier dossier, le mutant a √©t√© clou√©, et dans le second, il s'est √©chapp√©.  Naturellement, l'indicateur MSI a chut√©.  Une telle chose permet m√™me aux personnes qui ne veulent pas perdre de temps d'ex√©cuter des tests mutationnels avec leurs mains, de voir ce qu'elles ont fait de pire et d'y pr√™ter attention (exactement de la m√™me mani√®re que les examinateurs le font dans le processus de r√©vision du code). <br><br><h2>  R√©sultats </h2><br>  Il est encore difficile de donner des chiffres: nous n'avions aucun indicateur, maintenant il est apparu, mais il n'y a rien √† comparer. <br><br>  Je peux dire que le test mutationnel donne en termes d'effet psychologique.  Si vous commencez √† ex√©cuter vos tests par le biais de tests de mutation, vous commencez involontairement √† √©crire de meilleurs tests, et l'√©criture de tests de qualit√© conduit in√©vitablement √† un changement dans la fa√ßon dont vous √©crivez du code - vous commencez √† penser que vous devez couvrir tous les cas que vous pouvez casser, vous le lancez meilleure structure, le rendre plus testable. <br><br>  Il s'agit d'une opinion exclusivement subjective.  Mais certains de mes coll√®gues ont donn√© √† peu pr√®s les m√™mes commentaires: lorsqu'ils ont commenc√© √† utiliser constamment les tests mutationnels dans leur travail, ils ont commenc√© √† mieux √©crire les tests, et beaucoup ont dit qu'ils ont commenc√© √† mieux √©crire le code. <br><br><h2>  Conclusions </h2><br>  La couverture du code est une mesure importante qui doit √™tre surveill√©e.  Mais cet indicateur ne garantit rien: cela ne signifie pas que vous √™tes en s√©curit√©. <br><br>  Les tests de mutation peuvent aider √† am√©liorer vos tests unitaires, et le suivi de la couverture du code est logique.  Il existe d√©j√† un outil pour PHP, donc si vous avez un petit projet sans probl√®mes, alors saisissez et essayez aujourd'hui. <br><br>  Commencez au moins en ex√©cutant un test de mutation manuellement.  Faites cette simple √©tape et voyez ce que cela vous apporte.  Je suis s√ªr que vous l'aimerez. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462709/">https://habr.com/ru/post/fr462709/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462699/index.html">Maillage de service, ¬´Plan de donn√©es¬ª et ¬´Plan de contr√¥le¬ª (Plan de donn√©es de maillage de service par rapport au plan de contr√¥le)</a></li>
<li><a href="../fr462701/index.html">Biblioth√®que de g√©n√©rateur de code assembleur pour microcontr√¥leurs AVR. 2e partie</a></li>
<li><a href="../fr462703/index.html">Le tourniquet ¬´le moins cher¬ª de Russie contr√¥l√© depuis un smartphone</a></li>
<li><a href="../fr462705/index.html">Top 5 des bugs dans mes applications ReactJS</a></li>
<li><a href="../fr462707/index.html">Kubernetes lance les outils de d√©veloppement d'applications</a></li>
<li><a href="../fr462717/index.html">La ru√©e de deux yokozun</a></li>
<li><a href="../fr462723/index.html">Attrapez un chat avec TLA +</a></li>
<li><a href="../fr462725/index.html">Astuce de trigonom√©trie</a></li>
<li><a href="../fr462727/index.html">Digest Joomla pour juin-juillet 2019</a></li>
<li><a href="../fr462729/index.html">Soir√©e de conf√©rence ouverte sur la conception narrative au VSBI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>