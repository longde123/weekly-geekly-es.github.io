<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌁 👃🏾 👩‍👩‍👦‍👦 Panduan untuk audit otomatis kontrak pintar. Bagian 3: Mythril 🐂 💆🏼 👨🏿‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Peringatan 


 Artikel ini bukan peringkat keefektifan analisis otomatis. Saya menerapkannya pada kontrak saya sendiri, dengan sengaja mensintesis kes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panduan untuk audit otomatis kontrak pintar. Bagian 3: Mythril</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442114/"><h2 id="warning">  <strong>Peringatan</strong> </h2><br><p>  Artikel ini bukan peringkat keefektifan analisis otomatis.  Saya menerapkannya pada kontrak saya sendiri, dengan sengaja mensintesis kesalahan, dan mempelajari reaksinya.  Studi semacam itu tidak dapat menjadi dasar untuk menentukan "lebih baik-lebih buruk", karena ini masuk akal untuk melakukan studi buta pada sampel besar kontrak, yang, mengingat sifat berubah-ubah dari perangkat lunak jenis ini, sangat sulit.  Sangat mungkin bahwa kesalahan kecil dalam kontrak dapat menonaktifkan sebagian besar logika penganalisa, dan tanda heuristik sederhana dapat menambahkan sejumlah besar poin ke penganalisis dengan menemukan bug yang tersebar luas yang tidak bisa ditambahkan oleh pesaing.  Kesalahan dalam persiapan dan penyusunan kontrak juga dapat berperan.  Semua perangkat lunak yang dimaksud cukup muda, dan terus dikembangkan, jadi jangan menganggap komentar kritis sebagai masalah yang tidak dapat diperbaiki. </p><br><p> Tujuan artikel ini adalah untuk memberikan pembaca pemahaman tentang bagaimana metode analisis kode bekerja di berbagai analisis dan kemampuan untuk menggunakannya dengan benar, daripada "membuat pilihan."  Pilihan yang masuk akal adalah menggunakan beberapa alat sekaligus, dengan fokus pada yang paling cocok untuk kontrak yang dianalisis. </p><a name="habracut"></a><br><h2 id="nastroyka-i-podgotovka-k-zapusku">  <strong>Pengaturan dan persiapan untuk peluncuran</strong> </h2><br><p>  Mythril menggunakan beberapa jenis analisis sekaligus, berikut adalah beberapa artikel bagus tentangnya: yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paling penting</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> .  Sebelum melanjutkan, masuk akal untuk membacanya. </p><br><p>  Pertama, mari kita buat gambar Docker kita sendiri tentang Mythril (tidak masalah apa yang ingin kita ubah di dalamnya?): </p><br><pre><code class="plaintext hljs">git clone https://github.com/ConsenSys/mythril-classic.git cd mythril-classic docker build -t myth .</code> </pre> <br><p>  Sekarang coba jalankan di <code>contracts/flattened.sol</code> kami <code>contracts/flattened.sol</code> (saya menggunakan kontrak yang sama yang telah dibahas dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pendahuluan</a> ), di mana ada dua kontrak utama, <code>Ownable</code> dari Zeppelin dan <code>Booking</code> kami.  Kami masih memiliki masalah dengan versi kompiler, saya memperbaikinya dengan cara yang sama seperti pada artikel sebelumnya, menambahkan baris ke Dockerfile yang akan menggantikan versi kompiler: </p><br><pre> <code class="plaintext hljs">COPY --from=ethereum/solc:0.4.20 /usr/bin/solc /usr/bin</code> </pre> <br><p>  Setelah membangun kembali gambar, Anda dapat mencoba menjalankan analisis kontrak.  Segera mari kita gunakan <code>-v4</code> dan <code>-v4</code> <code>--verbose-report</code> untuk melihat semua peringatan.  Ayo pergi: </p><br><pre> <code class="plaintext hljs">docker run -v $(pwd):/tmp \ -w /tmp myth:latest \ -v4 \ --verbose-report \ -x contracts/flattened.sol</code> </pre> <br><p>  Di sini kami bekerja dengan kontrak yang rata tanpa ketergantungan.  Untuk menganalisis kontrak <code>Booking.sol</code> terpisah dan untuk membuat Mythril mengambil semua dependensi, Anda dapat menggunakan sesuatu seperti ini: </p><br><pre> <code class="plaintext hljs">docker run -v $(pwd):/tmp \ -w /tmp myth:latest \ --solc-args="--allow-paths /tmp/node_modules/zeppelin-solidity/ zeppelin-solidity=/tmp/node_modules/zeppelin-solidity" \ -v4 \ --verbose-report \ -x contracts/Booking.sol</code> </pre> <br><p>  Saya lebih suka bekerja dengan opsi yang diratakan, seperti  kami akan banyak memodifikasi kode.  Tapi Mythril juga memiliki mode yang sangat nyaman <code>--truffle</code> , yang hanya <code>--truffle</code> segala sesuatu yang <code>truffle</code> , memeriksa seluruh proyek untuk kerentanan.  Fitur penting lainnya adalah kemampuan untuk menentukan nama kontrak yang akan dianalisis melalui titik dua, jika tidak Mythril akan menganalisis semua kontrak yang dihadapinya.  Kami percaya bahwa <code>Ownable</code> 's Ownable adalah kontrak yang aman, dan kami hanya akan menganalisis <code>Booking</code> , jadi baris terakhir yang harus dijalankan adalah: </p><br><pre> <code class="plaintext hljs">docker run -v $(pwd):/tmp -w /tmp myth:latest -x contracts/flattened.sol:Booking -v4 --verbose-report</code> </pre> <br><h2 id="zapusk-i-deploy-kontrakta">  <strong>Mulai dan Sebarkan Kontrak</strong> </h2><br><p>  Kami memulai penganalisa dengan baris di atas, lihat output, dan kami mendapatkan, antara lain, baris ini: </p><br><pre> <code class="plaintext hljs">mythril.laser.ethereum.svm [WARNING]: No contract was created during the execution of contract creation Increase the resources for creation execution (--max-depth or --create-timeout) The analysis was completed successfully. No issues were detected.</code> </pre> <br><p>  Ternyata kontrak kami tidak dibuat dan "diperbaiki" di emulator.  Itulah sebabnya saya merekomendasikan menggunakan flag <code>-v4</code> untuk semua jenis analisis untuk melihat semua pesan dan tidak ketinggalan satu pun yang penting.  Mari kita cari tahu apa yang salah.  Solusi untuk masalah praktis ini cukup penting untuk memahami cara menggunakan Mythril dengan benar. </p><br><p>  Jadi, kita membaca tentang Mythril: <code>It uses concolic analysis, taint analysis and control flow checking to detect a variety of security vulnerabilities</code> .  Jika Anda tidak terlalu mengenal istilah-istilah ini, saya merekomendasikan wiki tentang pengujian concolic di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , tetapi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini ada</a> presentasi yang bagus tentang pengecekan noda untuk x86.  Singkatnya: Mythril mengemulasi pelaksanaan kontrak, memperbaiki cabang-cabang di mana eksekusi bisa berjalan dan mencoba untuk mencapai kondisi "rusak" kontrak, memilah-milah berbagai kombinasi parameter dan mencoba untuk mengatasi semua jalur yang mungkin.  Berikut ini contoh diagram tindakan dari artikel di atas: </p><br><pre> <code class="plaintext hljs">1.      .   symbolic-,        . 2.      ,     ,   trace .    ,      ,    . 3.     . 4.       trace-. 5.  symbolic execution   trace,   symbolic ,    ,     ,     . 6.     ,          .    , . 7.   :   ,   ,   input-,     ,      .   input-   ,   .6    . 8.   .4</code> </pre> <br><p>  Jika Anda sangat menyederhanakannya, maka Mythril, setelah menemukan cabang dalam kode, dapat memahami di bawah set variabel mana dimungkinkan untuk masuk ke satu dan cabang lainnya.  Di setiap cabang, Mythril tahu apakah itu mengarah ke <code>assert</code> , <code>transfer</code> , <code>selfdestruct</code> dan opcode yang relevan dengan keamanan lainnya.  Oleh karena itu, Mythril menganalisis set parameter dan transaksi mana yang dapat menyebabkan pelanggaran keamanan.  Dan cara Mythril memotong cabang yang tidak pernah mendapatkan kontrol dan menganalisis aliran kontrol adalah trik utamanya.  Rincian lebih lanjut tentang usus Mythril dan jalan cabang ditulis di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Karena determinisme pelaksanaan kontrak pintar, urutan instruksi yang sama selalu mengarah ketat ke satu set perubahan dalam keadaan, terlepas dari platform, arsitektur, atau lingkungan.  Juga, fungsi dalam kontrak pintar agak pendek, dan sumber dayanya sangat terbatas, oleh karena itu analis seperti Mythril, menggabungkan eksekusi simbolis dan asli, dapat bekerja sangat efisien untuk kontrak pintar. </p><br><p>  Dalam prosesnya, Mythril menggunakan konsep "negara" - ini adalah kode kontrak, lingkungannya, penunjuk ke perintah saat ini, penyimpanan kontrak, dan status tumpukan.  Berikut dokumentasinya: </p><br><pre> <code class="plaintext hljs">The machine state μ is defined as the tuple (g, pc, m, i, s) which are the gas available, the program counter pc ∈ P256, the memory contents, the active number of words in memory (counting continuously from position 0), and the stack contents. The memory contents μm are a series of zeroes of size 256.</code> </pre> <br><p>  Grafik transisi antar negara adalah objek utama penelitian.  Jika berhasil meluncurkan analisis, informasi tentang grafik ini ditampilkan dalam log analisis.  Juga, Mythril dapat membuat grafik ini dalam bentuk yang dapat dibaca manusia menggunakan opsi <code>--graph</code> . </p><br><p>  Sekarang kurang lebih memahami apa yang akan dilakukan Mythril, kami akan terus memahami mengapa kontrak tidak diuraikan dan dari mana <code>[WARNING]: No contract was created during the execution of contract creation</code> .  Untuk memulai, saya memutar opsi <code>--create-timeout</code> dan <code>--max-depth</code> (seperti yang disarankan) dan, tidak mendapatkan hasilnya, saya pikir konstruktor yang harus disalahkan - sesuatu di dalamnya tidak berfungsi.  Ini kodenya: </p><br><pre> <code class="plaintext hljs">function Booking( string _description, string _fileUrl, bytes32 _fileHash, uint256 _price, uint256 _cancellationFee, uint256 _rentDateStart, uint256 _rentDateEnd, uint256 _noCancelPeriod, uint256 _acceptObjectPeriod ) public payable { require(_price &gt; 0); require(_price &gt; _cancellationFee); require(_rentDateStart &gt; getCurrentTime()); require(_rentDateEnd &gt; _rentDateStart); require(_rentDateStart+_acceptObjectPeriod &lt; _rentDateEnd); require(_rentDateStart &gt; _noCancelPeriod); m_description = _description; m_fileUrl = _fileUrl; m_fileHash = _fileHash; m_price = _price; m_cancellationFee = _cancellationFee; m_rentDateStart = _rentDateStart; m_rentDateEnd = _rentDateEnd; m_noCancelPeriod = _noCancelPeriod; m_acceptObjectPeriod = _acceptObjectPeriod; }</code> </pre> <br><p>  Ingat algoritma tindakan Mythril.  Untuk menjalankan penelusuran, Anda perlu memanggil konstruktor kontrak, karena semua eksekusi selanjutnya akan bergantung pada parameter apa yang dipanggil dengan konstruktor.  Sebagai contoh, jika Anda memanggil konstruktor dengan <code>_price == 0</code> , konstruktor akan mengeluarkan pengecualian saat <code>require(_price &gt; 0)</code> .  Bahkan jika Mythril mengulangi banyak nilai <code>_price</code> , konstruktor akan tetap rusak jika, misalnya, <code>_price &lt;= _cancellationFee</code> .  Dalam kontrak ini, ada selusin parameter yang terkait dengan pembatasan ketat, dan Mythril, tentu saja, tidak dapat menebak kombinasi parameter yang valid.  Dia mencoba untuk pergi ke cabang eksekusi berikutnya, memilah-milah parameter konstruktor, tetapi dia praktis tidak punya kesempatan untuk menebak - ada terlalu banyak kombinasi parameter.  Oleh karena itu, perhitungan kontrak tidak berhasil - semua cara bertumpu pada beberapa jenis persyaratan <code>require(...)</code> , dan kami mendapatkan masalah di atas. </p><br><p>  Sekarang kita memiliki dua cara: yang pertama adalah untuk menonaktifkan semua yang <code>require</code> dalam konstruktor dengan berkomentar.  Kemudian Mythril akan dapat memanggil konstruktor dengan set parameter dan semuanya akan berfungsi.  Tetapi ini berarti bahwa dengan memeriksa kontrak dengan parameter seperti itu, Mythril akan menemukan kesalahan yang mungkin terjadi dengan nilai yang salah diteruskan ke konstruktor.  Sederhananya, jika Mythril menemukan bug yang muncul jika pembuat kontrak menentukan <code>_cancellationFee</code> satu miliar kali harga sewa <code>_mprice</code> , maka tidak ada gunanya bug semacam itu - kontrak seperti itu tidak akan pernah diblokir, dan sumber daya untuk menemukan kesalahan akan dihabiskan.  Kami menyiratkan bahwa kontrak masih terjebak dengan parameter yang kurang lebih konsisten, sehingga untuk analisis lebih lanjut masuk akal untuk menentukan parameter konstruktor yang lebih realistis sehingga Mythril tidak mencari kesalahan yang tidak akan pernah terjadi jika kontrak ditutup dengan benar. </p><br><p>  Saya menghabiskan waktu berjam-jam untuk mencoba memahami dengan tepat di mana penempatan rusak, termasuk dan menonaktifkan berbagai bagian konstruktor.  Selain masalah saya, konstruktor menggunakan <code>getCurrentTime()</code> , yang mengembalikan waktu saat ini, dan tidak jelas bagaimana panggilan ini menangani Mythril.  Saya tidak akan menggambarkan petualangan ini di sini, karena  kemungkinan besar dengan penggunaan reguler, kehalusan ini akan diketahui oleh auditor.  Oleh karena itu, saya memilih cara kedua: untuk membatasi input data, dan cukup menghapus semua parameter dari konstruktor, bahkan <code>getCurrentTime()</code> , cukup hardcoded parameter yang diperlukan langsung di konstruktor (idealnya, parameter ini harus diperoleh dari pelanggan): </p><br><pre> <code class="plaintext hljs"> function Booking( ) public payable { m_description = "My very long booking text about hotel and beautiful sea view!"; m_fileUrl = "https://ether-airbnb.bam/some-url/"; m_fileHash = 0x1628f3170cc16d40aad2e8fa1ab084f542fcb12e75ce1add62891dd75ba1ffd7; m_price = 1000000000000000000; // 1 ETH m_cancellationFee = 100000000000000000; // 0.1 ETH m_rentDateStart = 1550664800 + 3600 * 24; // current time + 1 day m_rentDateEnd = 1550664800 + 3600 * 24 * 4; // current time + 4 days m_acceptObjectPeriod = 3600 * 8; // 8 hours m_noCancelPeriod = 3600 * 24; // 1 day require(m_price &gt; 0); require(m_price &gt; m_cancellationFee); require(m_rentDateStart &gt; 1550664800); require(m_rentDateEnd &gt; m_rentDateStart); require((m_rentDateStart + m_acceptObjectPeriod) &lt; m_rentDateEnd); require(m_rentDateStart &gt; m_noCancelPeriod); }</code> </pre> <br><p>  Plus, untuk memulai semuanya, Anda juga harus mengatur parameter <code>max-depth</code> .  Ini bekerja untuk saya dengan konstruktor ini dengan <code>--max-depth=34</code> pada instance AWS t2.medium.  Pada saat yang sama, di laptop saya, yang lebih kuat, semuanya dimulai tanpa <code>max-depth</code> .  Menilai dengan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">parameter</a> ini, perlu untuk membangun cabang untuk analisis, dan nilai standarnya adalah tak terhingga ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode</a> ).  Oleh karena itu, putar-putar parameter ini, tetapi pastikan bahwa kontrak yang diinginkan dianalisis.  Anda dapat memahami ini dengan pesan seperti: </p><br><pre> <code class="plaintext hljs">mythril.laser.ethereum.svm [INFO]: 248 nodes, 247 edges, 2510 total states mythril.laser.ethereum.svm [INFO]: Achieved 59.86% coverage for code: .............</code> </pre> <br><p>  Baris pertama hanya menggambarkan grafik yang akan dianalisis, bacalah sisa baris itu sendiri.  Sumber daya komputasi yang serius diperlukan untuk menganalisis berbagai cabang yang dapat dieksekusi, jadi ketika menganalisis kontrak besar, Anda harus menunggu bahkan di komputer yang cepat. </p><br><h2 id="poisk-oshibok">  <strong>Cari kesalahan</strong> </h2><br><p>  Sekarang kita akan mencari kesalahan dan menambahkan kesalahan kita sendiri.  Mythril mencari cabang di mana penyiaran, penghancuran diri sendiri, penegasan, dan tindakan lain yang penting dari sudut pandang keamanan terjadi.  Jika salah satu dari instruksi di atas ditemukan di suatu tempat dalam kode kontrak, Mythril mempelajari cara-cara yang memungkinkan untuk datang ke cabang ini dan, terlebih lagi, menampilkan urutan transaksi yang mengarah ke cabang ini! </p><br><p>  Pertama, mari kita lihat apa yang dikeluarkan Mythril untuk kontrak <code>Booking</code> lama menderita.  Peringatan pertama: </p><br><pre> <code class="plaintext hljs">==== Dependence on predictable environment variable ==== SWC ID: 116 Severity: Low Contract: Booking Function name: fallback PC address: 566 Estimated Gas Usage: 17908 - 61696 Sending of Ether depends on a predictable variable. The contract sends Ether depending on the values of the following variables: - block.timestamp Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and/or can be manipulated by a malicious miner. Don't use them for random number generation or to make critical decisions. -------------------- In file: contracts/flattened.sol:142 msg.sender.transfer(msg.value-m_price)</code> </pre> <br><p>  dan itu muncul karena </p><br><pre> <code class="plaintext hljs">require(m_rentDateStart &gt; getCurrentTime());</code> </pre> <br><p>  dalam fungsi mundur. </p><br><p>  Perhatikan bahwa Mythril menyadari bahwa <code>getCurrentTime()</code> bersembunyi di <code>getCurrentTime()</code> .  Terlepas dari kenyataan bahwa makna kontrak bukanlah kesalahan, fakta bahwa Mythril mengaitkan <code>block.timestamp</code> dengan siaran sangat bagus!  Dalam hal ini, programmer harus memahami bahwa keputusan dibuat berdasarkan nilai yang dapat dikendalikan oleh penambang.  Dan, jika di masa depan suatu pelelangan atau pelelangan lain untuk suatu layanan muncul di tempat kontrak ini, seseorang harus memperhitungkan kemungkinan serangan-serangan yang sedang berlangsung. </p><br><p>  Mari kita lihat apakah Mythril melihat ketergantungan pada <code>block.timestamp</code> jika kita menyembunyikan variabel dalam panggilan bersarang seperti ini: </p><br><pre> <code class="plaintext hljs">function getCurrentTime() public view returns (uint256) { - return now; + return getCurrentTimeInner(); } + function getCurrentTimeInner() internal returns (uint256) { + return now; + }</code> </pre> <br><p>  Dan ya!  Mythril terus melihat hubungan antara block.timestamp dan transfer siaran, ini sangat penting bagi auditor.  Koneksi antara variabel yang dikendalikan oleh penyerang dan keputusan yang dibuat setelah beberapa perubahan dalam status kontrak bisa sangat tertutup oleh logika, dan Mythril memungkinkan Anda untuk melacaknya.  Meskipun tidak layak mengandalkan kenyataan bahwa semua koneksi yang mungkin di antara semua variabel yang mungkin akan <code>getCurrentTime()</code> untuk Anda: jika Anda terus mengolok-olok fungsi <code>getCurrentTime()</code> dan membuat kedalaman bersarang tiga kali lipat, peringatan itu menghilang.  Setiap panggilan fungsi untuk Mythril membutuhkan penciptaan cabang negara baru, jadi menganalisis tingkat sarang yang sangat dalam akan membutuhkan sumber daya yang besar. </p><br><p>  Tentu saja, ada peluang yang agak serius bahwa saya hanya salah menggunakan parameter analisis atau cutoff terjadi di suatu tempat di kedalaman alat analisis.  Seperti yang saya katakan, produk sedang dalam pengembangan aktif, tepat pada saat penulisan, saya melihat komitmen dalam repositori dengan menyebutkan <code>max-depth</code> , jadi jangan menganggap serius masalah saat ini, kami telah menemukan cukup bukti bahwa Mythril dapat dengan sangat efektif mencari koneksi implisit antara variabel. </p><br><p>  Pertama, tambahkan ke kontrak fungsi yang memberikan siaran kepada siapa pun, tetapi hanya setelah klien mengirim siaran ke kontrak.  Kami mengizinkan siapa pun untuk mengambil 1/5 eter, tetapi hanya ketika kontraknya dalam status <code>State.PAID</code> (yaitu hanya setelah klien membayar nomor sewaan dengan eter).  Inilah fungsinya: </p><br><pre> <code class="plaintext hljs">function collectTaxes() external onlyState(State.PAID) { msg.sender.transfer(address(this).balance / 5); }</code> </pre> <br><p>  Mythril menemukan masalahnya: </p><br><pre> <code class="plaintext hljs">==== Unprotected Ether Withdrawal ==== SWC ID: 105 Severity: High Contract: Booking Function name: collectTaxes() PC address: 2492 Estimated Gas Usage: 2135 - 2746 Anyone can withdraw ETH from the contract account. Arbitrary senders other than the contract creator can withdraw ETH from the contract account without previously having sent a equivalent amount of ETH to it. This is likely to be a vulnerability. -------------------- In file: contracts/flattened.sol:149 msg.sender.transfer(address(this).balance / 5) -------------------- -------------------- Transaction Sequence: { "2": { "calldata": "0x", "call_value": "0xde0b6b3a7640000", "caller": "0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef" }, "3": { "calldata": "0x01b613a5", "call_value": "0x0", "caller": "0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef" } }</code> </pre> <br><p>  Hebat, yaitu  Mythril bahkan mengeluarkan dua transaksi, yang mengarah pada fakta bahwa Anda dapat mengambil eter dari kontrak.  Sekarang ubah persyaratan <code>State.RENT</code> ke <code>State.RENT</code> , seperti ini: </p><br><pre> <code class="plaintext hljs">- function collectTaxes() external onlyState(State.PAID){ + function collectTaxes() external onlyState(State.RENT) {</code> </pre> <br><p>  Sekarang <code>collectTaxes()</code> dapat dipanggil hanya ketika kontrak ada di Negara. <code>State.RENT</code> negara, dan pada saat ini tidak ada pada keseimbangan, karena  kontrak telah mengirimkan seluruh siaran kepada pemilik.  Dan yang penting di sini adalah bahwa Mythril kali ini <strong>TIDAK</strong> menghasilkan kesalahan <code>==== Unprotected Ether Withdrawal ====</code> !  Di bawah kondisi <code>onlyState(State.RENT)</code> , penganalisis tidak sampai ke cabang kode yang mengirim eter dari kontrak dengan saldo tidak nol.  Mythril pergi melalui opsi yang berbeda untuk parameter, tetapi Anda dapat masuk ke <code>State.RENT</code> hanya dengan mengirim semua siaran ke lessor.  Oleh karena itu, mustahil untuk mencapai cabang kode ini dengan saldo tidak nol, dan Mythril sama sekali tidak mengganggu auditor! </p><br><p>  Dengan cara yang sama, Mythril akan menemukan <code>selfdestruct</code> dan <code>assert</code> , menunjukkan kepada auditor tindakan apa yang dapat menyebabkan penghancuran kontrak atau rusaknya fungsi yang penting.  Saya tidak akan memberikan contoh-contoh ini, hanya mencoba membuat fungsi yang mirip dengan yang di atas, hanya memanggil <code>selfdestruct</code> , dan memutar logikanya. </p><br><p>  Juga, jangan lupa bahwa salah satu bagian dari Mythril adalah eksekusi simbolis, dan pendekatan ini, dengan sendirinya, tanpa meniru eksekusi, dapat menentukan banyak kerentanan.  Misalnya, setiap penggunaan "+", "-" dan operator aritmatika lainnya dapat dianggap sebagai kerentanan "Integer overflow" jika salah satu operan dikendalikan oleh penyerang.  Tapi saya ulangi lagi, fitur Mythril yang paling kuat adalah kombinasi eksekusi simbolis dan asli dan penentuan nilai parameter yang mengarah ke branching logika. </p><br><h2 id="zaklyuchenie">  <strong>Kesimpulan</strong> </h2><br><p>  Tentu saja, untuk menunjukkan berbagai potensi masalah yang mampu dideteksi oleh Mythril, dibutuhkan bukan hanya satu, tetapi beberapa artikel.  Untuk yang lainnya, dia tahu bagaimana melakukan semuanya dalam blockchain nyata, menemukan kontrak dan kerentanan yang diperlukan dengan tanda tangan, membuat grafik panggilan yang indah, memformat laporan.  Mythril juga memungkinkan Anda untuk menulis skrip pengujian Anda sendiri, menyediakan antarmuka berbasis python untuk kontrak dan memungkinkan Anda untuk menguji fungsi individu, memperbaiki nilai parameter, atau bahkan menerapkan strategi Anda sendiri untuk bekerja dengan kode yang dibongkar dengan tingkat fleksibilitas yang sewenang-wenang. </p><br><p>  Mythril masih merupakan perangkat lunak yang cukup muda, ini bukan IDA Pro, dan ada sangat sedikit dokumentasi kecuali beberapa artikel.  Nilai banyak parameter hanya dapat dibaca dalam kode Mythril, dimulai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cli.py.</a>  Saya harap penjelasan lengkap dan mendalam tentang operasi setiap parameter muncul dalam dokumentasi. </p><br><p>  Selain itu, ketika kontrak lebih atau kurang besar, output dari banyak kesalahan memakan banyak ruang, tetapi saya ingin dapat menerima informasi terkompresi tentang kesalahan yang ditemukan, karena  ketika bekerja dengan Mythril, Anda harus melihat jalur analisis, melihat kontrak mana yang telah diuji sebaik kemampuan Anda, dan dapat secara paksa menonaktifkan kesalahan spesifik yang menurut auditor palsu-positif. </p><br><p>  Tetapi secara umum, Mythril adalah alat yang sangat baik dan sangat kuat untuk menganalisis kontrak pintar dan saat ini harus menjadi gudang dari setiap auditor.  Ini memungkinkan Anda untuk setidaknya memperhatikan bagian-bagian penting dari kode dan mendeteksi hubungan tersembunyi antar variabel. </p><br><p>  Untuk meringkas, rekomendasi untuk menggunakan Mythril adalah: </p><br><ol><li>  Persempit kondisi awal kontrak yang diteliti sebanyak mungkin.  Jika selama analisis Mythril akan menghabiskan banyak sumber daya pada cabang yang tidak akan pernah diimplementasikan dalam praktik, itu akan kehilangan kemampuan untuk menemukan bug yang sangat penting, jadi Anda harus selalu mencoba mempersempit area cabang potensial. </li><li>  Pastikan analisis kontrak telah dimulai, jangan lewatkan pesan seperti <code>mythril.laser.ethereum.svm [WARNING]: No contract was created during the execution of contract creation Increase the resources for creation execution (--max-depth or --create-timeout)</code> , jika tidak, Anda mungkin secara keliru menganggap bahwa tidak ada bug. </li><li>  Anda dapat secara acak menonaktifkan cabang dalam kode kontrak, memberikan variasi Mythril lebih sedikit dalam memilih cabang dan menghemat sumber daya.  Cobalah untuk melakukan tanpa batasan pada <code>max-depth</code> , agar tidak "memenggal" analisis, tetapi hati-hati untuk tidak menutupi kesalahan. </li><li>  Perhatikan setiap peringatan, bahkan komentar ringan terkadang sepadan untuk setidaknya menambahkan komentar pada kode kontrak, membuatnya lebih mudah bagi pengembang lain. </li></ol><br><p>  Pada artikel berikutnya, kita akan berurusan dengan penganalisa Manticore, tetapi di sini adalah daftar isi untuk artikel yang siap atau direncanakan untuk ditulis: </p><br><p>  Bagian 1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendahuluan.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kompilasi, perataan, versi Solidity</a> <br>  Bagian 2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Meluncur</a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian 3. Mythril (artikel ini) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian 4. Manticore (saat menulis) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian 5. Echidna (saat menulis)</font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442114/">https://habr.com/ru/post/id442114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442102/index.html">Untuk pertanyaan tentang baterai</a></li>
<li><a href="../id442104/index.html">Panduan Pengguna Kibana. Visualisasi. Bagian 5</a></li>
<li><a href="../id442108/index.html">Panduan bagi pengembang untuk membuat aplikasi AI</a></li>
<li><a href="../id442110/index.html">Vim Antipatterns</a></li>
<li><a href="../id442112/index.html">Bahasa pemrograman baru secara diam-diam mematikan koneksi kita dengan kenyataan</a></li>
<li><a href="../id442116/index.html">Meningkatkan Fungsi Komponen Bereaksi dengan React.memo ()</a></li>
<li><a href="../id442118/index.html">Kelompok penambangan Coinhive berhenti bekerja</a></li>
<li><a href="../id442120/index.html">Melatih model TensorFlow dengan Layanan Pembelajaran Azure Machine</a></li>
<li><a href="../id442122/index.html">Levelord Muscovite yang sederhana: sebuah wawancara dengan pencipta Duke Nukem</a></li>
<li><a href="../id442124/index.html">Facebook akan memberi pengguna kesempatan untuk membersihkan cerita mereka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>