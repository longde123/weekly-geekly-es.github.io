<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘­ ğŸ•´ğŸ½ ğŸš˜ 5 Perintah Pengembang TypeScript ğŸ‘©ğŸ¼â€ğŸ¤â€ğŸ‘¨ğŸ¾ âœï¸ ğŸ’Ÿ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Semakin banyak proyek dan tim yang menggunakan TypeScript. Namun, hanya menerapkan TypeScript dan memeras yang terbaik adalah hal yang sangat berbeda....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 Perintah Pengembang TypeScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461565/"><p><img src="https://habrastorage.org/webt/mx/7h/yr/mx7hyrh8ms-5uuolkemexd9jkvo.jpeg" alt="gambar"></p><br><p>  Semakin banyak proyek dan tim yang menggunakan TypeScript.  Namun, hanya menerapkan TypeScript dan memeras yang terbaik adalah hal yang sangat berbeda. </p><br><p>  Saya menyajikan kepada Anda daftar praktik terbaik tingkat tinggi untuk menggunakan TypeScript yang akan membantu Anda memaksimalkan bahasa ini. </p><a name="habracut"></a><br><h2 id="ne-lgite">  Jangan berbohong </h2><br><p>  <strong>Jenis adalah kontrak.</strong>  Apa artinya ini?  Ketika Anda mengimplementasikan suatu fungsi, tipenya menjadi janji bagi pengembang lain (atau untuk diri Anda sendiri di masa depan!) Bahwa, ketika dipanggil, fungsi ini akan mengembalikan jenis nilai tertentu. </p><br><p> Dalam contoh berikut, jenis fungsi <code>getUser</code> memastikan bahwa ia mengembalikan objek yang <strong>selalu</strong> memiliki dua properti: <code>name</code> dan <code>age</code> . </p><br><pre> <code class="javascript hljs">interface User { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: string; age: number; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id: number</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  TypeScript adalah bahasa yang sangat fleksibel.  Ini memiliki banyak kompromi yang dirancang untuk memfasilitasi pengenalan bahasa.  Misalnya, ini memungkinkan Anda untuk mengimplementasikan fungsi <code>getUser</code> seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id: number</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> User; }</code> </pre> <br><p>  Jangan lakukan itu!  Ini adalah SALAH.  Dengan membuat kode seperti itu, Anda BERBOHONG ke pengembang lain (yang akan menggunakan fungsi Anda dalam fungsinya).  Mereka berharap objek yang dikembalikan oleh <code>getUser</code> akan selalu memiliki semacam bidang <code>name</code> .  Tapi dia tidak ada di sana!  Selanjutnya, apa yang terjadi ketika kolega Anda menulis <code>getUser(1).name.toString()</code> ?  Anda tahu betul bahwa ... </p><br><p>  Di sini, tentu saja, kebohongan itu tampak jelas.  Namun, bekerja dengan basis kode besar, Anda akan sering menemukan diri Anda dalam situasi di mana nilai yang ingin Anda kembalikan (atau lewati) <em>hampir</em> cocok dengan jenis yang diharapkan.  <strong>Butuh waktu dan usaha untuk menemukan penyebab ketidakcocokan jenis</strong> , dan Anda sedang terburu-buru ... sehingga Anda memutuskan untuk menggunakan pengecoran jenis. </p><br><p>  Namun, dengan melakukan ini, Anda <strong>melanggar kontrak suci</strong> .  Lebih baik mengambil waktu dan memahami mengapa tipe tidak cocok daripada menggunakan tipe casting.  Sangat mungkin bahwa beberapa bug runtime bersembunyi di bawah permukaan. </p><br><p>  <strong>Jangan berbohong.</strong>  <strong>Patuhi kontrak Anda.</strong> </p><br><h2 id="budte-tochny">  Tepatnya </h2><br><p>  <strong>Jenisnya adalah dokumentasi.</strong>  Ketika mendokumentasikan suatu fungsi, tidakkah Anda ingin menyampaikan informasi sebanyak mungkin? </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   function getUser(id) { /* ... */ } //     : name  age function getUser(id) { /* ... */ } //  id       id , //     : name  age. //     undefined. function getUser(id) { /* ... */ }</span></span></code> </pre> <br><p>  Komentar untuk fungsi <code>getUser</code> mana yang <code>getUser</code> Anda sukai?  Semakin banyak Anda tahu bahwa suatu fungsi kembali, semakin baik.  Misalnya, mengetahui bahwa itu dapat kembali <code>undefined</code> , Anda dapat menulis blok <code>if</code> untuk memeriksa apakah objek yang fungsi dikembalikan didefinisikan sebelum meminta properti dari objek ini. </p><br><p>  Hal yang persis sama dengan tipe: semakin akurat suatu tipe dijelaskan, semakin banyak informasi yang disampaikannya. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUserType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id: number</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUserType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id: number</span></span></span><span class="hljs-function">): '</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">standard</span></span></span><span class="hljs-function">' | '</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">premium</span></span></span><span class="hljs-function">' | '</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">admin</span></span></span><span class="hljs-function">' </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  Versi kedua dari fungsi <code>getUserType</code> jauh lebih informatif, dan karenanya pemanggil berada dalam situasi yang jauh lebih nyaman.  Lebih mudah untuk memproses nilai jika Anda <strong>mungkin</strong> tahu (kontrak, ingat?) Bahwa itu akan menjadi salah satu dari tiga baris yang diberikan, dan bukan sembarang garis.  Untuk memulai dengan apa yang Anda ketahui dengan pasti - nilai tidak boleh berupa string kosong. </p><br><p>  Mari kita pertimbangkan contoh yang lebih nyata.  Tipe <code>State</code> menjelaskan status komponen yang meminta beberapa data dari backend.  Apakah tipe ini akurat? </p><br><pre> <code class="javascript hljs">interface State { <span class="hljs-attr"><span class="hljs-attr">isLoading</span></span>: boolean; data?: string[]; errorMessage?: string; }</code> </pre> <br><p>  Klien yang menggunakan tipe ini harus menangani beberapa kombinasi nilai properti negara yang tidak biasa.  Misalnya, sebuah situasi tidak mungkin ketika properti <code>data</code> dan <code>errorMessage</code> secara bersamaan didefinisikan: permintaan data dapat berhasil atau gagal. </p><br><p>  Kami dapat membuat jenis ini jauh lebih akurat dengan bantuan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jenis serikat yang didiskriminasi</a> : </p><br><pre> <code class="javascript hljs">type State = | { <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'loading'</span></span> } | { <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'successful'</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: string[] } | { <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'failed'</span></span>, <span class="hljs-attr"><span class="hljs-attr">errorMessage</span></span>: string };</code> </pre> <br><p>  Sekarang klien yang menggunakan tipe ini memiliki lebih banyak informasi: ia tidak perlu lagi memproses kombinasi properti yang salah. </p><br><p>  <strong>Tepatnya.</strong>  <strong>Berikan informasi sebanyak mungkin pada tipe Anda.</strong> </p><br><h2 id="nachinayte-snbsptipov">  Mulai dengan Jenis </h2><br><p>  Karena tipe merupakan kontrak dan dokumentasi, maka sangat bagus untuk <strong>mendesain</strong> fungsi (atau metode) Anda. </p><br><p>  Ada banyak artikel di Internet yang menyarankan programmer <strong>untuk berpikir sebelum menulis kode</strong> .  Saya sepenuhnya membagikan pendekatan ini.  Godaan untuk melompat langsung ke kode itu bagus, tetapi ini sering mengarah pada keputusan yang buruk.  Sedikit waktu yang dihabiskan untuk memikirkan implementasi selalu terbayar dengan baik. </p><br><p>  Jenis sangat berguna dalam proses ini.  <em>Berpikir</em> mengarah pada penciptaan tanda tangan jenis fungsi yang terkait dengan penyelesaian masalah Anda.  Dan itu hebat, karena Anda fokus pada apa fungsi Anda lakukan, daripada memikirkan <em>bagaimana</em> mereka melakukannya. </p><br><p>  Bereaksi JS memiliki konsep Komponen Pesanan Tinggi (HOC).  Ini adalah fungsi yang memperluas komponen yang diberikan dalam beberapa cara.  Misalnya, Anda dapat membuat komponen orde lebih tinggi <code>withLoadingIndicator</code> yang menambahkan indikator pemuatan ke komponen yang ada. </p><br><p>  Mari kita menulis tanda tangan jenis untuk fungsi ini.  Fungsi menerima input komponen dan mengembalikan komponen juga.  Untuk mewakili suatu komponen, kita dapat menggunakan tipe React <code>ComponentType</code> . </p><br><p>  <code>ComponentType</code> adalah tipe generik yang diparameterisasi oleh tipe properti komponen.  <code>withLoadingIndicator</code> menerima komponen dan mengembalikan komponen baru yang menampilkan komponen asli atau indikator pemuatan.  Keputusan tentang apa yang akan ditampilkan dibuat berdasarkan nilai dari properti logis baru - <code>isLoading</code> .  Dengan demikian, komponen yang dikembalikan membutuhkan properti yang sama dengan yang asli, hanya properti <code>isLoading</code> baru yang ditambahkan. </p><br><p>  Kami akan menyelesaikan jenisnya.  <code>withLoadingIndicator</code> menerima komponen tipe <code>ComponentType&lt;P&gt;</code> , di mana <code>P</code> menunjukkan tipe properti.  <code>withLoadingIndicator</code> mengembalikan komponen dengan properti lanjutan tipe <code>P &amp; { isLoading: boolean }</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> withLoadingIndicator = &lt;P&gt;(Component: ComponentType&lt;P&gt;) : ComponentType&lt;P &amp; { isLoading: boolean }&gt; =&gt; ({ isLoading, ...props }) =&gt; { /* ... */ }</code> </pre> <br><p>  Berhubungan dengan jenis-jenis fungsi, kami terpaksa berpikir tentang apa yang akan ada di inputnya dan apa yang akan di output.  Dengan kata lain, kami harus <em>merancang suatu fungsi</em> .  Menulis implementasinya sekarang mudah. </p><br><p>  <strong>Mulai dengan tipe.</strong>  <strong>Biarkan jenis memaksa Anda untuk merancang terlebih dahulu, dan baru kemudian menulis implementasinya.</strong> </p><br><h2 id="primite-strogost">  Ambil ketegaran </h2><br><p>  Tiga perintah pertama mengharuskan Anda memberi perhatian khusus pada jenis.  Untungnya, ketika menyelesaikan masalah ini, Anda tidak perlu melakukan semuanya sendiri - seringkali kompiler TypeScript akan memberi tahu Anda ketika tipe Anda berbohong atau ketika mereka tidak cukup akurat. </p><br><p>  Anda dapat membantu kompiler melakukan ini dengan lebih baik dengan <code>--strict</code> flag <code>--strict</code> .  Ini adalah meta flag yang <code>--noImplicitAny</code> semua opsi pengecekan tipe ketat: <code>--noImplicitAny</code> , <code>--noImplicitThis</code> , <code>--alwaysStrict</code> , <code>--strictBindCallApply</code> , <code>--strictNullChecks</code> , <code>--strictFunctionTypes</code> dan <code>--strictPropertyInitialization</code> . </p><br><p>  Apa yang dilakukan bendera?  Secara umum, dimasukkannya mereka menyebabkan peningkatan jumlah kesalahan kompilasi TypeScript.  Dan ini bagus!  Lebih banyak kesalahan kompilasi - lebih banyak bantuan dari kompiler. </p><br><p>  Mari kita lihat bagaimana mengaktifkan flag <code>--strictNullChecks</code> membantu mendeteksi kesalahan pada kode. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id: number</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'John'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; } }</code> </pre> <br><p>  Tipe <code>getUser</code> memastikan bahwa fungsi selalu mengembalikan objek tipe <code>User</code> .  Namun, lihat implementasinya: sebuah fungsi juga dapat mengembalikan yang <code>undefined</code> ! </p><br><p>  Untungnya, mengaktifkan flag <code>--strictNullChecks</code> menghasilkan kesalahan kompilasi: </p><br><pre> <code class="plaintext hljs">Type 'undefined' is not assignable to type 'User'.</code> </pre> <br><p>  Compiler TypeScript mendeteksi kepalsuan.  Untuk menghilangkan kesalahan ini, cukup jujur â€‹â€‹untuk mengatakan yang sebenarnya: </p><br><pre> <code class="plaintext hljs">function getUser(id: number): User | undefined { /* ... */ }</code> </pre> <br><p>  <strong>Terima kerasnya pengecekan tipe.</strong>  <strong>Biarkan kompiler melindungi Anda dari kesalahan.</strong> </p><br><h2 id="budte-v-kurse">  Tetap up to date </h2><br><p>  TypeScript berkembang dengan sangat cepat.  Rilis baru dirilis setiap dua bulan.  Setiap rilis membawa peningkatan bahasa yang signifikan dan fitur baru. </p><br><p>  Sering terjadi bahwa fitur-fitur baru dari bahasa memungkinkan Anda untuk menentukan jenis lebih akurat dan memeriksanya lebih ketat. </p><br><p>  Misalnya, dalam versi 2.0 Jenis Diskriminasi diperkenalkan (saya sebutkan dalam perintah, <em>akurat</em> ). </p><br><p>  Versi 3.2 memperkenalkan flag compiler <code>--strictBindCallApply</code> , yang mencakup pengetikan yang benar untuk fungsi <code>bind</code> , <code>call</code> dan <code>apply</code> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Versi 3.4 meningkatkan inferensi tipe dalam fungsi tingkat tinggi</a> , yang membuatnya lebih mudah untuk menggunakan tipe yang tepat saat menulis kode dalam gaya fungsional. </p><br><p>  Posisi saya adalah bahwa mengenal fitur-fitur bahasa yang diperkenalkan dalam versi terbaru dari TypeScript sebenarnya sepadan.  Seringkali ini dapat membantu Anda mengikuti empat perintah lainnya dari daftar. </p><br><p>  Titik awal yang baik adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Roadmap TypeScript resmi</a> .  Ini juga akan menyenangkan untuk secara teratur memeriksa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian TypeScript di Microsoft Devblog</a> , karena semua pengumuman rilis ada di sana. </p><br><p>  <strong>Tetap up to date dengan fitur-fitur baru bahasa ini, dan biarkan pengetahuan ini bekerja untuk Anda.</strong> </p><br><h2 id="rezyume">  Ringkasan </h2><br><p>  Saya harap daftar ini bermanfaat.  Seperti biasa dan dalam segala hal, seseorang hendaknya tidak secara membabi buta mengikuti perintah-perintah ini.  Tapi saya sangat percaya bahwa aturan ini akan membuat Anda menjadi pengembang TypeScript yang lebih baik. </p><br><p>  Saya akan senang melihat pendapat Anda tentang hal ini dalam komentar. </p><br><h2 id="bonus">  Bonus </h2><br><p>  Apakah Anda menyukai artikel ini tentang TypeScript?  Saya yakin Anda juga akan menyukai PDF gratis ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">10 Kesalahan pengembangan TypeScript yang membuat kode Anda tidak aman.</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461565/">https://habr.com/ru/post/id461565/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461547/index.html">Sistem Informasi Medis (SIM) sebagai produk</a></li>
<li><a href="../id461553/index.html">Pengalaman dalam mengotomatisasi pengujian visual regresi di Java + Selenium Webdriver + aShot</a></li>
<li><a href="../id461555/index.html">Google Spreadsheets Visualisasi</a></li>
<li><a href="../id461561/index.html">Timer Arduino</a></li>
<li><a href="../id461563/index.html">Lightsaber Laser Vapor Tembaga Buatan Rumah - Bagian 3 Final</a></li>
<li><a href="../id461567/index.html">SQL Teka-teki yang menghibur</a></li>
<li><a href="../id461569/index.html">Catatan untuk front-end: apa yang harus diperiksa sebelum pengujian</a></li>
<li><a href="../id461571/index.html">SVG dalam kehidupan nyata. Laporan Yandex</a></li>
<li><a href="../id461575/index.html">Membuat PBX berbasis cloud 3CX pada sembarang hosting yang kompatibel dengan Openstack</a></li>
<li><a href="../id461577/index.html">Bagian 5/2 Bldg. 1: Persimpangan RocketChip Avenue dan jalur instrumentasi yang licin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>