<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∏ ‚õëÔ∏è üéÉ OpenSceneGraph: Sistem Plugin üÜò üöÅ üÖøÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Di suatu tempat dalam pelajaran sebelumnya, sudah dikatakan bahwa OSG mendukung memuat berbagai jenis sumber daya seperti gambar raster,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Sistem Plugin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438296/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="gambar"><br><h1>  Pendahuluan </h1><br>  Di suatu tempat dalam pelajaran sebelumnya, sudah dikatakan bahwa OSG mendukung memuat berbagai jenis sumber daya seperti gambar raster, model 3D dari berbagai format, atau, misalnya, font melalui sistem plug-in sendiri.  Plugin OSG adalah komponen terpisah yang memperluas fungsi mesin dan memiliki antarmuka standar dalam OSG.  Plugin ini diimplementasikan sebagai pustaka bersama dinamis (dll pada Windows, begitu juga Linux, dll.).  Nama-nama pustaka plugin sesuai dengan konvensi tertentu <br><br><pre><code class="plaintext hljs">osgdb_&lt; &gt;.dll</code> </pre> <br>  artinya, nama plugin selalu berisi awalan osgdb_.  Ekstensi file memberi tahu mesin tentang plug-in mana yang harus digunakan untuk mengunduh file dengan ekstensi ini.  Misalnya, ketika kita menulis fungsi dalam kode <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"cessna.osg"</span></span>);</code> </pre><br>  mesin melihat ekstensi osg dan memuat plugin bernama osgdb_osg.dll (atau osgdb_osg.so dalam kasus Linux).  Kode plugin melakukan semua pekerjaan kotor dengan mengembalikan kita sebuah pointer ke sebuah node yang menggambarkan model cessna.  Demikian pula, mencoba memuat gambar PNG <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg:Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"picture.png"</span></span>);</code> </pre><br>  akan menyebabkan plugin osgdb_png.dll dimuat, yang mengimplementasikan algoritma untuk membaca data dari gambar PNG dan menempatkan data ini dalam objek bertipe osg :: Image. <br><a name="habracut"></a><br>  Semua operasi yang bekerja dengan sumber daya eksternal dilaksanakan oleh fungsi pustaka osgDB, yang dengannya kami selalu menautkan program dari contoh ke contoh.  Perpustakaan ini bergantung pada sistem plugin OSG.  Hingga saat ini, paket OSG mencakup banyak plug-in yang berfungsi dengan sebagian besar format gambar, model 3D, dan font yang digunakan dalam praktiknya.  Plugin menyediakan data membaca (impor) dari format tertentu, dan, dalam kebanyakan kasus, menulis data ke file dengan format yang diperlukan (ekspor).  Utilitas osgconv, khususnya, memungkinkan Anda untuk mengkonversi data dari satu format ke format lainnya, misalnya, sistem plug-in. <br><br><pre> <code class="plaintext hljs">$ osgconv cessna.osg cessna.3ds</code> </pre><br>  dengan mudah dan alami mengubah model cessna osg ke format 3DS, yang kemudian dapat diimpor ke editor 3D, misalnya, ke Blender (omong-omong, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekstensi untuk bekerja dengan osg langsung</a> untuk Blender) <br><br><img src="https://habrastorage.org/webt/vy/dm/qm/vydmqm2a3evtdqxu2vtf_kknmrw.png"><br><br>  Ada daftar resmi plugin OSG standar dengan deskripsi tujuan mereka, tetapi ini panjang dan saya terlalu malas untuk membawanya ke sini.  Lebih mudah untuk melihat jalur instalasi perpustakaan di folder bin / ospPlugins-xyz, di mana x, y, z adalah nomor versi OSG.  Dari nama file plugin, mudah untuk memahami format apa yang diprosesnya. <br><br>  Jika OSG dikompilasi oleh kompiler MinGW, awalan mingw_ tambahan ditambahkan ke nama standar plugin, yaitu, nama akan terlihat seperti ini <br><br><pre> <code class="plaintext hljs">mingw_osgdb_&lt; &gt;.dll</code> </pre><br>  Versi plugin yang dikompilasi dalam konfigurasi DEBUG juga dilengkapi dengan akhiran d di akhir nama, yaitu format akan menjadi <br><br><pre> <code class="plaintext hljs">osgdb_&lt; &gt;d.dll</code> </pre><br>  atau <br><br><pre> <code class="plaintext hljs">mingw_osgdb_&lt; &gt;d.dll</code> </pre><br>  saat merakit MinGW. <br><br><h1>  1. Plugin pseudo-loader </h1><br>  Beberapa plugin OSG menjalankan fungsi yang disebut pseudo-loader - ini berarti bahwa mereka tidak terikat pada ekstensi file tertentu, tetapi dengan menambahkan akhiran ke akhir nama file, Anda dapat menentukan plug-in mana yang harus digunakan untuk mengunduh file ini, misalnya <br><br><pre> <code class="plaintext hljs">$ osgviewer worldmap.shp.ogr</code> </pre><br>  Dalam hal ini, nama asli file pada disk adalah worldmap.shp - file ini menyimpan peta dunia dalam format ESRI shapefile.  Suffix .ogr memberi tahu perpustakaan osgDB untuk menggunakan plugin osgdb_ogr untuk memuat file ini;  jika tidak, plugin osgdb_shp akan digunakan. <br><br>  Contoh bagus lainnya adalah plugin osgdb_ffmpeg.  Pustaka FFmpeg mendukung lebih dari 100 codec yang berbeda.  Untuk membacanya, kita cukup menambahkan suffix .ffmpeg setelah nama file media. <br><br>  Selain itu, beberapa pseudo-loader memungkinkan kita untuk melewati akhiran sejumlah parameter yang mempengaruhi keadaan objek yang dimuat, dan kita sudah menemukan ini dalam contoh dengan animasi <br><br><pre> <code class="cpp hljs">node = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"cessna.osg.0,0,90.rot"</span></span>);</code> </pre><br>  Baris 0.90 menunjukkan ke plugin osgdb_osg parameter orientasi awal model yang dimuat.  Beberapa pseudo-loader membutuhkan parameter yang benar-benar spesifik untuk berfungsi. <br><br><h1>  2. API untuk mengembangkan plugin pihak ketiga </h1><br>  Sangat logis jika, setelah semua pembacaan, Anda memiliki gagasan bahwa mungkin tidak akan sulit untuk menulis plug-in Anda sendiri untuk OSG, yang akan memungkinkan Anda untuk mengimpor format model atau gambar 3D yang tidak standar.  Dan ini adalah pemikiran yang benar!  Mekanisme plugin hanya dirancang untuk memperluas fungsionalitas mesin tanpa mengubah OSG itu sendiri.  Untuk memahami prinsip dasar penulisan plugin, mari kita coba menerapkan contoh sederhana. <br><br>  Pengembangan plugin adalah untuk memperluas antarmuka baca / tulis virtual yang disediakan oleh OSG.  Fungsi ini disediakan oleh kelas virtual osgDB :: ReaderWriter.  Kelas ini menyediakan sejumlah metode virtual yang didefinisikan ulang oleh pengembang plugin. <br><table><thead><tr><th>  Metode </th><th>  Deskripsi </th></tr></thead><tbody><tr><td>  mendukung Ekstensi () </td><td>  Ini menerima dua parameter string: ekstensi file dan deskripsi.  Metode ini selalu disebut dalam konstruktor dari subclass. </td></tr><tr><td>  acceptsExtension () </td><td>  Mengembalikan nilai true jika ekstensi yang diteruskan sebagai argumen didukung oleh plugin </td></tr><tr><td>  fileExists () </td><td>  Memungkinkan Anda menentukan apakah file yang diberikan ada (path dilewatkan sebagai parameter) pada disk (mengembalikan true jika berhasil) </td></tr><tr><td>  readNode () </td><td>  Menerima nama file dan opsi sebagai objek osgDB :: Option.  Fungsi untuk membaca data dari file diimplementasikan oleh pengembang </td></tr><tr><td>  writeNode () </td><td>  Menerima nama simpul, nama file yang diinginkan, dan opsi.  Fungsi penulisan data ke disk diimplementasikan oleh pengembang </td></tr><tr><td>  readImage () </td><td>  Membaca data bitmap disk </td></tr><tr><td>  writeImage () </td><td>  Menulis bitmap ke disk </td></tr></tbody></table><br>  Implementasi metode readNode () dapat dijelaskan dengan kode berikut <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::<span class="hljs-function"><span class="hljs-function">ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         bool recognizableExtension = ...; bool fileExists = ...; if (!recognizableExtension) return ReadResult::FILE_NOT_HANDLED; if (!fileExists) return ReadResult::FILE_NOT_FOUND; //          osg::Node *root = ...; //       -     . //    -      bool errorInParsing = ...; if (errorInParsing) return ReadResult::ERROR_IN_READING_FILE; return root; }</span></span></code> </pre><br>  Agak mengejutkan bahwa alih-alih sebuah penunjuk ke simpul grafik adegan, metode ini mengembalikan tipe osgDB :: ReaderWriter :: ReadResult.  Tipe ini adalah objek hasil baca, dan dapat digunakan sebagai wadah simpul, gambar, pencacah status (misalnya, FILE_NOT_FOUND), objek khusus lain, atau bahkan sebagai string pesan kesalahan.  Ini memiliki banyak konstruktor implisit untuk mengimplementasikan fungsi yang dijelaskan. <br><br>  Kelas bermanfaat lainnya adalah osgDB :: Options.  Itu dapat memungkinkan Anda untuk mengatur atau mendapatkan serangkaian opsi pemuatan menggunakan metode setOptionString () dan getOptionString ().  Melewati string ini ke konstruktor kelas ini sebagai argumen juga diperbolehkan. <br><br>  Pengembang dapat mengontrol perilaku plugin dengan mengatur pengaturan dalam string parameter yang dilewatkan saat memuat objek, misalnya, dengan cara ini <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    osg::Node* node1 = osgDB::readNodeFile("cow.osg"); //     string osg::Node* node2 = osgDB::readNodeFile("cow.osg", new osgDB::Options(string));</span></span></code> </pre><br><h1>  3. Pemrosesan aliran data dalam plugin OSG </h1><br>  Kelas dasar osgDB :: ReaderWriter mencakup serangkaian metode yang memproses data aliran input / output yang disediakan oleh pustaka C ++ standar.  Satu-satunya perbedaan antara metode baca / tulis ini dan yang dibahas di atas adalah bahwa alih-alih nama file, mereka menerima std :: istream &amp; input stream atau std :: ostream &amp; output stream.  Menggunakan file I / O stream selalu lebih baik daripada menggunakan nama file.  Untuk melakukan operasi pembacaan file, kita dapat menggunakan desain antarmuka berikut: <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::<span class="hljs-function"><span class="hljs-function">ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ... osgDB::<span class="hljs-function"><span class="hljs-function">ifstream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file.c_str(), </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ios::binary)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!stream) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReadResult::ERROR_IN_READING_FILE; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> readNode(stream, options); } ... osgDB::ReaderWriter::<span class="hljs-function"><span class="hljs-function">ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp;stream, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         osg::Node *root = ...; return root; }</span></span></code> </pre><br>  Setelah mengimplementasikan plugin, kita dapat menggunakan fungsi standar osgDB :: readNodeFile () dan osgDB :: readImageFile () untuk memuat model dan gambar, cukup dengan menentukan path file.  OSG akan menemukan dan mengunduh plugin yang kami tulis. <br><br><h1>  4. Kami menulis plugin kami sendiri </h1><br><br>  Jadi, tidak ada yang mengganggu kita untuk menghasilkan format kita sendiri untuk menyimpan data pada geometri tiga dimensi, dan kita akan memunculkannya <br><br>  <strong>piramide.pmd</strong> <br><br><pre> <code class="plaintext hljs">vertex: 1.0 1.0 0.0 vertex: 1.0 -1.0 0.0 vertex: -1.0 -1.0 0.0 vertex: -1.0 1.0 0.0 vertex: 0.0 0.0 2.0 face: 0 1 2 3 face: 0 3 4 face: 1 0 4 face: 2 1 4 face: 3 2 4</code> </pre><br>  Di sini, di awal file adalah daftar simpul dengan koordinatnya.  Indeks vertex berjalan berurutan, mulai dari nol.  Setelah daftar simpul muncul daftar wajah.  Setiap wajah ditentukan oleh daftar indeks titik dari mana ia dibentuk.  Ternyata tidak ada yang rumit.  Tugasnya adalah membaca file ini dari disk dan membentuk geometri tiga dimensi atas dasar. <br><br><h1>  5. Pengaturan proyek plugin: membangun fitur skrip </h1><br>  Jika sebelum kita membangun aplikasi, sekarang kita harus menulis perpustakaan yang dinamis, dan bukan hanya perpustakaan, tetapi plug-in OSG yang memenuhi persyaratan tertentu.  Kami akan mulai memenuhi persyaratan ini dengan skrip build proyek yang akan terlihat seperti ini <br><br>  <strong>plugin.pro</strong> <br><br><pre> <code class="cmake hljs">TEMPLATE = lib CONFIG += plugin CONFIG += no_plugin_name_prefix <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = osgdb_pmd win32-g++: <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,mingw_,) win32 { OSG_LIB_DIRECTORY = $$(OSG_BIN_PATH) OSG_INCLUDE_DIRECTORY = $$(OSG_INCLUDE_PATH) DESTDIR = $$(OSG_PLUGINS_PATH) CONFIG(debug, debug|release) { <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,,d) LIBS += -L$$OSG_LIB_DIRECTORY -losgd LIBS += -L$$OSG_LIB_DIRECTORY -losgViewerd LIBS += -L$$OSG_LIB_DIRECTORY -losgDBd LIBS += -L$$OSG_LIB_DIRECTORY -lOpenThreadsd LIBS += -L$$OSG_LIB_DIRECTORY -losgUtild } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LIBS += -L$$OSG_LIB_DIRECTORY -losg LIBS += -L$$OSG_LIB_DIRECTORY -losgViewer LIBS += -L$$OSG_LIB_DIRECTORY -losgDB LIBS += -L$$OSG_LIB_DIRECTORY -lOpenThreads LIBS += -L$$OSG_LIB_DIRECTORY -losgUtil } INCLUDEPATH += $$OSG_INCLUDE_DIRECTORY } unix { DESTDIR = /usr/lib/osgPlugins-<span class="hljs-number"><span class="hljs-number">3.7</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> CONFIG(debug, debug|release) { <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,,d) LIBS += -losgd LIBS += -losgViewerd LIBS += -losgDBd LIBS += -lOpenThreadsd LIBS += -losgUtild } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LIBS += -losg LIBS += -losgViewer LIBS += -losgDB LIBS += -lOpenThreads LIBS += -losgUtil } } INCLUDEPATH += ./<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> HEADERS += $$files(./<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>/*.h) SOURCES += $$files(./src/*.cpp)</code> </pre><br>  Kami akan menganalisis nuansa individual secara lebih rinci <br><br><pre> <code class="cmake hljs">TEMPLATE = lib</code> </pre><br>  berarti kita akan membangun perpustakaan.  Untuk mencegah pembuatan tautan simbolik dengan bantuan masalah konflik versi pustaka yang diselesaikan dalam sistem * nix, kami mengindikasikan ke sistem build bahwa pustaka ini akan menjadi plug-in, artinya, itu akan dimuat ke dalam memori "saat itu juga" <br><br><pre> <code class="cmake hljs">CONFIG += plugin</code> </pre><br>  Selanjutnya, kami mengecualikan pembuatan awalan lib, yang ditambahkan saat menggunakan kompiler keluarga gcc dan diperhitungkan oleh lingkungan runtime saat memuat pustaka <br><br><pre> <code class="cmake hljs">CONFIG += no_plugin_name_prefix</code> </pre><br>  Tetapkan nama file perpustakaan <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = osgdb_pmd</code> </pre><br>  di mana pmd adalah ekstensi file format model 3D yang kami temukan.  Selanjutnya, kita harus menunjukkan bahwa dalam kasus perakitan MinGW, awalan mingw_ perlu ditambahkan ke namanya <br><br><pre> <code class="cmake hljs">win32-g++: <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,mingw_,)</code> </pre><br>  Tentukan jalur pembuatan pustaka: untuk Windows <br><br><pre> <code class="cmake hljs">DESTDIR = $$(OSG_PLUGINS_PATH)</code> </pre><br>  untuk linux <br><br><pre> <code class="cmake hljs">DESTDIR = /usr/lib/osgPlugins-<span class="hljs-number"><span class="hljs-number">3.7</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  Untuk Linux, dengan indikasi jalan (yang tidak diragukan lagi adalah penopang, tapi saya belum menemukan solusi lain), kami memberikan hak untuk menulis ke folder yang ditentukan dengan plugin OSG dari pengguna biasa <br><br><pre> <code class="plaintext hljs"># chmod 666 /usr/lib/osgPlugins-3.7.0</code> </pre><br>  Semua pengaturan build lainnya mirip dengan yang digunakan dalam perakitan aplikasi sampel sebelumnya. <br><br><h1>  6. Pengaturan proyek plugin: fitur mode debug </h1><br>  Karena proyek ini adalah perpustakaan yang dinamis, harus ada program yang memuat perpustakaan ini dalam proses pelaksanaannya.  Ini bisa berupa aplikasi apa pun yang menggunakan OSG dan di mana fungsinya akan dipanggil <br><br><pre> <code class="cpp hljs">node = osdDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"piramide.pmd"</span></span>);</code> </pre><br>  Dalam hal ini, plugin kami akan dimuat.  Agar Anda tidak menulis program semacam itu sendiri, kami akan menggunakan solusi yang sudah jadi - penampil osgviewer standar, yang termasuk dalam paket pengiriman mesin.  Jika di konsol jalankan <br><br><pre> <code class="plaintext hljs">$ osgviewer piramide.pmd</code> </pre><br>  maka itu juga akan memicu plugin.  Dalam pengaturan peluncuran proyek, tentukan path ke osgviewerd, sebagai direktori kerja, tentukan direktori tempat file piramide.pmd berada, dan tentukan file yang sama dalam opsi baris perintah osgviewer <br><br><img src="https://habrastorage.org/webt/v8/9y/xa/v89yxafvygysowtw7aeihf9mgcs.png"><br><br>  Sekarang kita dapat menjalankan plugin dan men-debug-nya langsung dari QtCreator IDE. <br><br><h1>  6. Kami menerapkan kerangka kerja plugin </h1><br>  Contoh ini sampai batas tertentu menggeneralisasikan pengetahuan yang telah kami terima tentang OSG dari pelajaran sebelumnya.  Saat menulis plugin, kita harus <br><br><ol><li>  Pilih struktur data untuk menyimpan informasi geometri model yang dibaca dari file model <br></li><li>  Baca dan parsing (parse) file data model <br></li><li>  Mengkonfigurasi osg :: Drawable geometric object berdasarkan data yang dibaca dari file <br></li><li>  Buat subgraph adegan untuk model yang dimuat <br></li></ol><br>  Jadi, berdasarkan tradisi, saya akan memberikan seluruh kode sumber plugin <br><br><div class="spoiler">  <b class="spoiler_title">Plugin Osgdb_pmd</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgDB/FileNameUtils&gt; #include &lt;osgDB/FileUtils&gt; #include &lt;osgDB/Registry&gt; #include &lt;osgUtil/SmoothingVisitor&gt; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ struct face_t { std::vector&lt;unsigned int&gt; indices; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ struct pmd_mesh_t { osg::ref_ptr&lt;osg::Vec3Array&gt; vertices; osg::ref_ptr&lt;osg::Vec3Array&gt; normals; std::vector&lt;face_t&gt; faces; pmd_mesh_t() : vertices(new osg::Vec3Array) , normals(new osg::Vec3Array) { } osg::Vec3 calcFaceNormal(const face_t &amp;face) const { osg::Vec3 v0 = (*vertices)[face.indices[0]]; osg::Vec3 v1 = (*vertices)[face.indices[1]]; osg::Vec3 v2 = (*vertices)[face.indices[2]]; osg::Vec3 n = (v1 - v0) ^ (v2 - v0); return n * (1 / n.length()); } }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class ReaderWriterPMD : public osgDB::ReaderWriter { public: ReaderWriterPMD(); virtual ReadResult readNode(const std::string &amp;filename, const osgDB::Options *options) const; virtual ReadResult readNode(std::istream &amp;stream, const osgDB::Options *options) const; private: pmd_mesh_t parsePMD(std::istream &amp;stream) const; std::vector&lt;std::string&gt; parseLine(const std::string &amp;line) const; }; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ ReaderWriterPMD::ReaderWriterPMD() { supportsExtension("pmd", "PMD model file"); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( const std::string &amp;filename, const osgDB::Options *options) const { std::string ext = osgDB::getLowerCaseFileExtension(filename); if (!acceptsExtension(ext)) return ReadResult::FILE_NOT_HANDLED; std::string fileName = osgDB::findDataFile(filename, options); if (fileName.empty()) return ReadResult::FILE_NOT_FOUND; std::ifstream stream(fileName.c_str(), std::ios::in); if (!stream) return ReadResult::ERROR_IN_READING_FILE; return readNode(stream, options); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( std::istream &amp;stream, const osgDB::Options *options) const { (void) options; pmd_mesh_t mesh = parsePMD(stream); osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(mesh.vertices.get()); for (size_t i = 0; i &lt; mesh.faces.size(); ++i) { osg::ref_ptr&lt;osg::DrawElementsUInt&gt; polygon = new osg::DrawElementsUInt(osg::PrimitiveSet::POLYGON, 0); for (size_t j = 0; j &lt; mesh.faces[i].indices.size(); ++j) polygon-&gt;push_back(mesh.faces[i].indices[j]); geom-&gt;addPrimitiveSet(polygon.get()); } geom-&gt;setNormalArray(mesh.normals.get()); geom-&gt;setNormalBinding(osg::Geometry::BIND_PER_PRIMITIVE_SET); osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; geode-&gt;addDrawable(geom.get()); return geode.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ pmd_mesh_t ReaderWriterPMD::parsePMD(std::istream &amp;stream) const { pmd_mesh_t mesh; while (!stream.eof()) { std::string line; std::getline(stream, line); std::vector&lt;std::string&gt; tokens = parseLine(line); if (tokens[0] == "vertex") { osg::Vec3 point; std::istringstream iss(tokens[1]); iss &gt;&gt; point.x() &gt;&gt; point.y() &gt;&gt; point.z(); mesh.vertices-&gt;push_back(point); } if (tokens[0] == "face") { unsigned int idx = 0; std::istringstream iss(tokens[1]); face_t face; while (!iss.eof()) { iss &gt;&gt; idx; face.indices.push_back(idx); } mesh.faces.push_back(face); mesh.normals-&gt;push_back(mesh.calcFaceNormal(face)); } } return mesh; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ std::string delete_symbol(const std::string &amp;str, char symbol) { std::string tmp = str; tmp.erase(std::remove(tmp.begin(), tmp.end(), symbol), tmp.end()); return tmp; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ std::vector&lt;std::string&gt; ReaderWriterPMD::parseLine(const std::string &amp;line) const { std::vector&lt;std::string&gt; tokens; std::string tmp = delete_symbol(line, '\r'); size_t pos = 0; std::string token; while ( (pos = tmp.find(':')) != std::string::npos ) { token = tmp.substr(0, pos); tmp.erase(0, pos + 1); if (!token.empty()) tokens.push_back(token); } tokens.push_back(tmp); return tokens; } REGISTER_OSGPLUGIN( pmd, ReaderWriterPMD )</span></span></span></span></code> </pre><br></div></div><br>  Pertama, mari kita perhatikan struktur untuk menyimpan data geometri. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">face_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; indices; };</code> </pre><br>  - menjelaskan wajah yang ditentukan oleh daftar indeks dari simpul-simpul yang dimiliki wajah ini.  Model secara keseluruhan akan dijelaskan oleh struktur seperti itu <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pmd_mesh_t</span></span></span><span class="hljs-class"> {</span></span> osg::ref_ptr&lt;osg::Vec3Array&gt; vertices; osg::ref_ptr&lt;osg::Vec3Array&gt; normals; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">face_t</span></span>&gt; faces; <span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span>() : vertices(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) , normals(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) { } osg::<span class="hljs-function"><span class="hljs-function">Vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcFaceNormal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">face_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;face)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ osg::Vec3 v0 = (*vertices)[face.indices[<span class="hljs-number"><span class="hljs-number">0</span></span>]]; osg::Vec3 v1 = (*vertices)[face.indices[<span class="hljs-number"><span class="hljs-number">1</span></span>]]; osg::Vec3 v2 = (*vertices)[face.indices[<span class="hljs-number"><span class="hljs-number">2</span></span>]]; osg::Vec3 n = (v1 - v0) ^ (v2 - v0); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * (<span class="hljs-number"><span class="hljs-number">1</span></span> / n.length()); } };</code> </pre><br>  Struktur terdiri dari variabel anggota untuk menyimpan data: simpul - untuk menyimpan array simpul objek geometrik;  normals - array normals ke wajah objek;  wajah - daftar wajah objek.  Konstruktor struktur segera menginisialisasi pointer pintar <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span>() : vertices(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) , normals(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) { }</code> </pre><br>  Selain itu, struktur berisi metode yang memungkinkan Anda untuk menghitung vektor normal ke wajah calcFaceNormal () sebagai parameter yang mengambil struktur yang menggambarkan wajah.  Kami tidak akan membahas detail implementasi metode ini, kami akan menganalisisnya sedikit nanti. <br><br>  Jadi, kami memutuskan pada struktur di mana kami akan menyimpan data geometri.  Sekarang mari kita menulis kerangka kerja plugin kita, yaitu, kita menerapkan kelas pewaris osgDB :: ReaderWriter <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReaderWriterPMD</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osgDB::ReaderWriter { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ReaderWriterPMD(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp;stream, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span> parsePMD(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp;stream) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; parseLine(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;line) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; };</code> </pre><br>  Seperti yang direkomendasikan dalam deskripsi API untuk mengembangkan plugin, di kelas ini kami mendefinisikan kembali metode membaca data dari file dan mengubahnya menjadi subgraph dari adegan tersebut.  Metode readNode () melakukan dua overload - satu menerima nama file sebagai input, yang lain menerima input standar.  Konstruktor kelas mendefinisikan ekstensi file yang didukung oleh plugin <br><br><pre> <code class="cpp hljs">ReaderWriterPMD::ReaderWriterPMD() { supportsExtension(<span class="hljs-string"><span class="hljs-string">"pmd"</span></span>, <span class="hljs-string"><span class="hljs-string">"PMD model file"</span></span>); }</code> </pre><br>  Kelebihan pertama dari metode readNode () menganalisis kebenaran nama file dan path untuk itu, mengaitkan aliran input standar dengan file, dan memanggil kelebihan kedua, yang melakukan pekerjaan utama <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;filename, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osgDB::Options *options) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//       std::string ext = osgDB::getLowerCaseFileExtension(filename); // ,      if (!acceptsExtension(ext)) return ReadResult::FILE_NOT_HANDLED; // ,       std::string fileName = osgDB::findDataFile(filename, options); if (fileName.empty()) return ReadResult::FILE_NOT_FOUND; //      std::ifstream stream(fileName.c_str(), std::ios::in); if (!stream) return ReadResult::ERROR_IN_READING_FILE; //      readNode() return readNode(stream, options); }</span></span></code> </pre><br>  Pada overload kedua, kami mengimplementasikan algoritma pembuatan objek untuk OSG <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp;stream, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osgDB::Options *options) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) options; <span class="hljs-comment"><span class="hljs-comment">//   *.pmd       pmd_mesh_t mesh = parsePMD(stream); //    osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; //    geom-&gt;setVertexArray(mesh.vertices.get()); //    for (size_t i = 0; i &lt; mesh.faces.size(); ++i) { //    GL_POLYGON      (  - 0) osg::ref_ptr&lt;osg::DrawElementsUInt&gt; polygon = new osg::DrawElementsUInt(osg::PrimitiveSet::POLYGON, 0); //       for (size_t j = 0; j &lt; mesh.faces[i].indices.size(); ++j) polygon-&gt;push_back(mesh.faces[i].indices[j]); //     geom-&gt;addPrimitiveSet(polygon.get()); } //    geom-&gt;setNormalArray(mesh.normals.get()); //  OpenGL,       geom-&gt;setNormalBinding(osg::Geometry::BIND_PER_PRIMITIVE_SET); //             osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; geode-&gt;addDrawable(geom.get()); //     return geode.release(); }</span></span></code> </pre><br>  Di akhir file main.cpp, panggil makro REGISTER_OSGPLUGIN (). <br><br><pre> <code class="cpp hljs">REGISTER_OSGPLUGIN( pmd, ReaderWriterPMD )</code> </pre><br>  Makro ini menghasilkan kode tambahan yang memungkinkan OSG, dalam bentuk pustaka osgDB, untuk membangun objek tipe ReaderWriterPMD dan memanggil metode-metodenya untuk memuat file tipe PMD.  Dengan demikian, kerangka kerja plugin siap, masalahnya tetap kecil - untuk mengimplementasikan pemuatan dan penguraian file pmd. <br><br><h1>  7. Parsim file model 3D </h1><br>  Sekarang semua fungsi plugin bergantung pada implementasi metode parsePMD () <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span> ReaderWriterPMD::parsePMD(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp;stream) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span> mesh; <span class="hljs-comment"><span class="hljs-comment">//    while (!stream.eof()) { //      std::string line; std::getline(stream, line); //     -     std::vector&lt;std::string&gt; tokens = parseLine(line); //    -  if (tokens[0] == "vertex") { //       osg::Vec3 point; std::istringstream iss(tokens[1]); iss &gt;&gt; point.x() &gt;&gt; point.y() &gt;&gt; point.z(); //      mesh.vertices-&gt;push_back(point); } //    -  if (tokens[0] == "face") { //         unsigned int idx = 0; std::istringstream iss(tokens[1]); face_t face; while (!iss.eof()) { iss &gt;&gt; idx; face.indices.push_back(idx); } //      mesh.faces.push_back(face); //     mesh.normals-&gt;push_back(mesh.calcFaceNormal(face)); } } return mesh; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Metode ParseLine () mem-parsing baris file PMD </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; ReaderWriterPMD::parseLine(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;line) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; tokens; <span class="hljs-comment"><span class="hljs-comment">//   ,        ( Windows) std::string tmp = delete_symbol(line, '\r'); size_t pos = 0; std::string token; //      ,     : //      while ( (pos = tmp.find(':')) != std::string::npos ) { //     (vertex  face   ) token = tmp.substr(0, pos); //         tmp.erase(0, pos + 1); if (!token.empty()) tokens.push_back(token); } //        tokens.push_back(tmp); return tokens; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode ini akan mengubah string "vertex: 1.0 -1.0 0.0" menjadi daftar dari dua baris "vertex" dan "1.0 -1.0 0.0". </font><font style="vertical-align: inherit;">Pada baris pertama, kami mengidentifikasi tipe data - titik atau wajah, dari baris kedua kami mengekstrak data pada koordinat titik tersebut. </font><font style="vertical-align: inherit;">Untuk memastikan operasi metode ini, kita memerlukan fungsi bantu delete_symbol (), yang menghapus karakter yang diberikan dari string dan mengembalikan string yang tidak mengandung karakter ini</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete_symbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> symbol)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> tmp = str; tmp.erase(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::remove(tmp.begin(), tmp.end(), symbol), tmp.end()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Artinya, sekarang kami telah menerapkan semua fungsi plugin kami dan dapat mengujinya. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Menguji plugin </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mengkompilasi plugin dan menjalankan debugging (F5). </font><font style="vertical-align: inherit;">Versi debug penampil osgviewerd standar akan diluncurkan, yang akan menganalisis file piramide.pmd yang diteruskan ke sana, memuat plugin kami dan memanggil metode readNode (). </font><font style="vertical-align: inherit;">Jika kita melakukan segalanya dengan benar, maka kita akan mendapatkan hasil seperti itu. </font></font><br><br><img src="https://habrastorage.org/webt/s3/5g/-y/s35g-ykmmlet5z8jisj7efkz7je.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ternyata daftar simpul dan wajah dalam file 3D model yang kita buat menyembunyikan piramida segi empat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa kami menghitung sendiri normals? </font><font style="vertical-align: inherit;">Dalam salah satu pelajaran, kami ditawari metode perhitungan otomatis normals smoothed berikut</font></font><br><br><pre> <code class="cpp hljs">osgUtil::SmoothingVisitor::smooth(*geom);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menerapkan fungsi ini dalam contoh kami, alih-alih menetapkan normals kami sendiri </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//geom-&gt;setNormalArray(mesh.normals.get()); //geom-&gt;setNormalBinding(osg::Geometry::BIND_PER_PRIMITIVE_SET); osgUtil::SmoothingVisitor::smooth(*geom);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan kami mendapatkan hasil sebagai berikut: </font></font><br><br><img src="https://habrastorage.org/webt/eb/gd/kt/ebgdktxsplxyqatprxunnwd8r2o.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normalnya mempengaruhi perhitungan model pencahayaan, dan kami melihat bahwa dalam situasi ini, normals yang dihaluskan menyebabkan hasil perhitungan pencahayaan piramida yang salah. </font><font style="vertical-align: inherit;">Karena alasan inilah kami menerapkan motor kami ke perhitungan normal. </font><font style="vertical-align: inherit;">Tetapi saya berpikir bahwa menjelaskan nuansa ini berada di luar cakupan pelajaran ini.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438296/">https://habr.com/ru/post/id438296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438286/index.html">Bekerja dengan zona waktu dalam JavaScript</a></li>
<li><a href="../id438288/index.html">Perlindungan tanpa rasa takut. Keamanan Memori dalam Karat</a></li>
<li><a href="../id438290/index.html">Post-mortem dengan GGJ-2019: bagaimana cara mendapatkan gundukan, tetapi tetap membuat game</a></li>
<li><a href="../id438292/index.html">Otomasi Apartemen dengan HomePod, Raspberry Pi dan Node.js</a></li>
<li><a href="../id438294/index.html">Menemukan Stream Twitch dalam Pertandingan PUBG</a></li>
<li><a href="../id438298/index.html">Mengapa mengajar jika berkembang lebih menguntungkan. Percakapan dengan GeekBrains</a></li>
<li><a href="../id438302/index.html">Kreativitas luar biasa dari evolusi digital</a></li>
<li><a href="../id438304/index.html">Subkontrak? Keren, Anda memukul</a></li>
<li><a href="../id438306/index.html">Radiasi: Laboratorium radiokimia hari kerja</a></li>
<li><a href="../id438310/index.html">Instagram menggunakan pembelajaran mesin untuk menghapus pengikut palsu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>