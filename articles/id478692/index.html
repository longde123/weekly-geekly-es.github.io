<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë©üèº üë®üèª‚Äçüè´ üîõ Bagaimana Java 8 didukung di Android üèì üëå üåâ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya membawa kepada Anda terjemahan dari artikel yang luar biasa dari serangkaian artikel oleh Jake Worton yang terkenal buruk tentang bag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana Java 8 didukung di Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/478692/">  Halo, Habr!  Saya membawa kepada Anda terjemahan dari artikel yang luar biasa dari serangkaian artikel oleh <a href="https://twitter.com/JakeWharton%3Flang%3Den">Jake Worton yang terkenal buruk</a> tentang bagaimana Android 8 didukung oleh Java. <br><br><img src="https://habrastorage.org/webt/ho/ap/qe/hoapqe-nhkwts3ekeettjbuiao8.png"><br><br>  <font color="#0000ff"><a href="https://jakewharton.com/androids-java-8-support/">Artikel asli ada di sini</a></font> <br><a name="habracut"></a><br>  Saya bekerja dari rumah selama beberapa tahun, dan saya sering mendengar rekan saya mengeluh tentang Android yang mendukung berbagai versi Java. <br><br>  Ini adalah topik yang agak rumit.  Pertama, Anda perlu memutuskan apa yang kami maksud dengan ‚Äúdukungan Java di Android‚Äù, karena dalam satu versi bahasa bisa ada banyak hal: fitur (lambda, misalnya), bytecode, alat, API, JVM dan sebagainya. <br><br>  Ketika orang berbicara tentang dukungan Java 8 di Android, mereka biasanya berarti dukungan untuk fitur bahasa.  Jadi, mari kita mulai dengan mereka. <br><br><h2>  Lambdas </h2><br>  Salah satu inovasi utama Java 8 adalah lambdas. <br>  Kode telah menjadi lebih ringkas dan sederhana, lambdas telah menyelamatkan kita dari menulis kelas anonim rumit menggunakan antarmuka dengan metode tunggal di dalamnya. <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ sayHi(s -&gt; System.out.println(s)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Logger logger)</span></span></span><span class="hljs-function"> </span></span>{ logger.log(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>); } }</code> </pre> <br>  Setelah mengkompilasi ini menggunakan alat javac dan legacy <code>dx tool</code> , kami mendapatkan kesalahan berikut: <br><br><pre> <code class="plaintext hljs">$ javac *.java $ ls Java8.java Java8.class Java8$Logger.class $ $ANDROID_HOME/build-tools/28.0.2/dx --dex --output . *.class Uncaught translation error: com.android.dx.cf.code.SimException: ERROR in Java8.main:([Ljava/lang/String;)V: invalid opcode ba - invokedynamic requires --min-sdk-version &gt;= 26 (currently 13) 1 error; aborting</code> </pre> <br>  Kesalahan ini terjadi karena fakta bahwa lambdas menggunakan instruksi baru dalam bytecode - <code>invokedynamic</code> , yang ditambahkan di Java 7. Dari teks kesalahan Anda dapat melihat bahwa Android hanya mendukungnya dimulai dengan 26 API (Android 8). <br><br>  Kedengarannya tidak terlalu bagus, karena hampir tidak ada orang yang akan merilis aplikasi dengan 26 minApi.  Untuk menyiasatinya, apa yang disebut proses <i>desugaring digunakan</i> , yang memungkinkan dukungan lambda pada semua versi API. <br><br><h2>  Sejarah Desaccharization </h2><br>  Dia cukup berwarna di dunia Android.  Tujuan desaccharization selalu sama - untuk memungkinkan fitur bahasa baru berfungsi di semua perangkat. <br><br>  Awalnya, misalnya, untuk mendukung lambdas di Android, pengembang menghubungkan plugin <a href="https://github.com/evant/gradle-retrolambda">Retrolambda</a> .  Dia menggunakan mekanisme built-in yang sama dengan JVM, mengubah lambdas ke kelas, tapi dia melakukannya di runtime, dan tidak pada waktu kompilasi.  Kelas yang dihasilkan sangat mahal dalam hal jumlah metode, tetapi seiring waktu, setelah perbaikan dan peningkatan, indikator ini menurun menjadi sesuatu yang lebih atau kurang masuk akal. <br><br>  Kemudian, tim Android <a href="https://android-developers.googleblog.com/2014/12/hello-world-meet-our-new-experimental.html">mengumumkan kompiler baru</a> yang mendukung semua fitur Java 8 dan lebih produktif.  Itu dibangun di atas kompiler Java Eclipse, tetapi bukannya menghasilkan bytecode Java, itu menghasilkan bytecode Dalvik.  Namun, kinerjanya masih banyak yang harus diinginkan. <br><br>  Ketika kompiler baru (untungnya) ditinggalkan, Java bytecode transformer di bytecode Java, yang melakukan juggling, <a href="https://android-developers.googleblog.com/2017/04/java-8-language-features-support-update.html">diintegrasikan ke dalam Plugin Android Gradle</a> dari <a href="https://docs.bazel.build/versions/master/bazel-and-android.html">Bazel</a> , sistem build Google.  Dan kinerjanya masih rendah, sehingga pencarian solusi yang lebih baik dilanjutkan secara paralel. <br><br>  Dan sekarang kami diberi <a href="https://android-developers.googleblog.com/2017/08/next-generation-dex-compiler-now-in.html"><code>  dexer</code></a> - <i>D8</i> , yang seharusnya menggantikan <code>dx tool</code> .  Desaccharization sekarang dilakukan selama konversi file JAR yang dikompilasi menjadi .dex (dexing).  D8 jauh lebih baik dalam kinerja dibandingkan dengan <code>dx</code> , dan karena Android Gradle Plugin 3.1 telah menjadi dexer default. <br><br><h2>  D8 </h2><br>  Sekarang, menggunakan D8, kita dapat mengkompilasi kode di atas. <br><br><pre> <code class="plaintext hljs">$ java -jar d8.jar \ --lib $ANDROID_HOME/platforms/android-28/android.jar \ --release \ --output . \ *.class $ ls Java8.java Java8.class Java8$Logger.class classes.dex</code> </pre> <br>  Untuk melihat bagaimana D8 mengkonversi lambda, Anda dapat menggunakan <code>dexdump tool</code> , yang termasuk dalam Android SDK.  Ini akan menampilkan cukup banyak segalanya, tetapi kami hanya akan fokus pada ini: <br><br><pre> <code class="plaintext hljs">$ $ANDROID_HOME/build-tools/28.0.2/dexdump -d classes.dex [0002d8] Java8.main:([Ljava/lang/String;)V 0000: sget-object v0, LJava8$1;.INSTANCE:LJava8$1; 0002: invoke-static {v0}, LJava8;.sayHi:(LJava8$Logger;)V 0005: return-void [0002a8] Java8.sayHi:(LJava8$Logger;)V 0000: const-string v0, "Hello" 0002: invoke-interface {v1, v0}, LJava8$Logger;.log:(Ljava/lang/String;)V 0005: return-void ‚Ä¶</code> </pre> <br>  Jika Anda belum membaca bytecode, jangan khawatir: banyak dari apa yang ditulis di sini dapat dipahami secara intuitif. <br><br>  Di blok pertama, metode <code>main</code> kami dengan indeks <code>0000</code> mendapat referensi dari bidang <code>INSTANCE</code> ke kelas <code>INSTANCE</code> <code>Java8$1</code> .  Kelas ini dihasilkan selama <code></code> .  Metode bytecode utama juga tidak mengandung penyebutan tubuh lambda kita, oleh karena itu, kemungkinan besar, ini terkait dengan kelas <code>Java8$1</code> .  Indeks <code>0002</code> kemudian memanggil metode statis <code>sayHi</code> menggunakan tautan ke <code>INSTANCE</code> .  <code>sayHi</code> membutuhkan <code>Java8$Logger</code> , sehingga tampaknya <code>Java8$1</code> mengimplementasikan antarmuka ini.  Kami dapat memverifikasi ini di sini: <br><br><pre> <code class="plaintext hljs">Class #2 - Class descriptor : 'LJava8$1;' Access flags : 0x1011 (PUBLIC FINAL SYNTHETIC) Superclass : 'Ljava/lang/Object;' Interfaces - #0 : 'LJava8$Logger;'</code> </pre> <br>  Bendera <code>SYNTHETIC</code> berarti kelas <code>Java8$1</code> telah dibuat dan daftar antarmuka yang disertakan berisi <code>Java8$Logger</code> . <br>  Kelas ini mewakili lambda kita.  Jika Anda melihat implementasi metode <code>log</code> , Anda tidak akan melihat tubuh lambda. <br><br><pre> <code class="plaintext hljs">‚Ä¶ [00026c] Java8$1.log:(Ljava/lang/String;)V 0000: invoke-static {v1}, LJava8;.lambda$main$0:(Ljava/lang/String;)V 0003: return-void ‚Ä¶</code> </pre> <br>  Sebaliknya, metode <code>static</code> dari kelas <code>Java8</code> - <code>lambda$main$0</code> .  Saya ulangi, metode ini hanya disajikan dalam bytecode. <br><br><pre> <code class="plaintext hljs">‚Ä¶ #1 : (in LJava8;) name : 'lambda$main$0' type : '(Ljava/lang/String;)V' access : 0x1008 (STATIC SYNTHETIC) [0002a0] Java8.lambda$main$0:(Ljava/lang/String;)V 0000: sget-object v0, Ljava/lang/System;.out:Ljava/io/PrintStream; 0002: invoke-virtual {v0, v1}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V 0005: return-void</code> </pre> <br>  Bendera <code>SYNTHETIC</code> lagi memberitahu kita bahwa metode ini dihasilkan, dan bytecode-nya hanya berisi tubuh lambda: panggilan ke <code>System.out.println</code> .  Alasan mengapa badan lambda ada di dalam <i>Java8.class</i> sederhana - mungkin perlu mengakses anggota kelas pribadi, yang tidak dapat diakses oleh kelas yang dihasilkan oleh kelas. <br><br>  Semua yang Anda butuhkan untuk memahami cara kerja <i>desakcharisasi</i> dijelaskan di atas.  Namun, melihatnya dalam bytecode Dalvik, Anda dapat melihat bahwa semuanya jauh lebih rumit dan menakutkan di sana. <br><br><h2>  Transformasi Sumber </h2><br>  Untuk lebih memahami bagaimana <i>desakarida</i> terjadi, mari kita coba langkah demi langkah untuk mengubah kelas kita menjadi sesuatu yang akan bekerja pada semua versi API. <br><br>  Mari kita ambil kelas yang sama dengan lambda sebagai dasar: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ sayHi(s -&gt; System.out.println(s)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Logger logger)</span></span></span><span class="hljs-function"> </span></span>{ logger.log(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>); } }</code> </pre> <br>  Pertama, tubuh lambda dipindahkan ke metode <code>package private</code> . <br><br><pre> <code class="diff hljs"> public static void main(String... args) { - sayHi(s -&gt; System.out.println(s)); + sayHi(s -&gt; lambda$main$0(s)); } + + static void lambda$main$0(String s) { + System.out.println(s); + }</code> </pre> <br>  Kemudian sebuah kelas diimplementasikan yang mengimplementasikan antarmuka <code>Logger</code> , di mana blok kode dari tubuh lambda dieksekusi. <br><br><pre> <code class="diff hljs"> public static void main(String... args) { - sayHi(s -&gt; lambda$main$0(s)); + sayHi(new Java8$1()); } @@ } + +class Java8$1 implements Java8.Logger { + @Override public void log(String s) { + Java8.lambda$main$0(s); + } +}</code> </pre> <br>  Selanjutnya, instance singleton dari <code>Java8$1</code> , yang disimpan dalam variabel variabel <code>INSTANCE</code> . <br><br><pre> <code class="diff hljs"> public static void main(String... args) { - sayHi(new Java8$1()); + sayHi(Java8$1.INSTANCE); } @@ class Java8$1 implements Java8.Logger { + static final Java8$1 INSTANCE = new Java8$1(); + @Override public void log(String s) {</code> </pre> <br>  Berikut ini adalah kelas yang <i>dijuluki</i> akhir yang dapat digunakan pada semua versi API: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ sayHi(Java8$<span class="hljs-number"><span class="hljs-number">1</span></span>.INSTANCE); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> lambda$main$<span class="hljs-number"><span class="hljs-number">0</span></span>(String s) { System.out.println(s); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Logger logger)</span></span></span><span class="hljs-function"> </span></span>{ logger.log(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class">$1 </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Java8$<span class="hljs-number"><span class="hljs-number">1</span></span> INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Java8$<span class="hljs-number"><span class="hljs-number">1</span></span>(); <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span><span class="hljs-function"> </span></span>{ Java8.lambda$main$<span class="hljs-number"><span class="hljs-number">0</span></span>(s); } }</code> </pre> <br>  Jika Anda melihat kelas yang dihasilkan dalam bytecode Dalvik, Anda tidak akan menemukan nama seperti Java8 $ 1 - akan ada sesuatu seperti <code>-$$Lambda$Java8$QkyWJ8jlAksLjYziID4cZLvHwoY</code> .  Alasan mengapa penamaan tersebut dihasilkan untuk kelas, dan apa kelebihannya, menarik ke artikel terpisah. <br><br><h2>  Dukungan lambda asli </h2><br>  Ketika kami menggunakan <code>dx tool</code> untuk mengkompilasi kelas yang berisi lambdas, pesan kesalahan mengatakan bahwa ini hanya akan bekerja dengan 26 API. <br><br><pre> <code class="plaintext hljs">$ $ANDROID_HOME/build-tools/28.0.2/dx --dex --output . *.class Uncaught translation error: com.android.dx.cf.code.SimException: ERROR in Java8.main:([Ljava/lang/String;)V: invalid opcode ba - invokedynamic requires --min-sdk-version &gt;= 26 (currently 13) 1 error; aborting</code> </pre> <br>  Oleh karena itu, tampaknya logis bahwa jika kita mencoba untuk mengkompilasi ini dengan <code>‚Äîmin-api 26</code> , maka desaccharization tidak akan terjadi. <br><br><pre> <code class="bash hljs">$ java -jar d8.jar \ --lib <span class="hljs-variable"><span class="hljs-variable">$ANDROID_HOME</span></span>/platforms/android-28/android.jar \ --release \ --min-api 26 \ --output . \ *.class</code> </pre> <br>  Namun, jika kita membuang file <code>.dex</code> , maka masih dapat ditemukan di dalamnya <code>-$$Lambda$Java8$QkyWJ8jlAksLjYziID4cZLvHwoY</code> .  Kenapa begitu  Apakah ini bug D8? <br><br>  Untuk menjawab pertanyaan ini, dan mengapa desakarisasi <i>selalu terjadi</i> , kita perlu melihat ke dalam kode kode Java dari kelas <code>Java8</code> . <br><br><pre> <code class="bash hljs">$ javap -v Java8.class class Java8 { public static void main(java.lang.String...); Code: 0: invokedynamic <span class="hljs-comment"><span class="hljs-comment">#2, 0 // InvokeDynamic #0:log:()LJava8$Logger; 5: invokestatic #3 // Method sayHi:(LJava8$Logger;)V 8: return } ‚Ä¶</span></span></code> </pre> <br>  Di dalam metode <code>main</code> , kita kembali melihat <i>invokedynamic</i> pada indeks <code>0</code> .  Argumen kedua dalam panggilan adalah <code>0</code> - indeks metode <a href="https://stackoverflow.com/questions/30733557/what-is-a-bootstrap-method">bootstrap</a> yang terkait dengannya. <br><br>  Berikut adalah daftar metode <i>bootstrap</i> : <br><br><pre> <code class="plaintext hljs">‚Ä¶ BootstrapMethods: 0: #27 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:( Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String; Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType; Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;) Ljava/lang/invoke/CallSite; Method arguments: #28 (Ljava/lang/String;)V #29 invokestatic Java8.lambda$main$0:(Ljava/lang/String;)V #28 (Ljava/lang/String;)V</code> </pre> <br>  Di sini metode <i>bootstrap</i> disebut <code>metafactory</code> di kelas <code>java.lang.invoke.LambdaMetafactory</code> .  Dia <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html">tinggal di JDK</a> dan menciptakan kelas on-the-fly anonim dalam runtime untuk lambdas, seperti D8 yang menghasilkannya dalam waktu komputasi. <br><br>  Jika Anda melihat <a href="https://developer.android.com/reference/java/lang/invoke/package-summary"><code> Android  java.lang.invoke</code></a> <br>  atau ke <a href="https://android.googlesource.com/platform/libcore/%2B/master/ojluni/src/main/java/java/lang/invoke/"><code> AOSP  java.lang.invoke</code></a> , kita melihat bahwa kelas ini tidak di runtime.  Itu sebabnya de-juggling selalu terjadi pada waktu kompilasi, tidak peduli berapa minApi yang Anda miliki.  VM mendukung instruksi bytecode yang mirip dengan <code>invokedynamic</code> , tetapi <code>invokedynamic</code> built-in ke JDK tidak tersedia untuk digunakan. <br><br><h2>  Referensi metode </h2><br>  Seiring dengan lambdas, Java 8 menambahkan referensi metode - ini adalah cara yang efektif untuk membuat lambda yang tubuhnya mereferensikan metode yang ada. <br><br>  Antarmuka <code>Logger</code> kami hanyalah contoh seperti itu.  Tubuh lambda disebut <code>System.out.println</code> .  Mari kita ubah lambda menjadi metode referensi: <br><br><pre> <code class="diff hljs"> public static void main(String... args) { - sayHi(s -&gt; System.out.println(s)); + sayHi(System.out::println); }</code> </pre> <br>  Ketika kita mengompilasinya dan melihat bytecode, kita akan melihat satu perbedaan dengan versi sebelumnya: <br><br><pre> <code class="plaintext hljs">[000268] -$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM.log:(Ljava/lang/String;)V 0000: iget-object v0, v1, L-$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM;.f$0:Ljava/io/PrintStream; 0002: invoke-virtual {v0, v2}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V 0005: return-void</code> </pre> <br>  Alih-alih memanggil <code>Java8.lambda$main$0</code> dihasilkan <code>Java8.lambda$main$0</code> , yang berisi panggilan ke <code>System.out.println</code> , sekarang <code>System.out.println</code> dipanggil langsung. <br><br>  Kelas dengan lambda bukan lagi singleton <code>static</code> , tetapi dengan indeks <code>0000</code> dalam bytecode, kita melihat bahwa kita mendapatkan tautan ke <code>PrintStream</code> - <code>System.out</code> , yang kemudian digunakan untuk memanggil <code>println</code> di atasnya. <br><br>  Akibatnya, kelas kami berubah menjadi ini: <br><br><pre> <code class="diff hljs"> public static void main(String... args) { - sayHi(System.out::println); + sayHi(new -$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM(System.out)); } @@ } + +class -$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM implements Java8.Logger { + private final PrintStream ps; + + -$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM(PrintStream ps) { + this.ps = ps; + } + + @Override public void log(String s) { + ps.println(s); + } +}</code> </pre> <br><h2>  Metode <code>Default</code> dan <code>static</code> di antarmuka </h2><br>  Perubahan penting dan besar lainnya yang dibawa Java 8 adalah kemampuan untuk mendeklarasikan metode <code>default</code> dan <code>static</code> di antarmuka. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String tag, String s)</span></span></span><span class="hljs-function"> </span></span>{ log(tag + <span class="hljs-string"><span class="hljs-string">": "</span></span> + s); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Logger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">systemOut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> System.out::println; } }</code> </pre> <br>  Semua ini juga didukung oleh D8.  Menggunakan alat yang sama seperti sebelumnya, mudah untuk melihat versi Logger yang masuk dengan metode <code>default</code> dan <code>static</code> .  Salah satu perbedaan dengan lambdas dan <code>method references</code> adalah bahwa metode default dan statis diterapkan di VM Android dan, dimulai dengan 24 API, D8 tidak akan <i>memisahkan</i> mereka. <br><br><h2>  Mungkin hanya menggunakan Kotlin? </h2><br>  Saat membaca artikel, sebagian besar dari Anda mungkin berpikir tentang Kotlin.  Ya, itu mendukung semua fitur Java 8, tetapi mereka diimplementasikan oleh <code>kotlinc</code> dengan cara yang sama seperti D8, dengan pengecualian beberapa detail. <br><br>  Oleh karena itu, dukungan Android untuk versi baru Java masih sangat penting, bahkan jika proyek Anda 100% ditulis di Kotlin. <br><br>  Ada kemungkinan bahwa di masa depan Kotlin tidak lagi mendukung bytecode Java 6 dan Java 7. <a href="https://blog.jetbrains.com/idea/2015/12/intellij-idea-16-eap-144-2608-is-out/">IntelliJ IDEA</a> , Gradle 5.0 beralih ke Java 8. Jumlah platform yang berjalan pada JVM lama semakin berkurang. <br><br><h2>  Desugaring APIs </h2><br>  Selama ini saya berbicara tentang fitur Java 8, tetapi tidak mengatakan apa-apa tentang API baru - stream, <code>CompletableFuture</code> , tanggal / waktu dan sebagainya. <br><br>  Kembali ke contoh Logger, kita dapat menggunakan API tanggal / waktu baru untuk mengetahui kapan pesan dikirim. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.time.*; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalDateTime time, String s)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ sayHi((time, s) -&gt; System.out.println(time + <span class="hljs-string"><span class="hljs-string">" "</span></span> + s)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Logger logger)</span></span></span><span class="hljs-function"> </span></span>{ logger.log(LocalDateTime.now(), <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>); } }</code> </pre> <br>  <i>Kompilasi</i> lagi dengan <code>javac</code> dan konversikan ke bytecode Dalvik dengan D8, yang <i>memisahkannya</i> untuk dukungan pada semua versi API. <br><br><pre> <code class="plaintext hljs">$ javac *.java $ java -jar d8.jar \ --lib $ANDROID_HOME/platforms/android-28/android.jar \ --release \ --output . \ *.class</code> </pre> <br>  Anda bahkan dapat menjalankan ini di perangkat Anda untuk memastikan itu berfungsi. <br><br><pre> <code class="plaintext hljs">$ adb push classes.dex /sdcard classes.dex: 1 file pushed. 0.5 MB/s (1620 bytes in 0.003s) $ adb shell dalvikvm -cp /sdcard/classes.dex Java8 2018-11-19T21:38:23.761 Hello</code> </pre> <br>  Jika API 26 dan di atasnya ada di perangkat ini, pesan Hello akan muncul.  Jika tidak, kita akan melihat yang berikut: <br><br><pre> <code class="plaintext hljs">java.lang.NoClassDefFoundError: Failed resolution of: Ljava/time/LocalDateTime; at Java8.sayHi(Java8.java:13) at Java8.main(Java8.java:9)</code> </pre> <br>  D8 berurusan dengan lambdas, metode referensi, tetapi tidak melakukan apa pun untuk bekerja dengan <code>LocalDateTime</code> , dan ini sangat menyedihkan. <br><br>  Pengembang harus menggunakan implementasi atau pembungkus mereka sendiri pada api tanggal / waktu, atau menggunakan perpustakaan seperti <code>ThreeTenBP</code> untuk bekerja dengan waktu, tetapi mengapa Anda tidak dapat melakukan D8 dengan tangan Anda sendiri? <br><br><h2>  Epilog </h2><br>  Kurangnya dukungan untuk semua Java 8 API baru tetap menjadi masalah besar di ekosistem Android.  Memang, tidak mungkin masing-masing dari kita dapat mengizinkan kita untuk menentukan 26 menit API dalam proyek kita.  Perpustakaan yang mendukung Android dan JVM tidak mampu menggunakan API yang diperkenalkan kepada kami 5 tahun yang lalu! <br><br>  Dan meskipun dukungan Java 8 sekarang merupakan bagian dari D8, setiap pengembang masih harus secara eksplisit menentukan kompatibilitas sumber dan target di Java 8. Jika Anda menulis pustaka Anda sendiri, Anda dapat memperkuat tren ini dengan meletakkan pustaka yang menggunakan bytecode Java 8. (bahkan jika Anda tidak menggunakan fitur bahasa baru). <br><br>  Banyak pekerjaan sedang dilakukan pada D8, jadi sepertinya semuanya akan baik-baik saja di masa depan dengan dukungan untuk fitur bahasa.  Bahkan jika Anda hanya menulis di Kotlin, sangat penting untuk memaksa tim pengembangan Android untuk mendukung semua versi Java yang baru, meningkatkan bytecode dan API baru. <br><br>  Posting ini adalah versi tertulis dari ceramah saya <a href="https://jakewharton.com/digging-into-d8-and-r8/">Menggali D8 dan R8</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id478692/">https://habr.com/ru/post/id478692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id478672/index.html">Pengujian dan Startup AI: Wawancara dengan Adam Carmi (Applitools)</a></li>
<li><a href="../id478680/index.html">Mengapa, dan yang paling penting, kemana orang pergi dari IT?</a></li>
<li><a href="../id478684/index.html">Pengantar SSD. Bagian 2. Antarmuka</a></li>
<li><a href="../id478688/index.html">Bagaimana rasanya belajar Ilmu Data pada tahun 2019</a></li>
<li><a href="../id478690/index.html">Perakitan dinamis dan penyebaran gambar Docker dengan werf menggunakan contoh situs dokumentasi versi</a></li>
<li><a href="../id478694/index.html">Karena kami merekomendasikan katalog terbaru di bioskop online ivi (+ kode Python)</a></li>
<li><a href="../id478696/index.html">Bagaimana Saya Mengunjungi Urban Tech 2019. Laporan Acara</a></li>
<li><a href="../id478698/index.html">Kami membuat rencana medan interaktif dalam 15 menit</a></li>
<li><a href="../id478702/index.html">Trik Pemrosesan Metrik di Kapacitor</a></li>
<li><a href="../id478706/index.html">Arsitek beban tinggi. Kursus baru dari OTUS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>