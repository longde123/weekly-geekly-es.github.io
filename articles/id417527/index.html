<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëô üë®üèæ‚Äçü§ù‚Äçüë®üèΩ üìõ Kami mengembangkan Udang: kami mengontrol permintaan paralel, kami masuk melalui spdlog dan banyak lagi ... üë®üèø‚ÄçüöÄ üåå üçÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pekan lalu, kami berbicara tentang proyek demo kecil kami, Shrimp , yang dengan jelas menunjukkan bagaimana Anda dapat menggunakan perpustakaan C ++ R...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami mengembangkan Udang: kami mengontrol permintaan paralel, kami masuk melalui spdlog dan banyak lagi ...</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417527/"><img src="https://habrastorage.org/webt/6p/er/na/6pernaqwjoqg3picsc4pz2d1xba.jpeg"><br><br>  Pekan lalu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kami berbicara tentang proyek demo kecil kami, Shrimp</a> , yang dengan jelas menunjukkan bagaimana Anda dapat menggunakan perpustakaan C ++ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RESTinio</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SObjectizer</a> dalam kondisi yang kurang lebih serupa.  Shrimp adalah aplikasi C ++ 17 kecil yang, melalui RESTinio, menerima permintaan HTTP untuk penskalaan gambar dan melayani permintaan ini dalam mode multi-berulir melalui SObjectizer dan ImageMagick ++. <br><br>  Proyek ini ternyata lebih bermanfaat bagi kami.  Piggy bank Wishlist untuk memperluas fungsi RESTinio dan SObjectizer telah secara signifikan diisi ulang.  Sesuatu yang bahkan telah diwujudkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi terbaru RESTinio-0.4.7</a> .  Jadi kami memutuskan untuk tidak memikirkan Udang versi pertama dan paling sepele, tetapi untuk melakukan satu atau dua iterasi lagi di sekitar proyek ini.  Jika seseorang tertarik pada apa dan bagaimana yang telah kami lakukan selama ini, Anda dipersilakan di bawah kucing. <br><blockquote>  Sebagai spoiler: ini tentang bagaimana kami menyingkirkan pemrosesan paralel dari permintaan yang identik, bagaimana kami menambahkan logging ke Shrimp menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pustaka spdlog yang luar biasa</a> , dan juga membuat perintah untuk memaksa cache dari gambar yang diubah untuk diatur ulang. </blockquote><a name="habracut"></a><h1>  v0.3: kontrol pemrosesan paralel permintaan identik </h1><br>  Versi udang pertama, yang dijelaskan dalam artikel sebelumnya, mengandung penyederhanaan serius: tidak ada kontrol atas apakah permintaan yang sama sedang diproses atau tidak. <br><br>  Bayangkan bahwa untuk pertama kalinya Shrimp menerima permintaan dari bentuk "/demo.jpg?op=resize&amp;max=1024".  Tidak ada gambar seperti itu di cache gambar yang diubah, jadi permintaan sedang diproses.  Pemrosesan dapat memakan waktu cukup lama, katakanlah, beberapa ratus milidetik. <br><br>  Pemrosesan permintaan belum selesai, dan Shrimp kembali menerima permintaan yang sama "/demo.jpg?op=resize&amp;max=1024", tetapi dari klien lain.  Belum ada hasil transformasi dalam cache, oleh karena itu permintaan ini juga akan diproses. <br><br>  Permintaan pertama maupun kedua belum selesai, dan Shrimp dapat kembali menerima permintaan yang sama "/demo.jpg?op=resize&amp;max=1024".  Dan permintaan ini juga akan diproses.  Ternyata gambar yang sama diskalakan dengan ukuran yang sama secara paralel beberapa kali. <br><br>  Ini tidak baik.  Karena itu, hal pertama yang kami putuskan di Shrimp adalah menyingkirkan kusen yang begitu serius.  Kami melakukan ini karena dua wadah rumit di agen transform_manager.  Kontainer pertama adalah antrian menunggu permintaan transformator gratis.  Ini adalah wadah bernama m_pending_requests.  Kontainer kedua menyimpan permintaan yang sudah diproses (mis. Transformer khusus dialokasikan untuk permintaan ini).  Ini adalah wadah bernama m_inprogress_requests. <br><br>  Ketika transform_manager menerima permintaan berikutnya, ia memeriksa keberadaan gambar yang sudah selesai dalam cache dari gambar yang diubah.  Jika tidak ada gambar yang dikonversi, maka wadah m_inprogress_requests dan m_pending_requests diperiksa.  Dan jika tidak ada permintaan dengan parameter seperti itu di salah satu wadah ini, hanya upaya yang dilakukan untuk menempatkan permintaan dalam antrian m_pending_requests.  Ini terlihat <a href="">seperti ini</a> : <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::handle_not_transformed_image( transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> request_key, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> store_to = [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.insert( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request_key), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd) ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_inprogress_requests.has_key( request_key ) ) { <span class="hljs-comment"><span class="hljs-comment">//    . //         . store_to( m_inprogress_requests ); } else if( m_pending_requests.has_key( request_key ) ) { //      . store_to( m_pending_requests ); } else if( m_pending_requests.unique_keys() &lt; max_pending_requests ) { //           . store_to( m_pending_requests ); //    transformer-     . try_initiate_pending_requests_processing(); } else { //  ,   . do_503_response( std::move(cmd-&gt;m_http_req) ); } }</span></span></code> </pre> <br>  Dikatakan di atas bahwa m_inprogress_requests dan m_pending_requests adalah wadah yang rumit.  Tapi apa masalahnya? <br><br>  Kuncinya adalah bahwa wadah ini menggabungkan sifat-sifat dari kedua antrian FIFO biasa (di mana urutan kronologis unsur-unsur tambahan dipertahankan) dan multimap, mis.  Wadah asosiatif di mana beberapa nilai dapat dipetakan ke satu kunci. <br><br>  Mempertahankan urutan kronologis itu penting, karena elemen tertua di m_pending_requests perlu diperiksa dan dihapus secara berkala dari m_pending_requests permintaan yang melebihi batas waktu maksimum.  Dan akses efektif ke elemen dengan kunci diperlukan baik untuk memeriksa keberadaan permintaan identik dalam antrian, dan agar semua permintaan duplikat dapat dihapus dari antrian pada suatu waktu. <br><br>  Di Shrimp, kami mengayuh sepaket <a href="">kecil</a> untuk tujuan ini.  Meskipun, jika Boost digunakan dalam udang, Boost.MultiIndex dapat digunakan.  Dan, mungkin, seiring waktu, pencarian yang efektif di m_pending_requests perlu diatur oleh beberapa kriteria lain, maka Boost.MultiIndex di Shrimp harus diaktifkan. <br><br><h1>  v0.4: masuk dengan spdlog </h1><br>  Kami mencoba membuat udang versi pertama sesederhana dan seringkas mungkin.  Karena apa, dalam versi pertama udang, kami tidak menggunakan penebangan.  Umumnya. <br><br>  Di satu sisi, ini memungkinkan untuk menjaga agar kode versi pertama tetap ringkas, tidak mengandung apa pun kecuali logika bisnis Shrimp yang diperlukan.  Namun, di sisi lain, kurangnya pembalakan menyulitkan pengembangan udang dan operasinya.  Oleh karena itu, segera setelah kami mendapatkannya, kami segera menyeret ke perpustakaan C ++ modern yang bagus untuk logging - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spdlog</a> .  Pernapasan segera menjadi lebih mudah, meskipun kode beberapa metode bertambah volumenya. <br><br>  Sebagai contoh, kode di atas metode handle_not_transformed_image () dengan logging mulai terlihat seperti <a href="">ini</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::handle_not_transformed_image( transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> request_key, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> store_to = [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.insert( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request_key), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd) ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_inprogress_requests.has_key( request_key ) ) { <span class="hljs-comment"><span class="hljs-comment">//    . m_logger-&gt;debug( "same request is already in progress; request_key={}", request_key ); //         . store_to( m_inprogress_requests ); } else if( m_pending_requests.has_key( request_key ) ) { //      . m_logger-&gt;debug( "same request is already pending; request_key={}", request_key ); store_to( m_pending_requests ); } else if( m_pending_requests.unique_keys() &lt; max_pending_requests ) { //           . m_logger-&gt;debug( "store request to pending requests queue; request_key={}", request_key ); store_to( m_pending_requests ); //    transformer-     . try_initiate_pending_requests_processing(); } else { //  ,   . m_logger-&gt;warn( "request is rejected because of overloading; " "request_key={}", request_key ); do_503_response( std::move(cmd-&gt;m_http_req) ); } }</span></span></code> </pre> <br><h2>  Mengkonfigurasi logger spdlog </h2><br>  Masuk ke udang dilakukan di konsol (mis. Dalam aliran keluaran standar).  Pada prinsipnya, seseorang dapat menempuh jalan yang sangat sederhana dan menciptakan di Udang satu-satunya contoh dari spd-logger.  Yaitu  seseorang dapat memanggil <a href="">stdout_color_mt</a> (atau <a href="">stdout_logger_mt</a> ), dan kemudian meneruskan pencatat ini ke semua entitas di Shrimp.  Tapi kami pergi sedikit lebih rumit: kami secara manual menciptakan apa yang disebut  sink (mis. saluran tempat spdlog akan menampilkan pesan yang dihasilkan), dan untuk entitas Udang mereka membuat logger terpisah yang melekat pada sink ini. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     . [[nodiscard]] spdlog::sink_ptr make_logger_sink() { auto sink = std::make_shared&lt; spdlog::sinks::ansicolor_stdout_sink_mt &gt;(); return sink; } [[nodiscard]] std::shared_ptr&lt;spdlog::logger&gt; make_logger( const std::string &amp; name, spdlog::sink_ptr sink, spdlog::level::level_enum level = spdlog::level::trace ) { auto logger = std::make_shared&lt; spdlog::logger &gt;( name, std::move(sink) ); logger-&gt;set_level( level ); logger-&gt;flush_on( level ); return logger; } //        : auto manager = coop.make_agent_with_binder&lt; a_transform_manager_t &gt;( create_one_thread_disp( "manager" )-&gt;binder(), make_logger( "manager", logger_sink ) ); ... const auto worker_name = fmt::format( "worker_{}", worker ); auto transformer = coop.make_agent_with_binder&lt; a_transformer_t &gt;( create_one_thread_disp( worker_name )-&gt;binder(), make_logger( worker_name, logger_sink ), app_params.m_storage );</span></span></code> </pre><br>  Ada titik halus dengan mengkonfigurasi logger di spdlog: secara default, logger mengabaikan pesan dengan tingkat keparahan penelusuran dan debug.  Yaitu, mereka terbukti sangat berguna saat debugging.  Oleh karena itu, di make_logger, kami secara default mengaktifkan pencatatan untuk semua level, termasuk jejak / debug. <br><br>  Karena fakta bahwa setiap entitas di Shrimp memiliki logger sendiri dengan namanya sendiri, kita dapat melihat siapa yang melakukan apa dalam log: <br><br><img src="https://habrastorage.org/webt/1o/jh/yx/1ojhyxgywovfstlfsybe19h0lb0.png"><br><br><h2>  Menelusuri SObjectizer dengan spdlog </h2><br>  Waktu pencatatan, yang dilakukan sebagai bagian dari logika bisnis utama aplikasi SObjectizer, tidak cukup untuk melakukan debug aplikasi.  Tidak jelas mengapa beberapa tindakan dimulai pada satu agen, tetapi sebenarnya tidak dilakukan pada agen lain.  Dalam hal ini, mekanisme msg_tracing yang dibangun ke dalam SObjectizer banyak membantu (yang telah kita bahas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam artikel terpisah</a> ).  Tetapi di antara implementasi msg_tracing standar untuk SObjectizer, tidak ada yang menggunakan spdlog.  Kami akan melakukan implementasi ini untuk Udang sendiri: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">spdlog_sobj_tracer_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::msg_tracing::<span class="hljs-keyword"><span class="hljs-keyword">tracer_t</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; m_logger; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">spdlog_sobj_tracer_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; logger ) : m_logger{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(logger) } {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; what )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> override </span></span>{ m_logger-&gt;trace( what ); } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> so_5::msg_tracing::<span class="hljs-keyword"><span class="hljs-keyword">tracer_unique_ptr_t</span></span> make( spdlog::sink_ptr sink ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;<span class="hljs-keyword"><span class="hljs-keyword">spdlog_sobj_tracer_t</span></span>&gt;( make_logger( <span class="hljs-string"><span class="hljs-string">"sobjectizer"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(sink) ) ); } };</code> </pre> <br>  Di sini kita melihat implementasi antarmuka SObjectizer khusus tracer_t, di mana yang utama adalah metode virtual trace ().  Dialah yang melakukan penelusuran internal SObjectizer melalui spdlog. <br><br>  Selanjutnya, implementasi ini diinstal sebagai pelacak ketika memulai SObjectizer: <br><br><pre> <code class="cpp hljs">so_5::<span class="hljs-keyword"><span class="hljs-keyword">wrapped_env_t</span></span> sobj{ [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) {...}, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">sobj_tracing_t</span></span>::on == sobj_tracing ) params.message_delivery_tracer( <span class="hljs-keyword"><span class="hljs-keyword">spdlog_sobj_tracer_t</span></span>::make( logger_sink ) ); } };</code> </pre> <br><h2>  RESTinio melacak melalui spdlog </h2><br>  Selain melacak apa yang terjadi di dalam SObjectizer, terkadang sangat berguna untuk melacak apa yang terjadi di dalam RESTinio.  Dalam versi udang yang diperbarui, jejak semacam itu juga ditambahkan. <br><br>  Jejak ini diimplementasikan melalui definisi kelas khusus yang dapat melakukan logging di RESTinio: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">http_server_logger_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">http_server_logger_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; logger ) : m_logger{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( logger ) } {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::trace, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::info, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">warn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::warn, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::err, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log_if_enabled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( spdlog::level::level_enum lv, Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_logger-&gt;should_log(lv) ) { m_logger-&gt;<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>( lv, msg_builder() ); } } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; m_logger; };</code> </pre> <br>  Kelas ini tidak diwarisi dari apa pun, karena mekanisme logging di RESTinio didasarkan pada pemrograman umum, dan bukan pada pendekatan berorientasi objek tradisional.  Itu memungkinkan Anda untuk benar-benar menghilangkan overhead apa pun dalam kasus di mana penebangan tidak diperlukan sama sekali (kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membahas</a> topik ini lebih detail ketika kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbicara tentang menggunakan templat di RESTinio</a> ). <br><br>  Selanjutnya, kita perlu menunjukkan bahwa server HTTP akan menggunakan kelas http_server_logger_t yang ditunjukkan di atas sebagai logger-nya.  Ini dilakukan dengan mengklarifikasi properti dari server HTTP: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">http_server_traits_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">http_server_logger_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">request_handler_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">http_req_router_t</span></span>; };</code> </pre> <br>  Nah, maka tidak ada lagi yang harus dilakukan - buat instance spesifik dari spd-logger dan kirim logger ini ke server HTTP yang dibuat: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> restinio_logger = make_logger( <span class="hljs-string"><span class="hljs-string">"restinio"</span></span>, logger_sink, <span class="hljs-keyword"><span class="hljs-keyword">restinio_tracing_t</span></span>::off == restinio_tracing ? spdlog::level::off : log_level ); restinio::run( asio_io_ctx, shrimp::make_http_server_settings( thread_count.m_io_threads, params, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(restinio_logger), manager_mbox_promise.get_future().get() ) );</code> </pre> <br><h1>  v0.5: reset paksa cache gambar yang diubah </h1><br>  Dalam proses debug Shrimp, satu hal kecil ditemukan yang sedikit mengganggu: untuk menyiram konten cache gambar yang diubah, Anda harus me-restart seluruh Shrimp.  Tampaknya hal itu sepele, tetapi tidak menyenangkan. <br><br>  Jika tidak menyenangkan, maka Anda harus menyingkirkan kekurangan ini.  Untungnya, ini sama sekali tidak sulit. <br><br>  Pertama, kami akan mendefinisikan URL lain di Shrimp tempat Anda dapat mengirim permintaan HTTP DELETE: "/ cache".  Karenanya, kami akan menggantung penangan kami di URL ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">http_req_router_t</span></span> &gt; make_router( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">app_params_t</span></span> &amp; params, so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> req_handler_mbox ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> router = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt; <span class="hljs-keyword"><span class="hljs-keyword">http_req_router_t</span></span> &gt;(); add_transform_op_handler( params, *router, req_handler_mbox ); add_delete_cache_handler( *router, req_handler_mbox ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> router; }</code> </pre> <br>  di mana fungsi add_delete_cache_handler () terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_delete_cache_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">http_req_router_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; router, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_handler_mbox )</span></span></span><span class="hljs-function"> </span></span>{ router.http_delete( <span class="hljs-string"><span class="hljs-string">"/cache"</span></span>, [req_handler_mbox]( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-comment"><span class="hljs-comment">/*params*/</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> qp = restinio::parse_query( req-&gt;header().query() ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> token = qp.get_param( <span class="hljs-string"><span class="hljs-string">"token"</span></span>sv ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !token ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_403_response( req, <span class="hljs-string"><span class="hljs-string">"No token provided\r\n"</span></span> ); } <span class="hljs-comment"><span class="hljs-comment">// Delegate request processing to transform_manager. so_5::send&lt; so_5::mutable_msg&lt;a_transform_manager_t::delete_cache_request_t&gt; &gt;( req_handler_mbox, req, restinio::cast_to&lt;std::string&gt;(*token) ); return restinio::request_accepted(); } ); }</span></span></code> </pre> <br>  Sedikit bertele-tele, tapi tidak ada yang rumit.  String kueri dari kueri harus memiliki parameter token.  Parameter ini harus berisi string dengan nilai khusus untuk token administratif.  Anda hanya dapat mengatur ulang cache jika nilai token dari parameter token cocok dengan apa yang ditetapkan saat Shrimp diluncurkan.  Jika tidak ada parameter token, permintaan pemrosesan tidak diterima.  Jika ada token, maka agen transform_manager, yang memiliki cache, dikirimi pesan perintah khusus, dengan mengeksekusi agen transform_manager itu sendiri yang akan menanggapi permintaan HTTP. <br><br>  Kedua, kami menerapkan penangan pesan baru delete_cache_request_t di agen transform_manager_t: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_delete_cache_request( <span class="hljs-keyword"><span class="hljs-keyword">mutable_mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">delete_cache_request_t</span></span>&gt; cmd ) { m_logger-&gt;warn( <span class="hljs-string"><span class="hljs-string">"delete cache request received; "</span></span> <span class="hljs-string"><span class="hljs-string">"connection_id={}, token={}"</span></span>, cmd-&gt;m_http_req-&gt;connection_id(), cmd-&gt;m_token ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> delay_response = [&amp;]( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> response_text ) { so_5::send_delayed&lt; so_5::mutable_msg&lt;<span class="hljs-keyword"><span class="hljs-keyword">negative_delete_cache_response_t</span></span>&gt; &gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds{<span class="hljs-number"><span class="hljs-number">7</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_http_req), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(response_text) ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * env_token = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::getenv( <span class="hljs-string"><span class="hljs-string">"SHRIMP_ADMIN_TOKEN"</span></span> ); <span class="hljs-comment"><span class="hljs-comment">// Token must be present and must not be empty. env_token &amp;&amp; *env_token ) { if( cmd-&gt;m_token == env_token ) { m_transformed_cache.clear(); m_logger-&gt;info( "cache deleted" ); do_200_plaintext_response( std::move(cmd-&gt;m_http_req), "Cache deleted\r\n" ); } else { m_logger-&gt;error( "invalid token value for delete cache request; " "token={}", cmd-&gt;m_token ); delay_response( "Token value mismatch\r\n" ); } } else { m_logger-&gt;warn( "delete cache can't performed because there is no " "admin token defined" ); // Operation can't be performed because admin token is not avaliable. delay_response( "No admin token defined\r\n" ); } }</span></span></code> </pre> <br>  Ada dua poin di sini yang harus diklarifikasi. <br><br>  Poin pertama dalam implementasi on_delete_cache_request () adalah verifikasi nilai token itu sendiri.  Token administratif diatur melalui variabel lingkungan SHRIMP_ADMIN_TOKEN.  Jika variabel ini disetel dan nilainya cocok dengan nilai dari parameter token permintaan HTTP DELETE, maka cache dihapus dan respons positif terhadap permintaan segera dihasilkan. <br><br>  Dan poin kedua dalam implementasi on_delete_cache_request () adalah penundaan respons negatif terhadap HTTP DELETE.  Jika nilai token administratif yang salah telah datang, maka Anda harus menunda respons terhadap HTTP DELETE sehingga tidak ada keinginan untuk memilih nilai token dengan kekerasan.  Tetapi bagaimana cara membuat penundaan ini?  Lagi pula, memanggil std :: thread :: sleep_for () bukan pilihan. <br><br>  Di sinilah pesan SObjectizer yang tertunda datang untuk menyelamatkan.  Alih-alih segera menghasilkan respons negatif di dalam on_delete_cache_request (), agen transform_manager mengirimkan sendiri pesan negative_delete_cache_response_t yang tertunda.  Timer SObjectizer akan menghitung waktu yang ditentukan dan mengirimkan pesan ini ke agen setelah penundaan yang ditentukan berlalu.  Dan sekarang di handler negative_delete_cache_response_t, Anda sudah dapat segera menghasilkan respons terhadap permintaan HTTP DELETE: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_negative_delete_cache_response( <span class="hljs-keyword"><span class="hljs-keyword">mutable_mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">negative_delete_cache_response_t</span></span>&gt; cmd ) { m_logger-&gt;debug( <span class="hljs-string"><span class="hljs-string">"send negative response to delete cache request; "</span></span> <span class="hljs-string"><span class="hljs-string">"connection_id={}"</span></span>, cmd-&gt;m_http_req-&gt;connection_id() ); do_403_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_http_req), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_response_text) ); }</code> </pre> <br>  Yaitu  ternyata skenario berikut: <br><br><ul><li>  Server HTTP menerima permintaan HTTP DELETE, mengubah permintaan ini menjadi pesan delete_cache_request_t ke agen transform_manager; </li><li>  agen transform_manager menerima pesan delete_cache_request_t dan segera menghasilkan respons positif terhadap permintaan atau mengirim sendiri pesan negative_delete_cache_response_t yang tertunda; </li><li>  transform_manager menerima pesan negative_delete_cache_response_t dan segera menghasilkan respons negatif terhadap permintaan HTTP DELETE yang sesuai. </li></ul><br><h1>  Akhir dari bagian kedua </h1><br>  Pada akhir bagian kedua, wajar untuk mengajukan pertanyaan: "Apa selanjutnya?" <br><br>  Selanjutnya, mungkin akan ada iterasi lain dan pembaruan proyek demo kami.  Saya ingin melakukan hal seperti mengubah gambar dari satu format ke format lainnya.  Katakanlah, di server, gambar di jpg, dan setelah transformasi, dikirim ke klien di webp. <br><br>  Juga akan menarik untuk melampirkan "halaman" terpisah dengan tampilan statistik terkini tentang karya Udang.  Pertama-tama, ini hanya ingin tahu.  Namun, pada prinsipnya, halaman seperti itu juga dapat disesuaikan untuk kebutuhan pemantauan kelangsungan hidup udang. <br><br>  Jika ada orang lain yang memiliki saran tentang apa yang ingin saya lihat di Udang atau di artikel di sekitar Udang, maka kami akan senang mendengar pemikiran konstruktif. <br><br>  Secara terpisah, saya ingin mencatat satu aspek dalam penerapan udang, yang agak mengejutkan kami.  Ini adalah penggunaan aktif pesan yang bisa berubah saat berkomunikasi satu sama lain dan server HTTP.  Biasanya, dalam praktik kami, yang terjadi adalah sebaliknya - lebih sering data dipertukarkan melalui pesan imun.  Tidak demikian di sini.  Ini menunjukkan bahwa kami dengan sengaja mendengarkan keinginan pengguna pada waktunya dan menambahkan pesan yang dapat diubah ke SObjectizer.  Jadi, jika Anda ingin melihat sesuatu di RESTinio atau SObjectizer, silakan bagikan ide Anda.  Kami yakin akan mendengarkan yang baik. <br><br>  Yah, dan sebagai kesimpulan, saya ingin mengucapkan terima kasih kepada semua orang yang meluangkan waktu dan berbicara tentang versi pertama udang, baik di sini di Habr√© dan melalui sumber daya lainnya.  Terima kasih <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dilanjutkan ...</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417527/">https://habr.com/ru/post/id417527/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417511/index.html">Intel Mengakuisisi eASIC - Pengembang ASIC Struktural</a></li>
<li><a href="../id417513/index.html">Analog dengan Python dan JavaScript. Bagian dua</a></li>
<li><a href="../id417515/index.html">Apa yang saya pelajari dengan membuat 100 game dalam 5 tahun</a></li>
<li><a href="../id417517/index.html">Halaman sejarah Intel. Foto Kronik dan Kuis</a></li>
<li><a href="../id417521/index.html">Tinjau sertifikat SSL untuk pencabutan</a></li>
<li><a href="../id417529/index.html">Tiga tren teknologi yang mengubah perdagangan dan konsumen</a></li>
<li><a href="../id417531/index.html">Bagaimana kami menang di SmartMailHack 2</a></li>
<li><a href="../id417533/index.html">Notepad pada Windows menerima pembaruan signifikan pertama dalam dua dekade</a></li>
<li><a href="../id417535/index.html">Apakah pengembangan CUBA merupakan langkah besar dari Spring?</a></li>
<li><a href="../id417537/index.html">"Game Anda membosankan," atau cara meningkatkan Retensi yang sudah tinggi di hari pertama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>