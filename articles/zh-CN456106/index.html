<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏾 👗 ⛓️ 我们更快地划分功能。 Badoo的Android开发经验 🍁 📯 📅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好！ 我叫Anatoly Varivonchik。 我已经在Badoo工作了一年多，而我在Android方面的总体开发经验已经超过五年。 

 在我的实践中，我和我的同事经常面临着尽可能快速，简单地测试想法的需求。 我们不想在实现上花费很多精力，因为我们知道，如果实验不成功，那么我们将扔掉代码。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们更快地划分功能。 Badoo的Android开发经验</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/456106/"> 大家好！ 我叫Anatoly Varivonchik。 我已经在Badoo工作了一年多，而我在Android方面的总体开发经验已经超过五年。 <br><br> 在我的实践中，我和我的同事经常面临着尽可能快速，简单地测试想法的需求。 我们不想在实现上花费很多精力，因为我们知道，如果实验不成功，那么我们将扔掉代码。 <br><br> 在本文中，我将通过实际示例展示在这种情况下我们如何行动以及哪些原则可以帮助我们做出选择，以选择特定的问题解决方案。 对示例的分析应该有助于理解我们的思维方式：您有时如何偷工减料，加快开发速度。 <br><br><img src="https://habrastorage.org/webt/j4/05/-q/j405-qdbd1fun1e6uxwa4lpzm2e.jpeg"><br><a name="habracut"></a><br> 计划是这样的： <br><br><ol><li>  Badoo中的开发方法原理。 <br></li><li> 案例研究。 <br></li><li> 设计系统。 <br></li><li> 何时应用所述原理。 <br></li></ol><br> 本文是我在AppsConf上的报告的文本版本，可在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>查看视频。 <br><br><h2> 发展方针原则 </h2><br> 数以亿计的人使用Badoo，因此，如果我们不确定用户是否会喜欢它并证明其有用性，那么我们将无法推出新功能。 <br><br> 我们的开发方法受到几个因素的影响。 <br><br><h3> 使用A / B测试 </h3><br> 今天，我们在移动平台上进行了数十项A / B测试，而数百项已经完成。 因此，如果您在两个不同的设备上使用Badoo应用程序，则它们之间的差异很大，乍一看可能看不到。 <br><br> 为什么我们需要A / B测试？ 重要的是要了解，产品经理认为哪些是必要的，甚至对我们而言似乎显而易见的，在现实中并不总是有用的。 有时我们必须删除一个月或两个月前编写的代码。 有时，为了了解新功能是否合适，测试新功能的想法很有意义。 如果用户喜欢该功能，那么我们已经可以在其开发上投入时间。 <br><br><h3> 降低开发成本 </h3><br> 当然，我们希望一切都能快速进行并变得美丽。 但是，并非总是能够在短时间内实现这一目标。 有时需要很多天。 为了避免这些问题，我们尝试通过预先评估任务成本并指出我们难以做到的事情和容易做到的事情来帮助产品经理。 <br><br><h3> 大多数用户规则 </h3><br> 想象一下，您拥有一个可以在所有设备上的所有场景下完美运行的功能，但是同时有一群使用中文设备的用户无法正常运行。 在这种情况下，可能不值得尽快解决问题，因为您最有可能承担更重要的任务。 <br><br><h2> 我们如何加快发展 </h2><br> 让我们看一些说明这些原理如何工作的示例。 在这里，我们将介绍我们在工作中遇到的实际案例以及解决方案。 <br><br> 首先，我建议您自己考虑如何解决这种情况。 然后，我将考虑每个选项，并解释为什么会出现/不适合我们的情况。 <br><br><h3> 例子1.进度累积按钮 </h3><br><br> 我们需要向用户展示圆角从0到1的电池进度累积贷款的过程。 <br><br><img width="340" src="https://habrastorage.org/webt/wa/no/nd/wanondml_lpwipzf1pfkjn6omji.jpeg"><br><br> 解决方案有哪些？ <br><br><img src="https://habrastorage.org/webt/16/vt/_4/16vt_4nepdnd6ugkjocwqqtrvbw.png"><br><br> 选项A。我们不需要此图标。 我们必须要求设计师重做功能。 让这里只显示一些文本。 <br> 选项B。使用位图蒙版。 通过正确的组合，我们可以准确地满足我们的需求。 <br><br><img src="https://habrastorage.org/webt/7e/wk/np/7ewknpgdavuhbbdmqueabnn4axm.jpeg"><br><br> 选项C：只需要几个图标，在客户端上对其进行硬编码，然后显示其中一个即可。 <br><br><img src="https://habrastorage.org/webt/po/vb/6b/povb6b07roe0epnevfflyzhmsam.jpeg"><br><br> 在我们的案例中，我们来到了解决方案B和C。我们将详细讨论。 <br><br><img src="https://habrastorage.org/webt/rg/f7/1r/rgf71rowbzy4ujjbqnrtdmte0ew.png"><br><br> 为什么不<b>选择选项A</b> ？ 我们可以解决这个特定的问题，它并不复杂。 我们在iOS和移动网络中使用相同的设计。 因此，没有理由拒绝说我们不这样做，而我们需要提出不同的设计。 <br><br><img width="790" src="https://habrastorage.org/webt/xh/jr/lx/xhjrlxoqy_aq0mpkoehcxvrg9w4.jpeg"><br><br> 位图掩码（ <b>选项B</b> ）是解决此问题的理想解决方案。 我们可以轻松地绘制一个圆角矩形。 我们可以轻松地在所需填充百分比上绘制一个常规矩形。 仍然可以混合它们并设置正确的设置。 之后，左侧的两个角都将消失。 <br><br><img width="300" src="https://habrastorage.org/webt/zy/nd/ko/zyndkob2eh87j9sndzk4pr2wogk.jpeg"><br><br> 在代码中，它看起来像这样： <br><br><pre><code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GoalInProgress</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> progress: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> unchargedPaint = Paint().apply { xfermode = PorterDuffXfermode(PorterDuff.Mode.MULTIPLY) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mixChargedAndUncharged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(canvas: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Canvas</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { drawFullyCharged(canvas) drawUnchargedPart(canvas) }</code> </pre> <br><br> 我删除了大部分代码。 在文章中阅读有关位图蒙版的更多信息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//habr.com/en/company/badoo/blog/310618/</a> 。 您还将从中学习如何混合使用蒙版，要实现什么效果以及它在性能方面如何工作。 <br><br> 该解决方案100％满足我们的要求，也就是说，可以显示从0到1的进度。 <br><br> 唯一的缺点：如果您以前从未这样做过，那么您将不得不花费时间找出位图蒙版。 此外，您仍然必须与它们一起玩，查看边缘情况并进行测试。 我认为整个过程大约需要四个小时。 <br><br> 选项C。我们只采用几种固定类型的图标，并根据进度显示其中一种。 例如，如果用户的进度小于0.5，则将显示一个空图标。 显然，此解决方案不能满足100％的要求。 但是对于其实现，您只需要编写五行代码并从设计者那里获得三个图标。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBackground</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(goal: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GoalInProgress</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (goal.progress) { <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span>..<span class="hljs-number"><span class="hljs-number">0.5</span></span> -&gt; R.drawable.ic_not_filled <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.5</span></span>..<span class="hljs-number"><span class="hljs-number">0.99</span></span> -&gt; R.drawable.ic_half_filled <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; R.drawable.ic_full_filled }</code> </pre><br><br> 此外，在严重缺乏时间的情况下（如发布实时功能时的情况），该解决方案是最佳的。 它并不需要很多时间-您只需将其推出并在下一版本中将其替换为正确的精美解决方案即可。 实际上，就像我们当时所做的那样。 <br><br><h3> 例子2.输入电话号码的行 </h3><br> 下一个示例是输入电话号码。 特色： <br><br><ul><li> 国家/地区前缀在左侧； <br></li><li> 前缀不能删除； <br></li><li> 有凹痕； <br></li><li> 前缀不可点击。 <br></li></ul><br><br><img width="340" src="https://habrastorage.org/webt/l7/cf/pi/l7cfpix6yyq-ulezvhrl-mkh_na.jpeg"><br><br> 让我们考虑一下如何实现。 <br><br><img src="https://habrastorage.org/webt/nu/rr/tp/nurrtpdw5b4wkifxs1xsgqjcib4.png"><br><br> 选项A：编写实现所需逻辑的自定义TextWatcher。 它将保留此前缀，保留空格，控制光标位置。 <br><br> 选项B：将此组件分为两个独立的字段。 从UI的角度来看，它将是相同的组件。 <br><br> 选项C：要求采用其他设计以使我们更轻松。 <br><br><img width="450" src="https://habrastorage.org/webt/jr/pq/dy/jrpqdyo3wdmo256pjj_zrtjtdn4.jpeg"><br><br> 我们决定实施选项B。更详细地考虑。 <br><br><img src="https://habrastorage.org/webt/xq/fx/_1/xqfx_1ha8yvjjho40yko80njaxg.png"><br><br> 要求不同的设计（选项C）是我们试图做的第一件事。 但是，产品坚持最初的想法。 如果企业坚持某种功能，那么我们的任务就是实施它。 <br><br> 乍一看，自定义TextWatcher（选项A）似乎是一个简单的解决方案，但实际上，有许多边缘情况需要处理。 例如，您需要： <br><br><ul><li> 以某种方式拦截单击前缀，然后更改光标位置； <br></li><li> 另外缩进； <br></li><li> 禁止删除，以使用户无法删除国家的空格或前缀。 <br></li></ul><br><br> 当然，做到所有这些都是可能的，但是相当困难。 似乎有一个更简单的选择。 <br><br> 他真的被发现了： <br><br><pre> <code class="kotlin hljs">&lt;merge xmlns:android=<span class="hljs-string"><span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span> tools:parentTag=<span class="hljs-string"><span class="hljs-string">"android.widget.LinearLayout"</span></span>&gt; &lt;TextView android:id=<span class="hljs-string"><span class="hljs-string">"@+id/country_code"</span></span> /&gt; &lt;EditText android:id=<span class="hljs-string"><span class="hljs-string">"@+id/phone_number"</span></span> /&gt; &lt;/merge&gt;</code> </pre><br><br> 我们仅将该组件分为两部分：TextView和EditText。 以编程方式，在TextView上，我们以某种方式设置背景，以便准确地获得产品期望的设计。 <br><br> 唯一值得考虑的是，在Android中，默认情况下，当EditText成为焦点时，底线的宽度会增加。 但是，我们可以轻松地关注焦点变化并更改背景的前缀。 没什么复杂的： <br><br><pre> <code class="kotlin hljs">phoneNumber.setOnFocusChangeListener { _, hasFocus -&gt; countryCode.setBackgroundResource(background(hasFocus)) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">background</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hasFocus: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (hasFocus) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; R.drawable.phone_input_active <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; R.drawable.phone_input_inactive }</code> </pre><br><br> 该解决方案具有以下优点： <br><br><ul><li> 无需处理对前缀的点击； <br></li><li> 无需处理光标位置-它始终位于单独的字段中。 <br></li><li> 这种实现方式很少出现边缘情况和问题。 <br></li></ul><br><br><h3> 例子3.自动完成的问题 </h3><br> 如您在左侧动画中所见，自动完成功能无法按我们希望的那样工作。 我们希望一切看起来像右边的动画。 <br><br><img width="270" src="https://habrastorage.org/webt/dd/r0/jy/ddr0jy5albxedofracf0ojmbdvy.gif"><img width="270" align="right" src="https://habrastorage.org/webt/t6/7v/jr/t67vjrxcqu-ud4cgzuc1ir_g764.gif"><br><br> 让我们考虑一下我们可以做些什么。 <br><br><img src="https://habrastorage.org/webt/xs/lb/m4/xslbm4wy8naisuohjx1_aqe-62i.png"><br><br> 选项A：这似乎是一种罕见的情况，没有人解决。 我们为什么不这样做？ <br><br> 选项B：自定义TextWatcher将做得更好，并解决了我们所有的问题。 <br><br> 选项C：取消字符数限制（如动画所示，此组件中有一定数量的字符）。 我们会将带有前缀的整个电话号码发送到服务器，然后让服务器确定该号码是否有效。 <br><br> 选项D：从末尾开始输入N个字符。 <br><br> 我们选择了选项D。 <br><br><img src="https://habrastorage.org/webt/qw/oz/hy/qwozhyv6y6w7bqf2pr_fcedtegg.png"><br><br> 选项A。我查看了几个大型应用程序。 似乎没有人修复它。 <br><br> 然而，将来越来越多的领域将充满自恋者。 您越早解决这个问题，您的用户就会越忠诚，您自己使用该应用程序就会越愉快。 例如，当我两次单击浏览整个屏幕时，我感到非常高兴。 <br><br> 选项B。实现自定义TextWatcher确实很容易，因为边缘脚本的数量不如上例所示。 您可以轻松拦截插入的文本。 只有一个小问题：在某些国家/地区，存在本地别名。 例如，+ 44和0表示同一件事。 <br><br> 自定义TextWatcher在这里无济于事。 在这种情况下，您需要编写其他逻辑，还要求服务器返回该国家/地区的所有可能的本地别名。 要解决此问题，您将必须更改与服务器的通信协议，然后在服务器上实现此功能。 这比在客户端上执行操作要花费更多时间。 似乎有一个更简单的解决方案（我们会来解决）。 <br><br> 选项C。我们取消字符数限制-然后服务器进行验证。 这是一个很好的选择。 可以将前缀显示两次。 如果用户继续进行下一步并且有效地确定了电话号码，则原则上不会有问题。 <br><br> 但是仍然有一个障碍。 假设用户不使用自动完成功能，而只是输入他的电话号码。 在这种情况下，如果字符数有限制，那么他意外地复制一个数字将变得更加困难-最终，他将看到最后一个数字没有被打印。 因此，我们决定不使用此方法。 <br><br> 选项D。从头开始使用N个字符对我们来说似乎是一个合适的解决方案。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DigitsTrimStartFilter</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> max: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) : InputFilter { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span>: CharSequence? { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s = source.subSequence(start, end).filter { it.isDigit() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> keep = max - (dest.length - (dend - dstart)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { keep &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">""</span></span> keep &gt;= s.length -&gt; <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-comment"><span class="hljs-comment">// keep original else -&gt; s.subSequence(s.length - keep, s.length) } } }</span></span></code> </pre><br><br> 我们拥有可以插入的电话号码的最大长度。 我们正在编写一个简单的类，它被封装并且可以在其他地方重用。 此外，当任何其他开发人员看到该代码时，他将迅速弄清楚是什么。 但是还有另外两个问题。 <br><br> 首先，有些国家的电话号码不同。 在这种情况下，我们的解决方案将在前缀旁边显示一个额外的数字。 其次，如果用户使用自动文件为另一个国家/地区插入前缀，则可能会发生同样的情况。 第二种情况对我们来说似乎很罕见，因为服务器最初会根据用户所在的国家/地区返回电话号码。 但是，如果我们知道这是一个问题，我们将不得不更改服务器上的协议，以便它一次返回所有数字的列表，并编写其他逻辑（现在我们不再认为这是必需的）。 <br><br><h3> 例子4.日期输入组件 </h3><br> 设计师和产品希望看到一个用于输入日期的掩码，如下所示： <br><br><img width="340" src="https://habrastorage.org/webt/vl/yz/xf/vlyzxfaqihmcgev2rcvmp0owiis.jpeg"><br><br> 让我们考虑一下如何实现。 <br><br><img src="https://habrastorage.org/webt/di/fa/e6/difae608vbmz6jrgoxs-hddfu_i.jpeg"><br><br> 选项A：随便做吧。 任务看起来很简单，很容易解决，不会出现任何问题。 <br><br> 选项B：使用遮罩库。 在这种情况下，她适合我们。 <br><br> 选项C：禁用对光标位置的控制。 因此，我们稍微简化了需求，并且使我们更容易实现此功能。 <br><br> 选项D：使用我们都看到的Android上的标准日期输入组件。 <br><br> 我们来到选项C。 <br><br><img src="https://habrastorage.org/webt/es/ba/5g/esba5g6zv2lbx05rkoqmanidxf8.png"><br><br> 选项A。任务似乎很简单。 当然，我们不是第一个实现此功能的人。 为什么不看看互联网上是否有合适的解决方案。 <br><br><img src="https://habrastorage.org/webt/u6/dh/qt/u6dhqtp8ya0jvj0ydzr-c0wn_qg.jpeg"><br><br> 我们采用此解决方案，将其添加到代码中，然后运行它。 我们开始测试： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTextChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CharSequence</span></span></span></span><span class="hljs-function"><span class="hljs-params">, start: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, before: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, count: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edited) { edited = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> working = getEditText() working = manageDateDivider(working, <span class="hljs-number"><span class="hljs-number">2</span></span>, start, before) working = manageDateDivider(working, <span class="hljs-number"><span class="hljs-number">5</span></span>, start, before) edited = <span class="hljs-literal"><span class="hljs-literal">true</span></span> input.setText(working) input.setSelection(input.text.length) }</code> </pre><br><br> 乍一看，它似乎或多或少适合我们。 没错，在每次更改后光标位置跳到末尾都是有问题的。 然后，我们开始进行更仔细的测试，并了解一切都不太好，并且存在无法解释的情况。 <br><br><img width="270" src="https://habrastorage.org/webt/9o/ll/da/9olldaduvxfxwjy_db17-bjhahg.gif"><br><br> 我们都需要完善这一点。 我想避免这种情况，因为这是测试人员的工作，然后我们的工作是修复错误等。 <br><br> 选项B：为什么不使用现成的库作为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">装饰</a>蒙版或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">输入蒙版android</a> ？ 他们测试了所有场景，您可以重用一切并享受生活。 如果您的项目中有用于遮罩的库，或者准备添加它，那么这是一个很好的解决方案。 <br><br> 我们没有图书馆。 为了一个很小的组件而将其拖到项目中，而这个组件在其他任何地方都没有使用，这似乎是多余的。 <br><br> 选项D。使用标准日期输入组件。 <br><br><img width="270" src="https://habrastorage.org/webt/2s/yh/sc/2syhsccrbwmk8ehpzrjf9hjutb0.jpeg"><br><br> 这似乎是最聪明的解决方案。 除了一个小缺陷，他一切都很好。 当您打开此组件时，您已经有一些预定义的值和一些有效的日期。 如果您设置一个有效的日期进行下一步，例如1980年1月1日，那么您将收到当天出生的数百万用户。 否则，您将收到许多相同的错误：用户年龄太大或太小而无法注册。 <br><br> 因此，我们一次放弃了Badoo注册表中的标准日期输入对话框。 有关无效日期的错误数量已减少了三倍。 <br><br><img src="https://habrastorage.org/webt/dj/eq/so/djeqso1wn5je1ufk1eh2ry6yyse.jpeg"><br><br> 还有一个小的减号。 似乎只有高级用户才能从第一种状态转移到第二种状态： <br><br><img src="https://habrastorage.org/webt/sb/jn/fy/sbjnfyufnm6suhfdp0j4ta1obdw.jpeg"><br><br> 如果不仅高级用户使用您的应用程序，他们还将逐月排序以查找所需日期。 <br><br> 因此，我们认为选项A还不错。 您只需要对其进行优化和简化即可： <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DateEditText</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatEditText</span></span></span></span>(context, attrs, defStyleAttr) { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> canChange: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> actualText: StringBuilder = StringBuilder() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSelectionChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(selStart: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, selEnd: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onSelectionChanged(selStart, selEnd) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!canChange) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> canChange = <span class="hljs-literal"><span class="hljs-literal">false</span></span> setSelection(actualText.length) canChange = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre><br><br> 当用户更改光标位置时，选项A的缺点开始出现。 我们想到：“为什么要给这个机会移动光标？” 并被禁止这样做。 <br><br><img width="270" src="https://habrastorage.org/webt/dc/yr/u9/dcyru9gqgi_pfivmtezqngwpbji.gif"><br><br> 因此，我们解决了所有问题。 产品具有适合他们的实现。 并且如果将来他们决定您仍然需要机会从中间删除字符，我们会做到的。 <br><br><h2> 例子5.视频流屏幕上的工具 </h2><br> 在开始视频流传输时，这些产品希望显示工具提示，以教用户如何使用该功能。 <br><br> 在实现功能时，我们有六种工具提示。 同时，屏幕上不应有多个。 工具提示会在随机时间从服务器动态到达。 有些必须重复。 如果出现了工具提示，但用户没有单击它，则N分钟后应该会再次出现。 <br><br><img width="270" src="https://habrastorage.org/webt/pn/gu/gb/pngugbgj9p1cumd6f2bph2oiibu.gif"><br><br> 所有这些似乎很难实现。 我们问产品一些问题。 <br><br> 首先，添加分类器，对工具提示进行优先排序。 无论如何，当一个和另一个工具提示都希望同时出现并且必须选择其中之一时，就会出现这种情况。 因此，我们需要优先事项。 其次，我们要求进行一些简化：仅为最高优先级的工具提示保留一个计时器。 <br><br> 以前，工具提示重复计时器是独立的： <br><br><img width="450" src="https://habrastorage.org/webt/9k/cl/pc/9kclpch8wr2nse6tjimgtnazgzq.jpeg"><br><br> 我们要求仅针对优先级最高的工具提示支持计时器： <br><br><img width="450" src="https://habrastorage.org/webt/ql/j7/tk/qlj7tkhc7ksulwncmoihynm_acs.jpeg"><br><br> 因此，计时器仅对工具提示1起作用。对工具提示1来说，计时器一经删除，便开始了下一个过程。 <br><br><img width="450" src="https://habrastorage.org/webt/wj/3r/sf/wj3rsfbqcigjaggx_xfaim2108k.jpeg"><br><br> 因此，我们简化了需求：对于我们来说，实现该功能变得更加容易，对于测试人员来说，对其进行测试也更加容易。 最后，我们意识到这个决定适合每个人。 <br><br><h3> 例子6.重新排序照片 </h3><br> 这种设计来到了我们： <br><br><img width="270" src="https://habrastorage.org/webt/ua/ii/ab/uaiiabygcb6tb3c9o4f8fr4xasy.gif"><br><br> 我们得出的结论是，实施起来非常困难，我们将不得不花三天的时间进行开发，然后想到：“如果我们不知道用户是否需要它，为什么要这样做？” 我们建议从简化版本开始，然后评估此功能的需求量。 <br><br><img width="270" src="https://habrastorage.org/webt/tr/jc/27/trjc27ksolmheeqjdcaft2fqfli.gif"><br><br> 原来，用户对此功能感兴趣。 之后，我们将重新渲染改进为原始设计的状态。 <br><br> 总计： <br><br><ul><li> 我们保护了我们自己和公司，避免了花太多时间在可能无用的功能上的风险； <br></li><li> 结果，产品要求得到了全面实施。 <br></li></ul><br><br><h3> 例子7. PIN输入组件 </h3><br> 我们不仅在开发Badoo应用程序-我们还开发其他设计完全不同的应用程序。 在这三个应用程序中，我们使用相同的组件来输入PIN码： <br><br><img src="https://habrastorage.org/webt/z8/iy/pp/z8iyppehiujviyzg0on1wtbpdkg.jpeg"><br><br> 从UX的角度来看，组件的行为应相同。 但是，在不同的应用程序中，会使用不同的字体，缩进甚至不同的背景。 我不想将其复制到每个应用程序中，而是要重用它。 设计系统可以帮助我们。 <br><br><blockquote> 设计系统是一组关于某些组件的行为的UX规则。 例如，我们已经明确指出，每个按钮必须具有某些状态，并且必须以某种方式运行。 </blockquote><br><br><img src="https://habrastorage.org/webt/oc/sv/le/ocsvleusm3bq6b-jaba9122-luo.jpeg"><img src="https://habrastorage.org/webt/dl/nt/t0/dlntt0sqtc19x_xktrqjjpolkbm.jpeg"><img src="https://habrastorage.org/webt/hg/qe/7q/hgqe7qwelpnwkvloy0gibt9nfve.jpeg"><br><br> 您可以从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rudy Artyom</a>的报告中了解有关设计系统的更多信息。 <br><br> 同时，返回到PIN输入组件。 我们想要什么？ <br><br><ul><li> 正确的键盘行为； <br></li><li> 完全定制UI的能力，以使其在不同的应用程序中看起来有所不同； <br></li><li> 像常规EditText一样，从此组件接收标准数据流。 <br></li></ul><br><br><img width="270" src="https://habrastorage.org/webt/zz/rw/r3/zzrwr3rjaioiy_jsslvhgtx3bb0.gif"><br><br> 我们的解决方案有哪些？ <br><br><img src="https://habrastorage.org/webt/zl/ha/da/zlhada_7p7p65deqnejcrynfk1g.jpeg"><br><br> 选项A：使用四个单独的EditText，其中每个PIN元素将是一个单独的EditText。 <br><br> 选项B：使用一个EditText，增加一些创造力-并获得所需的东西。 <br><br> 我们选择了选项B。 <br><br><img src="https://habrastorage.org/webt/hg/xk/fd/hgxkfdhcqjsxyfopzuj1imxtcm4.jpeg"><br><br> 选项A。四个单独的EditText存在问题。  Android在所有方面都添加了额外的填充，我们需要正确处理。 此外，您将需要执行一次长按操作，以便用户删除整个PIN码。 我们将不得不手动处理焦点并处理字符删除。 似乎相当复杂。 <br><br> 因此，我们决定作弊，并创建了一个不可见的EditText，其大小为0乘以0，它将作为数据源： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createActualInput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lengthCount: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = EditText(context) .apply { inputType = InputType.TYPE_CLASS_NUMBER isClickable = <span class="hljs-literal"><span class="hljs-literal">false</span></span> maxHeight = <span class="hljs-number"><span class="hljs-number">0</span></span> maxWidth = <span class="hljs-number"><span class="hljs-number">0</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0F</span></span> addOrUpdateFilter(InputFilter.LengthFilter(lengthCount)) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPinItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(count: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { actualText = createActualInput(count) actualText.textChanges() .subscribe { updatePins(it.toString()) pinChangesRelay.accept(it) } overlay.clicks().subscribe { focus() } }</code> </pre><br><br>  PIN码的每一位都将以编程方式添加。 因此，我们可以绘制任何类型的UI，放置任何缩进等。在用户单击组件之后，我们将焦点放在EditText中。 因此，我们得到了一个可以正常工作的键盘。 <br><br> 另外，我们订阅以更改不可见EditText的文本并将其显示在UI上。 之后，我们很容易从该组件中获取数据流。 实际上，我们重用了标准的Android EditText，只是稍微添加了必要的逻辑。 <br><br><h2> 总结 </h2><br> 这些原则并非始终适用。 我会给您提供条件，使其可以正常工作。 <br><br><ul><li> 开发人员具有<b>影响功能</b>的<b>能力</b> 。 否则，他只需要完成任务即可。 <br></li><li> 开发人员在一家<b>产品公司</b>工作，该<b>公司</b> <b>积极地共享和发布功能</b> ，并<b>迅速检查有关这些功能的假设</b> 。 在这种情况下，这些原则将得到充分体现，因为从一开始，我们再也无法百分百确定哪些更新将使用户满意，而哪些更新将使用户不​​满意。 <br></li><li> 开发人员具有<b>分解任务</b>的<b>能力</b> 。 在产品经理和开发人员进行双向交流的情况下，这些原则是合乎逻辑的解决方案，使双方都可以找到可以并且应该重做的内容。 <br></li><li>  <b>外包</b> 。 在极少数情况下，客户可能会对提案感兴趣，例如，通过简化部分功能来减少完成任务所需的时间。 <br></li></ul><br><br> 如何使用这些原则？ 不幸的是，在上下文之外，很难提出任何建议。 但是，我建议您注意以下事项。 <br><br> 在大多数示例中，您可能对UI / UX有问题，或者在工具提示示例中，可能对业务逻辑有问题。 您需要尝试将任务分解为几个小的子任务，然后对其进行评估。 <br><br> 之后，您可以准确地找到问题所在。 接下来，您与同事讨论如何解决他们。 也许可以简化一些事情。 或者，也许您只是不了解同事已经知道的一些简单解决方案。 在下一阶段，您将与产品协调替代解决方案。 如果他们满意，请执行您的报价。 <br><br> 我想补充一点，所有人有时都会犯错。 ,   ,      . ,      iOS. ,          .      ,       .             .  ,  Win-Win   . <br><br>     : <br><br><ul><li> GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/Nublo</a> ; <br></li><li> Telegram: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://t.me/anatolv</a> ; <br></li><li>      (   :)): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://vk.com/london_relocate</a> . <br></li></ul><br> PS ,       . ,   ,   .   — ,           .          ?    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN456106/">https://habr.com/ru/post/zh-CN456106/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN456094/index.html">我们阅读了数据手册2：STM32上的SPI; STM8上的PWM定时器和中断</a></li>
<li><a href="../zh-CN456096/index.html">极客时间平均读者在云中徘徊时的行为</a></li>
<li><a href="../zh-CN456100/index.html">现在采用新包装-M.2格式的金士顿A400急于上市</a></li>
<li><a href="../zh-CN456102/index.html">易于在C / C ++中进行报告</a></li>
<li><a href="../zh-CN456104/index.html">Ezblock Pi-无需编程即可编程，这次是针对Raspberry Pi爱好者</a></li>
<li><a href="../zh-CN456108/index.html">《哈伯周刊》第5期/黑暗话题无处不在，俄罗斯联邦的中国工厂，银行纷纷涌入，Pixel 4，ML污染了大气</a></li>
<li><a href="../zh-CN456110/index.html">您的文字看起来像什么？</a></li>
<li><a href="../zh-CN456112/index.html">克服摩尔定律：如何替代传统的平面晶体管</a></li>
<li><a href="../zh-CN456116/index.html">如何在yEd Graph Editor中构建漂亮的数据库架构</a></li>
<li><a href="../zh-CN456118/index.html">马文·明斯基（Marvin Minsky）的“情感机器”：第8.1-2章“创造力”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>