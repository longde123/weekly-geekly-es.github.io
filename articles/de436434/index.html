<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÇüèø üè¢ üë©üèæ‚Äçüç≥ PVS-Studio f√ºr Java ‚òÄÔ∏è üì¨ ü§≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In der siebten Version des statischen Analysators PVS-Studio haben wir Unterst√ºtzung f√ºr die Java-Sprache hinzugef√ºgt. Es ist Zeit, ein wenig dar√ºber ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio f√ºr Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/436434/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/859/2ca/ccd/8592caccdc92ac430645bd487d7b5284.png" alt="PVS-Studio f√ºr Java"></div><br>  In der siebten Version des statischen Analysators PVS-Studio haben wir Unterst√ºtzung f√ºr die Java-Sprache hinzugef√ºgt.  Es ist Zeit, ein wenig dar√ºber zu sprechen, wie wir angefangen haben, die Java-Sprache zu unterst√ºtzen, was wir getan haben und welche Zukunftspl√§ne wir haben.  Und nat√ºrlich zeigt der Artikel die ersten Tests des Analysators an offenen Projekten. <br><a name="habracut"></a><br><h2>  PVS-Studio </h2><br>  F√ºr Java-Entwickler, die noch nie von dem PVS-Studio-Tool geh√∂rt haben, werde ich eine kurze Beschreibung geben. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio</a> ist ein Tool zum Erkennen von Fehlern und potenziellen Schwachstellen im Quellcode von Programmen, die in C, C ++, C # und Java geschrieben wurden.  Es l√§uft unter Windows, Linux und MacOS. <br><br>  PVS-Studio f√ºhrt eine statische Code-Analyse durch und generiert einen Bericht, der dem Programmierer hilft, Fehler zu finden und zu beheben.  F√ºr diejenigen, die genau wissen m√∂chten, wie PVS-Studio nach Fehlern sucht, empfehle ich den Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Im PVS-Studio Code Analyzer verwendete Technologien zum Auffinden von Fehlern und potenziellen Schwachstellen</a> ". <br><br><h2>  Starten Sie </h2><br>  Ich k√∂nnte mir eine kluge Geschichte einfallen lassen, da wir seit zwei Jahren dar√ºber nachdenken, welche n√§chste Sprache in PVS-Studio unterst√ºtzt werden soll.  Die Tatsache, dass Java aufgrund der hohen Beliebtheit dieser Sprache usw. eine vern√ºnftige Wahl ist. <br><br>  Wie es im Leben passiert, wurde jedoch nicht alles durch eingehende Analyse, sondern durch Experiment entschieden :).  Ja, wir haben uns √ºberlegt, in welche Richtung der PVS-Studio-Analysator weiterentwickelt werden soll.  Programmiersprachen wie Java, PHP, Python, JavaScript und IBM RPG wurden ber√ºcksichtigt.  Wir waren zur Java-Sprache geneigt, aber die endg√ºltige Entscheidung wurde noch nicht getroffen.  Diejenigen, deren Augen auf ein unbekanntes IBM-Rollenspiel gerichtet sind, verweise ich hier auf diesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hinweis</a> , aus dem alles klar wird. <br><br>  Ende 2017 hat Kollege Egor Bredikhin untersucht, welche vorgefertigten Bibliotheken zum Parsen von Code (dh Parser) f√ºr neue Richtungen verf√ºgbar sind, die f√ºr uns von Interesse sind.  Und ich bin auf mehrere Projekte gesto√üen, um Java-Code zu analysieren.  Basierend auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spoon</a> gelang es ihm schnell, einen Prototyp-Analysator mit einigen Diagnosen herzustellen.  Dar√ºber hinaus wurde klar, dass wir einige Mechanismen des C ++ - Analysators mit Hilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SWIG</a> im Java-Analysator verwenden k√∂nnen.  Wir haben uns angesehen, was passiert ist, und festgestellt, dass unser n√§chster Parser f√ºr Java sein w√ºrde. <br><br>  Vielen Dank an Egor f√ºr sein Engagement und seine aktive Arbeit am Java-Analysator.  Wie die Entwicklung weiterging, beschrieb er im Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung eines neuen statischen Analysators: PVS-Studio Java</a> ". <br><br><h2>  Konkurrenten? </h2><br>  Es gibt weltweit viele kostenlose und kommerzielle statische Code-Analysatoren f√ºr Java.  Es ist nicht sinnvoll, sie alle im Artikel aufzulisten, und ich lasse nur einen Link zu " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Liste der Tools f√ºr die statische Code-Analyse</a> " (siehe Abschnitt Java und Mehrsprachig). <br><br>  Ich wei√ü jedoch, dass wir zun√§chst nach IntelliJ IDEA, FindBugs und SonarQube (SonarJava) gefragt werden. <br><br>  <b>IntelliJ IDEE</b> <br><br>  IntelliJ IDEA verf√ºgt √ºber einen sehr leistungsstarken statischen Code-Analysator.  Dar√ºber hinaus entwickelt sich der Analysator weiter und seine Autoren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºberwachen</a> unsere Aktivit√§ten genau.  Mit IntelliJ IDEA werden wir am schwierigsten sein.  Zumindest vorerst werden wir IntelliJ IDEA in Bezug auf Diagnosefunktionen nicht √ºbertreffen k√∂nnen.  Deshalb werden wir versuchen, uns auf unsere anderen Vorteile zu konzentrieren. <br><br>  Die statische Analyse in IntelliJ IDEA ist in erster Linie einer der Chips der Entwicklungsumgebung, die bestimmte Einschr√§nkungen auferlegt.  Wir sind frei, was wir mit unserem Analyseger√§t tun k√∂nnen.  Zum Beispiel k√∂nnen wir den Analysator schnell an die spezifischen Bed√ºrfnisse des Kunden anpassen.  Schnelle und umfassende Unterst√ºtzung ist unser Wettbewerbsvorteil.  Unsere Kunden kommunizieren direkt mit Programmierern, die einen bestimmten Teil von PVS-Studio entwickeln. <br><br>  PVS-Studio bietet viele M√∂glichkeiten, es in den Entwicklungszyklus gro√üer alter Projekte zu integrieren.  Dies ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Integration mit SonarQube</a> .  Dies ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">massive Unterdr√ºckung von</a> Analysatormeldungen, mit der Sie den Analysator sofort in einem gro√üen Projekt verwenden k√∂nnen, um Fehler nur in neuem oder ge√§ndertem Code zu verfolgen.  PVS-Studio ist in den kontinuierlichen Integrationsprozess integriert.  Ich denke, diese und andere Funktionen werden unserem Analysator helfen, einen Platz unter der Sonne in der Java-Welt zu finden. <br><br>  <b>Findbugs</b> <br><br>  Das FindBugs-Projekt wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abgebrochen</a> .  Es sollte jedoch daran erinnert werden, dass dies m√∂glicherweise der bekannteste kostenlose statische Analysator f√ºr Java-Code ist. <br><br>  Der Nachfolger von FindBugs ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SpotBugs-</a> Projekt.  Er ist jedoch weniger beliebt, und was mit ihm geschehen wird, ist auch noch nicht ganz klar. <br><br>  Im Allgemeinen glauben wir, dass FindBugs zwar sehr beliebt war und bleibt und auch ein kostenloser Analysator ist, wir aber nicht dar√ºber nachdenken sollten.  Dieses Projekt geh√∂rt der Ruhe an. <br><br>  PS √úbrigens kann PVS-Studio jetzt auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kostenlos</a> bei der Arbeit mit offenen Projekten verwendet werden. <br><br>  <b>SonarQube (SonarJava)</b> <br><br>  Wir glauben, dass wir nicht mit SonarQube konkurrieren, sondern es erg√§nzen.  PVS-Studio l√§sst sich in SonarQube integrieren, wodurch Entwickler mehr Fehler und potenzielle Schwachstellen in ihren Projekten finden k√∂nnen.  Wie Sie das PVS-Studio-Tool und andere Analyseger√§te in SonarQube integrieren, sprechen wir regelm√§√üig in Meisterkursen, die wir auf verschiedenen Konferenzen abhalten ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel</a> ). <br><br><h2>  So starten Sie PVS-Studio f√ºr Java </h2><br>  Wir haben den Benutzern die beliebtesten M√∂glichkeiten zur Integration des Analysators in das Montagesystem zur Verf√ºgung gestellt: <br><br><ul><li>  Plugin f√ºr Maven; </li><li>  Plugin f√ºr Gradle; </li><li>  Plugin f√ºr IntelliJ IDEA </li></ul><br>  In der Testphase haben wir viele Benutzer getroffen, die √ºber selbstgeschriebene Montagesysteme verf√ºgen, insbesondere in der mobilen Entwicklung.  Sie mochten die M√∂glichkeit, den Analysator direkt auszuf√ºhren und die Quellen und den Klassenpfad aufzulisten. <br><br>  Detaillierte Informationen zu allen Methoden zum Starten des Analysators finden Sie auf der Dokumentationsseite " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So starten Sie PVS-Studio Java</a> ". <br><br>  Wir konnten die bei Java-Entwicklern so beliebte Plattform zur Qualit√§tskontrolle von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SonarQube-</a> Code nicht ignorieren. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Deshalb haben</a> wir unserem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SonarQube-Plugin</a> Java-Sprachunterst√ºtzung hinzugef√ºgt. <br><br><h2>  Weitere Pl√§ne </h2><br>  Wir haben viele Ideen, die weiter untersucht werden m√ºssen, aber einige Pl√§ne, die f√ºr einen unserer Analysatoren spezifisch sind, sehen folgenderma√üen aus: <br><br><ul><li>  Erstellung neuer Diagnosen und Verfeinerung bestehender Diagnosen; </li><li>  Entwicklung der Datenflussanalyse; </li><li>  Verbesserung der Zuverl√§ssigkeit und Benutzerfreundlichkeit. </li></ul><br>  M√∂glicherweise finden wir Zeit, das IntelliJ IDEA-Plugin f√ºr CLion anzupassen.  Hallo C ++ an Entwickler, die √ºber den Java-Analysator lesen :-) <br><br><h2>  Beispiele f√ºr Fehler in Open Source-Projekten </h2><br>  Ich werde nicht ich sein, wenn ich im Artikel keine Fehler zeige, die mit dem neuen Analyseger√§t gefunden wurden.  Wir k√∂nnten ein gro√ües Open-Source-Java-Projekt nehmen und einen klassischen Artikel mit Fehleranalyse schreiben, wie wir es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">normalerweise tun</a> . <br><br>  Ich sehe jedoch sofort die Frage voraus, ob wir in Projekten wie IntelliJ IDEA, FindBugs usw. etwas finden k√∂nnen.  Deshalb habe ich einfach keinen Ausweg und werde mit diesen Projekten beginnen.  Deshalb habe ich mich entschlossen, einige interessante Beispiele f√ºr Fehler aus den folgenden Projekten schnell zu √ºberpr√ºfen und aufzuschreiben: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IntelliJ IDEA Community Edition</a> .  Ich denke, es ist nicht n√∂tig zu erkl√§ren, warum dieses Projekt ausgew√§hlt wurde :). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SpotBugs</a>  Wie ich bereits geschrieben habe, entwickelt sich das FindBugs-Projekt nicht.  Schauen Sie sich also das SpotBugs-Projekt an, das der Nachfolger von FindBugs ist.  SpotBugs ist ein klassischer statischer Java-Code-Analysator. </li><li>  Einige der Projekte von SonarSource, das Software f√ºr die kontinuierliche Kontrolle der Codequalit√§t entwickelt.  Schauen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> sich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekte</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SonarQube</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SonarJava an</a> . </li></ul><br>  Das Schreiben √ºber Fehler in diesen Projekten ist eine schwierige Aufgabe.  Tatsache ist, dass diese Projekte von sehr hoher Qualit√§t sind.  Eigentlich ist das nicht √ºberraschend.  Wie unsere Beobachtungen zeigen, wird der Code von statischen Analysatoren immer gut getestet und mit anderen Tools verifiziert. <br><br>  Trotz alledem muss ich mit genau diesen Projekten beginnen.  Ich werde keine zweite Chance haben, etwas √ºber sie zu schreiben.  Ich bin sicher, dass die Entwickler dieser Projekte nach der Ver√∂ffentlichung von PVS-Studio f√ºr Java PVS-Studio in Betrieb nehmen und damit beginnen werden, es regelm√§√üig oder zumindest regelm√§√üig zu √ºberpr√ºfen.  Ich wei√ü zum Beispiel, dass Tagir Valeyev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">lany</a> ), einer der JetBrains-Entwickler, der sich mit dem statischen Codeanalysator IntelliJ IDEA besch√§ftigt, bereits mit der Beta-Version von PVS-Studio spielt, als ich den Artikel schreibe.  Er hat uns bereits 15 Briefe mit Fehlerberichten und Empfehlungen geschrieben.  Danke Tagir! <br><br>  Gl√ºcklicherweise muss ich in einem bestimmten Projekt nicht so viele Fehler wie m√∂glich finden.  Jetzt ist es meine Aufgabe zu zeigen, dass der PVS-Studio-Analysator f√ºr Java nicht umsonst erschien und in der Lage sein wird, die Reihe anderer Tools aufzuf√ºllen, die zur Verbesserung der Codequalit√§t entwickelt wurden.  Ich habe nur die Berichte des Analysators durchgesehen und einige Fehler aufgeschrieben, die mir interessant erschienen.  Wann immer m√∂glich, habe ich versucht, Fehler verschiedener Art aufzuschreiben.  Mal sehen, was passiert ist. <br><br><h3>  IntelliJ IDEA Integer Division </h3><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSentenceCapitalization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String value)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;String&gt; words = StringUtil.split(value, <span class="hljs-string"><span class="hljs-string">" "</span></span>); .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> capitalized = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> capitalized / words.size() &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// allow reasonable amount of // capitalized words }</span></span></code> </pre> <br>  PVS-Studio Warnung: V6011 [CWE-682] Das Literal '0.2' vom Typ 'double' wird mit einem Wert vom Typ 'int' verglichen.  TitleCapitalizationInspection.java 169 <br><br>  Wie beabsichtigt sollte eine Funktion true zur√ºckgeben, wenn weniger als 20% der W√∂rter mit einem Gro√übuchstaben beginnen.  Tats√§chlich funktioniert die Pr√ºfung nicht, da eine Ganzzahldivision auftritt.  Durch die Teilung k√∂nnen nur zwei Werte erhalten werden: 0 oder 1. <br><br>  Die Funktion gibt nur dann einen falschen Wert zur√ºck, wenn alle W√∂rter mit einem Gro√übuchstaben beginnen.  In allen anderen F√§llen erzeugt die Division 0 und die Funktion gibt den wahren Wert zur√ºck. <br><br><h3>  IntelliJ IDEA Verd√§chtiger Zyklus </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPreviousIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> current)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = myPainter.getErrorStripeCount(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundLayer = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= current &amp;&amp; current &lt; count) { current--; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= int layer = getLayer(index); if (layer &gt; foundLayer) { foundIndex = index; foundLayer = layer; } } .... }</span></span></code> </pre> <br>  PVS-Studio-Warnung: V6007 [CWE-571] Der Ausdruck 'index&gt; = 0' ist immer wahr.  Updater.java 184 <br><br>  Schauen Sie sich zun√§chst die Bedingung an <i>(0 &lt;= aktuell &amp;&amp; aktuell &lt;Anzahl)</i> .  Es wird nur ausgef√ºhrt, wenn der Wert der Z√§hlvariablen gr√∂√üer als 0 ist. <br><br>  Schauen Sie sich nun die Schleife an: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++)</code> </pre> <br>  Der Variablenindex <i>wird</i> durch den Ausdruck <i>count - 1</i> initialisiert.  Da die Z√§hlvariable gr√∂√üer als 0 ist, ist der Anfangswert der <i>Indexvariablen</i> immer gr√∂√üer oder gleich 0. Es stellt sich heraus, dass die Schleife ausgef√ºhrt wird, bis die <i>Indexvariable</i> √ºberl√§uft. <br><br>  Dies ist h√∂chstwahrscheinlich nur ein Tippfehler und das Inkrement darf nicht ausgef√ºhrt werden, sondern das Dekrement der Variablen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index--)</code> </pre> <br><h3>  IntelliJ IDEA, Kopieren-Einf√ºgen </h3><br><pre> <code class="cpp hljs">@NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String BEFORE_STR_OLD = <span class="hljs-string"><span class="hljs-string">"before:"</span></span>; @NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String AFTER_STR_OLD = <span class="hljs-string"><span class="hljs-string">"after:"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isBeforeOrAfterKeyword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str, boolean trimKeyword)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (trimKeyword ? LoadingOrder.BEFORE_STR.trim() : LoadingOrder.BEFORE_STR).equalsIgnoreCase(str) || (trimKeyword ? LoadingOrder.AFTER_STR.trim() : LoadingOrder.AFTER_STR).equalsIgnoreCase(str) || LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str) || <span class="hljs-comment"><span class="hljs-comment">// &lt;= LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str); // &lt;= }</span></span></code> </pre> <br>  PVS-Studio Warnung: V6001 [CWE-570] Links und rechts vom '||' befinden sich identische Unterausdr√ºcke 'LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase (str)'.  Betreiber.  √úberpr√ºfen Sie die Zeilen: 127, 128. ExtensionOrderConverter.java 127 <br><br>  Guter alter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Effekt der letzten Zeile</a> .  Der Programmierer beeilte sich und verga√ü, nachdem er eine Codezeile multipliziert hatte, sie zu reparieren.  Infolgedessen wird die doppelte Zeichenfolge <i>str</i> mit <i>BEFORE_STR_OLD</i> verglichen.  Wahrscheinlich sollte einer der Vergleiche mit <i>AFTER_STR_OLD erfolgen</i> . <br><br><h3>  Tippfehler von IntelliJ IDEA </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> synchronized boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String name, final Project project)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\''</span></span>) &amp;&amp; !StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name = <span class="hljs-string"><span class="hljs-string">"\""</span></span> + name; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'"'</span></span>) &amp;&amp; !StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name += <span class="hljs-string"><span class="hljs-string">"\""</span></span>; } .... }</code> </pre> <br>  PVS-Studio Warnung: V6001 [CWE-571] Links und rechts vom Operator '&amp;&amp;' befinden sich identische Unterausdr√ºcke '! StringUtil.endsWithChar (Name,' "'). JsonNamesValidator.java 27 <br><br>  Dieser Code √ºberpr√ºft, ob der Name in einfachen oder doppelten Anf√ºhrungszeichen steht.  Ist dies nicht der Fall, werden doppelte Anf√ºhrungszeichen automatisch hinzugef√ºgt. <br><br>  Aufgrund eines Tippfehlers wird das Ende des Namens nur auf doppelte Anf√ºhrungszeichen √ºberpr√ºft.  Infolgedessen wird der Name in einfachen Anf√ºhrungszeichen nicht korrekt verarbeitet. <br><br>  Vorname <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span></code> </pre> <br>  Aufgrund der Hinzuf√ºgung zus√§tzlicher doppelter Anf√ºhrungszeichen wird daraus Folgendes: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span><span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br><h3>  IntelliJ IDEA, falscher Array-√úberlaufschutz </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Context </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = offset; i &lt; endOffset; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = text.charAt(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span> &amp;&amp; i &lt; endOffset &amp;&amp; text.charAt(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; startTag != null &amp;&amp; CharArrayUtil.regionMatches(text, i + <span class="hljs-number"><span class="hljs-number">2</span></span>, endOffset, startTag)) { endTagStartOffset = i; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... }</code> </pre> <br>  PVS-Studio-Warnung: V6007 [CWE-571] Der Ausdruck 'i &lt;endOffset' ist immer wahr.  EnterAfterJavadocTagHandler.java 183 <br><br>  Der Unterausdruck <i>i &lt;endOffset</i> im Zustand der <i>if-Anweisung</i> ist nicht sinnvoll.  Die Variable <i>i</i> ist immer kleiner als <i>endOffset</i> , wie aus der Bedingung f√ºr die Ausf√ºhrung der Schleife hervorgeht. <br><br>  H√∂chstwahrscheinlich wollte sich der Programmierer beim Aufrufen von Funktionen davor sch√ºtzen, aus der Reihe zu geraten: <br><br><ul><li>  text.charAt (i + 1) </li><li>  CharArrayUtil.regionMatches (Text, i + 2, endOffset, startTag) </li></ul><br>  In diesem Fall sollte der Unterausdruck zum √úberpr√ºfen des Index wie <i>folgt lauten</i> : <i>i &lt;endOffset - 2</i> . <br><br><h3>  IntelliJ IDEA Repeat Check </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateWarningMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { buffer.append(<span class="hljs-string"><span class="hljs-string">" "</span></span>).append( IdeBundle.message(<span class="hljs-string"><span class="hljs-string">"prompt.delete.and"</span></span>)).append(<span class="hljs-string"><span class="hljs-string">" "</span></span>); } } .... }</code> </pre> <br>  PVS-Studio-Warnung: V6007 [CWE-571] Der Ausdruck 'buffer.length ()&gt; 0' ist immer wahr.  DeleteUtil.java 62 <br><br>  Dies kann entweder ein harmloser redundanter Code oder ein schwerwiegender Fehler sein. <br><br>  Wenn beispielsweise w√§hrend des Refactorings zuf√§llig eine doppelte Pr√ºfung aufgetreten ist, ist daran nichts auszusetzen.  Die zweite Pr√ºfung kann einfach gel√∂scht werden. <br><br>  Ein anderes Szenario ist jedoch m√∂glich.  Die zweite √úberpr√ºfung sollte v√∂llig anders sein und der Code verh√§lt sich nicht wie beabsichtigt.  Dann ist das ein echter Fehler. <br><br>  <b>Hinweis</b>  √úbrigens gibt es viele verschiedene redundante Pr√ºfungen.  Dar√ºber hinaus wird oft gesehen, dass dies kein Fehler ist.  Analysatormeldungen k√∂nnen jedoch auch nicht als falsch positiv bezeichnet werden.  Zur Verdeutlichung hier ein Beispiel, das ebenfalls aus IntelliJ IDEA stammt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isMultiline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ String text = element.getText(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.contains(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); }</code> </pre> <br>  Der Analysator gibt an, dass die Funktion <i>text.contains ("\ r \ n")</i> immer false zur√ºckgibt.  Wenn das Symbol "\ n" und "\ r" nicht gefunden wird, macht es keinen Sinn, nach "\ r \ n" zu suchen.  Dies ist kein Fehler, und der Code ist nur deshalb schlecht, weil er etwas langsamer arbeitet und eine bedeutungslose Suche nach einem Teilstring durchf√ºhrt. <br><br>  Wie mit einem solchen Code umzugehen ist, liegt in jedem Fall bei den Programmierern.  Beim Schreiben von Artikeln achte ich in der Regel einfach nicht auf einen solchen Code. <br><br><h3>  IntelliJ IDEA, etwas stimmt nicht </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">satisfiedBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ .... @NonNls final String text = expression.getText().replaceAll(<span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text == null || text.length() &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"0"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0L"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0l"</span></span>.equals(text)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.charAt(<span class="hljs-number"><span class="hljs-number">0</span></span>) == <span class="hljs-string"><span class="hljs-string">'0'</span></span>; }</code> </pre> <br>  PVS-Studio-Warnung: V6007 [CWE-570] Der Ausdruck '"0" .equals (text)' ist immer falsch.  ConvertIntegerToDecimalPredicate.java 46 <br><br>  Dieser Code enth√§lt definitiv einen logischen Fehler.  Es f√§llt mir jedoch schwer zu sagen, was der Programmierer √ºberpr√ºfen wollte und wie der Fehler behoben werden kann.  Daher werde ich hier nur auf eine bedeutungslose Pr√ºfung hinweisen. <br><br>  Zu Beginn wird gepr√ºft, ob die Zeichenfolge mindestens zwei Zeichen enthalten muss.  Ist dies nicht der Fall, gibt die Funktion <i>false zur√ºck</i> . <br><br>  Das Folgende ist eine <i>"0" .equals (Text)</i> Pr√ºfung.  Dies ist bedeutungslos, da eine Zeichenfolge nicht nur ein Zeichen enthalten kann. <br><br>  Im Allgemeinen stimmt hier etwas nicht und der Code sollte korrigiert werden. <br><br><h3>  SpotBugs (Nachfolger von FindBugs), Iterationslimitfehler </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getXMLType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@WillNotClose InputStream in)</span></span></span><span class="hljs-function"> throws IOException </span></span>{ .... String s; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { s = r.readLine(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == null) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } Matcher m = tag.matcher(s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m.find()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.group(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOException(<span class="hljs-string"><span class="hljs-string">"Didn't find xml tag"</span></span>); .... }</code> </pre> <br>  PVS-Studio-Warnung: V6007 [CWE-571] Der Ausdruck 'count &lt;4' ist immer wahr.  Util.java 394 <br><br>  Wie geplant sollte die Suche nach dem XML-Tag nur in den ersten vier Zeilen der Datei durchgef√ºhrt werden.  Aufgrund der Tatsache, dass sie vergessen haben, die <i>Anzahl</i> der Variablen zu <i>erh√∂hen</i> , wird die gesamte Datei gelesen. <br><br>  Erstens kann sich dies als sehr langsamer Vorgang herausstellen, und zweitens kann irgendwo in der Mitte der Datei etwas gefunden werden, das als XML-Tag interpretiert wird, aber nicht. <br><br><h3>  SpotBugs (Nachfolger von FindBugs), Werte √ºberschreiben </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reportBug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = LOW_PRIORITY; String pattern = <span class="hljs-string"><span class="hljs-string">"NS_NON_SHORT_CIRCUIT"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawDangerOld) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawNullTestVeryOld) { priority = HIGH_PRIORITY; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } if (sawMethodCallOld || sawNumericTestVeryOld &amp;&amp; sawArrayDangerOld) { priority = HIGH_PRIORITY; // &lt;= pattern = "NS_DANGEROUS_NON_SHORT_CIRCUIT"; } else { priority = NORMAL_PRIORITY; // &lt;= } } bugAccumulator.accumulateBug( new BugInstance(this, pattern, priority).addClassAndMethod(this), this); }</span></span></code> </pre> <br>  PVS-Studio Warnung: V6021 [CWE-563] Der Wert wird der Variablen 'Priorit√§t' zugewiesen, aber nicht verwendet.  FindNonShortCircuit.java 197 <br><br>  Der Wert der <i>Priorit√§tsvariablen</i> wird abh√§ngig vom Wert der Variablen <i>sawNullTestVeryOld festgelegt</i> .  Dies spielt jedoch keine Rolle.  Ferner wird der <i>Priorit√§tsvariablen</i> in jedem Fall ein anderer Wert zugewiesen.  Ein offensichtlicher Fehler in der Logik der Funktion. <br><br><h3>  SonarQube, Kopieren-Einf√ºgen </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuleDto</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleDefinitionDto definition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleMetadataDto metadata; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromDefinition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromMetadata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } .... }</code> </pre> <br>  PVS-Studio: V6032 Es ist merkw√ºrdig, dass der Hauptteil der Methode 'setUpdatedAtFromDefinition' dem Hauptteil einer anderen Methode 'setUpdatedAtFromMetadata' vollst√§ndig entspricht.  √úberpr√ºfen Sie die Zeilen: 396, 405. RuleDto.java 396 <br><br>  Die <i>setUpdatedAtFromMetadata-</i> Methode verwendet das <i>Definitionsfeld</i> .  H√∂chstwahrscheinlich sollte das <i>Metadatenfeld</i> verwendet werden.  Dies ist den Konsequenzen des fehlgeschlagenen Kopierens und Einf√ºgens sehr √§hnlich. <br><br><h3>  SonarJava, Duplikate bei der Karteninitialisierung </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final Map&lt;JavaPunctuator, Tree.Kind&gt; assignmentOperators = Maps.newEnumMap(JavaPunctuator.class); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">KindMaps</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... }</code> </pre> <br>  PVS-Studio Warnung: V6033 [CWE-462] Ein Element mit demselben Schl√ºssel 'JavaPunctuator.PLUSEQU' wurde bereits hinzugef√ºgt.  √úberpr√ºfen Sie die Zeilen: 104, 100. KindMaps.java 104 <br><br>  Das gleiche Schl√ºssel-Wert-Paar wird zweimal auf die Karte gelegt.  H√∂chstwahrscheinlich stellte sich heraus, dass dies unaufmerksam war, und tats√§chlich gibt es keinen wirklichen Fehler.  In jedem Fall muss dieser Code jedoch √ºberpr√ºft werden, da Sie m√∂glicherweise vergessen haben, ein anderes Paar hinzuzuf√ºgen. <br><br><h2>  Fazit </h2><br>  Aber welche Schlussfolgerung kann es geben ?!  Ich lade alle unverz√ºglich ein, PVS-Studio herunterzuladen und zu versuchen, Ihre Arbeitsprojekte in Java zu testen!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Laden Sie PVS-Studio herunter</a> . <br><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit.  Ich hoffe, dass wir die Leser bald mit einer Reihe von Artikeln begeistern werden, die sich mit der √úberpr√ºfung verschiedener offener Java-Projekte befassen. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel einem englischsprachigen Publikum zug√§nglich machen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio f√ºr Java</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436434/">https://habr.com/ru/post/de436434/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436424/index.html">Kleine Kreaturen, gro√üe Taten: Die Rolle von Blattschneidern im Treibhauseffekt von Neotropika</a></li>
<li><a href="../de436426/index.html">Unterbrechen Sie die Anwendung, wenn die Netzwerkverbindung unterbrochen wird</a></li>
<li><a href="../de436428/index.html">Warum jubeln wir dem Sportprogramm zu?</a></li>
<li><a href="../de436430/index.html">Bekenntnis eines Graphomanen</a></li>
<li><a href="../de436432/index.html">SAP: Was ben√∂tigen Sie, um SAPUI5 zu lernen?</a></li>
<li><a href="../de436436/index.html">Das CERN plant den Bau eines neuen Beschleunigers mit einer Tunnell√§nge von 100 km</a></li>
<li><a href="../de436438/index.html">Roscosmos nannte die m√∂glichen Gr√ºnde f√ºr den Verlust der Kommunikation mit dem Spektr-R-Orbitalobservatorium</a></li>
<li><a href="../de436440/index.html">Ich muss schnell gehen: Auf Geschwindigkeit in iOS bauen. Teil 2</a></li>
<li><a href="../de436442/index.html">Ein Kopf ist gut und zwei sind besser oder Paarprogrammierung in Aktion</a></li>
<li><a href="../de436444/index.html">Unsichtbare Bereitstellung einer monolithischen Anwendung in der Produktion unter AWS. Pers√∂nliche Erfahrung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>