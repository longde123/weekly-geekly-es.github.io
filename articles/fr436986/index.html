<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§µüèª üåÉ üñ±Ô∏è API Linux Gestion de la mise en m√©moire tampon des E / S des fichiers du noyau ‚òÄÔ∏è üë† üêØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, habrozhiteli! Nous avons d√©j√† √©crit sur le livre de Michael Kerrisk ¬´Linux API. Guide complet . " Nous avons maintenant d√©cid√© de publier un ex...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>API Linux Gestion de la mise en m√©moire tampon des E / S des fichiers du noyau</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/436986/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/qk/pj/rf/qkpjrftqtsq-bnryowiwf_v88us.jpeg" align="left" alt="image"></a>  Salut, habrozhiteli!  Nous avons d√©j√† √©crit sur le livre de Michael Kerrisk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´Linux API.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide complet</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"</a>  Nous avons maintenant d√©cid√© de publier un extrait du livre "Gestion de la mise en m√©moire tampon des E / S des fichiers g√©r√©s dans le noyau" <br><br>  La r√©initialisation de la m√©moire tampon du noyau pour les fichiers de sortie peut √™tre forc√©e.  Parfois, cela est n√©cessaire si l'application, avant de continuer √† fonctionner (par exemple, une base de donn√©es de journalisation des processus change), doit garantir que la sortie est r√©ellement √©crite sur le disque (ou au moins dans le cache du disque mat√©riel). <br><br>  Avant de consid√©rer les appels syst√®me utilis√©s pour contr√¥ler la mise en m√©moire tampon du noyau, il serait utile de consid√©rer plusieurs d√©finitions li√©es de SUSv3. <br><a name="habracut"></a><br>  <b>E / S synchronis√©es avec int√©grit√© des donn√©es et des fichiers</b> <br><br>  Dans SUSv3, le concept d'ach√®vement des E / S synchronis√©es signifie "une op√©ration d'E / S qui a conduit √† un transfert de donn√©es r√©ussi [sur le disque] ou a √©t√© diagnostiqu√©e comme infructueuse". <br><br>  SUSv3 d√©finit deux types diff√©rents de terminaisons d'E / S synchronis√©es.  La diff√©rence entre les types concerne les m√©tadonn√©es (¬´donn√©es sur les donn√©es¬ª) d√©crivant le fichier.  Le noyau les stocke avec les donn√©es du fichier lui-m√™me.  Les d√©tails des m√©tadonn√©es de fichier seront abord√©s dans la section 14.4 lors de l'examen des inodes de fichier.  En attendant, il suffira de noter que les m√©tadonn√©es du fichier incluent des informations telles que des informations sur le propri√©taire du fichier et son groupe, les droits d'acc√®s au fichier, la taille du fichier, le nombre de liens durs vers le fichier, les horodatages indiquant l'heure √† laquelle le fichier a √©t√© acc√©d√© pour la derni√®re fois, l'heure de sa derni√®re modification et l'heure du dernier changement de m√©tadonn√©es, ainsi que des pointeurs vers des blocs de donn√©es. <br><br>  Le premier type d'ach√®vement d'E / S synchronis√© dans SUSv3 est l'ach√®vement de l'int√©grit√© des donn√©es.  Lors de la mise √† jour des donn√©es du fichier, le transfert d'informations suffisant pour permettre une extraction ult√©rieure de ces donn√©es pour continuer √† fonctionner doit √™tre assur√©. <br><br>  - pour une op√©ration de lecture, cela signifie que les donn√©es du fichier demand√© ont √©t√© transf√©r√©es (du disque) vers le processus.  S'il y a des op√©rations d'√©criture en attente qui peuvent affecter les donn√©es demand√©es, les donn√©es seront transf√©r√©es sur le disque avant la lecture. <br><br>  - pour une op√©ration d'√©criture, cela signifie que les donn√©es sp√©cifi√©es dans la demande d'√©criture ont √©t√© transf√©r√©es (sur disque), comme toutes les m√©tadonn√©es de fichier requises pour extraire ces donn√©es.  Le point cl√© √† prendre en compte: pour s'assurer que les donn√©es sont extraites du fichier modifi√©, il n'est pas n√©cessaire de transf√©rer tous les fichiers medaten.  Un exemple de l'attribut de m√©tadonn√©es d'un fichier modifi√© qui doit √™tre migr√© est sa taille (si l'op√©ration d'√©criture augmente la taille du fichier).  En revanche, les horodatages du fichier √† modifier n'auront pas besoin d'√™tre transf√©r√©s sur le disque avant que la r√©cup√©ration de donn√©es ult√©rieure ne se produise. <br><br>  Le deuxi√®me type d'ach√®vement d'E / S synchronis√©es d√©fini dans SUSv3 est l'ach√®vement de l'int√©grit√© des fichiers.  Il s'agit d'une option avanc√©e pour effectuer des E / S synchronis√©es avec l'int√©grit√© des donn√©es.  La diff√©rence entre ce mode est que lors de la mise √† jour du fichier, toutes ses m√©tadonn√©es sont transf√©r√©es sur le disque, m√™me si cela n'est pas n√©cessaire pour l'extraction ult√©rieure des donn√©es du fichier. <br><br>  <b>Appels syst√®me pour contr√¥ler la mise en m√©moire tampon du noyau pendant les E / S de fichiers</b> <br><br>  L'appel syst√®me fsync () r√©initialise toutes les donn√©es mises en m√©moire tampon et toutes les m√©tadonn√©es associ√©es √† un fichier ouvert dot√© d'un descripteur fd.  L'appel de fsync () place le fichier dans un √©tat d'int√©grit√© (fichier) apr√®s la fin des E / S synchrones. <br><br>  L'appel fsync () renvoie le contr√¥le uniquement une fois le transfert des donn√©es vers le p√©riph√©rique de disque (ou au moins vers son cache) termin√©. <br><br><pre><code class="plaintext hljs">#include &lt;unistd.h&gt; int fsync(int fd);</code> </pre> <br>  Retourne en cas de succ√®s 0 ou -1 en cas d'erreur <br><br>  L'appel syst√®me fdatasync () fonctionne exactement comme fsync (), mais place le fichier dans un √©tat d'int√©grit√© (donn√©es) apr√®s la fin des E / S synchrones. <br><br><pre> <code class="plaintext hljs">#include &lt;unistd.h&gt; int fdatasync(int fd);</code> </pre> <br>  Retourne en cas de succ√®s 0 ou -1 en cas d'erreur <br><br>  L'utilisation de fdatasync () r√©duit potentiellement le nombre d'op√©rations sur disque de deux requises par l'appel syst√®me fsync () √† une seule.  Par exemple, si les donn√©es du fichier ont chang√©, mais que la taille reste la m√™me, l'appel √† fdatasync () force uniquement la mise √† jour des donn√©es.  (Il a d√©j√† √©t√© not√© ci-dessus que pour terminer une op√©ration d'E / S synchrone avec l'int√©grit√© des donn√©es, il n'est pas n√©cessaire de transf√©rer les modifications apport√©es aux attributs tels que l'heure de la derni√®re modification du fichier.) En revanche, l'appel √† fsync () forcera √©galement le transfert des m√©tadonn√©es sur le disque. <br><br>  Une telle r√©duction du nombre d'op√©rations d'E / S disque sera utile pour les applications individuelles pour lesquelles les performances et la mise √† jour pr√©cise de m√©tadonn√©es sp√©cifiques (par exemple, les horodatages) jouent un r√¥le d√©cisif.  Cela peut conduire √† des am√©liorations significatives des performances pour les applications qui produisent plusieurs mises √† jour de fichiers √† la fois.  √âtant donn√© que les donn√©es de fichier et les m√©tadonn√©es sont g√©n√©ralement situ√©es dans diff√©rentes parties du disque, la mise √† jour des deux n√©cessitera des recherches r√©p√©t√©es en avant et en arri√®re sur le disque. <br><br>  Sur Linux 2.2 et versions ant√©rieures, fdatasync () est impl√©ment√© en tant qu'appel √† fsync (), donc il ne donne aucune am√©lioration des performances. <br><br><blockquote>  √Ä partir de la version 2.6.17 du noyau, Linux fournit un appel syst√®me non standard sync_file_range ().  Il vous permet de contr√¥ler plus pr√©cis√©ment le processus de vidage des donn√©es de fichier sur le disque que fdatasync ().  Lors de l'appel, vous pouvez sp√©cifier la zone √† supprimer dans le fichier et d√©finir des indicateurs qui d√©finissent les conditions de blocage de cet appel.  Voir la page de manuel sync_file_range (2) pour plus de d√©tails. </blockquote><br>  L'appel syst√®me sync () provoque le vidage de tous les tampons du noyau contenant les informations de fichier mises √† jour (c'est-√†-dire les blocs de donn√©es, les blocs de pointeur, les m√©tadonn√©es, etc.). <br><br><pre> <code class="plaintext hljs">#include &lt;unistd.h&gt; void sync(void);</code> </pre> <br>  Dans l'impl√©mentation Linux, la fonction sync () ne retourne le contr√¥le qu'apr√®s que toutes les donn√©es ont √©t√© transf√©r√©es vers le p√©riph√©rique de disque (ou au moins vers son cache).  Mais dans SUSv3, il est autoris√© que sync () introduise simplement le transfert de donn√©es pour l'op√©ration d'E / S dans le plan et renvoie le contr√¥le jusqu'√† ce que le transfert soit termin√©. <br><br><blockquote>  Un thread du noyau ex√©cut√© en continu vide les tampons du noyau modifi√©s sur le disque s'ils n'ont pas √©t√© explicitement synchronis√©s pendant 30 secondes.  Cette op√©ration est effectu√©e afin d'√©viter que les tampons de donn√©es ne soient d√©synchronis√©s avec le fichier disque correspondant pendant de longues p√©riodes (et non pour les exposer au risque de perte en cas de d√©faillance du syst√®me).  Sous Linux 2.6, cette t√¢che est effectu√©e par le thread du noyau pdflush.  (Sous Linux 2.4, il a √©t√© ex√©cut√© par le thread du noyau kupdated.) <br><br>  La p√©riode (en centi√®mes de seconde) apr√®s laquelle le tampon modifi√© doit √™tre vid√© sur le disque par le code de flux pdflush est d√©finie dans le fichier / proc / sys / vm / dirty_expire_centisecs.  Des fichiers suppl√©mentaires dans le m√™me r√©pertoire contr√¥lent d'autres fonctionnalit√©s de l'op√©ration effectu√©e par le flux pdflush. <br></blockquote><br>  <b>Activer le mode de synchronisation pour tous les enregistrements: O_SYNC</b> <br><br>  La sp√©cification de l'indicateur O_SYNC lors de l'appel √† open () entra√Æne l'ex√©cution de toutes les op√©rations de sortie suivantes en mode synchrone: <br><br><pre> <code class="plaintext hljs">fd = open(pathname, O_WRONLY | O_SYNC);</code> </pre> <br>  Apr√®s cet appel √† open (), chaque op√©ration d'√©criture () effectu√©e sur un fichier vide automatiquement les donn√©es et les m√©tadonn√©es de fichier sur le disque (c'est-√†-dire que les √©critures sont effectu√©es en tant qu'op√©rations d'√©criture synchronis√©es avec l'int√©grit√© du fichier). <br><br><blockquote>  Dans les anciennes versions du syst√®me BSD, l'indicateur O_FSYNC √©tait utilis√© pour fournir les fonctionnalit√©s incluses avec l'indicateur O_SYNC.  Dans la glibc, l'indicateur O_FSYNC est d√©fini comme synonyme d'O_SYNC. </blockquote><br>  <b>Impact sur les performances de l'indicateur O_SYNC</b> <br><br>  L'utilisation de l'indicateur O_SYNC (ou des appels fr√©quents √† fsync (), fdatasync () ou sync ()) peut consid√©rablement affecter les performances.  Dans le tableau.  La figure 13.3 montre le temps n√©cessaire pour √©crire 1 million d'octets dans un fichier qui vient d'√™tre cr√©√© (dans le syst√®me de fichiers ext2) pour diff√©rentes tailles de tampon avec l'indicateur O_SYNC d√©fini et d√©coch√©.  Les r√©sultats ont √©t√© obtenus (en utilisant le programme filebuff / write_bytes.c fourni dans le code source du livre) en utilisant la version 2.6.30 du noyau ¬´vanilla¬ª et le syst√®me de fichiers ext2 avec une taille de bloc de 4096 octets.  Chaque ligne contient la valeur moyenne obtenue apr√®s 20 d√©marrages pour une taille de tampon donn√©e. <br><br>  Tableau 13.3.  L'effet de l'indicateur O_SYNC sur une vitesse d'√©criture de 1 million d'octets <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_r/va/c0/_rvac0j3fu9affstt4_poiq5ybw.png" alt="image"></div><br>  Comme vous pouvez le voir, la sp√©cification de l'indicateur O_SYNC entra√Æne une augmentation monstrueuse du temps pass√© lors de l'utilisation d'un tampon de 1 octet plus de 1000 fois.  Veuillez √©galement noter la grande diff√©rence qui se produit lors de l'ex√©cution des enregistrements avec l'indicateur O_SYNC entre le temps √©coul√© et le temps d'utilisation du processeur.  C'est une cons√©quence du blocage de l'ex√©cution du programme lorsque le contenu r√©el de chaque tampon est vid√© sur le disque. <br><br>  Dans les r√©sultats indiqu√©s dans le tableau.  13.3, un autre facteur affectant les performances lors de l'utilisation de O_SYNC n'est pas pris en compte.  Les lecteurs de disque modernes ont un grand cache interne et, par d√©faut, le param√®tre O_SYNC transf√®re simplement les donn√©es vers ce cache.  Si vous d√©sactivez la mise en cache du disque (√† l'aide de la commande hdparm ‚ÄìW0), l'impact sur les performances d'O_SYNC deviendra encore plus important.  Avec une taille de tampon de 1 octet, le temps √©coul√© passera de 1030 secondes √† environ 16 000 secondes.  Avec une taille de tampon de 4096 octets, le temps √©coul√© passera de 0,34 seconde √† 4 secondes.  Par cons√©quent, si vous devez forcer le vidage des tampons du noyau sur le disque, vous devez d√©terminer si vous pouvez concevoir votre application √† l'aide de tampons plus grands pour write () ou envisager d'utiliser des appels p√©riodiques fsync () ou fdatasync () au lieu de l'indicateur O_SYNC. <br><br>  <b>Drapeaux O_DSYNC et O_RSYNC</b> <br><br>  SUSv3 d√©finit deux indicateurs d'√©tat de fichier ouvert suppl√©mentaires li√©s aux E / S synchronis√©es: O_DSYNC et O_RSYNC. <br><br>  L'indicateur O_DSYNC entra√Æne des op√©rations d'√©criture synchronis√©es ult√©rieures avec l'int√©grit√© des donn√©es des E / S termin√©es (similaire √† l'utilisation de fdatasync ()).  L'effet de son fonctionnement est diff√©rent de l'effet provoqu√© par l'indicateur O_SYNC, dont l'utilisation conduit √† des op√©rations d'√©criture synchronis√©es ult√©rieures avec l'int√©grit√© du fichier (comme fsync ()). <br><br>  L'indicateur O_RSYNC est sp√©cifi√© avec O_SYNC ou O_DSYNC et conduit √† une extension du comportement associ√© √† ces indicateurs lors des op√©rations de lecture.  La sp√©cification des indicateurs O_RSYNC et O_DSYNC lors de l'ouverture du fichier entra√Æne des op√©rations de lecture synchronis√©es ult√©rieures avec l'int√©grit√© des donn√©es (c'est-√†-dire qu'avant la fin de la lecture, toutes les entr√©es de fichier en attente sont termin√©es en raison de la pr√©sence de O_DSYNC).  La sp√©cification des indicateurs O_RSYNC et O_SYNC lors de l'ouverture du fichier entra√Æne des op√©rations de lecture synchronis√©es ult√©rieures avec l'int√©grit√© du fichier (c'est-√†-dire qu'avant la fin de la lecture, toutes les entr√©es de fichier en attente sont termin√©es en raison de la pr√©sence d'O_SYNC). <br><br>  Avant la sortie de la version 2.6.33 du noyau, les indicateurs O_DSYNC et O_RSYNC n'√©taient pas impl√©ment√©s sous Linux et ces constantes √©taient d√©finies dans les fichiers d'en-t√™te glibc comme d√©finissant l'indicateur O_SYNC.  (Dans le cas de O_RSYNC, ce n'√©tait pas vrai, car O_SYNC n'affecte aucune caract√©ristique fonctionnelle des op√©rations de lecture.) <br><br>  √Ä partir de la version 2.6.33 du noyau, Linux impl√©mente l'indicateur O_DSYNC, et l'impl√©mentation de l'indicateur O_RSYNC sera probablement ajout√©e dans les futures versions du noyau. <br><br><blockquote>  Avant la sortie du noyau 2.6.33 sous Linux, il n'y avait pas d'impl√©mentation compl√®te de la s√©mantique O_SYNC.  Au lieu de cela, l'indicateur O_SYNC a √©t√© impl√©ment√© en tant que O_DSYNC.  Dans les applications li√©es aux anciennes versions de la biblioth√®que GNU C pour les noyaux plus anciens, sur les versions Linux 2.6.33 et ult√©rieures, l'indicateur O_SYNC se comporte toujours comme O_DSYNC.  Cela est fait pour maintenir le comportement familier de ces programmes.  (Pour pr√©server la compatibilit√© binaire en amont dans le noyau 2.6.33, le drapeau O_DSYNC a re√ßu l'ancien drapeau O_SYNC et le nouveau drapeau O_SYNC comprend le drapeau O_DSYNC (respectivement 04010000 et 010000 sur l'une des machines). Cela permet aux applications compil√©es avec de nouveaux fichiers d'en-t√™te. , obtenez au moins la s√©mantique O_DSYNC dans les noyaux publi√©s avant la version 2.6.33.) </blockquote><br><h3>  13.4.  Pr√©sentation de la mise en m√©moire tampon des E / S </h3><br>  Dans la fig.  La figure 13.1 montre le sch√©ma de mise en m√©moire tampon utilis√© (pour les fichiers de sortie) par la biblioth√®que stdio et le noyau, ainsi que les m√©canismes de contr√¥le de chaque type de mise en m√©moire tampon.  Si vous descendez le graphique au milieu, vous verrez le transfert des donn√©es utilisateur par les fonctions de la biblioth√®que stdio vers le tampon stdio, qui fonctionne dans l'espace m√©moire de l'utilisateur.  Lorsque ce tampon est plein, la biblioth√®que stdio a recours √† l'appel syst√®me write (), qui transf√®re les donn√©es vers le cache de tampon du noyau (situ√© dans la m√©moire du noyau).  En cons√©quence, le noyau lance une op√©ration de disque pour transf√©rer des donn√©es sur le disque. <br><br>  Dans la partie gauche du circuit de la fig.  13.1 montre les appels qui peuvent √™tre utilis√©s √† tout moment pour forcer explicitement le vidage de n'importe quel tampon.  La partie de droite montre les appels qui peuvent √™tre utilis√©s pour effectuer automatiquement une r√©initialisation en d√©sactivant la mise en m√©moire tampon dans la biblioth√®que stdio ou en activant la sortie de fichier d'un mode d'ex√©cution synchrone pour les appels syst√®me afin que chaque appel write () soit imm√©diatement vid√© sur le disque. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cc/1f/of/cc1fofbz5pqtee-lktnypfahsac.png" alt="image"></div><br><br><h3>  13.5.  Notification d'E / S du noyau </h3><br>  L'appel syst√®me posix_fadvise () permet au processus d'informer le noyau de sa m√©thode pr√©f√©r√©e d'acc√®s aux donn√©es de fichier. <br><br>  Le noyau peut (mais n'est pas oblig√©) d'utiliser les informations fournies par l'appel syst√®me posix_fadvise () pour optimiser son utilisation du cache de tampon, augmentant ainsi les performances d'E / S pour le processus et pour le syst√®me dans son ensemble.  L'appel √† posix_fadvise () n'affecte pas la s√©mantique du programme. <br><br><pre> <code class="plaintext hljs">#define _XOPEN_SOURCE 600 #include &lt;fcntl.h&gt; int posix_fadvise(int fd, off_t offset, off_t len, int advice);</code> </pre> <br>  Renvoie en cas de succ√®s 0 ou un nombre d'erreur positif lorsqu'il se produit <br><br>  L'argument fd est un descripteur de fichier qui identifie le fichier pour lequel le noyau doit √™tre contact√©.  Les arguments offset et len ‚Äã‚Äãidentifient la zone du fichier √† laquelle se rapporte la notification: offset indique l'offset initial de la zone et len ‚Äã‚Äãindique sa taille en octets.  La d√©finition de len √† 0 signifie que tous les octets sont signifi√©s, commen√ßant par offset et se terminant par la fin du fichier.  (Dans les versions du noyau ant√©rieures √† 2.6.6, la valeur 0 pour len √©tait interpr√©t√©e litt√©ralement comme 0 octet.) <br><br>  L'argument de conseil montre la nature pr√©vue de l'acc√®s du processus au fichier.  Il est d√©fini avec l'une des valeurs suivantes. <br><br>  POSIX_FADV_NORMAL - le processus n'a pas de notification sp√©ciale concernant les mod√®les de traitement.  Il s'agit du comportement par d√©faut si aucune notification n'est donn√©e pour le fichier.  Sous Linux, cette op√©ration d√©finit la fen√™tre pour lire de mani√®re proactive les donn√©es d'un fichier √† leur taille d'origine (128 Ko). <br><br>  POSIX_FADV_SEQUENTIAL - le processus implique la lecture s√©quentielle des donn√©es des d√©calages plus petits vers les plus grands.  Sous Linux, cette op√©ration d√©finit la fen√™tre pour lire de mani√®re proactive les donn√©es d'un fichier pour doubler sa valeur d'origine. <br><br>  POSIX_FADV_RANDOM - le processus implique l'acc√®s aux donn√©es dans un ordre al√©atoire.  Sous Linux, cette option d√©sactive la lecture proactive des donn√©es d'un fichier. <br><br>  POSIX_FADV_WILLNEED - le processus implique d'acc√©der √† la zone sp√©cifi√©e du fichier dans un avenir proche.  Le noyau lit les donn√©es de mani√®re pr√©ventive pour remplir le cache de tampon avec des donn√©es de fichier dans la plage sp√©cifi√©e par les arguments offset et len.  Les appels read () ult√©rieurs au fichier ne bloquent pas les E / S disque, mais r√©cup√®rent simplement les donn√©es du cache de tampon.  Le noyau ne fait aucune garantie quant √† la dur√©e pendant laquelle les donn√©es extraites du fichier sont dans le cache de tampon.  Si pendant le fonctionnement d'un autre processus ou noyau il y a un besoin particulier de m√©moire, la page sera √©ventuellement r√©utilis√©e.  En d'autres termes, si la m√©moire est en forte demande, nous devons garantir un petit intervalle de temps entre l'appel √† posix_fadvise () et l'appel (ou les appels) suivant √† read ().  (La fonctionnalit√© √©quivalente √† l'op√©ration POSIX_FADV_WILLNEED est fournie par l'appel syst√®me readahead () sp√©cifique √† Linux.) <br><br>  POSIX_FADV_DONTNEED - le processus n'implique pas d'appels √† la zone de fichiers sp√©cifi√©e dans un avenir proche.  De cette fa√ßon, le noyau est inform√© qu'il peut lib√©rer les pages de cache correspondantes (le cas √©ch√©ant).  Sous Linux, cette op√©ration s'effectue en deux √©tapes.  Premi√®rement, si la file d'attente d'√©criture sur le p√©riph√©rique h√¥te n'est pas remplie d'une s√©rie de demandes, le noyau rejette toutes les pages de cache modifi√©es dans la zone sp√©cifi√©e.  Le noyau tente alors de lib√©rer toutes les pages de cache de la zone sp√©cifi√©e.  Pour les pages modifi√©es dans cette zone, la deuxi√®me √©tape ne se terminera avec succ√®s que si elles ont √©t√© enregistr√©es sur le p√©riph√©rique de base au cours de la premi√®re √©tape, c'est-√†-dire que la file d'attente d'enregistrement sur le p√©riph√©rique n'est pas pleine.  √âtant donn√© que l'application ne peut pas v√©rifier l'√©tat de la file d'attente sur le p√©riph√©rique, vous pouvez garantir que les pages de cache sont lib√©r√©es en appelant fsync () ou fdatasync () sur le descripteur fd avant d'appliquer POSIX_FADV_DONTNEED. <br><br>  POSIX_FADV_NOREUSE - le processus implique un acc√®s unique aux donn√©es dans la zone sp√©cifi√©e du fichier, sans les r√©utiliser.  Ainsi, le noyau est inform√© qu'il peut lib√©rer des pages apr√®s un seul acc√®s √† celles-ci.  Sous Linux, cette op√©ration est actuellement ignor√©e. <br><br>  La sp√©cification posix_fadvise () n'apparaissait que dans SUSv3 et cette interface n'est pas prise en charge par toutes les impl√©mentations UNIX.  Sous Linux, l'appel posix_fadvise () est fourni depuis la version 2.6 du noyau. <br><br><h3>  13.6.  Contournement du cache de tampon: E / S directes </h3><br>  √Ä partir de la version 2.4 du noyau, Linux permet √† une application de contourner le cache de tampon lors de l'ex√©cution des E / S disque en d√©pla√ßant les donn√©es directement de l'espace m√©moire de l'utilisateur vers un fichier ou un p√©riph√©rique de disque.  Parfois, ce mode est appel√© E / S directes ou non trait√©es. <br><br><blockquote>  Les informations fournies ici concernent uniquement Linux et ne sont pas standardis√©es dans SUSv3.  Cependant, certaines options d'acc√®s direct aux E / S pour les p√©riph√©riques ou les fichiers sont fournies par la plupart des impl√©mentations UNIX. </blockquote><br>  Parfois, les E / S directes sont mal comprises comme moyen d'atteindre des performances d'E / S √©lev√©es.  Mais pour la plupart des applications, l'utilisation d'E / S directes peut r√©duire consid√©rablement les performances.  Le fait est que le noyau effectue plusieurs optimisations pour augmenter les performances d'E / S gr√¢ce √† l'utilisation d'un cache de tampon, y compris la lecture s√©quentielle proactive des donn√©es, l'ex√©cution d'E / S dans des grappes de blocs de disques et la possibilit√© pour les processus d'acc√©der au m√™me volume le m√™me fichier, partagez les tampons dans le cache.  Tous ces types d'optimisation lors de l'utilisation d'E / S directes sont perdus.  Il est destin√© uniquement aux applications ayant des exigences d'E / S sp√©cialis√©es, par exemple, des syst√®mes de gestion de base de donn√©es qui effectuent leur propre mise en cache et optimisation d'E / S, et qui n'ont pas besoin du noyau pour perdre du temps CPU et de la m√©moire pour effectuer les m√™mes t√¢ches. <br><br>  L'entr√©e-sortie directe peut √™tre effectu√©e soit par rapport √† un seul fichier, soit par rapport √† un p√©riph√©rique de bloc (par exemple, un disque).  Pour ce faire, lors de l'ouverture d'un fichier ou d'un p√©riph√©rique √† l'aide de l'appel open (), l'indicateur O_DIRECT est sp√©cifi√©. <br><br>  L'indicateur O_DIRECT fonctionne depuis la version 2.4.10 du noyau.  L'utilisation de cet indicateur n'est pas prise en charge par tous les syst√®mes de fichiers et versions du noyau Linux.  La plupart des syst√®mes de fichiers de base prennent en charge l'indicateur O_DIRECT, mais de nombreux syst√®mes de fichiers non UNIX (tels que VFAT) ne le font pas.  Vous pouvez tester la prise en charge de cette fonctionnalit√© en testant le syst√®me de fichiers s√©lectionn√© (si le syst√®me de fichiers ne prend pas en charge O_DIRECT, l'appel √† open () √©chouera avec une erreur EINVAL) ou en examinant le code source du noyau pour cela. <br><br><blockquote>  Si un processus a ouvert le fichier avec l'indicateur O_DIRECT et l'autre de la mani√®re habituelle (c'est-√†-dire en utilisant le cache de tampon), il n'y a pas de coh√©rence entre le contenu du cache de tampon et les donn√©es lues ou √©crites via les E / S directes.  Une telle √©volution doit √™tre √©vit√©e. <br><br>  Des informations sur la m√©thode obsol√®te (d√©sormais d√©conseill√©e) pour obtenir un acc√®s brut √† un p√©riph√©rique de disque peuvent √™tre trouv√©es sur la page de manuel raw (8). </blockquote><br>  <b>Restrictions d'alignement pour les E / S directes</b> <br><br>  √âtant donn√© que les E / S directes (√† la fois sur les p√©riph√©riques de disque et par rapport aux fichiers) impliquent un acc√®s direct au disque, certaines limitations doivent √™tre respect√©es lors de l'ex√©cution des E / S. <br><br>  - le tampon de donn√©es portable doit √™tre align√© sur la bordure de la m√©moire, un multiple de la taille du bloc. <br><br>  - Le d√©calage dans le fichier ou dans l'appareil √† partir duquel les donn√©es transf√©r√©es commencent doit √™tre un multiple de la taille du bloc. <br><br>  - La longueur des donn√©es transf√©r√©es doit √™tre un multiple de la taille du bloc. <br><br>  Le non-respect de l'une de ces restrictions entra√Ænera une erreur EINVAL.  Dans la liste ci-dessus, la taille de bloc fait r√©f√©rence √† la taille du bloc physique de l'appareil (g√©n√©ralement 512 octets). <br><br><blockquote>  Lors de l'ex√©cution d'E / S directes sous Linux 2.4, plus de restrictions sont impos√©es que sous Linux 2.6: l'alignement, la longueur et le d√©calage doivent √™tre un multiple de la taille du bloc logique du syst√®me de fichiers utilis√©.  (En r√®gle g√©n√©rale, la taille des blocs logiques dans un syst√®me de fichiers est de 1024, 2048 ou 4096 octets.) <br></blockquote><br>  <b>Exemple de programme</b> <br><br>   13.1     O_DIRECT     .        ,  (  ) ,     ,     , ,     ,       ,    ,  read().               4096 . <br><br>   ,      : <br><br><pre> <code class="plaintext hljs">$ ./direct_read /test/x 512  512    0 Read 512 bytes  $ ./direct_read /test/x 256 ERROR [EINVAL Invalid argument] read    512 $ ./direct_read /test/x 512 1 ERROR [EINVAL Invalid argument] read    512 $ ./direct_read /test/x 4096 8192 512 Read 4096 bytes  $ ./direct_read /test/x 4096 512 256 ERROR [EINVAL Invalid argument] read    512</code> </pre> <br><blockquote>    13.1   ,    ,    ,      memalign().  memalign()    7.1.4. </blockquote><br><pre> <code class="plaintext hljs">#define _GNU_SOURCE /*   O_DIRECT  &lt;fcntl.h&gt; */ #include &lt;fcntl.h&gt; #include &lt;malloc.h&gt; #include "tlpi_hdr.h" int main(int argc, char *argv[]) { int fd; ssize_t numRead; size_t length, alignment; off_t offset; void *buf; if (argc &lt; 3 || strcmp(argv[1], "‚Äìhelp") == 0) usageErr("%s file length [offset [alignment]]\n", argv[0]); length = getLong(argv[2], GN_ANY_BASE, "length"); offset = (argc &gt; 3) ? getLong(argv[3], GN_ANY_BASE, "offset") : 0; alignment = (argc &gt; 4) ? getLong(argv[4], GN_ANY_BASE, "alignment") : 4096; fd = open(argv[1], O_RDONLY | O_DIRECT); if (fd == -1) errExit("open"); /*  memalign()   ,   ,    .     'buf'  ,  'alignment',     .    ,   ,  ,    ,  256 ,     ,     512- .    '(char *)'        (     'void *',   memalign(). */ buf = (char *) memalign(alignment * 2, length + alignment) + alignment; if (buf == NULL) errExit("memalign"); if (lseek(fd, offset, SEEK_SET) == -1) errExit("lseek"); numRead = read(fd, buf, length); if (numRead == -1) errExit("read"); printf("Read %ld bytes\n", (long) numRead); exit(EXIT_SUCCESS); } _______________________________________________________________filebuff/direct_read.c</code> </pre> <br><br> ¬ª       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contenu</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Extrait</a> <br><br>    20%   ‚Äî <b>Linux</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436986/">https://habr.com/ru/post/fr436986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436976/index.html">Int√©gration de la v√©rification du mot de passe KeePass avec la base de donn√©es des fuites</a></li>
<li><a href="../fr436978/index.html">Jetons TOTP programmables dans un facteur de forme fob cl√©</a></li>
<li><a href="../fr436980/index.html">Intelligence artificielle - Le jour du Jugement dernier ou l'√¢ge d'or de la prosp√©rit√© mondiale</a></li>
<li><a href="../fr436982/index.html">Semaine de s√©curit√© 04: que faire des mots de passe</a></li>
<li><a href="../fr436984/index.html">Microsoft cesse de prendre en charge Windows 10 Mobile</a></li>
<li><a href="../fr436988/index.html">Appareil photo, moteur, Big Data: comment les studios de cin√©ma recherchent de nouveaux films en utilisant l'IA</a></li>
<li><a href="../fr436990/index.html">Zimbra et Zextras Suite sont enti√®rement compatibles avec les syst√®mes d'exploitation NTC IT ROSA</a></li>
<li><a href="../fr436992/index.html">Essai et erreur lors du choix du proxy inverse HTTP</a></li>
<li><a href="../fr436994/index.html">Liquibase et Maven</a></li>
<li><a href="../fr436996/index.html">Cours final de sp√©cialisation Python du groupe Mail.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>