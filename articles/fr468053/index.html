<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧖🏼 👭 👼🏻 Apprentissage automatique pour votre chasse à plat. Partie 1 🛐 ☹️ 🔒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Avez-vous déjà cherché un appartement? Souhaitez-vous ajouter un apprentissage automatique et rendre un processus plus intéressant? 



 Aujourd'hui, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apprentissage automatique pour votre chasse à plat. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468053/"><p>  Avez-vous déjà cherché un appartement?  Souhaitez-vous ajouter un apprentissage automatique et rendre un processus plus intéressant? </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/af/w7/7e/afw77esq32gd2e0admnmjfby4kk.png" alt="Appartements à Iekaterinbourg"></div><a name="habracut"></a><br><p>  Aujourd'hui, nous envisagerons d'appliquer le Machine Learning pour trouver un appartement optimal. </p><br><h2 id="introduction">  Présentation </h2><br><p> Tout d'abord, je veux clarifier ce moment et expliquer ce que signifie "un appartement optimal".  C'est un appartement avec un ensemble de caractéristiques différentes comme "zone", "quartier", "nombre de balcons" et ainsi de suite.  Et pour ces caractéristiques de l'appartement, nous attendons un prix spécifique.  Ressemble à une fonction qui prend plusieurs paramètres et renvoie un nombre.  Ou peut-être une boîte noire qui apporte de la magie. </p><br><p>  Mais ... il y a un grand "mais", parfois vous pouvez faire face à un appartement qui est trop cher pour une série de raisons comme une bonne position géographique.  En outre, il existe des quartiers plus prestigieux au centre d'une ville et des quartiers à l'extérieur de la ville.  Ou ... parfois, les gens veulent vendre leurs appartements parce qu'ils se déplacent vers un autre point de la Terre.  En d'autres termes, de nombreux facteurs peuvent affecter le prix.  Cela vous semble familier? </p><br><h2 id="little-stepaside">  Petit pas de côté </h2><br><p>  Avant de continuer, permettez-moi de faire une petite digression lyrique. <br>  J'ai vécu à Ekaterinbourg (la ville entre l'Europe et l'Asie, l'une des villes qui avaient organisé le Championnat du monde de football en 2018) pendant 5 ans. </p><br><p>  J'étais amoureux de ces jungles en béton.  Et je détestais cette ville pour l'hiver et les transports en commun.  C'est une ville en pleine croissance et chaque mois il y a des milliers et des milliers d'appartements à vendre. </p><br><p>  Oui, c'est une ville surpeuplée et polluée.  Dans le même temps - c'est un bon endroit pour analyser un marché immobilier.  J'ai reçu beaucoup de publicités pour des appartements, sur Internet.  Et j'utiliserai ces informations dans une plus large mesure. </p><br><p>  J'ai également essayé de visualiser différentes offres sur la carte d'Ekaterinbourg.  Oui, c'est l'image accrocheuse de habracut, elle a été faite sur Kepler.gl </p><br><p><img src="https://habrastorage.org/webt/af/w7/7e/afw77esq32gd2e0admnmjfby4kk.png" alt="image"></p><br><p>  Il y a plus de 2000 appartements d'une chambre qui ont été vendus en juillet 2019 à Iekaterinbourg.  Ils avaient un prix différent, de moins d'un million à près de 14 millions de roubles. </p><br><p>  Ces points se réfèrent à leur géo-position.  La couleur des points sur la carte représente le prix, plus le prix est proche de la couleur bleue, plus le prix est proche du rouge.  Vous pouvez le considérer comme une analogie avec des couleurs froides et chaudes, la couleur plus chaude est la plus grande est le prix. <br>  S'il vous plaît, souvenez-vous de ce moment, plus la couleur est rouge, plus la valeur de quelque chose est élevée.  La même idée fonctionne pour le bleu mais dans le sens du prix le plus bas. </p><br><p>  Vous avez maintenant un aperçu <em>général</em> de l'image et le moment de l'analyse arrive. </p><br><h3 id="goal">  Objectif </h3><br><p>  Qu'est-ce que je voulais quand j'habitais à Iekaterinbourg?  J'ai cherché un appartement assez bon, ou si nous parlons de ML - je voulais construire un modèle qui me donnera une recommandation d'achat. </p><br><p>  D'une part, si un appartement est trop cher, le modèle devrait recommander d'attendre une baisse du prix en affichant le prix attendu de cet appartement. <br>  D'un autre côté - si un prix est assez bon, selon l'état du marché - je devrais peut-être envisager cette offre. </p><br><p>  Bien sûr, il n'y a rien d'idéal et j'étais prêt à accepter une erreur de calcul.  Habituellement, pour ce type de tâche, utiliser une erreur de prédiction moyenne et j'étais prêt à une erreur de 10%.  Par exemple, si vous avez 2-3 millions de roubles russes, vous pouvez ignorer l'erreur dans 200-300 mille, vous pouvez vous le permettre.  Comme il me semblait. </p><br><h2 id="preparing">  Préparez </h2><br><p>  Comme je l'ai mentionné précédemment, il y avait beaucoup d'appartements, regardons-les attentivement. <br>  importer des pandas en tant que pd </p><br><pre><code class="python hljs">df = pd.read_csv(<span class="hljs-string"><span class="hljs-string">'flats.csv'</span></span>) df.shape</code> </pre> <br><p><img src="https://habrastorage.org/webt/qx/_0/qg/qx_0qgrsiuprxgsbno2ccihjdia.png" alt="image"></p><br><p>  2310 appartements pendant un mois, on pourrait en tirer quelque chose d'utile.  Qu'en est-il d'un aperçu général des données? </p><br><pre> <code class="python hljs">df.describe()</code> </pre> <br><p><img src="https://habrastorage.org/webt/is/pi/tj/ispitjyk3gpg-cbkhwfwnrayloa.png" alt="image"><br>  Il n'y a pas quelque chose d'extraordinaire - longitude, latitude, prix d'un appartement (l'étiquette " <em>coût</em> "), etc.  Oui, pour ce moment j'ai utilisé " <em>coût</em> " au lieu de " <em>prix</em> ", j'espère que cela ne conduira pas à des malentendus, veuillez les considérer comme les mêmes. </p><br><h2 id="cleaning">  Le nettoyage </h2><br><p>  Est-ce que chaque enregistrement a la même signification?  Certains d'entre eux sont des appartements représentés comme une cabine, vous pouvez y travailler, mais vous ne souhaitez pas y vivre.  Ce sont de petites pièces exiguës, pas un vrai appartement.  Laissez-les retirer. </p><br><pre> <code class="python hljs">df = df[df.total_area &gt;= <span class="hljs-number"><span class="hljs-number">20</span></span>]</code> </pre> <br><p>  Le prix de prédiction de l'appartement provient des problèmes les plus anciens de l'économie et des domaines connexes.  Il n'y avait rien de lié au terme "ML" et les gens essayaient de deviner le prix en fonction des mètres carrés / pieds. <br>  Donc, nous regardons ces colonnes / étiquettes et essayons d'en obtenir la distribution. </p><br><pre> <code class="python hljs">numerical_fields = [<span class="hljs-string"><span class="hljs-string">'total_area'</span></span>,<span class="hljs-string"><span class="hljs-string">'cost'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numerical_fields: mask = ~np.isnan(df[col]) sns.distplot(df[col][mask], color=<span class="hljs-string"><span class="hljs-string">"r"</span></span>,label=col) plot.show()</code> </pre> <br><p><img src="https://habrastorage.org/webt/w2/kj/eq/w2kjeqg-gr-qzcum6hcgqnoz6eo.png" alt="image"></p><br><p>  Eh bien ... il n'y a rien de spécial, ça ressemble à une distribution normale.  Peut-être que nous devons aller plus loin? </p><br><pre> <code class="python hljs">sns.pairplot(df[numerical_fields])</code> </pre> <br><p><img src="https://habrastorage.org/webt/df/fw/lg/dffwlggd_vemlbfl96qdw-0h3fw.png" alt="image"></p><br><p>  Oups ... quelque chose de mal est là.  Nettoyez les valeurs aberrantes dans ces domaines et essayez d'analyser à nouveau nos données. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#Remove outliers df = df[abs(df.total_area - df.total_area.mean()) &lt;= (3 * df.total_area.std())] df = df[abs(df.cost - df.cost.mean()) &lt;= (3 * df.cost.std())] #Redraw our data sns.pairplot(df[numerical_fields])</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/uu/zp/ok/uuzpokfgmae_4d2bxqvsmp53jns.png" alt="image"></p><br><p>  Les valeurs aberrantes ont disparu, et maintenant ça a l'air mieux. </p><br><h2 id="transformation">  Transformation </h2><br><p>  Le label "année", qui désigne une année de construction devrait être transformé en quelque chose de plus informatif.  Que ce soit l'âge de la construction, c'est-à-dire la façon dont une maison spécifique est ancienne. </p><br><pre> <code class="python hljs">df[<span class="hljs-string"><span class="hljs-string">'age'</span></span>] = <span class="hljs-number"><span class="hljs-number">2019</span></span> -df[<span class="hljs-string"><span class="hljs-string">'year'</span></span>]</code> </pre> <br><p>  Jetons un œil au résultat. </p><br><pre> <code class="python hljs">df.head()</code> </pre> <br><p><img src="https://habrastorage.org/webt/wq/j_/h-/wqj_h-w8jwshp3fi0ofyhhuanca.png" alt="image"></p><br><p>  Il existe toutes sortes de données, catégorielles, valeurs nanométriques, description textuelle et quelques informations géographiques (longitude et latitude).  Mettons de côté les derniers parce qu'à ce stade ils sont inutiles.  Nous y reviendrons plus tard. </p><br><pre> <code class="python hljs">df.drop(columns=[<span class="hljs-string"><span class="hljs-string">"lon"</span></span>,<span class="hljs-string"><span class="hljs-string">"lat"</span></span>,<span class="hljs-string"><span class="hljs-string">"description"</span></span>],inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><h3 id="categorical-data">  Données catégoriques </h3><br><p>  Habituellement, pour les données catégorielles, les gens utilisent différents types d'encodage ou des choses comme CatBoost qui offrent la possibilité de travailler avec eux comme avec des variables numériques. <br>  Mais, pourrions-nous utiliser quelque chose de plus logique et plus intuitif?  Il est maintenant temps de rendre nos données plus compréhensibles sans en perdre le sens. </p><br><h3 id="districts">  Districts </h3><br><p>  Eh bien, il y a plus de vingt districts possibles, pourrions-nous ajouter plus de 20 variables supplémentaires dans notre modèle?  Bien sûr, nous pourrions, mais ... devrions-nous?  Nous sommes des gens et nous pourrions comparer les choses, n'est-ce pas? <br>  Tout d'abord, tous les districts ne sont pas équivalents à un autre.  Dans le centre de la ville, les prix d'un mètre carré sont plus élevés, plus éloignés du centre-ville - ils diminuent.  Cela semble-t-il logique?  Pouvons-nous l'utiliser? <br>  Oui, nous pourrions certainement faire correspondre n'importe quel district avec un coefficient spécifique et le district le plus éloigné est celui des appartements les moins chers. </p><br><p>  Après avoir fait correspondre la ville et utilisé une autre carte de service Web (ArcGIS Online) a changé et a une vue similaire <br><img src="https://habrastorage.org/webt/ji/a6/sw/jia6swan_kxipvxp4y2p1ycfqk4.png" alt="image"></p><br><p>  J'ai utilisé la même idée que pour la visualisation à plat.  Le quartier le plus "prestigieux" et "cher" coloré en rouge et le moins - bleu.  Une température de couleur, vous vous en souvenez? <br>  De plus, nous devons manipuler notre trame de données. </p><br><pre> <code class="python hljs">district_map = {<span class="hljs-string"><span class="hljs-string">'alpha'</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'beta'</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, ... <span class="hljs-string"><span class="hljs-string">'delta'</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>, ... <span class="hljs-string"><span class="hljs-string">'epsilon'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>} df.district = df.district.str.lower() df.replace({<span class="hljs-string"><span class="hljs-string">"district"</span></span>: district_map}, inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><p>  La même approche sera utilisée pour décrire la qualité interne de l'appartement.  Parfois, il a besoin d'une réparation, parfois plat est assez bien et prêt à vivre.  Et dans d'autres cas, vous devriez dépenser de l'argent supplémentaire pour le rendre plus beau (pour changer les robinets, pour peindre les murs).  Il pourrait également y avoir des coefficients d'utilisation. </p><br><pre> <code class="python hljs">repair = {<span class="hljs-string"><span class="hljs-string">'A'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'B'</span></span>: <span class="hljs-number"><span class="hljs-number">0.6</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>: <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-string"><span class="hljs-string">'D'</span></span>: <span class="hljs-number"><span class="hljs-number">0.8</span></span>} df.repair.fillna(<span class="hljs-string"><span class="hljs-string">'D'</span></span>, inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) df.replace({<span class="hljs-string"><span class="hljs-string">"repair"</span></span>: repair}, inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><p>  Soit dit en passant, sur les murs.  Bien sûr, cela influence également le prix de l'appartement.  Le matériau moderne est meilleur que l'ancien, la brique est meilleure que le béton.  Les murs en bois sont un moment assez controversé, c'est peut-être un bon choix pour la campagne, mais pas si bon pour la vie urbaine. </p><br><p>  Nous utilisons la même approche que précédemment, et faisons une suggestion sur les lignes dont nous ne savons rien.  Oui, parfois les gens ne fournissent pas toutes les informations sur leur appartement.  En outre, sur la base de l'histoire, nous pouvons essayer de deviner le matériau des murs.  Dans une période de temps spécifique (par exemple la période la plus importante de Khrouchtchev) - nous connaissons les matériaux typiques pour la construction. </p><br><pre> <code class="python hljs">walls_map = {<span class="hljs-string"><span class="hljs-string">'brick'</span></span>: <span class="hljs-number"><span class="hljs-number">1.0</span></span>, ... <span class="hljs-string"><span class="hljs-string">'concrete'</span></span>: <span class="hljs-number"><span class="hljs-number">0.8</span></span>, <span class="hljs-string"><span class="hljs-string">'block'</span></span>: <span class="hljs-number"><span class="hljs-number">0.8</span></span>, ... <span class="hljs-string"><span class="hljs-string">'monolith'</span></span>: <span class="hljs-number"><span class="hljs-number">0.9</span></span>, <span class="hljs-string"><span class="hljs-string">'wood'</span></span>: <span class="hljs-number"><span class="hljs-number">0.4</span></span>} mask = df[df[<span class="hljs-string"><span class="hljs-string">'walls'</span></span>].isna()][df.year &gt;= <span class="hljs-number"><span class="hljs-number">2010</span></span>].index df.loc[mask, <span class="hljs-string"><span class="hljs-string">'walls'</span></span>] = <span class="hljs-string"><span class="hljs-string">'monolith'</span></span> mask = df[df[<span class="hljs-string"><span class="hljs-string">'walls'</span></span>].isna()][df.year &gt;= <span class="hljs-number"><span class="hljs-number">2000</span></span>].index df.loc[mask, <span class="hljs-string"><span class="hljs-string">'walls'</span></span>] = <span class="hljs-string"><span class="hljs-string">'concrete'</span></span> mask = df[df[<span class="hljs-string"><span class="hljs-string">'walls'</span></span>].isna()][df.year &gt;= <span class="hljs-number"><span class="hljs-number">1990</span></span>].index df.loc[mask, <span class="hljs-string"><span class="hljs-string">'walls'</span></span>] = <span class="hljs-string"><span class="hljs-string">'block'</span></span> mask = df[df[<span class="hljs-string"><span class="hljs-string">'walls'</span></span>].isna()].index df.loc[mask, <span class="hljs-string"><span class="hljs-string">'walls'</span></span>] = <span class="hljs-string"><span class="hljs-string">'block'</span></span> df.replace({<span class="hljs-string"><span class="hljs-string">"walls"</span></span>: walls_map}, inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) df.drop(columns=[<span class="hljs-string"><span class="hljs-string">'year'</span></span>],inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><p>  En outre, il y a des informations sur le balcon.  À mon humble avis - le balcon est une chose vraiment utile, donc je ne pouvais pas m'empêcher de le considérer. <br>  Malheureusement, il existe des valeurs nulles.  Si l'auteur d'une publicité avait vérifié les informations à son sujet, nous aurions des informations plus réalistes. <br>  Eh bien, s'il n'y a aucune information, cela signifiera "il n'y a pas de balcon". </p><br><pre> <code class="python hljs">df.balcony.fillna(<span class="hljs-number"><span class="hljs-number">0</span></span>,inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><p>  Après cela, nous déposons des colonnes avec des informations sur l'année de construction (nous avons une bonne alternative pour elle).  De plus, nous supprimons la colonne contenant des informations sur le type de bâtiment car il contient beaucoup de valeurs NaN et je n'ai trouvé aucune possibilité de combler ces lacunes.  Et nous supprimons toutes les lignes avec NaN que nous avons. </p><br><pre> <code class="python hljs">df.drop(columns=[<span class="hljs-string"><span class="hljs-string">'type_house'</span></span>],inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) df = df.astype(np.float64) df.dropna(inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><h2 id="checking">  Vérification </h2><br><p>  Donc ... nous avons utilisé une approche non standard et remplacer les valeurs catégorielles par leur représentation numérique.  Et maintenant, nous avons terminé avec une transformation de nos données. <br>  Une partie des données a été supprimée, mais en général, il s'agit d'un assez bon ensemble de données.  Regardons la corrélation entre les variables indépendantes. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show_correlation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(df)</span></span></span><span class="hljs-function">:</span></span> sns.set(style=<span class="hljs-string"><span class="hljs-string">"whitegrid"</span></span>) corr = df.corr() * <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-comment"><span class="hljs-comment"># Select upper triangle of correlation matrix mask = np.zeros_like(corr, dtype=np.bool) mask[np.triu_indices_from(mask)] = True # Set up the matplotlib figure f, ax = plt.subplots(figsize=(15, 11)) # Generate a custom diverging colormap cmap = sns.diverging_palette(220, 10) # Draw the heatmap with the mask and correct aspect ratio sns.heatmap(corr, mask=mask, cmap=cmap, center=0, linewidths=1, cbar_kws={"shrink": .7}, annot=True, fmt=".2f") plot.show() # df[columns] = scale(df[columns]) return df df1 = show_correlation(df.drop(columns=['cost']))</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/ht/dv/ir/htdvirxheiytace3nmaujf3wet8.png" alt="image"></p><br><p>  Euh ... c'est devenu très intéressant. <br>  <strong>Corrélation positive</strong> <br>  <em>Superficie totale - balcons</em> .  Pourquoi pas?  Si notre appartement est grand, il y aura un balcon. <br>  <strong>Corrélation négative</strong> <br>  <em>Superficie totale - âge</em> .  Le plus récent est plat, le plus grand est un espace de vie.  Sonne logique, les nouveaux sont plus spacieux que les anciens. <br>  <em>Âge - balcon</em> .  Plus l'ancien est plat, moins il y a de balcons.  On dirait une corrélation à travers une autre variable.  C'est peut-être un triangle Age-Balcony-Area où une variable a une influence implicite sur une autre.  Mettez cela en attente pendant un certain temps. <br>  <em>Âge - district.</em>  L'appartement le plus ancien est la grande probabilité qui sera placée dans les quartiers les plus prestigieux.  Cela pourrait-il être lié à un prix plus élevé près du centre? </p><br><p>  En outre, nous avons pu voir la corrélation avec la variable dépendante </p><br><pre> <code class="python hljs">plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>)) corr = df.corr()*<span class="hljs-number"><span class="hljs-number">100.0</span></span> sns.heatmap(corr[[<span class="hljs-string"><span class="hljs-string">'cost'</span></span>]], cmap= sns.diverging_palette(<span class="hljs-number"><span class="hljs-number">220</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>), center=<span class="hljs-number"><span class="hljs-number">0</span></span>, linewidths=<span class="hljs-number"><span class="hljs-number">1</span></span>, cbar_kws={<span class="hljs-string"><span class="hljs-string">"shrink"</span></span>: <span class="hljs-number"><span class="hljs-number">.7</span></span>}, annot=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, fmt=<span class="hljs-string"><span class="hljs-string">".2f"</span></span>)</code> </pre> <br><p><img src="https://habrastorage.org/webt/o7/ax/m1/o7axm1zph-x3eterypsfcod38zo.png" alt="image"></p><br><p>  C'est parti ... </p><br><p>  La très forte corrélation entre le domaine du flat et le prix.  Si vous voulez avoir un plus grand logement, il vous faudra plus d'argent. <br>  Il existe une corrélation négative entre les paires « <em>âge / coût</em> » et « <em>district / coût</em> ».  Un appartement dans une maison neuve moins abordable que l'ancienne.  Et à la campagne, les appartements sont moins chers. <br>  Quoi qu'il en soit, cela semble clair et compréhensible, alors j'ai décidé d'y aller. </p><br><h2 id="model">  Modèle </h2><br><p>  Pour les tâches liées au prix forfaitaire de prédiction, utilisez généralement la régression linéaire.  Selon une corrélation significative d'une étape précédente, nous pourrions essayer de l'utiliser également.  C'est un cheval de bataille qui convient à de nombreuses tâches. <br>  Préparez nos données pour les prochaines actions </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.model_selection <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> train_test_split y = df.cost X = df.drop(columns=[<span class="hljs-string"><span class="hljs-string">'cost'</span></span>]) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number"><span class="hljs-number">0.2</span></span>, random_state=<span class="hljs-number"><span class="hljs-number">42</span></span>)</code> </pre> <br><p>  De plus, nous créons des fonctions simples pour la prédiction et l'évaluation du résultat.  Faisons notre premier essai pour prédire le prix! </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">predict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, y_test, model)</span></span></span><span class="hljs-function">:</span></span> y = model.predict(X) score = round((r2_score(y_test, y) * <span class="hljs-number"><span class="hljs-number">100</span></span>), <span class="hljs-number"><span class="hljs-number">2</span></span>) print(<span class="hljs-string"><span class="hljs-string">f'Score on </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{model.__class__.__name__}</span></span></span><span class="hljs-string"> is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{score}</span></span></span><span class="hljs-string">'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> score <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">train_model</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, y, regressor)</span></span></span><span class="hljs-function">:</span></span> model = regressor.fit(X, y) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.linear_model <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> LinearRegression regressor = LinearRegression() model = train_model(X_train, y_train, regressor) predict(X_test, y_test, model)</code> </pre> <br><p><img src="https://habrastorage.org/webt/ak/v3/_a/akv3_antf7wwaxndcpjwx90rvju.png" alt="image"></p><br><p>  Eh bien ... 76,67% de précision.  Est-ce un grand nombre ou non?  Selon mon point de vue, ce n'est pas mal.  De plus, c'est un bon point de départ.  Bien sûr, ce n'est pas idéal et il y a un potentiel d'amélioration. </p><br><p>  Dans le même temps - nous avons essayé de prédire une seule partie des données.  Qu'en est-il de l'application de la même stratégie pour d'autres données?  Oui, le temps de la validation croisée. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_cross_validation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, y, model)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.model_selection <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> KFold, cross_val_score regressor_name = model.__class__.__name__ fold = KFold(n_splits=<span class="hljs-number"><span class="hljs-number">10</span></span>, shuffle=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, random_state=<span class="hljs-number"><span class="hljs-number">0</span></span>) scores_on_this_split = cross_val_score(estimator=model, X=X, y=y, cv=fold, scoring=<span class="hljs-string"><span class="hljs-string">'r2'</span></span>) scores_on_this_split = np.round(scores_on_this_split * <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) mean_accuracy = scores_on_this_split.mean() print(<span class="hljs-string"><span class="hljs-string">f'Crossvaladaion accuracy on </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{model.__class__.__name__}</span></span></span><span class="hljs-string"> is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{mean_accuracy}</span></span></span><span class="hljs-string">'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mean_accuracy do_cross_validation(X, y, model)</code> </pre> <br><p><img src="https://habrastorage.org/webt/yn/uf/3y/ynuf3yr9ew4kgjrvnb-nifevbnq.png" alt="image"></p><br><p>  Le résultat de la validation croiséeNous prenons maintenant un autre résultat.  73 est inférieur à 76. Mais, c'est aussi un bon candidat jusqu'à un moment où nous en aurons un meilleur.  Cela signifie également qu'une régression linéaire fonctionne assez stable sur notre ensemble de données. </p><br><p>  Et c'est maintenant le moment de la dernière étape. </p><br><p>  Nous examinerons la meilleure caractéristique de la régression linéaire - l' <strong>interprétabilité</strong> . <br>  Cette famille de modèles, contrairement aux modèles plus complexes, a une meilleure capacité de compréhension.  Il y a juste quelques nombres avec des coefficients et vous pouvez mettre vos nombres dans l'équation, faire des calculs simples et avoir un résultat. </p><br><p>  Essayons d'interpréter notre modèle </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">estimate_model</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model)</span></span></span><span class="hljs-function">:</span></span> sns.set(style=<span class="hljs-string"><span class="hljs-string">"white"</span></span>, context=<span class="hljs-string"><span class="hljs-string">"talk"</span></span>) f, ax = plot.subplots(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, figsize=(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>), sharex=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) sns.barplot(x=model.coef_, y=X.columns, palette=<span class="hljs-string"><span class="hljs-string">"vlag"</span></span>, ax=ax) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(model.coef_.astype(int)): ax.text(v + <span class="hljs-number"><span class="hljs-number">3</span></span>, i + <span class="hljs-number"><span class="hljs-number">.25</span></span>, str(v), color=<span class="hljs-string"><span class="hljs-string">'black'</span></span>) ax.set_title(<span class="hljs-string"><span class="hljs-string">f"Coefficients"</span></span>) estimate_model(regressor)</code> </pre> <br><p><img src="https://habrastorage.org/webt/1j/bc/_a/1jbc_apacascsr3cakmwz4qbnu8.png" alt="Les coefficients de notre modèle"></p><br><p>  L'image semble assez logique.  <em>Balcon / Murs / Surface / Réparation</em> contribuent <strong>positivement</strong> à un prix forfaitaire. <br>  Plus le plat est élevé, plus la <strong>contribution négative est importante</strong> .  S'applique également à l'âge.  Le plus ancien appartement est le prix le plus bas. </p><br><p>  C'était donc un voyage fascinant. <br>  Nous sommes partis du terrain, utilisons l'approche atypique pour la transformation des données basée sur le point de vue humain (les nombres au lieu des variables factices), les variables vérifiées et leur relation les unes avec les autres.  Après cela, nous construisons notre modèle simple, utilisé la validation croisée pour tester son.  Et comme la cerise sur le gâteau - regardez les internes du modèle, ce qui nous donne confiance en notre chemin. </p><br><p>  Mais!  Ce n'est pas la fin de notre voyage mais seulement une pause.  Nous allons essayer de changer notre modèle à l'avenir et peut-être (juste peut-être) cela augmentera la précision de la prédiction. </p><br><p>  <strong>Merci d'avoir lu!</strong> </p><br><blockquote>  La deuxième partie est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">là</a> <br></blockquote><p>  PS Les données sources et le bloc-notes Ipython <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s'y</a> trouvent </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468053/">https://habr.com/ru/post/fr468053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468041/index.html">Annonce de l'interface Web de Kubernetes Web View (et un bref aperçu des autres interfaces Web pour Kubernetes)</a></li>
<li><a href="../fr468043/index.html">Comment créer un kit d'interface utilisateur à vendre. Étapes de développement d'un système de conception commerciale</a></li>
<li><a href="../fr468047/index.html">Utilisation des hiérarchies dans lsFusion</a></li>
<li><a href="../fr468049/index.html">Utilisation de werf pour déployer des graphiques Helm complexes</a></li>
<li><a href="../fr468051/index.html">VDS avec Windows Server sous licence pour 100 roubles: mythe ou réalité?</a></li>
<li><a href="../fr468057/index.html">Développement de système d'exploitation de type Unix - Multitâche et appels système (7)</a></li>
<li><a href="../fr468059/index.html">Ma deuxième semaine avec Haiku: beaucoup de diamants cachés et d'agréables surprises, ainsi que quelques problèmes</a></li>
<li><a href="../fr468061/index.html">Cron sur Linux: historique, utilisation et appareil</a></li>
<li><a href="../fr468063/index.html">Angulareact</a></li>
<li><a href="../fr468067/index.html">Fonctionnement de la composition alpha</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>