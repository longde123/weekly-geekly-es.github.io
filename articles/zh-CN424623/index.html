<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍⚖️ 👨🏽‍⚖️ 🧒🏾 让我们在Go上处理声音 🈳 🔵 👉🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="免责声明：我不考虑用于声音和语音识别的任何算法和API。 本文介绍音频问题以及如何使用Go解决问题。 




 phono是用于处理声音的应用程序框架。 它的主要功能是利用各种技术来制造输送机，以处理声音  为你  以您需要的方式。 


 除了采用不同的技术外，输送机还需要做什么？为什么还要使用...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>让我们在Go上处理声音</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424623/"><blockquote> 免责声明：我不考虑用于声音和语音识别的任何算法和API。 本文介绍音频问题以及如何使用Go解决问题。 </blockquote><p><img src="https://habrastorage.org/webt/gg/cf/7i/ggcf7ihwchhcfrbsnrwdpohwczg.png" alt="地鼠"></p><br><p> <code>phono</code>是用于处理声音的应用程序框架。 它的主要功能是利用各种技术来制造输送机，以处理声音 <del> 为你 </del> 以您需要的方式。 </p><br><p> 除了采用不同的技术外，输送机还需要做什么？为什么还要使用其他框架？ 现在让我们弄清楚。 </p><a name="habracut"></a><br><h2 id="otkuda-zvuk"> 声音从哪里来？ </h2><br><p> 到2018年，声音已成为人类与技术互动的标准方式。 大多数IT巨头<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">已经创建</a>了自己的语音助手，或者现在正在这样做。 语音控制已经在大多数操作系统上，并且语音消息传递是任何Messenger的典型功能。 在世界上， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">大约一千家</a>初创公司正在从事自然语言处理， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">约有200家正在</a>从事语音识别。 </p><br><p> 与音乐类似的故事。 它可以在任何设备上播放，并且录音对所有拥有计算机的人都可用。 音乐软件是由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">全球数百家公司</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">和数千名爱好者开发</a>的。 </p><br><h2 id="a-nametasksa-obschie-zadachi"> 常见任务 </h2><br><p> 如果您必须处理声音，那么以下条件听起来应该很熟悉： </p><br><ul><li> 必须从文件，设备，网络等<strong>获得</strong>音频。 </li><li> 必须<strong>处理</strong>音频：添加效果，转码，分析等。 </li><li> 音频必须<strong>传输</strong>到文件，设备，网络等。 </li><li> 数据在小缓冲区中传输。 </li></ul><br><p> 事实证明，这是一条常规的管道-数据流经过多个处理阶段。 </p><br><h2 id="resheniya"> 解决方案 </h2><br><p> 为了清楚起见，让我们从现实生活中完成一项任务。 例如，您需要将语音转换为文本： </p><br><ul><li> 我们从设备录制音频 </li><li> 消除噪音 </li><li> 均衡 </li><li> 将信号传递到语音识别API </li></ul><br><p> 像其他任何任务一样，此任务有多种解决方案。 </p><br><h3 id="v-lob"> 额头 </h3><br><p> 仅铁杆 <del> 骑单车的人 </del> 程序员。 我们直接通过声卡驱动程序录制声音，编写智能降噪和多频段均衡器。 这非常有趣，但是您可能会忘记几个月的原始任务。 </p><br><p> 很长很困难。 </p><br><h3 id="po-normalnomu"> 正常的 </h3><br><p> 一种替代方法是使用现有的API。 您可以使用ASIO，CoreAudio，PortAudio，ALSA等录制音频。 还有多种类型的插件需要处理：AAX，VST2，VST3，AU。 </p><br><p> 多种选择并不意味着您可以一次使用所有内容。 通常，以下限制适用： </p><br><ol><li> 作业系统 并非所有API在所有操作系统上都可用。 例如，AU是本机OS X技术，仅在此可用。 </li><li> 程式语言 大多数音频库都是用C或C ++编写的。  1996年，Steinberg发行了第一个版本的VST SDK，它仍然是最受欢迎的插件标准。  20年后，不再需要用C / C ++编写：对于VST，Java，Python，C＃，Rust中都有包装器，还有谁知道。 尽管语言仍然有局限性，但现在甚至可以在JavaScript中处理声音。 </li><li> 功能性。 如果任务简单明了，则无需编写新的应用程序。 相同的FFmpeg可以做很多事情。 </li></ol><br><p> 在这种情况下，复杂程度取决于您的选择。 在最坏的情况下，您必须处理多个库。 如果您根本不走运，那么您可以使用复杂的抽象和完全不同的界面。 </p><br><h3 id="chto-v-itoge"> 结果如何？ </h3><br><p> 您必须在<strong>非常复杂</strong>和<strong>复杂</strong>之间选择： </p><br><ul><li> 要么处理几个底层API来编写自行车 </li><li> 要么处理多个API，然后尝试与他们成为朋友 </li></ul><br><p> 无论选择哪种方法，任务始终落在传送带上。 所使用的技术可能有所不同，但本质是相同的。 问题是，除了解决实际问题，您还必须编写 <del> 自行车 </del> 传送带。 </p><br><p> 但是有一个出路。 </p><br><h2 id="phono"> 唱机 </h2><br><p><img src="https://habrastorage.org/webt/ym/fw/h6/ymfwh6c8hjwgig8hzksgbut2ifm.jpeg" alt="唱机"></p><br><p>  <code>phono</code>创建是为了解决常见问题-“ <strong>接收，处理和传输</strong> ”声音。 为此，他使用管道作为最自然的抽象。  Go <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方博客上</a>有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇文章</a>描述了管道模式。 管道的主要思想是，数据处理有多个阶段，这些阶段彼此独立工作并通过通道交换数据。 您需要什么。 </p><br><p> 为什么去 </p><br><p> 首先，大多数音频程序和库都是用C编写的，而Go通常被称为其后继程序。 此外，还有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cgo</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">许多</a>现有音频库的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">活页夹</a> 。 您可以使用。 </p><br><p> 其次，以我个人的观点，Go是一门好语言。 我不会深入，但是我会注意到它的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">多线程</a> 。 通道和gorutins大大简化了输送机的实施。 </p><br><h3 id="abstrakcii"> 抽象化 </h3><br><p>  <code>phono</code>的心脏是<code>pipe.Pipe</code>类型。 实现管道的是他。 就像<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">博客示例中一样</a> ，共有三种类型的阶段： </p><br><ol><li>  <code>pipe.Pump</code> （英式泵）- <strong>接收</strong>声音，仅输出通道 </li><li>  <code>pipe.Processor</code> （英语处理器）-声音<strong>处理</strong> ，输入和输出通道 </li><li>  <code>pipe.Sink</code> （英语水槽）-声音<strong>传输</strong> ，仅输入通道 </li></ol><br><p> 在<code>pipe.Pipe</code>内部<code>pipe.Pipe</code>数据在缓冲区中传递。 建立管道的规则： </p><br><p><img src="https://habrastorage.org/webt/go/ym/ep/goymepjg4pds_picireejjsshnq.png" alt="pipe_diagram"></p><br><ol><li> 一管<code>pipe.Pump</code> </li><li>  <code>pipe.Processor</code>一个接一个地放置 </li><li> 一个或多个<code>pipe.Sink</code>平行放置 </li><li> 所有<code>pipe.Pipe</code>组件必须具有相同的内容： <br><ul><li> 缓冲区大小（消息） </li><li> 采样率 </li><li> 通道数 </li></ul></li></ol><br><p> 最低配置为泵和一个水槽，其余为可选。 </p><br><p> 让我们看几个例子。 </p><br><h3 id="prostoy"> 简单的 </h3><br><p>  <strong>任务：</strong>播放wav文件。 </p><br><p> 让我们<strong>将</strong>其转换为“ <strong>接收，处理，转移</strong> ”的形式： </p><br><ol><li> 从WAV文件<strong>获取</strong>音频 </li><li>  <strong>将</strong>音频<strong>传输</strong>到端口音频设备 </li></ol><br><p><img src="https://habrastorage.org/webt/qz/5p/qg/qz5pqgxqfydujch359ei8fsp0pg.png"></p><br><p> 音频被读取并立即播放。 </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> example <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/dudk/phono"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/dudk/phono/pipe"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/dudk/phono/portaudio"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/dudk/phono/wav"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Example: // Read .wav file // Play it with portaudio func easy() { wavPath := "_testdata/sample1.wav" bufferSize := phono.BufferSize(512) // wav pump wavPump, err := wav.NewPump( wavPath, bufferSize, ) check(err) // portaudio sink paSink := portaudio.NewSink( bufferSize, wavPump.WavSampleRate(), wavPump.WavNumChannels(), ) // build pipe p := pipe.New( pipe.WithPump(wavPump), pipe.WithSinks(paSink), ) defer p.Close() // run pipe err = p.Do(pipe.Run) check(err) }</span></span></code> </pre> </div></div><br><p> 首先，我们创建未来管道的元素： <code>wav.Pump</code>和<code>portaudio.Sink</code>并将它们传递给<code>pipe.New</code>构造函数。  <code>p.Do(pipe.actionFn) error</code>函数启动管道并等待其完成。 </p><br><h3 id="slozhnee"> 更难 </h3><br><p>  <strong>任务：</strong>将wav文件拆分为样本，从样本中组成曲目，保存结果并同时播放。 </p><br><p> 音轨是样本序列，样本是一小段音频。 要剪切音频，必须首先将其加载到内存中。 为此，请使用<code>phono/asset</code>包中的<code>asset.Asset</code>类型。 我们将任务分为标准步骤： </p><br><ol><li> 从WAV文件<strong>获取</strong>音频 </li><li>  <strong>将</strong>音频<strong>传输</strong>到内存 </li></ol><br><p> 现在，我们用手制作样本，将其添加到轨道中并完成任务： </p><br><ol><li> 从轨道<strong>获取</strong>音频 </li><li>  <strong>将</strong>音频<strong>传输</strong>到 <br><ul><li>  WAV文件 </li><li> 端口音频设备 </li></ul></li></ol><br><p><img src="https://habrastorage.org/webt/r3/q7/yv/r3q7yvccvkpjxbho7s3iwr2zisc.png" alt="example_normal"></p><br><p> 同样，没有处理阶段，但是有两个管道！ </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> example <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/dudk/phono"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/dudk/phono/asset"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/dudk/phono/pipe"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/dudk/phono/portaudio"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/dudk/phono/track"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/dudk/phono/wav"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Example: // Read .wav file // Split it to samples // Put samples to track // Save track into .wav and play it with portaudio func normal() { bufferSize := phono.BufferSize(512) inPath := "_testdata/sample1.wav" outPath := "_testdata/example4_out.wav" // wav pump wavPump, err := wav.NewPump(inPath, bufferSize) check(err) // asset sink asset := &amp;asset.Asset{ SampleRate: wavPump.WavSampleRate(), } // import pipe importAsset := pipe.New( pipe.WithPump(wavPump), pipe.WithSinks(asset), ) defer importAsset.Close() err = importAsset.Do(pipe.Run) check(err) // track pump track := track.New(bufferSize, asset.NumChannels()) // add samples to track track.AddFrame(198450, asset.Frame(0, 44100)) track.AddFrame(66150, asset.Frame(44100, 44100)) track.AddFrame(132300, asset.Frame(0, 44100)) // wav sink wavSink, err := wav.NewSink( outPath, wavPump.WavSampleRate(), wavPump.WavNumChannels(), wavPump.WavBitDepth(), wavPump.WavAudioFormat(), ) // portaudio sink paSink := portaudio.NewSink( bufferSize, wavPump.WavSampleRate(), wavPump.WavNumChannels(), ) // final pipe p := pipe.New( pipe.WithPump(track), pipe.WithSinks(wavSink, paSink), ) err = p.Do(pipe.Run) }</span></span></code> </pre> </div></div><br><p> 与前面的示例相比，有两个<code>pipe.Pipe</code> 。 第一个将数据传输到内存，以便您可以剪切样本。 第二个在末尾有两个收件人： <code>wav.Sink</code>和<code>portaudio.Sink</code> 。 使用此方案，声音可以同时记录在wav文件中并进行播放。 </p><br><h3 id="esche-slozhnee"> 更难 </h3><br><p>  <strong>任务：</strong>读取两个wav文件，混合，处理vst2插件并保存到新的wav文件。 </p><br><p>  <code>phono/mixer</code> <code>mixer.Mixer</code>有一个简单的<code>mixer.Mixer</code> 。 它可以从多个源<strong>传输</strong>信号并混合一个。 为此，它同时实现了<code>pipe.Pump</code>和<code>pipe.Sink</code> 。 </p><br><p> 同样，该任务包含两个子任务。 第一个看起来像这样： </p><br><ol><li>  <strong>获取</strong>音频WAV文件 </li><li>  <strong>将</strong>音频<strong>传输</strong>到调音台 </li></ol><br><p> 第二： </p><br><ol><li> 从调音台<strong>获取</strong>音频。 </li><li>  <strong>处理</strong>音频插件 </li><li>  <strong>将</strong>音频<strong>传输</strong>到WAV文件 </li></ol><br><p><img src="https://habrastorage.org/webt/xw/hj/ad/xwhjadlajgapbhjufym72qjgssq.png" alt="example_hard"></p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> example <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/dudk/phono"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/dudk/phono/mixer"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/dudk/phono/pipe"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/dudk/phono/vst2"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/dudk/phono/wav"</span></span> vst2sdk <span class="hljs-string"><span class="hljs-string">"github.com/dudk/vst2"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Example: // Read two .wav files // Mix them // Process with vst2 // Save result into new .wav file // // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment"> For example both wav files have same characteristics ie: sample rate, bit depth and number of channels. // In real life implicit conversion will be needed. func hard() { bs := phono.BufferSize(512) inPath1 := "../_testdata/sample1.wav" inPath2 := "../_testdata/sample2.wav" outPath := "../_testdata/out/example5.wav" // wav pump 1 wavPump1, err := wav.NewPump(inPath1, bs) check(err) // wav pump 2 wavPump2, err := wav.NewPump(inPath2, bs) check(err) // mixer mixer := mixer.New(bs, wavPump1.WavNumChannels()) // track 1 track1 := pipe.New( pipe.WithPump(wavPump1), pipe.WithSinks(mixer), ) defer track1.Close() // track 2 track2 := pipe.New( pipe.WithPump(wavPump2), pipe.WithSinks(mixer), ) defer track2.Close() // vst2 processor vst2path := "../_testdata/Krush.vst" vst2lib, err := vst2sdk.Open(vst2path) check(err) defer vst2lib.Close() vst2plugin, err := vst2lib.Open() check(err) defer vst2plugin.Close() vst2processor := vst2.NewProcessor( vst2plugin, bs, wavPump1.WavSampleRate(), wavPump1.WavNumChannels(), ) // wav sink wavSink, err := wav.NewSink( outPath, wavPump1.WavSampleRate(), wavPump1.WavNumChannels(), wavPump1.WavBitDepth(), wavPump1.WavAudioFormat(), ) check(err) // out pipe out := pipe.New( pipe.WithPump(mixer), pipe.WithProcessors(vst2processor), pipe.WithSinks(wavSink), ) defer out.Close() // run all track1Done, err := track1.Begin(pipe.Run) check(err) track2Done, err := track2.Begin(pipe.Run) check(err) outDone, err := out.Begin(pipe.Run) check(err) // wait results err = track1.Wait(track1Done) check(err) err = track2.Wait(track2Done) check(err) err = out.Wait(outDone) check(err) }</span></span></code> </pre> </div></div><br><p> 已经有三个<code>pipe.Pipe</code> ，它们都通过一个混合器互连。 首先，使用<code>p.Begin(pipe.actionFn) (pipe.State, error)</code>函数。 与<code>p.Do(pipe.actionFn) error</code> ，它不会阻止调用，而只是返回一个状态，然后可以等待<code>p.Wait(pipe.State) error</code> 。 </p><br><h2 id="chto-dalshe"> 接下来是什么？ </h2><br><p> 我希望<code>phono</code>成为最方便的应用程序框架。 如果您在声音方面遇到问题，则无需了解复杂的API，也无需花时间研究标准。 所需要做的就是用合适的元件建造一条输送机并运行它。 </p><br><p> 半年来，拍摄了以下包装： </p><br><ul><li>  <code>phono/wav</code>读取/写入WAV文件 </li><li>  <code>phono/vst2</code> -VST2 SDK的绑定不完整，而您只能打开插件并调用其方法，但不能调用所有结构 </li><li>  <code>phono/mixer</code> -混音器，添加N个信号，没有平衡和音量 </li><li>  <code>phono/asset</code> -缓冲采样 </li><li>  <code>phono/track</code> -顺序读取样本（分层不完整） </li><li>  <code>phono/portaudio</code>实验期间的信号播放 </li></ul><br><p> 除了此列表以外，新想法和想法的积压也不断增加，其中包括： </p><br><ul><li> 倒数计时 </li><li> 动态变化的管道 </li><li>  HTTP泵/水槽 </li><li> 参数自动化 </li><li> 重采样处理器 </li><li> 搅拌机平衡和体积 </li><li> 实时泵 </li><li> 多轨同步泵 </li><li> 完整的vst2 </li></ul><br><p> 在以下文章中，我将分析： </p><br><ul><li>  <code>pipe.Pipe</code>生命周期-由于结构复杂，其状态由最终原子控制 </li><li> 如何编写管道阶段 </li></ul><br><p> 这是我的第一个开源项目，因此，我将感谢您的帮助和建议。 不客气 </p><br><h2 id="ssylki"> 参考文献 </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">唱机</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">并发模式：管道和取消</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN424623/">https://habr.com/ru/post/zh-CN424623/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN424609/index.html">如何扩展Kubernetes</a></li>
<li><a href="../zh-CN424611/index.html">如何从自由职业者创建员工</a></li>
<li><a href="../zh-CN424613/index.html">体验没有Reduce的Redux使用</a></li>
<li><a href="../zh-CN424615/index.html">曲线函数输出不仅可以在Wolfram Mathematica中平滑限制参数，信号</a></li>
<li><a href="../zh-CN424621/index.html">非电影超级英雄。 谁以及如何保护Lakhta Center施工现场免于火灾？</a></li>
<li><a href="../zh-CN424625/index.html">Aeroflot Web服务源代码泄漏</a></li>
<li><a href="../zh-CN424627/index.html">更改收银机。 第一部分</a></li>
<li><a href="../zh-CN424629/index.html">初创企业如何与投资者交流时增加投资机会？</a></li>
<li><a href="../zh-CN424633/index.html">STACKLEAK如何提高Linux内核安全性</a></li>
<li><a href="../zh-CN424635/index.html">欢迎来到Sberbank Data Science Journey 2018-机器学习算法竞赛</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>