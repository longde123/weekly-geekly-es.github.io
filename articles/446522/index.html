<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💪 🙅 👼🏿 Swift 5.1: ¿qué hay de nuevo? 🤽🏽 🦅 😭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Swift 5.0 estuvo disponible con el lanzamiento de Xcode 10.2, pero el trabajo en la próxima versión continúa y ya hay noticias de lo que puede esperar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Swift 5.1: ¿qué hay de nuevo?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446522/"><img src="https://habrastorage.org/webt/fi/zt/dn/fiztdnga2fbfx1-9joaxn3crp_o.png"><br><br>  Swift 5.0 estuvo disponible con el lanzamiento de Xcode 10.2, pero el trabajo en la próxima versión continúa y ya hay noticias de lo que puede esperar en él. <br><br>  Una característica clave de <b>Swift 5.1</b> es la <b>estabilidad del módulo</b> , lo que nos permite usar bibliotecas de terceros sin preocuparnos de con qué versión del compilador Swift fueron creadas.  Parece la <b>estabilidad ABI</b> que obtuvimos en Swift 5.0, pero hay una ligera diferencia: la estabilidad ABI resuelve las diferencias en las versiones de Swift en tiempo de ejecución y la estabilidad del módulo en tiempo de compilación. <br><br>  Además de esta importante innovación, recibiremos varias mejoras importantes en Swift, y en este artículo las repasaremos con ejemplos para que pueda verlas en acción. <br><a name="habracut"></a><br><h3>  Ser universal </h3><br>  <a href="">SE-0068</a> expande el uso de <b>Self</b> , de modo que se refiere al tipo que lo contiene dentro de clases, estructuras y enumeraciones.  Esto suele ser útil para los tipos dinámicos cuando es necesario determinar el tipo exacto de algo en tiempo de ejecución. <br><br>  Como ejemplo, considere el siguiente código: <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NetworkManager</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">maximumActiveRequests</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printDebugData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Maximum network requests: \(NetworkManager.maximumActiveRequests)."</span></span>) } }</code> </pre> <br>  Aquí definimos la propiedad estática <b>maximumActiveRequests</b> dentro de la clase <b>NetworkManager</b> y agregamos el método <b>printDebugData ()</b> para imprimir esta propiedad.  Aquí todo está bien, pero solo hasta que decidamos heredar de <b>NetworkManager</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThrottledNetworkManager</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NetworkManager</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">maximumActiveRequests</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> } }</code> </pre> <br>  En este heredero, cambiamos la propiedad maximumActiveRequests para que ahora sea igual a uno, pero si llamamos a <b>printDebugData ()</b> , <b>inferirá el</b> valor de la clase padre: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> manager = <span class="hljs-type"><span class="hljs-type">ThrottledNetworkManager</span></span>() manager.printDebugData()</code> </pre> <br>  Aquí deberíamos obtener 1 en lugar de 4, y aquí viene el rescate SE-0068: podemos usar <b>Self</b> <u>(con la 'S' mayúscula)</u> para referirnos al tipo actual.  Así que ahora podemos reescribir el método <b>printDebugData ()</b> de la clase padre de esta manera: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImprovedNetworkManager</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">maximumActiveRequests</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printDebugData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Maximum network requests: \(Self.maximumActiveRequests)."</span></span>) } }</code> </pre> <br>  Es decir, <b>Self</b> funciona de la misma manera que funcionaba en protocolos en versiones anteriores de Swift. <br><br><h3>  Advertencias de ambigüedad <b>ninguna</b> </h3><br>  <b>Las</b> opciones en Swift se implementan como una enumeración con dos opciones: <b>algunas</b> y <b>ninguna</b> .  Esto puede generar confusión si creamos nuestra propia enumeración que no tiene una opción y la envolvemos en <b>opcional</b> .  Por ejemplo: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BorderStyle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">none</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> solid(thickness: <span class="hljs-type"><span class="hljs-type">Int</span></span>) }</code> </pre> <br>  Cuando se utiliza no opcional, todo está limpio: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> border1: <span class="hljs-type"><span class="hljs-type">BorderStyle</span></span> = .<span class="hljs-keyword"><span class="hljs-keyword">none</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(border1)</code> </pre> <br>  Esto generará "ninguno".  Pero si usamos opcional para esta enumeración, entonces encontraremos un problema: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> border2: <span class="hljs-type"><span class="hljs-type">BorderStyle?</span></span> = .<span class="hljs-keyword"><span class="hljs-keyword">none</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(border2)</code> </pre><br>  Aquí se imprimirá cero, ya que Swift cree que .none significa que opcional está <u>vacío</u> , aunque en realidad es opcional <u>con un valor de</u> BorderStyle.none. <br>  En Swift 5.1, en caso de tal ambigüedad, se mostrará una advertencia: <br>  "Suponiendo que te refieres a 'Opcional.Ninguno';  ¿quiso decir 'BorderStyle.none' en su lugar? <br>  Por lo tanto, se informará al desarrollador que con su código no todo puede ser sencillo. <br><br><h3>  Emparejamiento de enumeraciones opcionales y no opcionales </h3><br>  Swift es lo suficientemente inteligente como para comprender la construcción de cambio / caso al combinar texto opcional / no opcional y valores enteros, pero no en el caso de enumeraciones. <br><br>  Ahora en Swift 5.1 podemos usar switch / case para hacer coincidir las opciones de enumeración opcionales y no opcionales: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BuildStatus</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> starting <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> inProgress <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> complete } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> status: <span class="hljs-type"><span class="hljs-type">BuildStatus?</span></span> = .inProgress <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> status { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .inProgress: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Build is starting…"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .complete: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Build is complete!"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Some other build status"</span></span>) }</code> </pre> <br>  Swift puede asignar enumeraciones opcionales a opciones no opcionales, y aquí se mostrará "La construcción está comenzando ...". <br><br><h3>  Comparar colecciones ordenadas </h3><br>  <a href="">SE-0240</a> introdujo la capacidad de calcular diferencias entre colecciones ordenadas, así como aplicar el resultado de comparación resultante a colecciones.  Esto puede ser de interés para los desarrolladores que tienen colecciones complejas en una vista de tabla y necesitan agregar o eliminar muchos elementos usando animación. <br><br>  El principio básico es simple: Swift 5.1 proporciona una nueva <b>diferencia de</b> método <b>(de :)</b> , que determina las diferencias entre dos colecciones ordenadas: qué elementos agregar y cuáles eliminar.  Esto se aplica a cualquier colección ordenada que contenga artículos que cumplan con el protocolo <b>Equatable</b> . <br><br>  Para demostrar esto, crearemos dos matrices de valores, calcularemos las diferencias de una y otra, y luego revisaremos la lista de diferencias y las aplicaremos para que las dos colecciones sean iguales. <br><br>  Nota: dado que Swift ahora se distribuye como parte de los sistemas operativos de Apple, se deben utilizar nuevas herramientas de idioma con la verificación <b>#disponible</b> para asegurarse de que el código se ejecute en un sistema operativo que admita la funcionalidad requerida.  Para la funcionalidad que se ejecuta en sistemas operativos desconocidos y no anunciados que pueden lanzarse en el futuro, se utiliza un número de versión especial, "9999", que significa: "Todavía no conocemos el número de versión correcto". <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scores1 = [<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">91</span></span>, <span class="hljs-number"><span class="hljs-number">95</span></span>, <span class="hljs-number"><span class="hljs-number">98</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> scores2 = [<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">98</span></span>, <span class="hljs-number"><span class="hljs-number">95</span></span>, <span class="hljs-number"><span class="hljs-number">91</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> #available(iOS <span class="hljs-number"><span class="hljs-number">9999</span></span>, *) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> diff = scores2.difference(from: scores1) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> change <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> diff { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> change { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .remove(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> offset, <span class="hljs-number"><span class="hljs-number">_</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span>): scores1.remove(at: offset) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .insert(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> offset, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> element, <span class="hljs-number"><span class="hljs-number">_</span></span>): scores1.insert(element, at: offset) } } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(scores1) }</code> </pre> <br>  Para una animación más avanzada, podemos usar el tercer parámetro en la lista resultante de diferencias: <b>relatedWith</b> .  Por lo tanto, en lugar de <b>.insert (let offset, let element, _),</b> podemos escribir .insert (let offset, let element, letsociatedWith).  Esto nos da la capacidad de rastrear simultáneamente pares de cambios: mover el elemento en la colección dos posiciones hacia abajo es eliminar el elemento y luego agregarlo, y <b>asociado con</b> "une" estos dos cambios juntos y le permite considerar este movimiento. <br><br>  En lugar de aplicar las diferencias manualmente, una por una, puede aplicarlas de una sola vez utilizando el nuevo método de <b>aplicación ()</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> #available(iOS <span class="hljs-number"><span class="hljs-number">9999</span></span>, *) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> diff = scores2.difference(from: scores1) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = scores1.applying(diff) ?? [] }</code> </pre> <br><h3>  Crear matrices sin inicializar </h3><br>  <a href="">SE-0245</a> introdujo un nuevo inicializador para matrices que no lo llena con valores predeterminados.  Estaba disponible anteriormente como una API privada, lo que significaba que Xcode no lo solicitó al completar el código, pero puede usarlo si lo necesita y comprende el riesgo de que esta funcionalidad no sea en el futuro. <br><br>  Para usar el inicializador, establezca el tamaño de la matriz, luego pase el cierre que llena la matriz con valores.  Un cierre recibirá un puntero inseguro a un búfer mutable, así como un segundo parámetro en el que indica cuántos valores realmente utiliza. <br><br>  Por ejemplo, podemos crear una matriz de 10 enteros aleatorios como este: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> randomNumbers = <span class="hljs-type"><span class="hljs-type">Array</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;(_unsafeUninitializedCapacity: <span class="hljs-number"><span class="hljs-number">10</span></span>) { buffer, initializedCount <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-number"><span class="hljs-number">10</span></span> { buffer[x] = <span class="hljs-type"><span class="hljs-type">Int</span></span>.random(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">10</span></span>) } initializedCount = <span class="hljs-number"><span class="hljs-number">10</span></span> }</code> </pre> <br>  Hay varias reglas: <br><br><ol><li>  No necesita usar todo el volumen que solicitó, pero no puede excederlo.  Es decir, si establece el tamaño de la matriz en 10, puede establecer <b>initializedCount</b> en el rango de 0 a 10, pero no 11. </li><li>  si no inicializó los elementos utilizados en la matriz, por ejemplo, configuró <b>initializedCount</b> en 5, pero no proporcionó valores reales a los elementos 0 a 4, lo más probable es que reciban valores aleatorios.  Como sabes, esta es una mala opción. </li><li>  Si no configura <b>initializedCount</b> , será igual a 0 y se perderán todos los datos que asignó. </li></ol><br>  Sí, podríamos reescribir el código usando <b>map ()</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> randomNumbers2 = (<span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">9</span></span>).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>.random(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">10</span></span>) }</code> </pre> <br>  Obviamente, esto es más legible, pero no tan efectivo: creamos un rango, luego una nueva matriz vacía, le asignamos un tamaño y "revisamos" todo el rango, aplicando un cierre a cada elemento. <br><br><h3>  Conclusión </h3><br>  Swift 5.1 todavía está en desarrollo, y aunque la rama final para Swift ya pasó, los cambios de algunos otros proyectos relacionados aún son visibles. <br><br>  Entonces, el cambio más importante es la <b>estabilidad del módulo</b> , y se sabe que el equipo de desarrollo está trabajando duro en esto.  No dieron una fecha de lanzamiento exacta, aunque dijeron que Swift 5.1 tuvo un tiempo de desarrollo significativamente más corto en comparación con Swift 5.0, que requirió una concentración extraordinaria de energía y atención.  Podemos asumir el acceso a WWDC19, pero es obvio que este no es el caso cuando necesita apresurarse a una fecha determinada. <br><br>  Otro punto que merece atención.  Dos cambios en esta lista (“Advertencias en caso de ambigüedad de la opción ninguno” y “Emparejamiento de enumeraciones opcionales y no opcionales”) no fueron el resultado de la evolución de Swift, pero se reconocieron como errores y se ajustaron. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446522/">https://habr.com/ru/post/446522/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446512/index.html">.NET Core Workers como servicios de Windows</a></li>
<li><a href="../446514/index.html">Gmail tiene 15 años</a></li>
<li><a href="../446516/index.html">Visualización del tiempo de renacimiento de Roshan</a></li>
<li><a href="../446518/index.html">Cortafuegos de aplicaciones web</a></li>
<li><a href="../446520/index.html">Cómo comenzó todo: la historia de los drones voladores</a></li>
<li><a href="../446530/index.html">Word2vec en imágenes</a></li>
<li><a href="../446532/index.html">Upwork introduce una tarifa por el derecho a escribir a un cliente potencial</a></li>
<li><a href="../446534/index.html">Visual Studio 2019 lanzado</a></li>
<li><a href="../446536/index.html">Colas y JMeter: Intercambio con editor y suscriptor</a></li>
<li><a href="../446538/index.html">PhotoGuru cambió al "lado oscuro" y al "más sabio"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>