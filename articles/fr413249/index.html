<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐵 🆎 👇🏼 Écriture d'un module du noyau Linux: I2C 🚘 📈 🐼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Habr, bonjour! 

 Cet article se concentre sur le développement du module du noyau Linux I2C (Inter-Integrated Circuit). Ce qui suit décrit le process...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Écriture d'un module du noyau Linux: I2C</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413249/">  Habr, bonjour! <br><br>  Cet article se concentre sur le développement du module du noyau Linux I2C (Inter-Integrated Circuit).  Ce qui suit décrit le processus d'implémentation de la structure de base du pilote I2C, dans lequel vous pouvez facilement ajouter l'implémentation des fonctionnalités nécessaires. <br><br>  Nous décrivons les données d'entrée: bloc I2C pour le nouveau processeur «câblé» au FPGA, exécutant la version 3.18.19 de Linux et les périphériques (EEPROM AT24C64 et BME280). <br><br>  Le principe de fonctionnement d'I2C est assez simple, mais si vous avez besoin de rafraîchir vos connaissances, vous pouvez lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><img src="https://habrastorage.org/webt/jq/rh/yg/jqrhyg8bveyubub7hysu0gxrkms.png"><br>  <i>Figure 1. Diagramme temporel des signaux du bus I2C</i> <br><a name="habracut"></a><br>  Avant de commencer à développer un pilote, voyons comment les applications de l'espace utilisateur interagissent avec le module du noyau, pour cela: <br><br><ol><li>  Nous mettons en œuvre une petite application d'espace utilisateur, dont le but est de lire l'ID de registre I2C unique de l'appareil.  Cette étape vous permettra de comprendre l'interface à travers laquelle l'échange se produit entre le module du noyau et l'application utilisateur; </li><li> Familiarisons-nous avec l'option de transmission des messages I2C par le module du noyau; </li><li>  Ajoutez le module du noyau à l'assembly et décrivez le matériel des périphériques dans l'arborescence des périphériques; </li><li>  Nous implémentons la structure générale (squelette) du pilote I2C avec quelques explications. </li></ol><br>  Malheureusement, il n'est pas possible de joindre les vraies sources du pilote développé.  De plus, je tiens à noter que tous les noms, noms et carte d'enregistrement du contrôleur sont modifiés.  Même la moitié des fonctionnalités développées n'étaient pas incluses dans le squelette du pilote, cependant, la structure du pilote est un bon point de départ pour le développement.  Des exemples de pilotes I2C peuvent être trouvés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h3>  <b>Première étape</b> </h3><br>  Tout d'abord, familiarisons-nous avec l'utilitaire i2cdetect.  Le résultat d'i2cdetect est le suivant: <br><pre><code class="cpp hljs">./i2cdetect -y <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> abcdef <span class="hljs-number"><span class="hljs-number">00</span></span>: — — — — — — — — — — — — — <span class="hljs-number"><span class="hljs-number">10</span></span>: — — — — — — — — — — — — — — — — <span class="hljs-number"><span class="hljs-number">20</span></span>: — — — — — — — — — — — — — — — — <span class="hljs-number"><span class="hljs-number">30</span></span>: — — — — — — — — — — — — — — — — <span class="hljs-number"><span class="hljs-number">40</span></span>: — — — — — — — — — — — — — — — — <span class="hljs-number"><span class="hljs-number">50</span></span>: <span class="hljs-number"><span class="hljs-number">50</span></span> — — — — — — — — — — — — — — — <span class="hljs-number"><span class="hljs-number">60</span></span>: — — — — — — — — — — — — — — — — <span class="hljs-number"><span class="hljs-number">70</span></span>: — — — — — — — —</code> </pre> <br>  L'utilitaire expose séquentiellement le bus d'adresse de périphérique sur l'I2C et, à la réception d'une réponse positive (dans ce cas, la réponse positive est ACK), affiche le numéro d'adresse de périphérique sur le bus dans la console. <br><br>  Nous allons écrire un petit programme qui lit l'ID unique du capteur de température et afficher le résultat de son travail dans la console.  Cela semble très simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/ioctl.h&gt; #include &lt;linux/i2c.h&gt; #include &lt;linux/i2c-dev.h&gt; #define I2C_ADAPTER "/dev/i2c-0" int read_buffer(int fd) { struct i2c_rdwr_ioctl_data data; struct i2c_msg messages[2]; unsigned char write_buf[1] = {0xD0}, read_buf[1] = {0x00}; unsigned char write[200]; /* * .addr -   () * .flags -     (0 - w, 1 - r) * .len - - /  * .buf -      */ messages[0].addr = 0x50; messages[0].flags = 0; messages[0].len = 1; messages[0].buf = write_buf; messages[1].addr = 0x50; messages[1].flags = 1; messages[1].len = 1; messages[1].buf = read_buf; data.msgs = messages; data.nmsgs = 2; if (ioctl(fd, I2C_RDWR, &amp;data) &lt; 0) printf("Cant send data!\n"); else printf("ID = 0x%x\n", read_buf[0]); } int main(int argc, char **argv) { int fd; /* * Open I2C file descriptor. */ fd = open(I2C_ADAPTER, O_RDWR); if (fd &lt; 0) { printf("Unable to open i2c file\n"); return 0; } read_buffer(fd); return 0; }</span></span></span></span></code> </pre><br>  Il devient clair que le module du noyau reçoit des données sous la forme de champs de message i2c_rdwr_ioctl_data.  La structure contient des champs tels que i2c_msg et nmsgs, qui sont utilisés pour la transmission: <br><br><ul><li>  .addr - adresses des périphériques; </li><li>  .flags - type d'opération (lecture ou écriture); </li><li>  .len - la longueur du message actuel; </li><li>  .buf- presse-papiers. </li></ul><br><h3>  <b>Deuxième étape</b> </h3><br>  Maintenant, je ne plonge pas dans les entrailles, je me familiarise avec une version du pilote I2C. <br>  Comme déjà établi, le module noyau reçoit des messages sous forme de structure.  Par exemple, considérez l'algorithme du pilote lors de l'exécution d'une opération d'écriture (partie dépendante du matériel): <br><br><ul><li>  Le premier TX FIFO est rempli: l'adresse de l'appareil vient en premier, puis les données restantes sont transmises; </li><li>  Le registre d'état d'interruption ISR est effacé et les interruptions dans le registre IER sont activées (dans ce cas, une interruption se produit lorsqu'il n'y a pas de données dans TX FIFO); </li><li>  La transmission de données est autorisée et le bit de démarrage est défini sur le bus. </li></ul><br>  Tous les échanges de données ultérieurs auront lieu dans le gestionnaire d'interruption. <br>  Les pilotes qui fonctionnent sur cet algorithme peuvent être trouvés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  De plus, le contrôleur peut ne pas avoir FIFO, mais seulement un seul registre de transfert, mais c'est un cas spécial avec une taille FIFO de un. <br><br><h3>  <b>Étape trois</b> </h3><br>  Ajoutez le module du noyau à l'assembly et décrivez le matériel des périphériques dans l'arborescence des périphériques: <br><br>  1. Créez un fichier source dans le répertoire suivant: <br><br><pre> <code class="cpp hljs">cd drivers/i2c/busses/ vim i2c-skel.c :wq</code> </pre><br>  En conséquence, le fichier apparaît: <br><br><pre> <code class="cpp hljs">drivers/i2c/busses/i2c-skel.c</code> </pre><br><br>  2. Ajoutez la configuration du pilote à <i>drivers / i2c / busses / Kconfig</i> : <br><br><pre> <code class="cpp hljs">config I2C_SKEL tristate <span class="hljs-string"><span class="hljs-string">"I2C adapter"</span></span> help If you say yes to <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> option, support will be included <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the I2C interface.</code> </pre><br>  3. Ajoutez le <i>pilote drivers / i2c / busses / Makefile</i> à l'assembly: <br><br><pre> <code class="cpp hljs">obj-$(CONFIG_I2C_SKEL) += i2c-skel.o</code> </pre><br>  4. Ajoutez une description du bloc I2C à devicetree (* .dts) et prenez également immédiatement en charge le périphérique eeprom: <br><br><pre> <code class="cpp hljs"> i2c: i2c@f8f01d00 { compatible = <span class="hljs-string"><span class="hljs-string">"skel,skel-i2c"</span></span>; <span class="hljs-meta"><span class="hljs-meta">#address-cells = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;1&gt;; #size-cells = &lt;0&gt;; reg = &lt;0x43c00000 0x100&gt;; interrupt-parent = &lt;&amp;ps7_scugic_0&gt;; interrupts = &lt;0 29 4&gt;; clock-names = "skel-i2c"; clocks = &lt;&amp;clkc 38&gt;; clock-frequency = &lt;100000&gt;; 24c64@50 { compatible = "at,24c64"; pagesize = &lt;32&gt;; reg = &lt;0x50&gt;; }; } ;</span></span></span></span></code> </pre><br>  Les étapes ci-dessus ne seront pas examinées en détail, mais les lecteurs curieux peuvent jeter un œil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h3>  <b>Quatrième étape</b> </h3><br>  Après vous être familiarisé avec le principe du pilote, procédons à l'implémentation. <br>  Tout d'abord, connectez les fichiers d'en-tête, décrivez la carte de registre «virtuelle», ainsi que la présentation du pilote I2C. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* i2c-skel.c: I2C bus driver. * * Name Surname &lt;name@surname.ru&gt; * * This file is licensed under the terms of the GNU General Public License * version 2. This program is licensed "as is" without any warranty of any * kind, whether express or implied. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/platform_device.h&gt; #include &lt;linux/i2c.h&gt; #include &lt;linux/io.h&gt; #include &lt;linux/clk.h&gt; #include &lt;linux/interrupt.h&gt; #include &lt;linux/time.h&gt; #include &lt;linux/delay.h&gt; #include &lt;linux/device.h&gt; /* * Registers description. */ #define SKEL_I2C_ID 0x00 /* Core Identifier register */ #define SKEL_I2C_ISR 0x14 /* Interrupt Status Register */ #define SKEL_I2C_ISR_DNE BIT(0) /* One byte transaction done */ #define SKEL_I2C_ISR_ARB BIT(1) /* Arbitration lost */ #define SKEL_I2C_ISR_TXE BIT(2) /* RX FIFO nearly full */ #define SKEL_I2C_ISR_NACK BIT(3) /* No ACK */ #define SKEL_I2C_IER 0x18 /* Interrupt Enable Register */ #define SKEL_I2C_IER_DNE BIT(0) /* Enable DNE IRQ */ #define SKEL_I2C_IER_ARB BIT(1) /* Enable ARB LOSR IRQ */ #define SKEL_I2C_IER_TXE BIT(2) /* Enable TX FIFO EPMTY IRQ */ #define SKEL_I2C_IER_NACK BIT(3) /* Enable NACK IRQ */ #define SKEL_I2C_CTRL 0x1C /* Control Register */ #define SKEL_I2C_CTRL_EN BIT(0) /* Enable I2C controller */ #define SKEL_I2C_CTRL_START BIT(1) /* Send START condition */ #define SKEL_I2C_CTRL_R BIT(2) /* Read command */ #define SKEL_I2C_CTRL_W BIT(3) /* Write command */ #define SKEL_I2C_CTRL_STOP BIT(4) /* Send STOP cindition */ #define SKEL_I2C_TX 0x20 /* TX FIFO */ #define SKEL_I2C_RX 0x24 /* RX FIFO */ #define SKEL_I2C_CLK 0x28 /* Clock Prescale Register*/ #define SKEL_I2C_TIMEOUT 100000 #define SKEL_I2C_XFER_TIMEOUT (msecs_to_jiffies(500)) #define FIFO_SIZE_TX 1024 #define FIFO_SIZE_RX 1024 int presc = -1; module_param(presc, int, S_IRUGO | S_IWUSR); /* * skel_i2c - I2C device context * @base: pointer to register struct * @msg: pointer to current message * @mlen: number of bytes transferred in msg * @dev: device reference * @adap: i2c core abstraction * @msg_complete: xfer completion object * @clk: reference for i2c input clock * @err: error occured * @buf: ptr to msg buffer * @bus_clock: current i2c bus clock rate * @lock: spinlock for IRQ synchronization */ struct skel_i2c { void __iomem *base; struct i2c_msg *msg; size_t mlen; struct device *dev; struct i2c_adapter adap; struct completion msg_complete; struct clk *clk; u32 bus_clock; int err; u32 addr; u8 *buf; spinlock_t lock; };</span></span></span></span></code> </pre><br>  Les principaux registres de contrôle du contrôleur sont: <br><br><ul><li>  Registre de contrôle (CTRL) - registre de contrôle; </li><li>  Registre d'état d'interruption (ISR) - registre d'état d'interruption; </li><li>  Registre d'activation d'interruption (IER) - Registre de masque d'interruption. </li></ul><br>  Le cœur du pilote est la structure skel_i2c, qui contient des champs tels que: <br><br><ul><li>  .base - pointeur vers le début de la carte d'enregistrement; </li><li>  .msg - pointeur vers le message actuel; </li><li>  .adap - abstraction I2C <a href="">(cliquez sur)</a> . </li></ul><br>  Passons à la partie la plus pratique, décrivons les types de périphériques pris en charge par le pilote, <br>  Fonctionnalité de l'adaptateur I2C et interface de messagerie I2C: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of_device_id</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_i2c_match</span></span></span><span class="hljs-class">[] = {</span></span> { .compatible = <span class="hljs-string"><span class="hljs-string">"skel,skel-i2c"</span></span>, }, { .compatible = <span class="hljs-string"><span class="hljs-string">"at,24c64"</span></span>, }, {}, }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> u32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skel_i2c_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct i2c_adapter *adap)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i2c_algorithm</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_i2c_algo</span></span></span><span class="hljs-class"> = {</span></span> .master_xfer = skel_i2c_xfer, .functionality = skel_i2c_func, }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">platform_driver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_i2c_driver</span></span></span><span class="hljs-class"> = {</span></span> .probe = skel_i2c_probe, .remove = skel_i2c_remove, .driver = { .name = <span class="hljs-string"><span class="hljs-string">"skel-i2c"</span></span>, .of_match_table = skel_i2c_match, }, }; module_platform_driver(skel_i2c_driver); MODULE_AUTHOR(<span class="hljs-string"><span class="hljs-string">"Name Surname"</span></span>); MODULE_DESCRIPTION(<span class="hljs-string"><span class="hljs-string">"I2C bus driver"</span></span>); MODULE_LICENSE(<span class="hljs-string"><span class="hljs-string">"GPL"</span></span>); MODULE_ALIAS(<span class="hljs-string"><span class="hljs-string">"platform:skel-i2c"</span></span>);</code> </pre><br>  À partir des noms des structures et des fonctions, leur objectif est évident, nous décrivons uniquement la structure principale à partir de ce qui précède: <br><br><ul><li>  skel_i2c_driver - décrit le nom du pilote, un tableau des périphériques et fonctions pris en charge qui sont appelés lorsque le module du noyau est chargé ou supprimé du système. </li></ul><br>  Il est temps d'enregistrer le pilote dans le système, ce qui signifie implémenter la fonction d'initialisation du contrôleur, et également décrire skel_i2c_probe (appelé lorsque le pilote est chargé dans le système) et skel_i2c_remove (appelé lorsque le pilote est supprimé du système). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skel_i2c_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct skel_i2c *rdev)</span></span></span><span class="hljs-function"> </span></span>{ u32 bus_clk_khz = rdev-&gt;bus_clock / <span class="hljs-number"><span class="hljs-number">1000</span></span>; u32 clk_khz = clk_get_rate(rdev-&gt;clk) / <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> prescale; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diff; prescale = clk_khz / (<span class="hljs-number"><span class="hljs-number">5</span></span> * bus_clk_khz) - <span class="hljs-number"><span class="hljs-number">1</span></span>; prescale = clamp(prescale, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>); diff = clk_khz / (<span class="hljs-number"><span class="hljs-number">5</span></span> * (prescale <span class="hljs-number"><span class="hljs-number">1</span></span>)) - bus_clk_khz; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(diff) &gt; bus_clk_khz / <span class="hljs-number"><span class="hljs-number">10</span></span>) { dev_err(rdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Unsupported clock settings: clk: %d KHz, bus: %d KHz\n"</span></span>, clk_khz, bus_clk_khz); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EINVAL; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (presc != <span class="hljs-number"><span class="hljs-number">-1</span></span>) i2c_write(presc, rdev-&gt;base, SKEL_I2C_CLK); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> i2c_write(prescale, rdev-&gt;base, SKEL_I2C_CLK); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skel_i2c_probe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct platform_device *pdev)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_i2c</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rdev</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resource</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">res</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> irq, ret; u32 val; rdev = devm_kzalloc(&amp;pdev-&gt;dev, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*rdev), GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rdev) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOMEM; res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="hljs-number"><span class="hljs-number">0</span></span>); rdev-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(rdev-&gt;base)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PTR_ERR(rdev-&gt;base); irq = platform_get_irq(pdev, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (irq &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Missing interrupt resource\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> irq; } rdev-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(rdev-&gt;clk)) { dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Missing clock\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PTR_ERR(rdev-&gt;clk); } rdev-&gt;dev = &amp;pdev-&gt;dev; init_completion(&amp;rdev-&gt;msg_complete); spin_lock_init(&amp;rdev-&gt;lock); val = of_property_read_u32(pdev-&gt;dev.of_node, <span class="hljs-string"><span class="hljs-string">"clock-frequency"</span></span>, &amp;rdev-&gt;bus_clock); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val) { dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Default to 100kHz\n"</span></span>); rdev-&gt;bus_clock = <span class="hljs-number"><span class="hljs-number">100000</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* default clock rate */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rdev-&gt;bus_clock &gt; <span class="hljs-number"><span class="hljs-number">400000</span></span>) { dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Invalid clock-frequency %d\n"</span></span>, rdev-&gt;bus_clock); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EINVAL; } ret = devm_request_irq(&amp;pdev-&gt;dev, irq, skel_i2c_isr, <span class="hljs-number"><span class="hljs-number">0</span></span>, pdev-&gt;name, rdev); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret) { dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Failed to claim IRQ %d\n"</span></span>, irq); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } ret = clk_prepare_enable(rdev-&gt;clk); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret) { dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Failed to enable clock\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } skel_i2c_init(rdev); i2c_set_adapdata(&amp;rdev-&gt;adap, rdev); strlcpy(rdev-&gt;adap.name, pdev-&gt;name, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(rdev-&gt;adap.name)); rdev-&gt;adap.owner = THIS_MODULE; rdev-&gt;adap.algo = &amp;skel_i2c_algo; rdev-&gt;adap.dev.parent = &amp;pdev-&gt;dev; rdev-&gt;adap.dev.of_node = pdev-&gt;dev.of_node; platform_set_drvdata(pdev, rdev); ret = i2c_add_adapter(&amp;rdev-&gt;adap); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret) { clk_disable_unprepare(rdev-&gt;clk); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } dev_info(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"I2C probe complete\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skel_i2c_remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct platform_device *pdev)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_i2c</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rdev</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">platform_get_drvdata</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pdev</span></span></span><span class="hljs-class">);</span></span> clk_disable_unprepare(rdev-&gt;clk); i2c_del_adapter(&amp;rdev-&gt;adap); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  La fonction la plus simple est skel_i2c_remove, qui désactive la source d'horloge et libère la mémoire utilisée.  La fonction skel_i2c_init effectue l'initialisation du contrôleur I2C. <br><br>  Comme mentionné précédemment, skel_i2c_probe enregistre le pilote dans le système.  La séquence d'actions, conditionnellement, peut être divisée en deux étapes: <br><br><ul><li>  Obtention des ressources système et enregistrement d'un gestionnaire d'interruption skel_i2c_isr; </li><li>  Remplir les champs de structure et appeler la procédure d'ajout d'un nouvel adaptateur I2C. </li></ul><br>  Une fois le pilote enregistré dans le système, vous pouvez implémenter la logique de transfert des messages sur l'interface: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i2c_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *base, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr)</span></span></span><span class="hljs-function"> </span></span>{ writel(value, base addr); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined DEBUG dev_dbg(rdev-&gt;dev, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"iowrite32(0x%x, base 0x%x);\n"</span></span></span><span class="hljs-meta">, value, addr); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } static inline uint32_t i2c_read(void *base, uint32_t addr) { uint32_t reg = readl(base addr); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined DEBUG dev_dbg(rdev-&gt;dev, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/* ioread32(base 0x%x) == 0x%x */\n"</span></span></span><span class="hljs-meta">, addr, reg); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> return reg; } static irqreturn_t skel_i2c_isr(int irq, void *dev) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (unlikely(int_stat &amp; skel_I2C_ISR_ARB)) { } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (unlikely(int_stat &amp; skel_I2C_ISR_NACK)) { } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (read) fill_rx_fifo(rdev); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> fill_tx_fifo(rdev); complete(&amp;rdev-&gt;msg_complete); return IRQ_HANDLED; } static int skel_i2c_xfer_msg(struct skel_i2c *rdev, struct i2c_msg *msg) { unsigned long time; rdev-&gt;msg = msg; rdev-&gt;mlen = msg-&gt;len; rdev-&gt;addr = msg-&gt;addr; rdev-&gt;buf = msg-&gt;buf; rdev-&gt;err = 0; reinit_completion(&amp;rdev-&gt;msg_complete); skel_i2c_start_trans(rdev, msg); time = wait_for_completion_timeout(&amp;rdev-&gt;msg_complete, skel_I2C_XFER_TIMEOUT); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (time == 0) rdev-&gt;err = -ETIMEDOUT; rdev-&gt;curr; return rdev-&gt;err; } static int skel_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num) { struct skel_i2c *rdev = i2c_get_adapdata(adap); int i, ret = 0; for (i = 0; (ret == 0) &amp;&amp; (i &lt; num); i) ret = skel_i2c_xfer_msg(rdev, msgs); skel_i2c_snd_stop(rdev); return ret ? : num; }</span></span></code> </pre><br>  La première étape a décrit l'interaction de l'application de l'espace utilisateur avec le module du noyau système.  Après avoir implémenté les internes du pilote, il est facile de voir l'interface à travers laquelle l'échange a lieu.  En général, la transmission des messages est la suivante: <br><br><ul><li>  skel_i2c_xfer - la fonction reçoit directement les messages pour la transmission et transfère séquentiellement chaque message à skel_i2c_xfer_msg.  Si une erreur s'est produite pendant le transfert de données, le transfert de données s'arrête; </li><li>  skel_i2c_xfer_msg - la fonction définit tous les champs de pilote nécessaires et initie le début de la transmission du message </li><li>  skel_i2c_isr - interrompre la routine de traitement.  C'est là que la gestion des erreurs et la communication par bus ont lieu.  Si toutes les données sont envoyées / reçues, l'indicateur done est défini en appelant la fonction complete, qui signale la fin de la transmission du message. </li></ul><br>  L'article ne décrit pas certaines des subtilités de l'œuvre.  Par exemple, la séquence d'actions pour l'envoi de messages, car la mise en œuvre de cet algorithme dépend du matériel.  Nous nous sommes concentrés sur la mise en œuvre de la partie générale du pilote, quelles que soient les caractéristiques matérielles du contrôleur. <br><br>  Le squelette complet du pilote est joint ci-dessous.  S'il vous plaît, si vous trouvez des erreurs / inexactitudes, ou si vous avez quelque chose à ajouter, écrivez dans le MP ou dans les commentaires. <br><br><div class="spoiler">  <b class="spoiler_title">Squelette conducteur</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* i2c-skel.c: I2C bus driver. * * Name Surname &lt;name@surname.ru&gt; * * This file is licensed under the terms of the GNU General Public License * version 2. This program is licensed "as is" without any warranty of any * kind, whether express or implied. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/platform_device.h&gt; #include &lt;linux/i2c.h&gt; #include &lt;linux/io.h&gt; #include &lt;linux/clk.h&gt; #include &lt;linux/interrupt.h&gt; #include &lt;linux/time.h&gt; #include &lt;linux/delay.h&gt; #include &lt;linux/device.h&gt; /* * Registers description. */ #define SKEL_I2C_ID 0x00 /* Core Identifier register */ #define SKEL_I2C_ISR 0x14 /* Interrupt Status Register */ #define SKEL_I2C_ISR_DNE BIT(0) /* One byte transaction done */ #define SKEL_I2C_ISR_ARB BIT(1) /* Arbitration lost */ #define SKEL_I2C_ISR_TXE BIT(2) /* RX FIFO nearly full */ #define SKEL_I2C_ISR_NACK BIT(3) /* No ACK */ #define SKEL_I2C_IER 0x18 /* Interrupt Enable Register */ #define SKEL_I2C_IER_DNE BIT(0) /* Enable DNE IRQ */ #define SKEL_I2C_IER_ARB BIT(1) /* Enable ARB LOSR IRQ */ #define SKEL_I2C_IER_TXE BIT(2) /* Enable TX FIFO EPMTY IRQ */ #define SKEL_I2C_IER_NACK BIT(3) /* Enable NACK IRQ */ #define SKEL_I2C_CTRL 0x1C /* Control Register */ #define SKEL_I2C_CTRL_EN BIT(0) /* Enable I2C controller */ #define SKEL_I2C_CTRL_START BIT(1) /* Send START condition */ #define SKEL_I2C_CTRL_R BIT(2) /* Read command */ #define SKEL_I2C_CTRL_W BIT(3) /* Write command */ #define SKEL_I2C_CTRL_STOP BIT(4) /* Send STOP cindition */ #define SKEL_I2C_TX 0x20 /* TX FIFO */ #define SKEL_I2C_RX 0x24 /* RX FIFO */ #define SKEL_I2C_CLK 0x28 /* Clock Prescale Register*/ #define SKEL_I2C_TIMEOUT 100000 #define SKEL_I2C_XFER_TIMEOUT (msecs_to_jiffies(500)) #define FIFO_SIZE_TX 1024 #define FIFO_SIZE_RX 1024 int presc = -1; module_param(presc, int, S_IRUGO | S_IWUSR); /* * skel_i2c - I2C device context * @base: pointer to register struct * @msg: pointer to current message * @mlen: number of bytes transferred in msg * @dev: device reference * @adap: i2c core abstraction * @msg_complete: xfer completion object * @clk: reference for i2c input clock * @err: error occured * @buf: ptr to msg buffer * @bus_clock: current i2c bus clock rate * @lock: spinlock for IRQ synchronization */ struct skel_i2c { void __iomem *base; struct i2c_msg *msg; size_t mlen; struct device *dev; struct i2c_adapter adap; struct completion msg_complete; struct clk *clk; u32 bus_clock; int err;; u32 addr; u8 *buf; spinlock_t lock; }; static const struct of_device_id skel_i2c_match[] = { { .compatible = "skel,skel-i2c", }, { .compatible = "at,24c64", }, {}, }; static inline void i2c_write(uint32_t value, void *base, uint32_t addr) { writel(value, base + addr); #if defined DEBUG dev_dbg(rdev-&gt;dev, "iowrite32(0x%x, base 0x%x);\n", value, addr); #endif } static inline uint32_t i2c_read(void *base, uint32_t addr) { uint32_t reg = readl(base + addr); #if defined DEBUG dev_dbg(rdev-&gt;dev, "/* ioread32(base 0x%x) == 0x%x */\n", addr, reg); #endif return reg; } static void skel_i2c_transfer(struct skel_i2c *rdev, u32 data) { i2c_write(data, rdev-&gt;base, SKEL_I2C_TX); } static void fill_tx_fifo(struct skel_i2c *rdev) { size_t tx_fifo_avail = FIFO_SIZE_TX; int bytes_to_transfer = min(tx_fifo_avail, rdev-&gt;mlen); while (bytes_to_transfer-- &gt; 0) { skel_i2c_transfer(rdev, *rdev-&gt;buf); rdev-&gt;mlen--; } } static void fill_rx_fifo(struct skel_i2c *rdev) { size_t rx_fifo_avail = FIFO_SIZE_RX; int receive = min(rx_fifo_avail, rdev-&gt;mlen); while (receive-- &gt; 0) { *rdev-&gt;buf = i2c_read(rdev-&gt;base, SKEL_I2C_RX); rdev-&gt;mlen--; } } void skel_i2c_snd_stop(struct skel_i2c *rdev) { u32 control = i2c_read(rdev-&gt;base, SKEL_I2C_CTRL); i2c_write(control | SKEL_I2C_CTRL_STOP, rdev-&gt;base, SKEL_I2C_CTRL); } static irqreturn_t skel_i2c_isr(int irq, void *dev) { struct skel_i2c *rdev = dev; u32 int_stat, read; int_stat = i2c_read(rdev-&gt;base, SKEL_I2C_ISR); read = rdev-&gt;msg-&gt;flags &amp; I2C_M_RD; if (unlikely(int_stat &amp; SKEL_I2C_ISR_ARB)) { } else if (unlikely(int_stat &amp; SKEL_I2C_ISR_NACK)) { } if (read) fill_rx_fifo(rdev); else fill_tx_fifo(rdev); complete(&amp;rdev-&gt;msg_complete); return IRQ_HANDLED; } static void skel_i2c_start_trans(struct skel_i2c *rdev, struct i2c_msg *msg) { } static int skel_i2c_xfer_msg(struct skel_i2c *rdev, struct i2c_msg *msg) { unsigned long time; rdev-&gt;msg = msg; rdev-&gt;mlen = msg-&gt;len; rdev-&gt;addr = msg-&gt;addr; rdev-&gt;buf = msg-&gt;buf; rdev-&gt;err = 0; reinit_completion(&amp;rdev-&gt;msg_complete); skel_i2c_start_trans(rdev, msg); time = wait_for_completion_timeout(&amp;rdev-&gt;msg_complete, SKEL_I2C_XFER_TIMEOUT); if (time == 0) rdev-&gt;err = -ETIMEDOUT; return rdev-&gt;err; } static int skel_i2c_init(struct skel_i2c *rdev) { u32 bus_clk_khz = rdev-&gt;bus_clock / 1000; u32 clk_khz = clk_get_rate(rdev-&gt;clk) / 1000; int prescale; int diff; prescale = clk_khz / (5 * bus_clk_khz) - 1; prescale = clamp(prescale, 0, 0xFFFF); diff = clk_khz / (5 * (prescale - 1)) - bus_clk_khz; if (abs(diff) &gt; bus_clk_khz / 10) { dev_err(rdev-&gt;dev, "Unsupported clock settings: clk: %d KHz, bus: %d KHz\n", clk_khz, bus_clk_khz); return -EINVAL; } if (presc != -1) i2c_write(presc, rdev-&gt;base, SKEL_I2C_CLK); else i2c_write(prescale, rdev-&gt;base, SKEL_I2C_CLK); return 0; } static int skel_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num) { struct skel_i2c *rdev = i2c_get_adapdata(adap); int i, ret = 0; for (i = 0; (ret == 0) &amp;&amp; (i &lt; num); i++) ret = skel_i2c_xfer_msg(rdev, msgs); skel_i2c_snd_stop(rdev); return ret ? : num; } static u32 skel_i2c_func(struct i2c_adapter *adap) { return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL; } static const struct i2c_algorithm skel_i2c_algo = { .master_xfer = skel_i2c_xfer, .functionality = skel_i2c_func, }; static int skel_i2c_probe(struct platform_device *pdev) { struct skel_i2c *rdev = NULL; struct resource *res; int irq, ret; u32 val; rdev = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*rdev), GFP_KERNEL); if (!rdev) return -ENOMEM; res = platform_get_resource(pdev, IORESOURCE_MEM, 0); rdev-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res); if (IS_ERR(rdev-&gt;base)) return PTR_ERR(rdev-&gt;base); irq = platform_get_irq(pdev, 0); if (irq &lt; 0) { dev_err(&amp;pdev-&gt;dev, "Missing interrupt resource\n"); return irq; } rdev-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, NULL); if (IS_ERR(rdev-&gt;clk)) { dev_err(&amp;pdev-&gt;dev, "Missing clock\n"); return PTR_ERR(rdev-&gt;clk); } rdev-&gt;dev = &amp;pdev-&gt;dev; init_completion(&amp;rdev-&gt;msg_complete); spin_lock_init(&amp;rdev-&gt;lock); val = of_property_read_u32(pdev-&gt;dev.of_node, "clock-frequency", &amp;rdev-&gt;bus_clock); if (val) { dev_err(&amp;pdev-&gt;dev, "Default to 100kHz\n"); rdev-&gt;bus_clock = 100000; /* default clock rate */ } if (rdev-&gt;bus_clock &gt; 400000) { dev_err(&amp;pdev-&gt;dev, "Invalid clock-frequency %d\n", rdev-&gt;bus_clock); return -EINVAL; } ret = devm_request_irq(&amp;pdev-&gt;dev, irq, skel_i2c_isr, 0, pdev-&gt;name, rdev); if (ret) { dev_err(&amp;pdev-&gt;dev, "Failed to claim IRQ %d\n", irq); return ret; } ret = clk_prepare_enable(rdev-&gt;clk); if (ret) { dev_err(&amp;pdev-&gt;dev, "Failed to enable clock\n"); return ret; } skel_i2c_init(rdev); i2c_set_adapdata(&amp;rdev-&gt;adap, rdev); strlcpy(rdev-&gt;adap.name, pdev-&gt;name, sizeof(rdev-&gt;adap.name)); rdev-&gt;adap.owner = THIS_MODULE; rdev-&gt;adap.algo = &amp;skel_i2c_algo; rdev-&gt;adap.dev.parent = &amp;pdev-&gt;dev; rdev-&gt;adap.dev.of_node = pdev-&gt;dev.of_node; platform_set_drvdata(pdev, rdev); ret = i2c_add_adapter(&amp;rdev-&gt;adap); if (ret) { clk_disable_unprepare(rdev-&gt;clk); return ret; } dev_info(&amp;pdev-&gt;dev, "I2C probe complete\n"); return 0; } static int skel_i2c_remove(struct platform_device *pdev) { struct skel_i2c *rdev = platform_get_drvdata(pdev); clk_disable_unprepare(rdev-&gt;clk); i2c_del_adapter(&amp;rdev-&gt;adap); return 0; } static struct platform_driver skel_i2c_driver = { .probe = skel_i2c_probe, .remove = skel_i2c_remove, .driver = { .name = "skel-i2c", .of_match_table = skel_i2c_match, }, }; module_platform_driver(skel_i2c_driver); MODULE_AUTHOR("Name Surname"); MODULE_DESCRIPTION("I2C bus driver"); MODULE_LICENSE("GPL"); MODULE_ALIAS("platform:skel-i2c");</span></span></span></span></code> </pre><br></div></div><br>  Merci de votre attention! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413249/">https://habr.com/ru/post/fr413249/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413239/index.html">Comment rendre un smartphone un peu idiot</a></li>
<li><a href="../fr413241/index.html">Interception de fonctions dans le noyau Linux à l'aide de ftrace</a></li>
<li><a href="../fr413243/index.html">School of Data: comment combiner mathématiques et affaires</a></li>
<li><a href="../fr413245/index.html">Sur les équipements Dolby Atmos - uniquement le son "natif". Dolby interdit le upmix non natif</a></li>
<li><a href="../fr413247/index.html">Pourquoi surveiller les systèmes de stockage?</a></li>
<li><a href="../fr413251/index.html">Réaction en chaîne par polymérase et Vladivostok</a></li>
<li><a href="../fr413253/index.html">Richard Hamming: Chapitre 21. Fibre optique</a></li>
<li><a href="../fr413255/index.html">Richard Hamming: Chapitre 27. Données invalides</a></li>
<li><a href="../fr413261/index.html">Comment fonctionne la recherche</a></li>
<li><a href="../fr413265/index.html">Vers les bains avec IT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>