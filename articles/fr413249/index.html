<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêµ üÜé üëáüèº √âcriture d'un module du noyau Linux: I2C üöò üìà üêº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Habr, bonjour! 

 Cet article se concentre sur le d√©veloppement du module du noyau Linux I2C (Inter-Integrated Circuit). Ce qui suit d√©crit le process...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√âcriture d'un module du noyau Linux: I2C</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413249/">  Habr, bonjour! <br><br>  Cet article se concentre sur le d√©veloppement du module du noyau Linux I2C (Inter-Integrated Circuit).  Ce qui suit d√©crit le processus d'impl√©mentation de la structure de base du pilote I2C, dans lequel vous pouvez facilement ajouter l'impl√©mentation des fonctionnalit√©s n√©cessaires. <br><br>  Nous d√©crivons les donn√©es d'entr√©e: bloc I2C pour le nouveau processeur ¬´c√¢bl√©¬ª au FPGA, ex√©cutant la version 3.18.19 de Linux et les p√©riph√©riques (EEPROM AT24C64 et BME280). <br><br>  Le principe de fonctionnement d'I2C est assez simple, mais si vous avez besoin de rafra√Æchir vos connaissances, vous pouvez lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><img src="https://habrastorage.org/webt/jq/rh/yg/jqrhyg8bveyubub7hysu0gxrkms.png"><br>  <i>Figure 1. Diagramme temporel des signaux du bus I2C</i> <br><a name="habracut"></a><br>  Avant de commencer √† d√©velopper un pilote, voyons comment les applications de l'espace utilisateur interagissent avec le module du noyau, pour cela: <br><br><ol><li>  Nous mettons en ≈ìuvre une petite application d'espace utilisateur, dont le but est de lire l'ID de registre I2C unique de l'appareil.  Cette √©tape vous permettra de comprendre l'interface √† travers laquelle l'√©change se produit entre le module du noyau et l'application utilisateur; </li><li> Familiarisons-nous avec l'option de transmission des messages I2C par le module du noyau; </li><li>  Ajoutez le module du noyau √† l'assembly et d√©crivez le mat√©riel des p√©riph√©riques dans l'arborescence des p√©riph√©riques; </li><li>  Nous impl√©mentons la structure g√©n√©rale (squelette) du pilote I2C avec quelques explications. </li></ol><br>  Malheureusement, il n'est pas possible de joindre les vraies sources du pilote d√©velopp√©.  De plus, je tiens √† noter que tous les noms, noms et carte d'enregistrement du contr√¥leur sont modifi√©s.  M√™me la moiti√© des fonctionnalit√©s d√©velopp√©es n'√©taient pas incluses dans le squelette du pilote, cependant, la structure du pilote est un bon point de d√©part pour le d√©veloppement.  Des exemples de pilotes I2C peuvent √™tre trouv√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h3>  <b>Premi√®re √©tape</b> </h3><br>  Tout d'abord, familiarisons-nous avec l'utilitaire i2cdetect.  Le r√©sultat d'i2cdetect est le suivant: <br><pre><code class="cpp hljs">./i2cdetect -y <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> abcdef <span class="hljs-number"><span class="hljs-number">00</span></span>: ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî <span class="hljs-number"><span class="hljs-number">10</span></span>: ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî <span class="hljs-number"><span class="hljs-number">20</span></span>: ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî <span class="hljs-number"><span class="hljs-number">30</span></span>: ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî <span class="hljs-number"><span class="hljs-number">40</span></span>: ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî <span class="hljs-number"><span class="hljs-number">50</span></span>: <span class="hljs-number"><span class="hljs-number">50</span></span> ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî <span class="hljs-number"><span class="hljs-number">60</span></span>: ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî <span class="hljs-number"><span class="hljs-number">70</span></span>: ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî ‚Äî</code> </pre> <br>  L'utilitaire expose s√©quentiellement le bus d'adresse de p√©riph√©rique sur l'I2C et, √† la r√©ception d'une r√©ponse positive (dans ce cas, la r√©ponse positive est ACK), affiche le num√©ro d'adresse de p√©riph√©rique sur le bus dans la console. <br><br>  Nous allons √©crire un petit programme qui lit l'ID unique du capteur de temp√©rature et afficher le r√©sultat de son travail dans la console.  Cela semble tr√®s simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/ioctl.h&gt; #include &lt;linux/i2c.h&gt; #include &lt;linux/i2c-dev.h&gt; #define I2C_ADAPTER "/dev/i2c-0" int read_buffer(int fd) { struct i2c_rdwr_ioctl_data data; struct i2c_msg messages[2]; unsigned char write_buf[1] = {0xD0}, read_buf[1] = {0x00}; unsigned char write[200]; /* * .addr -   () * .flags -     (0 - w, 1 - r) * .len - - /  * .buf -      */ messages[0].addr = 0x50; messages[0].flags = 0; messages[0].len = 1; messages[0].buf = write_buf; messages[1].addr = 0x50; messages[1].flags = 1; messages[1].len = 1; messages[1].buf = read_buf; data.msgs = messages; data.nmsgs = 2; if (ioctl(fd, I2C_RDWR, &amp;data) &lt; 0) printf("Cant send data!\n"); else printf("ID = 0x%x\n", read_buf[0]); } int main(int argc, char **argv) { int fd; /* * Open I2C file descriptor. */ fd = open(I2C_ADAPTER, O_RDWR); if (fd &lt; 0) { printf("Unable to open i2c file\n"); return 0; } read_buffer(fd); return 0; }</span></span></span></span></code> </pre><br>  Il devient clair que le module du noyau re√ßoit des donn√©es sous la forme de champs de message i2c_rdwr_ioctl_data.  La structure contient des champs tels que i2c_msg et nmsgs, qui sont utilis√©s pour la transmission: <br><br><ul><li>  .addr - adresses des p√©riph√©riques; </li><li>  .flags - type d'op√©ration (lecture ou √©criture); </li><li>  .len - la longueur du message actuel; </li><li>  .buf- presse-papiers. </li></ul><br><h3>  <b>Deuxi√®me √©tape</b> </h3><br>  Maintenant, je ne plonge pas dans les entrailles, je me familiarise avec une version du pilote I2C. <br>  Comme d√©j√† √©tabli, le module noyau re√ßoit des messages sous forme de structure.  Par exemple, consid√©rez l'algorithme du pilote lors de l'ex√©cution d'une op√©ration d'√©criture (partie d√©pendante du mat√©riel): <br><br><ul><li>  Le premier TX FIFO est rempli: l'adresse de l'appareil vient en premier, puis les donn√©es restantes sont transmises; </li><li>  Le registre d'√©tat d'interruption ISR est effac√© et les interruptions dans le registre IER sont activ√©es (dans ce cas, une interruption se produit lorsqu'il n'y a pas de donn√©es dans TX FIFO); </li><li>  La transmission de donn√©es est autoris√©e et le bit de d√©marrage est d√©fini sur le bus. </li></ul><br>  Tous les √©changes de donn√©es ult√©rieurs auront lieu dans le gestionnaire d'interruption. <br>  Les pilotes qui fonctionnent sur cet algorithme peuvent √™tre trouv√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  De plus, le contr√¥leur peut ne pas avoir FIFO, mais seulement un seul registre de transfert, mais c'est un cas sp√©cial avec une taille FIFO de un. <br><br><h3>  <b>√âtape trois</b> </h3><br>  Ajoutez le module du noyau √† l'assembly et d√©crivez le mat√©riel des p√©riph√©riques dans l'arborescence des p√©riph√©riques: <br><br>  1. Cr√©ez un fichier source dans le r√©pertoire suivant: <br><br><pre> <code class="cpp hljs">cd drivers/i2c/busses/ vim i2c-skel.c :wq</code> </pre><br>  En cons√©quence, le fichier appara√Æt: <br><br><pre> <code class="cpp hljs">drivers/i2c/busses/i2c-skel.c</code> </pre><br><br>  2. Ajoutez la configuration du pilote √† <i>drivers / i2c / busses / Kconfig</i> : <br><br><pre> <code class="cpp hljs">config I2C_SKEL tristate <span class="hljs-string"><span class="hljs-string">"I2C adapter"</span></span> help If you say yes to <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> option, support will be included <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the I2C interface.</code> </pre><br>  3. Ajoutez le <i>pilote drivers / i2c / busses / Makefile</i> √† l'assembly: <br><br><pre> <code class="cpp hljs">obj-$(CONFIG_I2C_SKEL) += i2c-skel.o</code> </pre><br>  4. Ajoutez une description du bloc I2C √† devicetree (* .dts) et prenez √©galement imm√©diatement en charge le p√©riph√©rique eeprom: <br><br><pre> <code class="cpp hljs"> i2c: i2c@f8f01d00 { compatible = <span class="hljs-string"><span class="hljs-string">"skel,skel-i2c"</span></span>; <span class="hljs-meta"><span class="hljs-meta">#address-cells = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;1&gt;; #size-cells = &lt;0&gt;; reg = &lt;0x43c00000 0x100&gt;; interrupt-parent = &lt;&amp;ps7_scugic_0&gt;; interrupts = &lt;0 29 4&gt;; clock-names = "skel-i2c"; clocks = &lt;&amp;clkc 38&gt;; clock-frequency = &lt;100000&gt;; 24c64@50 { compatible = "at,24c64"; pagesize = &lt;32&gt;; reg = &lt;0x50&gt;; }; } ;</span></span></span></span></code> </pre><br>  Les √©tapes ci-dessus ne seront pas examin√©es en d√©tail, mais les lecteurs curieux peuvent jeter un ≈ìil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h3>  <b>Quatri√®me √©tape</b> </h3><br>  Apr√®s vous √™tre familiaris√© avec le principe du pilote, proc√©dons √† l'impl√©mentation. <br>  Tout d'abord, connectez les fichiers d'en-t√™te, d√©crivez la carte de registre ¬´virtuelle¬ª, ainsi que la pr√©sentation du pilote I2C. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* i2c-skel.c: I2C bus driver. * * Name Surname &lt;name@surname.ru&gt; * * This file is licensed under the terms of the GNU General Public License * version 2. This program is licensed "as is" without any warranty of any * kind, whether express or implied. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/platform_device.h&gt; #include &lt;linux/i2c.h&gt; #include &lt;linux/io.h&gt; #include &lt;linux/clk.h&gt; #include &lt;linux/interrupt.h&gt; #include &lt;linux/time.h&gt; #include &lt;linux/delay.h&gt; #include &lt;linux/device.h&gt; /* * Registers description. */ #define SKEL_I2C_ID 0x00 /* Core Identifier register */ #define SKEL_I2C_ISR 0x14 /* Interrupt Status Register */ #define SKEL_I2C_ISR_DNE BIT(0) /* One byte transaction done */ #define SKEL_I2C_ISR_ARB BIT(1) /* Arbitration lost */ #define SKEL_I2C_ISR_TXE BIT(2) /* RX FIFO nearly full */ #define SKEL_I2C_ISR_NACK BIT(3) /* No ACK */ #define SKEL_I2C_IER 0x18 /* Interrupt Enable Register */ #define SKEL_I2C_IER_DNE BIT(0) /* Enable DNE IRQ */ #define SKEL_I2C_IER_ARB BIT(1) /* Enable ARB LOSR IRQ */ #define SKEL_I2C_IER_TXE BIT(2) /* Enable TX FIFO EPMTY IRQ */ #define SKEL_I2C_IER_NACK BIT(3) /* Enable NACK IRQ */ #define SKEL_I2C_CTRL 0x1C /* Control Register */ #define SKEL_I2C_CTRL_EN BIT(0) /* Enable I2C controller */ #define SKEL_I2C_CTRL_START BIT(1) /* Send START condition */ #define SKEL_I2C_CTRL_R BIT(2) /* Read command */ #define SKEL_I2C_CTRL_W BIT(3) /* Write command */ #define SKEL_I2C_CTRL_STOP BIT(4) /* Send STOP cindition */ #define SKEL_I2C_TX 0x20 /* TX FIFO */ #define SKEL_I2C_RX 0x24 /* RX FIFO */ #define SKEL_I2C_CLK 0x28 /* Clock Prescale Register*/ #define SKEL_I2C_TIMEOUT 100000 #define SKEL_I2C_XFER_TIMEOUT (msecs_to_jiffies(500)) #define FIFO_SIZE_TX 1024 #define FIFO_SIZE_RX 1024 int presc = -1; module_param(presc, int, S_IRUGO | S_IWUSR); /* * skel_i2c - I2C device context * @base: pointer to register struct * @msg: pointer to current message * @mlen: number of bytes transferred in msg * @dev: device reference * @adap: i2c core abstraction * @msg_complete: xfer completion object * @clk: reference for i2c input clock * @err: error occured * @buf: ptr to msg buffer * @bus_clock: current i2c bus clock rate * @lock: spinlock for IRQ synchronization */ struct skel_i2c { void __iomem *base; struct i2c_msg *msg; size_t mlen; struct device *dev; struct i2c_adapter adap; struct completion msg_complete; struct clk *clk; u32 bus_clock; int err; u32 addr; u8 *buf; spinlock_t lock; };</span></span></span></span></code> </pre><br>  Les principaux registres de contr√¥le du contr√¥leur sont: <br><br><ul><li>  Registre de contr√¥le (CTRL) - registre de contr√¥le; </li><li>  Registre d'√©tat d'interruption (ISR) - registre d'√©tat d'interruption; </li><li>  Registre d'activation d'interruption (IER) - Registre de masque d'interruption. </li></ul><br>  Le c≈ìur du pilote est la structure skel_i2c, qui contient des champs tels que: <br><br><ul><li>  .base - pointeur vers le d√©but de la carte d'enregistrement; </li><li>  .msg - pointeur vers le message actuel; </li><li>  .adap - abstraction I2C <a href="">(cliquez sur)</a> . </li></ul><br>  Passons √† la partie la plus pratique, d√©crivons les types de p√©riph√©riques pris en charge par le pilote, <br>  Fonctionnalit√© de l'adaptateur I2C et interface de messagerie I2C: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of_device_id</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_i2c_match</span></span></span><span class="hljs-class">[] = {</span></span> { .compatible = <span class="hljs-string"><span class="hljs-string">"skel,skel-i2c"</span></span>, }, { .compatible = <span class="hljs-string"><span class="hljs-string">"at,24c64"</span></span>, }, {}, }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> u32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skel_i2c_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct i2c_adapter *adap)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i2c_algorithm</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_i2c_algo</span></span></span><span class="hljs-class"> = {</span></span> .master_xfer = skel_i2c_xfer, .functionality = skel_i2c_func, }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">platform_driver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_i2c_driver</span></span></span><span class="hljs-class"> = {</span></span> .probe = skel_i2c_probe, .remove = skel_i2c_remove, .driver = { .name = <span class="hljs-string"><span class="hljs-string">"skel-i2c"</span></span>, .of_match_table = skel_i2c_match, }, }; module_platform_driver(skel_i2c_driver); MODULE_AUTHOR(<span class="hljs-string"><span class="hljs-string">"Name Surname"</span></span>); MODULE_DESCRIPTION(<span class="hljs-string"><span class="hljs-string">"I2C bus driver"</span></span>); MODULE_LICENSE(<span class="hljs-string"><span class="hljs-string">"GPL"</span></span>); MODULE_ALIAS(<span class="hljs-string"><span class="hljs-string">"platform:skel-i2c"</span></span>);</code> </pre><br>  √Ä partir des noms des structures et des fonctions, leur objectif est √©vident, nous d√©crivons uniquement la structure principale √† partir de ce qui pr√©c√®de: <br><br><ul><li>  skel_i2c_driver - d√©crit le nom du pilote, un tableau des p√©riph√©riques et fonctions pris en charge qui sont appel√©s lorsque le module du noyau est charg√© ou supprim√© du syst√®me. </li></ul><br>  Il est temps d'enregistrer le pilote dans le syst√®me, ce qui signifie impl√©menter la fonction d'initialisation du contr√¥leur, et √©galement d√©crire skel_i2c_probe (appel√© lorsque le pilote est charg√© dans le syst√®me) et skel_i2c_remove (appel√© lorsque le pilote est supprim√© du syst√®me). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skel_i2c_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct skel_i2c *rdev)</span></span></span><span class="hljs-function"> </span></span>{ u32 bus_clk_khz = rdev-&gt;bus_clock / <span class="hljs-number"><span class="hljs-number">1000</span></span>; u32 clk_khz = clk_get_rate(rdev-&gt;clk) / <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> prescale; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diff; prescale = clk_khz / (<span class="hljs-number"><span class="hljs-number">5</span></span> * bus_clk_khz) - <span class="hljs-number"><span class="hljs-number">1</span></span>; prescale = clamp(prescale, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>); diff = clk_khz / (<span class="hljs-number"><span class="hljs-number">5</span></span> * (prescale <span class="hljs-number"><span class="hljs-number">1</span></span>)) - bus_clk_khz; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(diff) &gt; bus_clk_khz / <span class="hljs-number"><span class="hljs-number">10</span></span>) { dev_err(rdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Unsupported clock settings: clk: %d KHz, bus: %d KHz\n"</span></span>, clk_khz, bus_clk_khz); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EINVAL; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (presc != <span class="hljs-number"><span class="hljs-number">-1</span></span>) i2c_write(presc, rdev-&gt;base, SKEL_I2C_CLK); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> i2c_write(prescale, rdev-&gt;base, SKEL_I2C_CLK); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skel_i2c_probe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct platform_device *pdev)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_i2c</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rdev</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resource</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">res</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> irq, ret; u32 val; rdev = devm_kzalloc(&amp;pdev-&gt;dev, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*rdev), GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rdev) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOMEM; res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="hljs-number"><span class="hljs-number">0</span></span>); rdev-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(rdev-&gt;base)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PTR_ERR(rdev-&gt;base); irq = platform_get_irq(pdev, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (irq &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Missing interrupt resource\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> irq; } rdev-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(rdev-&gt;clk)) { dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Missing clock\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PTR_ERR(rdev-&gt;clk); } rdev-&gt;dev = &amp;pdev-&gt;dev; init_completion(&amp;rdev-&gt;msg_complete); spin_lock_init(&amp;rdev-&gt;lock); val = of_property_read_u32(pdev-&gt;dev.of_node, <span class="hljs-string"><span class="hljs-string">"clock-frequency"</span></span>, &amp;rdev-&gt;bus_clock); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val) { dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Default to 100kHz\n"</span></span>); rdev-&gt;bus_clock = <span class="hljs-number"><span class="hljs-number">100000</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* default clock rate */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rdev-&gt;bus_clock &gt; <span class="hljs-number"><span class="hljs-number">400000</span></span>) { dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Invalid clock-frequency %d\n"</span></span>, rdev-&gt;bus_clock); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EINVAL; } ret = devm_request_irq(&amp;pdev-&gt;dev, irq, skel_i2c_isr, <span class="hljs-number"><span class="hljs-number">0</span></span>, pdev-&gt;name, rdev); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret) { dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Failed to claim IRQ %d\n"</span></span>, irq); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } ret = clk_prepare_enable(rdev-&gt;clk); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret) { dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Failed to enable clock\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } skel_i2c_init(rdev); i2c_set_adapdata(&amp;rdev-&gt;adap, rdev); strlcpy(rdev-&gt;adap.name, pdev-&gt;name, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(rdev-&gt;adap.name)); rdev-&gt;adap.owner = THIS_MODULE; rdev-&gt;adap.algo = &amp;skel_i2c_algo; rdev-&gt;adap.dev.parent = &amp;pdev-&gt;dev; rdev-&gt;adap.dev.of_node = pdev-&gt;dev.of_node; platform_set_drvdata(pdev, rdev); ret = i2c_add_adapter(&amp;rdev-&gt;adap); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret) { clk_disable_unprepare(rdev-&gt;clk); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } dev_info(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"I2C probe complete\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skel_i2c_remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct platform_device *pdev)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_i2c</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rdev</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">platform_get_drvdata</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pdev</span></span></span><span class="hljs-class">);</span></span> clk_disable_unprepare(rdev-&gt;clk); i2c_del_adapter(&amp;rdev-&gt;adap); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  La fonction la plus simple est skel_i2c_remove, qui d√©sactive la source d'horloge et lib√®re la m√©moire utilis√©e.  La fonction skel_i2c_init effectue l'initialisation du contr√¥leur I2C. <br><br>  Comme mentionn√© pr√©c√©demment, skel_i2c_probe enregistre le pilote dans le syst√®me.  La s√©quence d'actions, conditionnellement, peut √™tre divis√©e en deux √©tapes: <br><br><ul><li>  Obtention des ressources syst√®me et enregistrement d'un gestionnaire d'interruption skel_i2c_isr; </li><li>  Remplir les champs de structure et appeler la proc√©dure d'ajout d'un nouvel adaptateur I2C. </li></ul><br>  Une fois le pilote enregistr√© dans le syst√®me, vous pouvez impl√©menter la logique de transfert des messages sur l'interface: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i2c_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *base, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr)</span></span></span><span class="hljs-function"> </span></span>{ writel(value, base addr); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined DEBUG dev_dbg(rdev-&gt;dev, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"iowrite32(0x%x, base 0x%x);\n"</span></span></span><span class="hljs-meta">, value, addr); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } static inline uint32_t i2c_read(void *base, uint32_t addr) { uint32_t reg = readl(base addr); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined DEBUG dev_dbg(rdev-&gt;dev, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/* ioread32(base 0x%x) == 0x%x */\n"</span></span></span><span class="hljs-meta">, addr, reg); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> return reg; } static irqreturn_t skel_i2c_isr(int irq, void *dev) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (unlikely(int_stat &amp; skel_I2C_ISR_ARB)) { } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (unlikely(int_stat &amp; skel_I2C_ISR_NACK)) { } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (read) fill_rx_fifo(rdev); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> fill_tx_fifo(rdev); complete(&amp;rdev-&gt;msg_complete); return IRQ_HANDLED; } static int skel_i2c_xfer_msg(struct skel_i2c *rdev, struct i2c_msg *msg) { unsigned long time; rdev-&gt;msg = msg; rdev-&gt;mlen = msg-&gt;len; rdev-&gt;addr = msg-&gt;addr; rdev-&gt;buf = msg-&gt;buf; rdev-&gt;err = 0; reinit_completion(&amp;rdev-&gt;msg_complete); skel_i2c_start_trans(rdev, msg); time = wait_for_completion_timeout(&amp;rdev-&gt;msg_complete, skel_I2C_XFER_TIMEOUT); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (time == 0) rdev-&gt;err = -ETIMEDOUT; rdev-&gt;curr; return rdev-&gt;err; } static int skel_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num) { struct skel_i2c *rdev = i2c_get_adapdata(adap); int i, ret = 0; for (i = 0; (ret == 0) &amp;&amp; (i &lt; num); i) ret = skel_i2c_xfer_msg(rdev, msgs); skel_i2c_snd_stop(rdev); return ret ? : num; }</span></span></code> </pre><br>  La premi√®re √©tape a d√©crit l'interaction de l'application de l'espace utilisateur avec le module du noyau syst√®me.  Apr√®s avoir impl√©ment√© les internes du pilote, il est facile de voir l'interface √† travers laquelle l'√©change a lieu.  En g√©n√©ral, la transmission des messages est la suivante: <br><br><ul><li>  skel_i2c_xfer - la fonction re√ßoit directement les messages pour la transmission et transf√®re s√©quentiellement chaque message √† skel_i2c_xfer_msg.  Si une erreur s'est produite pendant le transfert de donn√©es, le transfert de donn√©es s'arr√™te; </li><li>  skel_i2c_xfer_msg - la fonction d√©finit tous les champs de pilote n√©cessaires et initie le d√©but de la transmission du message </li><li>  skel_i2c_isr - interrompre la routine de traitement.  C'est l√† que la gestion des erreurs et la communication par bus ont lieu.  Si toutes les donn√©es sont envoy√©es / re√ßues, l'indicateur done est d√©fini en appelant la fonction complete, qui signale la fin de la transmission du message. </li></ul><br>  L'article ne d√©crit pas certaines des subtilit√©s de l'≈ìuvre.  Par exemple, la s√©quence d'actions pour l'envoi de messages, car la mise en ≈ìuvre de cet algorithme d√©pend du mat√©riel.  Nous nous sommes concentr√©s sur la mise en ≈ìuvre de la partie g√©n√©rale du pilote, quelles que soient les caract√©ristiques mat√©rielles du contr√¥leur. <br><br>  Le squelette complet du pilote est joint ci-dessous.  S'il vous pla√Æt, si vous trouvez des erreurs / inexactitudes, ou si vous avez quelque chose √† ajouter, √©crivez dans le MP ou dans les commentaires. <br><br><div class="spoiler">  <b class="spoiler_title">Squelette conducteur</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* i2c-skel.c: I2C bus driver. * * Name Surname &lt;name@surname.ru&gt; * * This file is licensed under the terms of the GNU General Public License * version 2. This program is licensed "as is" without any warranty of any * kind, whether express or implied. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/platform_device.h&gt; #include &lt;linux/i2c.h&gt; #include &lt;linux/io.h&gt; #include &lt;linux/clk.h&gt; #include &lt;linux/interrupt.h&gt; #include &lt;linux/time.h&gt; #include &lt;linux/delay.h&gt; #include &lt;linux/device.h&gt; /* * Registers description. */ #define SKEL_I2C_ID 0x00 /* Core Identifier register */ #define SKEL_I2C_ISR 0x14 /* Interrupt Status Register */ #define SKEL_I2C_ISR_DNE BIT(0) /* One byte transaction done */ #define SKEL_I2C_ISR_ARB BIT(1) /* Arbitration lost */ #define SKEL_I2C_ISR_TXE BIT(2) /* RX FIFO nearly full */ #define SKEL_I2C_ISR_NACK BIT(3) /* No ACK */ #define SKEL_I2C_IER 0x18 /* Interrupt Enable Register */ #define SKEL_I2C_IER_DNE BIT(0) /* Enable DNE IRQ */ #define SKEL_I2C_IER_ARB BIT(1) /* Enable ARB LOSR IRQ */ #define SKEL_I2C_IER_TXE BIT(2) /* Enable TX FIFO EPMTY IRQ */ #define SKEL_I2C_IER_NACK BIT(3) /* Enable NACK IRQ */ #define SKEL_I2C_CTRL 0x1C /* Control Register */ #define SKEL_I2C_CTRL_EN BIT(0) /* Enable I2C controller */ #define SKEL_I2C_CTRL_START BIT(1) /* Send START condition */ #define SKEL_I2C_CTRL_R BIT(2) /* Read command */ #define SKEL_I2C_CTRL_W BIT(3) /* Write command */ #define SKEL_I2C_CTRL_STOP BIT(4) /* Send STOP cindition */ #define SKEL_I2C_TX 0x20 /* TX FIFO */ #define SKEL_I2C_RX 0x24 /* RX FIFO */ #define SKEL_I2C_CLK 0x28 /* Clock Prescale Register*/ #define SKEL_I2C_TIMEOUT 100000 #define SKEL_I2C_XFER_TIMEOUT (msecs_to_jiffies(500)) #define FIFO_SIZE_TX 1024 #define FIFO_SIZE_RX 1024 int presc = -1; module_param(presc, int, S_IRUGO | S_IWUSR); /* * skel_i2c - I2C device context * @base: pointer to register struct * @msg: pointer to current message * @mlen: number of bytes transferred in msg * @dev: device reference * @adap: i2c core abstraction * @msg_complete: xfer completion object * @clk: reference for i2c input clock * @err: error occured * @buf: ptr to msg buffer * @bus_clock: current i2c bus clock rate * @lock: spinlock for IRQ synchronization */ struct skel_i2c { void __iomem *base; struct i2c_msg *msg; size_t mlen; struct device *dev; struct i2c_adapter adap; struct completion msg_complete; struct clk *clk; u32 bus_clock; int err;; u32 addr; u8 *buf; spinlock_t lock; }; static const struct of_device_id skel_i2c_match[] = { { .compatible = "skel,skel-i2c", }, { .compatible = "at,24c64", }, {}, }; static inline void i2c_write(uint32_t value, void *base, uint32_t addr) { writel(value, base + addr); #if defined DEBUG dev_dbg(rdev-&gt;dev, "iowrite32(0x%x, base 0x%x);\n", value, addr); #endif } static inline uint32_t i2c_read(void *base, uint32_t addr) { uint32_t reg = readl(base + addr); #if defined DEBUG dev_dbg(rdev-&gt;dev, "/* ioread32(base 0x%x) == 0x%x */\n", addr, reg); #endif return reg; } static void skel_i2c_transfer(struct skel_i2c *rdev, u32 data) { i2c_write(data, rdev-&gt;base, SKEL_I2C_TX); } static void fill_tx_fifo(struct skel_i2c *rdev) { size_t tx_fifo_avail = FIFO_SIZE_TX; int bytes_to_transfer = min(tx_fifo_avail, rdev-&gt;mlen); while (bytes_to_transfer-- &gt; 0) { skel_i2c_transfer(rdev, *rdev-&gt;buf); rdev-&gt;mlen--; } } static void fill_rx_fifo(struct skel_i2c *rdev) { size_t rx_fifo_avail = FIFO_SIZE_RX; int receive = min(rx_fifo_avail, rdev-&gt;mlen); while (receive-- &gt; 0) { *rdev-&gt;buf = i2c_read(rdev-&gt;base, SKEL_I2C_RX); rdev-&gt;mlen--; } } void skel_i2c_snd_stop(struct skel_i2c *rdev) { u32 control = i2c_read(rdev-&gt;base, SKEL_I2C_CTRL); i2c_write(control | SKEL_I2C_CTRL_STOP, rdev-&gt;base, SKEL_I2C_CTRL); } static irqreturn_t skel_i2c_isr(int irq, void *dev) { struct skel_i2c *rdev = dev; u32 int_stat, read; int_stat = i2c_read(rdev-&gt;base, SKEL_I2C_ISR); read = rdev-&gt;msg-&gt;flags &amp; I2C_M_RD; if (unlikely(int_stat &amp; SKEL_I2C_ISR_ARB)) { } else if (unlikely(int_stat &amp; SKEL_I2C_ISR_NACK)) { } if (read) fill_rx_fifo(rdev); else fill_tx_fifo(rdev); complete(&amp;rdev-&gt;msg_complete); return IRQ_HANDLED; } static void skel_i2c_start_trans(struct skel_i2c *rdev, struct i2c_msg *msg) { } static int skel_i2c_xfer_msg(struct skel_i2c *rdev, struct i2c_msg *msg) { unsigned long time; rdev-&gt;msg = msg; rdev-&gt;mlen = msg-&gt;len; rdev-&gt;addr = msg-&gt;addr; rdev-&gt;buf = msg-&gt;buf; rdev-&gt;err = 0; reinit_completion(&amp;rdev-&gt;msg_complete); skel_i2c_start_trans(rdev, msg); time = wait_for_completion_timeout(&amp;rdev-&gt;msg_complete, SKEL_I2C_XFER_TIMEOUT); if (time == 0) rdev-&gt;err = -ETIMEDOUT; return rdev-&gt;err; } static int skel_i2c_init(struct skel_i2c *rdev) { u32 bus_clk_khz = rdev-&gt;bus_clock / 1000; u32 clk_khz = clk_get_rate(rdev-&gt;clk) / 1000; int prescale; int diff; prescale = clk_khz / (5 * bus_clk_khz) - 1; prescale = clamp(prescale, 0, 0xFFFF); diff = clk_khz / (5 * (prescale - 1)) - bus_clk_khz; if (abs(diff) &gt; bus_clk_khz / 10) { dev_err(rdev-&gt;dev, "Unsupported clock settings: clk: %d KHz, bus: %d KHz\n", clk_khz, bus_clk_khz); return -EINVAL; } if (presc != -1) i2c_write(presc, rdev-&gt;base, SKEL_I2C_CLK); else i2c_write(prescale, rdev-&gt;base, SKEL_I2C_CLK); return 0; } static int skel_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num) { struct skel_i2c *rdev = i2c_get_adapdata(adap); int i, ret = 0; for (i = 0; (ret == 0) &amp;&amp; (i &lt; num); i++) ret = skel_i2c_xfer_msg(rdev, msgs); skel_i2c_snd_stop(rdev); return ret ? : num; } static u32 skel_i2c_func(struct i2c_adapter *adap) { return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL; } static const struct i2c_algorithm skel_i2c_algo = { .master_xfer = skel_i2c_xfer, .functionality = skel_i2c_func, }; static int skel_i2c_probe(struct platform_device *pdev) { struct skel_i2c *rdev = NULL; struct resource *res; int irq, ret; u32 val; rdev = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*rdev), GFP_KERNEL); if (!rdev) return -ENOMEM; res = platform_get_resource(pdev, IORESOURCE_MEM, 0); rdev-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res); if (IS_ERR(rdev-&gt;base)) return PTR_ERR(rdev-&gt;base); irq = platform_get_irq(pdev, 0); if (irq &lt; 0) { dev_err(&amp;pdev-&gt;dev, "Missing interrupt resource\n"); return irq; } rdev-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, NULL); if (IS_ERR(rdev-&gt;clk)) { dev_err(&amp;pdev-&gt;dev, "Missing clock\n"); return PTR_ERR(rdev-&gt;clk); } rdev-&gt;dev = &amp;pdev-&gt;dev; init_completion(&amp;rdev-&gt;msg_complete); spin_lock_init(&amp;rdev-&gt;lock); val = of_property_read_u32(pdev-&gt;dev.of_node, "clock-frequency", &amp;rdev-&gt;bus_clock); if (val) { dev_err(&amp;pdev-&gt;dev, "Default to 100kHz\n"); rdev-&gt;bus_clock = 100000; /* default clock rate */ } if (rdev-&gt;bus_clock &gt; 400000) { dev_err(&amp;pdev-&gt;dev, "Invalid clock-frequency %d\n", rdev-&gt;bus_clock); return -EINVAL; } ret = devm_request_irq(&amp;pdev-&gt;dev, irq, skel_i2c_isr, 0, pdev-&gt;name, rdev); if (ret) { dev_err(&amp;pdev-&gt;dev, "Failed to claim IRQ %d\n", irq); return ret; } ret = clk_prepare_enable(rdev-&gt;clk); if (ret) { dev_err(&amp;pdev-&gt;dev, "Failed to enable clock\n"); return ret; } skel_i2c_init(rdev); i2c_set_adapdata(&amp;rdev-&gt;adap, rdev); strlcpy(rdev-&gt;adap.name, pdev-&gt;name, sizeof(rdev-&gt;adap.name)); rdev-&gt;adap.owner = THIS_MODULE; rdev-&gt;adap.algo = &amp;skel_i2c_algo; rdev-&gt;adap.dev.parent = &amp;pdev-&gt;dev; rdev-&gt;adap.dev.of_node = pdev-&gt;dev.of_node; platform_set_drvdata(pdev, rdev); ret = i2c_add_adapter(&amp;rdev-&gt;adap); if (ret) { clk_disable_unprepare(rdev-&gt;clk); return ret; } dev_info(&amp;pdev-&gt;dev, "I2C probe complete\n"); return 0; } static int skel_i2c_remove(struct platform_device *pdev) { struct skel_i2c *rdev = platform_get_drvdata(pdev); clk_disable_unprepare(rdev-&gt;clk); i2c_del_adapter(&amp;rdev-&gt;adap); return 0; } static struct platform_driver skel_i2c_driver = { .probe = skel_i2c_probe, .remove = skel_i2c_remove, .driver = { .name = "skel-i2c", .of_match_table = skel_i2c_match, }, }; module_platform_driver(skel_i2c_driver); MODULE_AUTHOR("Name Surname"); MODULE_DESCRIPTION("I2C bus driver"); MODULE_LICENSE("GPL"); MODULE_ALIAS("platform:skel-i2c");</span></span></span></span></code> </pre><br></div></div><br>  Merci de votre attention! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413249/">https://habr.com/ru/post/fr413249/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413239/index.html">Comment rendre un smartphone un peu idiot</a></li>
<li><a href="../fr413241/index.html">Interception de fonctions dans le noyau Linux √† l'aide de ftrace</a></li>
<li><a href="../fr413243/index.html">School of Data: comment combiner math√©matiques et affaires</a></li>
<li><a href="../fr413245/index.html">Sur les √©quipements Dolby Atmos - uniquement le son "natif". Dolby interdit le upmix non natif</a></li>
<li><a href="../fr413247/index.html">Pourquoi surveiller les syst√®mes de stockage?</a></li>
<li><a href="../fr413251/index.html">R√©action en cha√Æne par polym√©rase et Vladivostok</a></li>
<li><a href="../fr413253/index.html">Richard Hamming: Chapitre 21. Fibre optique</a></li>
<li><a href="../fr413255/index.html">Richard Hamming: Chapitre 27. Donn√©es invalides</a></li>
<li><a href="../fr413261/index.html">Comment fonctionne la recherche</a></li>
<li><a href="../fr413265/index.html">Vers les bains avec IT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>