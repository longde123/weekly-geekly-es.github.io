<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥧 🎟️ 🚌 Caching von Ereignishandlern und Verbesserung der Anwendungsleistung 📩 ✊🏿 👼🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute veröffentlichen wir eine Übersetzung des Materials, dessen Autor, nachdem er die Funktionen der Arbeit mit Objekten in JavaScript analysiert hat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Caching von Ereignishandlern und Verbesserung der Anwendungsleistung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/426053/">  Heute veröffentlichen wir eine Übersetzung des Materials, dessen Autor, nachdem er die Funktionen der Arbeit mit Objekten in JavaScript analysiert hat, React-Entwicklern eine Methode zur Beschleunigung von Anwendungen bietet.  Insbesondere sprechen wir über die Tatsache, dass eine Variable, die, wie sie sagen, "einem Objekt zugewiesen" ist und oft einfach "Objekt" genannt wird, tatsächlich nicht das Objekt selbst speichert, sondern eine Verknüpfung dazu.  Funktionen in JavaScript sind ebenfalls Objekte, daher gilt das oben Gesagte für sie.  Wenn Sie dies berücksichtigen, können Sie durch das Entwerfen von React-Komponenten und die kritische Analyse ihres Codes ihre internen Mechanismen verbessern und die Anwendungsleistung verbessern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54f/6b5/80a/54f6b580affe2d9741da8207f93b4746.png"></div><br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Funktionen zum Arbeiten mit Objekten in JavaScript</font> </h2><br>  Wenn Sie einige Funktionen erstellen, die genau gleich aussehen, und versuchen, sie zu vergleichen, stellt sich heraus, dass sie aus Sicht des Systems unterschiedlich sind.  Um dies zu überprüfen, können Sie den folgenden Code ausführen: <br><br><pre><code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionOne = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionTwo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); }; functionOne === functionTwo; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Versuchen wir nun, einer vorhandenen Funktion, die bereits einer anderen Variablen zugewiesen ist, eine Variable zuzuweisen, und vergleichen Sie diese beiden Variablen: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionThree = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionFour = functionThree; functionThree === functionFour; <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  Wie Sie sehen können, gibt der strikte Gleichheitsoperator bei diesem Ansatz <code>true</code> . <br>  Objekte verhalten sich natürlich genauso: <br><br><pre> <code class="hljs julia"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object3 = object1; object1 === object2; // <span class="hljs-literal"><span class="hljs-literal">false</span></span> object1 === object3; // <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  Hier geht es um JavaScript. Wenn Sie jedoch Erfahrung in der Entwicklung in anderen Sprachen haben, sind Sie möglicherweise mit dem Konzept der Zeiger vertraut.  Im obigen Code wird jedes Mal, wenn ein Objekt erstellt wird, ein Teil des Systemspeichers dafür zugewiesen.  Wenn wir einen Befehl der Form <code>object1 = {}</code> , führt dies dazu, dass ein speziell für <code>object1</code> zugewiesener Speicher mit einigen Daten gefüllt wird. <br><br>  Man kann sich <code>object1</code> durchaus als die Adresse vorstellen, an der sich die auf das Objekt bezogenen Datenstrukturen im Speicher befinden.  Die Ausführung des Befehls <code>object2 = {}</code> führt zur Zuweisung eines anderen Speicherbereichs, der speziell für <code>object2</code> .  <code>object2</code> <code>obect1</code> und <code>object2</code> im selben Speicherbereich?  Nein, jeder von ihnen hat seine eigene Handlung.  Deshalb werden wir <code>false</code> wenn wir versuchen, <code>object2</code> und <code>object2</code> zu vergleichen.  Diese Objekte haben möglicherweise eine identische Struktur, aber die Adressen im Speicher, in dem sie sich befinden, unterscheiden sich, und es sind die Adressen, die während des Vergleichs überprüft werden. <br><br>  Durch Ausführen des Befehls <code>object3 = object1</code> schreiben wir die Adresse von <code>object3</code> Konstante <code>object3</code> .  Dies ist kein neues Objekt.  Dieser Konstante wird die Adresse eines vorhandenen Objekts zugewiesen.  Sie können dies überprüfen, indem Sie: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = { x: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object3 = object1; object3.x = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; object1.x; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  In diesem Beispiel wird ein Objekt im Speicher erstellt und seine Adresse in die Konstante <code>object1</code> .  Dann wird dieselbe Adresse in das konstante <code>object3</code> .  Durch Ändern von <code>object3</code> wird das Objekt im Speicher <code>object3</code> .  Dies bedeutet, dass wir beim Zugriff auf ein Objekt mit einem anderen Verweis darauf, beispielsweise dem in <code>object1</code> gespeicherten, bereits mit seiner geänderten Version arbeiten. <br><br><h2>  <font color="#3AC1EF">Funktionen, Objekte und Reaktion</font> </h2><br>  Ein Missverständnis des oben genannten Mechanismus durch unerfahrene Entwickler führt häufig zu Fehlern, und möglicherweise ist die Berücksichtigung der Merkmale der Arbeit mit Objekten eines separaten Artikels würdig.  Unser heutiges Thema ist jedoch die Leistung von React-Anwendungen.  In diesem Bereich können selbst von ziemlich erfahrenen Entwicklern Fehler gemacht werden, die einfach nicht darauf achten, wie React-Anwendungen von der Tatsache beeinflusst werden, dass JavaScript-Variablen und -Konstanten nicht in den Objekten selbst gespeichert werden, sondern nur auf diese verlinken. <br><br>  Was hat das mit React zu tun?  React verfügt über intelligente Mechanismen zum Einsparen von Systemressourcen zur Verbesserung der Anwendungsleistung: Wenn sich die Eigenschaften und der Status der Komponente nicht ändern, ändert sich auch nichts an der Renderfunktion.  Wenn die Komponente dieselbe bleibt, muss sie natürlich nicht erneut gerendert werden.  Wenn sich nichts ändert, gibt die <code>render</code> dieselbe wie zuvor zurück, sodass sie nicht ausgeführt werden muss.  Dieser Mechanismus macht React schnell.  Etwas wird nur bei Bedarf angezeigt. <br><br>  React überprüft die Eigenschaften und den Status von Komponenten mithilfe von Standard-JavaScript-Funktionen auf Gleichheit. Das heißt, es werden sie einfach mit dem Operator <code>==</code> verglichen.  React führt keinen "flachen" oder "tiefen" Vergleich von Objekten durch, um deren Gleichheit zu bestimmen.  Ein "flacher Vergleich" ist ein Konzept, das verwendet wird, um einen Vergleich jedes Schlüssel-Wert-Paares eines Objekts zu beschreiben, im Gegensatz zu einem Vergleich, bei dem nur die Adressen von Objekten im Speicher verglichen werden (Verweise auf diese).  Der „tiefe“ Vergleich von Objekten geht noch weiter, und wenn die Werte der verglichenen Eigenschaften der Objekte auch Objekte sind, vergleichen sie auch die Schlüssel-Wert-Paare dieser Objekte.  Dieser Vorgang wird für alle in anderen Objekten verschachtelten Objekte wiederholt.  React macht nichts dergleichen, sondern prüft nur die Gleichheit der Links. <br><br>  Wenn Sie beispielsweise die Eigenschaft einer Komponente, die durch ein Objekt der Form <code>{ x: 1 }</code> in ein anderes Objekt ändern, das genau gleich aussieht, wird die Komponente von React erneut gerendert, da sich diese Objekte in verschiedenen Speicherbereichen befinden.  Wenn Sie sich an das obige Beispiel erinnern, wird beim Ändern der Eigenschaften einer Komponente von <code>object1</code> in <code>object3</code> eine solche Komponente von React nicht erneut <code>object3</code> , da sich die Konstanten <code>object1</code> und <code>object3</code> auf dasselbe Objekt beziehen. <br><br>  Das Arbeiten mit Funktionen in JavaScript ist genauso organisiert.  Wenn React auf dieselben Funktionen stößt, deren Adressen unterschiedlich sind, wird es erneut gerendert.  Wenn die „neue Funktion“ nur eine Verknüpfung zu einer bereits verwendeten Funktion ist, erfolgt kein erneutes Rendern. <br><br><h2>  <font color="#3AC1EF">Ein typisches Problem bei der Arbeit mit Komponenten</font> </h2><br>  Hier ist eines der Szenarien für die Arbeit mit Komponenten, die mir leider ständig beim Überprüfen des Codes eines anderen auffallen: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ get instructions() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.do) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Click</span></span> the button: ';   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Do</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> click the button: '; } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instructions}       &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={() =&gt; alert('!')} /&gt;     &lt;/div&gt;   ); } }</code> </pre> <br>  Vor uns liegt eine sehr einfache Komponente.  Es ist eine Schaltfläche. Wenn Sie darauf klicken, wird eine Benachrichtigung angezeigt.  Neben der Schaltfläche werden Anweisungen zur Verwendung angezeigt, die den Benutzer darüber informieren, ob er diese Schaltfläche drücken soll.  Steuern Sie, welche Anweisung angezeigt wird, indem Sie die <code>SomeComponent</code> <code>do</code> ( <code>do={true}</code> oder <code>do={false}</code> ) <code>SomeComponent</code> . <br><br>  Jedes Mal, <code>SomeComponent</code> die <code>SomeComponent</code> Komponente erneut gerendert wird (wenn der Wert der Eigenschaft <code>do</code> von <code>true</code> in <code>false</code> geändert wird und umgekehrt), wird auch das <code>Button</code> Element gerendert.  Der <code>onClick</code> Handler wird bei jedem <code>onClick</code> der <code>onClick</code> neu erstellt, obwohl er immer derselbe ist.  Infolgedessen stellt sich heraus, dass jedes Mal, wenn die Komponente im Speicher angezeigt wird, eine neue Funktion erstellt wird, da ihre Erstellung in der <code>render</code> wird, eine Verknüpfung mit der neuen Adresse im Speicher an <code>&lt;Button /&gt;</code> wird und die <code>Button</code> Komponente trotz der Tatsache, dass in erneut gerendert wird nichts hat sich geändert. <br><br>  Lassen Sie uns darüber sprechen, wie Sie das Problem beheben können. <br><br><h2>  <font color="#3AC1EF">Lösung</font> </h2><br>  Wenn die Funktion unabhängig von der Komponente ist ( <code>this</code> Kontext), können Sie sie außerhalb der Komponente definieren.  Alle Instanzen der Komponente verwenden dieselbe Funktionsreferenz, da es sich in allen Fällen um dieselbe Funktion handelt.  So sieht es aus: <br><br><pre> <code class="hljs scala">const createAlertBox = () =&gt; alert('!'); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ get instructions() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.do) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Click</span></span> the button: ';   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Do</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> click the button: '; } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instructions}       &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={createAlertBox} /&gt;     &lt;/div&gt;   ); } }</code> </pre> <br>  Im Gegensatz zum vorherigen Beispiel enthält <code>createAlertBox</code> bei jedem Aufruf zum <code>render</code> denselben Link zu demselben Bereich im Speicher.  Infolgedessen wird <code>Button</code> wiederholte Ausgabe von <code>Button</code> nicht ausgeführt. <br><br>  Während die <code>Button</code> Komponente klein ist und schnell gerendert wird, kann das obige Problem, das mit der internen Deklaration von Funktionen verbunden ist, auch in großen, komplexen Komponenten auftreten, deren Rendern viel Zeit in Anspruch nimmt.  Dies kann die React-Anwendung erheblich verlangsamen.  In diesem Zusammenhang ist es sinnvoll, der Empfehlung zu folgen, wonach solche Funktionen niemals innerhalb der <code>render</code> deklariert werden sollten. <br><br>  Wenn die Funktion von der Komponente abhängt, dh nicht außerhalb der Komponente definiert werden kann, kann die Komponentenmethode als Ereignishandler übergeben werden: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ createAlertBox = () =&gt; {   alert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.message); }; get instructions() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.do) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Click</span></span> the button: ';   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Do</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> click the button: '; } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instructions}       &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createAlertBox} /&gt;     &lt;/div&gt;   ); } }</code> </pre> <br>  In diesem Fall werden in jeder Instanz von <code>SomeComponent</code> beim Klicken auf die Schaltfläche verschiedene Meldungen angezeigt.  Der Ereignishandler des <code>Button</code> Elements muss für <code>SomeComponent</code> eindeutig <code>SomeComponent</code> .  Beim Übergeben der <code>cteateAlertBox</code> Methode spielt <code>cteateAlertBox</code> keine Rolle, ob <code>SomeComponent</code> neu gerendert wird.  Es spielt keine Rolle, ob sich die <code>message</code> geändert hat.  Die Adresse der Funktion <code>createAlertBox</code> nicht. <code>createAlertBox</code> bedeutet, dass das <code>Button</code> Element nicht erneut gerendert werden sollte.  Dank dieser Funktion können Sie Systemressourcen sparen und die Rendergeschwindigkeit der Anwendung verbessern. <br><br>  Das alles ist gut.  Was aber, wenn Funktionen dynamisch sind? <br><br><h2>  <font color="#3AC1EF">Ein komplexeres Problem lösen</font> </h2><br>  <i>Der Autor dieses Materials bittet Sie, darauf zu achten, dass er die Beispiele in diesem Abschnitt vorbereitet hat, wobei er sich als erstes Gedanken über die Wiederverwendung von Funktionen gemacht hat.</i>  <i>Diese Beispiele sollen dem Leser helfen, das Wesentliche der Idee zu erfassen.</i>  <i>Obwohl dieser Abschnitt zum Lesen empfohlen wird, um die Essenz des Geschehens zu verstehen, empfiehlt der Autor, auf Kommentare zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originalartikel</a> zu achten, da einige Leser bessere Versionen der hier diskutierten Mechanismen vorgeschlagen haben, die Merkmale der in React integrierten Cache-Invalidierung und Speicherverwaltungsmechanismen berücksichtigen.</i> <br><br>  Daher ist es äußerst häufig, dass in einer Komponente viele eindeutige, dynamische Ereignishandler vorhanden sind. Beispielsweise ist im Code etwas Ähnliches zu sehen, in dem die <code>map</code> Array-Methode in der <code>render</code> Methode verwendet wird: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;ul&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.list.map(listItem =&gt;         &lt;li key={listItem.text}&gt;           &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={() =&gt; alert(listItem.text)} /&gt;         &lt;/li&gt;       )}     &lt;/ul&gt;   ); } }</code> </pre> <br>  Hier wird eine andere Anzahl von Schaltflächen angezeigt und eine andere Anzahl von Ereignishandlern erstellt, von denen jede durch eine eindeutige Funktion dargestellt wird. Im Voraus ist beim Erstellen von <code>SomeComponent</code> nicht bekannt, um welche Funktionen es sich handelt.  Wie löse ich dieses Rätsel? <br><br>  Hier hilft uns das Auswendiglernen oder einfacher das Zwischenspeichern.  Erstellen Sie für jeden eindeutigen Wert eine Funktion und legen Sie sie im Cache ab.  Wenn dieser eindeutige Wert erneut auftritt, reicht es aus, die entsprechende Funktion aus dem Cache zu entnehmen, die zuvor im Cache abgelegt wurde. <br><br>  So sieht die Umsetzung dieser Idee aus: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    SomeComponent        //   . clickHandlers = {}; //       //    . getClickHandler(key) {   //       ,  .   if (!Object.prototype.hasOwnProperty.call(this.clickHandlers, key)) {     this.clickHandlers[key] = () =&gt; alert(key);   }   return this.clickHandlers[key]; } render() {   return (     &lt;ul&gt;       {this.props.list.map(listItem =&gt;         &lt;li key={listItem.text}&gt;           &lt;Button onClick={this.getClickHandler(listItem.text)} /&gt;         &lt;/li&gt;       )}     &lt;/ul&gt;   ); } }</span></span></code> </pre> <br>  Jedes Element des Arrays wird von der Methode <code>getClickHandler</code> verarbeitet.  Diese Methode erstellt beim ersten Aufruf mit einem bestimmten Wert eine für diesen Wert eindeutige Funktion, legt sie im Cache ab und gibt sie zurück.  Bei allen nachfolgenden Aufrufen dieser Methode, bei denen derselbe Wert übergeben wird, wird einfach eine Verknüpfung zur Funktion aus dem Cache zurückgegeben. <br><br>  Infolgedessen wird beim erneuten Rendern von <code>SomeComponent</code> die <code>SomeComponent</code> nicht erneut <code>SomeComponent</code> .  In ähnlicher Weise werden durch Hinzufügen von Elementen zur <code>list</code> dynamisch Ereignishandler für jede Schaltfläche erstellt. <br><br>  Sie müssen kreativ sein, um eindeutige Bezeichner für Handler zu erstellen, wenn diese durch mehr als eine Variable definiert sind. Dies ist jedoch nicht viel komplizierter als die übliche Erstellung einer eindeutigen <code>key</code> für jedes JSX-Objekt, das als Ergebnis der <code>map</code> wird. <br><br>  Hier möchte ich Sie vor möglichen Problemen bei der Verwendung von Array-Indizes als Bezeichner warnen.  Tatsache ist, dass bei diesem Ansatz Fehler auftreten können, wenn sich die Reihenfolge der Elemente im Array ändert oder einige seiner Elemente gelöscht werden.  Wenn beispielsweise ein ähnliches Array zunächst wie <code>[ 'soda', 'pizza' ]</code> aussah und dann in <code>[ 'pizza' ]</code> wurde und Sie Ereignishandler mit einem Befehl der Formular- <code>listeners[0] = () =&gt; alert('soda')</code> , wenn der Benutzer auf die Schaltfläche klickt, der der Handler mit der Kennung 0 zugewiesen ist und die gemäß dem Inhalt des Arrays <code>[ 'pizza' ]</code> eine <code>pizza</code> Nachricht anzeigen soll, wird eine <code>soda</code> Nachricht angezeigt.  Aus dem gleichen Grund wird nicht empfohlen, Array-Indizes als Schlüsseleigenschaften zu verwenden. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In diesem Artikel haben wir die Funktionen der internen JavaScript-Mechanismen untersucht und berücksichtigt, mit denen Sie das Rendern von React-Anwendungen beschleunigen können.  Wir hoffen, dass die hier vorgestellten Ideen nützlich sind. <br><br>  <b>Liebe Leser!</b>  Wenn Sie interessante Möglichkeiten zur Optimierung von React-Anwendungen kennen, teilen Sie diese bitte mit. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426053/">https://habr.com/ru/post/de426053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426039/index.html">Notstart "Sojus MS-10" (Besatzung gerettet, ausgestrahlt)</a></li>
<li><a href="../de426041/index.html">Symbolische Lösung linearer Differentialgleichungen und -systeme durch die Laplace-Transformationsmethode mit SymPy</a></li>
<li><a href="../de426045/index.html">Besondere Ausnahmen in .NET und wie man sie vorbereitet</a></li>
<li><a href="../de426047/index.html">10 großartige Bücher für Anfänger in Englisch</a></li>
<li><a href="../de426051/index.html">Verbesserung der Fähigkeiten zum Debuggen von Software - einige Tipps</a></li>
<li><a href="../de426055/index.html">TensorFlow.js und clmtrackr.js: Verfolgen der Blickrichtung des Benutzers im Browser</a></li>
<li><a href="../de426059/index.html">Tutu PHP Meetup # 2: Sprachvideo</a></li>
<li><a href="../de426061/index.html">Microsoft tritt dem Open Invention Network bei und gewährt 60.000 Lizenzen</a></li>
<li><a href="../de426063/index.html">HPE MSA-Array-Innovationen der Einstiegsklasse: günstigeres Flash-Array und umfassende Lösungsintegration</a></li>
<li><a href="../de426065/index.html">Smart TV, das selbst den interessantesten Kanal bestimmt, oder eine ungewöhnliche Sudoku-Lösung für Videoinhalte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>