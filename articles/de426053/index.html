<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ß üéüÔ∏è üöå Caching von Ereignishandlern und Verbesserung der Anwendungsleistung üì© ‚úäüèø üëºüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute ver√∂ffentlichen wir eine √úbersetzung des Materials, dessen Autor, nachdem er die Funktionen der Arbeit mit Objekten in JavaScript analysiert hat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Caching von Ereignishandlern und Verbesserung der Anwendungsleistung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/426053/">  Heute ver√∂ffentlichen wir eine √úbersetzung des Materials, dessen Autor, nachdem er die Funktionen der Arbeit mit Objekten in JavaScript analysiert hat, React-Entwicklern eine Methode zur Beschleunigung von Anwendungen bietet.  Insbesondere sprechen wir √ºber die Tatsache, dass eine Variable, die, wie sie sagen, "einem Objekt zugewiesen" ist und oft einfach "Objekt" genannt wird, tats√§chlich nicht das Objekt selbst speichert, sondern eine Verkn√ºpfung dazu.  Funktionen in JavaScript sind ebenfalls Objekte, daher gilt das oben Gesagte f√ºr sie.  Wenn Sie dies ber√ºcksichtigen, k√∂nnen Sie durch das Entwerfen von React-Komponenten und die kritische Analyse ihres Codes ihre internen Mechanismen verbessern und die Anwendungsleistung verbessern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54f/6b5/80a/54f6b580affe2d9741da8207f93b4746.png"></div><br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Funktionen zum Arbeiten mit Objekten in JavaScript</font> </h2><br>  Wenn Sie einige Funktionen erstellen, die genau gleich aussehen, und versuchen, sie zu vergleichen, stellt sich heraus, dass sie aus Sicht des Systems unterschiedlich sind.  Um dies zu √ºberpr√ºfen, k√∂nnen Sie den folgenden Code ausf√ºhren: <br><br><pre><code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionOne = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionTwo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); }; functionOne === functionTwo; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Versuchen wir nun, einer vorhandenen Funktion, die bereits einer anderen Variablen zugewiesen ist, eine Variable zuzuweisen, und vergleichen Sie diese beiden Variablen: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionThree = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionFour = functionThree; functionThree === functionFour; <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  Wie Sie sehen k√∂nnen, gibt der strikte Gleichheitsoperator bei diesem Ansatz <code>true</code> . <br>  Objekte verhalten sich nat√ºrlich genauso: <br><br><pre> <code class="hljs julia"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object3 = object1; object1 === object2; // <span class="hljs-literal"><span class="hljs-literal">false</span></span> object1 === object3; // <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  Hier geht es um JavaScript. Wenn Sie jedoch Erfahrung in der Entwicklung in anderen Sprachen haben, sind Sie m√∂glicherweise mit dem Konzept der Zeiger vertraut.  Im obigen Code wird jedes Mal, wenn ein Objekt erstellt wird, ein Teil des Systemspeichers daf√ºr zugewiesen.  Wenn wir einen Befehl der Form <code>object1 = {}</code> , f√ºhrt dies dazu, dass ein speziell f√ºr <code>object1</code> zugewiesener Speicher mit einigen Daten gef√ºllt wird. <br><br>  Man kann sich <code>object1</code> durchaus als die Adresse vorstellen, an der sich die auf das Objekt bezogenen Datenstrukturen im Speicher befinden.  Die Ausf√ºhrung des Befehls <code>object2 = {}</code> f√ºhrt zur Zuweisung eines anderen Speicherbereichs, der speziell f√ºr <code>object2</code> .  <code>object2</code> <code>obect1</code> und <code>object2</code> im selben Speicherbereich?  Nein, jeder von ihnen hat seine eigene Handlung.  Deshalb werden wir <code>false</code> wenn wir versuchen, <code>object2</code> und <code>object2</code> zu vergleichen.  Diese Objekte haben m√∂glicherweise eine identische Struktur, aber die Adressen im Speicher, in dem sie sich befinden, unterscheiden sich, und es sind die Adressen, die w√§hrend des Vergleichs √ºberpr√ºft werden. <br><br>  Durch Ausf√ºhren des Befehls <code>object3 = object1</code> schreiben wir die Adresse von <code>object3</code> Konstante <code>object3</code> .  Dies ist kein neues Objekt.  Dieser Konstante wird die Adresse eines vorhandenen Objekts zugewiesen.  Sie k√∂nnen dies √ºberpr√ºfen, indem Sie: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = { x: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object3 = object1; object3.x = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; object1.x; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  In diesem Beispiel wird ein Objekt im Speicher erstellt und seine Adresse in die Konstante <code>object1</code> .  Dann wird dieselbe Adresse in das konstante <code>object3</code> .  Durch √Ñndern von <code>object3</code> wird das Objekt im Speicher <code>object3</code> .  Dies bedeutet, dass wir beim Zugriff auf ein Objekt mit einem anderen Verweis darauf, beispielsweise dem in <code>object1</code> gespeicherten, bereits mit seiner ge√§nderten Version arbeiten. <br><br><h2>  <font color="#3AC1EF">Funktionen, Objekte und Reaktion</font> </h2><br>  Ein Missverst√§ndnis des oben genannten Mechanismus durch unerfahrene Entwickler f√ºhrt h√§ufig zu Fehlern, und m√∂glicherweise ist die Ber√ºcksichtigung der Merkmale der Arbeit mit Objekten eines separaten Artikels w√ºrdig.  Unser heutiges Thema ist jedoch die Leistung von React-Anwendungen.  In diesem Bereich k√∂nnen selbst von ziemlich erfahrenen Entwicklern Fehler gemacht werden, die einfach nicht darauf achten, wie React-Anwendungen von der Tatsache beeinflusst werden, dass JavaScript-Variablen und -Konstanten nicht in den Objekten selbst gespeichert werden, sondern nur auf diese verlinken. <br><br>  Was hat das mit React zu tun?  React verf√ºgt √ºber intelligente Mechanismen zum Einsparen von Systemressourcen zur Verbesserung der Anwendungsleistung: Wenn sich die Eigenschaften und der Status der Komponente nicht √§ndern, √§ndert sich auch nichts an der Renderfunktion.  Wenn die Komponente dieselbe bleibt, muss sie nat√ºrlich nicht erneut gerendert werden.  Wenn sich nichts √§ndert, gibt die <code>render</code> dieselbe wie zuvor zur√ºck, sodass sie nicht ausgef√ºhrt werden muss.  Dieser Mechanismus macht React schnell.  Etwas wird nur bei Bedarf angezeigt. <br><br>  React √ºberpr√ºft die Eigenschaften und den Status von Komponenten mithilfe von Standard-JavaScript-Funktionen auf Gleichheit. Das hei√üt, es werden sie einfach mit dem Operator <code>==</code> verglichen.  React f√ºhrt keinen "flachen" oder "tiefen" Vergleich von Objekten durch, um deren Gleichheit zu bestimmen.  Ein "flacher Vergleich" ist ein Konzept, das verwendet wird, um einen Vergleich jedes Schl√ºssel-Wert-Paares eines Objekts zu beschreiben, im Gegensatz zu einem Vergleich, bei dem nur die Adressen von Objekten im Speicher verglichen werden (Verweise auf diese).  Der ‚Äûtiefe‚Äú Vergleich von Objekten geht noch weiter, und wenn die Werte der verglichenen Eigenschaften der Objekte auch Objekte sind, vergleichen sie auch die Schl√ºssel-Wert-Paare dieser Objekte.  Dieser Vorgang wird f√ºr alle in anderen Objekten verschachtelten Objekte wiederholt.  React macht nichts dergleichen, sondern pr√ºft nur die Gleichheit der Links. <br><br>  Wenn Sie beispielsweise die Eigenschaft einer Komponente, die durch ein Objekt der Form <code>{ x: 1 }</code> in ein anderes Objekt √§ndern, das genau gleich aussieht, wird die Komponente von React erneut gerendert, da sich diese Objekte in verschiedenen Speicherbereichen befinden.  Wenn Sie sich an das obige Beispiel erinnern, wird beim √Ñndern der Eigenschaften einer Komponente von <code>object1</code> in <code>object3</code> eine solche Komponente von React nicht erneut <code>object3</code> , da sich die Konstanten <code>object1</code> und <code>object3</code> auf dasselbe Objekt beziehen. <br><br>  Das Arbeiten mit Funktionen in JavaScript ist genauso organisiert.  Wenn React auf dieselben Funktionen st√∂√üt, deren Adressen unterschiedlich sind, wird es erneut gerendert.  Wenn die ‚Äûneue Funktion‚Äú nur eine Verkn√ºpfung zu einer bereits verwendeten Funktion ist, erfolgt kein erneutes Rendern. <br><br><h2>  <font color="#3AC1EF">Ein typisches Problem bei der Arbeit mit Komponenten</font> </h2><br>  Hier ist eines der Szenarien f√ºr die Arbeit mit Komponenten, die mir leider st√§ndig beim √úberpr√ºfen des Codes eines anderen auffallen: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ get instructions() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.do) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Click</span></span> the button: ';   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Do</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> click the button: '; } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instructions}       &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={() =&gt; alert('!')} /&gt;     &lt;/div&gt;   ); } }</code> </pre> <br>  Vor uns liegt eine sehr einfache Komponente.  Es ist eine Schaltfl√§che. Wenn Sie darauf klicken, wird eine Benachrichtigung angezeigt.  Neben der Schaltfl√§che werden Anweisungen zur Verwendung angezeigt, die den Benutzer dar√ºber informieren, ob er diese Schaltfl√§che dr√ºcken soll.  Steuern Sie, welche Anweisung angezeigt wird, indem Sie die <code>SomeComponent</code> <code>do</code> ( <code>do={true}</code> oder <code>do={false}</code> ) <code>SomeComponent</code> . <br><br>  Jedes Mal, <code>SomeComponent</code> die <code>SomeComponent</code> Komponente erneut gerendert wird (wenn der Wert der Eigenschaft <code>do</code> von <code>true</code> in <code>false</code> ge√§ndert wird und umgekehrt), wird auch das <code>Button</code> Element gerendert.  Der <code>onClick</code> Handler wird bei jedem <code>onClick</code> der <code>onClick</code> neu erstellt, obwohl er immer derselbe ist.  Infolgedessen stellt sich heraus, dass jedes Mal, wenn die Komponente im Speicher angezeigt wird, eine neue Funktion erstellt wird, da ihre Erstellung in der <code>render</code> wird, eine Verkn√ºpfung mit der neuen Adresse im Speicher an <code>&lt;Button /&gt;</code> wird und die <code>Button</code> Komponente trotz der Tatsache, dass in erneut gerendert wird nichts hat sich ge√§ndert. <br><br>  Lassen Sie uns dar√ºber sprechen, wie Sie das Problem beheben k√∂nnen. <br><br><h2>  <font color="#3AC1EF">L√∂sung</font> </h2><br>  Wenn die Funktion unabh√§ngig von der Komponente ist ( <code>this</code> Kontext), k√∂nnen Sie sie au√üerhalb der Komponente definieren.  Alle Instanzen der Komponente verwenden dieselbe Funktionsreferenz, da es sich in allen F√§llen um dieselbe Funktion handelt.  So sieht es aus: <br><br><pre> <code class="hljs scala">const createAlertBox = () =&gt; alert('!'); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ get instructions() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.do) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Click</span></span> the button: ';   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Do</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> click the button: '; } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instructions}       &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={createAlertBox} /&gt;     &lt;/div&gt;   ); } }</code> </pre> <br>  Im Gegensatz zum vorherigen Beispiel enth√§lt <code>createAlertBox</code> bei jedem Aufruf zum <code>render</code> denselben Link zu demselben Bereich im Speicher.  Infolgedessen wird <code>Button</code> wiederholte Ausgabe von <code>Button</code> nicht ausgef√ºhrt. <br><br>  W√§hrend die <code>Button</code> Komponente klein ist und schnell gerendert wird, kann das obige Problem, das mit der internen Deklaration von Funktionen verbunden ist, auch in gro√üen, komplexen Komponenten auftreten, deren Rendern viel Zeit in Anspruch nimmt.  Dies kann die React-Anwendung erheblich verlangsamen.  In diesem Zusammenhang ist es sinnvoll, der Empfehlung zu folgen, wonach solche Funktionen niemals innerhalb der <code>render</code> deklariert werden sollten. <br><br>  Wenn die Funktion von der Komponente abh√§ngt, dh nicht au√üerhalb der Komponente definiert werden kann, kann die Komponentenmethode als Ereignishandler √ºbergeben werden: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ createAlertBox = () =&gt; {   alert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.message); }; get instructions() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.do) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Click</span></span> the button: ';   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Do</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> click the button: '; } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instructions}       &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createAlertBox} /&gt;     &lt;/div&gt;   ); } }</code> </pre> <br>  In diesem Fall werden in jeder Instanz von <code>SomeComponent</code> beim Klicken auf die Schaltfl√§che verschiedene Meldungen angezeigt.  Der Ereignishandler des <code>Button</code> Elements muss f√ºr <code>SomeComponent</code> eindeutig <code>SomeComponent</code> .  Beim √úbergeben der <code>cteateAlertBox</code> Methode spielt <code>cteateAlertBox</code> keine Rolle, ob <code>SomeComponent</code> neu gerendert wird.  Es spielt keine Rolle, ob sich die <code>message</code> ge√§ndert hat.  Die Adresse der Funktion <code>createAlertBox</code> nicht. <code>createAlertBox</code> bedeutet, dass das <code>Button</code> Element nicht erneut gerendert werden sollte.  Dank dieser Funktion k√∂nnen Sie Systemressourcen sparen und die Rendergeschwindigkeit der Anwendung verbessern. <br><br>  Das alles ist gut.  Was aber, wenn Funktionen dynamisch sind? <br><br><h2>  <font color="#3AC1EF">Ein komplexeres Problem l√∂sen</font> </h2><br>  <i>Der Autor dieses Materials bittet Sie, darauf zu achten, dass er die Beispiele in diesem Abschnitt vorbereitet hat, wobei er sich als erstes Gedanken √ºber die Wiederverwendung von Funktionen gemacht hat.</i>  <i>Diese Beispiele sollen dem Leser helfen, das Wesentliche der Idee zu erfassen.</i>  <i>Obwohl dieser Abschnitt zum Lesen empfohlen wird, um die Essenz des Geschehens zu verstehen, empfiehlt der Autor, auf Kommentare zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originalartikel</a> zu achten, da einige Leser bessere Versionen der hier diskutierten Mechanismen vorgeschlagen haben, die Merkmale der in React integrierten Cache-Invalidierung und Speicherverwaltungsmechanismen ber√ºcksichtigen.</i> <br><br>  Daher ist es √§u√üerst h√§ufig, dass in einer Komponente viele eindeutige, dynamische Ereignishandler vorhanden sind. Beispielsweise ist im Code etwas √Ñhnliches zu sehen, in dem die <code>map</code> Array-Methode in der <code>render</code> Methode verwendet wird: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;ul&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.list.map(listItem =&gt;         &lt;li key={listItem.text}&gt;           &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={() =&gt; alert(listItem.text)} /&gt;         &lt;/li&gt;       )}     &lt;/ul&gt;   ); } }</code> </pre> <br>  Hier wird eine andere Anzahl von Schaltfl√§chen angezeigt und eine andere Anzahl von Ereignishandlern erstellt, von denen jede durch eine eindeutige Funktion dargestellt wird. Im Voraus ist beim Erstellen von <code>SomeComponent</code> nicht bekannt, um welche Funktionen es sich handelt.  Wie l√∂se ich dieses R√§tsel? <br><br>  Hier hilft uns das Auswendiglernen oder einfacher das Zwischenspeichern.  Erstellen Sie f√ºr jeden eindeutigen Wert eine Funktion und legen Sie sie im Cache ab.  Wenn dieser eindeutige Wert erneut auftritt, reicht es aus, die entsprechende Funktion aus dem Cache zu entnehmen, die zuvor im Cache abgelegt wurde. <br><br>  So sieht die Umsetzung dieser Idee aus: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    SomeComponent        //   . clickHandlers = {}; //       //    . getClickHandler(key) {   //       ,  .   if (!Object.prototype.hasOwnProperty.call(this.clickHandlers, key)) {     this.clickHandlers[key] = () =&gt; alert(key);   }   return this.clickHandlers[key]; } render() {   return (     &lt;ul&gt;       {this.props.list.map(listItem =&gt;         &lt;li key={listItem.text}&gt;           &lt;Button onClick={this.getClickHandler(listItem.text)} /&gt;         &lt;/li&gt;       )}     &lt;/ul&gt;   ); } }</span></span></code> </pre> <br>  Jedes Element des Arrays wird von der Methode <code>getClickHandler</code> verarbeitet.  Diese Methode erstellt beim ersten Aufruf mit einem bestimmten Wert eine f√ºr diesen Wert eindeutige Funktion, legt sie im Cache ab und gibt sie zur√ºck.  Bei allen nachfolgenden Aufrufen dieser Methode, bei denen derselbe Wert √ºbergeben wird, wird einfach eine Verkn√ºpfung zur Funktion aus dem Cache zur√ºckgegeben. <br><br>  Infolgedessen wird beim erneuten Rendern von <code>SomeComponent</code> die <code>SomeComponent</code> nicht erneut <code>SomeComponent</code> .  In √§hnlicher Weise werden durch Hinzuf√ºgen von Elementen zur <code>list</code> dynamisch Ereignishandler f√ºr jede Schaltfl√§che erstellt. <br><br>  Sie m√ºssen kreativ sein, um eindeutige Bezeichner f√ºr Handler zu erstellen, wenn diese durch mehr als eine Variable definiert sind. Dies ist jedoch nicht viel komplizierter als die √ºbliche Erstellung einer eindeutigen <code>key</code> f√ºr jedes JSX-Objekt, das als Ergebnis der <code>map</code> wird. <br><br>  Hier m√∂chte ich Sie vor m√∂glichen Problemen bei der Verwendung von Array-Indizes als Bezeichner warnen.  Tatsache ist, dass bei diesem Ansatz Fehler auftreten k√∂nnen, wenn sich die Reihenfolge der Elemente im Array √§ndert oder einige seiner Elemente gel√∂scht werden.  Wenn beispielsweise ein √§hnliches Array zun√§chst wie <code>[ 'soda', 'pizza' ]</code> aussah und dann in <code>[ 'pizza' ]</code> wurde und Sie Ereignishandler mit einem Befehl der Formular- <code>listeners[0] = () =&gt; alert('soda')</code> , wenn der Benutzer auf die Schaltfl√§che klickt, der der Handler mit der Kennung 0 zugewiesen ist und die gem√§√ü dem Inhalt des Arrays <code>[ 'pizza' ]</code> eine <code>pizza</code> Nachricht anzeigen soll, wird eine <code>soda</code> Nachricht angezeigt.  Aus dem gleichen Grund wird nicht empfohlen, Array-Indizes als Schl√ºsseleigenschaften zu verwenden. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In diesem Artikel haben wir die Funktionen der internen JavaScript-Mechanismen untersucht und ber√ºcksichtigt, mit denen Sie das Rendern von React-Anwendungen beschleunigen k√∂nnen.  Wir hoffen, dass die hier vorgestellten Ideen n√ºtzlich sind. <br><br>  <b>Liebe Leser!</b>  Wenn Sie interessante M√∂glichkeiten zur Optimierung von React-Anwendungen kennen, teilen Sie diese bitte mit. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426053/">https://habr.com/ru/post/de426053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426039/index.html">Notstart "Sojus MS-10" (Besatzung gerettet, ausgestrahlt)</a></li>
<li><a href="../de426041/index.html">Symbolische L√∂sung linearer Differentialgleichungen und -systeme durch die Laplace-Transformationsmethode mit SymPy</a></li>
<li><a href="../de426045/index.html">Besondere Ausnahmen in .NET und wie man sie vorbereitet</a></li>
<li><a href="../de426047/index.html">10 gro√üartige B√ºcher f√ºr Anf√§nger in Englisch</a></li>
<li><a href="../de426051/index.html">Verbesserung der F√§higkeiten zum Debuggen von Software - einige Tipps</a></li>
<li><a href="../de426055/index.html">TensorFlow.js und clmtrackr.js: Verfolgen der Blickrichtung des Benutzers im Browser</a></li>
<li><a href="../de426059/index.html">Tutu PHP Meetup # 2: Sprachvideo</a></li>
<li><a href="../de426061/index.html">Microsoft tritt dem Open Invention Network bei und gew√§hrt 60.000 Lizenzen</a></li>
<li><a href="../de426063/index.html">HPE MSA-Array-Innovationen der Einstiegsklasse: g√ºnstigeres Flash-Array und umfassende L√∂sungsintegration</a></li>
<li><a href="../de426065/index.html">Smart TV, das selbst den interessantesten Kanal bestimmt, oder eine ungew√∂hnliche Sudoku-L√∂sung f√ºr Videoinhalte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>