<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🔧 🧕 📭 Teste de unidade no Laravel 👇🏿 🐂 🕤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Entre as discussões na comunidade, muitas vezes ouço a opinião de que o teste de unidade no Laravel é errado, complicado e os testes são longos e não ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Teste de unidade no Laravel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457866/"><p>  Entre as discussões na comunidade, muitas vezes ouço a opinião de que o teste de unidade no Laravel é errado, complicado e os testes são longos e não trazem nenhum benefício.  Por esse motivo, poucos escrevem esses testes, limitando-se apenas aos testes de recursos, e o uso de testes de unidade tende a 0. <br>  Eu também pensei isso uma vez, mas uma vez pensei nisso e me perguntei - talvez eu não saiba como cozinhá-los? </p><br><p>  Por algum tempo eu entendi e, na saída, tive um novo entendimento sobre os testes de unidade, e os testes se tornaram claros, amigáveis, rápidos e começaram a me ajudar. <br>  Quero compartilhar meu entendimento com a comunidade e, ainda melhor, entender este tópico, tornar meus testes ainda melhores. </p><a name="habracut"></a><br><h2 id="nemnogo-filosofii-i-ogranicheniy">  Um pouco de filosofia e limitações </h2><br><p>  O Laravel é um tipo de framework em alguns lugares.  Especialmente em termos de fachadas e Eloquent.  Não tocarei em discussões ou condenações desses pontos, mas mostrarei como os combino com testes de unidade. <br>  Escrevo testes depois (ou ao mesmo tempo) de escrever o código principal.  Talvez minha abordagem não seja compatível com a abordagem TDD ou exija ajustes parciais. </p><br><p> A pergunta mais importante que me faço antes de escrever um teste é "o que exatamente eu quero testar?".  Esta é uma questão importante.  Foi essa ideia que me permitiu reconsiderar meus pontos de vista sobre a escrita de testes de unidade e o próprio código do projeto. </p><br><p>  Os testes devem ser estáveis ​​e minimamente dependentes do ambiente.  Se, quando você fizer mutações, seus testes falharem, provavelmente serão bons.  Por outro lado, se eles não caem, provavelmente não são muito bons. </p><br><p>  Pronto para uso, o Laravel suporta 3 tipos de testes: </p><br><ul><li>  Navegador </li><li>  Recurso </li><li>  Unidade </li></ul><br><p>  Vou falar principalmente sobre testes de unidade. </p><br><p>  Não testei todo o código por meio de testes de unidade (talvez isso não esteja correto).  Não testei nenhum código (mais sobre isso abaixo). </p><br><p>  Se moques forem usados ​​nos testes, não esqueça de usar Mockery :: close () no tearDown. </p><br><p>  Alguns exemplos de testes são "retirados da Internet". </p><br><h2 id="kak-ya-testiruyu">  Como eu teste </h2><br><p>  Abaixo, agruparei exemplos de teste por grupo de turmas e tentarei dar exemplos de teste para cada grupo de turmas.  Para a maioria dos grupos de turmas, não darei exemplos do código em si. </p><br><h3 id="middleware">  Middleware </h3><br><p>  Para o teste de unidade do middleware, crio um objeto da classe Request, um objeto do Middleware desejado, depois chamo o método handle e executo as declarações necessárias.  O middleware de acordo com as ações executadas pode ser dividido em 3 grupos: </p><br><ul><li>  objeto de solicitação de alteração (alteração de solicitação do corpo ou sessões) </li><li>  redirecionando (alterando o status da resposta) </li><li>  não fazendo nada com o objeto de solicitação <br>  Vamos tentar dar um exemplo de teste para cada grupo: </li></ul><br><p>  Suponha que tenhamos o seguinte Middleware, cuja tarefa é modificar o campo de título: </p><br><pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TitlecaseMiddleware</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($request, Closure $next)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($request-&gt;title) { $request-&gt;merge([ <span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; title_case($request-&gt;title) ]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $next($request); } }</code> </pre> <br><p>  Um teste para um Middleware semelhante pode ser assim: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testChangeTitleToTitlecase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request; $request-&gt;merge([ <span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'Title is in mixed CASE'</span></span> ]); $middleware = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TitlecaseMiddleware; $middleware-&gt;handle($request, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals(<span class="hljs-string"><span class="hljs-string">'Title Is In Mixed Case'</span></span>, $req-&gt;title); }); }</code> </pre> <br><p>  Os testes para os grupos 2 e 3 terão esse plano, respectivamente: </p><br><pre> <code class="php hljs">$response = $middleware-&gt;handle($request, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{}); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals($response-&gt;getStatusCode(), <span class="hljs-number"><span class="hljs-number">302</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   $this-&gt;assertEquals($response, null); //      request</span></span></code> </pre> <br><h3 id="request-class">  Solicitar classe </h3><br><p>  A principal tarefa desse grupo de classes é a autorização e a validação de solicitações. </p><br><p>  Não testei essas classes através de testes de unidade (admito que isso pode não ser verdade), apenas através de testes de recursos.  Na minha opinião, os testes de unidade são redundantes para essas classes, mas encontrei alguns exemplos interessantes de como isso pode ser feito.  Talvez eles o ajudem se você decidir testar sua classe de unidade de solicitação com testes: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://medium.com/@daaaan/a-guide-to-unit-testing-laravel-form-requests-in-a-different-way-f1bdb6d86053</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://stackoverflow.com/questions/36978147/unit-test-laravels-formrequest</a> </li></ul><br><h3 id="controller">  Controlador </h3><br><p>  Também não testo controladores através de testes de unidade.  Mas, ao testá-los, uso um recurso sobre o qual gostaria de falar. </p><br><p>  Controladores, na minha opinião, devem ser leves.  A tarefa deles é obter a solicitação correta, ligar para os serviços e repositórios necessários (já que esses dois termos são “estranhos” para o Laravel, explicarei minha terminologia abaixo), retorne a resposta.  Às vezes, aciona um evento, trabalho, etc. <br>  Assim, ao testar através de testes de recursos, precisamos não apenas chamar o controlador com os parâmetros necessários e verificar a resposta, mas também bloquear os serviços necessários e verificar se eles realmente estão sendo chamados (ou não).  Às vezes - crie um registro no banco de dados. </p><br><p>  Um exemplo de teste de controlador com uma classe de serviço simulada: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testProductCategorySync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $service = Mockery::mock(\App\Services\Product::class); app()-&gt;instance(\App\Services\Product::class, $service); $service-&gt;shouldReceive(<span class="hljs-string"><span class="hljs-string">'sync'</span></span>)-&gt;once(); $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post(<span class="hljs-string"><span class="hljs-string">'/api/v1/sync/eventsCallback'</span></span>, [ <span class="hljs-string"><span class="hljs-string">"eventType"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"PRODUCT_SYNC"</span></span> ]); $response-&gt;assertStatus(<span class="hljs-number"><span class="hljs-number">200</span></span>); }</code> </pre> <br><p>  Um exemplo de teste de controlador com simulação de fachada (no nosso caso, um evento, mas por analogia, é feito para outras fachadas do Laravel): </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testChangeCart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Event::fake(); $user = factory(User::class)-&gt;create(); Passport::actingAs( $user ); $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post(<span class="hljs-string"><span class="hljs-string">'/api/v1/cart/update'</span></span>, [ <span class="hljs-string"><span class="hljs-string">'products'</span></span> =&gt; [ [ <span class="hljs-comment"><span class="hljs-comment">// our changed data ] ], ]); $data = json_decode($response-&gt;getContent()); $response-&gt;assertStatus(200); $this-&gt;assertEquals($user-&gt;id, $data-&gt;data-&gt;userId); // and assert other data from response Event::assertDispatched(CartChanged::class); }</span></span></code> </pre> <br><h3 id="service-i-repositories">  Serviço e Repositórios </h3><br><p>  Esses tipos de classes estão prontos para uso.  Eu tento manter os controladores magros, então dedico todo o trabalho extra a um desses grupos de turmas. </p><br><p>  Eu determinei a diferença entre eles da seguinte maneira: </p><br><ul><li>  Se eu precisar implementar alguma lógica de negócios, coloquei isso na camada de serviço apropriada (classe). </li><li>  Em todos os outros casos, eu coloquei isso no grupo de classes do repositório.  Por via de regra, o funcional com Eloquent vai para lá.  Entendo que essa não é a definição correta do nível do repositório.  Também ouvi dizer que alguns suportam tudo relacionado ao Eloquent no modelo.  Minha abordagem é uma espécie de compromisso, na minha opinião, embora "academicamente" não seja inteiramente verdadeiro. </li></ul><br><p>  Para classes de repositório, quase não escrevo testes. </p><br><p>  Exemplo de teste de classe de serviço abaixo: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testUpdateCart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Event::fake(); $cartService = resolve(CartService::class); $cartRepo = resolve(CartRepository::class); $user = factory(User::class)-&gt;make(); $cart = $cartRepo-&gt;getCart($user); <span class="hljs-comment"><span class="hljs-comment">// set data $data = [ ]; $newCart = $cartService-&gt;updateForUser($user, $data); $this-&gt;assertEquals($data, $newCart-&gt;toArray()); Event::assertDispatched(CartChanged::class, 1); }</span></span></code> </pre> <br><h3 id="event-listener-jobs">  Ouvinte de eventos, Trabalhos </h3><br><p>  Essas classes são testadas quase pelo princípio geral - preparamos os dados necessários para o teste;  Chamamos a classe desejada a partir da estrutura e verificamos o resultado. <br>  Exemplo para o Ouvinte: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testHandle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $user = factory(User::class)-&gt;create(); $cart = Cart::create([ <span class="hljs-string"><span class="hljs-string">'userId'</span></span> =&gt; $user-&gt;id, <span class="hljs-comment"><span class="hljs-comment">// other needed data ]); $listener = new CreateTaskForSyncCart(); $listener-&gt;handle(new CartChanged($cart)); $job = // get our job $this-&gt;assertSame(json_encode($cart-&gt;products), $job-&gt;payload); $this-&gt;assertSame($user-&gt;id, $job-&gt;user_id); // some additional asserts. Work with this data simplest for example $this-&gt;assertTrue($updatedAt-&gt;equalTo($job-&gt;last_updated_at)); }</span></span></code> </pre> <br><h3 id="console-commands">  Console do console </h3><br><p>  Considero os comandos do console como algum tipo de controlador que pode gerar adicionalmente (e executar manipulações mais complexas com os dados de entrada e saída de console descritos na documentação).  Assim, os testes são semelhantes ao controlador: verificamos se os métodos de serviço necessários são chamados, eventos são acionados (ou não) e também verificamos a interação com o console (saída ou solicitação de dados). </p><br><p>  Um exemplo de teste semelhante: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSendCartSyncDataEmptyJobs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $service = m::mock(CartJobsRepository::class); app()-&gt;instance(CartJobsRepository::class, $service); $service-&gt;shouldReceive(<span class="hljs-string"><span class="hljs-string">'getAll'</span></span>) -&gt;once()-&gt;andReturn(collect([])); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;artisan(<span class="hljs-string"><span class="hljs-string">'sync:cart'</span></span>) -&gt;expectsOutput(<span class="hljs-string"><span class="hljs-string">'Get all jobs for sending...'</span></span>) -&gt;expectsOutput(<span class="hljs-string"><span class="hljs-string">'All count for sending: 0'</span></span>) -&gt;expectsOutput(<span class="hljs-string"><span class="hljs-string">'Empty jobs'</span></span>) -&gt;assertExitCode(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><h3 id="otdelnye-vneshnie-biblioteki">  Bibliotecas externas separadas </h3><br><p>  Como regra, se bibliotecas separadas tiverem recursos para testes de unidade, elas serão descritas na documentação.  Noutros casos, o trabalho com este código é testado de forma semelhante à camada de serviço.  Não faz sentido cobrir as próprias bibliotecas com testes (somente se você quiser enviar PR para essa biblioteca) e considere-as como algum tipo de caixa preta. </p><br><p>  Em muitos projetos, tenho que interagir através da API com outros serviços.  O Laravel geralmente usa a biblioteca Guzzle para esses fins.  Pareceu-me conveniente colocar todo o trabalho com outros serviços em uma classe separada do serviço NetworkService.  Isso facilitou a escrita e o teste do código principal e ajudou a padronizar as respostas e o tratamento de erros. </p><br><p>  Dou exemplos de vários testes para minha classe NetworkService: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSuccessfulSendNetworkService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $mockHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MockHandler([ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response(<span class="hljs-number"><span class="hljs-number">200</span></span>), ]); $handler = HandlerStack::create($mockHandler); $client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Client([<span class="hljs-string"><span class="hljs-string">'handler'</span></span> =&gt; $handler]); app()-&gt;instance(\GuzzleHttp\Client::class, $client); $networkService = resolve(NetworkService::class); $response = $networkService-&gt;sendRequestToSite(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals(<span class="hljs-string"><span class="hljs-string">'200'</span></span>, $response-&gt;getStatusCode()); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testUnsupportedMethodSendNetworkService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $networkService = resolve(NetworkService::class); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;expectException(<span class="hljs-string"><span class="hljs-string">'\InvalidArgumentException'</span></span>); $networkService-&gt;sendRequestToSite(<span class="hljs-string"><span class="hljs-string">'PUT'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testUnsetConfigUrlNetworkService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $networkService = resolve(NetworkService::class); Config::shouldReceive(<span class="hljs-string"><span class="hljs-string">'get'</span></span>) -&gt;once() -&gt;with(<span class="hljs-string"><span class="hljs-string">'app.api_url'</span></span>) -&gt;andReturn(<span class="hljs-string"><span class="hljs-string">''</span></span>); Config::shouldReceive(<span class="hljs-string"><span class="hljs-string">'get'</span></span>) -&gt;once() -&gt;with(<span class="hljs-string"><span class="hljs-string">'app.api_token'</span></span>) -&gt;andReturn(<span class="hljs-string"><span class="hljs-string">'token'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;expectException(<span class="hljs-string"><span class="hljs-string">'\InvalidArgumentException'</span></span>); $networkService-&gt;sendRequestToApi(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); }</code> </pre> <br><h2 id="vyvody">  Conclusões </h2><br><p>  Essa abordagem permite que eu escreva um código melhor e mais compreensível, aproveitando as abordagens do SOLID e SRP ao escrever o código.  Meus testes se tornaram mais rápidos e, o mais importante - começaram a me beneficiar. </p><br><p>  Com a refatoração ativa ao expandir ou alterar a funcionalidade, vemos imediatamente o que exatamente está caindo e podemos corrigir com rapidez e precisão os erros sem liberá-los do ambiente local.  Isso torna a correção de erros o mais barata possível. </p><br><p>  Espero que os princípios e abordagens que descrevi o ajudem a lidar com o teste de unidade no Laravel e faça com que os testes de unidade sejam seus assistentes no desenvolvimento de código. </p><br><p>  Escreva suas adições e comentários. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt457866/">https://habr.com/ru/post/pt457866/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt457852/index.html">Análise: como os problemas com as autoridades dos EUA afetarão os negócios da Huawei e de TI</a></li>
<li><a href="../pt457854/index.html">Olá dos programadores dos anos 80</a></li>
<li><a href="../pt457860/index.html">Desenvolvendo um aplicativo para streaming usando Node.js e React</a></li>
<li><a href="../pt457862/index.html">iOS Digest No. 8 (14 a 27 de junho)</a></li>
<li><a href="../pt457864/index.html">Mitos e lendas da análise do sistema ou o que um analista de um banco faz</a></li>
<li><a href="../pt457870/index.html">Infraestrutura de construção de projeto com janela de encaixe</a></li>
<li><a href="../pt457872/index.html">Como gerenciar o tempo e parar de procrastinar?</a></li>
<li><a href="../pt457874/index.html">Por que os funcionários estão voltando? Histórias de partida e retorno</a></li>
<li><a href="../pt457876/index.html">Tradução: Padrão IEEE 802.15.4z. O que nos espera no futuro?</a></li>
<li><a href="../pt457884/index.html">Internet Soberana - esclarecendo ordens</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>