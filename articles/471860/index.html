<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õèÔ∏è üö∞ üë©üèº‚Äçüéì Analizadores de clavijas üö£üèø üôèüèΩ ü§õüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace unos a√±os, alguien me pregunt√≥ si ten√≠a sentido convertir Python en un analizador PEG (o en una gram√°tica PEG; no recuerdo exactamente qui√©n y cu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analizadores de clavijas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471860/"><p>  Hace unos a√±os, alguien me pregunt√≥ si ten√≠a sentido convertir Python en un analizador PEG (o en una gram√°tica PEG; no recuerdo exactamente qui√©n y cu√°ndo fue).  Luego lo mir√© un poco, pero no llegu√© a ninguna conclusi√≥n y, por lo tanto, dej√© este tema.  Recientemente aprend√≠ m√°s sobre PEG (Parsing Expression Grammars, Parsing Expression Grammar), y ahora creo que esta es una alternativa interesante al generador de analizador autoescrito que se desarroll√≥ hace 30 a√±os cuando reci√©n comenzaba a trabajar en Python.  Lo llam√© "pgen", y este fue probablemente el primer c√≥digo que escrib√≠ para Python. </p><br><div class="spoiler">  <b class="spoiler_title">Contenido de la serie Python PEG Parser</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Analizadores de clavijas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementaci√≥n del analizador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Generador de analizador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Visualizaci√≥n del analizador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gram√°tica de PEG recursiva izquierda</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Agregar acciones a la gram√°tica PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Meta gram√°tica para el analizador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementando las caracter√≠sticas restantes de PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PEG en Core Developer Sprint</a> </li></ul></div></div><br><p> La raz√≥n por la que actualmente estoy interesado en el analizador PEG es porque estoy un poco molesto por las limitaciones de pgen.  Se basa en su propia implementaci√≥n de LL (1), que tiene una serie de supuestos.  Por ejemplo, no me gustaban las reglas gramaticales que pod√≠an generar l√≠neas vac√≠as, as√≠ que las prohib√≠.  Y de este modo simplific√≥ el algoritmo para crear tablas de an√°lisis.  Tambi√©n invent√© mi propia notaci√≥n gramatical tipo EBNF, que todav√≠a me gusta mucho. </p><a name="habracut"></a><br><p> Aqu√≠ hay algunos problemas con pgen que me molestan.  El "1" en el nombre LL (1) implica que solo analiza el siguiente token, y esto limita nuestra capacidad de crear buenas reglas gramaticales.  Por ejemplo, una declaraci√≥n de Python puede ser una expresi√≥n o una asignaci√≥n (u otra cosa, pero todas comienzan con una palabra clave resaltada, como <code>if</code> o <code>def</code> ).  Me gustar√≠a describir la sintaxis usando la notaci√≥n pgen.  Tenga en cuenta que este es solo un ejemplo simplificado, que es un subconjunto de Python, como generalmente se hace al describir el dise√±o del lenguaje.  Esta ser√° una gram√°tica de juguete que ser√° √∫til para futuras demostraciones. </p><br><pre> <code class="plaintext hljs">statement: assignment | expr | if_statement expr: expr '+' term | expr '-' term | term term: term '*' atom | term '/' atom | atom atom: NAME | NUMBER | '(' expr ')' assignment: target '=' expr target: NAME if_statement: 'if' expr ':' statement</code> </pre> <br><p>  Algunas palabras sobre notaci√≥n: <code>NAME</code> y <code>NUMBER</code> son tokens y est√°n predefinidos fuera de la gram√°tica.  Las cadenas entre comillas de tipo <code>'+'</code> o <code>'if'</code> tambi√©n son tokens.  (Pospongamos hablar de ellos la pr√≥xima vez) Las reglas gramaticales comienzan con el nombre de la regla, seguido de <code>:</code> y luego una o m√°s alternativas, separadas por <code>|</code>  . </p><br><p>  El problema es que si describe la gram√°tica de esta manera, entonces pgen no funcionar√°.  Esto se debe al hecho de que algunas reglas ( <code>expr</code> y <code>term</code> ) se dejan recursivas, y √©l no es lo suficientemente inteligente como para manejar correctamente tales situaciones.  Por lo general, esto se resuelve reescribiendo solo estas reglas, dejando las otras reglas sin cambios.  Por ejemplo: </p><br><pre> <code class="plaintext hljs">expr: term ('+' term | '-' term)* term: atom ('*' atom | '/' atom)*</code> </pre> <br><p>  Esto revela varias posibilidades de EBNF en pgen: puede anidar alternativas entre par√©ntesis y crear repeticiones colocando <code>*</code> despu√©s del elemento.  Entonces, la regla para la expresi√≥n <code>expr</code> aqu√≠ significa "es un t√©rmino seguido de cero o m√°s repeticiones de la secuencia &lt;t√©rmino m√°s o menos, seguido de t√©rmino&gt;".  Esta gram√°tica toma el mismo lenguaje que la primera versi√≥n, pero nuevamente no refleja la intenci√≥n de dise√±o del lenguaje.  En particular, no muestra que los operadores est√©n vinculados a la izquierda, y esto es importante cuando intenta generar c√≥digo. </p><br><p>  Pero hay otro problema molesto en este ejemplo (y tambi√©n en Python).  Debido al an√°lisis de un solo token, el analizador no puede determinar lo que est√° mirando: el comienzo de una expresi√≥n o asignaci√≥n.  Al comienzo del procesamiento del operador, el analizador debe decidir solo el primer token, qu√© alternativa analiza.  (¬øPor qu√©? As√≠ es como funciona la implementaci√≥n del an√°lisis en pgen) Digamos que nuestro programa es el siguiente: </p><br><pre> <code class="plaintext hljs">answer = 42</code> </pre> <br><p>  Este programa est√° representado por tres tokens: <code>NAME</code> (con valor de <code>answer</code> ), <code>=</code> y <code>NUMBER</code> (con valor <code>42</code> ).  Lo √∫nico que sabemos al comienzo del an√°lisis es el primer token <code>NAME</code> .  La regla que estamos tratando de analizar en esta etapa es la <code>statement</code> (el car√°cter inicial de la gram√°tica).  Se definen tres alternativas para ello: <code>expr</code> , <code>assignment</code> y <code>if_statement</code> .  Podemos excluir inmediatamente <code>if_statement</code> , porque el token anterior no es <code>if</code> .  Pero tanto <code>expr</code> como la <code>assignment</code> pueden comenzar con el token <code>NAME</code> , y debido a esto, pgen rechaza nuestra gram√°tica como ambigua. </p><br><p>  Esto no es del todo correcto, ya que t√©cnicamente la gram√°tica en s√≠ no lo es;  No puedo encontrar una formulaci√≥n m√°s precisa, as√≠ que deteng√°monos en esta.  ¬øY c√≥mo pgen resuelve esto?  Calcula algo llamado PRIMER conjunto para cada regla gramatical, y si se cruzan, arroja una excepci√≥n. </p><br><p>  Entonces, ¬øno podemos resolver este problema proporcionando al analizador un b√∫fer de visualizaci√≥n m√°s grande?  Para nuestro ejemplo, un segundo token de vista previa es suficiente, ya que en esta gram√°tica el segundo token de asignaci√≥n deber√≠a ser <code>=</code> .  Pero en un lenguaje m√°s realista como Python, es posible que necesite un b√∫fer ilimitado, ya que el contenido a la izquierda de <code>=</code> token <code>=</code> puede ser arbitrariamente complejo, por ejemplo: </p><br><pre> <code class="python hljs">table[index + <span class="hljs-number"><span class="hljs-number">1</span></span>].name.first = <span class="hljs-string"><span class="hljs-string">'Steven'</span></span></code> </pre> <br><p>  En este caso, tendr√° que analizar diez fichas antes de que nos encontremos con <code>=</code> .  Pero te aseguro que puede haber expresiones m√°s largas.  Para resolver este problema en pgen, cambiamos el analizador de gram√°tica para aceptar algunas expresiones incorrectas, agregando una verificaci√≥n adicional en un pase posterior.  Lanzar√° un error SyntaxError si no puede coincidir con los lados izquierdo y derecho.  Para nuestro lenguaje de juguetes, todo se reduce a escribir lo siguiente: </p><br><pre> <code class="plaintext hljs">statement: assignment_or_expr | if_statement assignment_or_expr: expr ['=' expr]</code> </pre> <br><p>  Los corchetes indican una parte opcional.  Y luego, en el pr√≥ximo paso del compilador (digamos, generaci√≥n de c√≥digo de bytes), verificamos si hay <code>=</code> o no, y si es as√≠, verificamos que el lado izquierdo coincida con la sintaxis de <code>target</code> . </p><br><p>  Hay un problema similar para los argumentos de llamada de funci√≥n.  Nos gustar√≠a escribir algo como esto (nuevamente, en una versi√≥n simplificada de la sintaxis de Python): </p><br><pre> <code class="plaintext hljs">call: atom '(' arguments ')' arguments: arg (',' arg) * arg: posarg | kwarg posarg: expr kwarg: NAME '=' expr</code> </pre> <br><p>  Pero un algoritmo de an√°lisis que tenga en cuenta solo el siguiente token no puede decirle al analizador si <code>NAME</code> al comienzo de los argumentos es el comienzo de <code>posarg</code> (ya que <code>expr</code> puede comenzar con <code>NAME</code> ) o el comienzo de <code>kwarg</code> .  Nuevamente, el analizador actual de Python resuelve este problema determinando: </p><br><pre> <code class="plaintext hljs">arg: expr ['=' expr]</code> </pre> <br><p>  y luego completa la alternativa en un paso posterior del compilador.  (Incluso cometimos un peque√±o error y analizamos <code>foo((a) = 1)</code> misma manera que <code>foo(a = 1)</code> . Esto se solucion√≥ solo en Python 3.8) </p><br><p>  Entonces, ¬øc√≥mo resuelve estos problemas un analizador PEG?  ¬°Usando un buffer de respaldo infinito!  Su implementaci√≥n t√≠pica utiliza el llamado analizador de paquete, que no solo carga todo el programa en la memoria antes de analizarlo, sino que tambi√©n permite que el analizador vuelva a un n√∫mero arbitrario de tokens.  Aunque el t√©rmino PEG se refiere principalmente a la notaci√≥n gramatical, los analizadores generados a partir de gram√°ticas de PEG son t√≠picamente analizadores con descenso recursivo y retorno ilimitado.  El analizador Packrat hace que el ego sea eficiente al recordar las reglas que ya se han analizado para posiciones espec√≠ficas. </p><br><p>  Esto simplifica el algoritmo, pero por supuesto hay un precio: la memoria.  Hace treinta a√±os, ten√≠a una buena raz√≥n para usar LL (1): la memoria era cara.  √âl (como otras tecnolog√≠as como LALR (1), que se hizo famoso por YACC) usa una m√°quina de estado y una pila para construir eficientemente un √°rbol de an√°lisis. </p><br><p>  Afortunadamente, las computadoras que ejecutan CPython tienen mucha m√°s memoria que hace 30 a√±os, y almacenar todo el archivo en la memoria ya no es un problema.  Por ejemplo, el archivo sin prueba m√°s grande en stdlib que pude encontrar es <code>_pydecimal.py</code> , que toma alrededor de 223kb.  En el mundo de gigabytes, esto no es esencialmente nada, lo que me hizo echar un vistazo diferente a los analizadores. </p><br><p>  Pero hay una cosa m√°s en el actual analizador de CPython que me molesta.  Los compiladores son cosas complejas, y la implementaci√≥n de CPython no es una excepci√≥n.  Aunque el resultado del analizador pgen es un √°rbol de an√°lisis, no se usa directamente como entrada para el generador de c√≥digo de bytes: primero se convierte en un √°rbol de sintaxis abstracta (AST), y solo entonces este AST se compila en c√≥digo de bytes.  (De hecho, es a√∫n m√°s complicado all√≠, pero por ahora no entraremos en detalles) </p><br><p>  ¬øPor qu√© no compilar inmediatamente desde un √°rbol de an√°lisis?  As√≠ fue exactamente, pero hace unos 15 a√±os descubrimos que el compilador era demasiado complicado.  Entonces aislamos AST y la fase de transformaci√≥n de AST del √°rbol de an√°lisis por separado.  A medida que Python evolucion√≥, AST se mantuvo m√°s estable que el an√°lisis, lo que redujo la probabilidad de errores en el compilador. </p><br><p>  AST tambi√©n es m√°s f√°cil de trabajar con bibliotecas de terceros que desean probar el c√≥digo Python.  Se puede obtener utilizando el popular m√≥dulo <code>ast</code> .  Tambi√©n le permite crear nodos desde cero y modificar los existentes, as√≠ como compilar partes en c√≥digo de bytes.  Este √∫ltimo permiti√≥ la creaci√≥n de toda una industria de extensiones de lenguaje para Python.  (El √°rbol de an√°lisis tambi√©n es accesible para los usuarios de Python a trav√©s del m√≥dulo de an√°lisis, pero trabajar con √©l es mucho m√°s dif√≠cil; por lo tanto, no es tan popular) </p><br><p>  Ahora quiero combinar estas cosas y ver si podemos crear un nuevo analizador para CPython, que usa PEG y packrat para crear el AST directamente durante el an√°lisis.  Por lo tanto, ser√° posible omitir la generaci√≥n del √°rbol intermedio de an√°lisis, lo que puede ahorrarnos memoria, incluso a pesar del uso de un b√∫fer infinito para los tokens.  Todav√≠a estoy en proceso de implementaci√≥n, pero ya tengo un prototipo que puede compilar un subconjunto de Python en AST aproximadamente a la misma velocidad que el analizador CPython actual.  Sin embargo, usa m√°s memoria y me parece que expandir el subconjunto al lenguaje completo ralentizar√° el analizador PEG.  Pero hasta ahora no he pensado en ninguna optimizaci√≥n, por lo que continuar√© trabajando. </p><br><p>  La √∫ltima ventaja de cambiar a PEG es que proporciona m√°s flexibilidad para una mayor evoluci√≥n del lenguaje.  En el pasado, se dec√≠a que las restricciones LL (1) en pgen manten√≠an la gram√°tica de Python simple.  Este puede muy bien ser el caso, pero tenemos muchos otros procesos para evitar el crecimiento descontrolado del lenguaje (principalmente el proceso PEP, que es ayudado por requisitos muy estrictos de compatibilidad con versiones anteriores y una nueva estructura de gesti√≥n).  As√≠ que no estoy preocupado por eso. </p><br><p>  Me gustar√≠a contar mucho m√°s sobre PEG y mi implementaci√≥n, pero ser√° en las pr√≥ximas publicaciones despu√©s de que limpie el c√≥digo. </p><br><p>  Licencia para este art√≠culo y c√≥digo citado: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/471860/">https://habr.com/ru/post/471860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471844/index.html">5 razones para visitar EPAM INSIDER en Kazajst√°n</a></li>
<li><a href="../471852/index.html">Noticias del mundo de OpenStreetMap No. 481 (01/10/2019 - 07/10/2019)</a></li>
<li><a href="../471854/index.html">Heat Death 5G</a></li>
<li><a href="../471856/index.html">Resolvemos las 42 versiones del rompecabezas de pociones de Harry Potter</a></li>
<li><a href="../471858/index.html">RabbitMQ vs. Kafka: conmutaci√≥n por error y alta disponibilidad en cl√∫steres</a></li>
<li><a href="../471864/index.html">Generador de analizador PEG</a></li>
<li><a href="../471866/index.html">Visualizaci√≥n del analizador PEG</a></li>
<li><a href="../471868/index.html">Gen√©tica del amor: conflicto entre g√©neros como base para la cooperaci√≥n en parejas de p√°jaros mon√≥gamos</a></li>
<li><a href="../471870/index.html">Uso efectivo de libdispatch</a></li>
<li><a href="../471874/index.html">C√≥mo pasamos por alto las pautas de revisi√≥n y lanzamos un servidor en el tel√©fono</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>