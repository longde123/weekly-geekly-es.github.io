<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø üë®‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® üëà Byte-machine para el fuerte (y no solo) en nativos americanos (parte 4) üë©‚Äçüë¶‚Äçüë¶ üë®üèΩ‚Äçüíº ü§ôüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬°Y nuevamente sobreestim√© el volumen del art√≠culo! Plane√© que este ser√≠a el art√≠culo final, donde haremos un compilador y realizaremos pruebas. Pero e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Byte-machine para el fuerte (y no solo) en nativos americanos (parte 4)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437466/"><img src="https://habrastorage.org/getpro/habr/post_images/dbb/a59/e93/dbba59e932ecdb4b0c28896a7e6fc3e3.jpg" alt="Fort Byte Coche (y m√°s) Nativos americanos"><br><br>  ¬°Y nuevamente sobreestim√© el volumen del art√≠culo!  Plane√© que este ser√≠a el art√≠culo final, donde haremos un compilador y realizaremos pruebas.  Pero el volumen result√≥ ser grande, y decid√≠ dividir el art√≠culo en dos. <br><br>  En este art√≠culo, haremos casi todas las funciones b√°sicas del compilador.  Tendr√° vida y ser√° posible escribir, compilar y ejecutar c√≥digo bastante serio.  Y haremos pruebas en la siguiente parte.  (Por cierto, las partes anteriores: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uno</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dos</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tres</a> ). <br><br>  Escribo por primera vez en Habr√©; quiz√°s no siempre est√° bien.  En mi opini√≥n, los art√≠culos 2, 3 resultaron ser bastante secos, mucho c√≥digo, poca descripci√≥n.  Esta vez intentar√© hacer algo diferente, centrarme en la descripci√≥n de las ideas mismas.  Bueno, el c√≥digo ... el c√≥digo, ¬°por supuesto que lo har√°!  Quien quiera entender a fondo, tal oportunidad ser√°.  En muchos casos, pondr√© el c√≥digo debajo del spoiler.  Y, por supuesto, siempre puedes ver la fuente completa en el github. <br><br>  El compilador continuar√° escribiendo durante alg√∫n tiempo en ensamblador, pero luego ir√° al fuerte y continuar√° escribiendo el compilador en nosotros mismos.  Esto se parecer√° al bar√≥n Munchausen, que se tir√≥ del pelo del pantano.  Pero, para empezar, describir√© c√≥mo funciona el compilador en el fuerte.  ¬°Bienvenido a cat! <br><a name="habracut"></a><br><h4>  ¬øC√≥mo funciona el compilador? </h4><br>  La memoria en el fuerte consiste en un fragmento continuo en el que las entradas del diccionario se ordenan secuencialmente.  Despu√©s de su finalizaci√≥n es seguido por un √°rea de memoria libre.  El primer byte libre est√° indicado por la variable h.  Tambi√©n existe la palabra de uso frecuente aqu√≠, que empuja la direcci√≥n del primer byte libre en la pila, se determina de manera muy simple: <br><br><pre><code class="cpp hljs">: here h @ ;</code> </pre> <br><img src="https://habrastorage.org/webt/bd/eg/sq/bdegsqg7t06egwbvxoib9lqk_nc.png"><br><br>  Vale la pena mencionar la palabra asignaci√≥n, que reserva el n√∫mero especificado de bytes moviendo el puntero h.  La palabra asignaci√≥n se puede definir de la siguiente manera: <br><br><pre> <code class="cpp hljs">: allot h +! ;</code> </pre> <br>  De hecho, el compilador utiliza un modo de int√©rprete especial m√°s algunas palabras especiales.  Entonces, con una oraci√≥n, puedes describir todo el principio del compilador en el fuerte.  La variable de estado determina en qu√© modo trabaja el int√©rprete.  Si es cero, se establece el modo de ejecuci√≥n; de lo contrario, modo de compilaci√≥n.  Ya estamos familiarizados con el modo de ejecuci√≥n, en √©l las palabras del b√∫fer de entrada simplemente se ejecutan una tras otra.  Pero en modo de compilaci√≥n no se ejecutan, sino que se compilan en la memoria mediante el puntero h.  En consecuencia, el puntero se mueve hacia adelante. <br><br>  En el fuerte cl√°sico, la palabra "," se usa para compilar un valor entero, la palabra "c" se usa para compilar un byte.  Nuestro sistema utiliza valores de diferentes profundidades de bits (8, 16, 32, 64), por lo tanto, tambi√©n haremos las palabras "w" e "i".  Tambi√©n hacemos la palabra "str", que compilar√° la cadena, tomando dos valores de la pila: la direcci√≥n y la longitud de la cadena. <br><br>  Se usan palabras especiales del compilador para formar estructuras de control.  Estas son las palabras si, entonces, do, loop y otras.  Estas palabras se ejecutan incluso en modo de compilaci√≥n.  Por ejemplo, la palabra if compila un comando de byte de rama condicional (? Nbranch) en la ejecuci√≥n.  Para que el sistema sepa qu√© palabras deben ejecutarse en modo de compilaci√≥n, y no compilarse, se utiliza el indicador (signo) inmediato.  Ya lo tenemos en el campo de marca de la entrada del diccionario.  En el c√≥digo fuente del ensamblador, se llama f_immediate.  Para establecer esta bandera, use la palabra inmediato.  No tiene par√°metros, el indicador inmediato se establece en la √∫ltima palabra del diccionario. <br><br>  ¬°Ahora pasemos de la teor√≠a a la pr√°ctica! <br><br><h4>  Preparaci√≥n </h4><br>  Al principio, necesitamos hacer algunos comandos de bytes simples en lenguaje ensamblador que necesitamos.  Aqu√≠ est√°n: mover (copiar el √°rea de memoria), llenar (llenar el √°rea de memoria), operaciones de bits (y, o, xor, invertir), comandos de desplazamiento de bits (rshift, lshift).  Hagamos el mismo rpick (esto es lo mismo que pick, solo funciona con la pila de retorno, no con la pila de datos). <br><br><div class="spoiler">  <b class="spoiler_title">Estos comandos son muy simples, aqu√≠ est√° su c√≥digo</b> <div class="spoiler_text"><pre> <code class="cpp hljs">b_move = <span class="hljs-number"><span class="hljs-number">0x66</span></span> bcmd_move: pop rcx pop rdi pop rsi repz movsb jmp _next b_fill = <span class="hljs-number"><span class="hljs-number">0x67</span></span> bcmd_fill: pop rax pop rcx pop rdi repz stosb jmp _next b_rpick = <span class="hljs-number"><span class="hljs-number">0x63</span></span> bcmd_rpick: pop rcx push [rbp + rcx * <span class="hljs-number"><span class="hljs-number">8</span></span>] jmp _next b_and = <span class="hljs-number"><span class="hljs-number">0x58</span></span> bcmd_and: pop rax <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> [rsp], rax jmp _next b_or = <span class="hljs-number"><span class="hljs-number">0x59</span></span> bcmd_or: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> [rsp], rax jmp _next b_xor = <span class="hljs-number"><span class="hljs-number">0x5A</span></span> bcmd_xor: pop rax xor [rsp], rax jmp _next b_invert = <span class="hljs-number"><span class="hljs-number">0x5B</span></span> bcmd_invert: notq [rsp] jmp _next b_rshift = <span class="hljs-number"><span class="hljs-number">0x5C</span></span> bcmd_rshift: pop rcx <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rcx, rcx jz _next <span class="hljs-number"><span class="hljs-number">1</span></span>: shrq [rsp] dec rcx jnz <span class="hljs-number"><span class="hljs-number">1b</span></span> jmp _next b_lshift = <span class="hljs-number"><span class="hljs-number">0x5D</span></span> bcmd_lshift: pop rcx <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rcx, rcx jz _next <span class="hljs-number"><span class="hljs-number">1</span></span>: shlq [rsp] dec rcx jnz <span class="hljs-number"><span class="hljs-number">1b</span></span> jmp _next</code> </pre> </div></div><br>  Todav√≠a necesito hacer que la palabra sea palabra.  Esto es lo mismo que blword, pero se indica un delimitador espec√≠fico en la pila.  No proporciono el c√≥digo, se puede encontrar en la fuente.  Copi√© / pegu√© las palabras blworld y reemplac√© los comandos de comparaci√≥n. <br><br>  En conclusi√≥n, hacemos la palabra syscall.  Con √©l, ser√° posible realizar las operaciones faltantes del sistema, por ejemplo, trabajar con archivos.  Tal soluci√≥n no funcionar√° si se requiere independencia de la plataforma.  Pero este sistema ahora se usa para pruebas, as√≠ que d√©jalo as√≠ por ahora.  Si es necesario, todas las operaciones se pueden convertir en comandos de bytes, no es nada dif√≠cil.  El comando syscall aceptar√° 6 par√°metros para la llamada al sistema y el n√∫mero de llamada de la pila.  Devolver√° un par√°metro.  Las asignaciones de par√°metros y el valor de retorno est√°n determinados por el n√∫mero de llamada del sistema. <br><br><pre> <code class="cpp hljs">b_syscall = <span class="hljs-number"><span class="hljs-number">0xFF</span></span> bcmd_syscall: sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> mov [rbp], r8 pop rax pop r9 pop r8 pop r10 pop rdx pop rsi pop rdi syscall push rax mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next</code> </pre><br>  Y ahora procedamos directamente al compilador. <br><br><h4>  Compilador </h4><br>  Crea la variable h, todo es simple. <br><br><pre> <code class="cpp hljs"> item h h: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre>  Escribiremos su inicializaci√≥n en la l√≠nea de inicio: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># forth last_item context @ ! h dup 8 + swap ! quit start: .byte b_call16 .word forth - . - 2 .byte b_call16 .word last_item - . - 2 .byte b_call16 .word context - . - 2 .byte b_get .byte b_set .byte b_call16 .word h - . - 2 .byte b_dup, b_num8, b_add, b_swap, b_set .byte b_quit</span></span></code> </pre><br>  Hagamos la palabra aqu√≠: <br><br><pre> <code class="cpp hljs"> item here .byte b_call8, h - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_get .byte b_exit</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Y tambi√©n palabras para compilar los valores: "asignaci√≥n" y "c", "w", "i", ",", "str"</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : allot h +! ; item allot allot: .byte b_call8, h - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_setp, b_exit # : , here ! <span class="hljs-number"><span class="hljs-number">8</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">","</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set, b_num8, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : i, here i! <span class="hljs-number"><span class="hljs-number">4</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">"i,"</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set32, b_num4, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : w, here w! <span class="hljs-number"><span class="hljs-number">2</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">"w,"</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set16, b_num2, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : c, here c! <span class="hljs-number"><span class="hljs-number">1</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">"c,"</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set8, b_num1, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : str, dup -rot dup c, here swap move <span class="hljs-number"><span class="hljs-number">1</span></span>+ h +!; item <span class="hljs-string"><span class="hljs-string">"str,"</span></span> c_str: .byte b_dup, b_mrot, b_dup callb c_8 callb here .byte b_swap, b_move callb h .byte b_setp .byte b_exit</code> </pre></div></div><br>  Ahora hagamos que el estado sea variable y dos palabras para controlar su valor: "[" y "]".  Por lo general, estas palabras se utilizan para realizar algo en el momento de la compilaci√≥n.  Por lo tanto, la palabra "[" desactiva el modo de compilaci√≥n y la palabra "]" lo activa.  Pero nada impide que se usen en otros casos cuando es necesario activar o desactivar el modo de compilaci√≥n.  La palabra "[" ser√° nuestra primera palabra con el signo inmediato.  De lo contrario, no podr√° desactivar el modo de compilaci√≥n, ya que se compilar√°, no se ejecutar√°. <br><br><pre> <code class="cpp hljs"> item state .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item <span class="hljs-string"><span class="hljs-string">"]"</span></span> .byte b_num1 callb state .byte b_set, b_exit item <span class="hljs-string"><span class="hljs-string">"["</span></span>, f_immediate .byte b_num0 callb state .byte b_set, b_exit</code> </pre><br>  Lleg√≥ el turno de la palabra $ compilar.  Tomar√° la direcci√≥n de la entrada del diccionario de la pila y compilar√° la palabra especificada.  Para compilar una palabra en implementaciones ordinarias de Fort, es suficiente aplicar la palabra "," a la direcci√≥n de ejecuci√≥n.  Aqu√≠ todo es mucho m√°s complicado.  En primer lugar, hay dos tipos de palabras: c√≥digo de bytes y c√≥digo de m√°quina.  Los primeros se compilan por byte y los segundos por el comando call byte.  Y en segundo lugar, tenemos hasta cuatro variantes del comando de llamada: call8, call16, call32 y call64.  Cuatro?  No!  Cuando escrib√≠ el compilador, ¬°agregu√© 16 m√°s a estos cuatro!  :) <br><br>  ¬øC√≥mo sucedi√≥ esto?  Tenemos que hacer una peque√±a digresi√≥n. <br><br><h4>  Mejorando el comando de llamada </h4><br>  Cuando el compilador comenz√≥ a funcionar, descubr√≠ que en muchos casos (pero no en todos) el comando call8 es suficiente.  Esto es cuando la palabra llamada est√° dentro de 128 bytes.  Pens√©, ¬øy c√≥mo asegurarme de que esto suceda en casi todos los casos?  ¬øC√≥mo poner m√°s de 256 valores en un byte? <br>  El primer punto que not√© fue que en el fuerte la llamada siempre se dirige a direcciones m√°s bajas.  Esto significa que puede rehacer el comando de llamada de tal manera que solo pueda llamar a direcciones inferiores, pero para 256 bytes, no 128. Es mejor. <br><br>  Pero si pones algunos bits en alguna parte ... ¬°Resulta que all√≠ es donde!  Tenemos dos bytes: un byte es el comando, el segundo es el desplazamiento.  Pero nada impide que los bits m√°s bajos del comando coloquen los bits m√°s altos del par√°metro (desplazamiento).  Para una m√°quina de bytes, parece que en lugar de un comando de llamada, hay varios.  S√≠, de esta manera ocupamos varias celdas de la tabla de c√≥digos de byte-command con un comando, pero a veces vale la pena hacerlo.  El comando de llamada es uno de los comandos m√°s utilizados, as√≠ que decid√≠ poner 4 bits de desplazamiento en el comando.  ¬°Por lo tanto, puede hacer una llamada a una distancia de hasta 4095 bytes!  Esto significa que un comando de llamada tan corto se usar√° casi siempre.  Coloqu√© estos comandos con el c√≥digo 0xA0 y las siguientes l√≠neas aparecieron en la tabla de comandos: <br><br><pre> <code class="cpp hljs">.quad bcmd_call8b0, bcmd_call8b1, bcmd_call8b2, bcmd_call8b3, bcmd_call8b4, bcmd_call8b5, bcmd_call8b6, bcmd_call8b7 # <span class="hljs-number"><span class="hljs-number">0xA0</span></span> .quad bcmd_call8b8, bcmd_call8b9, bcmd_call8b10, bcmd_call8b11, bcmd_call8b12, bcmd_call8b13, bcmd_call8b14, bcmd_call8b15</code> </pre> <br>  El primero de estos comandos de bytes simplemente realiza una llamada en la direcci√≥n de las direcciones m√°s bajas en el desplazamiento especificado en el par√°metro (hasta 255).  El resto agrega el desplazamiento correspondiente al par√°metro.  bcmd_call8b1 agrega 256, bcmd_call8b2 agrega 512, y as√≠ sucesivamente.  Hice el primer comando de llamada por separado, el resto con una macro. <br><br>  Primer comando: <br><br><pre> <code class="cpp hljs">b_call8b0 = <span class="hljs-number"><span class="hljs-number">0xA0</span></span> bcmd_call8b0: movzx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 sub r8, rax jmp _next</code> </pre><br>  Macro y creaci√≥n del resto de los comandos de llamada: <br><br><pre> <code class="cpp hljs">.macro call8b N b_call8b\N = <span class="hljs-number"><span class="hljs-number">0xA</span></span>\N bcmd_call8b\N: movzx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 add rax, \N * <span class="hljs-number"><span class="hljs-number">256</span></span> mov [rbp], r8 sub r8, rax jmp _next .endm call8b <span class="hljs-number"><span class="hljs-number">1</span></span> call8b <span class="hljs-number"><span class="hljs-number">2</span></span> call8b <span class="hljs-number"><span class="hljs-number">3</span></span> call8b <span class="hljs-number"><span class="hljs-number">4</span></span> call8b <span class="hljs-number"><span class="hljs-number">5</span></span> call8b <span class="hljs-number"><span class="hljs-number">6</span></span> call8b <span class="hljs-number"><span class="hljs-number">7</span></span> call8b <span class="hljs-number"><span class="hljs-number">8</span></span> call8b <span class="hljs-number"><span class="hljs-number">9</span></span> call8b <span class="hljs-number"><span class="hljs-number">10</span></span> call8b <span class="hljs-number"><span class="hljs-number">11</span></span> call8b <span class="hljs-number"><span class="hljs-number">12</span></span> call8b <span class="hljs-number"><span class="hljs-number">13</span></span> call8b <span class="hljs-number"><span class="hljs-number">14</span></span> call8b <span class="hljs-number"><span class="hljs-number">15</span></span></code> </pre><br>  Bueno, rehice el antiguo comando call8 para llamar hacia adelante, ya que ya tenemos 16 equipos haciendo una devoluci√≥n de llamada.  Cualquiera sea la confusi√≥n, le cambi√© el nombre por b_call8f: <br><br><pre> <code class="cpp hljs">b_call8f = <span class="hljs-number"><span class="hljs-number">0x0C</span></span> bcmd_call8f: movzx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 add r8, rax jmp _next</code> </pre><br>  Por cierto, por conveniencia, hice una macro, que en ensamblador compila autom√°ticamente la llamada correspondiente dentro de 4095. Y luego nunca necesit√© :) <br><br><pre> <code class="cpp hljs">.macro callb adr .<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> \adr &gt; . .error <span class="hljs-string"><span class="hljs-string">"callb do not for forward!"</span></span> .endif .byte b_call8b0 + (. - \adr + <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span> .byte (. - \adr + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span> .endm</code> </pre> <br>  Y ahora ... <br><br><h4>  Equipo de compilaci√≥n </h4><br>  Entonces, obtenemos un algoritmo de compilaci√≥n de comandos bastante complicado.  Si se trata de un comando de byte, compile solo un byte (c√≥digo de comando de byte).  Y si esta palabra ya est√° escrita en bytecode, debe compilar su llamada con el comando de llamada, eligiendo uno de los veinte.  M√°s precisamente 19, por lo que no tenemos desv√≠o de llamadas, y call8f no se utilizar√° para el fuerte. <br><br>  Entonces la elecci√≥n es esta.  Si el desplazamiento se encuentra dentro de 0 ...- 4095, seleccione el comando bcmd_call8b con el c√≥digo 0xA0, colocando los cuatro bits de desplazamiento m√°s significativos en los bits menos significativos del comando.  Al mismo tiempo, para la m√°quina de bytes, el c√≥digo para uno de los comandos bcmd_call8b0 es bcmd_call8b15. <br><br>  Si el desplazamiento hacia atr√°s es mayor o igual a 4095, entonces determinamos en qu√© dimensi√≥n se coloca el desplazamiento y usamos el comando apropiado de call16 / 32/64.  Debe tenerse en cuenta que la compensaci√≥n para estos equipos est√° firmada.  Pueden causar tanto hacia adelante como hacia atr√°s.  Por ejemplo, call16 puede llamar a una distancia de 32767 en ambas direcciones. <br><br>  Aqu√≠ est√° la implementaci√≥n como resultado: <br><br>  <b>$ compilar</b> <br><br>  Compila una palabra.  Como par√°metro, toma la direcci√≥n de la entrada del diccionario de la palabra compilada.  De hecho, comprueba el indicador f_code, calcula la direcci√≥n del c√≥digo (cfa) y llama a compile_b o compile_c (si el indicador est√° configurado). <br><br>  <b>compilar_c</b> <br><br>  Compila un comando de byte.  La palabra m√°s simple aqu√≠ se describe en el fuerte as√≠: <br><br><pre> <code class="cpp hljs">: compile_c c@ c, ;</code> </pre> <br>  <b>compilar_b</b> <br>  Toma una direcci√≥n de bytecode en la pila y compila su llamada. <br><br>  <b>test_bv</b> <br><br>  Toma un desplazamiento de la pila (con un signo) y determina qu√© profundidad de bits usar (1, 2, 4 u 8 bytes).  Devuelve el valor 0, 1, 2 o 3. Con esta palabra, puede determinar cu√°l usar a partir de los comandos call16 / 32/64.  Esta palabra ser√° √∫til al compilar n√∫meros (una opci√≥n de lit8 / 16/32/64). <br><br>  Por cierto, puede iniciar el sistema y "jugar" en la consola fort con cualquiera de estas palabras.  Por ejemplo: <br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; 222 test_bv ( 2 ): 222 1 &gt; drop drop ( 0 ): &gt; 1000000 test_bv ( 2 ): 1000000 2 &gt; drop drop ( 0 ): &gt; -33 test_bv ( 2 ): -33 0 &gt;</code> </pre> <br>  <b>test_bvc</b> <br><br>  Toma un desplazamiento (con un signo) de la pila y determina qu√© comando de llamada usar.  De hecho, verifica si el desplazamiento se encuentra dentro del rango de 0 ... -4095, y devuelve 0. En este caso, si no hay acierto en este intervalo, llama a test_bv. <br><br><div class="spoiler">  <b class="spoiler_title">Eso es todo lo que se necesita para compilar el comando.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : test_bvc dup <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;= over FFF &lt;= <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ... item test_bvc test_bvc: .byte b_dup, b_neg .byte b_num0 .byte b_gteq .byte b_over, b_neg .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">0xFFF</span></span> .byte b_lteq .byte b_and .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_num0 .byte b_exit item test_bv test_bv: .byte b_dup, b_lit8, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, b_gteq, b_over, b_lit8, <span class="hljs-number"><span class="hljs-number">0x7f</span></span>, b_lteq, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - ., b_num0 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">0x8001</span></span> .byte b_gteq .byte b_over .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">0x7ffe</span></span> .byte b_lteq, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - ., b_num1, b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_dup .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80000002</span></span> .byte b_gteq .byte b_over .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x7ffffffd</span></span> .byte b_lteq, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - ., b_num2, b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_num3 .byte b_exit #  - item compile_c compile_c: .byte b_get8 callb c_8 .byte b_exit #   - item compile_b compile_b: callb here .byte b_num2, b_add .byte b_sub callb test_bvc .byte b_dup .byte b_zeq .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_drop .byte b_neg .byte b_dup .byte b_lit8, <span class="hljs-number"><span class="hljs-number">8</span></span> .byte b_rshift .byte b_lit8, b_call8b0 .byte b_or callb c_8 callb c_8 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup, b_num1, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - ., b_drop, b_lit8, b_call16 callb c_8 .byte b_wm callb c_16 .byte b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_num2, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - ., b_lit8, b_call32 callb c_8 .byte b_num3, b_sub callb c_32 .byte b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_lit8, b_call64 callb c_8 .byte b_lit8, <span class="hljs-number"><span class="hljs-number">7</span></span>, b_sub callb c_64 .byte b_exit #: $compile dup c@ <span class="hljs-number"><span class="hljs-number">0x80</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cfa compile_c <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> cfa compile_b then ; item <span class="hljs-string"><span class="hljs-string">"$compile"</span></span> _compile: .byte b_dup, b_get8, b_lit8, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - ., b_cfa callb compile_c .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_cfa callb compile_b .byte b_exit</code> </pre><br></div></div><br>  Ahora necesitamos compilar el n√∫mero. <br><br><h4>  Compilar un n√∫mero (literal) </h4><br>  Escribi√≥ un subt√≠tulo completo, preparado para describir espec√≠ficamente la compilaci√≥n del literal, pero resulta que no hay nada especial para describir :) <br><br>  Ya hemos hecho la mitad del trabajo en la palabra test_bv.  Solo queda llamar a test_bv y, seg√∫n el resultado, compilar lit8 / 16/32/64, y luego el valor correspondiente de 1, 2, 4 u 8 bytes de tama√±o. <br><br><div class="spoiler">  <b class="spoiler_title">Hacemos esto definiendo la palabra compile_n</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#   item compile_n compile_n: callb test_bv .byte b_dup .byte b_zeq .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_drop, b_lit8, b_lit8 callb c_8 callb c_8 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup, b_num1, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - ., b_drop, b_lit8, b_lit16 callb c_8 callb c_16 .byte b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_num2, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - ., b_lit8, b_lit32 callb c_8 callb c_32 .byte b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_lit8, b_lit64 callb c_8 callb c_64 .byte b_exit</code> </pre></div></div><br><h4>  Modificar el int√©rprete </h4><br>  Todo est√° listo para compilar el comando y los literales.  Ahora debe integrarse en el int√©rprete.  Esta modificaci√≥n es simple.  Donde se ejecut√≥ el comando, agregue la comprobaci√≥n de estado.  Si el estado no es nulo y la palabra no contiene el indicador inmediato, en lugar de la ejecuci√≥n, debe llamar a $ compile.  Y casi lo mismo que hacer cuando el n√∫mero se obtiene de la secuencia de entrada.  Si el estado es cero, simplemente deje el n√∫mero en la pila y, si no, llame a compile_n. <br><br><div class="spoiler">  <b class="spoiler_title">Aqu√≠ esta el int√©rprete</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_over .byte b_over .byte b_find .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_mrot .byte b_drop .byte b_drop callb state .byte b_get .byte b_qnbranch8, irpt_execute - . #  <span class="hljs-number"><span class="hljs-number">0</span></span>,    .byte b_dup, b_get8, b_lit8, f_immediate, b_and #  immediate    .byte b_qbranch8, irpt_execute - . #    -   #   ! callb _compile .byte b_branch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . irpt_execute: .byte b_cfa #  ,    (state = <span class="hljs-number"><span class="hljs-number">0</span></span>  immediate  ) .byte b_execute .byte b_branch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_drop .byte b_over, b_over .byte b_numberq # ,    .byte b_qbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - . #     <span class="hljs-number"><span class="hljs-number">0</span></span>, ,      <span class="hljs-number"><span class="hljs-number">3</span></span> .byte b_type #    .byte b_strp #   .byte <span class="hljs-number"><span class="hljs-number">19</span></span> #     .ascii <span class="hljs-string"><span class="hljs-string">" : word not found!\n"</span></span> .byte b_quit #    <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_nip, b_nip #  ,     ( b_over, b_over) #   -   callb state # ,    .byte b_get .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . #   -     ;   -   #   callb compile_n <span class="hljs-number"><span class="hljs-number">2</span></span>: #       .byte b_depth #    .byte b_zlt # ,   <span class="hljs-number"><span class="hljs-number">0</span></span> ( <span class="hljs-number"><span class="hljs-number">0</span></span>&lt;) .byte b_qnbranch8, interpret_ok - . #   ,    ,   .byte b_strp #    .byte <span class="hljs-number"><span class="hljs-number">14</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\nstack fault!\n"</span></span> .byte b_quit #    interpret_ok: .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre></div></div><br>  Ahora estamos a un paso del compilador ... <br><br><h4>  Definici√≥n de nuevas palabras (palabra ":") </h4><br>  Ahora, si establecemos la variable de estado en un valor distinto de cero, comenzar√° el proceso de compilaci√≥n.  Pero el resultado ser√° in√∫til, no podemos cumplirlo ni encontrarlo en la memoria.  Para hacer posible todo esto, es necesario formatear el resultado de la compilaci√≥n en forma de art√≠culo de diccionario.  Para hacer esto, antes de activar el modo de compilaci√≥n, debe crear un t√≠tulo para la palabra. <br><br>  El encabezado debe contener banderas, un campo de comunicaci√≥n y un nombre.  Aqu√≠ tenemos una historia familiar: el campo de comunicaci√≥n puede ser de 1, 2, 4 u 8 bytes.  Hagamos la palabra compile_1248, que nos ayudar√° a formar dicho campo de comunicaci√≥n.  Tomar√° dos n√∫meros en la pila: el desplazamiento y el valor generado por el comando test_bv. <br><br><div class="spoiler">  <b class="spoiler_title">compilar_1248</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#    , ,     #     ,  test_dv item compile_1248 compile_1248: .byte b_dup .byte b_zeq .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_drop callb c_8 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup, b_num1, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . .byte b_drop callb c_16 .byte b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_num2, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - . callb c_32 .byte b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: callb c_64 .byte b_exit</code> </pre></div></div><br>  Ahora haga la palabra $ crear.  Nos ser√° √∫til m√°s de una vez.  Puede usarlo siempre que necesite crear un t√≠tulo para una entrada de diccionario.  Tomar√° dos valores de la pila: la direcci√≥n del nombre de la palabra creada y su longitud.  Despu√©s de ejecutar esta palabra, la direcci√≥n de la entrada del diccionario creada aparecer√° en la pila. <br><br><div class="spoiler">  <b class="spoiler_title">$ crear</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : $create here current @ @ here - test_bv dup c, compile_1248 -rot str, current @ ! <span class="hljs-string"><span class="hljs-string">' var0 here c!; item "$create" create: callb here callb current .byte b_get, b_get callb here .byte b_sub callb test_bv .byte b_dup callb c_8 callb compile_1248 .byte b_mrot callb c_str #       callb current .byte b_get, b_set #     - var0,      here #   ,    -    ,    #     ,     #    1 allot   ,   .byte b_lit8, b_var0 callb here .byte b_set8 .byte b_exit</span></span></code> </pre> </div></div><br>  La siguiente palabra recoger√° el nombre de la nueva palabra de la secuencia de entrada usando la palabra blword y llamar√° a $ create, creando una nueva palabra con el nombre especificado. <br><br><div class="spoiler">  <b class="spoiler_title">create_in</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> item <span class="hljs-string"><span class="hljs-string">"create_in"</span></span> create_in: .byte b_blword .byte b_dup .byte b_qbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_strp #   (     ) .byte <span class="hljs-number"><span class="hljs-number">3f</span></span> - <span class="hljs-number"><span class="hljs-number">2f</span></span> #     <span class="hljs-number"><span class="hljs-number">2</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\ncreate_in - name not found!\n"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">1</span></span>: callb create .byte b_exit</code> </pre></div></div><br>  Y finalmente, haga la palabra ":".  Crear√° una nueva palabra usando create_in y establecer√° el modo de compilaci√≥n, no est√° instalado.  Y si est√° instalado, da un error.  La palabra ":" tendr√° el signo inmediato. <br><br><div class="spoiler">  <b class="spoiler_title">la palabra</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : : create_in <span class="hljs-number"><span class="hljs-number">1</span></span> state dup @ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .<span class="hljs-string"><span class="hljs-string">" : - no execute state!"</span></span> then ! <span class="hljs-number"><span class="hljs-number">110</span></span> ; immediate item <span class="hljs-string"><span class="hljs-string">":"</span></span>, f_immediate colon: callb create_in .byte b_num1 callb state .byte b_dup .byte b_get .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . .byte b_strp #   (     ) .byte <span class="hljs-number"><span class="hljs-number">4f</span></span> - <span class="hljs-number"><span class="hljs-number">3f</span></span> #     <span class="hljs-number"><span class="hljs-number">3</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\n: - no execute state!\n"</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_set .byte b_lit8, <span class="hljs-number"><span class="hljs-number">110</span></span> .byte b_exit</code> </pre></div></div><br>  Si alguien mir√≥ el c√≥digo, vio que esta palabra hace otra cosa :) <br><br>  ¬øY aqu√≠ hay 110 ??? <br><br>  S√≠, esta palabra tambi√©n empuja el n√∫mero 110 a la pila, y es por eso.  Cuando se compila, las diversas construcciones deben ser un todo √∫nico.  Por ejemplo, despu√©s de si debe ser entonces.  Y la palabra creada usando ":" debe terminar con ";".  Para verificar estas condiciones, palabras especiales del compilador ponen ciertos valores en la pila y verifican su presencia.  Por ejemplo, la palabra ":" pone el valor 110 y la palabra ";"  comprueba que 110 est√° en la parte superior de la pila. Si este no es el caso, entonces es un error.  Entonces, las estructuras de control no estaban emparejadas. <br><br>  Tal verificaci√≥n se lleva a cabo en todas las palabras del compilador, por lo tanto, haremos una palabra especial para esto: "? Pares".  Tomar√° dos valores de la pila y arrojar√° un error si no son iguales. <br><br>  Adem√°s, en tales palabras, a menudo tiene que verificar que el modo de compilaci√≥n est√© configurado.  Hagamos la palabra "? Estado" para esto. <br><br><div class="spoiler">  <b class="spoiler_title">estado de "pares"</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#: ?pairs = ifnot <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> then .<span class="hljs-string"><span class="hljs-string">" \nerror: no pairs operators"</span></span> quit then ; item <span class="hljs-string"><span class="hljs-string">"?pairs"</span></span> .byte b_eq, b_qbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">3f</span></span> - <span class="hljs-number"><span class="hljs-number">2f</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\nerror: no pairs operators"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_exit #: ?state state @ <span class="hljs-number"><span class="hljs-number">0</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abort</span></span><span class="hljs-string"><span class="hljs-string">" error: no compile state"</span></span> then ; item <span class="hljs-string"><span class="hljs-string">"?state"</span></span> callb state .byte b_get, b_zeq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">3f</span></span> - <span class="hljs-number"><span class="hljs-number">2f</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\nerror: no compile state"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_exit</code> </pre></div></div><br>  Eso es todo!  No compilaremos nada m√°s en ensamblador manualmente :) <br><br>  Pero hasta el final, el compilador a√∫n no se ha escrito, por lo que al principio tendr√° que usar algunos m√©todos inusuales ... <br><br><h4>  Prepar√©monos para compilar el compilador creado con el compilador creado. </h4><br>  Para comenzar, puede verificar c√≥mo funciona la palabra ":" compilando algo simple.  Hagamos, por ejemplo, la palabra: <br><br><pre> <code class="cpp hljs">: ^<span class="hljs-number"><span class="hljs-number">2</span></span> dup * ;</code> </pre> <br>  Esta palabra es cuadrada.  Pero no tenemos la palabra ";" ¬øqu√© hacer?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En su lugar, escribimos la palabra salir, y se compila. </font><font style="vertical-align: inherit;">Y luego apague el modo de compilaci√≥n con la palabra "[" y suelte el valor 110:</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : ^2 dup * exit [ drop ( 0 ): &gt; 4 ^2 ( 1 ): 16 &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funciona! </font><font style="vertical-align: inherit;">Continuemos </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que continuaremos escribiendo el fuerte en el fuerte, tenemos que pensar d√≥nde estar√° el c√≥digo fuente del fuerte y cu√°ndo compilarlo. </font><font style="vertical-align: inherit;">Hagamos la opci√≥n m√°s f√°cil. </font><font style="vertical-align: inherit;">El c√≥digo fuente de la fortaleza se colocar√° en el c√≥digo fuente en ensamblador, como una cadena de texto. </font><font style="vertical-align: inherit;">Y para que no ocupe demasiado espacio, lo colocaremos inmediatamente despu√©s de la direcci√≥n aqu√≠, en el √°rea de memoria libre. </font><font style="vertical-align: inherit;">Por supuesto, necesitamos esta √°rea para la compilaci√≥n, pero la velocidad de "fuga" de la interpretaci√≥n ser√° mayor que la necesidad de una nueva memoria. </font><font style="vertical-align: inherit;">Por lo tanto, el c√≥digo compilado comenzar√° a sobrescribir la fuente en el fuerte, comenzando desde el principio, pero ya no lo necesitaremos, ya que ya hemos le√≠do y usado esta secci√≥n.</font></font><br><br><pre> <code class="cpp hljs">fcode: .ascii <span class="hljs-string"><span class="hljs-string">" 2 2 + . quit"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero, al comienzo de la l√≠nea, vale la pena colocar una docena de espacios. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que esto funcione, cambiamos el bytecode de inicio para que tib, #tib apunte a esta l√≠nea. </font><font style="vertical-align: inherit;">Al final hay que salir para ingresar a la l√≠nea de comando normal del sistema.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comenzar bytecode se ha convertido as√≠</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">start: .byte b_call16 .word forth - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word last_item - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word context - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_get .byte b_set .byte b_call16 .word vhere - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_dup .byte b_call16 .word h - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_call16 .word definitions - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word tib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_lit16 .word fcode_end - fcode .byte b_call16 .word ntib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_call16 .word interpret - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_quit</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lanzamiento </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth 4 ( 0 ): &gt;</code> </pre><br>  Genial <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y ahora ... </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compila el compilador con el compilador </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego, escribimos el c√≥digo en la l√≠nea fcode. </font><font style="vertical-align: inherit;">Lo primero que debe hacer, por supuesto, es la palabra ";".</font></font><br><br><pre> <code class="cpp hljs">: ; ?state <span class="hljs-number"><span class="hljs-number">110</span></span> ?pairs lit8 [ blword <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> find cfa c@ c, ] c, <span class="hljs-number"><span class="hljs-number">0</span></span> state ! <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> [ current @ @ dup c@ <span class="hljs-number"><span class="hljs-number">96</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> swap c! drop</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Har√© algunas explicaciones. </font></font><br><br><pre> <code class="plaintext hljs">?state 110 ?pairs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqu√≠ comprobamos que el estado de compilaci√≥n est√° realmente configurado y que 110 est√° en la pila, de lo contrario, habr√° una interrupci√≥n por error. </font></font><br><br><pre> <code class="plaintext hljs">lit8 [ blword exit find cfa c@ c, ]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto compilamos el comando iluminado con el bytecode del comando de salida. </font><font style="vertical-align: inherit;">Tuve que pasar al modo de ejecuci√≥n, encontrar la palabra salir, obtener la direcci√≥n de ejecuci√≥n y obtener el c√≥digo de comando desde all√≠. </font><font style="vertical-align: inherit;">Todo esto fue necesario porque todav√≠a no tenemos la palabra compilar. </font><font style="vertical-align: inherit;">Si lo fuera, en lugar de todo esto, ser√≠a suficiente simplemente escribir "compilar salir" :)</font></font><br><br><pre> <code class="plaintext hljs">c, 0 state !</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto compilar√° el comando de salida cuando se ejecute la palabra ";", y luego se establecer√° el modo de interpretaci√≥n. </font><font style="vertical-align: inherit;">La palabra "[" no se puede usar aqu√≠, ya que tiene el signo inmediato y se ejecuta </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ahora</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero necesitamos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compilar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dichos comandos en la palabra ";" para que apaguen el modo de compilaci√≥n.</font></font><br><br><pre> <code class="plaintext hljs">exit [</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya hemos experimentado esto. </font><font style="vertical-align: inherit;">La palabra salir se compila y el modo de compilaci√≥n se desactiva. </font><font style="vertical-align: inherit;">Todo, la palabra ";" </font><font style="vertical-align: inherit;">compilado </font><font style="vertical-align: inherit;">¬øY qu√© m√°s se escribe all√≠ m√°s?</font></font><br><br><pre> <code class="plaintext hljs">current @ @ dup c@ 96 or swap c! drop</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debe establecer la bandera inmediata para la nueva palabra. </font><font style="vertical-align: inherit;">Esto es exactamente lo que hace la secuencia indicada, excepto la ca√≠da de palabras. </font><font style="vertical-align: inherit;">La ca√≠da de palabras elimina el 110 olvidado que coloc√≥ la palabra ":" al comienzo de la creaci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Ahora es todo! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lanzamos e intentamos.</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : ^3 dup dup * * ; ( 0 ): &gt; 6 ^3 . 216 ( 0 ): &gt;</code> </pre><br>  Hay!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta es la primera palabra que nuestro compilador compil√≥ "de verdad". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero todav√≠a no tenemos condiciones, ni bucles, y mucho m√°s ... Comencemos con una palabra peque√±a pero muy necesaria para crear un compilador: inmediato. </font><font style="vertical-align: inherit;">Establece el atributo inmediato en la √∫ltima palabra creada:</font></font><br><br><pre> <code class="cpp hljs">: immediate current @ @ dup c@ <span class="hljs-number"><span class="hljs-number">96</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> swap c! ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una secuencia familiar :) Recientemente, se escribi√≥ manualmente, ya no ser√° necesario. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora hagamos algunas palabras peque√±as pero √∫tiles:</font></font><br><br><pre> <code class="cpp hljs">: hex <span class="hljs-number"><span class="hljs-number">16</span></span> base ! ; : decimal <span class="hljs-number"><span class="hljs-number">10</span></span> base ! ; : bl <span class="hljs-number"><span class="hljs-number">32</span></span> ; : tab <span class="hljs-number"><span class="hljs-number">9</span></span> ; : lf <span class="hljs-number"><span class="hljs-number">10</span></span> ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hexadecimal y decimal establecen el sistema num√©rico correspondiente. </font><font style="vertical-align: inherit;">El resto son constantes para obtener los c√≥digos de caracteres correspondientes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n hacemos una palabra para copiar una l√≠nea con un contador </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:: cmove sobre c @ 1+ move; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y ahora estaremos comprometidos en las condiciones. </font><font style="vertical-align: inherit;">En general, si hubiera una palabra compilar, se ver√≠a as√≠:</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ?state compile ?nbranch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate : then ?state <span class="hljs-number"><span class="hljs-number">111</span></span> ?pairs dup here swap - swap c! ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas estas palabras al principio verifican que el modo de compilaci√≥n est√© configurado y generan un error si este no es el caso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La palabra if compila una rama condicional, reserva un byte para el par√°metro del comando de rama condicional y empuja la direcci√≥n de ese byte a la pila. Luego empuja el valor de control 111 sobre la pila. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La palabra luego verifica la presencia del valor de control 111, y luego escribe el desplazamiento en la direcci√≥n en la pila.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E inmediatamente haga la palabra m√°s. </font><font style="vertical-align: inherit;">Al principio, compila el comando de salto incondicional para omitir la rama else. </font><font style="vertical-align: inherit;">De la misma manera que si, el desplazamiento de transici√≥n a√∫n no se conoce, simplemente se reserva y su direcci√≥n se inserta en la pila. </font><font style="vertical-align: inherit;">Bueno, despu√©s de eso, se hace exactamente lo mismo que en ese momento: la direcci√≥n de la transici√≥n de captura se establece en la rama else. </font><font style="vertical-align: inherit;">Algo es m√°s dif√≠cil de describir que el c√≥digo en s√≠ :) Si alguien quiere resolverlo a fondo, es mejor analizar el trabajo de un c√≥digo tan simplificado al m√°ximo:</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> compile ?nbranch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, ; immediate : then dup here swap - swap c! ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bueno, ahora programamos el c√≥digo real. </font><font style="vertical-align: inherit;">Como no tenemos la palabra compilar, aplicamos el mismo truco que cuando creamos la palabra ";":</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ?state lit8 [ blword ?nbranch8 find cfa c@ c, ] c, here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate : then ?state <span class="hljs-number"><span class="hljs-number">111</span></span> ?pairs dup here swap - swap c! ; immediate : <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ?state <span class="hljs-number"><span class="hljs-number">111</span></span> ?pairs lit8 [ blword branch8 find cfa c@ c, ] c, here <span class="hljs-number"><span class="hljs-number">0</span></span> c, swap dup here swap - swap c! <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora puede intentar compilar la condici√≥n. </font><font style="vertical-align: inherit;">Hagamos, por ejemplo, una palabra que imprima 1000 si hay 5 en la pila y 0 en otros casos:</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : test 5 = if 1000 . else 0 . then ; ( 0 ): &gt; 22 test 0 ( 0 ): &gt; 3 test 0 ( 0 ): &gt; 5 test 1000 ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Est√° claro que tal resultado no funcion√≥ de inmediato, hubo errores, hubo depuraci√≥n. </font><font style="vertical-align: inherit;">Pero al final, ¬°las condiciones funcionaron!</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una peque√±a digresi√≥n sobre la longitud de los comandos de transici√≥n</font></font></b> <div class="spoiler_text">  ,       ,      127 .       . ,  ,       .     ,   ,        .   8   ,    40  127    .   ,       ? <br><br>   .   ‚Äî    16 . <br><br>      . 16        ‚Äî    . ,      ,     call,      . , 11     ( 1023   ).         300  1000  .      ,        .      3  ,     8    .    :   (?nbranch),    (?branch)   (branch).  ‚Äî 24 . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenemos condiciones, la vida se vuelve m√°s f√°cil :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hagamos una palabra. "(Comillas). Muestra el texto especificado cuando se ejecuta. Se utiliza de esta manera:</font></font><br><br><pre> <code class="cpp hljs">.<span class="hljs-string"><span class="hljs-string">"    "</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede usar esta palabra solo en modo de compilaci√≥n. </font><font style="vertical-align: inherit;">Esto se har√° evidente despu√©s de analizar el dispositivo de esta palabra:</font></font><br><br><pre> <code class="cpp hljs">: .<span class="hljs-string"><span class="hljs-string">" ?state 34 word dup if lit8 [ blword (."</span></span>) find cfa c@ c, ] c, str, <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drop then ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta palabra se ejecuta en modo de compilaci√≥n. Toma una cadena desde la secuencia de entrada hasta comillas (34 palabras). Si no se pudo obtener la fila, no hace nada. Aunque, aqu√≠ ser√≠a mejor derivar un diagn√≥stico. Pero para la salida de la l√≠nea, esta palabra es exactamente lo que estamos haciendo :) Si es necesario, puede redefinir esta palabra nuevamente, ya con diagn√≥sticos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si fue posible obtener la cadena, se compila el comando de byte (. ") Y luego se recibe la cadena. Este comando de byte (comillas de puntos entre par√©ntesis), cuando se ejecuta, muestra la cadena que se compil√≥ detr√°s del byte de comando. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verificar.</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : test ."    " ; ( 0 ): &gt; test     ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y finalmente, hagamos que la palabra se compile. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Est√° claro que en el modo de compilaci√≥n esta palabra debe tomar el nombre de la siguiente palabra de la transmisi√≥n, encu√©ntrela en el diccionario. Y luego habr√° opciones: puede ser un comando de byte, o puede ser una palabra escrita en c√≥digo de byte. Estas palabras deben compilarse de diferentes maneras. Por lo tanto, crearemos dos palabras auxiliares: "(compile_b)" y "(compile_c)". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(compile_b) compilar√° el comando de llamada para invocar el bytecode. El par√°metro ser√° una palabra de 64 bits: la direcci√≥n del bytecode que se llama. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(compile_c) compilar√° el comando byte. En consecuencia, el par√°metro de este comando ser√° un byte: el c√≥digo del comando. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bueno, la palabra compilar en s√≠ compilar√° (compile_b) o (compile_c) con los par√°metros correspondientes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos con (compile_c),como con el m√°s simple:</font></font><br><br><pre> <code class="cpp hljs">: (compile_c) r&gt; dup c@ swap <span class="hljs-number"><span class="hljs-number">1</span></span>+ &gt;rc, ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pesar de su simplicidad, primero escribimos una palabra en bytecode, que en s√≠ misma tiene par√°metros. Por lo tanto, comentar√©. Despu√©s de ingresar (compile_c), la direcci√≥n de retorno se encuentra en la pila de retorno, ya que no es trillada. Esta es la direcci√≥n del siguiente byte despu√©s del comando de llamada. La situaci√≥n en el momento de la llamada se muestra a continuaci√≥n. A0 - c√≥digo de comando de llamada, XX - par√°metro de comando de llamada - direcci√≥n de llamada (desplazamiento) del c√≥digo de byte de la palabra (compile_c).</font></font><br><br><img src="https://habrastorage.org/webt/vj/jh/kh/vjjhkhqa7e35ygxdzclv0lf4-pw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La direcci√≥n de retorno indica el byte NN. Por lo general, existe el c√≥digo para el siguiente byte del comando. Pero nuestra palabra tiene par√°metros, por lo que NN son solo los par√°metros de la palabra "(compile_c)", es decir, el c√≥digo de bytes del comando compilado. Debe leer este byte y cambiar la direcci√≥n de retorno movi√©ndolo al siguiente comando de byte. Esto se realiza mediante la secuencia "r&gt; dup c @ swap 1+&gt; r". Esta secuencia extrae la direcci√≥n de retorno de la pila de retorno a la pila normal, recupera un byte, le agrega uno (direcci√≥n de retorno) y la devuelve a la pila de retorno. El comando restante "c" compila el c√≥digo de comando de byte obtenido de los par√°metros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(compile_b) no es mucho m√°s complicado:</font></font><br><br><pre> <code class="cpp hljs">: (compile_b) r&gt; dup @ swap <span class="hljs-number"><span class="hljs-number">8</span></span> + &gt;r compile_b ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ todo es igual, solo se lee el par√°metro de 64 bits y la palabra compile_b se usa para compilar la palabra, que ya hemos creado para el compilador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y ahora la palabra compilar. </font><font style="vertical-align: inherit;">Como ya se discuti√≥, lee el nombre de la palabra, la encuentra y compila uno de los dos comandos anteriores. </font><font style="vertical-align: inherit;">No voy a comentarlo, ya hemos aplicado y desmontado todas las construcciones utilizadas.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Word compila</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">: compile blword over over find dup <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dup c@ <span class="hljs-number"><span class="hljs-number">128</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cfa c@ (compile_b) [ blword (compile_c) find cfa , ] c, <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> cfa (compile_b) [ blword (compile_b) find cfa , ] , then drop drop <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drop .<span class="hljs-string"><span class="hljs-string">" compile: "</span></span> type .<span class="hljs-string"><span class="hljs-string">" - not found"</span></span> then ; immediate</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para verificar la palabra creada, hacemos, con su ayuda, la palabra ifnot. </font></font><br><br><pre> <code class="cpp hljs">: ifnot ?state compile ?branch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬°Compru√©balo! </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : test 5 = ifnot 1000 . else 0 . then ; ( 0 ): &gt; 22 test 1000 ( 0 ): &gt; 3 test 1000 ( 0 ): &gt; 5 test 0 ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo esta bien! Y es hora de hacer ciclos ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este art√≠culo haremos ciclos con una condici√≥n. El fuerte tiene dos opciones para un ciclo con una condici√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La primera opci√≥n es comenzar ... hasta. La palabra hasta elimina el valor de la pila, y si no es igual a cero, el ciclo termina. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La segunda opci√≥n es comenzar ... mientras ... repetir. En este caso, la comprobaci√≥n se produce cuando se ejecuta la palabra mientras se ejecuta. El ciclo sale si el valor en la pila es cero. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los ciclos en el fuerte se hacen de la misma manera que las condiciones: en transiciones condicionales e incondicionales. Traigo el c√≥digo, los comentarios, creo, no son necesarios.</font></font><br><br><pre> <code class="cpp hljs">: begin ?state here <span class="hljs-number"><span class="hljs-number">112</span></span> ; immediate : until ?state <span class="hljs-number"><span class="hljs-number">112</span></span> ?pairs compile ?nbranch8 here - c, ; immediate : <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ?state <span class="hljs-number"><span class="hljs-number">112</span></span> ?pairs compile ?nbranch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">113</span></span> ; immediate : repeat ?state <span class="hljs-number"><span class="hljs-number">113</span></span> ?pairs swap compile branch8 here - c, dup here swap - swap c! ; immediate</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hoy hemos terminado con el compilador. </font><font style="vertical-align: inherit;">Queda muy poco. </font><font style="vertical-align: inherit;">De las funciones clave que a√∫n no se han implementado son solo ciclos con un contador. </font><font style="vertical-align: inherit;">Y tambi√©n vale la pena hacer que salga el comando del bucle de salida. </font><font style="vertical-align: inherit;">Lo haremos la pr√≥xima vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Pero no experimentamos el comando del ciclo! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hacemos esto escribiendo las palabras de palabras est√°ndar. </font><font style="vertical-align: inherit;">Finalmente debemos ver nuestro diccionario. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para hacer esto, al principio, hacemos la palabra enlace @. </font><font style="vertical-align: inherit;">Extraer√° el campo de comunicaci√≥n de la entrada del diccionario (desplazado a la entrada anterior). </font><font style="vertical-align: inherit;">Como recordamos, el campo de comunicaci√≥n puede tener un tama√±o diferente: 1, 2, 4 u 8 bytes. </font><font style="vertical-align: inherit;">Esta palabra tomar√° en la pila la direcci√≥n de la entrada del diccionario y devolver√° dos valores: la direcci√≥n del campo de nombre y el valor del campo de comunicaci√≥n.</font></font><br><br><pre> <code class="cpp hljs">: link@ dup c@ <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> swap <span class="hljs-number"><span class="hljs-number">1</span></span>+ swap dup <span class="hljs-number"><span class="hljs-number">0</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop dup <span class="hljs-number"><span class="hljs-number">1</span></span>+ swap c@ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> dup <span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop dup <span class="hljs-number"><span class="hljs-number">2</span></span> + swap w@ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop dup <span class="hljs-number"><span class="hljs-number">4</span></span> + swap i@ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drop dup <span class="hljs-number"><span class="hljs-number">8</span></span> + swap @ then then then ;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y ahora puedes hacer la palabra palabras: </font></font><br><br><pre> <code class="cpp hljs">: words context @ @ <span class="hljs-number"><span class="hljs-number">0</span></span> begin + dup link@ swap count type tab emit dup <span class="hljs-number"><span class="hljs-number">0</span></span>= until drop drop ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lanzando ... </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; words words link@ repeat while until begin ifnot compile (compile_b) (compile_c) ." else then if cmove tab bl decimal hex immediate ; bye ?state ?pairs : str, interpret $compile compile_b compile_n compile_1248 compile_c c, w, i, , allot here h test_bv test_bvc [ ] state .s &gt;in #tib tib . #&gt; #s 60 # hold span holdpoint holdbuf base quit execute cfa find word blword var16 var8 (.") (") count emit expect type lshift rshift invert xor or and &gt;= &lt;= &gt; &lt; = 0&gt; 0&lt; 0= bfind compare syscall fill move rpick r@ r&gt; &gt;r -! +! i! i@ w! w@ c! c@ ! @ depth roll pick over -rot rot swap drop dup abs /mod mod / * - + 1+ 1- exit ?nbranch16 ?nbranch8 ?branch16 ?branch8 branch16 branch8 call8b0 call64 call32 call16 call8f lit64 lit32 lit16 lit8 8 4 3 2 1 0 context definitions current forth ( 0 ): &gt;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ est√°, nuestra riqueza :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quer√≠a decir todo ... no, sin embargo, hagamos posible especificar un archivo con un programa fort para compilaci√≥n y ejecuci√≥n como par√°metro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hacemos comandos syscall para abrir, cerrar y leer el archivo. </font><font style="vertical-align: inherit;">Definimos las constantes necesarias para ellos.</font></font><br><br><pre> <code class="cpp hljs">: file_open <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> syscall ; : file_close <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> syscall ; : file_read <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> syscall ; : file_O_RDONLY <span class="hljs-number"><span class="hljs-number">0</span></span> ; : file_O_WRONLY <span class="hljs-number"><span class="hljs-number">1</span></span> ; : file_O_RDWR <span class="hljs-number"><span class="hljs-number">3</span></span> ;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora puede hacer que la palabra de inicio _start: </font></font><br><br><pre> <code class="cpp hljs">: _start <span class="hljs-number"><span class="hljs-number">0</span></span> pick <span class="hljs-number"><span class="hljs-number">1</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> pick file_O_RDONLY <span class="hljs-number"><span class="hljs-number">0</span></span> file_open dup <span class="hljs-number"><span class="hljs-number">0</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .\<span class="hljs-string"><span class="hljs-string">" error: \" . quit then dup here 32 + 32768 file_read dup 0&lt; if .\" error: \" . quit then swap file_close drop #tib ! here 32 + tib ! 0 &gt;in ! interpret then ;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta palabra se cargar√° desde el archivo y ejecutar√° cualquier programa fort. </font><font style="vertical-align: inherit;">M√°s precisamente, el int√©rprete ejecutar√° todo lo que estar√° en este archivo. </font><font style="vertical-align: inherit;">Y puede haber, por ejemplo, una compilaci√≥n de nuevas palabras y su ejecuci√≥n. </font><font style="vertical-align: inherit;">El nombre del archivo se indica mediante el primer par√°metro al inicio. </font><font style="vertical-align: inherit;">No entrar√© en detalles, pero los par√°metros de lanzamiento en Linux se pasan a trav√©s de la pila. </font><font style="vertical-align: inherit;">La palabra _start los alcanzar√° con los comandos 0 pick (n√∫mero de par√°metros) y 2 pick (puntero al primer par√°metro). </font><font style="vertical-align: inherit;">Para un sistema fort, estos valores se encuentran fuera de la pila, pero puede obtenerlos con el comando pick. </font><font style="vertical-align: inherit;">El tama√±o del archivo est√° limitado a 32 KB, mientras que no hay administraci√≥n de memoria. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora queda escribir en la l√≠nea fcode al final:</font></font><br><br><pre> <code class="cpp hljs">_start quit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crea un archivo test.f y escribe algo all√≠ en el fuerte. </font><font style="vertical-align: inherit;">Por ejemplo, el algoritmo euclidiano para encontrar el mayor factor com√∫n:</font></font><br><br><pre> <code class="cpp hljs">: NOD begin over over &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> over over &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> swap over - swap <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> over - then repeat drop ; <span class="hljs-number"><span class="hljs-number">23101</span></span> <span class="hljs-number"><span class="hljs-number">44425</span></span> NOD . bye</code> </pre><br>  Empezamos <br><br><pre> <code class="plaintext hljs">$ ./forth test.f 1777 Bye! $</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La respuesta es correcta </font><font style="vertical-align: inherit;">La palabra fue compilada, luego cumplida. </font><font style="vertical-align: inherit;">Se muestra el resultado, luego se ejecut√≥ el comando bye. </font><font style="vertical-align: inherit;">Si elimina las dos √∫ltimas l√≠neas, la palabra NOD se agregar√° al diccionario y el sistema ir√° a su l√≠nea de comando. </font><font style="vertical-align: inherit;">Ya puedes escribir programas :-)</font></font><br><br>  Eso es todo.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A qui√©n le importa, puede descargar la fuente o el binario listo para Linux en x86-64 desde Github: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/hal9000cc/forth64</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Las fuentes vienen con una licencia </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNU GPL v2</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCH v1 - Haga lo que quiera :-)</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437466/">https://habr.com/ru/post/437466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437454/index.html">Arithmometer Felix M revisi√≥n</a></li>
<li><a href="../437456/index.html">M√°s joven: revisi√≥n de los tel√©fonos IP Snom D315 y D305</a></li>
<li><a href="../437458/index.html">Registro obligatorio por IMEI oferta para hacer pago</a></li>
<li><a href="../437460/index.html">Ejemplo de unidad flash falsa de 32 GB</a></li>
<li><a href="../437464/index.html">Precio de TypeScript</a></li>
<li><a href="../437468/index.html">Retropie Dreamcast</a></li>
<li><a href="../437470/index.html">Algunas palabras simples sobre defensa antimisiles</a></li>
<li><a href="../437472/index.html">Transici√≥n de la oficina a udalenka: compartir experiencias y trucos para la vida</a></li>
<li><a href="../437474/index.html">Optimice el rendimiento del juego con las opciones de importaci√≥n de sonido de Unity</a></li>
<li><a href="../437476/index.html">Ok Yandex! ¬øD√≥nde est√°n nuestros objetivos de alcance?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>