<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐 🔒 📈 Tres paradigmas de programación asincrónica en Vertx 🌆 👨🏾‍🚀 🌯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quiero mostrar tres paradigmas de programación asincrónica: devoluciones de llamada, futuros, rutinas en el ejemplo de una aplicación web simple en el...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tres paradigmas de programación asincrónica en Vertx</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449092/"> Quiero mostrar tres paradigmas de programación asincrónica: devoluciones de llamada, futuros, rutinas en el ejemplo de una aplicación web simple en el marco Vertx.  Escribiremos el código en Kotlin. <br><br>  Supongamos que tenemos una aplicación que recibe una determinada cadena en una solicitud HTTP, busca una URL en la base de datos que la usa, va a esa URL y envía su contenido al cliente. <br>  Vertx está concebido como un marco asincrónico para aplicaciones altamente cargadas, utiliza un nuevo y pequeño bus de eventos IO <br><br><a name="habracut"></a>  Como es habitual en Vertx, un Verticle (un análogo del actor, si conoce a Akka) recibe una solicitud, envía una cadena de bus de eventos para buscar la URL de algún otro BusinessVerticle, que realmente se dedica al trabajo. <br><br><pre><code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Main { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vertx = Vertx.vertx() vertx.deployVerticle(HttpVerticle()) vertx.deployVerticle(BusinessVerticle()) } }</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpVerticle</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AbstractVerticle</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Throws(Exception::class)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(startFuture: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Future</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Void</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> router = createRouter() vertx.createHttpServer() .requestHandler(router) .listen(<span class="hljs-number"><span class="hljs-number">8080</span></span>) { result -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.succeeded()) { startFuture.complete() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { startFuture.fail(result.cause()) } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createRouter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Router = Router.router(vertx).apply { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"/"</span></span>).handler(handlerRoot) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> handlerRoot = Handler&lt;RoutingContext&gt; { rc -&gt; vertx.eventBus().send(<span class="hljs-string"><span class="hljs-string">"my.addr"</span></span>, rc.request().getParam(<span class="hljs-string"><span class="hljs-string">"id"</span></span>) ?: <span class="hljs-string"><span class="hljs-string">""</span></span>) { resp: AsyncResult&lt;Message&lt;String&gt;&gt; -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resp.succeeded()) { rc.response().end(resp.result().body()) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rc.fail(<span class="hljs-number"><span class="hljs-number">500</span></span>) } } } }</code> </pre><br>  En la API estándar, toda la asincronía se realiza a través de las devoluciones de llamada, por lo que la implementación inicial de BusinessVerticle se verá así: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BusinessVerticle</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AbstractVerticle</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dbclient: JDBCClient <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> webclient: WebClient <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { vertx.eventBus().consumer&lt;String&gt;(<span class="hljs-string"><span class="hljs-string">"my.addr"</span></span>) { message -&gt; handleMessage(message) } dbclient = JDBCClient.createShared( vertx, JsonObject() .put(<span class="hljs-string"><span class="hljs-string">"url"</span></span>, <span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://localhost:5432/payroll"</span></span>) .put(<span class="hljs-string"><span class="hljs-string">"driver_class"</span></span>, <span class="hljs-string"><span class="hljs-string">"org.postgresql.Driver"</span></span>) .put(<span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-string"><span class="hljs-string">"vala"</span></span>) .put(<span class="hljs-string"><span class="hljs-string">"password"</span></span>, <span class="hljs-string"><span class="hljs-string">"vala"</span></span>) .put(<span class="hljs-string"><span class="hljs-string">"max_pool_size"</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> options = WebClientOptions() .setUserAgent(<span class="hljs-string"><span class="hljs-string">"My-App/1.2.3"</span></span>) options.isKeepAlive = <span class="hljs-literal"><span class="hljs-literal">false</span></span> webclient = WebClient.create(vertx, options) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { dbclient.getConnection { res -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res.succeeded()) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> connection = res.result() connection.query(<span class="hljs-string"><span class="hljs-string">"SELECT url FROM payee_company where name='</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message.body()}</span></span></span><span class="hljs-string">'"</span></span>) { res2 -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res2.succeeded()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> url = res2.result().rows[<span class="hljs-number"><span class="hljs-number">0</span></span>].getString(<span class="hljs-string"><span class="hljs-string">"url"</span></span>).removePrefix(<span class="hljs-string"><span class="hljs-string">"http://"</span></span>) webclient .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(url,<span class="hljs-string"><span class="hljs-string">"/"</span></span>) .send { ar -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ar.succeeded()) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> response = ar.result() message.reply(response.bodyAsString()) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { message.fail(<span class="hljs-number"><span class="hljs-number">500</span></span>, ar.cause().message) } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { message.fail(<span class="hljs-number"><span class="hljs-number">500</span></span>, e.message) } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { message.fail(<span class="hljs-number"><span class="hljs-number">500</span></span>, res2.cause().message) } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { message.fail(<span class="hljs-number"><span class="hljs-number">500</span></span>, res.cause().message) } } } }</code> </pre> <br>  Se ve francamente, más o menos: devolución de llamadas, especialmente el manejo de errores. <br><br>  Intentemos mejorar la situación, como nos enseña el gurú de devolución de llamada, seleccionando cada devolución de llamada en un método separado: <br><br><pre> <code class="kotlin hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BusinessVerticle</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AbstractVerticle</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dbclient: JDBCClient <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> webclient: WebClient <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { vertx.eventBus().consumer&lt;String&gt;(<span class="hljs-string"><span class="hljs-string">"my.addr"</span></span>) { message -&gt; handleMessage(message) } dbclient = JDBCClient.createShared( vertx, JsonObject() .put(<span class="hljs-string"><span class="hljs-string">"url"</span></span>, <span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://localhost:5432/payroll"</span></span>) .put(<span class="hljs-string"><span class="hljs-string">"driver_class"</span></span>, <span class="hljs-string"><span class="hljs-string">"org.postgresql.Driver"</span></span>) .put(<span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-string"><span class="hljs-string">"vala"</span></span>) .put(<span class="hljs-string"><span class="hljs-string">"password"</span></span>, <span class="hljs-string"><span class="hljs-string">"vala"</span></span>) .put(<span class="hljs-string"><span class="hljs-string">"max_pool_size"</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> options = WebClientOptions() .setUserAgent(<span class="hljs-string"><span class="hljs-string">"My-App/1.2.3"</span></span>) options.isKeepAlive = <span class="hljs-literal"><span class="hljs-literal">false</span></span> webclient = WebClient.create(vertx, options) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { dbclient.getConnection { res -&gt; handleConnectionCallback(res, message) } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleConnectionCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( res: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AsyncResult</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SQLConnection</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res.succeeded()) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> connection = res.result() connection.query(<span class="hljs-string"><span class="hljs-string">"SELECT url FROM payee_company where name='</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message.body()}</span></span></span><span class="hljs-string">'"</span></span>) { res2 -&gt; handleQueryCallBack(res2, message) } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { message.fail(<span class="hljs-number"><span class="hljs-number">500</span></span>, res.cause().message) } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleQueryCallBack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( res2: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AsyncResult</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ResultSet</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res2.succeeded()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> url = res2.result().rows[<span class="hljs-number"><span class="hljs-number">0</span></span>].getString(<span class="hljs-string"><span class="hljs-string">"url"</span></span>).removePrefix(<span class="hljs-string"><span class="hljs-string">"http://"</span></span>) webclient .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(url, <span class="hljs-string"><span class="hljs-string">"/"</span></span>) .send { ar -&gt; handleHttpCallback(ar, message) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { message.fail(<span class="hljs-number"><span class="hljs-number">500</span></span>, e.message) } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { message.fail(<span class="hljs-number"><span class="hljs-number">500</span></span>, res2.cause().message) } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleHttpCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ar: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AsyncResult</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">HttpResponse</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Buffer</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&gt;, message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ar.succeeded()) { <span class="hljs-comment"><span class="hljs-comment">// Obtain response val response = ar.result() message.reply(response.bodyAsString()) } else { message.fail(500, ar.cause().message) } } }</span></span></code> </pre> <br>  Bueno, se puso mejor.  Pero también más o menos. <br><br>  Muchas líneas, no un código particularmente legible, necesita arrastrar el objeto del <i>mensaje</i> para obtener una respuesta, el manejo de errores se extendió por el código. <br><br>  Intentemos reescribir esta basura usando <i>Futuros</i> <br>  <i>Los futuros</i> son especialmente buenos porque se pueden combinar fácilmente con <i>Future.compose ()</i> <br><br>  Primero, traduciremos los métodos estándar de Vertx que aceptan una devolución de llamada y no devuelven nada a métodos que devuelvan Futuro. <br><br>  Aprovechamos la capacidad de Kotlin para agregar métodos a las clases existentes: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> JDBCClient.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConnectionF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Future&lt;SQLConnection&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f = Future.future&lt;SQLConnection&gt;() getConnection { res -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res.succeeded()) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> connection = res.result() f.complete(connection) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { f.fail(res.cause()) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> SQLConnection.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queryF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(query:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Future&lt;ResultSet&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f = Future.future&lt;ResultSet&gt;() query(query) { res -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res.succeeded()) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultSet = res.result() f.complete(resultSet) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { f.fail(res.cause()) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T,M&gt;</span></span></span><span class="hljs-function"> HttpRequest</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Future&lt;HttpResponse&lt;M&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f = Future.future&lt;HttpResponse&lt;M&gt;&gt;() send() { res -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res.succeeded()) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> response = res.result() f.complete(response) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { f.fail(res.cause()) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f }</code> </pre><br>  Y convierta nuestro BusinessVerticle.handleMessage en esto: <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> content = getContent(message) content.setHandler{res-&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res.succeeded()) { <span class="hljs-comment"><span class="hljs-comment">// Obtain response val response = res.result() message.reply(response) } else { message.fail(500, res.cause().message) } } } private fun getContent(message: Message&lt;String&gt;): Future&lt;String&gt; { val connection = dbclient.getConnectionF() val resultSet = connection.compose { it.queryF("SELECT url FROM payee_company where name='${message.body()}'") } val url = resultSet.map { it.rows[0].getString("url").removePrefix("http://") } val httpResponse = url.compose { webclient.get(it, "/").sendF() } val content = httpResponse.map { it.bodyAsString() } return content }</span></span></code> </pre><br>  Se ve genial <br><br>  Código simple y legible.  Error al manejar en un solo lugar.  Si es necesario, puede hacer una reacción diferente a diferentes excepciones o, por ejemplo, ponerla en una función separada. <br><br>  El sueño del poeta! <br><br>  Pero, ¿qué sucede si necesitamos terminar la cadena de <i>Futuros</i> por alguna condición? <br>  Por ejemplo, si no hay una entrada correspondiente en la base de datos, no queremos lanzar una excepción (y el código 500 al cliente), pero devolvemos la cadena "Sin registro" con el código 200. <br><br>  La única forma (que sé) de terminar la cadena de <i>Future.compose ()</i> es lanzar una excepción. <br><br>  Es decir  necesita hacer algo como esto: determine su tipo de excepción, arroje esta excepción si no hay entrada en la base de datos, maneje esta excepción de una manera especial. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NoContentException</span></span></span></span>(message:String):Exception(message) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Future&lt;String&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> connection = dbclient.getConnectionF() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultSet = connection.compose { it.queryF(<span class="hljs-string"><span class="hljs-string">"SELECT url FROM payee_company where name='</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message.body()}</span></span></span><span class="hljs-string">'"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> url = resultSet.map { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it.numRows&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> NoContentException(<span class="hljs-string"><span class="hljs-string">"No records"</span></span>) it.rows[<span class="hljs-number"><span class="hljs-number">0</span></span>].getString(<span class="hljs-string"><span class="hljs-string">"url"</span></span>).removePrefix(<span class="hljs-string"><span class="hljs-string">"http://"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> httpResponse = url.compose { webclient.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(it, <span class="hljs-string"><span class="hljs-string">"/"</span></span>).sendF() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> content = httpResponse.map { it.bodyAsString() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> content } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> content = getContent(message) content.setHandler{res-&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res.succeeded()) { <span class="hljs-comment"><span class="hljs-comment">// Obtain response val response = res.result() message.reply(response) } else { if (res.cause() is NoContentException) message.reply(res.cause().message) else message.fail(500, res.cause().message) } } }</span></span></code> </pre><br>  Funciona! <br><br>  Pero ya se ve peor: usar excepciones para controlar el flujo de ejecución no es hermoso.  Y si habrá muchos de estos casos que requieren un procesamiento por separado, el código será mucho menos legible. <br><br>  Tratemos de hacer lo mismo con las corutinas de Kotlin. <br>  Se ha escrito mucho sobre las corutinas, incluso en Habré ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3</a> , ...), por lo tanto, no escribiré sobre ellas por separado. <br><br>  Las últimas versiones de Vertx generan automáticamente versiones de rutina de todos los métodos que una devolución de llamada debe aceptar. <br><br>  Conectamos bibliotecas <br>  'vertx-lang-kotlin-coroutines' <br>  'vertx-lang-kotlin' <br><br>  y obtener, por ejemplo <br><br><pre> <code class="kotlin hljs">JDBCClient.getConnectionAwait() SQLConnection.queryAwait()</code> </pre><br>  etc. <br><br>  Luego, nuestros métodos de procesamiento de mensajes se convierten en algo agradable y simple: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> content = getContent(message) message.reply(content) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(e:Exception){ message.fail(<span class="hljs-number"><span class="hljs-number">500</span></span>, e.message) } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: String { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> connection = dbclient.getConnectionAwait() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultSet = connection.queryAwait(<span class="hljs-string"><span class="hljs-string">"SELECT url FROM payee_company where name='</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message.body()}</span></span></span><span class="hljs-string">'"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> url = resultSet.rows[<span class="hljs-number"><span class="hljs-number">0</span></span>].getString(<span class="hljs-string"><span class="hljs-string">"url"</span></span>).removePrefix(<span class="hljs-string"><span class="hljs-string">"http://"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> httpResponse = webclient.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(url, <span class="hljs-string"><span class="hljs-string">"/"</span></span>).sendAwait() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> content = httpResponse.bodyAsString() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> content }</code> </pre> <br>  Bueno, debe cambiar la llamada proporcionando un contexto de rutina: <br><br><pre> <code class="kotlin hljs">vertx.eventBus().consumer&lt;String&gt;(<span class="hljs-string"><span class="hljs-string">"my.addr"</span></span>) { message -&gt; GlobalScope.launch(vertx.dispatcher()) { handleMessage(message)} }</code> </pre><br>  ¿Qué está pasando aquí? <br><br>  Todos estos métodos con Await llaman al código de forma asincrónica, esperan el resultado y, mientras esperan, el hilo cambia a la ejecución de otra rutina. <br><br>  Si miramos debajo del capó, entonces se ve así: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> SQLClient.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConnectionAwait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: SQLConnection { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> awaitResult { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getConnection(it) } } <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">awaitResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">h</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Handler</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AsyncResult</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&gt;)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): T { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> asyncResult = awaitEvent(block) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (asyncResult.succeeded()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> asyncResult.result() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> asyncResult.cause() } <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">awaitEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">h</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Handler</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> suspendCancellableCoroutine { cont: CancellableContinuation&lt;T&gt; -&gt; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { block.invoke(Handler { t -&gt; cont.resume(t) }) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { cont.resumeWithException(e) } } }</code> </pre><br>  Algo similar a nuestra implementación autoescrita con Futures. <br><br>  Pero aquí obtenemos el código normal: cadena como tipo de retorno (en lugar de futuro), intente / atrapar en lugar de la devolución de llamada fea con AsyncResult <br><br>  Y si necesitamos detener la cadena de ejecución en el medio, parece natural, sin ninguna excepción: <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: String { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> connection = dbclient.getConnectionAwait() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultSet = connection.queryAwait(<span class="hljs-string"><span class="hljs-string">"SELECT url FROM payee_company where name='</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message.body()}</span></span></span><span class="hljs-string">'"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resultSet.numRows&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"No records"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> url = resultSet.rows[<span class="hljs-number"><span class="hljs-number">0</span></span>].getString(<span class="hljs-string"><span class="hljs-string">"url"</span></span>).removePrefix(<span class="hljs-string"><span class="hljs-string">"http://"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> httpResponse = webclient.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(url, <span class="hljs-string"><span class="hljs-string">"/"</span></span>).sendAwait() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> content = httpResponse.bodyAsString() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> content }</code> </pre><br>  En mi opinión, genial! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/449092/">https://habr.com/ru/post/449092/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../449080/index.html">Contenedor Docker para administrar servidores HP a través de la OIT</a></li>
<li><a href="../449082/index.html">La calidad es responsabilidad del equipo. Nuestra experiencia de control de calidad</a></li>
<li><a href="../449086/index.html">Dentro de la llama: un nuevo método para investigar sistemas reactivos a alta temperatura</a></li>
<li><a href="../449088/index.html">Es hora de que los inversores y empresarios comiencen a resolver el problema de la salud mental en las nuevas empresas.</a></li>
<li><a href="../449090/index.html">Cambiar dinámicamente el esquema JSON en Go con gob</a></li>
<li><a href="../449094/index.html">Startup Psychology: transformaciones que no todos vivirán</a></li>
<li><a href="../449098/index.html">Cómo una compañía de software espía llegó a la tienda de certificados de Mozilla y qué surgió</a></li>
<li><a href="../449100/index.html">A raíz de RTM. Investigación forense de una computadora infectada con un troyano bancario</a></li>
<li><a href="../449106/index.html">UPS para instituciones bancarias y financieras</a></li>
<li><a href="../449108/index.html">UDB Que es esto Parte 7. Módulo de control de temporización y reinicio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>