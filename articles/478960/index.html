<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåï üíú üë±üèø Mini sensor de luz y choque | nRF52840 üë®üèΩ‚Äçüé§ üìô üñêüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En el art√≠culo de hoy quiero hablar sobre un nuevo sensor de luz y vibraci√≥n. El sensor funciona en el m√≥dulo E73-2G4M08S1C (nRF52840). La raz√≥n para ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mini sensor de luz y choque | nRF52840</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478960/">  En el art√≠culo de hoy quiero hablar sobre un nuevo sensor de luz y vibraci√≥n.  El sensor funciona en el m√≥dulo E73-2G4M08S1C (nRF52840).  La raz√≥n para el desarrollo de MK fue la simple adici√≥n de soporte para Arduino IDE basado en la biblioteca Sandeep Mistry, bajo costo, excelentes caracter√≠sticas y la capacidad de cambiar de MySensors a ZigBee por ejemplo :) <br><br><img src="https://habrastorage.org/webt/dm/b0/dt/dmb0dtvbakfgj_pgye8k_wjlmdc.jpeg"><br><a name="habracut"></a><br>  La necesidad de tal proyecto surgi√≥ con la llegada de una persiana enrollable en mi casa :).  Era necesario que el controlador de persiana enrollable recibiera datos sobre el nivel de iluminaci√≥n directamente desde la ventana en la que el controlador controla la cortina. <br><br>  Inicialmente, plane√© usar el sensor BH1750FVI, las caracter√≠sticas de este sensor estaban bien, se us√≥ m√°s de una vez en mis otros proyectos de bricolaje.  Pero en alg√∫n momento, cuando hablamos de todo tipo de sensores, alguien sugiri√≥ echar un vistazo m√°s de cerca al sensor MAX44009.  Mir√© de cerca y desde ese momento nunca m√°s volv√≠ a recordar el BH1750FVI. <br><br><img src="https://habrastorage.org/webt/d7/bg/a_/d7bga_4sti9_x359xlgirab0egk.jpeg"><br><br>  <b>Especificaciones de MAX44009:</b> <br><br><ul><li>  Rango de voltaje de alimentaci√≥n 1.7-3.6 V, </li><li>  Corriente de funcionamiento ultrabaja: 0,65 ŒºA (m√°s baja que la corriente en el modo de apagado para muchos productos similares), </li><li>  Amplio rango din√°mico de 22 bits 0.045-188000, </li><li>  La presencia de la funci√≥n de interrupci√≥n, la capacidad de monitorear continuamente el nivel de iluminaci√≥n y generar una se√±al de interrupci√≥n para el MC cuando excede los umbrales especificados. </li></ul><br>  Tambi√©n quer√≠a la universalidad o alg√∫n tipo de funcionalidad avanzada, despu√©s de pensar un poco decid√≠ agregar un aceler√≥metro al proyecto que funcionar√≠a como un sensor de vibraci√≥n.  Esto agregar√° funcionalidad de seguridad al sensor.  En mi caso, sobre la base del evento, se activar√° un script en UD desde el sensor que simula la presencia en la casa (enciende la luz en las habitaciones), cuando se activa, no hay nadie en casa.  En general, el sensor tambi√©n se puede usar como un sensor de vibraci√≥n y choque independiente, solo se puede soldar un sensor de luz o solo un aceler√≥metro.  El aceler√≥metro tambi√©n se puede reprogramar para reconocer tapas, giros, etc. <br><br>  Como aceler√≥metro, se eligi√≥ el sensor LIS2DW12, que es uno de los aceler√≥metros m√°s econ√≥micos del mercado, si no el m√°s econ√≥mico. <br><br><img src="https://habrastorage.org/webt/ex/jc/op/exjcop6l77shvd-ietzkuksg5hq.jpeg"><br><br>  <b>Caracter√≠sticas de LIS2DW12:</b> <br><br><ul><li>  Rango de voltaje de alimentaci√≥n 1.62-3.6 V, </li><li>  50 nA en modo de espera </li><li>  1 ŒºA en modo de baja potencia, </li><li>  La presencia de la funci√≥n de interrupci√≥n, la posibilidad de operaci√≥n continua del sensor y la formaci√≥n de una se√±al de interrupci√≥n para el MC cuando excede los umbrales especificados. </li></ul><br>  Anticipando posibles problemas para los hermanos Arduino con el lanzamiento de este modelo de aceler√≥metro debido a la falta total de bibliotecas Arduino listas para LIS2DW12, m√°s tarde se agreg√≥ soporte para otro modelo de aceler√≥metro LIS2DH12 con caracter√≠sticas similares, pero mayor consumo en modo de baja potencia - 2 ŒºA.  Para los aceler√≥metros LIS2DH12 hay bibliotecas Arduino bastante buenas. <br><br>  El sensor de luz funciona con una bater√≠a CR2032. <br><br><img src="https://habrastorage.org/webt/bd/z3/lf/bdz3lfe167cepe3m-5vvg0fc5-0.jpeg"><br><br>  Muchos de los que ya usan el proyecto MySensors para construir su Smart Home probablemente conozcan la l√≥gica no √≥ptima de MySensors en dispositivos de bater√≠a.  Env√≠o constante de presentaciones cuando se reinicia el dispositivo, modo sub√≥ptimo de recuperaci√≥n autom√°tica de dispositivos en la red, consumo sub√≥ptimo con interrupciones activadas en la funci√≥n de reposo, en general, la sola presencia de solo dos interrupciones en un sue√±o.  Todas las circunstancias insin√∫an el hecho de que los fundadores del proyecto Maysensors tienen una mala actitud hacia las bater√≠as :) <br><br>  En este proyecto, intent√© minimizar estas deficiencias. <br><br>  Lo m√°s b√°sico con lo que quer√≠a lidiar eran las interrupciones.  Por lo general, cuando se activan las interrupciones en la funci√≥n de reposo, el nRF52 MK comienza a consumir + 10mKA para el consumo del propio MK (desde 1.4 ŒºA para nRF52810-52811 y hasta 4.7 ŒºA para nRF52832-52840).  Hay un total de 2 interrupciones disponibles. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> sleep(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> interrupt1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> mode1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> interrupt2, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> mode2, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> sleepingMS = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> smartSleep = <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br>  Anteriormente en la b√∫squeda de soluciones para optimizar el consumo en un sue√±o, se realiz√≥ la posibilidad de usar interrupciones en el comparador de bajo consumo incorporado, el consumo en un sue√±o ya no era + 10 ŒºA, sino en la regi√≥n de +1 ŒºA, pero era posible usar solo una interrupci√≥n.  En principio, aparte de las molestias en el c√≥digo (procesamiento de se√±ales de pines adicionales) y elementos adicionales en el tablero (diodos), esta fue una buena soluci√≥n.  Pero lo quer√≠a a√∫n mejor. <br><br>  En este momento ya estaba un poco familiarizado :) con el SDK nRF5, as√≠ que despu√©s de estudiar el foro mysensors.org (sugerencias, consejos :)) decid√≠ buscar la soluci√≥n en el SDK nRF5 ... y lo encontr√©.  Ahora hay disponible un n√∫mero ilimitado de interrupciones que pr√°cticamente no consumen nada extra.  Lo principal que debe hacer es realizar un peque√±o cambio en el c√≥digo de la biblioteca Sandeepmistry nRF5, en el archivo WInterrupts. Antes de la funci√≥n GPIOTE_IRQHandler () agregue el atributo "d√©bil" que le permitir√° redefinir esta funci√≥n de biblioteca en el c√≥digo de usuario - __attribute__ ((d√©bil)) <br><br><img src="https://habrastorage.org/webt/s5/sf/oy/s5sfoy5fdmvjiu16afhtkcrxkjg.png"><br><br>  El archivo se encuentra en la ruta: C: \ Users \ USER_COMPA \ AppData \ Local \ Arduino15 \ packages \ sandeepmistry \ <br>  hardware \ nRF5 \ 0.6.0 \ n√∫cleos \ nRF5 \ <br>  Los archivos que deben agregarse al proyecto se encuentran en mi Gita en la carpeta EFEKTA-LIS2DW12-MAX44009-E73C / SOURCE CODE / ARDUINO /, un ejemplo de uso se encuentra en el boceto EFEKTA-LIS2DW12-MAX44009-E73C / SOURCE CODE / ARDUINO / vibro_ambi1_ vibro_ambi1_ vibro_ambi1_ <br><br>  Lo siguiente que quer√≠a finalizar era la propia biblioteca Sandeepmistry nRF5, que ser√≠a conveniente trabajar con los nuevos MK nRF52840, nRF52811 y anteriores, pero por alguna raz√≥n no se merecen sin m√©ritos nRF52810 (despu√©s de todo, 1.4 ŒºA en un sue√±o no es para ti :)).  Por supuesto, puede trabajar con nRF52840 en Arduino IDE y desde nRF52832, pero ... quer√≠a hacerlo m√°s c√≥modo.  Arriba, escrib√≠ que hay inter√©s en hacer algo en el SDK n√≥rdico, especialmente Segger Embedded Studio es gratuito cuando se trabaja con MK nRF5.  El soporte para todos los tableros que me interesaron fue tomado del SDK y transferido a Arduino (hasta ahora sin un dispositivo suave, y no es necesario con mis sensores).  Tambi√©n se han agregado nuevos tableros a la biblioteca MySensors. <br><br><img src="https://habrastorage.org/webt/xc/hy/dy/xchydy8gbj0ld1tcvtyjiqbu70o.png"><br><br>  <a href="https://github.com/smartboxchannel/arduino-nRF5" rel="nofollow">github.com/smartboxchannel/arduino-nRF5</a> <br>  <a href="https://github.com/smartboxchannel/MySensors" rel="nofollow">github.com/smartboxchannel/MySensors</a> <br><br>  Si uno de los lectores ya est√° familiarizado con mis art√≠culos anteriores, entonces probablemente no se sorprender√° de que yo, como antes, hice una impresora de pol√≠mero l√≠quido en el SLA con un estuche para un sensor de luz.  Las ventajas de imprimir en esta tecnolog√≠a es su alta precisi√≥n.  Pero, por supuesto, tambi√©n hay desventajas, los pol√≠meros con los que pueden trabajar las impresoras dom√©sticas SLA siguen siendo inferiores en resistencia a los pl√°sticos para FDM. El modelo 3D de la caja consta de 2 partes, cada mitad se imprimi√≥ durante 40 minutos (espesor de capa de 50 micras).  Especialmente, probablemente no haya necesidad de detenerse all√≠, solo un par de im√°genes del proceso de desarrollo en un editor 3D. <br><br><img src="https://habrastorage.org/webt/a0/x0/qt/a0x0qtl5jiglsmcidmbjibr_5wi.png"><br><br><img src="https://habrastorage.org/webt/by/cz/rk/byczrkmuesyuzijn5yyvv71uroa.png"><br><br><img src="https://habrastorage.org/webt/i4/ct/qc/i4ctqcrbeduw2p4an1a1jpkie9s.png"><br><br>  El programa del sensor implement√≥ un reinicio del dispositivo sin enviar presentaciones.  Funciona de esta manera: mientras el dispositivo es nuevo y no se agrega a su red, cuando se agrega por primera vez a la red, se registrar√° y completar√° la presentaci√≥n, luego de un registro exitoso, el dispositivo que recibi√≥ el identificador ya no enviar√° la presentaci√≥n nuevamente, pero puede enviarla haciendo clic en el bot√≥n del sensor (esto necesario, por ejemplo, si no todos los sensores se presentaron con √©xito de inmediato).  Adem√°s, el programa desactiva la posibilidad de una recuperaci√≥n autom√°tica est√°ndar de la actividad de la red (si el sensor pierde la red), se invent√≥ su propia opci√≥n no est√°ndar :).  Funciona as√≠: si el sensor detecta m√°s de 5 (esto es configurable) intentos fallidos de enviar mensajes en una fila, el dispositivo deja de enviar datos desde los sensores y comienza a enviar un mensaje de b√∫squeda en la red con un intervalo inicialmente igual al intervalo de env√≠o desde / 2 sensores y aumentando peri√≥dicamente este intervalo c cada env√≠o, entre env√≠os, un sue√±o saludable.  Todo esto le permite ahorrar significativamente la energ√≠a de la bater√≠a. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de prueba</b> <div class="spoiler_text"><pre> <code class="css hljs">// <span class="hljs-selector-tag"><span class="hljs-selector-tag">SDK</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PORT</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">extern</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">C</span></span>" { #include "app_gpiote.h" #include "nrf_gpio.h" } <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">APP_GPIOTE_MAX_USERS</span></span> 1 <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">LIS2DW12Sensor</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">MAX44009</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; //<span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MY_DEBUG</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MY_RADIO_NRF5_ESB</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MY_DISABLED_SERIAL</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mtwr</span></span>; <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MY_TRANSPORT_WAIT_READY_MS</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">mtwr</span></span>) <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MY_NRF5_ESB_PA_LEVEL</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">NRF5_PA_MAX</span></span>) <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">MySensors</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SN</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">LUX</span></span> &amp; <span class="hljs-selector-tag"><span class="hljs-selector-tag">VIBRO</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SENS</span></span>" <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SV</span></span> "1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>" <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_SENS_CHILD_ID</span></span> 1 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LUX_SENS_CHILD_ID</span></span> 2 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">WPM_SENS_CHILD_ID</span></span> 3 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">INTERVAL_R_LUX_CHILD_ID</span></span> 220 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LEVEL_SENSIV_V_SENS_CHILD_ID</span></span> 230 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ENABLE_WPM_SENS_CHILD_ID</span></span> 240 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SIGNAL_Q_ID</span></span> 253 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">TEMP_CHILD_ID</span></span> 254 //<span class="hljs-selector-tag"><span class="hljs-selector-tag">for</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">any</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">tests</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">MySensors</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vibroMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">V_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_TRIPPED</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">brightMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">LUX_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_LEVEL</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">wpmMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">WPM_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_LEVEL</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">conf_wpmMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">ENABLE_WPM_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_VAR1</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">conf_vsensMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">LEVEL_SENSIV_V_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_VAR1</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">conf_interv_rluxMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">INTERVAL_R_LUX_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_VAR1</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">tempMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">TEMP_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_VAR1</span></span>); //<span class="hljs-selector-tag"><span class="hljs-selector-tag">for</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">any</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">tests</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">nosleep</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">button_flag</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">configMode</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">wpm_enable</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">onoff</span></span> = 1; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_update_transport_param</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_sendRoute_parent</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_no_present</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_nogateway_mode</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_find_parent_process</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_fcount</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Ack_TL</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Ack_FP</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PRESENT_ACK</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">conf_vibro_set</span></span> = 1; <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">interval_reading_lux</span></span> = 10; <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">err_delivery_beat</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">problem_mode_count</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint8_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">countbatt</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint8_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">batt_cap</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint8_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">old_batt_cap</span></span> = 100; //<span class="hljs-selector-tag"><span class="hljs-selector-tag">unsigned</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">long</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">BATT_TIME</span></span> = 43200000; //12 <span class="hljs-selector-tag"><span class="hljs-selector-tag">hours</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">BATT_TIME</span></span> = 7200000; //12 <span class="hljs-selector-tag"><span class="hljs-selector-tag">hours</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SLEEP_TIME_TEMP</span></span> = 60000; //1 <span class="hljs-selector-tag"><span class="hljs-selector-tag">minute</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SLEEP_TIME</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">C_BATT_TIME</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">oldmillis</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">newmillis</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">previousMillis</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">lightMillisR</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">configMillis</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">interrupt_time</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SLEEP_TIME_W</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">axel_time</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">result</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">brightness</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">lastbrightness</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">brightThreshold</span></span> = 25; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">myid</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mypar</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">old_mypar</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">-1</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">master_id</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Wpm</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_1Hz6_LP_ONLY</span></span> = 1<span class="hljs-selector-class"><span class="hljs-selector-class">.6f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_12Hz5</span></span> = 12<span class="hljs-selector-class"><span class="hljs-selector-class">.5f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_25Hz</span></span> = 25<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_50Hz</span></span> = 50<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_100Hz</span></span> = 100<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_200Hz</span></span> = 200<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vibro</span></span> = 1; <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">app_gpiote_user_id_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">m_gpiote_user_id</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PIN_BUTTON1_MASK</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">AXEL_INT1_MASK</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">volatile</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">axelInt1Status</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">volatile</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">buttInt1Status</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">batteryVoltage</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">linkQuality</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">old_linkQuality</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">LIS2DW12Sensor</span></span> *<span class="hljs-selector-tag"><span class="hljs-selector-tag">lis2</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">MAX44009</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">light</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">preHwInit</span></span>() { board_Init(); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">before</span></span>() { blinky(1, 1, GREEN_LED); wait(1000); nRF_Init(); device_Conf(); happy_init(); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">setup</span></span>() { interrupt_Init(); sensors_Init(); config_Happy_node(); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">presentation</span></span>() { if (!sendSketchInfo(SN, SV)) { _transportSM.failedUplinkTransmissions = 0; sleep(1000); wait(50); if (!sendSketchInfo(SN, SV)) { _transportSM.failedUplinkTransmissions = 0; } } <span class="hljs-selector-tag"><span class="hljs-selector-tag">present</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">V_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">S_VIBRATION</span></span>, "<span class="hljs-selector-tag"><span class="hljs-selector-tag">STATUS</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">VIBRO</span></span>", 1); <span class="hljs-selector-tag"><span class="hljs-selector-tag">wait</span></span>(2500, <span class="hljs-selector-tag"><span class="hljs-selector-tag">C_PRESENTATION</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">S_VIBRATION</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">CORE_DEBUG</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">PSTR</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">MyS</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">TEST</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">WAIT</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">AFTER</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PRESENT</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SENSOR</span></span>\<span class="hljs-selector-tag"><span class="hljs-selector-tag">n</span></span>")); <span class="hljs-selector-tag"><span class="hljs-selector-tag">if</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">PRESENT_ACK</span></span> == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(V_SENS_CHILD_ID, S_VIBRATION, "STATUS VIBRO", 1); wait(2500, C_PRESENTATION, S_VIBRATION); CORE_DEBUG(PSTR("<span class="hljs-attribute"><span class="hljs-attribute">MyS</span></span>: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(LUX_SENS_CHILD_ID, S_LIGHT_LEVEL, "</span></span>LUX<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_LIGHT_LEVEL); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(LUX_SENS_CHILD_ID, S_LIGHT_LEVEL, "</span></span>LUX<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_LIGHT_LEVEL); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(WPM_SENS_CHILD_ID, S_LIGHT_LEVEL, "</span></span>W/M^<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_LIGHT_LEVEL); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(WPM_SENS_CHILD_ID, S_LIGHT_LEVEL, "</span></span>W/M^<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_LIGHT_LEVEL); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(SIGNAL_Q_ID, S_CUSTOM, "</span></span>SIGNAL QUALITY<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(SIGNAL_Q_ID, S_CUSTOM, "</span></span>SIGNAL QUALITY<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(ENABLE_WPM_SENS_CHILD_ID, S_CUSTOM, "</span></span>ON|OFF WPM<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(ENABLE_WPM_SENS_CHILD_ID, S_CUSTOM, "</span></span>ON|OFF WPM<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(LEVEL_SENSIV_V_SENS_CHILD_ID, S_CUSTOM, "</span></span>SENS LEVEL VIBRO<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(LEVEL_SENSIV_V_SENS_CHILD_ID, S_CUSTOM, "</span></span>SENS LEVEL VIBRO<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(INTERVAL_R_LUX_CHILD_ID, S_CUSTOM, "</span></span>INTERVAL RLUX|MIN<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(INTERVAL_R_LUX_CHILD_ID, S_CUSTOM, "</span></span>INTERVAL RLUX|MIN<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } send(conf_wpmMsg.set(wpm_enable), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (Ack_TL == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); send(conf_wpmMsg.set(wpm_enable), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { Ack_TL = 0; } send(conf_vsensMsg.set(conf_vibro_set), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (Ack_TL == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); send(conf_vsensMsg.set(conf_vibro_set), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { Ack_TL = 0; } send(conf_interv_rluxMsg.set(interval_reading_lux), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (Ack_TL == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); send(conf_interv_rluxMsg.set(interval_reading_lux), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { Ack_TL = 0; } } void loop() { if (flag_update_transport_param == 1) { update_Happy_transport(); } if (flag_sendRoute_parent == 1) { present_only_parent(); } if (isTransportReady() == true) { if (flag_nogateway_mode == 0) { if (flag_find_parent_process == 1) { find_parent_process(); } if (configMode == 0) { if ((axelInt1Status == AXEL_INT1) || (buttInt1Status == PIN_BUTTON1)) { if (axelInt1Status == AXEL_INT1) { nosleep = 1; send_Axel(); axelInt1Status = 0; newmillis = millis(); interrupt_time = newmillis - oldmillis; SLEEP_TIME_W = SLEEP_TIME_W - interrupt_time; if (SLEEP_TIME_W &lt; 5000) { SLEEP_TIME_W = SLEEP_TIME; send_Brigh(1); countbatt++; if (countbatt == C_BATT_TIME) { sendBatteryStatus(1); countbatt = 0; } } nosleep = 0; } if (buttInt1Status == PIN_BUTTON1) { if (digitalRead(PIN_BUTTON1) == 0 &amp;&amp; button_flag == 0) { button_flag = 1; nosleep = 1; previousMillis = millis(); ledsOff(); } if (digitalRead(PIN_BUTTON1) == 0 &amp;&amp; button_flag == 1) { if ((millis() - previousMillis &gt; 0) &amp;&amp; (millis() - previousMillis &lt;= 1750)) { if (millis() - lightMillisR &gt; 25) { lightMillisR = millis(); onoff = !onoff; digitalWrite(GREEN_LED, onoff); } } if ((millis() - previousMillis &gt; 1750) &amp;&amp; (millis() - previousMillis &lt;= 2000)) { ledsOff(); } if ((millis() - previousMillis &gt; 2000) &amp;&amp; (millis() - previousMillis &lt;= 4000)) { if (millis() - lightMillisR &gt; 25) { lightMillisR = millis(); onoff = !onoff; digitalWrite(BLUE_LED, onoff); } } if ((millis() - previousMillis &gt; 4000) &amp;&amp; (millis() - previousMillis &lt;= 4250)) { ledsOff(); } if ((millis() - previousMillis &gt; 4250) &amp;&amp; (millis() - previousMillis &lt;= 6250)) { if (millis() - lightMillisR &gt; 25) { lightMillisR = millis(); onoff = !onoff; digitalWrite(RED_LED, onoff); } } if ((millis() - previousMillis &gt; 6250) &amp;&amp; (millis() - previousMillis &lt;= 6500)) { ledsOff(); } if ((millis() - previousMillis &gt; 6500) &amp;&amp; (millis() - previousMillis &lt;= 8500)) { if (millis() - lightMillisR &gt; 50) { lightMillisR = millis(); onoff = !onoff; digitalWrite(RED_LED, onoff); } } if (millis() - previousMillis &gt; 8500) { ledsOff(); } } if (digitalRead(PIN_BUTTON1) == 1 &amp;&amp; button_flag == 1) { if (millis() - previousMillis &lt;= 2000) { ledsOff(); send_Brigh(0); nosleep = 0; button_flag = 0; buttInt1Status = 0; } if ((millis() - previousMillis &gt; 2000) &amp;&amp; (millis() - previousMillis &lt;= 4000)) { ledsOff(); configMode = 1; button_flag = 0; configMillis = millis(); } if ((millis() - previousMillis &gt; 4250) &amp;&amp; (millis() - previousMillis &lt;= 6250)) { ledsOff(); blinky(2, 2, RED_LED); button_flag = 0; buttInt1Status = 0; presentation(); nosleep = 0; } if ((millis() - previousMillis &gt; 6500) &amp;&amp; (millis() - previousMillis &lt;= 8500)) { ledsOff(); blinky(3, 3, RED_LED); new_device(); } if (((millis() - previousMillis &gt; 1750) &amp;&amp; (millis() - previousMillis &lt;= 2000)) || ((millis() - previousMillis &gt; 4000) &amp;&amp; (millis() - previousMillis &lt;= 4250)) || ((millis() - previousMillis &gt; 6250) &amp;&amp; (millis() - previousMillis &lt;= 6500)) || ((millis() - previousMillis &gt; 8500))) { ledsOff(); blinky(1, 2, GREEN_LED); nosleep = 0; button_flag = 0; buttInt1Status = 0; } } } } else { SLEEP_TIME_W = SLEEP_TIME; send_Brigh(1); countbatt++; if (countbatt == C_BATT_TIME) { sendBatteryStatus(1); countbatt = 0; } nosleep = 0; } } else { if (millis() - configMillis &gt; 30000) { blinky(3, 3, GREEN_LED); configMode = 0; nosleep = 0; button_flag = 0; buttInt1Status = 0; } } } else { if (buttInt1Status == PIN_BUTTON1) { if (digitalRead(PIN_BUTTON1) == 0 &amp;&amp; button_flag == 0) { button_flag = 1; nosleep = 1; previousMillis = millis(); ledsOff(); } if (digitalRead(PIN_BUTTON1) == 0 &amp;&amp; button_flag == 1) { if ((millis() - previousMillis &gt; 0) &amp;&amp; (millis() - previousMillis &lt;= 500)) { ledsOff(); } if ((millis() - previousMillis &gt; 500) &amp;&amp; (millis() - previousMillis &lt;= 2500)) { lightMillisR = millis(); onoff = !onoff; digitalWrite(BLUE_LED, onoff); } if ((millis() - previousMillis &gt; 2500) &amp;&amp; (millis() - previousMillis &lt;= 2750)) { ledsOff(); } if ((millis() - previousMillis &gt; 2750) &amp;&amp; (millis() - previousMillis &lt;= 4750)) { if (millis() - lightMillisR &gt; 50) { lightMillisR = millis(); onoff = !onoff; digitalWrite(RED_LED, onoff); } } if (millis() - previousMillis &gt; 4750) { ledsOff(); blinky(3, 1, GREEN_LED); button_flag = 0; nosleep = 0; buttInt1Status = 0; } } if (digitalRead(PIN_BUTTON1) == 1 &amp;&amp; button_flag == 1) { if (millis() - previousMillis &lt;= 500) { ledsOff(); button_flag = 0; nosleep = 0; buttInt1Status = 0; } if ((millis() - previousMillis &gt; 500) &amp;&amp; (millis() - previousMillis &lt;= 2500)) { ledsOff(); blinky(1, 1, BLUE_LED); check_parent(); button_flag = 0; nosleep = 0; buttInt1Status = 0; } if ((millis() - previousMillis &gt; 2500) &amp;&amp; (millis() - previousMillis &lt;= 2750)) { ledsOff(); button_flag = 0; nosleep = 0; buttInt1Status = 0; } if ((millis() - previousMillis &gt; 2750) &amp;&amp; (millis() - previousMillis &lt;= 4750)) { ledsOff(); blinky(3, 3, RED_LED); new_device(); } if (millis() - previousMillis &gt; 4750) { ledsOff(); button_flag = 0; nosleep = 0; buttInt1Status = 0; } } } else { check_parent(); } } } if (_transportSM.failureCounter &gt; 0) { _transportConfig.parentNodeId = loadState(101); _transportConfig.nodeId = myid; _transportConfig.distanceGW = loadState(103); mypar = _transportConfig.parentNodeId; nosleep = 0; flag_fcount = 1; err_delivery_beat = 5; happy_node_mode(); gateway_fail(); } if (configMode == 0) { if (nosleep == 0) { oldmillis = millis(); axelInt1Status = 0; buttInt1Status = 0; wait(100); sleep(SLEEP_TIME_W, false); wait(50); nosleep = 1; } } } float GetWpm() { float SunLuxCoef = 0.0079; float Wpm_temp = 0; Wpm_temp = (float)brightness; Wpm_temp *= SunLuxCoef; return Wpm_temp; } void blinky(uint8_t pulses, uint8_t repit, uint8_t ledColor) { for (int x = 0; x &lt; repit; x++) { if (x &gt; 0) { sleep(300); } for (int i = 0; i &lt; pulses; i++) { if (i &gt; 0) { sleep(80); } digitalWrite(ledColor, LOW); sleep(20); digitalWrite(ledColor, HIGH); } } } void ledsOff() { digitalWrite(RED_LED, HIGH); digitalWrite(GREEN_LED, HIGH); digitalWrite(BLUE_LED, HIGH); } void nRF_Init() { NRF_POWER-&gt;DCDCEN = 1; NRF_NFCT-&gt;TASKS_DISABLE = 1; NRF_NVMC-&gt;CONFIG = 1; NRF_UICR-&gt;NFCPINS = 0; NRF_NVMC-&gt;CONFIG = 0; NRF_SAADC -&gt;ENABLE = 0; NRF_PWM0 -&gt;ENABLE = 0; NRF_PWM1 -&gt;ENABLE = 0; NRF_PWM2 -&gt;ENABLE = 0; NRF_TWIM1 -&gt;ENABLE = 0; NRF_TWIS1 -&gt;ENABLE = 0; NRF_RADIO-&gt;TXPOWER = 8; } void sensors_Init() { Wire.begin(); wait(100); light.begin(); wait(100); lis2 = new LIS2DW12Sensor (&amp;Wire); vibro_Init(); if (isTransportReady() == true) { blinky(3, 1, BLUE_LED); wait(200); blinky(3, 1, GREEN_LED); wait(200); blinky(3, 1, RED_LED); SLEEP_TIME_W = SLEEP_TIME; send_Brigh(0); wait(50); sendBatteryStatus(0); axel_time = millis(); } else { blinky(5, 3, RED_LED); } } void vibro_Init() { if (conf_vibro_set == 1) { lis2-&gt;ODRTEMP = ODR_1Hz6_LP_ONLY; } if (conf_vibro_set == 2) { lis2-&gt;ODRTEMP = ODR_12Hz5; } if (conf_vibro_set == 3) { lis2-&gt;ODRTEMP = ODR_25Hz; } if (conf_vibro_set == 4) { lis2-&gt;ODRTEMP = ODR_100Hz; } if (conf_vibro_set == 5) { lis2-&gt;ODRTEMP = ODR_200Hz; } lis2-&gt;Enable_X(); wait(50); lis2-&gt;Enable_Wake_Up_Detection(); wait(50); } void board_Init() { pinMode(PIN_BUTTON1, INPUT); pinMode(AXEL_INT1, INPUT); pinMode(AXEL_INT2, INPUT); pinMode(AMBI_INT, INPUT); pinMode(RED_LED, OUTPUT); pinMode(GREEN_LED, OUTPUT); pinMode(BLUE_LED, OUTPUT); ledsOff(); } void send_Axel() { if (millis() - axel_time &gt;= 5000) { blinky(6, 1, RED_LED); lis2-&gt;Disable_Wake_Up_Detection(); wait(100); if (_transportConfig.parentNodeId == 0) { if (send(vibroMsg.set(vibro))) { wait(100); err_delivery_beat = 0; if (flag_nogateway_mode == 1) { flag_nogateway_mode = 0; CORE_DEBUG(PSTR("</span></span>MyS: NORMAL GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); err_delivery_beat = 0; } } else { _transportSM.failedUplinkTransmissions = 0; if (err_delivery_beat &lt; 5) { err_delivery_beat++; } if (err_delivery_beat == 4) { if (flag_nogateway_mode == 0) { gateway_fail(); CORE_DEBUG(PSTR("</span></span>MyS: LOST GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); } } } lis2-&gt;Enable_Wake_Up_Detection(); wait(100); axel_time = millis(); nosleep = 0; } if (_transportConfig.parentNodeId &gt; 0) { send(vibroMsg.set(vibro), 1); wait(2500, C_SET, V_TRIPPED); if (Ack_TL == 1) { Ack_TL = 0; err_delivery_beat = 0; //sleep_flag = 0; if (flag_nogateway_mode == 1) { flag_nogateway_mode = 0; CORE_DEBUG(PSTR("</span></span>MyS: NORMAL GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); err_delivery_beat = 0; } } else { _transportSM.failedUplinkTransmissions = 0; if (err_delivery_beat &lt; 5) { err_delivery_beat++; } if (err_delivery_beat == 4) { if (flag_nogateway_mode == 0) { gateway_fail(); CORE_DEBUG(PSTR("</span></span>MyS: LOST GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); } } } lis2-&gt;Enable_Wake_Up_Detection(); wait(100); axel_time = millis(); nosleep = 0; } } else { nosleep = 0; } } void send_Brigh(bool start) { brightness = light.get_lux() * 2; wait(50); if (start == 1) { if (abs(brightness - lastbrightness) &gt;= brightThreshold) { if (_transportConfig.parentNodeId == 0) { if (send(brightMsg.set(brightness, 0))) { err_delivery_beat = 0; if (flag_nogateway_mode == 1) { flag_nogateway_mode = 0; CORE_DEBUG(PSTR("</span></span>MyS: NORMAL GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); err_delivery_beat = 0; } lastbrightness = brightness; if (wpm_enable == 1) { Wpm = GetWpm(); wait(100); send(wpmMsg.set(Wpm, 0)); } wait(50); blinky(2, 2, BLUE_LED); } else { _transportSM.failedUplinkTransmissions = 0; if (err_delivery_beat &lt; 5) { err_delivery_beat++; } if (err_delivery_beat == 4) { if (flag_nogateway_mode == 0) { gateway_fail(); CORE_DEBUG(PSTR("</span></span>MyS: LOST GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); } } } } if (_transportConfig.parentNodeId &gt; 0) { send(brightMsg.set(brightness, 0), 1); wait(2500, C_SET, V_LEVEL); if (Ack_TL == 1) { Ack_TL = 0; err_delivery_beat = 0; if (flag_nogateway_mode == 1) { flag_nogateway_mode = 0; CORE_DEBUG(PSTR("</span></span>MyS: NORMAL GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); err_delivery_beat = 0; } lastbrightness = brightness; if (wpm_enable == 1) { Wpm = GetWpm(); wait(100); send(wpmMsg.set(Wpm, 0)); } wait(50); blinky(2, 2, BLUE_LED); } else { _transportSM.failedUplinkTransmissions = 0; if (err_delivery_beat &lt; 5) { err_delivery_beat++; } if (err_delivery_beat == 4) { if (flag_nogateway_mode == 0) { gateway_fail(); CORE_DEBUG(PSTR("</span></span>MyS: LOST GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); } } } } } } else { send(brightMsg.set(brightness, 0)); lastbrightness = brightness; if (wpm_enable == 1) { Wpm = GetWpm(); wait(100); send(wpmMsg.set(Wpm, 0)); } wait(50); blinky(2, 2, BLUE_LED); } } void interrupt_Init() { //*** //SET //NRF_GPIO_PIN_NOPULL //NRF_GPIO_PIN_PULLUP //NRF_GPIO_PIN_PULLDOWN //*** nrf_gpio_cfg_input(PIN_BUTTON1, NRF_GPIO_PIN_PULLUP); nrf_gpio_cfg_input(AXEL_INT1, NRF_GPIO_PIN_NOPULL); APP_GPIOTE_INIT(APP_GPIOTE_MAX_USERS); PIN_BUTTON1_MASK = 1 &lt;&lt; PIN_BUTTON1; AXEL_INT1_MASK = 1 &lt;&lt; AXEL_INT1; // app_gpiote_user_register(p_user_id, pins_low_to_high_mask, pins_high_to_low_mask, event_handler) app_gpiote_user_register(&amp;m_gpiote_user_id, AXEL_INT1_MASK, PIN_BUTTON1_MASK, gpiote_event_handler); app_gpiote_user_enable(m_gpiote_user_id); axelInt1Status = 0; buttInt1Status = 0; } void gpiote_event_handler(uint32_t event_pins_low_to_high, uint32_t event_pins_high_to_low) { MY_HW_RTC-&gt;CC[0] = (MY_HW_RTC-&gt;COUNTER + 2); if (PIN_BUTTON1_MASK &amp; event_pins_high_to_low) { if ((buttInt1Status == 0) &amp;&amp; (axelInt1Status == 0)) { buttInt1Status = PIN_BUTTON1; } } if (flag_nogateway_mode == 0) { if (configMode == 0) { if (AXEL_INT1_MASK &amp; event_pins_low_to_high) { if ((axelInt1Status == 0) &amp;&amp; (buttInt1Status == 0)) { axelInt1Status = AXEL_INT1; } } } } /*** if ((PIN_BUTTON_MASK &amp; event_pins_low_to_high) || (PIN_BUTTON1_MASK &amp; event_pins_high_to_low)) ***/ } void device_Conf() { conf_vibro_set = loadState(230); if ((conf_vibro_set &gt; 5) || (conf_vibro_set == 0)) { conf_vibro_set = 1; saveState(230, conf_vibro_set); } wpm_enable = loadState(240); if (wpm_enable &gt; 1) { wpm_enable = 0; saveState(240, wpm_enable); } interval_reading_lux = loadState(220); if (interval_reading_lux &gt; 60) { interval_reading_lux = 60; saveState(230, interval_reading_lux); } else if (interval_reading_lux &lt; 1) { interval_reading_lux = 1; saveState(230, interval_reading_lux); } SLEEP_TIME = SLEEP_TIME_TEMP * interval_reading_lux; C_BATT_TIME = BATT_TIME / SLEEP_TIME; } void sendBatteryStatus(bool start) { sleep(5000); wait(200); batteryVoltage = hwCPUVoltage(); wait(10); batt_cap = battery_level_in_percent(batteryVoltage); if (start == 1) { if (batt_cap &lt; old_batt_cap) { sendBatteryLevel(battery_level_in_percent(batteryVoltage), 1); wait(2500, C_INTERNAL, I_BATTERY_LEVEL); old_batt_cap = batt_cap; } } else { sendBatteryLevel(battery_level_in_percent(batteryVoltage), 1); wait(2500, C_INTERNAL, I_BATTERY_LEVEL); } linkQuality = calculationRxQuality(); if (linkQuality != old_linkQuality) { wait(10); sendSignalStrength(linkQuality); wait(50); old_linkQuality = linkQuality; } } bool sendSignalStrength(const int16_t level, const bool ack) { return _sendRoute(build(_msgTmp, GATEWAY_ADDRESS, SIGNAL_Q_ID, C_SET, V_VAR1, ack).set(level)); } int16_t calculationRxQuality() { int16_t nRFRSSI_temp = transportGetReceivingRSSI(); int16_t nRFRSSI = map(nRFRSSI_temp, -85, -40, 0, 100); if (nRFRSSI &lt; 0) { nRFRSSI = 0; } if (nRFRSSI &gt; 100) { nRFRSSI = 100; } return nRFRSSI; } void happy_init() { //hwWriteConfig(EEPROM_NODE_ID_ADDRESS, 255); // ******************** checking the node config reset ************************* if (hwReadConfig(EEPROM_NODE_ID_ADDRESS) == 0) { hwWriteConfig(EEPROM_NODE_ID_ADDRESS, 255); } if (loadState(100) == 0) { saveState(100, 255); } CORE_DEBUG(PSTR("</span></span>EEPROM NODE ID: %d\n<span class="hljs-string"><span class="hljs-string">"), hwReadConfig(EEPROM_NODE_ID_ADDRESS)); CORE_DEBUG(PSTR("</span></span>USER MEMORY SECTOR NODE ID: %d\n<span class="hljs-string"><span class="hljs-string">"), loadState(100)); if (hwReadConfig(EEPROM_NODE_ID_ADDRESS) == 255) { mtwr = 0; } else { mtwr = 10000; no_present(); } CORE_DEBUG(PSTR("</span></span>MY_TRANSPORT_WAIT_MS: %d\n<span class="hljs-string"><span class="hljs-string">"), mtwr); } void new_device() { hwWriteConfig(EEPROM_NODE_ID_ADDRESS, 255); saveState(100, 255); wdt_enable(WDTO_15MS); } void config_Happy_node() { if (mtwr == 0) { myid = getNodeId(); saveState(100, myid); mypar = _transportConfig.parentNodeId; old_mypar = mypar; master_id = 0; // *************************** master slave mode is not initialized in this example, ..stub ******************************* saveState(101, mypar); saveState(102, _transportConfig.distanceGW); } if (mtwr != 0) { myid = getNodeId(); if (myid != loadState(100)) { saveState(100, myid); } if (isTransportReady() == true) { mypar = _transportConfig.parentNodeId; master_id = 0; // *************************** master slave mode is not initialized in this example, ..stub ******************************* if (mypar != loadState(101)) { saveState(101, mypar); } if (_transportConfig.distanceGW != loadState(102)) { saveState(102, _transportConfig.distanceGW); } present_only_parent(); } if (isTransportReady() == false) { no_present(); flag_fcount = 1; err_delivery_beat = 5; _transportConfig.nodeId = myid; _transportConfig.parentNodeId = loadState(101); _transportConfig.distanceGW = loadState(102); mypar = _transportConfig.parentNodeId; happy_node_mode(); gateway_fail(); } } } void no_present() { _coreConfig.presentationSent = true; _coreConfig.nodeRegistered = true; } void happy_node_mode() { _transportSM.findingParentNode = false; _transportSM.transportActive = true; _transportSM.uplinkOk = true; _transportSM.pingActive = false; transportSwitchSM(stReady); _transportSM.failureCounter = 0; } void gateway_fail() { flag_nogateway_mode = 1; flag_update_transport_param = 0; SLEEP_TIME_W = SLEEP_TIME / 2; lis2-&gt;Disable_Wake_Up_Detection(); } void find_parent_process() { flag_update_transport_param = 1; flag_find_parent_process = 0; CORE_DEBUG(PSTR("</span></span>MyS: STANDART TRANSPORT MODE IS RESTORED\n<span class="hljs-string"><span class="hljs-string">")); err_delivery_beat = 0; lis2-&gt;Enable_Wake_Up_Detection(); } void update_Happy_transport() { CORE_DEBUG(PSTR("</span></span>MyS: UPDATE TRANSPORT CONFIGURATION\n<span class="hljs-string"><span class="hljs-string">")); mypar = _transportConfig.parentNodeId; master_id = 0; // *************************** master slave mode is not initialized in this example, ..stub ******************************* if (mypar != loadState(101)) { saveState(101, mypar); } if (_transportConfig.distanceGW != loadState(102)) { saveState(102, _transportConfig.distanceGW); } present_only_parent(); wait(50); nosleep = 0; flag_update_transport_param = 0; } void present_only_parent() { if (old_mypar != mypar) { CORE_DEBUG(PSTR("</span></span>MyS: SEND LITTLE PRESENT:) WITH PARENT ID\n<span class="hljs-string"><span class="hljs-string">")); if (_sendRoute(build(_msgTmp, 0, NODE_SENSOR_ID, C_INTERNAL, 6).set(mypar))) { flag_sendRoute_parent = 0; old_mypar = mypar; } else { flag_sendRoute_parent = 1; } } } void check_parent() { _transportSM.findingParentNode = true; CORE_DEBUG(PSTR("</span></span>MyS: SEND FIND PARENT REQUEST, WAIT RESPONSE\n<span class="hljs-string"><span class="hljs-string">")); _sendRoute(build(_msg, 255, NODE_SENSOR_ID, C_INTERNAL, 7).set("</span></span><span class="hljs-string"><span class="hljs-string">")); wait(1500, C_INTERNAL, 8); if (_msg.sensor == 255) { if (mGetCommand(_msg) == 3) { if (_msg.type == 8) { Ack_FP = 1; CORE_DEBUG(PSTR("</span></span>MyS: PARENT RESPONSE FOUND\n<span class="hljs-string"><span class="hljs-string">")); } } } if (Ack_FP == 1) { CORE_DEBUG(PSTR("</span></span>MyS: FIND PARENT PROCESS\n<span class="hljs-string"><span class="hljs-string">")); Ack_FP = 0; transportSwitchSM(stParent); flag_nogateway_mode = 0; flag_find_parent_process = 1; SLEEP_TIME_W = SLEEP_TIME; problem_mode_count = 0; } else { _transportSM.findingParentNode = false; CORE_DEBUG(PSTR("</span></span>MyS: PARENT RESPONSE NOT FOUND\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; nosleep = 0; if (problem_mode_count &lt; 24) { CORE_DEBUG(PSTR("</span></span>PROBLEM MODE COUNTER: %d\n<span class="hljs-string"><span class="hljs-string">"), problem_mode_count); problem_mode_count++; SLEEP_TIME_W = SLEEP_TIME / 100 * 120; } else if (problem_mode_count == 24) { SLEEP_TIME_W = SLEEP_TIME * 30; CORE_DEBUG(PSTR("</span></span>PROBLEM MODE COUNTER: %d\n<span class="hljs-string"><span class="hljs-string">"), problem_mode_count); } } } void receive(const MyMessage &amp; message) { if (message.sensor == ENABLE_WPM_SENS_CHILD_ID) { if (message.type == V_VAR1) { if (mGetCommand(message) == C_SET) { if (message.isEcho()) { Ack_TL = 1; } else { wpm_enable = message.getBool(); saveState(240, wpm_enable); wait(10); send(conf_wpmMsg.set(wpm_enable)); wait(50); blinky(3, 3, GREEN_LED); configMode = 0; nosleep = 0; button_flag = 0; buttInt1Status = 0; } } } } if (message.sensor == LEVEL_SENSIV_V_SENS_CHILD_ID) { if (message.type == V_VAR1) { if (mGetCommand(message) == C_SET) { if (message.isEcho()) { Ack_TL = 1; } else { conf_vibro_set = message.getByte(); vibro_Init(); saveState(230, conf_vibro_set); wait(10); send(conf_vsensMsg.set(conf_vibro_set)); wait(50); blinky(3, 3, GREEN_LED); configMode = 0; nosleep = 0; button_flag = 0; buttInt1Status = 0; } } } } if (message.sensor == INTERVAL_R_LUX_CHILD_ID) { if (message.type == V_VAR1) { if (mGetCommand(message) == C_SET) { if (message.isEcho()) { Ack_TL = 1; } else { interval_reading_lux = message.getByte(); SLEEP_TIME = SLEEP_TIME_TEMP * interval_reading_lux; C_BATT_TIME = BATT_TIME / SLEEP_TIME; saveState(220, interval_reading_lux); wait(10); send(conf_interv_rluxMsg.set(interval_reading_lux)); wait(50); blinky(3, 3, GREEN_LED); configMode = 0; nosleep = 0; button_flag = 0; buttInt1Status = 0; } } } } if (message.sensor == LUX_SENS_CHILD_ID) { if (message.type == V_LEVEL) { if (mGetCommand(message) == C_SET) { if (message.isEcho()) { Ack_TL = 1; } } } } if (message.sensor == V_SENS_CHILD_ID) { if (message.type == V_TRIPPED) { if (mGetCommand(message) == C_SET) { if (message.isEcho()) { Ack_TL = 1; } } } } if (mGetCommand(message) == 0) { PRESENT_ACK = 1; CORE_DEBUG(PSTR("</span></span>MyS: !!!ACK OF THE PRESENTATION IN THE FUNCTION RECEIVE RECEIVED!!!\n<span class="hljs-string"><span class="hljs-string">")); } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Project github (bibliotecas adicionales, fuentes de proyectos, esquemas, gerberas, BOM): </font></font><br> <a href="https://github.com/smartboxchannel/EFEKTA-LIS2DW12-MAX44009-E73C" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/smartboxchannel/EFEKTA-LIS2DW12-MAX44009-E73C </font></font></a> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caracter√≠sticas del sensor:</font></font></b> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rango de voltaje de operaci√≥n 2-3 V, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6.7ŒºA en modo de reposo, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8 mA en modo de red, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E73-2G4M08S1C nRF52840, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sensor de luz ambiental MAX44009, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LIS2DW12 \ LIS2DH12 Aceler√≥metro MEMS de 3 ejes, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LED RGB </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usuario botton, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puerto de programaci√≥n SWD + Serial. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A continuaci√≥n se muestra un ejemplo del funcionamiento del sensor en el sistema Majordomo UD, naturalmente funcionar√° en cualquier UD en el que se agregue el soporte del protocolo MySensors, y esto es casi todo lo que se conoce. </font></font><br><br><img src="https://habrastorage.org/webt/bm/xj/zj/bmxjzjfpzn0wuvccte-w5xqtn3e.png"><br><br><img src="https://habrastorage.org/webt/5t/9k/xr/5t9kxrdt4agswilm1yukte51m4g.jpeg"><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video con el interior de la placa, un ejemplo de un sensor, un ejemplo de configuraci√≥n</font></font></b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/I2ywIxp-RsE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foto del sensor</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/wc/xl/hk/wcxlhkb-zb-paorsmpqx4jwkg-4.jpeg"><br><br><img src="https://habrastorage.org/webt/mh/f-/ak/mhf-akawv5xgbnuijpdv0edgcoo.jpeg"><br><br><img src="https://habrastorage.org/webt/ie/1q/ig/ie1qign_51mb0ya5ysfiurmdgkm.jpeg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probablemente redondear√© esto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un lugar donde siempre estar√° feliz de ayudar a todos los que quieran conocer MYSENSORS (instalar tableros, trabajar con microcontroladores nRF5 en el entorno Arduino IDE, consejos para trabajar con el protocolo mysensors, discutir proyectos - telegram chat </font></font><a href="https://tgclick.com/mysensors_rus" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@mysensors_rus ¬°</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buena suerte y buena suerte en sus proyectos! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS / Share con planes inmediatos, pronto se publicar√° un art√≠culo sobre un </font></font><a href="https://habr.com/ru/post/452532/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">borrador</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> actualizado </font><a href="https://habr.com/ru/post/452532/"><font style="vertical-align: inherit;">de</font></a><font style="vertical-align: inherit;"> mi sensor de temperatura y humedad con una pantalla de tinta electr√≥nica, finalmente ahora es un dispositivo terminado y no un m√≥dulo, tambi√©n habr√° un art√≠culo sobre un sensor abierto / cerrado con un interruptor de l√°minas, aceler√≥metro y sensor </font><font style="vertical-align: inherit;">campo magn√©tico y codificador en nRF52811. Fotos y video a continuaci√≥n en el spoiler.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/T66y83lF-xg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><img src="https://habrastorage.org/webt/rg/dh/u2/rgdhu2htxcazyavpoh5mgf71hfo.jpeg"><br><br><img src="https://habrastorage.org/webt/uz/mx/_n/uzmx_nvuyazh3nihtfjxgb_tkpi.jpeg"><br><br><img src="https://habrastorage.org/webt/xn/7s/a2/xn7sa2lbrn3g2jvje5mr1wbcuh8.jpeg"><br><br><img src="https://habrastorage.org/webt/4y/-s/la/4y-slajjmwr_ydmqdq0v2vcify4.jpeg"><br><br><img src="https://habrastorage.org/webt/90/ub/i7/90ubi72wfku6mlf7dshkfl2nqfo.jpeg"><br><br><img src="https://habrastorage.org/webt/p9/fe/9e/p9fe9ehr29jqggmkhutdipmqygu.jpeg"><br><br><img src="https://habrastorage.org/webt/sn/gm/ou/sngmou0381zr6ias3gbtsfez3lg.jpeg"><br><br><img src="https://habrastorage.org/webt/o5/t2/j-/o5t2j-gncldts6gsxg7kxl26dce.jpeg"><br><br><img src="https://habrastorage.org/webt/jt/vl/ro/jtvlrov-l3qclnkgilhu7aqpls4.jpeg"><br><br><img src="https://habrastorage.org/webt/be/3v/je/be3vjejo_xhuxhpc_hyg9fmz4ns.jpeg"><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/478960/">https://habr.com/ru/post/478960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../478950/index.html">Los resultados de la semana: Huawei se adapta a las sanciones, Putin firma leyes sensacionales y ShutterStock est√° bloqueado en Rusia</a></li>
<li><a href="../478952/index.html">Un mes con Onyx Boox Note Pro</a></li>
<li><a href="../478954/index.html">RE: Miedo y asco en TI</a></li>
<li><a href="../478956/index.html">Presentamos 3CX V16 Update 4 Beta con un cliente Chrome VoIP y una aplicaci√≥n de video para Android</a></li>
<li><a href="../478958/index.html">Gu√≠a completa de actualizaci√≥n de Windows 10 para empresas de cualquier tama√±o</a></li>
<li><a href="../478962/index.html">Ilya Yakyamsev: la eficiencia no funciona</a></li>
<li><a href="../478966/index.html">¬øC√≥mo sobrevivir y convertirse en un desarrollador frontend en el mundo moderno?</a></li>
<li><a href="../478968/index.html">SpaceX lanza nanoracks para crear estaciones orbitales de desechos espaciales</a></li>
<li><a href="../478970/index.html">Bot√≥n de llamada de bricolaje parte 2. Videotel√©fono de Raspberry Pi</a></li>
<li><a href="../478972/index.html">Ganadores del concurso de plataformas Miro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>