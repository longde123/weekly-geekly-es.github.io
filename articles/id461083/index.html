<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèæ üéÖüèª üëºüèΩ Menulis perangkat lunak dengan fungsi utilitas klien-server Windows, bagian 02 üë®üèª‚Äçüéì ‚èπÔ∏è ü§∏üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Melanjutkan serangkaian artikel tentang implementasi kustom utilitas konsol di Windows, TFTP (Trivial File Transfer Protocol) adalah protokol transfer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menulis perangkat lunak dengan fungsi utilitas klien-server Windows, bagian 02</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461083/">  Melanjutkan serangkaian artikel tentang implementasi kustom utilitas konsol di Windows, TFTP (Trivial File Transfer Protocol) adalah protokol transfer file sederhana. <br><br>  Seperti terakhir kali, kita membahas teori secara singkat, melihat kode yang mengimplementasikan fungsional yang mirip dengan yang diperlukan, dan menganalisisnya.  Baca lebih lanjut - di bawah potongan <a name="habracut"></a><br><br>  Saya tidak akan menyalin-rekatkan informasi rujukan, tautan yang secara tradisional dapat ditemukan di akhir artikel, saya hanya akan mengatakan bahwa TFTP pada dasarnya adalah variasi yang disederhanakan dari protokol FTP, yang menghilangkan pengaturan kontrol akses, dan sebenarnya tidak ada apa-apa di sini selain perintah untuk menerima dan mentransfer file. .  Namun, untuk membuat implementasi kami sedikit lebih elegan dan disesuaikan dengan prinsip-prinsip penulisan kode saat ini, sintaks sedikit berubah - itu tidak mengubah prinsip kerja, tetapi antarmuka, IMHO, menjadi sedikit lebih logis dan menggabungkan aspek positif dari FTP dan TFTP. <br><br>  Secara khusus, ketika memulai, klien meminta alamat ip server dan port tempat custom TFTP terbuka (karena ketidakcocokan dengan protokol standar, saya menganggap pantas untuk meninggalkan opsi untuk memilih port ke pengguna), setelah itu terjadi koneksi, akibatnya klien dapat mengirim salah satu perintah - dapatkan atau masukkan, untuk menerima atau mengirim file ke server.  Semua file dikirim dalam mode biner - untuk menyederhanakan logika. <br><br>  Untuk implementasi protokol, saya secara tradisional menggunakan 4 kelas: <br><br><ul><li>  TFTPClient </li><li>  TFTPServer </li><li>  TFTPClientTester </li><li>  TFTPServerTester </li></ul><br>  Karena fakta bahwa kelas pengujian hanya ada untuk debugging yang utama, saya tidak akan menganalisisnya, tetapi kode akan berada di repositori, tautan ke sana dapat ditemukan di akhir artikel.  Dan sekarang saya akan mengerti kelas utama. <br><br><h4>  TFTPClient </h4><br>  Tugas kelas ini adalah untuk menyambung ke server jarak jauh dengan nomor ip dan port-nya, membaca perintah dari aliran input (dalam hal ini, keyboard), menguraikannya, mentransfernya ke server, dan tergantung pada apakah Anda ingin mentransfer atau menerima file, mentransfernya atau untuk menerima. <br><br>  Kode peluncuran klien untuk menghubungkan ke server dan menunggu perintah dari aliran input terlihat seperti ini.  Sejumlah variabel global yang digunakan di sini dijelaskan di luar artikel, dalam teks lengkap program.  Karena kesederhanaan mereka, saya tidak mengutip agar tidak membebani artikel. <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> port)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ip = ip; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.port = port; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { inicialization(); Scanner keyboard = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scanner(System.in); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (isRunning) { getAndParseInput(keyboard); sendCommand(); selector(); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { System.out.println(e.getMessage()); } }</code> </pre> <br>  Mari kita membahas metode yang disebut dalam blok kode ini: <br><br>  Di sini file dikirim - menggunakan pemindai, kami menyajikan konten file sebagai array byte, yang kami tulis ke soket satu per satu, lalu tutup dan buka kembali (bukan solusi yang paling jelas, tetapi menjamin pelepasan sumber daya), setelah itu kami menampilkan pesan tentang kesuksesan transmisi. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String sourcePath, String destPath)</span></span></span><span class="hljs-function"> </span></span>{ File src = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(sourcePath); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { InputStream scanner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(src); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytes = scanner.readAllBytes(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> b : bytes) sout.write(b); sout.close(); inicialization(); System.out.println(<span class="hljs-string"><span class="hljs-string">"\nDone\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { System.out.println(e.getMessage()); } }</code> </pre> <br>  Fragmen kode ini menjelaskan penerimaan data dari server.  Semuanya sepele lagi, hanya blok kode pertama yang menarik.  Untuk memahami dengan tepat berapa banyak byte yang perlu Anda baca dari soket, Anda perlu tahu berapa berat file yang ditransfer.  Ukuran file di server tampaknya bilangan bulat panjang, jadi 4 byte diterima di sini, yang kemudian dikonversi ke satu nomor.  Ini bukan pendekatan yang sangat Java, ini agak mirip untuk SI, tetapi menyelesaikan masalahnya. <br><br>  Kemudian semuanya sepele - kita mendapatkan jumlah byte yang diketahui dari soket dan menuliskannya ke file, setelah itu kita menampilkan pesan sukses. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String sourcePath, String destPath)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sizeOfFile = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] sizeBytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[Long.SIZE]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i =<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt; Long.SIZE/Byte.SIZE; i++) { sizeBytes[i] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)sin.read(); sizeOfFile*=<span class="hljs-number"><span class="hljs-number">256</span></span>; sizeOfFile+=sizeBytes[i]; } FileOutputStream writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(destPath)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i =<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; sizeOfFile; i++) { writer.write(sin.read()); } writer.close(); System.out.println(<span class="hljs-string"><span class="hljs-string">"\nDONE\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e){ System.out.println(e.getMessage()); } }</code> </pre> <br>  Jika perintah selain get atau put dimasukkan ke dalam jendela klien, fungsi showErrorMessage akan dipanggil, menunjukkan kesalahan input.  Karena hal-hal sepele - Saya tidak mengutip.  Yang agak lebih menarik adalah fungsi mendapatkan dan memisahkan string input.  Kami melewati pemindai untuk itu, dari mana kami berharap untuk menerima garis yang dipisahkan oleh dua spasi dan berisi perintah, alamat sumber, dan alamat tujuan. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAndParseInput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Scanner scanner)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { input = scanner.nextLine().split(<span class="hljs-string"><span class="hljs-string">" "</span></span>); typeOfCommand = input[<span class="hljs-number"><span class="hljs-number">0</span></span>]; sourcePath = input[<span class="hljs-number"><span class="hljs-number">1</span></span>]; destPath = input[<span class="hljs-number"><span class="hljs-number">2</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bad input"</span></span>); } }</code> </pre> <br>  Mengirim perintah - mengirim perintah yang dimasukkan dari pemindai ke soket dan memaksanya untuk dikirim <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String str : input) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch : str.toCharArray()) { sout.write(ch); } sout.write(<span class="hljs-string"><span class="hljs-string">' '</span></span>); } sout.write(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { System.out.print(e.getMessage()); } }</code> </pre> <br>  Selector adalah fungsi yang menentukan tindakan suatu program tergantung pada string input.  Semuanya tidak terlalu indah di sini dan trik yang tidak begitu baik dengan memaksa blok kode yang digunakan digunakan, tetapi alasan utama untuk ini adalah tidak adanya di Jawa beberapa hal, seperti delegasi dalam C #, petunjuk ke fungsi dari C ++, atau setidaknya goto menakutkan dan mengerikan, yang biarkan Anda menyadarinya dengan indah.  Jika Anda tahu cara membuat kode sedikit lebih elegan, saya menunggu kritik di komentar.  Tampaknya bagi saya bahwa kamus String-delegate diperlukan di sini, tetapi tidak ada delegasi ... <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">selector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typeOfCommand.equals(<span class="hljs-string"><span class="hljs-string">"get"</span></span>)){ get(sourcePath, destPath); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typeOfCommand.equals(<span class="hljs-string"><span class="hljs-string">"put"</span></span>)){ put(sourcePath, destPath); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } showErrorMessage(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } }</code> </pre> <br><h4>  TFTPServer </h4><br>  Fungsionalitas server berbeda dari fungsionalitas klien pada umumnya hanya dalam perintah yang datang bukan dari keyboard, tetapi dari soket.  Beberapa metode bertepatan, jadi saya tidak akan memberikannya, saya hanya akan menyebutkan perbedaannya. <br><br>  Untuk memulai di sini, metode jalankan digunakan, yang menerima port untuk input dan memproses data input dari soket dalam siklus abadi. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> port)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.port = port; incialization(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { getAndParseInput(); selector(); } }</code> </pre> <br>  Metode put, yang merupakan pembungkus metode writeToFileFromSocket, yang membuka aliran penulisan ke file dan menulis semua byte input dari soket, setelah perekaman selesai, menampilkan pesan tentang keberhasilan penyelesaian transfer. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String source, String dest)</span></span></span></span>{ writeToFileFromSocket(); System.out.print(<span class="hljs-string"><span class="hljs-string">"\nDone\n"</span></span>); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeToFileFromSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { FileOutputStream writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(destPath)); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytes = sin.readAllBytes(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> b : bytes) { writer.write(b); } writer.close(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e){ System.out.println(e.getMessage()); } }</code> </pre> <br>  Metode get menyediakan file server.  Seperti yang telah disebutkan di bagian sisi klien dari program, untuk berhasil mentransfer file, Anda perlu tahu ukurannya, disimpan dalam bilangan bulat panjang, jadi saya membaginya menjadi array 4 byte, mentransfernya ke soket byte, dan kemudian, setelah menerima dan mengumpulkannya di klien kembali ke nomor, saya mentransfer semua byte yang membentuk file, baca dari aliran input dari file. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String source, String dest)</span></span></span></span>{ File sending = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(source); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { FileInputStream readFromFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(sending); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] arr = readFromFile.readAllBytes(); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytes = ByteBuffer.allocate(Long.SIZE / Byte.SIZE).putLong(sending.length()).array(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;Long.SIZE / Byte.SIZE; i++) sout.write(bytes[i]); sout.flush(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> b : arr) sout.write(b); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e){ System.out.println(e.getMessage()); } };</code> </pre> <br>  Metode getAndParseInput sama dengan di klien, satu-satunya perbedaan adalah bahwa ia membaca data dari soket, dan bukan dari keyboard.  Kode dalam repositori, seperti pemilih. <br>  Dalam hal ini, inisialisasi dibuat dalam blok kode yang terpisah, karena  dalam kerangka implementasi ini, setelah transfer selesai, sumber daya dibebaskan dan ditempati lagi, lagi dengan tujuan memberikan perlindungan terhadap kebocoran memori. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { serverSocket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ServerSocket(port); socket = serverSocket.accept(); sin = socket.getInputStream(); sout = socket.getOutputStream(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { System.out.print(e.getMessage()); } }</code> </pre> <br>  Singkatnya: <br><br>  Kami baru saja menulis variasi kami pada protokol transfer data sederhana dan menemukan cara kerjanya.  Pada prinsipnya, saya tidak menemukan Amerika dan tidak menulis banyak hal baru, tetapi - tidak ada artikel serupa tentang Habr√©, dan sebagai bagian dari menulis serangkaian artikel tentang utilitas CMD, tidak mungkin untuk tidak menyentuh dia. <br><br>  Referensi: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Repositori kode sumber</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Secara singkat tentang TFTP</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hal yang sama, tetapi dalam bahasa Rusia</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461083/">https://habr.com/ru/post/id461083/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461073/index.html">Kami menghubungkan peta online ke navigator di smartphone. Bagian 3 - OverpassTurbo</a></li>
<li><a href="../id461075/index.html">Kecerdasan bisnis. Objek IT, komponen, alat</a></li>
<li><a href="../id461077/index.html">Bagaimana pentester dimasak? Pengujian Pintu Masuk untuk Interns Keamanan Digital</a></li>
<li><a href="../id461079/index.html">Kota tanpa kemacetan lalu lintas</a></li>
<li><a href="../id461081/index.html">Hari ketika Dodo berhenti. Skrip asinkron</a></li>
<li><a href="../id461085/index.html">Beralih bahasa di aplikasi Android</a></li>
<li><a href="../id461087/index.html">Menghasilkan ruang bawah tanah dan gua untuk game saya</a></li>
<li><a href="../id461091/index.html">Lampu Camelion LED</a></li>
<li><a href="../id461093/index.html">Berita dari dunia OpenStreetMap No. 469 (07/09/2019 - 07/07/2019)</a></li>
<li><a href="../id461095/index.html">Apollo Guidance Computer - arsitektur dan perangkat lunak sistem. Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>