<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñêüèΩ üìÑ üßúüèº Como os gr√°ficos de rede neural ajudaram üêò üë©üèø‚Äçüíº üö´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em 1943, os neuropsic√≥logos americanos McCallock e Pitts desenvolveram um modelo de computador de uma rede neural e, em 1958, a primeira rede de camad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como os gr√°ficos de rede neural ajudaram</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/441260/">  Em 1943, os neuropsic√≥logos americanos McCallock e Pitts desenvolveram um modelo de computador de uma rede neural e, em 1958, a <strong>primeira</strong> rede de camada √∫nica em <strong>funcionamento</strong> reconheceu algumas letras.  Agora, as redes neurais n√£o s√£o usadas apenas para qu√™: prever a taxa de c√¢mbio, diagnosticar doen√ßas, pilotos autom√°ticos e criar gr√°ficos em jogos de computador.  Apenas sobre o √∫ltimo e conversar. <br><br>  <strong>Evgeni Tumanov</strong> trabalha como engenheiro de Deep Learning na <strong>NVIDIA</strong> .  Com base nos resultados de seu discurso na confer√™ncia HighLoad ++, preparamos uma hist√≥ria sobre o uso de Machine Learning e Deep Learning em gr√°ficos.  O aprendizado de m√°quina n√£o termina com PNL, Vis√£o por Computador, sistemas de recomenda√ß√£o e tarefas de pesquisa.  Mesmo se voc√™ n√£o estiver familiarizado com essa √°rea, poder√° aplicar as melhores pr√°ticas do artigo em seu campo ou setor. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/eeCYmJQAyKA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  A hist√≥ria consistir√° em tr√™s partes.  Analisaremos as tarefas no gr√°fico que s√£o resolvidas com a ajuda do aprendizado de m√°quina, derivaremos a ideia principal e descreveremos o caso de aplic√°-la em uma tarefa espec√≠fica e, especificamente, na <b>renderiza√ß√£o de nuvens</b> . <a name="habracut"></a><br><br><h2>  DL / ML supervisionado em gr√°ficos ou treinamento de professores em gr√°ficos </h2><br>  Vamos analisar dois grupos de tarefas.  Para come√ßar, denote-os brevemente. <br><br>  <strong>Mundo real ou mecanismo de renderiza√ß√£o</strong> : <br><br><ul><li>  Cria√ß√£o de anima√ß√µes cred√≠veis: locomo√ß√£o, anima√ß√£o facial. </li><li>  P√≥s-processamento de imagens renderizadas: superamostragem, suaviza√ß√£o de serrilhado. </li><li>  Slow Motion: interpola√ß√£o de quadros. </li><li>  Gera√ß√£o de materiais. </li></ul><br>  O segundo grupo de tarefas agora √© chamado convencionalmente de " <strong>algoritmo pesado</strong> ".  Inclu√≠mos tarefas como renderizar objetos complexos, como nuvens e <strong>simula√ß√µes f√≠sicas</strong> : √°gua, fuma√ßa. <br><br>  Nosso objetivo √© entender a diferen√ßa fundamental entre os dois grupos.  Vamos considerar as tarefas com mais detalhes. <br><br><h3>  Cria√ß√£o de anima√ß√µes cred√≠veis: locomo√ß√£o, anima√ß√£o facial <br></h3><br>  Nos √∫ltimos anos, muitos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigos apareceram</a> , onde os pesquisadores oferecem novas maneiras de gerar belas anima√ß√µes.  Usar o trabalho de artistas √© caro, e substitu√≠-los por um algoritmo seria muito ben√©fico para todos.  H√° um ano, na NVIDIA, est√°vamos trabalhando em um projeto no qual est√°vamos envolvidos em anima√ß√£o facial de personagens em jogos: sincronizando o rosto do her√≥i com a trilha sonora do discurso.  Tentamos "reviver" o rosto para que todos os pontos se movessem e, acima de tudo, os l√°bios, porque esse √© o momento mais dif√≠cil da anima√ß√£o.  Manualmente, um artista faz isso caro e por um longo tempo.  Quais s√£o as op√ß√µes para resolver esse problema e criar um <strong>conjunto</strong> de <strong>dados</strong> para ele? <br><br>  A primeira op√ß√£o √© <strong>identificar as vogais: a boca se abre e as consoantes se fecham</strong> .  Este √© um algoritmo simples, mas muito simples.  Nos jogos, queremos mais qualidade.  A segunda op√ß√£o √© <strong>fazer</strong> com <strong>que as pessoas leiam textos diferentes e escrevam seus rostos e depois compare as letras que pronunciam com express√µes faciais.</strong>  √â uma boa ideia, e fizemos isso em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">projeto</a> conjunto com a Remedy Entertainment.  A √∫nica diferen√ßa √© que no jogo n√£o estamos mostrando um v√≠deo, mas um modelo 3D de pontos.  Para montar um conjunto de dados, voc√™ precisa entender como os pontos espec√≠ficos da face se movem.  Pegamos atores, pedimos para ler textos com entona√ß√µes diferentes, filmamos em c√¢meras muito boas de diferentes √¢ngulos, ap√≥s o que restauramos o modelo 3D de rostos em cada quadro e previmos a posi√ß√£o dos pontos no rosto pelo som. <br><br><h3>  P√≥s-processamento de imagem renderizada: superamostragem, anti-aliasing <br></h3><br>  Considere um caso de um jogo espec√≠fico: temos um mecanismo que gera imagens em diferentes resolu√ß√µes.  Queremos renderizar a imagem em uma resolu√ß√£o de 1000 √ó 500 pixels e mostrar ao player 2000 √ó 1000 - isso ser√° mais bonito.  Como montar um conjunto de dados para esta tarefa? <br><br>  Primeiro, renderize a imagem em alta resolu√ß√£o, abaixe a qualidade e tente treinar o sistema para converter a imagem de baixa resolu√ß√£o para alta resolu√ß√£o. <br><br><h3>  Slow Motion: interpola√ß√£o de quadros <br></h3><br>  Temos um v√≠deo e queremos que a rede adicione quadros no meio - para interpolar quadros.  A id√©ia √© √≥bvia - gravar um v√≠deo real com um grande n√∫mero de quadros, remover os intermedi√°rios e tentar prever o que foi removido pela rede. <br><br><h3>  Gera√ß√£o de material <br></h3><br>  N√£o vamos nos concentrar muito na gera√ß√£o de materiais.  Sua ess√™ncia √© que pegamos, por exemplo, um peda√ßo de madeira em v√°rios √¢ngulos de ilumina√ß√£o e interpolamos a vista de outros √¢ngulos. <br><br>  Examinamos o primeiro grupo de problemas.  O segundo √© fundamentalmente diferente.  Falaremos sobre a renderiza√ß√£o de objetos complexos, como nuvens, mais tarde, mas agora vamos lidar com simula√ß√µes f√≠sicas. <br><br><h3>  Simula√ß√µes f√≠sicas de √°gua e fuma√ßa <br></h3><br>  Imagine uma piscina na qual objetos s√≥lidos em movimento est√£o localizados.  Queremos prever o movimento de part√≠culas fluidas.  Existem part√≠culas na piscina no tempo <strong>t</strong> , e no tempo <strong>t + Œît</strong> queremos obter sua posi√ß√£o.  Para cada part√≠cula, chamamos de rede neural e obtemos uma resposta onde ela estar√° no pr√≥ximo quadro. <br><br>  Para resolver o problema, usamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a</a> <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">equa√ß√£o de Navier-Stokes</a></strong> , que descreve o movimento de um fluido.  Para uma simula√ß√£o plaus√≠vel e fisicamente correta da √°gua, teremos que resolver a equa√ß√£o ou aproxima√ß√£o a ela.  Isso pode ser feito de maneira computacional, da qual muitos foram inventados nos √∫ltimos 50 anos: o algoritmo SPH, FLIP ou Fluido Baseado em Posi√ß√£o. <br><br><h3>  A diferen√ßa entre o primeiro grupo de tarefas do segundo <br></h3><br>  No primeiro grupo, o professor do algoritmo √© algo acima: uma grava√ß√£o da vida real, como no caso de indiv√≠duos, ou algo do mecanismo, por exemplo, renderizando imagens.  No segundo grupo de problemas, usamos o m√©todo da matem√°tica computacional.  A partir dessa divis√£o tem√°tica, uma id√©ia cresce. <br><br><h2>  Ideia principal <br></h2><br>  Temos uma tarefa computacionalmente complexa que √© longa, dif√≠cil e dif√≠cil de resolver pelo m√©todo cl√°ssico da universidade de computa√ß√£o.  Para resolv√™-lo e acelerar, talvez at√© perdendo um pouco de qualidade, precisamos: <br><br><blockquote><ul><li>  encontre o lugar que consome mais tempo na tarefa em que o c√≥digo dura mais tempo; </li><li>  veja o que essa linha produz; </li><li>  tente prever o resultado de uma linha usando uma rede neural ou qualquer outro algoritmo de aprendizado de m√°quina. </li></ul></blockquote><br>  Essa √© uma metodologia geral e a id√©ia principal √© uma receita sobre como encontrar aplicativos para aprendizado de m√°quina.  O que voc√™ deve fazer para tornar essa ideia √∫til?  N√£o existe uma resposta exata - use a criatividade, veja seu trabalho e encontre-o.  Eu fa√ßo gr√°ficos e n√£o estou t√£o familiarizado com outros campos, mas posso imaginar que no ambiente acad√™mico - em f√≠sica, qu√≠mica, rob√≥tica - voc√™ pode definitivamente encontrar aplica√ß√£o.  Se voc√™ resolver uma equa√ß√£o f√≠sica complexa em seu local de trabalho, tamb√©m poder√° encontrar um aplicativo para essa ideia.  Para maior clareza, considere um caso espec√≠fico. <br><br><h2>  Tarefa de renderiza√ß√£o em nuvem <br></h2><br>  Estivemos envolvidos neste projeto na NVIDIA h√° seis meses: a tarefa √© desenhar uma nuvem fisicamente correta, representada como a densidade de got√≠culas de l√≠quido no espa√ßo. <br><br><blockquote>  Uma nuvem √© um objeto fisicamente complexo, uma suspens√£o de got√≠culas l√≠quidas que n√£o podem ser modeladas como um objeto s√≥lido. </blockquote><br>  N√£o ser√° poss√≠vel impor uma textura e renderizar na nuvem, porque as gotas de √°gua s√£o dif√≠ceis geometricamente localizadas no espa√ßo 3D e s√£o complexas em si mesmas: elas praticamente n√£o absorvem a cor, mas a refletem anisotropicamente - em todas as dire√ß√µes de diferentes maneiras. <br><br>  Se voc√™ observar uma gota de √°gua na qual o sol brilha e os vetores do olho e do sol em uma gota forem paralelos, ser√° observado um grande pico de intensidade de luz.  Isso explica o fen√¥meno f√≠sico que todos j√° viram: em dias ensolarados, uma das margens da nuvem √© muito brilhante, quase branca.  Estamos olhando para a borda da nuvem, e a linha de vis√£o e o vetor dessa borda para o sol s√£o quase paralelos. <br><img src="https://habrastorage.org/webt/yt/hz/ij/ythzijgn-xfjhl3xri9mefn4vrg.png"><br><br>  A nuvem √© um objeto fisicamente complexo e sua renderiza√ß√£o pelo algoritmo cl√°ssico requer muito tempo.  Falaremos sobre o algoritmo cl√°ssico um pouco mais tarde.  Dependendo dos par√¢metros, o processo pode levar horas ou at√© dias.  Imagine que voc√™ √© um artista e desenhe um filme com efeitos especiais.  Voc√™ tem uma cena complicada com ilumina√ß√£o diferente com a qual deseja brincar.  Desenhamos uma topologia em nuvem - eu n√£o gosto, e voc√™ deseja redesenhar e obter uma resposta aqui.  √â importante obter uma resposta de uma altera√ß√£o de par√¢metro o mais r√°pido poss√≠vel.  Isso √© um problema.  Portanto, vamos tentar acelerar esse processo. <br><br><h3>  Solu√ß√£o cl√°ssica <br></h3><br>  Para resolver o problema, voc√™ precisa resolver esta equa√ß√£o complicada. <br><img src="https://habrastorage.org/webt/vs/fg/hq/vsfghqwn4s0rkmnsnescb1h62ma.png"><br><br>  A equa√ß√£o √© dura, mas vamos entender seu significado f√≠sico.  Considere um raio perfurado por uma nuvem perfurando uma nuvem.  Como a luz entra na c√¢mera nessa dire√ß√£o?  Primeiro, a luz pode chegar ao ponto de sa√≠da do raio da nuvem e depois se propagar ao longo desse raio dentro da nuvem. <br><br>  Para o segundo m√©todo de "propaga√ß√£o da luz ao longo da dire√ß√£o" √© o termo integral da equa√ß√£o.  Seu significado f√≠sico √© o seguinte. <br><br>  Considere o segmento dentro da nuvem no raio - do ponto de entrada ao ponto de sa√≠da.  A integra√ß√£o √© realizada precisamente sobre esse segmento e, para cada ponto, consideramos a chamada <strong>energia luminosa indireta L (x, œâ)</strong> - o significado da integral I <sub>1</sub> - ilumina√ß√£o indireta no ponto.  Parece que as gotas de maneiras diferentes refletem a luz do sol.  Consequentemente, uma enorme quantidade de raios mediados das got√≠culas ao redor chega ao ponto.  I <sub>1</sub> √© a integral sobre a esfera que circunda um ponto no raio.  No algoritmo cl√°ssico, √© contado usando o m√©todo de <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Monte Carlo</a></strong> . <br><br>  O algoritmo cl√°ssico. <br><br><ul><li>  Renderize uma imagem a partir de pixels e produza um raio que vai do centro da c√¢mera para um pixel e depois para mais longe. </li><li>  Atravessamos a viga com a nuvem, encontramos os pontos de entrada e sa√≠da. </li><li>  Consideramos o √∫ltimo termo da equa√ß√£o: cruzar, conectar-se ao sol. </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Amostragem de import√¢ncia de</a></strong> introdu√ß√£o </li></ul><br>  Como considerar a estimativa de Monte Carlo I <sub>1</sub> n√£o analisaremos, porque √© dif√≠cil e n√£o √© t√£o importante.  Basta dizer que esta √© a parte mais longa e mais dif√≠cil de todo o algoritmo. <br><br><h3>  Conectamos redes neurais <br></h3><br>  A partir da id√©ia principal e da descri√ß√£o do algoritmo cl√°ssico, segue-se uma receita sobre como aplicar redes neurais a esta tarefa.  O mais dif√≠cil √© calcular a pontua√ß√£o de Monte Carlo.  Ele fornece um n√∫mero que significa ilumina√ß√£o indireta em um ponto, e √© exatamente isso que queremos prever. <br><img src="https://habrastorage.org/webt/nz/on/st/nzonstvyqkk3uaiylmqjbs6fny0.png"><br><br>  Decidimos a sa√≠da, agora entenderemos a entrada - a partir de quais informa√ß√µes ficar√° claro qual √© a magnitude da luz indireta no ponto.  Essa √© a luz refletida pelas muitas gotas de √°gua que cercam o ponto.  A topologia da luz √© fortemente influenciada pela topologia da densidade em torno do ponto, a dire√ß√£o da fonte e a dire√ß√£o da c√¢mera. <br><img src="https://habrastorage.org/webt/ks/x6/hc/ksx6hc2boi4sgdp3_j7det6firo.png"><br><br>  Para construir a entrada para a rede neural, descrevemos a densidade local.  Existem v√°rias maneiras de fazer isso, mas nos concentramos no artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dispers√£o Profunda: Renderiza√ß√£o de Nuvens Atmosf√©ricas com Redes Neurais Preditivas de Radi√¢ncia, Kallwcit et al.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2017</a> e muitas id√©ias vieram de l√°. <br><br>  Resumidamente, o m√©todo de representa√ß√£o local da densidade em torno de um ponto se parece com isso. <br><br><ul><li>  <strong>Corrija uma constante relativamente pequena</strong> .  Que seja o caminho livre m√©dio na nuvem. <br></li><li>  <strong>Desenhe em torno de um ponto em nosso segmento uma grade retangular volum√©trica de tamanho fixo</strong> , digamos 5 * 5 * 9.  No centro deste cubo ser√° o nosso ponto.  O espa√ßamento da grade √© uma pequena constante fixa.  Nos n√≥s da grade, mediremos a densidade da nuvem. </li><li>  <strong>Vamos aumentar a constante em 2 vezes</strong> , desenhar uma grade maior e fazer o mesmo - me√ßa a densidade nos n√≥s da grade. </li><li>  <strong>Repita a etapa anterior v√°rias vezes</strong> .  Fizemos isso 10 vezes e, ap√≥s o procedimento, obtivemos 10 grades - 10 tensores, cada um dos quais armazena a densidade das nuvens e cada um dos tensores cobre uma vizinhan√ßa cada vez maior ao redor do ponto. </li></ul><br>  Essa abordagem nos fornece a descri√ß√£o mais detalhada de uma pequena √°rea - quanto mais pr√≥xima ao ponto, mais detalhada √© a descri√ß√£o.  Decidido sobre a sa√≠da e entrada da rede, resta entender como trein√°-la. <br><br><h3>  Treinamento <br></h3><br>  Geraremos 100 nuvens diferentes com diferentes topologias.  N√≥s simplesmente os renderizamos usando o algoritmo cl√°ssico, anote o que o algoritmo recebe na mesma linha em que ele executa a integra√ß√£o de Monte Carlo e anote as propriedades que correspondem ao ponto.  Ent√£o, temos um conjunto de dados para aprender. <br><img src="https://habrastorage.org/webt/yc/im/rh/ycimrhfbcbhfhx_rjwsqoc-xt1q.png"><br><br><h3>  O que ensinar, ou arquitetura de rede <br></h3><br>  A arquitetura de rede para esta tarefa n√£o √© o momento mais crucial e, se voc√™ n√£o entende nada - n√£o se preocupe -, essa n√£o √© a coisa mais importante que eu queria transmitir.  Usamos a seguinte arquitetura: para cada ponto, existem 10 tensores, cada um dos quais √© calculado em uma grade de escala cada vez maior.  Cada um desses tensores cai no bloco correspondente. <br><br><ul><li>  Primeiro na primeira <strong>camada totalmente conectada</strong> regular. </li><li>  Depois de sair da primeira camada totalmente conectada, na segunda camada totalmente conectada, que n√£o possui ativa√ß√£o. </li></ul><br>  Uma camada totalmente conectada sem ativa√ß√£o √© apenas a multiplica√ß√£o por uma matriz.  Ao resultado da multiplica√ß√£o pela matriz, adicionamos a sa√≠da do <strong>bloco residual</strong> anterior e s√≥ ent√£o aplicamos a ativa√ß√£o. <br><img src="https://habrastorage.org/webt/he/fb/pn/hefbpncqogvya11gpsmzjwxtawi.png"><br><br>  Tomamos um ponto, contamos os valores em cada uma das grades, colocamos os tensores obtidos no bloco residual correspondente - e voc√™ pode realizar <strong>infer√™ncia da rede neural</strong> - modo de produ√ß√£o da rede.  Fizemos isso e nos certificamos de tirar fotos de nuvens. <br><br><h3>  Resultados <br></h3><br>  A primeira observa√ß√£o - conseguimos o que quer√≠amos: uma chamada de rede neural, comparada √† estimativa de Monte Carlo, funciona mais r√°pido, o que j√° √© bom. <br><br>  Mas h√° outra observa√ß√£o sobre os resultados do treinamento - √© a converg√™ncia no n√∫mero de amostras.  Do que voc√™ est√° falando? <br><img src="https://habrastorage.org/webt/mb/wd/eg/mbwdegnr_cpk6irbcsvrmyhe3n4.png"><br><br>  Ao renderizar uma imagem, vamos cort√°-la em pequenos blocos - quadrados de pixels, digamos 16 * 16.  Considere um bloco de imagem sem perda de generalidade.  Quando renderizamos esse bloco, para cada pixel da c√¢mera, liberamos muitos raios correspondentes a um pixel e adicionamos um pouco de ru√≠do aos raios para que eles sejam ligeiramente diferentes.  Esses raios s√£o chamados <strong>anti-aliasing</strong> e s√£o inventados para reduzir o ru√≠do na imagem final. <br><br><ul><li>  Liberamos v√°rios raios anti-aliasing para cada pixel. </li><li>  Na parte interna do feixe da c√¢mera, na nuvem, em um segmento, calculamos <em>n</em> amostras de pontos nos quais queremos realizar uma avalia√ß√£o de Monte Carlo ou chamar uma rede para eles. </li></ul><br>  Ainda existem amostras que correspondem √† conex√£o com as fontes de luz.  Eles aparecem quando conectamos um ponto a uma fonte de luz, por exemplo, ao sol.  Isso √© f√°cil, porque o sol s√£o os raios que caem na terra paralelos um ao outro.  Por exemplo, o c√©u, como fonte de luz, √© muito mais complicado, porque aparece como uma esfera infinitamente distante, que tem uma fun√ß√£o de cor na dire√ß√£o.  Se o vetor olhar diretamente para o c√©u, a cor √© azul.  Quanto mais baixo, mais brilhante.  No fundo da esfera geralmente existe uma cor neutra que imita a terra: verde, marrom. <br><br>  Quando conectamos um ponto ao c√©u para entender quanta luz entra nele, sempre liberamos alguns raios para obter uma resposta que converge para a verdade.  Lan√ßamos mais de um raio para obter uma nota melhor.  Portanto, toda a <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">renderiza√ß√£o do pipeline</a></strong> precisa de tantas amostras. <br><br>  Quando treinamos a rede neural, percebemos que ela aprende uma solu√ß√£o muito mais m√©dia.  Se fixarmos o n√∫mero de amostras, veremos que o algoritmo cl√°ssico converge para a linha esquerda da coluna da imagem e a rede aprende √† direita.  Isso n√£o significa que o m√©todo original seja ruim - apenas convergimos mais rapidamente.  Quando aumentarmos o n√∫mero de amostras, o m√©todo original estar√° cada vez mais pr√≥ximo do que obtemos. <br><br>  Nosso principal resultado que quer√≠amos obter √© um aumento na velocidade de renderiza√ß√£o.  Para uma nuvem espec√≠fica em uma resolu√ß√£o espec√≠fica com par√¢metros de amostra, vemos que as imagens obtidas pela rede e pelo m√©todo cl√°ssico s√£o quase id√™nticas, mas obtemos a imagem certa 800 vezes mais r√°pido. <br><img src="https://habrastorage.org/webt/qp/ly/xn/qplyxntotijyhtzhgeqzsygahmc.png"><br><br><h2>  Implementa√ß√£o <br></h2><br>  Existe um programa de c√≥digo aberto para modelagem 3D - <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Blender</a></strong> , que implementa o algoritmo cl√°ssico.  N√≥s mesmos n√£o escrevemos um algoritmo, mas usamos este programa: treinamos no Blender, anotando tudo o que precis√°vamos para o algoritmo.  A produ√ß√£o tamb√©m foi realizada no programa: treinamos a rede no <strong>TensorFlow</strong> , transferimos para C ++ usando o TensorRT e j√° integramos a rede do TensorRT ao Blender, porque seu c√≥digo √© aberto. <br><br>  Como fizemos tudo para o Blender, nossa solu√ß√£o possui todos os recursos do programa: podemos renderizar qualquer tipo de cena e muitas nuvens.  As nuvens em nossa solu√ß√£o s√£o definidas criando um cubo, dentro do qual determinamos a fun√ß√£o de densidade de uma maneira espec√≠fica para programas 3D.  Otimizamos esse processo - densidade de cache.  Se um usu√°rio deseja desenhar a mesma nuvem em uma pilha de configura√ß√µes diferentes de uma cena: sob diferentes condi√ß√µes de ilumina√ß√£o, com diferentes objetos no palco, ele n√£o precisa recalcular constantemente a densidade da nuvem.  O que aconteceu, voc√™ pode assistir ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">v√≠deo</a> . <br><br>  Concluindo, repito mais uma vez a id√©ia principal que eu queria transmitir: <em>se, durante muito tempo, no seu trabalho, voc√™ considera algo como um algoritmo computacional espec√≠fico, e isso n√£o combina com voc√™ - encontre o lugar mais dif√≠cil do c√≥digo, substitua-o por uma rede neural e talvez isso ajude voc√™.</em> <br><br><blockquote>  Redes neurais e intelig√™ncia artificial s√£o um dos novos t√≥picos que discutiremos no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Saint HighLoad ++ 2019</a> em abril.  J√° recebemos v√°rios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aplicativos</a> sobre esse t√≥pico e, se voc√™ tiver uma experi√™ncia interessante, n√£o necessariamente em redes neurais, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">envie um aplicativo</a> antes de <strong>1¬∫ de mar√ßo</strong> .  Teremos o maior prazer em v√™-lo entre os nossos oradores. <br><br>  Para acompanhar como o programa √© formado e quais relat√≥rios s√£o aceitos, assine o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">boletim</a> .  Nele, publicamos apenas cole√ß√µes tem√°ticas de relat√≥rios, resumos de artigos e novos v√≠deos. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441260/">https://habr.com/ru/post/pt441260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441248/index.html">A R√∫ssia ficou em 9¬∫ lugar na classifica√ß√£o SSL global, √† frente da China, Dinamarca e Su√≠√ßa</a></li>
<li><a href="../pt441250/index.html">In√≠cio r√°pido: Ir + Apache Kafka + Redis</a></li>
<li><a href="../pt441252/index.html">‚ÄúArtigo sobre boquete‚Äù: cientistas processaram 109 horas de sexo oral para desenvolver uma IA que suga um membro</a></li>
<li><a href="../pt441254/index.html">Semin√°rio ‚ÄúPor que entramos em contato com o Kubernetes e o que obtemos dele‚Äù, 28 de fevereiro de Moscou</a></li>
<li><a href="../pt441258/index.html">Rastreamento din√¢mico completo no Linux usando eBPF e bpftrace</a></li>
<li><a href="../pt441262/index.html">Tarefas simples e longas eliminam os candidatos melhor do que os curtos e complexos</a></li>
<li><a href="../pt441264/index.html">Guia do Usu√°rio Kibana. Visualiza√ß√£o. Parte 2</a></li>
<li><a href="../pt441266/index.html">Como o framework tiOPF para delphi / lazarus funciona. Modelo de visitante</a></li>
<li><a href="../pt441268/index.html">Testes de Ceedling + Eclipse ou de unidade para microcontroladores</a></li>
<li><a href="../pt441270/index.html">Primeiro, observe o FoundationDB da Apple</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>