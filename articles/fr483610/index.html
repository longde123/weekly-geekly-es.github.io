<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéë üàµ ‚ú≥Ô∏è Un automate est-il un √©v√©nement? üë∑ üíÉüèΩ üóØÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introduction 
 Ayant entendu de l√®vres autoritaires que ¬´les automates sont une chose √©v√©nementielle¬ª [3], je me suis rendu compte que les automate...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un automate est-il un √©v√©nement?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483610/"><h3>  1. Introduction </h3><br>  Ayant entendu de l√®vres autoritaires que ¬´les automates sont une chose √©v√©nementielle¬ª [3], je me suis rendu compte que les automates finis sont enti√®rement marqu√©s.  Jugez par vous-m√™me: dans la biblioth√®que Qt, un mod√®le d'√©v√©nement des automates [1] est impl√©ment√©, en UML ils sont aussi [2], nous regardons les automates du package d'extension Simulink-Stateflow du syst√®me MATLAB [4] (ci-apr√®s simplement Stateflow) et l√†-bas sur les √©v√©nements, etc.  etc.  Dans ce contexte, la d√©claration de Ph.D.  A.A.  C'est m√©chant d'interpr√©ter d'une mani√®re diff√©rente, car  rien d'autre ne peut √™tre, parce qu'il ne peut pas l'√™tre. <br><br>  Mais, si vous vous souvenez de la th√©orie des automates finis (TCA), alors il n'y a pas un mot sur les automates d'√©v√©nements en elle!  Mais pour contredire la th√©orie, des arguments de poids sont n√©cessaires.  Y a-t-il une raison de douter du professionnalisme de D.Harell, en tant que cr√©ateur de la notation sur laquelle le langage UML, le package Stateflow, fonde ses id√©es, qui, √† son tour, ne sont pas inconnues de A.A.  Vilain?  En effet, UML, Stateflow, la programmation SWITCH et d'autres options de programmation automatique existent et, √† un degr√© ou √† un autre, fonctionnent avec succ√®s. <br><br>  Est-il donc possible de supprimer la ¬´stigmatisation des √©v√©nements¬ª du mod√®le de machine √† √©tats finis en s√©parant les ¬´c√¥telettes des mouches¬ª?  C'est-√†-dire  s√©parer la th√©orie des automates et des mod√®les de calcul similaires aux mod√®les de D. Harel.  Et de consid√©rer que ces derniers, bien qu'utilisant la terminologie de la th√©orie des automates, repr√©sentent, √† en juger par leur mise en ≈ìuvre, le d√©veloppement d'un mod√®le de sch√©mas fonctionnels de programmes. <br><a name="habracut"></a><br>  <i>Remarque 1. Dans ce cas, nous parlons du mod√®le de gestion de programme, et non du mod√®le de programme lui-m√™me (pour plus de d√©tails sur les mod√®les, voir [5]).</i> <br><br>  Donc, rappelez-vous, la biblioth√®que Qt impl√©mente un mod√®le d'√©v√©nement d'une machine √† √©tats finis, qui a √©t√© emprunt√© √† UML.  Le m√™me mod√®le est impl√©ment√© par Stateflow.  C'est-√†-dire  la source des √©v√©nements est UML, o√π les automates sont bas√©s sur la notation propos√©e par D. Harel.  Mais bl√¢mer ce dernier pour la cr√©ation d'une telle programmation automatique ne serait pas non plus vrai, car  L '¬´√©v√©nementiel¬ª est une tendance des approches modernes √† la mise en ≈ìuvre de mod√®les logiciels.  Il est bas√© sur des opinions faisant autorit√© telles que les ¬´machines sont un √©v√©nement¬ª et la grande popularit√© des langages et technologies tels que UML.  C'est sans aucun doute le r√©sultat du mim√©tisme des machines selon les principes de fonctionnement des syst√®mes d'exploitation existants. <br><br>  Mais, r√©p√©tons-le, car cela ne semble pas √©trange, mais pour certains cela peut m√™me devenir une nouveaut√©, dans la th√©orie des automates, il n'y a pas de mod√®le d'√©v√©nement d'un automate fini.  Au moins dans cette partie qui est consid√©r√©e comme classique (voir pour plus de d√©tails, par exemple, [6] ou [7]).  Il existe une nette contradiction entre la th√©orie et la pratique.  Dans une telle situation, vous devez faire quelque chose avec la th√©orie ou influencer d'une mani√®re ou d'une autre la pratique.  Mais, peut-√™tre, les programmeurs ont-ils raison de vouloir finaliser le mod√®le d'une machine √† √©tats finis en y incluant le concept d '¬´√©v√©nement¬ª [8, 9]? <br><br>  Mais comment relier les d√©sirs des programmeurs au fait que ¬´les plus grandes difficult√©s √† utiliser l'approche des automates sont li√©es √† la compr√©hension des caract√©ristiques du fonctionnement des automates dans les syst√®mes √©v√©nementiels¬ª (voir [8]).  Je voudrais comprendre les causes de ces probl√®mes et, dans ce contexte, impl√©menter des machines √©v√©nementielles et / ou leurs analogues.  Pour cela, pour des sp√©cificit√©s, nous prenons l'impl√©mentation d'automates dans Qt et les r√©p√©tons en utilisant le mod√®le d'un automate fini classique. <br><br>  Une telle impl√©mentation d'automates √©v√©nementiels est n√©cessaire pour √©valuer et / ou surmonter les ¬´fonctionnalit√©s¬ª mentionn√©es.  L'utilisation du mod√®le classique √©tendra √©galement la th√©orie des automates √† la ¬´programmation d'√©v√©nements¬ª.  Et, au final, un analogue bas√© sur un autre mod√®le ne fera qu'√©largir le domaine d'application des mod√®les de machines √† √©tats finis. <br><br><h3>  2. √âv√©nements, signaux et identit√© de genre des automates </h3><br>  En UML, un √©v√©nement est ¬´un ph√©nom√®ne significatif qui a une certaine position dans le temps et l'espace ... et entra√Æne certaines cons√©quences¬ª [10].  Un √©v√©nement dans la th√©orie des automates est un sous-ensemble des caract√®res d'entr√©e repr√©sent√©s par les caract√®res de l'alphabet de sortie (il y a m√™me le concept de l'alg√®bre des √©v√©nements dans le TCA) [6].  La m√™me chose qui provoque la transition d'un automate est appel√©e signaux d'entr√©e dans la th√©orie des automates.  Ce sont les cons√©quences et ¬´la raison, la transition de l'automate d'un √©tat √† l'autre.  Dans ce cas, les signaux de sortie sont la ¬´r√©ponse de l'automate aux signaux d'entr√©e¬ª. Ces deux ¬´se r√©f√®rent √† des instants temporels d√©termin√©s par les transitions correspondantes de l'automate¬ª [6]. En UML, le signal (signal) est ¬´une entit√© nomm√©e qui sert de moyen de communication entre les objets ¬ª[10]. <br><br>  Ainsi, les noms des termes sont les m√™mes, mais le sens qui y est investi est diff√©rent.  Bien que, si vous les r√©organisez, vous pouvez trouver une similitude: il devient clair que les √©v√©nements dans UML correspondent aux signaux des machines √† √©tats finis dans le TCA.  Mais, peut-√™tre, diff√©rentes entit√©s sont √©galement cach√©es sous le terme de ¬´machine √† √©tats finis¬ª?  Essayons de le comprendre, en commen√ßant par les √©v√©nements ... <br><br>  L'automate d'√©v√©nement est un automate passif, car  ne fonctionne qu'au moment de l'arriv√©e des √©v√©nements.  En revanche, l'automate classique repr√©sente le mod√®le actif.  Il fonctionne sans r√©f√©rence √† quoi que ce soit (pour plus de d√©tails sur les automates passifs et actifs, voir [9]).  Ici, l'association avec deux coureurs commence, o√π le premier est entra√Æn√© par des coups de pied (√©v√©nements), et le second court par lui-m√™me. <br><br>  Contrairement √† [8], nous n'associerons pas dans un premier temps les moments d'occurrence des √©v√©nements au d√©marrage de l'automate.  Nous resterons donc dans le cadre de la th√©orie des automates, qui d√©termine la nature asynchrone du fonctionnement des automates par rapport √† l'environnement ext√©rieur.  Il ne parle que de temps discret, dans lequel le changement d'√©tats est effectu√© pour une p√©riode en temps r√©el arbitrairement petite, mais non √©gale √† z√©ro.  Et la raison des transitions est l'√©tat actuel et les signaux d'entr√©e de la machine, o√π les cons√©quences sont l'installation d'un nouvel √©tat et les valeurs des signaux de sortie de la machine (pour plus de d√©tails sur la d√©finition des machines, voir [6]). <br><br>  La th√©orie des automates est flexible pour d√©terminer le temps discret, qui est un mod√®le en temps r√©el.  Ainsi, un cycle temporel discret peut avoir une valeur fixe ou flottante d'un intervalle en temps r√©el, et conform√©ment √† cela, les machines sont appel√©es synchrones ou asynchrones.  Dans le m√™me temps, l'intervalle de temps associ√© √† l'horloge peut avoir n'importe quelle valeur, y compris une valeur infiniment petite, mais non √©gale √† z√©ro. <br><br>  <i>Remarque 2. Un mod√®le de machine √† √©tats finis est l'un des rares mod√®les formels qui inclut dans sa d√©finition un mod√®le en temps r√©el sous une forme explicite.</i> <br><br>  Par cons√©quent, la vitesse formellement ¬´infinie¬ª de l'automate actif permet de traiter tout √©v√©nement comme un signal d'entr√©e potentiel (en termes d'UML, la condition [11] lui correspond).  La machine n'aura besoin que de ¬´capturer¬ª de tels √©v√©nements / signaux et des pauses entre eux.  Tout cela d√©finit en fait le protocole du travail conjoint du m√©dium et de l'automate.  Le protocole devrait √©galement r√©soudre le probl√®me de la reconnaissance d'√©v√©nements identiques re√ßus successivement.  Sans cela, par exemple, deux symboles identiques, re√ßus l'un apr√®s l'autre, peuvent √™tre per√ßus comme un seul. <br><br>  Formellement, les nuances du traitement des √©v√©nements ne sont pas significatives (voir les m√™mes automates abstraits), mais dans la mise en ≈ìuvre pratique d'algorithmes construits par le type de mod√®le d'√©v√©nement, elles doivent √™tre prises en compte.  Dans le cas de la biblioth√®que Qt, leur comptabilit√© est cach√©e dans les classes d'impl√©mentation de l'automate.  De plus, nous prendrons en compte les diff√©rences entre les automates √©v√©nementiels et classiques en utilisant l'exemple de l'impl√©mentation du calculateur le plus simple de [1], o√π son ¬´impl√©mentation √©v√©nementielle¬ª est donn√©e.  Contrairement √† cette solution, des mod√®les √©quivalents seront cr√©√©s sur la base de la machine √† √©tats finis classique. <br><br><h3>  3. Mod√®les de calculatrice </h3><br>  Alors, commen√ßons ... Nous appelons des signaux d'√©v√©nements, des √©v√©nements d'automates ordinaires ... ou dans l'ordre inverse et / ou vice versa?  Ugh!  Confus.  En bref, la ¬´budlanula glocky cuzdra shteko¬ª compl√®te et quelque chose de ¬´boucles¬ª.  Pour savoir qui est qui, quoi et quoi appeler, le plus s√ªr est de choisir un ¬´bokra¬ª sp√©cifique et de le ¬´bump¬ª ... Le programme ¬´calculatrice automatique¬ª continuera √† √™tre un tel ¬´c√¥t√©¬ª. <br><br><h4>  3.1.  Mod√®le de calculateur actif </h4><br>  Dans la fig.  1 montre le mod√®le original de la classe Calculatrice de [1].  En apparence, il ressemble √† une machine abstraite classique sans issue.  La diff√©rence est que Qt connecte des actions lorsqu'il entre et sort d'un √©tat.  En sortie, ils sont d√©clench√©s par le signal sorti (), et √† l'entr√©e dans l'√©tat, par le signal entr√© ().  Mais, notons-le, ces actions ne sont en aucun cas repr√©sent√©es dans le graphique. <br><br>  Si nous comparons le mod√®le de la Fig.  1 avec un automate √† √©tat abstrait (ses autres noms sont automate structurel et logique), on peut facilement voir que les actions √† la sortie de l'√©tat correspondent aux signaux de l'automate Mealy, et les actions √† l'entr√©e correspondent aux signaux de l'automate Moore. <br>  Remarque 3. De plus, compte tenu de l'impl√©mentation logicielle du mod√®le, nous ne parlerons pas de signaux, d'√©v√©nements, de conditions, etc., mais des actions des automates, en supposant qu'au niveau du programme, ils sont associ√©s √† certaines actions du programme, ce qui dans le cas g√©n√©ral repr√©sent√©s par des fonctions logicielles. <br><br>  L'automate Mili-Moore dit combin√© (ou un automate diff√©remment m√©lang√© [12]), √©quivalent √† l'automate de la Fig.  1, est repr√©sent√©e sur la Fig. 2, o√π les fonctions correspondant aux signaux d'entr√©e et de sortie de l'automate sont √©galement repr√©sent√©es √† droite du graphique. <br><br><img src="https://habrastorage.org/webt/dq/ki/ps/dqkipszttmbkgyexe9labqsio9e.jpeg" alt="image"><br>  <i>Fig.1.</i>  <i>Diagramme de machine d'√©v√©nement de calculatrice</i> <br><br><img src="https://habrastorage.org/webt/c3/la/ue/c3laueqyd9oiwdf9aiu5gpyi_yk.jpeg" alt="image"><br>  <i>Fig.2.</i>  <i>Calculatrice de classe d'automates Count Miley-Moore</i> <br><br>  Pour un mod√®le similaire √† un automate dans la Fig. 2, par actions d'entr√©e / sortie, nous entendons des pr√©dicats et des actions, qui sont des fonctions de programme-m√©thodes des classes [automate].  Les pr√©dicats n'analysent en aucun cas l'√©tat actuel des √©l√©ments de la m√©moire (variables, propri√©t√©s de classe) (c'est important!) Sans les affecter, mais en fonction de leur valeur, renvoyer une valeur bool√©enne.  Les actions d'une valeur ne retournent pas, mais modifient les √©l√©ments de m√©moire. <br>  De la fig.  2, il s'ensuit que le mod√®le de calculatrice, comme la ¬´bo√Æte noire¬ª, a quatre canaux d'entr√©e et sept canaux de sortie en termes de nombre de pr√©dicats et d'actions.  Il est facile de voir qu'en comparaison avec un automate abstrait, qui par d√©finition n'a pas plus d'un canal d'entr√©e et un canal de sortie, un automate structurel √† plusieurs canaux est plus universel, flexible et pratique. <br><br>  Le mod√®le de la fig.  2 peut √™tre simplifi√© en ¬´collant¬ª les √©tats 1 et 2. Pour ce faire, vous devez d'abord transformer l'automate d'origine en automate Mealy.  On l'obtient en chargeant les arcs entrant dans l'√©tat des signaux avec les signaux repr√©sent√©s par les signaux des sommets de l'automate Moore.  Apr√®s cela, l'op√©ration de collage devient apparente.  Le r√©sultat du collage des √©tats √† l'√©tat 2, qui devient maintenant initial, est illustr√© √† la Fig.  3. <br><br><img src="https://habrastorage.org/webt/qa/en/yw/qaenywlioaky3gizvfju27faxmm.jpeg" alt="image"><br>  <i>Fig.3.</i>  <i>Le r√©sultat de la transformation et du collage des √©tats de l'automate sur la figure 2</i> <br><br>  Expliquez l'action y1 et la variable nTypeButtons.  Au total, ils impl√©mentent un protocole qui simule des √©v√©nements.  La variable nTypeButtons d√©termine le type de symboles d'entr√©e de l'automate en les divisant en symboles num√©riques, symboles de fonctionnement, symbole "reset" et symbole "√©gal".  Sa valeur √©gale √† z√©ro signifie l'absence de caract√®res saisis (aucune touche de la calculatrice n'est enfonc√©e).  Apr√®s traitement du symbole, cela signifie √©galement que le symbole d'entr√©e est per√ßu automatiquement.  Cela bloque la r√©ponse au caract√®re saisi. <br><br>  Le code de la classe de la calculatrice cr√©√©e dans le cadre de l'environnement de programmation automatique de composants visuels (VKPa) [5] est indiqu√© dans les listes 1, 2. <br><br><div class="spoiler">  <b class="spoiler_title">Listing 1. En-t√™te de classe FCalculator</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"lfsaappl.h"</span></span></span><span class="hljs-meta"> enum Buttons { digit0 = 0, digit1, digit2, digit3, digit4, digit5, digit6, digit7, digit8, digit9, opPlus, opMinus, opCancel, opEqual, opNone }; class FCalculator : public LFsaAppl { public: void MooreAction(); LFsaAppl* Create(CVarFSA *pCVF) { Q_UNUSED(pCVF)return new FCalculator(pTAppCore, nameFsa, pCVarFsaLibrary); } FCalculator(TAppCore *pInfo, string strNam, CVarFsaLibrary *pCVFL); virtual ~FCalculator(void); public: void digitButtonPressed(int button); void operationButtonPressed(int button); private: void s1Entered(); void s2Entered(); void s3Entered(); void s3Exited(); void s5Entered(); void s5Exited(); private: int Rf, Rb; Buttons transitionButton, Op; int nTypeButtons; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 0 - none; 1 - digit button; 2 - operation button; void doOp(Buttons op); protected: int x1(); int x2(); int x3(); int x4(); void y1(); void y3(); void y5(); void y6(); void y7(); void y8(); void y9(); void y10(); int nState{2}; };</span></span></span></span></code> </pre> <br><br></div></div><br>  Expliquons.  Dans VKPa, toute classe d'automate h√©rite des propri√©t√©s de la classe d'automate de base LFsaAppl.  La m√©thode Create () cr√©e des copies des classes incluses dans les biblioth√®ques dynamiques des processus automatiques.  La m√©thode virtuelle MooreAction () se chevauche lorsqu'un mod√®le d'automate Moore est s√©lectionn√©, d√©finissant les actions associ√©es aux √©tats de l'automate.  Les m√©thodes x [n] et y [n] sont les pr√©dicats et actions associ√©s aux canaux d'entr√©e / sortie de l'automate.  L'algorithme de comportement de la classe [automate] est repr√©sent√© par la table de transition (voir Listing 2), qui consiste en un tableau de cha√Ænes de type LArc.  Le reste du code r√©p√®te le code de la calculatrice de la classe source. <br><br><div class="spoiler">  <b class="spoiler_title">Listing 2. Impl√©mentation de la classe FCalculator</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdafx.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FCalculator.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"DlgCalculator.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ui_cdlgcalculator.h"</span></span></span><span class="hljs-meta"> static LArc TBL_Calculator[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//* LArc("1", "2","x1", "y1"), // [0-9] LArc("2", "1","x3", "y1"), // [c] LArc("2", "2","x1", "y1"), // [0-9] LArc("2", "3","x2", "y1"), // [+][-] LArc("3", "1","x3", "y3"), // [c] LArc("3", "3","x2", "y3"), // [+][-] LArc("3", "4","x1", "y3"), // [0-9] LArc("3", "5","x4", "y3"), // [=] LArc("4", "1","x3", "y1"), // [c] LArc("4", "3","x2", "y1"), // [+][-] LArc("4", "4","x1", "y1"), // [0-9] LArc("4", "5","x4", "y1"), // [=] LArc("5", "1","x3", "y5"), // [c] LArc("5", "2","x1", "y5"), // [0-9] LArc("5", "3","x2", "y5"), // [+][-] //*/ /* LArc("2", "2","x1", "y1y7"), // [0-9] LArc("2", "2","x3", "y1y6"), // [c] LArc("2", "3","x2", "y1y8"), // [+][-] LArc("3", "2","x3", "y3y6"), // [c] LArc("3", "3","x2", "y3y8"), // [+][-] LArc("3", "4","x1", "y3y7"), // [0-9] LArc("3", "5","x4", "y3y9"), // [=] LArc("4", "2","x3", "y1y6"), // [c] LArc("4", "3","x2", "y1y8"), // [+][-] LArc("4", "4","x1", "y1y7"), // [0-9] LArc("4", "5","x4", "y1y9"), // [=] LArc("5", "2","x3", "y5y6"), // [c] LArc("5", "2","x1", "y5y7"), // [0-9] LArc("5", "3","x2", "y5y8"), // [+][-] */ // LArc("1", "1","--", "y10"), // SWITCH LArc() }; FCalculator::FCalculator(TAppCore *pInfo, string strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_Calculator, strNam, nullptr, pCVFL) { pTAppCore = pInfo; Rf= 0; Rb = 0; Op = opNone; } FCalculator::~FCalculator(void) { } //   int FCalculator::x1() { if (nTypeButtons != 1) return false; else return true; } //   +, - int FCalculator::x2() { if (nTypeButtons == 0 || nTypeButtons != 2) return false; if (transitionButton != opCancel &amp;&amp; transitionButton != opEqual ) return true; else return false; } //  Cancel int FCalculator::x3() { if (nTypeButtons == 0 || nTypeButtons != 2) return false; if (transitionButton == opCancel) return true; else return false; } //  opEqual int FCalculator::x4() { if (nTypeButtons == 0 || nTypeButtons != 2) return false; if (transitionButton == opEqual) return true; else return false; } void FCalculator::y1() { nTypeButtons = 0; } void FCalculator::y3() { s3Exited(); } void FCalculator::y5() { s5Exited(); } void FCalculator::y6() { s1Entered(); } // 1 void FCalculator::y7() { s2Entered(); } // 2, 4 void FCalculator::y8() { s3Entered(); } // 3 void FCalculator::y9() { s5Entered(); } // 5 void FCalculator::y10() { switch(nState) { case 2: if (x1()) { y1();y7(); } if (x3()) { y1();y6(); } if (x2()) { y1();y8(); nState = 3; } break; case 3: if (x3()) { y3();y6(); nState = 2; } if (x2()) { y3();y8(); } if (x1()) { y3();y7(); nState = 4; } if (x4()) { y3();y9(); nState = 5; } break; case 4: if (x3()) { y1();y6(); nState = 2; } if (x2()) { y1();y8(); nState = 3; } if (x1()) { y1();y7(); } if (x4()) { y1();y9(); nState = 5; } break; case 5: if (x3()) { y5();y6(); nState = 2; } if (x1()) { y5();y7(); nState = 2; } if (x2()) { y5();y8(); nState = 3; } break; } } void FCalculator::MooreAction() { // return; string strState = FGetState(); if (strState=="1") { y6(); } else if (strState=="2") { y7(); } else if (strState=="3") { y8(); } else if (strState=="4") { y7(); } else if (strState=="5") { y9(); } } /////////////////////////////////////////////////////////////////////////// void FCalculator::digitButtonPressed(int button) { transitionButton = static_cast&lt;Buttons&gt;(button); nTypeButtons = 1; } void FCalculator::operationButtonPressed(int button) { transitionButton = static_cast&lt;Buttons&gt;(button); nTypeButtons = 2; } void FCalculator::s1Entered() { Rf = 0; Rb = 0; Op = opNone; static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } void FCalculator::s2Entered() { if (Rf &lt; 9999999) { Rf = Rf*10 + transitionButton; static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } } void FCalculator::s3Entered() { if (Rb != 0) { doOp(Op); static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } Rb = Rf; Op = transitionButton; } void FCalculator::s3Exited() { nTypeButtons = 0; if (transitionButton &gt; digit9 &amp;&amp; transitionButton &lt; opCancel ) { doOp(transitionButton); Rb = 0; Op = transitionButton; static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } else { Rf = 0; } } void FCalculator::s5Entered() { doOp(Op); Op = opNone; Rb = Rf; // added by me static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } void FCalculator::s5Exited() { nTypeButtons = 0; if (transitionButton &lt;= 9) { Rb = 0; Rf = 0; } } void FCalculator::doOp(Buttons op) { switch (op) { case opPlus: Rf = Rf + Rb; break; case opMinus: Rf = Rb - Rf; break; default: break; } }</span></span></span></span></code> </pre><br><br></div></div><br>  L'avis 2 contient trois tables de saut (deux sont comment√©es).  C‚Äôest ainsi que les capacit√©s de contr√¥le d√©di√© sont r√©alis√©es lorsque, apr√®s avoir supprim√© le commentaire, le comportement de la classe peut √™tre modifi√© ¬´par clic¬ª sans affecter ses m√©thodes et ses propri√©t√©s.  La m√©thode y10 et la ligne correspondante dans le tableau de transition (voir la ligne marqu√©e avec le commentaire SWICH) ont √©t√© introduites pour simuler la technologie SWITCH (pour plus de d√©tails voir [9]) dans le cadre de la technologie VKPA.  Dans ce cas, le comportement de tout automate est mod√©lis√© par un appel cyclique √† l'op√©rateur SWITCH, qui imite le comportement de l'automate (ici l'automate VKPa agit comme un environnement externe). <br><br><h4>  3.2.  Mod√®le de calculateur passif </h4><br>  Le mod√®le de calculateur actif balaye constamment les canaux d'entr√©e.  D√®s que la valeur de la variable nTypeButtons devient non nulle, cela sert de signe de l'arriv√©e du prochain symbole √† l'entr√©e de l'automate.  Par cons√©quent, la transition et l'action y1 sont d√©clench√©es, r√©initialisant la variable nTypeButtons, bloquant le red√©marrage automatique de la machine par le m√™me caract√®re. <br>  Contrairement au mod√®le ¬´calculatrice active¬ª, un automate d'√©v√©nements ne peut pas, par d√©finition, retraiter un symbole d'entr√©e.  Il est maintenant clair que "les plus grandes difficult√©s √† utiliser l'approche des automates ... dans les syst√®mes d'√©v√©nements" semblent se r√©sumer √† supprimer l'activit√© d'un automate actif et √† lier son fonctionnement aux √©v√©nements.  Nous montrons la proc√©dure pour passer √† un automate passif en utilisant l'exemple de la ¬´calculatrice active¬ª qui vient d'√™tre cr√©√©e. <br>  L'environnement VKPa contient un mode de fonctionnement pas √† pas introduit pour le d√©bogage des processus automatiques.  Mais il peut √™tre utilis√© pour simuler des machines d'√©v√©nements.  Pour ce faire, 1) d√©finissez l'espace de l'automate dans lequel l'automate est plac√© un mode de fonctionnement pas √† pas (notez, pas un automate s√©par√©, mais tout l'espace de l'automate contenant des automates), et 2) reliez les moments d'occurrence des √©v√©nements avec l'ex√©cution d'une √©tape discr√®te du fonctionnement de l'espace.  Le listing 3 montre comment proc√©der, refl√©tant uniquement les modifications apport√©es au mod√®le (l'en-t√™te de classe reste inchang√©). <br><br><div class="spoiler">  <b class="spoiler_title">Listing 3. Une variante √©ventuelle de la classe FCalculator</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> LArc TBL_Calculator[] = { LArc(<span class="hljs-string"><span class="hljs-string">"st"</span></span>, <span class="hljs-string"><span class="hljs-string">"st"</span></span>,<span class="hljs-string"><span class="hljs-string">"^x12"</span></span>, <span class="hljs-string"><span class="hljs-string">"y12"</span></span>), <span class="hljs-comment"><span class="hljs-comment">// LArc("st", "1","x12", "y11"), // // ... }; ... //   bool FCalculator::FCreationOfLinksForVariables() { pNet = GetPointerToNet(); //    if (pNet) { string str = pNet-&gt;strName; //    //  -  pSV = this-&gt;pTAppCore-&gt;pSetVarSetting-&gt;GetAddressVar(const_cast&lt;char*&gt;(str.c_str())); } return true; } ... // int FCalculator::x12() { if (!pNet) return false; if (!pSV) return false; return true; } ... //    step-by-step void FCalculator::y11() { pSV-&gt;bIfStepByStep = true; } //   void FCalculator::y12() { FCreationOfLinksForVariables(); } // ... ///////////////////////////////////////////////////////////////////////////////////////////////////////////////// void FCalculator::digitButtonPressed(int button) { ... pSV-&gt;bIfStopAllTasks = false; //     } void FCalculator::operationButtonPressed(int button) { ... pSV-&gt;bIfStopAllTasks = false; //     } ...</span></span></code> </pre><br><br></div></div><br>  Ici, tout d'abord, un √©tat [initial] suppl√©mentaire est introduit, dans lequel la r√©f√©rence √† l'espace o√π se trouve la machine et le lien vers l'objet qui d√©termine les propri√©t√©s de l'espace (y compris son mode de fonctionnement) sont v√©rifi√©s.  Eh forme l'action de y12.  Lorsque les liaisons sont √©tablies, il y a une transition vers [l'ancien] √©tat initial du mod√®le de calculatrice avec l'installation d'un mode de fonctionnement pas √† pas de l'espace automate. <br><br>  De plus, le mod√®le fonctionne dans un mode pas √† pas de fonctionnement spatial.  Le lancement d'une √©tape impl√©mente le code ins√©r√© dans les gestionnaires d'√©v√©nements associ√©s √† l'entr√©e du caract√®re suivant (voir le listing 3 pour les modifications apport√©es aux m√©thodes digitButtonPressed et operationButtonPressed). <br><br><h3>  4. Pourquoi? </h3><br>  Pourquoi inventer quelque chose, s'il existe, comme on peut le supposer, un mod√®le d'√©v√©nement plus avanc√© de D. Harel.  Et comment penser diff√©remment s'il √©tait ex√©cut√© en UML, Stateflow, dans la biblioth√®que Qt, etc.  etc.  et il n'y a pas beaucoup de panique √† propos de ses d√©fauts.  Eh bien, ils ont appel√© les √©v√©nements de signaux, et ont transform√© la machine active en une machine passive ... Et si le mod√®le, comme on dit, est aussi formellement √©quivalent aux machines Mili / Moore classiques, alors comment ne pas y croire?  Et il en est ainsi, si toutes ces d√©clarations ne sont prises que sur la foi ... <br><br>  Prenez pour le d√©but de l'√©v√©nement (c'est exactement ce que nous avons fait ci-dessus).  Un automate structurel classique poss√®de, par exemple, de nombreux canaux d'entr√©e, chacun √©tant associ√© √† un signal, et ils peuvent √™tre trait√©s simultan√©ment / en parall√®le.  Mais UML dit que ¬´chaque objet ne peut traiter qu'un seul √©v√©nement √† la fois¬ª et m√™me ¬´si deux √©v√©nements se produisent simultan√©ment, l'objet les traitera toujours un √† la fois¬ª [10].  Ainsi, au niveau de la d√©finition, les signaux et les √©v√©nements sont √©quivalents, mais l'idylle s'effondre dans le processus de mise en ≈ìuvre des transitions du mod√®le. <br><br>  Prenons l'exemple avec lequel je commence √† tester / apprendre n'importe quelle langue ou technologie.  Il s'agit de l'impl√©mentation logicielle du mod√®le d'√©l√©ment ET-NON.  Au niveau structurel, il correspond √† la ¬´bo√Æte noire¬ª, qui a deux canaux d'entr√©e et une sortie, et sur l'algorithmique, l'automate repr√©sent√© sur la Fig.  4. <br><br><img src="https://habrastorage.org/webt/6q/7d/ve/6q7dve1toup6onrda9kkjsqzg2u.jpeg" alt="image"><br>  <i>Fig.</i>  <i>4. Le mod√®le automate de l'√©l√©ment ET NON</i> <br><br>  Comment cr√©er un mod√®le proc√©dural r√©gulier (voir Listing 4) ou comment impl√©menter un automate en VKPa (voir Listing 5) est compr√©hensible, mais comment r√©p√©ter cela sur la base de l'automate d'√©v√©nement de la biblioth√®que Qt n'est pas tr√®s clair en raison du probl√®me de mise en ≈ìuvre de la transition de l'√©tat "1" indiquer "0", ce qui n√©cessite l'analyse simultan√©e de plusieurs √©v√©nements. <br><br>  Listing 4. Impl√©mentation d'objet du mod√®le proc√©dural AND-NOT <br><br><div class="spoiler">  <b class="spoiler_title">Listing 4. Impl√©mentation d'objet du mod√®le proc√©dural AND-NOT</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">INE</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: INE() {} ~INE(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bX1, bX2, bY; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bY = !(bX1&amp;&amp;bX2); } };</code> </pre><br><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Listing 5. Impl√©mentation d'objet du mod√®le d'automate AND-NOT</b> <div class="spoiler_text"><pre> <code class="cpp hljs">LArc T_INE[] = { LArc(<span class="hljs-string"><span class="hljs-string">"s1"</span></span>, <span class="hljs-string"><span class="hljs-string">"s0"</span></span>, <span class="hljs-string"><span class="hljs-string">"x1x2"</span></span>, <span class="hljs-string"><span class="hljs-string">"y1"</span></span>), LArc(<span class="hljs-string"><span class="hljs-string">"s0"</span></span>, <span class="hljs-string"><span class="hljs-string">"s1"</span></span>, <span class="hljs-string"><span class="hljs-string">"^x1"</span></span>, <span class="hljs-string"><span class="hljs-string">"y2"</span></span>), LArc(<span class="hljs-string"><span class="hljs-string">"s0"</span></span>, <span class="hljs-string"><span class="hljs-string">"s1"</span></span>, <span class="hljs-string"><span class="hljs-string">"^x2"</span></span>, <span class="hljs-string"><span class="hljs-string">"y2"</span></span>), }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ine</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> LFsaAppl { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Ine(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> strNam = <span class="hljs-string"><span class="hljs-string">"-"</span></span>): LFsaAppl(T_INE, strNam) {} ~Ine(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bX1, bX2; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bX1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bX2; } };</code> </pre><br><br></div></div>  Ainsi, que l'impl√©mentation du mod√®le d'√©v√©nement de l'√©l√©ment NAND dans le cadre des classes d'automates Qt soit un ¬´devoir¬ª pour les Habrovans.  Je ne peux que citer sa d√©cision dans Stateflow comme une ¬´cerise sur le g√¢teau¬ª.  Il est illustr√© sur la fig.  5. Le relief Stateflow est utilis√© ici, ce qui permet de ne pas marquer la transition avec un √©v√©nement: si le nom de l'√©v√©nement n'est pas sp√©cifi√©, alors la transition se produira lorsqu'un √©v√©nement se produit (voir l'√©tiquette de transition dans [13] pour un exemple). <br><br><img src="https://habrastorage.org/webt/_9/j7/4e/_9j74efmsk0ema7itfdezvpmfca.jpeg" alt="image"><br>  <i>Fig.</i>  <i>5. Un mod√®le d'automate d'un √©l√©ment AND-NOT dans Stateflow</i> <br><br>  Ainsi, les machines √† √©tats sont un mod√®le hybride (actif-passif) d'une machine.  Certes, il n'est pas clair comment la machine se comportera en l'absence de tout √©v√©nement.  On peut supposer qu'il ¬´g√®lera¬ª en pr√©vision des √©v√©nements.  Et s'ils ne le seront pas?  C'est-√†-dire  en fin de compte, il s'agit toujours plus d'un mod√®le passif que d'un mod√®le de machine active.  Bien que seulement en apparence, il est difficile de les distinguer de ces derniers. <br><br><h3>  5. Conclusion </h3><br>  En ce qui concerne les √©v√©nements, on peut dire qu'en raison de l'activit√©, la mise en ≈ìuvre du mod√®le classique des automates semble pr√©f√©rable au mod√®le des automates synchrones.  Si nous parlons de la programmation automatique en g√©n√©ral, le package d'extension Stateflow montre ce qu'un type de programmation compl√®tement diff√©rent peut √™tre.  Mais, malheureusement, jusqu'√† pr√©sent seulement en perspective, car  des probl√®mes subsistent en raison du mod√®le de calcul Stateflow, qui reste essentiellement un sch√©ma fonctionnel.  Il semble que pr√©cis√©ment pour ces raisons, avec les automates, la programmation visuelle dans Statefow est repr√©sent√©e par la notation des organigrammes. <br><br>  D√©couvrir o√π se trouve la v√©ritable programmation automatique et o√π se trouve son imitation est l'un de nos principaux objectifs.  Dans l'article pr√©c√©dent [5], nous avons r√©solu l'une des t√¢ches de base pos√©es - nous avons formul√© le concept de programmes d'automates.  Ensuite, vous devez traiter de la d√©finition d'un mod√®le de gestion de programme, qui devrait √™tre un automate fini et √™tre efficace et pratique pour les programmeurs. <br><br>  Apr√®s avoir trait√© des √©v√©nements, nous avons jet√© les bases d'un tel travail.  Dans d'autres articles, nous comprendrons d√©j√† les d√©tails du mod√®le propos√© par D. Harel.  En courant un peu plus loin, nous disons que, pour le dire franchement, elle a d√©form√© la compr√©hension des automates.  Mais, d'un autre c√¥t√©, ici nous devons lui rendre son d√ª, elle a r√©v√©l√© des probl√®mes qui ne permettraient pas, sans elle, de former une programmation automatique efficace dans le cadre du mod√®le classique qui attirerait les programmeurs. <br><br>  Nous avons d√©couvert ci-dessus qu'au moins au niveau de l'√©v√©nement, les automates classiques n'ont aucun probl√®me.  Nous comprendrons plus loin ... En attendant, ce n'est que le d√©but.  Nous attendons beaucoup de choses int√©ressantes et, notons, n'allons pas au-del√† de la th√©orie classique des automates.  Ceci est crucial si nous voulons une programmation vraiment automatis√©e.  Nous vous souhaitons beaucoup de succ√®s!  :) <br><br><h3>  Les r√©f√©rences </h3><br>  1. Borovsky A.N.  Qt4.7.  Programmation C ++ pratique.  - SPb.: BHV-Petersburg, 2012 .-- 496 p. <br>  2. BUCH G., RAMBO J., JACOBSON I. UML.  Manuel d'utilisation.  Deuxi√®me √©dition.  Akademiya IT: Moscou, 2007 .-- 493 p. <br>  3. Shalyto A. A. Une nouvelle conf√©rence sur la programmation automatique.  2019, [Ressource √©lectronique], <a href="https://www.youtube.com/watch%3Fv%3DPPWTxceMutk%26feature%3Dyoutu.be" rel="nofollow">Mode d'</a> acc√®s: <a href="https://www.youtube.com/watch%3Fv%3DPPWTxceMutk%26feature%3Dyoutu.be" rel="nofollow">www.youtube.com/watch?v=PPWTxceMutk&amp;feature=youtu.be</a> , gratuit.  Yaz.  Russe  (date du traitement 5 d√©cembre 2019). <br>  4. Stateflow.  <a href="https://www.mathworks.com/products/stateflow.html" rel="nofollow">www.mathworks.com/products/stateflow.html</a> , gratuit.  Yaz.  Anglais  (date de diffusion 7.01.2020). <br>  5. Machine de Turing, comme mod√®le de programmes d'automates.  <a href="https://habr.com/ru/post/481998/">habr.com/en/post/481998</a> , gratuit.  Yaz.  Russe  (date de diffusion 7.01.2020). <br>  6. Melikhov A.N.  Graphes orient√©s et machines √† √©tats finis.  - M.: Nauka, 1971. - 416 p. <br>  7. KUDRYAVTSEV VB, Aleshin S.V., PODKOLZIN A.S.  Introduction √† la th√©orie des automates - M.: Science.  Ch.  √©d.  Phys.-Math.  lit., 1985 .-- 320 p. <br>  8. Tukkel N.I., Shalyto A.A.  Impl√©mentation d'automates lors de la programmation de syst√®mes d'√©v√©nements.  "Programmer", 2002. No. 4.  C.74-80. <br>  9. Polikarpova N., A. Shalyto A. Programmation des automates.  2e √©d., Saint-P√©tersbourg.: Peter, 2011 .-- 176 p. <br>  10. Rambo J., Jacobson A., Butch G. UML: r√©f√©rence sp√©ciale.  - Saint-P√©tersbourg: Peter, 2002 .-- 656 p. <br>  11. Goma H. ‚Äã‚ÄãUML.  Conception de syst√®mes temps r√©el, d'applications parall√®les et distribu√©es: Per.  de l'anglais  - M.: DMK Press, 2002. - 2002. - 704 p. <br>  12. SHALYTO A.A.  Technologie SWITCH.  Algorithmisation et programmation des t√¢ches de contr√¥le logique.  Saint-P√©tersbourg: Nauka, 1998.628 s. <br>  13. Rogachev G.N.  Notations Stateflow.  <a href="http://bourabai.kz/cm/stateflow13.htm" rel="nofollow">bourabai.kz/cm/stateflow13.htm</a> , gratuit.  Yaz.  Russe  (date de l'appel 01.10.2020). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr483610/">https://habr.com/ru/post/fr483610/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr483598/index.html">Des oeufs de P√¢ques encore plus musicaux: on continue de parler de cadeaux pour des auditeurs attentifs</a></li>
<li><a href="../fr483600/index.html">Lib√©rez votre Android</a></li>
<li><a href="../fr483602/index.html">Conf√©rence DefCon 27: Dans les coulisses de la cr√©ation de badges √©lectroniques 2e partie</a></li>
<li><a href="../fr483604/index.html">Iridium: recevoir et d√©coder des signaux de constellation de satellites √† domicile</a></li>
<li><a href="../fr483608/index.html">Visualisation des limites d'une solution de classificateur bas√©e sur l'image</a></li>
<li><a href="../fr483612/index.html">Un conducteur de Tesla condamn√© √† une amende pour s'√™tre bross√© les dents pendant qu'il conduisait sur un pilote automatique</a></li>
<li><a href="../fr483614/index.html">M√©thodes de lutte contre le vol dans un club de robotique</a></li>
<li><a href="../fr483616/index.html">Projet Lacmus: comment la vision par ordinateur aide √† sauver des personnes perdues</a></li>
<li><a href="../fr483626/index.html">Comment d√©crire un job 100 gitlab en 100 lignes sur Jsonnet</a></li>
<li><a href="../fr483628/index.html">G√©n√©ration de code d'OpenAPI v3 (aka Swagger 3) vers TypeScript et pas seulement</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>