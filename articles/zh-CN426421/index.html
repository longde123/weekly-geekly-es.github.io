<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍✈️ 🍆 🤞🏻 EHCI人为俄语 🤚🏼 🧘🏼 🙆🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="引言 
 我欢迎大家 今天，我想分享我的经验，但我认为，乍一看，我仍然清楚地解释了USB 2.0主机控制器的简单标准。 

 最初，您可以想象一个USB 2.0端口只有4个引脚，其中两个仅用于传输数据（例如，一个COM端口），但实际上并非如此，甚至完全相反。 原则上，USB控制器不允许我们像通过常规...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EHCI人为俄语</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426421/"><img src="https://habrastorage.org/webt/kk/0o/he/kk0ohepnkx9kfrbmht7mtec5pr4.jpeg" alt="图片"><br><br><h3>  <b>引言</b> </h3><br> 我欢迎大家 今天，我想分享我的经验，但我认为，乍一看，我仍然清楚地解释了USB 2.0主机控制器的简单标准。 <br><br> 最初，您可以想象一个USB 2.0端口只有4个引脚，其中两个仅用于传输数据（例如，一个COM端口），但实际上并非如此，甚至完全相反。 原则上，USB控制器不允许我们像通过常规COM端口那样传输数据。  EHCI是一个相当复杂的标准，它允许以相反的方向从软件到设备本身进行可靠，快速的数据传输。 <br><br> 例如，如果您没有足够的驱动程序编写技能和硬件的阅读文档，您可能会发现本文很有用。 一个简单的例子：您要为小型PC编写OS，以使某些Windows或其他Linux发行版本不下载硬件，并且将其所有功能专用于您自己的目的。 <br><a name="habracut"></a><br><h3>  <b>什么是EHCI？</b> </h3><br> 好吧，让我们开始吧。  EHCI-增强型主机控制器接口，旨在将数据和控制请求传输到USB设备，并且在另一个方向上进行传输，在99％的情况下，它是任何软件和物理设备之间的链接。  EHCI用作PCI设备，因此使用MMIO（内存映射的IO）来控制控制器（是的，我知道有些PCI设备使用端口，但是这里我概括了所有内容）。 英特尔的文档仅描述了操作原理，而对于至少以伪代码编写的所有算法都没有任何提示。  EHCI有两种类型的MMIO寄存器：功能和操作。 前者用来获得控制器的特性，而后者用来控制它。 实际上，我将附上软件与EHCI控制器之间连接的本质： <br><br><img src="https://habrastorage.org/webt/rh/px/zr/rhpxzre1s167jv51xhcz_shffsu.jpeg" alt="图片"><br><br> 每个EHCI控制器都有几个端口，每个端口都可以连接到任何USB设备。 另外，请注意，EHCI是UHCI的改进版本，它也是英特尔几年前开发的。 为了向后兼容，任何版本低于EHCI的UHCI / OHCI控制器都将作为EHCI的伴侣。 例如，您有一个可以在USB 1.1上使用的USB键盘（到目前为止，到目前为止，大多数键盘都是这样的）（请注意，USB 1.1的最大速度为每秒12兆位，而FullSpeed USB 2.0具有带宽最高可达480 Mbps），并且您有一台带有USB 2.0端口的计算机，将键盘连接到计算机时，EHCI主机控制器可以与USB 1.1一起使用。 下图显示了该模型： <br><br><img src="https://habrastorage.org/webt/61/mg/lf/61mglfeajk5ivpcqmwjkazxniwy.jpeg" alt="图片"><br><br> 另外，将来，我想立即警告您，由于这种荒唐的情况，您的驱动程序可能无法正常工作：您先初始化UHCI，然后初始化EHCI，同时添加两个相同的设备，将端口所有者控制位设置为端口寄存器，然后由于EHCI自动将端口拖到自身上，并且UHCI上的端口停止响应，因此UHCI停止工作，需要对此情况进行监视。 <br><br> 另外，让我们看一下显示EHCI体系结构本身的图： <br><br><img src="https://habrastorage.org/webt/vq/t-/nt/vqt-ntbqnrcrz4k8he1uzngwyyo.jpeg" alt="图片"><br><br> 右边写的是关于队列的信息，稍后再写。 <br><br><h2>  EHCI控制器寄存器 </h2><br> 首先，我想再次澄清一下，通过这些寄存器，您将控制您的设备，因此它们非常重要-没有它们，EHCI编程是不可能的。 <br><br> 首先，您需要获取提供给该控制器的MMIO地址，偏移量+ 0x10将是我们等待已久的寄存器的地址。 有一件事情：首先，能力寄存器进入，并且只有在它们之后-操作，因此，偏移量为0（相对于EHCI MMIO的起始地址在偏移量0x10处接收到的先前地址），只有一个字节—能力寄存器的长度。 <br><br><h3>  <b>能力寄存器</b> </h3><br>  <b>HCIVERSION</b>寄存器<b>位于</b>偏移量2 <b>处</b> -该HC的修订版号，占2个字节，并包含修订版的BCD版本（可以在Wikipedia上找到什么BCD）。 <br>  <b>HCSPARAMS</b>寄存器<b>位于</b>偏移量+4 <b>处</b> ，其大小为2个字，它包含器件的结构参数，其位如下所示： <br><br><ul><li> 位16-端口指示器-已连接的USB设备的可用LED。 </li><li> 位15:12-分配给该控制器的配套控制器的编号 </li><li> 位11：8-随播控制器上的端口数 </li><li> 位7-端口路由规则-显示这些端口如何映射到配套端口 </li><li> 位4-端口电源控制-指示是否需要打开每个端口的电源，0-自动提供电源 </li><li> 位3：0-此控制器的端口数。 </li><li>  HCCPARAMS寄存器位于偏移量+8处-它显示兼容性参数，其位表示以下内容： </li><li> 位2-异步队列可用性， </li><li> 位1-定期（顺序）队列可用性 </li><li> 位0-64位兼容性 </li></ul><br><h3>  <b>操作寄存器</b> </h3><br> 在偏移0处， <b>USBCMD</b>寄存器是控制器的命令寄存器，其位表示以下含义： <br><br><ul><li> 位23:16-中断阈值控制-显示一个常规帧将使用多少个微帧。 越大，速度越快，但如果大于8，则微帧将以与8相同的速度处理。 </li><li> 位6-异步队列中的每个事务之后中断， </li><li> 位5-是使用的异步队列 </li><li> 第4位-顺序队列的使用， </li><li> 位3：2-FrameList'a的大小（稍后会详细介绍）。  0表示1024个元素，1-512，2-256，3-保留 </li><li> 位1 —设置为重置主机控制器。 </li><li> 位0-运行/停止 </li></ul>  。 <br> 接下来，在偏移量+4处，有一个<b>USBSTS</b>寄存器-主机控制器的状态， <br><br><ul><li> 位15指示是否正在使用异步队列。 </li><li> 位14指示是否正在使用顺序队列， </li><li> 位13-指示已检测到空异步队列， </li><li> 位12设置为1，如果在处理事务时发生错误，则主机控制器将停止所有队列。 </li><li> 位4设置为1，如果发生严重错误，主机控制器将停止所有队列。 </li><li>  Bit 3 FrameList（寄存器）翻转-当主机控制器处理整个frameList时，设置为1。 </li><li> 位1-USB错误中断-是否生成错误中断？ </li><li> 位0-USB中断-如果在TD中安装了IOC，则在成功进行事务处理后置位 </li></ul><br> 不累吗 您可以给自己倒一个坚固的海鸥并带上肝脏，我们才刚刚起步！ <br><br> 在偏移+8处，有一个<b>USBINTR</b>寄存器-中断使能寄存器 <br> 为了长时间不写入，甚至更长时间不写入，可以在规范中找到该寄存器的位值，其链接将留在下面。 在这里我只写0，因为 我绝对不希望编写处理程序，映射中断等，因此我认为这几乎是毫无意义的。 <br><br> 在偏移量+12（0x0C）处，位于<b>FRINDEX</b>寄存器中，当前帧号仅位于其中，我要注意的是，最后4位显示微帧号，在高28位中显示帧号（该值不一定小于frameList的大小）但是，如果您需要索引，最好带0x3FF（或0x1FF等）的掩码。 <br><br>  <b>CTRLDSSEGMENT</b>寄存器的偏移量为+ 0x10；它向主机控制器显示了帧表地址的最高32位。 <br><br>  <b>PERIODICLISTBASE</b>寄存器的偏移量为+ 0x14，可以将帧表的低32位放入其中，请注意，该地址应与内存页的大小（4096）对齐。 <br><br>  <b>ASYNCLISTADDR</b>寄存器的偏移量为+ 0x18，您可以将异步队列的地址放入其中，请注意，它必须在32字节的边界处对齐，而它必须在物理内存的前4 GB中。 <br><br>  <b>CONFIGFLAG</b>寄存器指示是否配置了器件。 完成设备设置后，必须将位0设置为0，偏移量为+ 0x40。 <br><br> 让我们继续进行端口寄存器。 每个端口都有自己的命令状态寄存器，每个端口寄存器的偏移量为<b>+ 0x44 +（PortNumber-1）* 4</b> ，其位表示以下含义： <br><br><ul><li> 位12-端口电源，1-提供电源，0-否。 </li><li> 位8-端口静止-设置为复位设备。 </li><li> 位3-端口启用/禁用更改-更改端口的“包含”状态时设置。 </li><li> 位2-端口打开/关闭。 </li><li> 位1-更改连接状态，例如，如果您连接或断开了USB设备，则设置为1。 </li><li> 位0-连接状态，1-已连接，0-否。 </li></ul><br> 现在让我们继续汁液本身。 <br><br><h2> 数据传输和查询结构 </h2><br> 组织用于处理请求的结构包括队列和传输描述符（TD）。 <br><br> 目前，我们仅考虑3种结构。 <br><br><h3> 顺序表 </h3><br> 顺序（周期性，周期性）列表的组织方式如下： <br><br><img src="https://habrastorage.org/webt/hv/2h/23/hv2h23mnmv5uks1ffugte6ycpcu.jpeg" alt="图片"><br><br> 如您在图中所看到的，处理开始于从工作表框架中获取所需的框架，其每个元素占用4个字节，并具有以下结构： <br><br><img src="https://habrastorage.org/webt/o_/m7/ic/o_m7icnqm0ifgvnfpfycwahilwy.jpeg" alt="图片"><br><br> 如图所示，队列地址/描述符传输在32个字节的边界对齐，位0表示主机控制器将不处理此元素，位3：1表示主机控制器将处理的类型：0-等时TD （iTD），第1转，第2和第3条，我将不予考虑。 <br><br><h3> 异步队列 </h3><br> 仅当顺序帧为空或主机控制器已处理整个序列表时，主机控制器才处理此队列。 <br><br> 异步队列是指向包含其他需要处理的队列的队列的指针。 方案： <br><br><img src="https://habrastorage.org/webt/rz/sv/4s/rzsv4sqoyqegzwqoij9vl7qpt14.jpeg" alt="图片"><br><br><h3>  qTD（队列元素传输描述符） </h3><br> 该TD具有以下结构： <br><br><img src="https://habrastorage.org/webt/hf/gq/g5/hfgqg5fvujkx2bv8piy6i3gijyu.jpeg" alt="图片"><br><br>  <b>下一个qTD指针</b> -指向要继续处理的队列的指针（用于水平执行），位0下一个qTD指针指示没有其他队列。 <br>  <b>qTD令牌</b> -TD令牌，显示数据传输参数： <br><br><ul><li> 第31位-数据切换（稍后会详细介绍） </li><li> 位30:16-要传输的数据量，在事务完成之后，其值将减少传输的数据量。 </li><li> 位15-IOC-中断完成-在描述符处理完成后引起中断。 </li><li> 位14:12显示了当前缓冲区的交换编号，从该缓冲区交换数据，稍后将对此进行更多说明。 </li><li> 位11:10-允许的错误数。 下表显示错误计数减少的时间： <br><br><img src="https://habrastorage.org/webt/ko/hz/ia/kohzia9y2vxtrd1tepp-h5qokgm.jpeg" alt="图片"><br><br> 脚注1-检测到Babble或Stall会自动停止队列开头的执行。 脚注3-主机存在数据缓冲区错误。 他们不考虑设备重试。 </li><li>  9：8-PID代码-令牌类型：0-输入令牌（从主机到设备），1-输出令牌（从设备到主机），2-“ SETUP”令牌 </li><li> 位7：0指示TD状态： <br> 位7表示TD处于活动状态（即，主机控制器处理该TD） <br> 位6-暂停-表示已发生错误，并且TD执行已停止。 <br> 位4-已检测到Babble-我们发送到设备的数据量（或每转一圈）少于我们传输的数据量，例如，该设备向我们发送了100字节的数据，而我们仅读取了50个字节，然后又读取了50个字节如果该位设置为1，还将设置Halted位。 <br> 位3-交易错误-交易期间发生错误。 </li></ul><br>  <b>qTD缓冲区页面指针列表</b> -5个缓冲区中的任何一个。 它包含一个链接，指向要在内存中进行交易的位置（将数据发送到设备/从设备接收数据），缓冲区中除第一个缓冲区外的所有地址都应与页面的大小（4096字节）对齐。 <br><br><h3> 线头 </h3><br> 队列头具有以下结构： <br><br><img src="https://habrastorage.org/webt/9m/ob/l7/9mobl76mr1drsddxbgndgbgoneo.jpeg" alt="图片"><br><br>  <b>队列头水平链接指针</b> -指向下一个队列的指针，位2：1根据队列类型具有以下值： <br><br><img src="https://habrastorage.org/webt/bu/gw/sa/bugwsap9snr11blm5ifggvhei60.jpeg" alt="图片"><br><br>  <b>端点功能/特征</b> -队列特征： <br><br><ul><li> 位26:16包含用于传输的最大数据包大小 </li><li> 位14：数据切换控制-显示主机控制器应在何处获取初始数据切换值，0-忽略qTD中的DT位，将DT位保存为队列头。 </li><li> 位13:12-传输速率特征： <img src="https://habrastorage.org/webt/gk/tb/sd/gktbsdm7kys5kcgk6e3uewkgf1q.jpeg" alt="图片"></li><li> 位11：8-向其发出请求的端点的编号 </li><li> 位6：0-设备地址 </li></ul><br>  <b>端点功能：队列头DWord 2-</b>上一个双字的延续： <br><br><ul><li> 位29:23-集线器编号 </li><li> 位22:16-集线器地址 </li></ul><br>  <b>当前qTD链接指针</b> -指向<b>当前qTD的指针</b> 。 <br><br> 我们传递给最有趣的。 <br><br><h2>  EHCI驱动程序 </h2><br> 让我们从EHCI可以满足的查询开始。 有两种类型的请求：控制-一个la命令，以及批量-到端点，用于数据交换，例如，绝大多数USB闪存驱动器（USB MassStorage）使用数据传输类型Bulk / Bulk / Bulk。 鼠标和键盘还使用批量请求进行数据传输。 <br><br> 初始化EHCI并配置异步和顺序队列： <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Base I/O Address PciBar bar; PciGetBar(&amp;bar, id, 0); EhciController *hc = VMAlloc(sizeof(EhciController)); hc-&gt;capRegs = (EhciCapRegs *)(uintptr_t)bar.u.address; hc-&gt;opRegs = (EhciOpRegs *)(uintptr_t)(bar.u.address + hc-&gt;capRegs-&gt;capLength); // Read the Command register //    uint cmd = ROR(usbCmdO); // Write it back, setting bit 2 (the Reset bit) //   ,   2(Reset) // and making sure the two schedule Enable bits are clear. //  ,  2   WOR(usbCmdO, 2 | cmd &amp; ~(CMD_ASE | CMD_PSE)); // A small delay here would be good. You don't want to read //     ,     // the register before it has a chance to actually set the bit //   ,         ROR(usbCmdO); // Now wait for the controller to clear the reset bit. //      Reset while (ROR(usbCmdO) &amp; 2); // Again, a small delay here would be good to allow the // reset to actually become complete. //   ROR(usbCmdO); // wait for the halted bit to become set //    Halted    while (!(ROR(usbStsO) &amp; STS_HCHALTED)); //     ,        // ,           128  hc-&gt;frameList = (u32 *)VMAlloc(1024 * sizeof(u32) + 8192 * 4); hc-&gt;frameList = (((uint)hc-&gt;frameList) / 16384) * 16384 + 16384; hc-&gt;qhPool = (EhciQH *)VMAlloc(sizeof(EhciQH) * MAX_QH + 8192 * 4); hc-&gt;tdPool = (EhciTD *)VMAlloc(sizeof(EhciTD) * MAX_TD + 8192 * 4); hc-&gt;qhPool = (((uint)hc-&gt;qhPool) / 16384) * 16384 + 16384; hc-&gt;tdPool = (((uint)hc-&gt;tdPool) / 16384) * 16384 + 16384; // Asynchronous queue setup //    EhciQH *qh = EhciAllocQH(hc); //     ,      // ,    qh-&gt;qhlp = (u32)(uintptr_t)qh | PTR_QH; //  ,  ,     qh-&gt;ch = QH_CH_H; qh-&gt;caps = 0; qh-&gt;curLink = 0; qh-&gt;nextLink = PTR_TERMINATE; qh-&gt;altLink = 0; qh-&gt;token = 0; //    for (uint i = 0; i &lt; 5; ++i) { qh-&gt;buffer[i] = 0; qh-&gt;extBuffer[i] = 0; } hc-&gt;asyncQH = qh; // Periodic list queue setup //    qh = EhciAllocQH(hc); //     qh-&gt;qhlp = PTR_TERMINATE; qh-&gt;ch = 0; qh-&gt;caps = 0; qh-&gt;curLink = 0; qh-&gt;nextLink = PTR_TERMINATE; qh-&gt;altLink = 0; qh-&gt;token = 0; //   for (uint i = 0; i &lt; 5; ++i) { qh-&gt;buffer[i] = 0; qh-&gt;extBuffer[i] = 0; } qh-&gt;transfer = 0; qh-&gt;qhLink.prev = &amp;qh-&gt;qhLink; qh-&gt;qhLink.next = &amp;qh-&gt;qhLink; hc-&gt;periodicQH = qh; //        for (uint i = 0; i &lt; 1024; ++i) hc-&gt;frameList[i] = PTR_QH | (u32)(uintptr_t)qh; kprintf("FrameList filled. Turning off Legacy BIOS support..."); // Check extended capabilities //  BIOS Legacy support uint eecp = (RCR(hccParamsO) &amp; HCCPARAMS_EECP_MASK) &gt;&gt; HCCPARAMS_EECP_SHIFT; if (eecp &gt;= 0x40) { // Disable BIOS legacy support uint legsup = PciRead32(id, eecp + USBLEGSUP); kprintf("."); if (legsup &amp; USBLEGSUP_HC_BIOS) { PciWrite32(id, eecp + USBLEGSUP, legsup | USBLEGSUP_HC_OS); kprintf("."); for (;;) { legsup = PciRead32(id, eecp + USBLEGSUP); kprintf("."); if (~legsup &amp; USBLEGSUP_HC_BIOS &amp;&amp; legsup &amp; USBLEGSUP_HC_OS) { break; } } } } kprintf("Done\n"); // Disable interrupts //   //hc-&gt;opRegs-&gt;usbIntr = 0; MWIR(ehcibase, usbIntrO, 0); // Setup frame list //     //hc-&gt;opRegs-&gt;frameIndex = 0; WOR(frameIndexO, 0); //hc-&gt;opRegs-&gt;periodicListBase = (u32)(uintptr_t)hc-&gt;frameList; WOR(periodicListBaseO, (u32)(uintptr_t)hc-&gt;frameList); //       //hc-&gt;opRegs-&gt;asyncListAddr = (u32)(uintptr_t)hc-&gt;asyncQH; WOR(asyncListAddrO, (u32)(uintptr_t)hc-&gt;asyncQH); //    0 //hc-&gt;opRegs-&gt;ctrlDsSegment = 0; WOR(ctrlDsSegmentO, 0); // Clear status //   //hc-&gt;opRegs-&gt;usbSts = ~0; WOR(usbStsO, ~0); // Enable controller //  , 8 -,  //     //hc-&gt;opRegs-&gt;usbCmd = (8 &lt;&lt; CMD_ITC_SHIFT) | CMD_PSE | CMD_ASE | CMD_RS; WOR(usbCmdO, (8 &lt;&lt; CMD_ITC_SHIFT) | CMD_PSE | CMD_ASE | CMD_RS); while (ROR(usbStsO)&amp;STS_HCHALTED); // Configure all devices to be managed by the EHCI // ,   //hc-&gt;opRegs-&gt;configFlag = 1; WOR(configFlagO, 1);\ // Probe devices //   EhciProbe(hc);</span></span></code> </pre> <br> 实际上，用于将端口重置为其原始状态的代码： <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> u32 *reg = &amp;hc-&gt;opRegs-&gt;ports[port]; <span class="hljs-comment"><span class="hljs-comment">//    ,  100 *reg|=(1&lt;&lt;12)|(1&lt;&lt;20); Wait(100); //  ,  50  EhciPortSet(reg, PORT_RESET | (1&lt;&lt;12) | (1&lt;&lt;20) | (1&lt;&lt;6)); Wait(50); EhciPortClr(reg, PORT_RESET); // Wait 100ms for port to enable (TODO - what is appropriate length of time?) //  100    ,   , //  100    uint status = 0; for (uint i = 0; i &lt; 10; ++i) { // Delay Wait(10); // Get current status //    status = *reg; // Check if device is attached to port //      if (~status &amp; PORT_CONNECTION) break; // Acknowledge change in status //    -    if (status &amp; (PORT_ENABLE_CHANGE | PORT_CONNECTION_CHANGE)) { EhciPortClr(reg, PORT_ENABLE_CHANGE | PORT_CONNECTION_CHANGE); continue; } // Check if device is enabled //    ,    if (status &amp; PORT_ENABLE) break; } return status;</span></span></code> </pre><br> 对设备的控制请求： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EhciDevControl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UsbDevice *dev, UsbTransfer *t)</span></span></span><span class="hljs-function"> </span></span>{ EhciController *hc = (EhciController *)dev-&gt;hc; UsbDevReq *req = t-&gt;req; <span class="hljs-comment"><span class="hljs-comment">// Determine transfer properties //    uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint maxSize = dev-&gt;maxPacketSize; uint type = req-&gt;type; uint len = req-&gt;len; // Create queue of transfer descriptors //   TDs EhciTD *td = EhciAllocTD(hc); if (!td) return; EhciTD *head = td; EhciTD *prev = 0; // Setup packet //   uint toggle = 0; uint packetType = USB_PACKET_SETUP; uint packetSize = sizeof(UsbDevReq); EhciInitTD(td, prev, toggle, packetType, packetSize, req); prev = td; // Data in/out packets packetType = type &amp; RT_DEV_TO_HOST ? USB_PACKET_IN : USB_PACKET_OUT; u8 *it = (u8 *)t-&gt;data; u8 *end = it + len; //EhciPrintTD(td); while (it &lt; end) { td = EhciAllocTD(hc); if (!td) return; toggle ^= 1; packetSize = end - it; if (packetSize &gt; maxSize) packetSize = maxSize; EhciInitTD(td, prev, toggle, packetType, packetSize, it); it += packetSize; prev = td; } // Status packet //   td = EhciAllocTD(hc); if (!td) return; toggle = 1; packetType = type &amp; RT_DEV_TO_HOST ? USB_PACKET_OUT : USB_PACKET_IN; EhciInitTD(td, prev, toggle, packetType, 0, 0); // Initialize queue head //   : EhciQH *qh = EhciAllocQH(hc); EhciInitQH(qh, t, head, dev-&gt;parent, false, speed, addr, 0, maxSize); // Wait until queue has been processed //       EhciInsertAsyncQH(hc-&gt;asyncQH, qh); EhciWaitForQH(hc, qh); }</span></span></code> </pre><br> 队列处理代码： <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_HALTED) { t-&gt;success = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; t-&gt;complete = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;nextLink &amp; PTR_TERMINATE) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (~qh-&gt;token &amp; TD_TOK_ACTIVE) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_DATABUFFER) kprintf(<span class="hljs-string"><span class="hljs-string">" Data Buffer Error\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_BABBLE) kprintf(<span class="hljs-string"><span class="hljs-string">" Babble Detected\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_XACT) kprintf(<span class="hljs-string"><span class="hljs-string">" Transaction Error\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_MMF) kprintf(<span class="hljs-string"><span class="hljs-string">" Missed Micro-Frame\n"</span></span>); t-&gt;success = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; t-&gt;complete = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t-&gt;complete) ....</code> </pre><br> 现在是端点请求（批量请求） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EhciDevIntr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UsbDevice *dev, UsbTransfer *t)</span></span></span><span class="hljs-function"> </span></span>{ EhciController *hc = (EhciController *)dev-&gt;hc; <span class="hljs-comment"><span class="hljs-comment">// Determine transfer properties //    uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint maxSize = t-&gt;endp-&gt;desc-&gt;maxPacketSize; uint endp = t-&gt;endp-&gt;desc-&gt;addr &amp; 0xf; EhciTD *td = EhciAllocTD(hc); if (!td) { t-&gt;success = false; t-&gt;complete = true; return; } EhciTD *head = td; EhciTD *prev = 0; // Data in/out packets uint toggle = t-&gt;endp-&gt;toggle; uint packetType = t-&gt;endp-&gt;desc-&gt;addr &amp; 0x80 ? USB_PACKET_IN : USB_PACKET_OUT; uint packetSize = t-&gt;len; EhciInitTD(td, prev, toggle, packetType, packetSize, t-&gt;data); // Initialize queue head //    EhciQH *qh = EhciAllocQH(hc); EhciInitQH(qh, t, head, dev-&gt;parent, true, speed, addr, endp, maxSize); //printQh(qh); // Schedule queue //    EhciInsertPeriodicQH(hc-&gt;periodicQH, qh); }</span></span></code> </pre><br> 我认为该主题非常有趣，俄语版本的互联网上几乎没有有关该主题的文档，描述和文章，如果有的话，则非常模糊。 如果涉及硬件和OS开发的主题很有趣，那么有很多事情要说。 <br><br> 底座： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">规格</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN426421/">https://habr.com/ru/post/zh-CN426421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN426411/index.html">开发C ++ / CLI描述符类</a></li>
<li><a href="../zh-CN426413/index.html">每个开发人员都应了解的SOLID原则</a></li>
<li><a href="../zh-CN426415/index.html">金融科技摘要：中央银行的数字化控制，加密货币工资，手镯和钥匙圈形式的Mir卡</a></li>
<li><a href="../zh-CN426417/index.html">Pavel 2.0：JS，带有套接字和电话的node.js上的复制顾问</a></li>
<li><a href="../zh-CN426419/index.html">Java中禁止的重载或桥接方法</a></li>
<li><a href="../zh-CN426423/index.html">mmWave在智能手机上：高通如何使不可能变为可能</a></li>
<li><a href="../zh-CN426425/index.html">关于RTOS的全部真相。 第十四条 内存部分：简介和基本服务</a></li>
<li><a href="../zh-CN426427/index.html">对“东西”有用的东西：少量低价选择</a></li>
<li><a href="../zh-CN426429/index.html">在Debian 9上安装FreeSWITCH 1.8（Raspbian Stretch，Rasbperri Pi上MajorDoMo智能家庭系统的基本映像）</a></li>
<li><a href="../zh-CN426431/index.html">拆卸Qlie视觉小说引擎</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>