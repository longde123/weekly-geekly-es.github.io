<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç± üôçüèæ üëçüèΩ Testes de regress√£o visual. Reiniciar ü¶ç üö£üèΩ ü§™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No meu artigo anterior, falei sobre a experi√™ncia de usar o mecanismo Gemini para desenvolver testes visuais, ou melhor, testes de regress√£o visual. E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testes de regress√£o visual. Reiniciar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/479040/">  No meu <a href="https://habr.com/ru/post/454464/">artigo</a> anterior, falei sobre a experi√™ncia de usar o mecanismo <a href="https://github.com/gemini-testing/gemini">Gemini</a> para desenvolver testes visuais, ou melhor, testes de regress√£o visual.  Esses testes verificam se algo ‚Äúmudou‚Äù na interface do usu√°rio ap√≥s as pr√≥ximas altera√ß√µes, comparando as capturas de tela atuais com as de refer√™ncia corrigidas anteriormente.  Desde ent√£o, muita coisa mudou em nossas abordagens para escrever testes visuais, incluindo o mecanismo usado.  Agora usamos <a href="https://github.com/gemini-testing/hermione">Hermione</a> , mas neste artigo vou falar n√£o apenas e n√£o tanto sobre Hermione, mas sobre os problemas que se acumularam desde ent√£o e como resolv√™-los, o que, entre outras coisas, levou √† transi√ß√£o para um novo mecanismo. <br><a name="habracut"></a><br>  Em primeiro lugar, embora os testes funcionassem e com bastante sucesso, n√£o t√≠nhamos um entendimento claro do que era coberto pelos testes e do que n√£o era.  Havia, √© claro, alguma id√©ia do grau de cobertura, mas n√£o a medimos quantitativamente.  Em segundo lugar, a composi√ß√£o dos testes aumentou com o tempo e testes diferentes frequentemente testavam a mesma coisa, porque  em capturas de tela diferentes, alguma parte coincidia com a mesma parte, mas em uma captura de tela diferente.  Como resultado, mesmo pequenas altera√ß√µes no CSS podem sobrecarregar muitos testes ao mesmo tempo e exigir a atualiza√ß√£o de um grande n√∫mero de padr√µes.  Em terceiro lugar, um tema sombrio apareceu em nosso produto e, para cobri-lo de alguma forma com testes, alguns testes foram selecionados seletivamente para usar um tema sombrio, o que tamb√©m n√£o adicionava clareza ao problema ao determinar o grau de cobertura. <br><br><h2>  Otimiza√ß√£o de desempenho </h2><br>  Estranhamente, come√ßamos com desempenho otimizado.  Eu vou explicar o porqu√™.  Nossos testes visuais s√£o baseados no <a href="https://github.com/storybooks/storybook">Storybook</a> .  Cada hist√≥ria do livro de hist√≥rias n√£o √© um componente √∫nico, mas um "bloco" inteiro (por exemplo, uma grade com uma lista de entidades, um cart√£o de entidade, di√°logo ou mesmo o aplicativo como um todo).  Para exibir este bloco, voc√™ precisa ‚Äúbombear‚Äù a hist√≥ria com dados, n√£o apenas os dados exibidos para o usu√°rio, mas tamb√©m o estado dos componentes usados ‚Äã‚Äãdentro do bloco.  Essas informa√ß√µes s√£o armazenadas junto com o c√≥digo-fonte na forma de arquivos json que cont√™m uma representa√ß√£o serializada do estado do aplicativo (reposit√≥rio redux).  Sim, esses dados s√£o, para dizer o m√≠nimo, redundantes, mas simplificam bastante a cria√ß√£o de testes.  Para criar um novo teste, basta abrir o cart√£o, a lista ou o di√°logo desejado no aplicativo, tirar uma foto do estado atual do aplicativo e serializ√°-lo em um arquivo.  Em seguida, adicionamos uma nova hist√≥ria e testes que fazem capturas de tela dessa hist√≥ria (todas em poucas linhas de c√≥digo). <br><br>  Essa abordagem inevitavelmente aumenta o tamanho do pacote.  O grau de duplica√ß√£o de dados nele apenas "passa".  Ao executar testes, o mecanismo gemini executa cada su√≠te de testes em uma sess√£o separada do navegador.  Cada sess√£o carrega o pacote novamente e o tamanho do pacote nesse esquema est√° longe do √∫ltimo valor. <br><br>  Para reduzir o tempo de execu√ß√£o do teste, reduzimos o n√∫mero de su√≠tes de teste aumentando o n√∫mero de testes neles.  Assim, um conjunto de testes pode afetar v√°rias hist√≥rias de uma s√≥ vez.  Nesse esquema, praticamente perdemos a capacidade de ‚Äúrastrear‚Äù apenas uma determinada √°rea da tela devido ao fato de o Gemini permitir que voc√™ defina a √°rea de captura de tela apenas para o conjunto de testes como um todo (embora a API permita que voc√™ fa√ßa isso antes de cada captura de tela, mas, na pr√°tica, n√£o funciona). <br><br>  A incapacidade de limitar a √°rea da captura de tela nos testes levou √† duplica√ß√£o de informa√ß√µes visuais nas imagens de refer√™ncia.  Embora n√£o houvesse muitos testes, esse problema n√£o parecia significativo.  Sim, e a interface do usu√°rio n√£o mudou com muita frequ√™ncia.  Mas isso n√£o poderia durar para sempre - uma reformula√ß√£o apareceu no horizonte. <br><br>  Olhando para o futuro, direi que em Hermione uma √°rea de captura de tela pode ser definida para cada cena e, √† primeira vista, mudar para um novo mecanismo resolveria todos os problemas.  Mas ainda ter√≠amos que ‚Äúesmagar‚Äù grandes su√≠tes de teste.  O fato √© que os testes visuais n√£o s√£o inerentemente est√°veis ‚Äã‚Äã(isso pode ser devido a v√°rias raz√µes, por exemplo, com defasagens na rede, usando anima√ß√µes ou com "clima em Marte") e √© muito dif√≠cil fazer sem tentativas autom√°ticas.  G√™meos e Hermione realizam novas tentativas para a su√≠te de testes como um todo, e quanto mais espessa for a su√≠te de testes, menor a probabilidade de concluir com √™xito durante as tentativas, como  na pr√≥xima execu√ß√£o, os testes que foram conclu√≠dos anteriormente com √™xito podem cair.  Para conjuntos de testes espessos, tivemos que implementar um esquema de repeti√ß√£o alternativo incorporado ao mecanismo Gemini e realmente n√£o queremos fazer isso novamente ao mudar para um novo mecanismo. <br><br>  Portanto, para acelerar o carregamento do conjunto de testes, dividimos o pacote monol√≠tico em partes, alocando cada instant√¢neo do estado do aplicativo em uma "pe√ßa" separada, carregada "sob demanda" para cada mat√©ria separadamente.  O c√≥digo de cria√ß√£o da hist√≥ria agora se parece com isso: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// visual-regression.stories.js import React from 'react'; import StoryProvider from './story-provider'; const stories = storiesOf('visual-regression', module); [ { name: 'Contract', loadData: import('./snapshots/contract.testdata') }, { name: 'ExecutionTask', loadData: import('./snapshots/execution-task.testdata') }, { name: 'ExecutionAssignment', loadData: import('./snapshots/execution-assignment.testdata') }, { name: 'DocumentTemplate', loadData: import('./snapshots/document-template.testdata') }, { name: 'Explorer', loadData: import('./snapshots/explorer.testdata') }, { name: 'Inbox', loadData: import('./snapshots/inbox.testdata') }, ] .map(story =&gt; { stories .add(story.name, () =&gt; &lt;StoryProvider loadSnapshot={story.loadData} /&gt;) .add(`${story.name}Dark`, () =&gt; &lt;StoryProvider loadSnapshot={story.loadData} theme='night' /&gt;); });</span></span></code> </pre> <br>  Para criar uma hist√≥ria, o componente StoryProvider √© usado (seu c√≥digo ser√° fornecido abaixo).  Os instant√¢neos s√£o carregados usando a fun√ß√£o de <a href="https://webpack.js.org/guides/code-splitting/">importa√ß√£o din√¢mica</a> .  Hist√≥rias diferentes diferem entre si apenas em imagens de estados.  Para um tema sombrio, sua pr√≥pria hist√≥ria √© gerada, usando o mesmo instant√¢neo da hist√≥ria para um tema claro.  No contexto de um livro de hist√≥rias, fica assim: <br><br><div class="spoiler">  <b class="spoiler_title">Hist√≥ria do tema padr√£o</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d6/vc/uk/d6vcukhmensy0jogshjj4hifoui.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Dark theme story</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/jy/z0/uu/jyz0uuyel6t1pofayyjxftuunwg.png"><br></div></div><br>  O componente StoryProvider aceita um retorno de chamada para carregar uma captura instant√¢nea na qual a fun√ß√£o import () √© chamada.  A fun√ß√£o import () funciona de forma ass√≠ncrona, portanto voc√™ n√£o pode capturar uma captura de tela imediatamente ap√≥s carregar a hist√≥ria - corremos o risco de remover o vazio.  Para capturar o momento do final do download, o provedor renderiza o elemento DOM do marcador sinalizando o mecanismo de teste durante todo o tempo do download, que deve ser adiado com a captura de tela: <br><br><div class="spoiler">  <b class="spoiler_title">story-provider.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// story-provider.js const propsStub = { // -,      . . . }; type Props = { loadSnapshot: () =&gt; Object, theme: ?string }; const StoryProvider = (props: Props) =&gt; { const [ snapshotState, setsnapshotState ] = React.useState(null); React.useEffect(() =&gt; { //    (async() =&gt; setsnapshotState((await props.loadSnapshot).default))(); }); if (!snapshotState) //     ,     return &lt;div className={'loading-stub'}&gt;Loading...&lt;/div&gt;; //    snapshotState.metadata = require('./snapshots/metadata'); //  redux-   const store = createMockStore(snapshotState); //   applyTheme(props.theme); return ( &lt;Provider store={store}&gt; &lt;MemoryRouter&gt; &lt;App {...propsStub} /&gt; &lt;/MemoryRouter&gt; &lt;/Provider&gt; ); }; export default StoryProvider;</span></span></code> </pre><br></div></div><br>  Al√©m disso, para reduzir o tamanho do pacote, desative a adi√ß√£o de mapas de origem ao pacote.  Mas, para n√£o perder a capacidade de depurar a hist√≥ria (voc√™ nunca sabe o que), fazemos isso sob a condi√ß√£o: <br><br><div class="spoiler">  <b class="spoiler_title">.storybook / webpack.config.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// .storybook/webpack.config.js ... module.exports = { ... devtool: process.env.NODE_ENV === 'vr-test' ? '(none)' : 'eval-source-map' };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">package.json</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// package.json { ... "scripts": { ... "storybook": "start-storybook", "build-storybook": "cross-env NODE_ENV=vr-test build-storybook -o ./storybook-static", ... },</span></span></code> </pre><br></div></div><br>  O <b>script build-storybook do npm run</b> compila um livro de hist√≥rias est√°tico sem o mapa de origem na pasta est√°tica do livro de hist√≥rias.  √â usado ao executar testes.  E o <b>script de livro de hist√≥rias npm run √©</b> usado para desenvolver e depurar hist√≥rias de teste. <br><br><h2>  Elimina√ß√£o da duplica√ß√£o de informa√ß√µes visuais </h2><br>  Como eu disse acima, o Gemini permite definir seletores de √°rea de captura de tela para o conjunto de testes como um todo, o que significa que, para resolver completamente o problema de duplicar informa√ß√µes visuais nas capturas de tela, ter√≠amos que criar nosso pr√≥prio conjunto de testes para cada captura de tela.  Mesmo levando em considera√ß√£o a otimiza√ß√£o do carregamento da hist√≥ria, ela n√£o parecia muito otimista em termos de velocidade e pensamos em mudar o mecanismo de teste. <br><br>  Na verdade, por que Hermione?  Atualmente, o reposit√≥rio Gemini est√° marcado como obsoleto e, mais cedo ou mais tarde, tivemos que "mudar" para algum lugar.  A estrutura do arquivo de configura√ß√£o Hermione √© id√™ntica √† estrutura do arquivo de configura√ß√£o Gemini e pudemos reutilizar essa configura√ß√£o.  Os plugins G√™meos e Hermione tamb√©m s√£o comuns.  Al√©m disso, pudemos reutilizar a infraestrutura de teste - m√°quinas virtuais e implantamos a grade de sel√™nio. <br><br>  Ao contr√°rio de G√™meos, Hermione n√£o est√° posicionada como uma ferramenta apenas para testes de regress√£o de layout.  Seus recursos de manipula√ß√£o de navegador s√£o muito mais amplos e limitados apenas pelos recursos do <a href="http://v4.webdriver.io/">Webdriver IO</a> .  Em combina√ß√£o com o <a href="https://github.com/mochajs/mocha">mocha,</a> esse mecanismo √© conveniente para usar mais em testes funcionais (simulando a√ß√µes do usu√°rio) do que em testes de layout.  Para teste de regress√£o do layout, Hermione fornece apenas o m√©todo assertView (), que compara uma captura de tela de uma p√°gina do navegador com uma refer√™ncia.  A captura de tela pode ser limitada √† √°rea especificada usando seletores de css. <br><br>  Para o nosso caso, o teste para cada hist√≥ria individual ficaria assim: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    describe('Visual regression', function() { it('Contract card should equal to etalon', function() { return this.browser //  story   .url('http://localhost:8080/iframe.html?selectedKind=visual-regression&amp;selectedStory=ContractDark') // ,      story .waitForVisible('.loading-stub', true) //          .assertView('layout', '.form'); }) });</span></span></code> </pre><br>  O m√©todo waitForVisible (), apesar do nome, permite esperar n√£o apenas a apar√™ncia, mas tamb√©m a oculta√ß√£o do elemento, se voc√™ definir o segundo par√¢metro como true.  Aqui, usamos para aguardar a oculta√ß√£o de um elemento marcador, indicando que o instant√¢neo de dados ainda n√£o foi carregado e a hist√≥ria ainda n√£o est√° pronta para uma captura de tela. <br><br>  Se voc√™ tentar encontrar o m√©todo waitForVisible () na documenta√ß√£o da Hermione, n√£o encontrar√° nada.  O fato √© que o <a href="http://v4.webdriver.io/api/utility/waitForVisible.html">m√©todo</a> waitForVisible () <a href="http://v4.webdriver.io/api/utility/waitForVisible.html">√© o m√©todo da API Webdriver IO</a> .  O m√©todo url (), respectivamente, tamb√©m.  No m√©todo url (), passamos o endere√ßo do quadro de uma hist√≥ria espec√≠fica, n√£o o livro de hist√≥rias inteiro.  Primeiro, isso √© necess√°rio para que a lista de hist√≥rias n√£o seja exibida na janela do navegador - n√£o precisamos test√°-la.  Em segundo lugar, se necess√°rio, podemos ter acesso aos elementos DOM dentro do quadro (os m√©todos webdriverIO permitem executar o c√≥digo JavaScript no contexto do navegador). <br><br>  Para simplificar a grava√ß√£o dos testes, criamos nosso inv√≥lucro sobre os testes mocha.  O fato √© que n√£o h√° um sentido particular na elabora√ß√£o detalhada de casos de teste para teste de regress√£o.  Todos os casos de teste s√£o iguais - 'deve ser igual a etalon'.  Bem, tamb√©m n√£o quero duplicar o c√≥digo para aguardar o carregamento de dados em cada teste.  Portanto, o mesmo trabalho para todos os testes "monkey" √© delegado √† fun√ß√£o wrapper, e os pr√≥prios testes s√£o escritos de forma declarativa (bem, quase).  Aqui est√° o texto desta fun√ß√£o: <br><br><div class="spoiler">  <b class="spoiler_title">create-test-suite.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> themes = [ <span class="hljs-string"><span class="hljs-string">'default'</span></span>, <span class="hljs-string"><span class="hljs-string">'dark'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rootClassName = <span class="hljs-string"><span class="hljs-string">'.explorer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loadingStubClassName = <span class="hljs-string"><span class="hljs-string">'.loading-stub'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timeout = <span class="hljs-number"><span class="hljs-number">2000</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTestSuite</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">testSuite</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, storyName, browsers, testCases, selector } = testSuite; <span class="hljs-comment"><span class="hljs-comment">//  ,       browsers &amp;&amp; hermione.only.in(browsers); //      themes.forEach(theme =&gt; { describe(`${name}_${theme}`, () =&gt; it('should equal to etalon', function() { let browser = this.browser //   story .url(`${storybookUrl}/iframe.html?selectedKind=visual-regression&amp;selectedStory=${storyName}-${theme}`) //     .waitForVisible(loadingStubClassName, timeout, true) .waitForVisible(rootClassName); //    (  ) if (testCases &amp;&amp; testCases.length &gt; 0) { testCases.forEach(testCase =&gt; { if (testCase.before) browser = testCase.before(browser); browser = browser.assertView(`${name}__${testCase.name}_${theme}`, testCase.selector || selector || rootClassName, testCase.options); }); return browser; } //    ,    return browser.assertView(`${name}_${theme}`, selector || rootClassName); })); }); }</span></span></code> </pre><br></div></div><br>  Um objeto que descreve o conjunto de testes √© passado para a entrada da fun√ß√£o.  Cada su√≠te de teste √© criada de acordo com o seguinte cen√°rio: fazemos uma captura de tela do layout principal (por exemplo, uma √°rea de um cart√£o de entidade ou uma √°rea de uma lista de entidades), depois pressionamos programaticamente bot√µes que podem levar √† apar√™ncia de outros elementos (por exemplo, pain√©is pop-up ou menus de contexto) e ‚Äúcapturamos uma captura de tela ¬ªCada um desses elementos separadamente.  Assim, simulamos a√ß√µes do usu√°rio no navegador, mas n√£o com o objetivo de testar um cen√°rio de neg√≥cios, mas simplesmente para "capturar" o n√∫mero m√°ximo poss√≠vel de componentes visuais.  Al√©m disso, a duplica√ß√£o de informa√ß√µes visuais nas capturas de tela √© m√≠nima, porque  as capturas de tela s√£o feitas "no sentido hor√°rio" usando seletores.  Exemplo de su√≠te de teste: <br><br><div class="spoiler">  <b class="spoiler_title">explorer-suite.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// explorer-suite.js //         module.exports = { //  story,    storyName: 'explorer', //    name: 'explorer', //  ,       browsers: [ 'chrome-1920x1080', 'ie-1920x1080' ], //   testCases: [ { //    name: 'layout' }, { //    name: 'notification-area', selector: '.notification-area__popup', before: b =&gt; b .click('.notification-area__popup-button') .waitForVisible('.notification-area__popup') .execute(function() { //       document.querySelectorAll('.expandable-item__content')[2].click(); }) }, //... ] };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">tests.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// tests.js [ require('./suites/explorer-suite'), //... ] .forEach(suite =&gt; createTestSuite(suite));</span></span></code> </pre><br></div></div><br><h2>  Determina√ß√£o da cobertura </h2><br>  Ent√£o, como descobrimos a velocidade e a redund√¢ncia, resta descobrir a efic√°cia de nossos testes, ou seja, determinar o grau de cobertura do c√≥digo com os testes (aqui, por c√≥digo, quero dizer folhas de estilo CSS). <br><br>  Para hist√≥rias de teste, selecionamos empiricamente os cart√µes, listas e outros elementos mais complicados a serem preenchidos para cobrir o maior n√∫mero poss√≠vel de estilos com uma captura de tela.  Por exemplo, para testar um cart√£o de entidade, foram selecionados cart√µes com um grande n√∫mero de tipos diferentes de controles (texto, n√∫mero, transfer√™ncias, datas, grades etc.).  Os cart√µes para diferentes tipos de entidades t√™m especificidades pr√≥prias; por exemplo, um painel com uma lista de vers√µes de documentos pode ser exibido em um cart√£o de documentos e a correspond√™ncia nessa tarefa √© exibida no cart√£o de tarefas.  Dessa forma, para cada tipo de entidade, sua pr√≥pria hist√≥ria e um conjunto de testes espec√≠ficos para esse tipo etc. foram criados.  No final, achamos que tudo parecia coberto de testes, mas quer√≠amos um pouco mais de confian√ßa do que "gostar". <br><br>  Para avaliar a cobertura no Chrome DevTools, existe uma ferramenta com o nome Cobertura muito adequada para este caso: <br><br><img src="https://habrastorage.org/webt/ma/yt/dh/maytdhehcjiumoxdsdj-woa40lo.png"><br><br>  A cobertura permite determinar quais estilos ou qual c√≥digo js foi usado ao trabalhar com a p√°gina do navegador.  O relat√≥rio sobre o uso de listras verdes indica o c√≥digo usado, vermelho - n√£o usado.  E tudo ficaria bem se tiv√©ssemos uma aplica√ß√£o do n√≠vel "ol√°, mundo", mas o que fazer quando tivermos milhares de linhas de c√≥digo?  Os desenvolvedores de cobertura entenderam isso muito bem e forneceram a capacidade de exportar o relat√≥rio para um arquivo que j√° pode ser trabalhado programaticamente. <br><br>  Devo dizer imediatamente que at√© agora n√£o encontramos uma maneira de coletar o grau de cobertura automaticamente.  Teoricamente, isso pode ser feito usando o navegador sem cabe√ßa do aluno, mas o aluno n√£o funciona sob o controle do sel√™nio, o que significa que n√£o poderemos reutilizar o c√≥digo de nossos testes.  Ent√£o, por enquanto, vamos pular esse t√≥pico extremamente interessante e trabalhar com canetas. <br><br>  Depois de executar os testes no modo manual, obtemos um relat√≥rio de cobertura, que √© um arquivo json.  No relat√≥rio para cada css, js, ts, etc.  o arquivo indica seu texto (em uma linha) e os intervalos do c√≥digo usado neste texto (na forma de √≠ndices de caracteres dessa linha).  Abaixo est√° uma parte do relat√≥rio: <br><br><div class="spoiler">  <b class="spoiler_title">cobertura.json</b> <div class="spoiler_text"><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:6006/theme-default.css"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ranges"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">8127</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"... --theme_primary-accent: #5b9bd5;\r\n --theme_primary-light: #ffffff;\r\n --theme_primary: #f4f4f4;\r\n ..."</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:6006/main.css"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ranges"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">610</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">728</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">754</span></span> } ] <span class="hljs-string"><span class="hljs-string">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"... \r\n line-height:1;\r\n}\r\n\r\nol, ul{\r\n list-style:none;\r\n}\r\n\r\nblockquote, q..."</span></span> ]</code> </pre><br></div></div><br>  √Ä primeira vista, n√£o h√° nada dif√≠cil em encontrar seletores de css n√£o utilizados.  Mas ent√£o o que fazer com essa informa√ß√£o?  De fato, na an√°lise final, precisamos encontrar seletores n√£o espec√≠ficos, mas componentes que esquecemos de cobrir com os testes.  Os estilos de um componente podem ser definidos por mais de uma d√∫zia de seletores.  Como resultado, com base nos resultados da an√°lise do relat√≥rio, obtemos centenas de seletores n√£o utilizados e, se voc√™ lidar com cada um deles, poder√° gastar muito tempo. <br><br>  Aqui, express√µes regulares nos ajudam.  Obviamente, eles s√≥ funcionar√£o se as conven√ß√µes de nomenclatura para classes css forem cumpridas (em nosso c√≥digo, as classes css s√£o nomeadas de acordo com a metodologia BEM - block_name_name_name_modifier).  Usando express√µes regulares, calculamos os valores exclusivos dos nomes dos blocos, que n√£o s√£o mais dif√≠ceis de associar aos componentes.  Obviamente, tamb√©m estamos interessados ‚Äã‚Äãem elementos e modificadores, mas n√£o em primeiro lugar, primeiro precisamos lidar com um ‚Äúpeixe‚Äù maior.  Abaixo est√° um script para processar um relat√≥rio de cobertura <br><br><div class="spoiler">  <b class="spoiler_title">cobertura.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> modules = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./coverage.json'</span></span>).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> e.url.endsWith(<span class="hljs-string"><span class="hljs-string">'.css'</span></span>)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module, rangeStart, rangeEnd, isUsed</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rules = <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.text.slice(rangeStart, rangeEnd); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> regex = <span class="hljs-regexp"><span class="hljs-regexp">/^\.([^\d{:,)_ ]+-?)+/gm</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classNames = rules.match(regex); classNames &amp;&amp; classNames.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> selectors[name] = selectors[name] || isUsed); } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> previousEnd, selectors = {}; modules.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module</span></span></span><span class="hljs-function"> =&gt;</span></span> { previousEnd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> range <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.ranges) { processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, previousEnd, range.start, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, range.start, range.end, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); previousEnd = range.end; } processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, previousEnd, <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.length, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'className;isUsed'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(selectors).sort().forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${s}</span></span></span><span class="hljs-string">;</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${selectors[s]}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre><br></div></div><br>  Executamos o script primeiro colocando o arquivo de cobertura.json exportado do Chrome DevTools e gravando o escape em um arquivo .csv: <br><br>  <b>n√≥ cobertura.js&gt; cobertura.csv</b> <br><br>  Voc√™ pode abrir esse arquivo usando o Excel e analisar os dados, incluindo a determina√ß√£o da porcentagem de cobertura de c√≥digo pelos testes. <br><br><img src="https://habrastorage.org/webt/gh/ss/b8/ghssb8zrlh41pakcvwhyl6fcjge.png"><br><br><h2>  Em vez de um curr√≠culo </h2><br>  O uso do livro de hist√≥rias como base para testes visuais se justificou completamente - temos um grau suficiente de cobertura do c√≥digo css com testes com um n√∫mero relativamente pequeno de hist√≥rias e custos m√≠nimos para a cria√ß√£o de novos. <br><br>  A transi√ß√£o para um novo mecanismo nos permitiu eliminar a duplica√ß√£o de informa√ß√µes visuais nas capturas de tela, o que simplificou bastante o suporte aos testes existentes. <br><br>  O grau de cobertura do c√≥digo css √© mensur√°vel e, de tempos em tempos, √© monitorado.  Obviamente, existe uma grande quest√£o - como n√£o esquecer a necessidade desse controle e como n√£o perder algo no processo de coleta de informa√ß√µes sobre cobertura.  Idealmente, eu gostaria de medir o grau de cobertura automaticamente em cada execu√ß√£o de teste, para que, quando o limite especificado for atingido, os testes caiam com um erro.  Vamos trabalhar nisso, se houver novidades, eu definitivamente direi a voc√™. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt479040/">https://habr.com/ru/post/pt479040/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt479022/index.html">TVs inteligentes Samsung, LG, Vizio e TCL a cada segundo pegam "impress√µes digitais" da tela e enviam para o servidor</a></li>
<li><a href="../pt479026/index.html">Verdadeiro somat√≥rio de canais da Internet - OpenMPTCPRouter</a></li>
<li><a href="../pt479034/index.html">Como conectar-se a uma VPN corporativa no Linux usando openconnect e vpn-slice</a></li>
<li><a href="../pt479036/index.html">A Intel n√£o pode lidar com a demanda por processadores. HP e Dell sofrem como resultado</a></li>
<li><a href="../pt479038/index.html">Transforma√ß√£o digital Leroy Merlin: projetando uma interface para trabalhar com chamadas de clientes</a></li>
<li><a href="../pt479042/index.html">O m√©todo Y √© uma maneira muito f√°cil de construir um cubo de Rubik</a></li>
<li><a href="../pt479044/index.html">Minha implementa√ß√£o de buffer de anel no flash NOR</a></li>
<li><a href="../pt479048/index.html">Node.js Streams para manequins ou como trabalhar com streams</a></li>
<li><a href="../pt479050/index.html">Pesquisa de patentes em TI. O curso do jovem lutador. Parte II Fontes de informa√ß√£o para pesquisa de patentes</a></li>
<li><a href="../pt479052/index.html">[Supercomputa√ß√£o 2019]. Armazenamento em v√°rias nuvens como um aplicativo para novas unidades Kingston DC1000M</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>