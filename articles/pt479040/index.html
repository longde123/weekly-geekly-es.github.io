<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍱 🙍🏾 👍🏽 Testes de regressão visual. Reiniciar 🦍 🚣🏽 🤪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No meu artigo anterior, falei sobre a experiência de usar o mecanismo Gemini para desenvolver testes visuais, ou melhor, testes de regressão visual. E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testes de regressão visual. Reiniciar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/479040/">  No meu <a href="https://habr.com/ru/post/454464/">artigo</a> anterior, falei sobre a experiência de usar o mecanismo <a href="https://github.com/gemini-testing/gemini">Gemini</a> para desenvolver testes visuais, ou melhor, testes de regressão visual.  Esses testes verificam se algo “mudou” na interface do usuário após as próximas alterações, comparando as capturas de tela atuais com as de referência corrigidas anteriormente.  Desde então, muita coisa mudou em nossas abordagens para escrever testes visuais, incluindo o mecanismo usado.  Agora usamos <a href="https://github.com/gemini-testing/hermione">Hermione</a> , mas neste artigo vou falar não apenas e não tanto sobre Hermione, mas sobre os problemas que se acumularam desde então e como resolvê-los, o que, entre outras coisas, levou à transição para um novo mecanismo. <br><a name="habracut"></a><br>  Em primeiro lugar, embora os testes funcionassem e com bastante sucesso, não tínhamos um entendimento claro do que era coberto pelos testes e do que não era.  Havia, é claro, alguma idéia do grau de cobertura, mas não a medimos quantitativamente.  Em segundo lugar, a composição dos testes aumentou com o tempo e testes diferentes frequentemente testavam a mesma coisa, porque  em capturas de tela diferentes, alguma parte coincidia com a mesma parte, mas em uma captura de tela diferente.  Como resultado, mesmo pequenas alterações no CSS podem sobrecarregar muitos testes ao mesmo tempo e exigir a atualização de um grande número de padrões.  Em terceiro lugar, um tema sombrio apareceu em nosso produto e, para cobri-lo de alguma forma com testes, alguns testes foram selecionados seletivamente para usar um tema sombrio, o que também não adicionava clareza ao problema ao determinar o grau de cobertura. <br><br><h2>  Otimização de desempenho </h2><br>  Estranhamente, começamos com desempenho otimizado.  Eu vou explicar o porquê.  Nossos testes visuais são baseados no <a href="https://github.com/storybooks/storybook">Storybook</a> .  Cada história do livro de histórias não é um componente único, mas um "bloco" inteiro (por exemplo, uma grade com uma lista de entidades, um cartão de entidade, diálogo ou mesmo o aplicativo como um todo).  Para exibir este bloco, você precisa “bombear” a história com dados, não apenas os dados exibidos para o usuário, mas também o estado dos componentes usados ​​dentro do bloco.  Essas informações são armazenadas junto com o código-fonte na forma de arquivos json que contêm uma representação serializada do estado do aplicativo (repositório redux).  Sim, esses dados são, para dizer o mínimo, redundantes, mas simplificam bastante a criação de testes.  Para criar um novo teste, basta abrir o cartão, a lista ou o diálogo desejado no aplicativo, tirar uma foto do estado atual do aplicativo e serializá-lo em um arquivo.  Em seguida, adicionamos uma nova história e testes que fazem capturas de tela dessa história (todas em poucas linhas de código). <br><br>  Essa abordagem inevitavelmente aumenta o tamanho do pacote.  O grau de duplicação de dados nele apenas "passa".  Ao executar testes, o mecanismo gemini executa cada suíte de testes em uma sessão separada do navegador.  Cada sessão carrega o pacote novamente e o tamanho do pacote nesse esquema está longe do último valor. <br><br>  Para reduzir o tempo de execução do teste, reduzimos o número de suítes de teste aumentando o número de testes neles.  Assim, um conjunto de testes pode afetar várias histórias de uma só vez.  Nesse esquema, praticamente perdemos a capacidade de “rastrear” apenas uma determinada área da tela devido ao fato de o Gemini permitir que você defina a área de captura de tela apenas para o conjunto de testes como um todo (embora a API permita que você faça isso antes de cada captura de tela, mas, na prática, não funciona). <br><br>  A incapacidade de limitar a área da captura de tela nos testes levou à duplicação de informações visuais nas imagens de referência.  Embora não houvesse muitos testes, esse problema não parecia significativo.  Sim, e a interface do usuário não mudou com muita frequência.  Mas isso não poderia durar para sempre - uma reformulação apareceu no horizonte. <br><br>  Olhando para o futuro, direi que em Hermione uma área de captura de tela pode ser definida para cada cena e, à primeira vista, mudar para um novo mecanismo resolveria todos os problemas.  Mas ainda teríamos que “esmagar” grandes suítes de teste.  O fato é que os testes visuais não são inerentemente estáveis ​​(isso pode ser devido a várias razões, por exemplo, com defasagens na rede, usando animações ou com "clima em Marte") e é muito difícil fazer sem tentativas automáticas.  Gêmeos e Hermione realizam novas tentativas para a suíte de testes como um todo, e quanto mais espessa for a suíte de testes, menor a probabilidade de concluir com êxito durante as tentativas, como  na próxima execução, os testes que foram concluídos anteriormente com êxito podem cair.  Para conjuntos de testes espessos, tivemos que implementar um esquema de repetição alternativo incorporado ao mecanismo Gemini e realmente não queremos fazer isso novamente ao mudar para um novo mecanismo. <br><br>  Portanto, para acelerar o carregamento do conjunto de testes, dividimos o pacote monolítico em partes, alocando cada instantâneo do estado do aplicativo em uma "peça" separada, carregada "sob demanda" para cada matéria separadamente.  O código de criação da história agora se parece com isso: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// visual-regression.stories.js import React from 'react'; import StoryProvider from './story-provider'; const stories = storiesOf('visual-regression', module); [ { name: 'Contract', loadData: import('./snapshots/contract.testdata') }, { name: 'ExecutionTask', loadData: import('./snapshots/execution-task.testdata') }, { name: 'ExecutionAssignment', loadData: import('./snapshots/execution-assignment.testdata') }, { name: 'DocumentTemplate', loadData: import('./snapshots/document-template.testdata') }, { name: 'Explorer', loadData: import('./snapshots/explorer.testdata') }, { name: 'Inbox', loadData: import('./snapshots/inbox.testdata') }, ] .map(story =&gt; { stories .add(story.name, () =&gt; &lt;StoryProvider loadSnapshot={story.loadData} /&gt;) .add(`${story.name}Dark`, () =&gt; &lt;StoryProvider loadSnapshot={story.loadData} theme='night' /&gt;); });</span></span></code> </pre> <br>  Para criar uma história, o componente StoryProvider é usado (seu código será fornecido abaixo).  Os instantâneos são carregados usando a função de <a href="https://webpack.js.org/guides/code-splitting/">importação dinâmica</a> .  Histórias diferentes diferem entre si apenas em imagens de estados.  Para um tema sombrio, sua própria história é gerada, usando o mesmo instantâneo da história para um tema claro.  No contexto de um livro de histórias, fica assim: <br><br><div class="spoiler">  <b class="spoiler_title">História do tema padrão</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d6/vc/uk/d6vcukhmensy0jogshjj4hifoui.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Dark theme story</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/jy/z0/uu/jyz0uuyel6t1pofayyjxftuunwg.png"><br></div></div><br>  O componente StoryProvider aceita um retorno de chamada para carregar uma captura instantânea na qual a função import () é chamada.  A função import () funciona de forma assíncrona, portanto você não pode capturar uma captura de tela imediatamente após carregar a história - corremos o risco de remover o vazio.  Para capturar o momento do final do download, o provedor renderiza o elemento DOM do marcador sinalizando o mecanismo de teste durante todo o tempo do download, que deve ser adiado com a captura de tela: <br><br><div class="spoiler">  <b class="spoiler_title">story-provider.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// story-provider.js const propsStub = { // -,      . . . }; type Props = { loadSnapshot: () =&gt; Object, theme: ?string }; const StoryProvider = (props: Props) =&gt; { const [ snapshotState, setsnapshotState ] = React.useState(null); React.useEffect(() =&gt; { //    (async() =&gt; setsnapshotState((await props.loadSnapshot).default))(); }); if (!snapshotState) //     ,     return &lt;div className={'loading-stub'}&gt;Loading...&lt;/div&gt;; //    snapshotState.metadata = require('./snapshots/metadata'); //  redux-   const store = createMockStore(snapshotState); //   applyTheme(props.theme); return ( &lt;Provider store={store}&gt; &lt;MemoryRouter&gt; &lt;App {...propsStub} /&gt; &lt;/MemoryRouter&gt; &lt;/Provider&gt; ); }; export default StoryProvider;</span></span></code> </pre><br></div></div><br>  Além disso, para reduzir o tamanho do pacote, desative a adição de mapas de origem ao pacote.  Mas, para não perder a capacidade de depurar a história (você nunca sabe o que), fazemos isso sob a condição: <br><br><div class="spoiler">  <b class="spoiler_title">.storybook / webpack.config.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// .storybook/webpack.config.js ... module.exports = { ... devtool: process.env.NODE_ENV === 'vr-test' ? '(none)' : 'eval-source-map' };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">package.json</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// package.json { ... "scripts": { ... "storybook": "start-storybook", "build-storybook": "cross-env NODE_ENV=vr-test build-storybook -o ./storybook-static", ... },</span></span></code> </pre><br></div></div><br>  O <b>script build-storybook do npm run</b> compila um livro de histórias estático sem o mapa de origem na pasta estática do livro de histórias.  É usado ao executar testes.  E o <b>script de livro de histórias npm run é</b> usado para desenvolver e depurar histórias de teste. <br><br><h2>  Eliminação da duplicação de informações visuais </h2><br>  Como eu disse acima, o Gemini permite definir seletores de área de captura de tela para o conjunto de testes como um todo, o que significa que, para resolver completamente o problema de duplicar informações visuais nas capturas de tela, teríamos que criar nosso próprio conjunto de testes para cada captura de tela.  Mesmo levando em consideração a otimização do carregamento da história, ela não parecia muito otimista em termos de velocidade e pensamos em mudar o mecanismo de teste. <br><br>  Na verdade, por que Hermione?  Atualmente, o repositório Gemini está marcado como obsoleto e, mais cedo ou mais tarde, tivemos que "mudar" para algum lugar.  A estrutura do arquivo de configuração Hermione é idêntica à estrutura do arquivo de configuração Gemini e pudemos reutilizar essa configuração.  Os plugins Gêmeos e Hermione também são comuns.  Além disso, pudemos reutilizar a infraestrutura de teste - máquinas virtuais e implantamos a grade de selênio. <br><br>  Ao contrário de Gêmeos, Hermione não está posicionada como uma ferramenta apenas para testes de regressão de layout.  Seus recursos de manipulação de navegador são muito mais amplos e limitados apenas pelos recursos do <a href="http://v4.webdriver.io/">Webdriver IO</a> .  Em combinação com o <a href="https://github.com/mochajs/mocha">mocha,</a> esse mecanismo é conveniente para usar mais em testes funcionais (simulando ações do usuário) do que em testes de layout.  Para teste de regressão do layout, Hermione fornece apenas o método assertView (), que compara uma captura de tela de uma página do navegador com uma referência.  A captura de tela pode ser limitada à área especificada usando seletores de css. <br><br>  Para o nosso caso, o teste para cada história individual ficaria assim: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    describe('Visual regression', function() { it('Contract card should equal to etalon', function() { return this.browser //  story   .url('http://localhost:8080/iframe.html?selectedKind=visual-regression&amp;selectedStory=ContractDark') // ,      story .waitForVisible('.loading-stub', true) //          .assertView('layout', '.form'); }) });</span></span></code> </pre><br>  O método waitForVisible (), apesar do nome, permite esperar não apenas a aparência, mas também a ocultação do elemento, se você definir o segundo parâmetro como true.  Aqui, usamos para aguardar a ocultação de um elemento marcador, indicando que o instantâneo de dados ainda não foi carregado e a história ainda não está pronta para uma captura de tela. <br><br>  Se você tentar encontrar o método waitForVisible () na documentação da Hermione, não encontrará nada.  O fato é que o <a href="http://v4.webdriver.io/api/utility/waitForVisible.html">método</a> waitForVisible () <a href="http://v4.webdriver.io/api/utility/waitForVisible.html">é o método da API Webdriver IO</a> .  O método url (), respectivamente, também.  No método url (), passamos o endereço do quadro de uma história específica, não o livro de histórias inteiro.  Primeiro, isso é necessário para que a lista de histórias não seja exibida na janela do navegador - não precisamos testá-la.  Em segundo lugar, se necessário, podemos ter acesso aos elementos DOM dentro do quadro (os métodos webdriverIO permitem executar o código JavaScript no contexto do navegador). <br><br>  Para simplificar a gravação dos testes, criamos nosso invólucro sobre os testes mocha.  O fato é que não há um sentido particular na elaboração detalhada de casos de teste para teste de regressão.  Todos os casos de teste são iguais - 'deve ser igual a etalon'.  Bem, também não quero duplicar o código para aguardar o carregamento de dados em cada teste.  Portanto, o mesmo trabalho para todos os testes "monkey" é delegado à função wrapper, e os próprios testes são escritos de forma declarativa (bem, quase).  Aqui está o texto desta função: <br><br><div class="spoiler">  <b class="spoiler_title">create-test-suite.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> themes = [ <span class="hljs-string"><span class="hljs-string">'default'</span></span>, <span class="hljs-string"><span class="hljs-string">'dark'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rootClassName = <span class="hljs-string"><span class="hljs-string">'.explorer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loadingStubClassName = <span class="hljs-string"><span class="hljs-string">'.loading-stub'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timeout = <span class="hljs-number"><span class="hljs-number">2000</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTestSuite</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">testSuite</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, storyName, browsers, testCases, selector } = testSuite; <span class="hljs-comment"><span class="hljs-comment">//  ,       browsers &amp;&amp; hermione.only.in(browsers); //      themes.forEach(theme =&gt; { describe(`${name}_${theme}`, () =&gt; it('should equal to etalon', function() { let browser = this.browser //   story .url(`${storybookUrl}/iframe.html?selectedKind=visual-regression&amp;selectedStory=${storyName}-${theme}`) //     .waitForVisible(loadingStubClassName, timeout, true) .waitForVisible(rootClassName); //    (  ) if (testCases &amp;&amp; testCases.length &gt; 0) { testCases.forEach(testCase =&gt; { if (testCase.before) browser = testCase.before(browser); browser = browser.assertView(`${name}__${testCase.name}_${theme}`, testCase.selector || selector || rootClassName, testCase.options); }); return browser; } //    ,    return browser.assertView(`${name}_${theme}`, selector || rootClassName); })); }); }</span></span></code> </pre><br></div></div><br>  Um objeto que descreve o conjunto de testes é passado para a entrada da função.  Cada suíte de teste é criada de acordo com o seguinte cenário: fazemos uma captura de tela do layout principal (por exemplo, uma área de um cartão de entidade ou uma área de uma lista de entidades), depois pressionamos programaticamente botões que podem levar à aparência de outros elementos (por exemplo, painéis pop-up ou menus de contexto) e “capturamos uma captura de tela »Cada um desses elementos separadamente.  Assim, simulamos ações do usuário no navegador, mas não com o objetivo de testar um cenário de negócios, mas simplesmente para "capturar" o número máximo possível de componentes visuais.  Além disso, a duplicação de informações visuais nas capturas de tela é mínima, porque  as capturas de tela são feitas "no sentido horário" usando seletores.  Exemplo de suíte de teste: <br><br><div class="spoiler">  <b class="spoiler_title">explorer-suite.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// explorer-suite.js //         module.exports = { //  story,    storyName: 'explorer', //    name: 'explorer', //  ,       browsers: [ 'chrome-1920x1080', 'ie-1920x1080' ], //   testCases: [ { //    name: 'layout' }, { //    name: 'notification-area', selector: '.notification-area__popup', before: b =&gt; b .click('.notification-area__popup-button') .waitForVisible('.notification-area__popup') .execute(function() { //       document.querySelectorAll('.expandable-item__content')[2].click(); }) }, //... ] };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">tests.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// tests.js [ require('./suites/explorer-suite'), //... ] .forEach(suite =&gt; createTestSuite(suite));</span></span></code> </pre><br></div></div><br><h2>  Determinação da cobertura </h2><br>  Então, como descobrimos a velocidade e a redundância, resta descobrir a eficácia de nossos testes, ou seja, determinar o grau de cobertura do código com os testes (aqui, por código, quero dizer folhas de estilo CSS). <br><br>  Para histórias de teste, selecionamos empiricamente os cartões, listas e outros elementos mais complicados a serem preenchidos para cobrir o maior número possível de estilos com uma captura de tela.  Por exemplo, para testar um cartão de entidade, foram selecionados cartões com um grande número de tipos diferentes de controles (texto, número, transferências, datas, grades etc.).  Os cartões para diferentes tipos de entidades têm especificidades próprias; por exemplo, um painel com uma lista de versões de documentos pode ser exibido em um cartão de documentos e a correspondência nessa tarefa é exibida no cartão de tarefas.  Dessa forma, para cada tipo de entidade, sua própria história e um conjunto de testes específicos para esse tipo etc. foram criados.  No final, achamos que tudo parecia coberto de testes, mas queríamos um pouco mais de confiança do que "gostar". <br><br>  Para avaliar a cobertura no Chrome DevTools, existe uma ferramenta com o nome Cobertura muito adequada para este caso: <br><br><img src="https://habrastorage.org/webt/ma/yt/dh/maytdhehcjiumoxdsdj-woa40lo.png"><br><br>  A cobertura permite determinar quais estilos ou qual código js foi usado ao trabalhar com a página do navegador.  O relatório sobre o uso de listras verdes indica o código usado, vermelho - não usado.  E tudo ficaria bem se tivéssemos uma aplicação do nível "olá, mundo", mas o que fazer quando tivermos milhares de linhas de código?  Os desenvolvedores de cobertura entenderam isso muito bem e forneceram a capacidade de exportar o relatório para um arquivo que já pode ser trabalhado programaticamente. <br><br>  Devo dizer imediatamente que até agora não encontramos uma maneira de coletar o grau de cobertura automaticamente.  Teoricamente, isso pode ser feito usando o navegador sem cabeça do aluno, mas o aluno não funciona sob o controle do selênio, o que significa que não poderemos reutilizar o código de nossos testes.  Então, por enquanto, vamos pular esse tópico extremamente interessante e trabalhar com canetas. <br><br>  Depois de executar os testes no modo manual, obtemos um relatório de cobertura, que é um arquivo json.  No relatório para cada css, js, ts, etc.  o arquivo indica seu texto (em uma linha) e os intervalos do código usado neste texto (na forma de índices de caracteres dessa linha).  Abaixo está uma parte do relatório: <br><br><div class="spoiler">  <b class="spoiler_title">cobertura.json</b> <div class="spoiler_text"><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:6006/theme-default.css"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ranges"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">8127</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"... --theme_primary-accent: #5b9bd5;\r\n --theme_primary-light: #ffffff;\r\n --theme_primary: #f4f4f4;\r\n ..."</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:6006/main.css"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ranges"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">610</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">728</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">754</span></span> } ] <span class="hljs-string"><span class="hljs-string">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"... \r\n line-height:1;\r\n}\r\n\r\nol, ul{\r\n list-style:none;\r\n}\r\n\r\nblockquote, q..."</span></span> ]</code> </pre><br></div></div><br>  À primeira vista, não há nada difícil em encontrar seletores de css não utilizados.  Mas então o que fazer com essa informação?  De fato, na análise final, precisamos encontrar seletores não específicos, mas componentes que esquecemos de cobrir com os testes.  Os estilos de um componente podem ser definidos por mais de uma dúzia de seletores.  Como resultado, com base nos resultados da análise do relatório, obtemos centenas de seletores não utilizados e, se você lidar com cada um deles, poderá gastar muito tempo. <br><br>  Aqui, expressões regulares nos ajudam.  Obviamente, eles só funcionarão se as convenções de nomenclatura para classes css forem cumpridas (em nosso código, as classes css são nomeadas de acordo com a metodologia BEM - block_name_name_name_modifier).  Usando expressões regulares, calculamos os valores exclusivos dos nomes dos blocos, que não são mais difíceis de associar aos componentes.  Obviamente, também estamos interessados ​​em elementos e modificadores, mas não em primeiro lugar, primeiro precisamos lidar com um “peixe” maior.  Abaixo está um script para processar um relatório de cobertura <br><br><div class="spoiler">  <b class="spoiler_title">cobertura.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> modules = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./coverage.json'</span></span>).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> e.url.endsWith(<span class="hljs-string"><span class="hljs-string">'.css'</span></span>)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module, rangeStart, rangeEnd, isUsed</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rules = <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.text.slice(rangeStart, rangeEnd); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> regex = <span class="hljs-regexp"><span class="hljs-regexp">/^\.([^\d{:,)_ ]+-?)+/gm</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classNames = rules.match(regex); classNames &amp;&amp; classNames.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> selectors[name] = selectors[name] || isUsed); } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> previousEnd, selectors = {}; modules.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module</span></span></span><span class="hljs-function"> =&gt;</span></span> { previousEnd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> range <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.ranges) { processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, previousEnd, range.start, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, range.start, range.end, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); previousEnd = range.end; } processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, previousEnd, <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.length, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'className;isUsed'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(selectors).sort().forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${s}</span></span></span><span class="hljs-string">;</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${selectors[s]}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre><br></div></div><br>  Executamos o script primeiro colocando o arquivo de cobertura.json exportado do Chrome DevTools e gravando o escape em um arquivo .csv: <br><br>  <b>nó cobertura.js&gt; cobertura.csv</b> <br><br>  Você pode abrir esse arquivo usando o Excel e analisar os dados, incluindo a determinação da porcentagem de cobertura de código pelos testes. <br><br><img src="https://habrastorage.org/webt/gh/ss/b8/ghssb8zrlh41pakcvwhyl6fcjge.png"><br><br><h2>  Em vez de um currículo </h2><br>  O uso do livro de histórias como base para testes visuais se justificou completamente - temos um grau suficiente de cobertura do código css com testes com um número relativamente pequeno de histórias e custos mínimos para a criação de novos. <br><br>  A transição para um novo mecanismo nos permitiu eliminar a duplicação de informações visuais nas capturas de tela, o que simplificou bastante o suporte aos testes existentes. <br><br>  O grau de cobertura do código css é mensurável e, de tempos em tempos, é monitorado.  Obviamente, existe uma grande questão - como não esquecer a necessidade desse controle e como não perder algo no processo de coleta de informações sobre cobertura.  Idealmente, eu gostaria de medir o grau de cobertura automaticamente em cada execução de teste, para que, quando o limite especificado for atingido, os testes caiam com um erro.  Vamos trabalhar nisso, se houver novidades, eu definitivamente direi a você. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt479040/">https://habr.com/ru/post/pt479040/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt479022/index.html">TVs inteligentes Samsung, LG, Vizio e TCL a cada segundo pegam "impressões digitais" da tela e enviam para o servidor</a></li>
<li><a href="../pt479026/index.html">Verdadeiro somatório de canais da Internet - OpenMPTCPRouter</a></li>
<li><a href="../pt479034/index.html">Como conectar-se a uma VPN corporativa no Linux usando openconnect e vpn-slice</a></li>
<li><a href="../pt479036/index.html">A Intel não pode lidar com a demanda por processadores. HP e Dell sofrem como resultado</a></li>
<li><a href="../pt479038/index.html">Transformação digital Leroy Merlin: projetando uma interface para trabalhar com chamadas de clientes</a></li>
<li><a href="../pt479042/index.html">O método Y é uma maneira muito fácil de construir um cubo de Rubik</a></li>
<li><a href="../pt479044/index.html">Minha implementação de buffer de anel no flash NOR</a></li>
<li><a href="../pt479048/index.html">Node.js Streams para manequins ou como trabalhar com streams</a></li>
<li><a href="../pt479050/index.html">Pesquisa de patentes em TI. O curso do jovem lutador. Parte II Fontes de informação para pesquisa de patentes</a></li>
<li><a href="../pt479052/index.html">[Supercomputação 2019]. Armazenamento em várias nuvens como um aplicativo para novas unidades Kingston DC1000M</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>