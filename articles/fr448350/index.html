<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🤝‍👨🏼 👍🏾 👇🏾 Implémentation de dictionnaire en Python 👰🏿 😀 🎽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour à tous, le 30 avril, le cours Algorithms for Developers débutera à OTUS, et c'est exactement ce à quoi la publication du matériel d'aujourd'hu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implémentation de dictionnaire en Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/448350/">  Bonjour à tous, le 30 avril, le cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Algorithms for Developers</a> débutera à OTUS, et c'est exactement ce à quoi la publication du matériel d'aujourd'hui est dédiée.  Commençons. <br><br><img src="https://habrastorage.org/webt/hq/5t/r4/hq5tr4-0h1wb2kxrkaggtq_fatm.png"><br><br>  Dans cet article, vous apprendrez comment les dictionnaires sont implémentés en Python. <br>  Les dictionnaires sont indexés à l'aide de clés et peuvent être considérés comme des tableaux associés.  Ajoutons 3 paires clé / valeur au dictionnaire: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d = {<span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>} &gt;&gt;&gt; d[<span class="hljs-string"><span class="hljs-string">'c'</span></span>] = <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; d {<span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>}</code> </pre> <a name="habracut"></a><br>  Les valeurs sont accessibles comme suit: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d[<span class="hljs-string"><span class="hljs-string">'a'</span></span>] <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; d[<span class="hljs-string"><span class="hljs-string">'b'</span></span>] <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;&gt;&gt; d[<span class="hljs-string"><span class="hljs-string">'c'</span></span>] <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; d[<span class="hljs-string"><span class="hljs-string">'d'</span></span>] Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; KeyError: <span class="hljs-string"><span class="hljs-string">'d'</span></span></code> </pre> <br>  La clé <code>“d”</code> n'existe pas, donc une erreur KeyError se produira. <br><br>  <b>Tables de hachage</b> <br><br>  Les dictionnaires en Python sont implémentés à l'aide de tables de hachage.  Ce sont des tableaux dont les indices sont calculés à l'aide de fonctions de hachage.  Le but de la fonction de hachage est de répartir uniformément les clés dans le tableau.  Une bonne fonction de hachage minimise le nombre de collisions, c'est-à-dire  la probabilité que différentes clés aient un hachage.  Il n'y a pas de telles fonctions de hachage en Python.  Ses fonctions de hachage les plus importantes (pour les chaînes et les valeurs entières) produisent des valeurs similaires dans les cas généraux: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>map(hash, (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] &gt;&gt;&gt; map(hash, (<span class="hljs-string"><span class="hljs-string">"namea"</span></span>, <span class="hljs-string"><span class="hljs-string">"nameb"</span></span>, <span class="hljs-string"><span class="hljs-string">"namec"</span></span>, <span class="hljs-string"><span class="hljs-string">"named"</span></span>)) [<span class="hljs-number"><span class="hljs-number">-1658398457</span></span>, <span class="hljs-number"><span class="hljs-number">-1658398460</span></span>, <span class="hljs-number"><span class="hljs-number">-1658398459</span></span>, <span class="hljs-number"><span class="hljs-number">-1658398462</span></span>]</code> </pre> <br>  Nous supposerons que jusqu'à la fin de cet article, nous utiliserons des chaînes comme clés.  La fonction de hachage en Python pour les chaînes est définie comme suit: <br><br><pre> <code class="python hljs">arguments: string object returns: hash function string_hash: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hash cached: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> it set len to string<span class="hljs-string"><span class="hljs-string">'s length initialize var p pointing to 1st char of string object set x to value pointed by p left shifted by 7 bits while len &gt;= 0: set var x to (1000003 * x) xor value pointed by p increment pointer p set x to x xor length of string object cache x as the hash so we don'</span></span>t need to calculate it again <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> the hash</code> </pre> <br>  Si vous exécutez le <code>hash('a')</code> en Python, il <code>12416037344</code> <code>string_hash()</code> et renverra <code>12416037344</code> .  Ici, nous utilisons la machine 64 bits par défaut. <br><br>  Si un tableau de taille <code></code> utilisé pour stocker les paires valeur / clé, un masque sera utilisé pour calculer l'indice de la cellule de la cellule dans le tableau, qui est calculé comme <code>-1</code> .  Cette approche permet de calculer rapidement les indices des cellules.  La probabilité de trouver une cellule vide est assez élevée en raison du mécanisme de redimensionnement, qui est décrit ci-dessous.  Cela signifie qu'un calcul simple a du sens dans la plupart des cas.  La taille du tableau est 8, l'index pour <code>'a'</code> sera: <code>hash('a') &amp; 7 = 0</code> .  L'indice pour <code>'b'</code> est 2, l'indice pour <code>'c'</code> est 3, l'indice pour <code>'z'</code> est 3, tout comme pour <code>'b'</code> , et c'est là que nous obtenons une collision. <br><br><img src="https://habrastorage.org/webt/m0/uu/ie/m0uuieays-qf4xbaurxripjwdi8.png"><br><br>  Comme nous pouvons le voir, une fonction de hachage en Python fait son travail de manière de qualité lorsque les clés sont séquentielles, ce qui est bien, car vous devez souvent travailler avec de telles données.  Cependant, dès que nous ajoutons la touche <code>'z'</code> , une collision se produit car elle n'est pas cohérente avec les précédentes. <br><br>  Nous pourrions utiliser une liste chaînée pour stocker des paires, ayant le même hachage, mais cela augmenterait le temps de recherche et ne serait pas égal à O (1) en moyenne.  La section suivante décrit la méthode de résolution de collision utilisée pour les dictionnaires en Python. <br><br>  <b>Adressage ouvert</b> <br><br>  L'adressage ouvert est une technique de résolution de collision qui utilise le sondage.  Dans le cas de <code>'z'</code> , l'index de la cellule 3 est déjà utilisé dans le tableau, nous devons donc rechercher un autre index qui n'a pas encore été utilisé.  L'opération d'ajout d'une paire clé / valeur prend en moyenne O (1), ainsi que l'opération de recherche. <br><br>  Pour rechercher des cellules libres, une séquence de sondage quadratique est utilisée.  Il est implémenté comme suit: <br><br><pre> <code class="python hljs">j = (<span class="hljs-number"><span class="hljs-number">5</span></span>*j) + <span class="hljs-number"><span class="hljs-number">1</span></span> + perturb; perturb &gt;&gt;= PERTURB_SHIFT; use j % <span class="hljs-number"><span class="hljs-number">2</span></span>**i <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> the next table index;</code> </pre> <br>  La récursivité à (5 * j) +1 augmente rapidement les grandes différences de bits qui n'ont pas affecté l'index d'origine.  La variable <code>"perturb"</code> dans ce cas reprend les autres bits du code de hachage. <br><br>  Regardons par curiosité ce qui se passe si nous avons un exemple de séquence avec un tableau de taille 32 et j = 3. <br><br>  3 -&gt; 11 -&gt; 19 -&gt; 29 -&gt; 5 -&gt; 6 -&gt; 16 -&gt; 31 -&gt; 28 -&gt; 13 -&gt; 2 ... <br><br>  Vous pouvez en savoir plus sur cette séquence de <a href="">sondage</a> en vous référant au code source <a href="">dictobject.c</a> .  Une explication détaillée du mécanisme de sondage se trouve en haut du fichier. <br><br><img src="https://habrastorage.org/webt/jq/vo/l3/jqvol3q4ekq8yullsftv4ylm-p4.png"><br><br>  Regardons le code source Python avec cet exemple. <br><br>  <b>Structures de dictionnaire C</b> <br><br>  La structure C suivante est utilisée pour stocker l'entrée dans le dictionnaire: paire clé / valeur.  Le hachage, la clé et la valeur sont stockés.  <code>PyObject</code> est la classe de base pour les objets en Python. <br><br><pre> <code class="python hljs">typedef struct { Py_ssize_t me_hash; PyObject *me_key; PyObject *me_value; } PyDictEntry;</code> </pre> <br>  La structure suivante est un dictionnaire.  <code>ma_fill</code> est le nombre total de cellules utilisées et inactives.  Une cellule est considérée comme inactive lorsqu'une paire de clés est supprimée.  <code>ma_used</code> est le nombre de cellules utilisées (actives).  <code>ma_mask</code> est égal à la taille du tableau -1 et est utilisé pour calculer l'indice de cellule.  <code>ma_table</code> est un tableau et <code>ma_smalltable</code> est le tableau d'origine de taille 8. <br><br><pre> <code class="python hljs">typedef struct _dictobject PyDictObject; struct _dictobject { PyObject_HEAD Py_ssize_t ma_fill; Py_ssize_t ma_used; Py_ssize_t ma_mask; PyDictEntry *ma_table; PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash); PyDictEntry ma_smalltable[PyDict_MINSIZE]; };</code> </pre> <br>  <b>Initialisation du vocabulaire</b> <br><br>  Lorsque vous venez de créer un dictionnaire, la fonction <code>PyDict_New()</code> est <code>PyDict_New()</code> .  J'ai supprimé quelques lignes et converti le code C en pseudo-code pour me concentrer sur les concepts clés. <br><br>  <code>PyDict_New()</code> : <br><br><ul><li>  Renvoie un objet dictionnaire; </li><li>  Alloue un nouvel objet dictionnaire; </li><li>  Efface la table du dictionnaire; </li><li>  Définit le nombre de cellules de dictionnaire utilisées et de cellules inutilisées ( <code>ma_fill</code> ) sur 0; </li><li>  Définit le nombre de cellules actives ( <code>ma_used</code> ) à 0; </li><li>  Définit le masque de dictionnaire ( <code>ma_value</code> ) sur une valeur égale à la taille du dictionnaire - 1 = 7; </li><li>  Définit la fonction de recherche de dictionnaire <code>lookdict_string</code> ; </li><li>  Renvoie l'objet de dictionnaire alloué. </li></ul><br>  <b>Ajouter un élément</b> <br><br>  Lorsqu'une nouvelle paire clé / valeur est ajoutée, <code>PyDict_SetItem()</code> appelée.  Cette fonction accepte un pointeur vers un objet dictionnaire et une paire clé / valeur en entrée.  Il vérifie si la clé est une chaîne et évalue le hachage ou réutilise le cache s'il en existe un.  <code>insertdict()</code> est appelé pour ajouter une nouvelle paire clé / valeur et la taille du dictionnaire change si le nombre de cellules utilisées et inutilisées est supérieur aux 2/3 de la taille du tableau. <br><br>  Pourquoi exactement 2/3?  Cela est nécessaire pour garantir que la séquence de sonde puisse trouver des cellules libres assez rapidement.  Plus tard, nous considérerons la fonction de redimensionnement. <br><br><pre> <code class="python hljs">arguments: dictionary, key, value returns: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> OK <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> function PyDict_SetItem: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key<span class="hljs-string"><span class="hljs-string">'s hash cached: use hash else: calculate hash call insertdict with dictionary object, key, hash and value if key/value pair added successfully and capacity over 2/3: call dictresize to resize dictionary'</span></span>s table</code> </pre> <br>  <code>inserdict()</code> utilise la fonction de recherche <code>lookdict_string()</code> pour trouver une cellule libre.  La même fonction est utilisée pour rechercher une clé. <br><br>  <code>lookdict_string()</code> calcule l'index de cellule en utilisant des valeurs de hachage et de masque.  Si elle ne peut pas trouver la clé par la valeur de la cellule index = hash &amp; mask (slot index = hash &amp; mask), elle commence à sonder en utilisant le cycle décrit ci-dessus jusqu'à ce qu'elle trouve une cellule libre.  À la première tentative de vérification, si la clé est <code>null</code> , elle renvoie une cellule inutilisée si elle a été trouvée lors de la première recherche.  Cela garantit la priorité pour la réutilisation des cellules précédemment supprimées. <br>  Nous voulons ajouter les paires clé / valeur suivantes: <code>{'a': 1, 'b': 2′, 'z': 26, 'y': 25, 'c': 5, 'x': 24}</code> .  Voici ce qui va se passer: <br><br>  La structure du dictionnaire est allouée avec une taille de table de 8. <br><br><ul><li>  PyDict_SetItem: key = 'a', value = 1 <br><ul><li>  hash = hash ('a') = 12416037344 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li>  index des emplacements = hachage et masque = 12416037344 et 7 = 0 </li><li>  l'emplacement 0 n'est pas utilisé, renvoyez cette cellule </li></ul></li><li>  initialisation de l'entrée à l'index 0 avec clé, valeur et hachage </li><li>  ma_used = 1, ma_fill = 1 </li></ul></li></ul></li><li>  PyDict_SetItem: key = 'b', value = 2 <br><ul><li>  hachage = hachage («b») = 12544037731 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li>  index des emplacements = hachage et masque = 12544037731 et 7 = 3 </li><li>  l'emplacement 3 n'est pas utilisé, renvoyez cette cellule </li></ul></li><li>  initialisation de l'entrée à l'index 3 avec clé, valeur et hachage </li><li>  ma_used = 2, ma_fill = 2 <br></li></ul></li></ul></li><li>  PyDict_SetItem: key = 'z', value = 26 <br><ul><li>  hachage = hachage («z») = 15616046971 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li>  index des emplacements = hachage et masque = 15616046971 et 7 = 3 </li><li>  l'emplacement 3 est utilisé, essayez une autre cellule: 5 est libre <br></li></ul><br>  initialisation de l'entrée à l'index 5 avec clé, valeur et hachage <br>  ma_used = 3, ma_fill = 3 <br></li></ul></li></ul></li><li>  PyDict_SetItem: key = 'y', value = 25 <br><ul><li>  hachage = hachage («y») = 15488046584 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li>  index de l'emplacement = hachage et masque = 15488046584 et 7 = 0 </li><li>  l'emplacement 0 est utilisé, essayez une autre cellule: 1 est libre </li></ul></li><li>  initialisation de l'entrée à l'index 1 avec clé, valeur et hachage </li><li>  ma_used = 4, ma_fill = 4 </li></ul></li></ul></li></ul><br>  PyDict_SetItem: key = 'c', value = 3 <br><ul><li>  hachage = hachage («c») = 12672038114 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li>  index de l'emplacement = hachage et masque = 12672038114 et 7 = 2 </li><li>  l'emplacement 2 n'est pas utilisé, renvoyez cette cellule </li></ul></li><li>  initialisation de l'entrée à l'index 2 avec clé, valeur et hachage </li><li>  ma_used = 5, ma_fill = 5 </li></ul></li></ul><br>  PyDict_SetItem: key = 'x', value = 24 <br><ul><li>  hachage = hachage ('x') = 15360046201 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li>  index des emplacements = hachage et masque = 15360046201 &amp; 7 = 1 </li><li>  l'emplacement 1 est utilisé, essayez une autre cellule: 7 est libre </li></ul></li><li>  initialisation de l'entrée à l'index 7 avec clé, valeur et hachage </li><li>  ma_used = 6, ma_fill = 6 </li></ul></li></ul><br>  Voici ce que nous obtenons: <br><br><img src="https://habrastorage.org/webt/f9/wa/hf/f9wahfryuhllv1zykzjmwjcqllk.png"><br><br>  Maintenant, 6 cellules sur 8 sont utilisées, plus des 2/3 de la capacité de la baie sont occupés.  <code>dictresize()</code> est appelé pour allouer un tableau plus grand.  Cette fonction copie également les enregistrements de l'ancienne table vers la nouvelle. <br><br>  <code>dictresize ()</code> est appelé avec <code>minused</code> = 24 dans notre cas, où 4 * <code>ma_used</code> .  2 * <code>ma_used</code> utilisé lorsque le nombre de cellules utilisées est très important (plus de 50 000).  Pourquoi 4 fois plus de cellules?  Cela réduit le nombre d'étapes pour implémenter le redimensionnement et augmente la parcimonie. <br><br>  La nouvelle taille du tableau doit être supérieure à 24, elle est calculée en décalant la taille actuelle de 1 bit vers la gauche jusqu'à ce que la taille du tableau devienne supérieure à 24. Par conséquent, ce sera 32, par exemple 8 -&gt; 16 -&gt; 32. <br><br>  Voici ce qui arrive à notre table lors du redimensionnement: une nouvelle table de taille 32 est mise en évidence. Les anciennes entrées de table sont insérées dans la nouvelle table en utilisant la nouvelle valeur de masque de 31. Le résultat est le suivant: <br><br><img src="https://habrastorage.org/webt/qy/ue/ke/qyueke3baeooxaxzskg8dphcpli.png"><br><br>  <b>Supprimer des éléments</b> <br><br>  <code>PyDict_DelItem()</code> est appelé pour supprimer des enregistrements.  Le hachage est calculé pour la clé d'enregistrement, puis la fonction de recherche est appelée pour renvoyer l'enregistrement.  Maintenant, la cellule est vide. <br><br>  Nous voulons supprimer la clé c de notre dictionnaire.  En conséquence, nous obtenons le tableau suivant: <br><br><img src="https://habrastorage.org/webt/sw/x1/l1/swx1l1efqzzelggasprbesixdqw.png"><br><br>  Notez que l'opération de suppression d'un élément ne modifie pas la taille du tableau si le nombre de cellules utilisées est bien inférieur à leur nombre total.  Cependant, lorsqu'une paire clé / valeur est ajoutée, la nécessité de redimensionner dépend du nombre de cellules utilisées et inactives, de sorte que l'opération d'ajout peut également réduire le tableau. <br><br>  Cette publication a pris fin, et nous attendons traditionnellement vos commentaires et invitons tout le monde à une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">leçon ouverte</a> , qui se tiendra le 18 avril. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448350/">https://habr.com/ru/post/fr448350/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448336/index.html">Séminaire «Nuages ​​hybrides - avantages et inconvénients: quoi préparer pour les affaires et l'informatique» - 25 avril, Moscou</a></li>
<li><a href="../fr448338/index.html">Décomposer les principes fondamentaux de C #: allouer de la mémoire pour un type de référence sur la pile</a></li>
<li><a href="../fr448340/index.html">Création du jeu 35MM. Après l'apocalypse en Russie</a></li>
<li><a href="../fr448342/index.html">MyDrops - TWS à faible coût avec un bon son et Bluetooth fiable</a></li>
<li><a href="../fr448346/index.html">De GNU à Doom: TechTrain 2019 annoncé</a></li>
<li><a href="../fr448352/index.html">Boring Company va creuser un tunnel à Las Vegas</a></li>
<li><a href="../fr448354/index.html">GraphQL Voyager comme outil de recherche de vulnérabilités</a></li>
<li><a href="../fr448358/index.html">Nous écoutons de la musique et des conférences de Youtube avec un écran de smartphone verrouillé et sans publicité en utilisant Telegram</a></li>
<li><a href="../fr448360/index.html">Une petite porte dérobée sur Flask ou comment contrôler un ordinateur sur un réseau local</a></li>
<li><a href="../fr448362/index.html">J'ai pensé que je devais envoyer des designers à ...</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>