<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ôüèª üë©‚Äçüé§ üèáüèΩ Wie wir PHP 7 doppelt so schnell wie PHP 5 gemacht haben. Teil 2: Optimierung des Bytecodes in PHP 7.1 üí¢ üî∫ üïµÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im ersten Teil der Geschichte, basierend auf einer Pr√§sentation von Dmitry Stogov von Zend Technologies auf HighLoad ++, haben wir die interne Struktu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir PHP 7 doppelt so schnell wie PHP 5 gemacht haben. Teil 2: Optimierung des Bytecodes in PHP 7.1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/445512/">  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil der</a> Geschichte, basierend auf einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pr√§sentation von</a> <strong>Dmitry Stogov</strong> von Zend Technologies auf HighLoad ++, haben wir die interne Struktur von PHP verstanden.  Wir haben im Detail und aus erster Hand erfahren, welche √Ñnderungen in den grundlegenden Datenstrukturen es PHP 7 erm√∂glichten, mehr als zweimal zu beschleunigen.  Dies h√§tte gestoppt werden k√∂nnen, aber bereits in Version 7.1 gingen die Entwickler viel weiter, da sie noch viele Ideen zur Optimierung hatten. <br><br>  Die gesammelten Erfahrungen mit JIT vor den sieben k√∂nnen nun interpretiert werden, indem die Ergebnisse in 7.0 ohne JIT und die Ergebnisse von HHVM mit JIT betrachtet werden.  In PHP 7.1 wurde beschlossen, nicht mit JIT zu arbeiten, sondern sich erneut an den Interpreter zu wenden.  Wenn die Optimierung fr√ºher den Interpreter betraf, werden wir uns in diesem Artikel mit der Optimierung des Bytecodes befassen, wobei die Typinferenz verwendet wird, die f√ºr unsere JIT implementiert wurde. <br><br><img src="https://habrastorage.org/webt/km/1d/cu/km1dcunb58tbgkftxkwegfktjto.png"><br><br>  Unter dem Schnitt wird Dmitry Stogov anhand eines einfachen Beispiels zeigen, wie dies alles funktioniert. <br><a name="habracut"></a><br><h3>  Bytecode-Optimierung </h3><br>  Unten finden Sie den Bytecode, in den der Standard-PHP-Compiler die Funktion kompiliert.  Es ist Single-Pass - schnell und dumm, kann aber seine Aufgabe bei jeder HTTP-Anfrage erneut erledigen (wenn OPcache nicht verbunden ist). <br><img src="https://habrastorage.org/webt/ur/rp/xe/urrpxeazkhjaoccg7lgswufya-o.png"><br><br><h3>  OPcache-Optimierungen </h3><br>  Mit dem Aufkommen von OPcache haben wir begonnen, es zu optimieren.  Einige Optimierungsmethoden <strong>sind seit langem in OPcache integriert</strong> , z. B. Methoden <strong>zur Spaltoptimierung.</strong> Wenn wir den Code durch das Guckloch betrachten, suchen Sie nach vertrauten Mustern und ersetzen Sie sie durch Heuristiken.  Diese Methoden werden in 7.0 weiterhin verwendet.  Zum Beispiel haben wir zwei Operationen: Addition und Zuweisung. <br><img src="https://habrastorage.org/webt/hn/qm/dg/hnqmdgqu4_etjvz7zxnzbfwgpve.png"><br><br>  Sie k√∂nnen zu einer zusammengesetzten Zuweisungsoperation kombiniert werden, die eine Addition direkt f√ºr das Ergebnis <code>ASSIGN_ADD $sum, $i</code> : <code>ASSIGN_ADD $sum, $i</code> .  Ein anderes Beispiel ist eine Post-Inkrement-Variable, die theoretisch ein Ergebnis zur√ºckgeben k√∂nnte. <br><img src="https://habrastorage.org/webt/re/gt/m4/regtm4l3qupkaynn4dulv8bliok.png"><br><br>  Es ist m√∂glicherweise kein Skalarwert und muss entfernt werden.  Verwenden Sie dazu die <code>FREE</code> Anweisung.  Wenn Sie es jedoch in ein Vorinkrement √§ndern, ist die <code>FREE</code> Anweisung nicht erforderlich. <br><img src="https://habrastorage.org/webt/xz/pd/0b/xzpd0bnqezhnqbcx3_zqseojbkq.png"><br><br>  Am Ende stehen zwei <code>RETURN</code> Anweisungen: Die erste spiegelt direkt die RETURN-Anweisung im Quelltext wider, und die zweite wird von einem dummen Compiler mit einer schlie√üenden Klammer hinzugef√ºgt.  Dieser Code wird niemals erreicht und kann gel√∂scht werden. <br>  Es sind nur noch vier Anweisungen in der Schleife vorhanden.  Es scheint, dass es nichts weiter zu optimieren gibt, aber nicht f√ºr uns. <br>  Schauen Sie sich den <code>$i++</code> und die entsprechende Anweisung an - das <code>PRE_INC</code> - <code>PRE_INC</code> .  Jedes Mal, wenn es ausgef√ºhrt wird: <br><br><ul><li>  m√ºssen √ºberpr√ºfen, welche Art von Variable kam; </li><li>  ob es <code>is_long</code> ; </li><li>  Inkrement ausf√ºhren; </li><li>  auf √úberlauf pr√ºfen; </li><li>  gehe zum n√§chsten; </li><li>  Vielleicht √ºberpr√ºfen Sie die Ausnahme. </li></ul><br>  Eine Person, die nur den PHP-Code betrachtet, wird jedoch feststellen, dass die Variable <code>$i</code> im Bereich von 0 bis 100 liegt und es keinen √úberlauf geben kann, dass keine Typpr√ºfungen erforderlich sind und es auch keine Ausnahmen geben kann.  <strong>In PHP 7.1 haben wir versucht, dem Compiler beizubringen, dies zu verstehen</strong> . <br><br><h3>  Optimierung des Kontrollflussdiagramms </h3><img src="https://habrastorage.org/webt/6c/kc/ov/6ckcovmmyomlp00lnvxvcdqkxpk.png"><br><br>  Dazu m√ºssen Sie Typen ableiten und zur Eingabe von Typen zun√§chst eine formale Darstellung der Datenstr√∂me erstellen, die der Computer versteht.  Zun√§chst erstellen wir jedoch ein Kontrollflussdiagramm, ein Kontrollabh√§ngigkeitsdiagramm.  Zun√§chst teilen wir den Code in Basisbl√∂cke auf - eine Reihe von Anweisungen mit einer Eingabe und einer Ausgabe.  Daher schneiden wir den Code an den Stellen, an denen der √úbergang stattfindet, dh an den Bezeichnungen L0, L1.  Wir schneiden es auch nach den bedingten und unbedingten Verzweigungsoperatoren und verbinden es dann mit B√∂gen, die die Abh√§ngigkeiten f√ºr die Steuerung anzeigen. <br><img src="https://habrastorage.org/webt/jb/rd/a2/jbrda2sz2t2yukuja4uido5ptk8.png"><br><br>  Also haben wir CFG. <br><br><h3>  Optimierung des statischen Einzelzuweisungsformulars </h3><br>  Nun brauchen wir eine Datenabh√§ngigkeit.  Zu diesem Zweck verwenden wir das statische Einzelzuweisungsformular - eine beliebte Darstellung in der Welt der Optimierung von Compilern.  Dies bedeutet, dass der Wert jeder Variablen nur einmal zugewiesen werden kann. <br><img src="https://habrastorage.org/webt/io/se/cd/iosecdoawvlte3fa8hn-q5ga3ea.png"><br><br>  F√ºr jede Variable f√ºgen wir einen Index oder eine Reinkarnationsnummer hinzu.  An jedem Ort, an dem die Zuordnung stattfindet, setzen wir einen neuen Index und verwenden ihn - bis zu den Fragezeichen, da er nicht immer √ºberall bekannt ist.  Zum Beispiel kann in der Anweisung <code>IS_SMALLER</code> $ i sowohl vom Block L0 mit der Nummer 4 als auch vom ersten Block mit der Nummer 2 stammen. <br><br>  Um dieses Problem zu l√∂sen, f√ºhrt die SSA <strong>die Phi-</strong> Pseudofunktion ein, die bei Bedarf am Anfang von basic-&gt; block eingef√ºgt wird, alle Arten von Indizes einer Variablen verwendet, die von verschiedenen Stellen in den Basisblock gelangt sind, und eine neue Reinkarnation der Variablen erstellt.  Es sind solche Variablen, die sp√§ter verwendet werden, um Mehrdeutigkeiten zu beseitigen. <br><img src="https://habrastorage.org/webt/ef/um/d8/efumd8l0ymc_8ffs0wwgraqso_q.png"><br><br>  Wenn Sie alle Fragezeichen auf diese Weise ersetzen, erstellen wir die SSA. <br><br><h3>  Typoptimierung </h3><br>  Jetzt leiten wir Typen ab - als ob wir versuchen w√ºrden, diesen Code direkt im Management auszuf√ºhren. <br><img src="https://habrastorage.org/webt/jd/tl/zf/jdtlzfxasn7ioyfhmumpxosc6z0.png"><br><br>  Im ersten Block werden den Variablen konstante Werte zugewiesen - Nullen, und wir wissen mit Sicherheit, dass diese Variablen vom Typ long sind.  Als n√§chstes kommt die Phi-Funktion.  Long kommt zur Eingabe und wir kennen die Werte anderer Variablen, die aus anderen Zweigen stammen, nicht. <br><img src="https://habrastorage.org/webt/qr/bf/ji/qrbfjicsc1njj9g0uv7llwwlax8.png"><br><br>  Wir glauben, dass die Ausgabe phi () wir lange haben werden. <br><img src="https://habrastorage.org/webt/ci/au/rx/ciaurxm91_qykojqstnrye1ixyo.png"><br><br>  Wir vertreiben weiter.  Wir kommen zu bestimmten Funktionen, zum Beispiel <code>ASSIGN_ADD</code> und <code>PRE_INC</code> .  Addiere zwei lange.  Das Ergebnis kann entweder lang oder doppelt sein, wenn ein √úberlauf auftritt. <br><img src="https://habrastorage.org/webt/sh/h1/xk/shh1xkzcm6gnefcsrn1n4jncrwu.png"><br><br>  Diese Werte fallen wieder in die Phi-Funktion, die Vereinigung der Mengen m√∂glicher Typen, die auf verschiedenen Zweigen ankommen, erfolgt.  Nun und so weiter verbreiten wir uns weiter, bis wir zu einem festen Punkt kommen und sich alles beruhigt. <br><img src="https://habrastorage.org/webt/cp/wi/pc/cpwipcwroghcv7tflquaeblynp8.png"><br><br>  Wir haben an jedem Punkt im Programm einen m√∂glichen Satz von Typwerten.  Das ist schon gut  Der Computer wei√ü bereits, dass <code>$i</code> nur lang oder doppelt sein kann und einige unn√∂tige √úberpr√ºfungen ausschlie√üen kann.  Aber wir wissen, dass doppeltes <code>$i</code> nicht sein kann.  Woher wissen wir das?  Und wir sehen eine Bedingung, die das Wachstum von <code>$i</code> im Zyklus auf einen m√∂glichen √úberlauf begrenzt.  Wir werden dem Computer beibringen, dies zu sehen. <br><br><h3>  Optimierung der Reichweitenausbreitung </h3><br>  In der <code>PRE_INC</code> Anweisung <code>PRE_INC</code> wir nie herausgefunden, dass ich nur eine ganze Zahl sein kann - es kostet lang oder doppelt.  Dies geschieht, weil wir nicht versucht haben, m√∂gliche Bereiche abzuleiten.  Dann k√∂nnten wir die Frage beantworten, ob ein √úberlauf auftritt oder nicht. <br><br>  Diese Ausgabe der Bereiche erfolgt auf √§hnliche, aber etwas komplexere Weise.  Als Ergebnis erhalten wir einen festen Bereich von Variablen <code>$i</code> mit den Indizes 2, 4, 6 und 7, und jetzt k√∂nnen wir sicher sagen, dass das Inkrement <code>$i</code> nicht zu einem √úberlauf f√ºhrt. <br><img src="https://habrastorage.org/webt/pd/fu/od/pdfuod-a6kri95noggd--fjtgly.png"><br><br>  Durch die Kombination dieser beiden Ergebnisse k√∂nnen wir mit Sicherheit sagen, dass die Doppelvariable <code>$i</code> niemals werden kann. <br><img src="https://habrastorage.org/webt/pj/ls/v7/pjlsv7o9sb_sovt2klcfhv0rthg.png"><br><br>  Wir haben nur noch keine Optimierung, dies sind Informationen zur Optimierung!  Betrachten Sie die <code>ASSIGN_ADD</code> .  Im Allgemeinen k√∂nnte der alte Wert der Summe, die zu dieser Anweisung kam, beispielsweise ein Objekt sein.  Nach dem Hinzuf√ºgen sollte der alte Wert entfernt worden sein.  In unserem Fall wissen wir jedoch mit Sicherheit, dass es einen Long- oder Double-Wert gibt, dh einen Skalarwert.  Es ist keine Zerst√∂rung erforderlich, wir k√∂nnen <code>ASSIGN_ADD</code> durch <code>ADD</code> ersetzen - eine einfachere Anweisung.  <code>ADD</code> verwendet die <code>sum</code> sowohl als Argument als auch als Wert. <br><img src="https://habrastorage.org/webt/s5/ln/i7/s5lni7nz1-kiwnyo-ch9h1jfpds.png"><br><br>  Bei Vorinkrementierungsoperationen wissen wir mit Sicherheit, dass der Operand immer lang ist und keine √úberl√§ufe auftreten k√∂nnen.  F√ºr diese Anweisung verwenden wir einen hochspezialisierten Handler, der nur die erforderlichen Aktionen ohne √úberpr√ºfung ausf√ºhrt. <br><img src="https://habrastorage.org/webt/90/9v/vm/909vvmh7ygoi4cudrfek9r9igw0.png"><br><br>  Vergleichen Sie nun die Variable am Ende der Schleife.  Wir wissen, dass der Wert der Variablen nur lang sein wird - Sie k√∂nnen diesen Wert sofort √ºberpr√ºfen, indem Sie ihn mit hundert vergleichen.  Wenn wir fr√ºher das Ergebnis der √úberpr√ºfung in einer tempor√§ren Variablen aufgezeichnet und dann die tempor√§re Variable erneut auf wahr / falsch √ºberpr√ºft haben, kann dies jetzt mit einer Anweisung erfolgen, dh vereinfacht. <br><img src="https://habrastorage.org/webt/y0/rl/gu/y0rlgu9ga2q1t9oxt_fdszkizei.png"><br><br>  Bytecode-Ergebnis im Vergleich zum Original. <br><img src="https://habrastorage.org/webt/_c/k7/ed/_ck7edx3i303of0vmfgpx6cefz4.png"><br><br>  Der Zyklus enth√§lt nur noch drei Anweisungen, von denen zwei hochspezialisiert sind.  Infolgedessen ist der Code auf der rechten Seite <strong>dreimal schneller als das</strong> Original. <br><br><h3>  Hochspezialisierte Handler </h3><br>  Jeder <strong>PHP-Crawler ist nur eine C-Funktion</strong> .  Links befindet sich ein Standardhandler und oben rechts ein hochspezialisierter.  Der linke pr√ºft: den Typ des Operanden, wenn ein √úberlauf aufgetreten ist, wenn eine Ausnahme aufgetreten ist.  Der Richtige f√ºgt nur einen hinzu und das wars.  Es √ºbersetzt in 4 Maschinenanweisungen.  Wenn wir weiter gehen und JIT machen w√ºrden, w√ºrden wir nur eine einmalige Anweisung <code>incl</code> . <br><img src="https://habrastorage.org/webt/jg/zk/me/jgzkmezahf-1rxzvxrgvhdrhmiw.png"><br><br><h2>  Was weiter? </h2><br>  Wir erh√∂hen weiterhin die Geschwindigkeit von PHP Branch 7 ohne JIT.  <strong>PHP 7.1 wird</strong> bei typischen synthetischen Tests <strong>wieder 60% schneller</strong> sein, aber bei realen Anwendungen bringt dies fast keinen Gewinn - nur 1-2% bei WordPress.  Das ist nicht besonders interessant.  Seit August 2016, als der 7.1-Zweig wegen gr√∂√üerer √Ñnderungen eingefroren wurde, haben wir wieder begonnen, an JIT f√ºr PHP 7.2 bzw. PHP 8 zu arbeiten. <br><br>  In einem neuen Versuch verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DynAsm</a> , um den Code zu generieren, der von Mike Paul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">f√ºr LuaJIT-2 entwickelt wurde</a> .  Es ist gut, weil es <strong>sehr schnell Code generiert</strong> : Die Tatsache, dass Minuten in der JIT-Version auf LLVM kompiliert wurden, geschieht jetzt in 0,1-0,2 s.  Bereits heute ist die <strong>Beschleunigung auf bank.php auf JIT 75-mal schneller</strong> als auf PHP 5. <br><br>  Bei realen Anwendungen gibt es keine Beschleunigung, und dies ist die n√§chste Herausforderung f√ºr uns.  Zum Teil haben wir den optimalen Code erhalten, aber nachdem wir zu viele PHP-Skripte kompiliert hatten, haben wir den Prozessor-Cache verstopft, sodass er nicht schneller funktionierte.  Und nicht die Codegeschwindigkeit war ein Engpass in realen Anwendungen ... <br><br>  Vielleicht kann DynAsm verwendet werden, um nur bestimmte Funktionen zu kompilieren, die entweder von einem Programmierer oder durch z√§hlerbasierte Heuristiken ausgew√§hlt werden - wie oft eine Funktion aufgerufen wurde, wie oft Zyklen darin wiederholt werden usw. <br><br>  Unten finden Sie den Maschinencode, den unsere JIT f√ºr dasselbe Beispiel generiert.  Viele Befehle sind optimal kompiliert: Inkrementieren in einen CPU-Befehl, Variableninitialisierung auf Konstanten in zwei.  Wo die Typen nicht geschl√ºpft sind, muss man sich etwas mehr k√ºmmern. <br><img src="https://habrastorage.org/webt/fj/zh/n9/fjzhn9m8unce1eui5yhb7otreng.png"><br><br>  Zur√ºck zum Titelbild zeigt PHP im Vergleich zu √§hnlichen Sprachen im Mandelbrot-Test sehr gute Ergebnisse (obwohl die Daten Ende 2016 relevant sind). <br><img src="https://habrastorage.org/webt/km/1d/cu/km1dcunb58tbgkftxkwegfktjto.png"><br>  <i>Das Diagramm zeigt die Ausf√ºhrungszeit in Sekunden, weniger ist besser.</i> <br><br>  Vielleicht ist <strong>Mandelbrot nicht der beste Test.</strong>  Es ist rechnerisch, aber einfach und in allen Sprachen gleicherma√üen implementiert.  Es w√§re sch√∂n zu wissen, wie schnell Wordpress in C ++ funktionieren w√ºrde, aber es gibt kaum eine Kuriosit√§t, die bereit ist, es neu zu schreiben, nur um alle Perversionen des PHP-Codes zu √ºberpr√ºfen und sogar zu wiederholen.  Wenn Sie Ideen f√ºr einen angemesseneren Satz von Benchmarks haben, schlagen Sie vor. <br><br><blockquote>  Wir werden uns <strong>am 17. Mai</strong> auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PHP in Russland</a> treffen und die Perspektiven und die Entwicklung des √ñkosystems sowie die Erfahrungen mit der Verwendung von PHP f√ºr wirklich komplexe und coole Projekte diskutieren.  Schon bei uns: <br><br><ul><li>  <strong>Nikita Popov</strong> , einer der bekanntesten Entwickler des PHP-Kernels, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wird erz√§hlen,</a> was uns in der kommenden Version von PHP 7.4 erwartet. </li><li>  <strong>Dmitry Stogov</strong> wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in PHP 8</a> √ºber grandiose <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pl√§ne</a> sprechen. </li><li>  <strong>Anton Titov</strong> , Autor des RoadRunner-Anwendungsservers, wird das Thema ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwickeln hybrider PHP / Go-Anwendungen mit RoadRunner</a> ‚Äú vorstellen. </li></ul><br>  Das ist nat√ºrlich alles andere als gut.  Und Call for Papers ist noch geschlossen. <strong>Bis zum 1. April</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">warten wir auf Anwendungen</a> von denen, die moderne Ans√§tze und Best Practices anwenden k√∂nnen, um coole PHP-Dienste zu implementieren.  Haben Sie keine Angst vor dem Wettbewerb mit herausragenden Rednern - wir <strong>suchen nach Erfahrung in der Verwendung</strong> ihrer Aufgaben in realen Projekten und helfen Ihnen dabei, die Vorteile Ihrer F√§lle aufzuzeigen. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445512/">https://habr.com/ru/post/de445512/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445500/index.html">Informationen zu Open Distros, Open Source und Elastic</a></li>
<li><a href="../de445502/index.html">Vivaldi 2.4 - Bewegen Sie die Kn√∂pfe mit zwei H√§nden</a></li>
<li><a href="../de445504/index.html">IT Service Management (ITSM) mit Tools f√ºr maschinelles Lernen effizienter</a></li>
<li><a href="../de445506/index.html">OS1: Primitiver Kernel auf Rust f√ºr x86</a></li>
<li><a href="../de445510/index.html">Erwartungen managen oder nein sagen</a></li>
<li><a href="../de445514/index.html">Das interessanteste auf der Ausstellung Securika Moskau 2019</a></li>
<li><a href="../de445516/index.html">Neuronale Quantenzust√§nde - Darstellung einer Wellenfunktion durch ein neuronales Netzwerk</a></li>
<li><a href="../de445518/index.html">Altes Eisen: elektronische Werkzeuge, die in den Tiefen der Geschichte verloren gehen</a></li>
<li><a href="../de445520/index.html">Erweiterungen f√ºr Visual Studio Code, mit denen Sie mit Git arbeiten k√∂nnen</a></li>
<li><a href="../de445524/index.html">Analyse der Anzeige (Schnittstelle der Anordnung der Waren im Gesch√§ft)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>