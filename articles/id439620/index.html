<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👩🏽 🍍 🐆 Memahami Asynchrony dalam JavaScript [Terjemahan dari Sukhjinder Arora] 🕺🏻 👵 💮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya mempersembahkan untuk Anda terjemahan artikel “Memahami Asynchronous JavaScript” oleh Sukhjinder Arora. 



 Dari penulis terjemahan:...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memahami Asynchrony dalam JavaScript [Terjemahan dari Sukhjinder Arora]</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439620/">  Halo, Habr!  Saya mempersembahkan untuk Anda terjemahan artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Memahami Asynchronous JavaScript”</a> oleh Sukhjinder Arora. <br><br><img src="https://habrastorage.org/webt/78/ss/a1/78ssa15sg7wxe0nukoyfnjgopao.jpeg"><br><a name="habracut"></a><br>  <i>Dari penulis terjemahan: Saya harap terjemahan artikel ini akan membantu Anda membiasakan diri dengan sesuatu yang baru dan bermanfaat.</i>  <i>Jika artikelnya membantu Anda, maka jangan malas dan berterima kasih pada penulis aslinya.</i>  <i>Saya tidak berpura-pura menjadi penerjemah profesional, saya baru mulai menerjemahkan artikel dan saya akan senang dengan umpan balik informatif.</i> <br><br>  JavaScript adalah bahasa pemrograman single-threaded di mana hanya satu hal yang dapat dieksekusi pada suatu waktu.  Artinya, dalam satu utas, mesin JavaScript hanya dapat memproses 1 pernyataan pada satu waktu. <br><br>  Meskipun bahasa single-threaded membuat kode penulisan lebih mudah karena Anda tidak perlu khawatir tentang masalah konkurensi, itu juga berarti Anda tidak akan dapat melakukan operasi panjang seperti mengakses jaringan tanpa memblokir utas utama. <br><br>  Kirim permintaan API untuk beberapa data.  Bergantung pada situasinya, server mungkin membutuhkan waktu untuk memproses permintaan Anda, sementara eksekusi aliran utama akan diblokir karena halaman web Anda akan berhenti merespons permintaan itu. <br><br>  Di sinilah JavaScript asinkron berperan.  Menggunakan JavaScript asynchrony (callback, janji, dan async / menunggu) Anda dapat melakukan permintaan jaringan yang panjang tanpa memblokir utas utama. <br><br>  Meskipun tidak perlu mempelajari semua konsep ini untuk menjadi pengembang JavaScript yang baik, itu berguna untuk mengetahuinya. <br><br>  Jadi, tanpa basa-basi, mari kita mulai. <br><br><h2>  Bagaimana cara kerja javascript sinkron? </h2><br>  Sebelum kita mempelajari pekerjaan asinkron JavaScript, mari kita terlebih dahulu memahami bagaimana kode sinkron berjalan di dalam mesin JavaScript.  Sebagai contoh: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello there!'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hi there!'</span></span>); second(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The End'</span></span>); } first();</code> </pre> <br>  Untuk memahami bagaimana kode di atas dieksekusi di dalam mesin JavaScript, kita perlu memahami konsep konteks eksekusi dan tumpukan panggilan (juga dikenal sebagai tumpukan eksekusi). <br><br><h3>  Konteks eksekusi </h3><br>  Konteks eksekusi adalah konsep abstrak dari lingkungan di mana kode dievaluasi dan dieksekusi.  Setiap kali kode dieksekusi dalam JavaScript, ia berjalan dalam konteks eksekusi. <br><br>  Kode fungsi dieksekusi di dalam konteks eksekusi fungsi, dan kode global, pada gilirannya, dieksekusi di dalam konteks eksekusi global.  Setiap fungsi memiliki konteks eksekusi sendiri. <br><br><h3>  Tumpukan panggilan </h3><br>  Tumpukan panggilan adalah tumpukan dengan struktur LIFO (Last in, First Out, first use), yang digunakan untuk menyimpan semua konteks eksekusi yang dibuat selama eksekusi kode. <br><br>  JavaScript hanya memiliki satu tumpukan panggilan, karena ini adalah bahasa pemrograman single-threaded.  Struktur LIFO berarti bahwa elemen hanya dapat ditambahkan dan dihapus dari bagian atas tumpukan. <br><br>  Sekarang mari kita kembali ke potongan kode di atas dan mencoba memahami bagaimana mesin JavaScript melakukan itu. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello there!'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hi there!'</span></span>); second(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The End'</span></span>); } first();</code> </pre> <br><img src="https://habrastorage.org/webt/mq/bn/_d/mqbn_dfda1fmgpqrdq48jk7zhcy.png"><br><br><h3>  Jadi apa yang terjadi di sini? </h3><br>  Ketika kode mulai dieksekusi, konteks eksekusi global dibuat (direpresentasikan sebagai <i>main ()</i> ) dan ditambahkan ke bagian atas tumpukan panggilan.  Ketika panggilan ke fungsi <i>pertama ()</i> ditemui, itu juga ditambahkan ke bagian atas tumpukan. <br><br>  Selanjutnya, <i>console.log ('Hai di sana!')</i> Ditempatkan di bagian atas tumpukan panggilan, setelah eksekusi dihapus dari tumpukan.  Setelah itu, kita memanggil fungsi <i>kedua ()</i> , sehingga ditempatkan di bagian atas tumpukan. <br><br>  <i>console.log ('Halo di sana!')</i> ditambahkan ke bagian atas tumpukan dan dihapus darinya setelah penyelesaian eksekusi.  Fungsi <i>kedua ()</i> selesai, itu juga dihapus dari tumpukan. <br><br>  <i>console.log ('The End')</i> ditambahkan ke bagian atas tumpukan dan dihapus di bagian akhir.  Setelah itu, fungsi <i>pertama ()</i> berakhir dan juga dihapus dari tumpukan. <br><br>  Eksekusi program berakhir, sehingga konteks panggilan global ( <i>main ()</i> ) dihapus dari stack. <br><br><h2>  Bagaimana cara kerja JavaScript asinkron? </h2><br>  Sekarang kita memiliki pemahaman dasar tentang tumpukan panggilan dan cara kerja JavaScript sinkron, mari kembali ke JavaScript asinkron. <br><br><h3>  Apa itu pemblokiran? </h3><br>  Mari kita asumsikan bahwa kita sedang memproses pemrosesan gambar atau permintaan jaringan secara serempak.  Sebagai contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processImage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">image</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">/** *    **/</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Image processed'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> networkRequest = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">/** *      **/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> someData; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeting = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World'</span></span>); } processImage(logo.jpg); networkRequest(<span class="hljs-string"><span class="hljs-string">'www.somerandomurl.com'</span></span>); greeting();</code> </pre> <br>  Pemrosesan gambar dan permintaan jaringan membutuhkan waktu.  Ketika fungsi <i>processImage ()</i> dipanggil, eksekusi akan memakan waktu, tergantung pada ukuran gambar. <br><br>  Ketika fungsi <i>processImage ()</i> selesai, ia dihapus dari tumpukan.  Setelah itu, fungsi <i>networkRequest ()</i> dipanggil dan ditambahkan ke stack.  Ini lagi akan memakan waktu sebelum menyelesaikan eksekusi. <br><br>  Pada akhirnya, ketika fungsi <i>networkRequest ()</i> dijalankan, fungsi <i>ucapan ()</i> dipanggil, karena hanya berisi metode <i>console.log</i> , dan metode ini biasanya cepat, fungsi <i>ucapan ()</i> akan mengeksekusi dan berakhir secara instan. <br><br>  Seperti yang Anda lihat, kita perlu menunggu fungsi (seperti <i>processImage ()</i> atau <i>networkRequest ()</i> ) selesai.  Ini berarti bahwa fungsi tersebut memblokir tumpukan panggilan atau utas utama.  Akibatnya, kami tidak dapat melakukan operasi lain hingga kode di atas dijalankan. <br><br><h3>  Jadi apa solusinya? </h3><br>  Solusi paling sederhana adalah fungsi callback asinkron.  Kami menggunakannya untuk membuat kode kami tidak terblokir.  Sebagai contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> networkRequest = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Async Code'</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World'</span></span>); networkRequest();</code> </pre> <br>  Di sini saya menggunakan metode <i>setTimeout</i> untuk mensimulasikan permintaan jaringan.  Harap ingat bahwa <i>setTimeout</i> bukan bagian dari mesin JavaScript, itu adalah bagian dari apa yang disebut web API (di browser) dan C / C ++ API (dalam node.js). <br><br>  Untuk memahami bagaimana kode ini dieksekusi, kita perlu berurusan dengan beberapa konsep lagi, seperti loop acara dan antrian panggilan balik (juga dikenal sebagai antrian tugas atau antrian pesan). <br><br><img src="https://habrastorage.org/webt/fd/u7/jx/fdu7jxtawrvjmrptsnumrtidceg.png"><br><br>  Perulangan acara, API web, dan antrian pesan / antrian tugas bukan bagian dari mesin JavaScript, melainkan bagian dari runtime JavaScript JavaScript atau runtime JavaScript di Nodejs (dalam kasus Nodejs).  Di Nodejs, API web diganti dengan C / C ++ API. <br><br>  Sekarang, mari kita kembali ke kode di atas dan melihat apa yang terjadi dalam kasus eksekusi asinkron. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> networkRequest = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Async Code'</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World'</span></span>); networkRequest(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The End'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/pc/zt/e5/pczte5tqprl18tltgiurc75m50g.gif"><br><br>  Ketika kode di atas dimuat ke browser, <i>console.log ('Hello World')</i> ditambahkan ke tumpukan dan dihapus dari itu setelah penyelesaian eksekusi.  Selanjutnya, panggilan ke fungsi <i>networkRequest () ditemui</i> , ditambahkan ke bagian atas tumpukan. <br><br>  Selanjutnya, fungsi <i>setTimeout ()</i> dipanggil dan ditempatkan di bagian atas tumpukan.  Fungsi <i>setTimeout ()</i> memiliki 2 argumen: 1) fungsi panggilan balik dan 2) waktu dalam milidetik. <br><br>  <i>setTimeout ()</i> memulai penghitung waktu selama 2 detik di lingkungan API web.  Pada titik ini, <i>setTimeout ()</i> selesai dan dihapus dari tumpukan.  Setelah itu, <i>console.log ('The End')</i> ditambahkan ke stack, dieksekusi dan dihapus dari itu setelah selesai. <br><br>  Sementara itu, timer telah kedaluwarsa, sekarang callback ditambahkan ke antrian pesan.  Tetapi panggilan balik tidak dapat segera dieksekusi, dan di sinilah siklus pemrosesan peristiwa memasuki proses. <br><br><h3>  Perulangan acara </h3><br>  Tugas dari loop acara adalah untuk melacak tumpukan panggilan dan menentukan apakah itu kosong atau tidak.  Jika tumpukan panggilan kosong, maka loop acara terlihat di antrian pesan untuk melihat apakah ada panggilan balik yang menunggu untuk diselesaikan. <br><br>  Dalam kasus kami, antrian pesan berisi satu panggilan balik, dan tumpukan eksekusi kosong.  Oleh karena itu, loop peristiwa menambahkan panggilan balik ke bagian atas tumpukan. <br><br>  Setelah <i>console.log ('Kode Async')</i> ditambahkan ke bagian atas tumpukan, dieksekusi dan dihapus darinya.  Pada titik ini, panggilan balik selesai dan dihapus dari tumpukan, dan program sepenuhnya selesai. <br><br><h3>  Acara DOM </h3><br>  Antrian pesan juga berisi panggilan balik dari acara DOM, seperti klik dan acara keyboard.  Sebagai contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.btn'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>,(event) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Button Clicked'</span></span>); });</code> </pre> <br>  Dalam kasus peristiwa DOM, pengendali peristiwa dikelilingi oleh API web, menunggu peristiwa tertentu (dalam hal ini, klik), dan ketika peristiwa ini terjadi, fungsi panggilan balik ditempatkan dalam antrian pesan, menunggu pelaksanaannya. <br><br>  Kami mempelajari bagaimana panggilan balik tidak sinkron dan peristiwa DOM dieksekusi, yang menggunakan antrian pesan untuk menyimpan panggilan balik yang menunggu untuk dieksekusi. <br><br><h3>  ES6 MicroTask Queue </h3><br>  <i>Catatan</i>  <i>penulis terjemahan: Dalam artikel tersebut, penulis menggunakan antrian pesan / tugas dan antrian pekerjaan / mikro-taks, tetapi jika Anda menerjemahkan antrian tugas dan antrian pekerjaan, maka secara teori ternyata hal yang sama.</i>  <i>Saya berbicara dengan penulis terjemahan dan memutuskan untuk menghilangkan konsep antrian pekerjaan.</i>  <i>Jika Anda memiliki pemikiran tentang ini, maka saya menunggu Anda di komentar</i> <i><br><br></i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautkan ke terjemahan artikel dengan janji dari penulis yang sama</a></i> <i><br></i> <br><br>  ES6 memperkenalkan konsep antrian mikrotask, yang digunakan oleh Promises in JavaScript.  Perbedaan antara antrian pesan dan antrian mikrotask adalah bahwa antrian mikrotask memiliki prioritas lebih tinggi daripada antrian pesan, yang berarti bahwa "janji" di dalam antrian mikrotask akan dieksekusi lebih awal daripada panggilan balik dalam antrian pesan. <br><br>  Sebagai contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Script start'</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'setTimeout'</span></span>); }, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise resolved'</span></span>); }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Script End'</span></span>);</code> </pre> <br>  Kesimpulan: <br><br><pre> <code class="javascript hljs">Script start Script End <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> resolved setTimeout</code> </pre> <br>  Seperti yang Anda lihat, "janji" dijalankan sebelum <i>setTimeout</i> , semua ini karena respons dari "janji" disimpan di dalam antrian microstask, yang memiliki prioritas lebih tinggi daripada antrian pesan. <br><br>  Mari kita lihat contoh berikut, kali ini 2 "janji" dan 2 <i>setTimeout</i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Script start'</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'setTimeout 1'</span></span>); }, <span class="hljs-number"><span class="hljs-number">0</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'setTimeout 2'</span></span>); }, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise 1 resolved'</span></span>); }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err)); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise 2 resolved'</span></span>); }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Script End'</span></span>);</code> </pre> <br>  Kesimpulan: <br><br><pre> <code class="javascript hljs">Script start Script End <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> resolved <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> resolved setTimeout <span class="hljs-number"><span class="hljs-number">1</span></span> setTimeout <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Dan lagi, kedua "janji" kami dieksekusi sebelum callback di dalam <i>setTimeout</i> , karena loop pemrosesan acara menganggap tugas dari antrian mikrotask lebih penting daripada tugas dari antrian pesan / antrian tugas. <br><br>  Jika “Janji” lain muncul dari antrian mikrotask selama pelaksanaan tugas, maka akan ditambahkan ke akhir antrian ini dan dieksekusi sebelum panggilan balik dari antrian pesan, dan tidak peduli berapa lama mereka menunggu eksekusi. <br><br>  Sebagai contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Script start'</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'setTimeout'</span></span>); }, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise 1 resolved'</span></span>); }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res)); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise 2 resolved'</span></span>); }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise 3 resolved'</span></span>); }) }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Script End'</span></span>);</code> </pre> <br>  Kesimpulan: <br><br><pre> <code class="javascript hljs">Script start Script End <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> resolved <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> resolved <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> resolved setTimeout</code> </pre> <br>  Dengan demikian, semua tugas dari antrian mikrotask akan selesai sebelum tugas dari antrian pesan.  Yaitu, loop pemrosesan acara pertama-tama akan menghapus antrian mikrotask, dan baru kemudian ia akan mulai mengeksekusi callback dari antrian pesan. <br><br><h2>  Kesimpulan </h2><br>  Jadi, kami mempelajari cara kerja JavaScript dan konsep asinkron: tumpukan panggilan, loop acara, antrian pesan / antrian tugas, dan antrian mikrotask yang membentuk runtime JavaScript </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439620/">https://habr.com/ru/post/id439620/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439608/index.html">Agama Modern: Apa yang diberikan Google, Facebook, Amazon, dan Apple kepada orang-orang?</a></li>
<li><a href="../id439610/index.html">Seperti pada kendaraan listrik Chevrolet Bolt saya, dalam garansi, dua modul baterai diganti, dan yang ketiga dalam pengawasan</a></li>
<li><a href="../id439612/index.html">JavaScript yang kuat: mengejar mitos</a></li>
<li><a href="../id439616/index.html">Intisari proyek-proyek TI yang menarik di Kickstarter No. 7</a></li>
<li><a href="../id439618/index.html">PHP untuk pemula. Koneksi file</a></li>
<li><a href="../id439624/index.html">Mengapa menyimpan data dalam orbit</a></li>
<li><a href="../id439626/index.html">Pengalaman mengembangkan aplikasi gratis untuk kolektor OpenNumismat</a></li>
<li><a href="../id439628/index.html">Refresh data paralel di ASP.NET Web API</a></li>
<li><a href="../id439632/index.html">Cara mengatur Penerapan Berkelanjutan untuk proyek Anda: pengalaman pribadi</a></li>
<li><a href="../id439636/index.html">Krisis konsep untuk meningkatkan keselamatan jalan dan konsep baru untuk menyelesaikannya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>