<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº üë∏üèª üëπ Exibi√ß√£o e otimiza√ß√£o da sa√≠da do terminal na web üßëüèΩ‚Äçü§ù‚Äçüßëüèª üëõ üõéÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="H√° pouco tempo, deparei-me com uma tarefa bastante simples e ao mesmo tempo interessante: implementar terminal somente leitura em um aplicativo da web...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Exibi√ß√£o e otimiza√ß√£o da sa√≠da do terminal na web</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448030/"><p>  H√° pouco tempo, deparei-me com uma tarefa bastante simples e ao mesmo tempo interessante: implementar terminal somente leitura em um aplicativo da web.  O interesse na tarefa foi dado por tr√™s aspectos importantes: </p><br><ul><li>  suporte para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seq√º√™ncias</a> b√°sicas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">escape ANSI</a> </li><li>  suporte para pelo menos 50.000 linhas de dados </li><li>  exibir dados assim que estiverem dispon√≠veis. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ku/fa/rk/kufarkakkmxskpfqqokeixh_ste.png"></div><br><p>  Neste artigo, falarei sobre como foi implementado e como otimizou tudo. </p><a name="habracut"></a><br><p>  <em>Isen√ß√£o de responsabilidade: n√£o sou desenvolvedor web experiente, portanto algumas coisas podem parecer √≥bvias para voc√™ e as conclus√µes ou decis√µes est√£o erradas.</em>  <em>Por corre√ß√µes e esclarecimentos, serei grato.</em> </p><br><h2 id="dlya-chego-eto-zatevalos">  Por que isso </h2><br><p>  A tarefa toda √© a seguinte: um script est√° sendo executado no servidor (bash, python etc.) e escreve algo no stdout.  E essa conclus√£o deve ser exibida na p√°gina da Web √† medida que ela chega.  Ao mesmo tempo, deve ser semelhante ao terminal (com formata√ß√£o, transfer√™ncia de cursor etc.) <br>  Eu n√£o controlo o pr√≥prio script e sua sa√≠da de forma alguma e o mostro de forma pura. </p><br><p>  Obviamente, entre a interface da web e o script, deve haver um intermedi√°rio - um servidor da web.  E se n√£o dissimular - eu j√° tenho um aplicativo da web e um servidor, e de alguma forma funcionar.  O esquema √© mais ou menos assim: <br><img src="https://habrastorage.org/webt/ww/kb/ei/wwkbei13_tv9n6w6vcw_6c4e5dm.png"></p><br><p>  Mas antes, o servidor era respons√°vel pelo processamento e formata√ß√£o.  E eu queria melhor√°-lo por um grande n√∫mero de raz√µes: </p><br><ul><li>  processamento de dados duplo - primeiro analisando no servidor e depois transformando em componentes html no cliente </li><li>  algoritmo n√£o ideal devido √† prepara√ß√£o de dados para o cliente </li><li>  carga pesada no servidor - o processamento da sa√≠da de um √∫nico script pode carregar completamente um √∫nico encadeamento no servidor </li><li>  suporte incompleto para seq√º√™ncias de escape ANSI </li><li>  erros sutis </li><li>  o cliente se saiu muito mal ao exibir at√© 10k linhas formatadas </li></ul><br><p>  Portanto, foi decidido transferir toda a l√≥gica de an√°lise para o aplicativo Web e deixar apenas o fluxo de dados brutos para o servidor </p><br><h2 id="postanovka-zadachi">  Declara√ß√£o do problema </h2><br><p>  Partes do texto chegam ao cliente.  O cliente deve analis√°-los em componentes: texto sem formata√ß√£o, avan√ßo de linha, retorno de carro e comandos ANSI especiais.  N√£o h√° garantias na integridade das partes - um comando ou uma palavra pode vir em pacotes diferentes. </p><br><p>  Os comandos ANSI podem afetar o formato do texto (cor, plano de fundo, estilo), a posi√ß√£o do cursor (de onde o texto subsequente deve ser exibido) ou para limpar parte da tela. <br>  Um exemplo de como √©: <br><img src="https://habrastorage.org/webt/5u/3c/tt/5u3cttwmep44kv8c9gysh5bn9ig.png"></p><br><p>  Al√©m disso, pode haver URLs no texto que tamb√©m precisam ser reconhecidos e destacados. </p><br><h2 id="beryom-gotovuyu-biblioteku-i-">  Tomamos a biblioteca acabada e ... </h2><br><p>  Entendi que o processamento correto e r√°pido de todos os comandos n√£o √© uma tarefa f√°cil.  Por isso, decidi procurar uma biblioteca pronta.  E <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">eis que</a> eu imediatamente me deparei com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">xterm.js</a> .  Um componente pronto do terminal, que j√° √© usado em muitos lugares e, al√©m disso, <em>"√© realmente r√°pido, inclui at√© um renderizador acelerado por GPU"</em> .  O √∫ltimo foi o mais importante para mim, porque  Eu finalmente queria ter um cliente muito r√°pido. </p><br><p>  Apesar de gostar de escrever minhas pr√≥prias bicicletas, fiquei extremamente feliz por n√£o apenas economizar tempo, mas tamb√©m obter v√°rias funcionalidades √∫teis gratuitamente. </p><br><p>  Levei duas horas para tentar conectar o terminal e n√£o <strong>consegui</strong> lidar com isso.  Absolutamente. <br>  Diferentes alturas de linha, sele√ß√£o distorcida, tamanho adaptativo do terminal, uma API muito estranha, falta de documenta√ß√£o s√£ ... </p><br><p>  Mas eu ainda tinha um pouco de inspira√ß√£o e acreditava que poderia lidar com esses problemas. <br>  At√© eu alimentar meu teste de 10k linhas no terminal ... Ele morreu.  E enterrou comigo os restos de minhas esperan√ßas. </p><br><h2 id="opisanie-itogovogo-algoritma">  Descri√ß√£o do algoritmo final </h2><br><p>  Primeiro, copiei o algoritmo atual implementado em python e o adaptei para javascript (apenas removendo chaves e outro para sintaxe). </p><br><p>  Eu conhecia todos os principais pr√≥s e contras do antigo algoritmo, ent√£o s√≥ precisava melhorar os lugares ineficazes nele. </p><br><p>  Ap√≥s delibera√ß√£o, tentativa e erro, decidi pela seguinte op√ß√£o: dividimos o algoritmo em 2 componentes: </p><br><ul><li>  modelo para analisar texto e armazenar o estado atual do "terminal" </li><li>  mapeamento que traduz o modelo em HTML </li></ul><br><h4 id="model-struktura-i-algoritm">  Modelo (estrutura e algoritmo) </h4><br><ul><li>  Todas as linhas s√£o armazenadas em uma matriz (n√∫mero da linha = √≠ndice na matriz) </li><li>  Os estilos de texto s√£o armazenados em uma matriz separada. </li><li>  A posi√ß√£o atual do cursor √© armazenada e pode ser alterada por comandos </li><li>  O pr√≥prio algoritmo verifica os dados de entrada caractere por caractere: <br><ul><li>  Se for apenas texto, adicione √† linha atual </li><li>  Se houver quebra de linha, aumente o √≠ndice da linha atual </li><li>  Se esse √© um dos caracteres de comando, colocamos no buffer de comando e aguardamos o pr√≥ximo caractere </li><li>  Se o buffer do comando estiver correto, execute este comando, caso contr√°rio, escrevemos esse buffer como texto </li></ul></li><li>  O modelo notifica os ouvintes sobre quais linhas foram alteradas ap√≥s o processamento de texto recebido </li></ul><br><p>  Na minha implementa√ß√£o, a complexidade do algoritmo √© O ( <em>n</em> log <em>n</em> ), em que log <em>n</em> √© a prepara√ß√£o de linhas alteradas para notifica√ß√£o (exclusividade e classifica√ß√£o).  No momento da reda√ß√£o deste artigo, percebi que, em um caso especial, voc√™ pode se livrar do log <em>n</em> , j√° que as linhas s√£o adicionadas com mais freq√º√™ncia ao final. </p><br><h4 id="otobrazhenie">  Exibi√ß√£o </h4><br><ul><li>  Exibe texto como elementos HTML </li><li>  Se a sequ√™ncia foi alterada, substitui completamente todos os elementos da sequ√™ncia </li><li>  Quebra cada linha com base em estilos: cada segmento estilizado tem seu pr√≥prio elemento </li></ul><br><p>  Com essa estrutura, testar √© uma tarefa bastante simples - transferimos o texto para o modelo (em um √∫nico pacote ou em partes) e apenas verificamos o estado atual de todas as linhas e estilos nele.  E para exibir apenas alguns testes, porque  sempre redesenha as linhas alteradas. </p><br><p>  Uma vantagem importante √© tamb√©m uma certa pregui√ßa da tela.  Se em um peda√ßo de texto sobrescrevermos a mesma linha (por exemplo, barra de progresso), depois que o modelo funcionar, para exibi√ß√£o, ele parecer√° com uma linha alterada. </p><br><h4 id="dom-vs-canvas">  DOM vs Canvas </h4><br><p>  Eu gostaria de pensar um pouco sobre por que escolhi o DOM, embora o objetivo fosse desempenho.  A resposta √© simples - pregui√ßa.  Para mim, renderizar tudo no Canvas sozinho parece uma tarefa bastante assustadora.  Mantendo a usabilidade: real√ßar, copiar, redimensionar a tela, parecer elegante, etc.  O exemplo do xterm.js me mostrou claramente que isso n√£o √© nada f√°cil.  Sua renderiza√ß√£o em tela estava longe de ser ideal. </p><br><p>  Al√©m disso, a depura√ß√£o da √°rvore DOM no navegador e a capacidade de cobrir testes de unidade s√£o uma vantagem importante. </p><br><p>  No final, meu objetivo era 50 mil linhas e eu sabia que o DOM tinha que lidar com isso, com base no trabalho do antigo algoritmo. </p><br><h2 id="optimizacii">  Otimiza√ß√µes </h2><br><p>  O algoritmo estava pronto, depurado e lenta mas seguramente funcionou.  Estava na hora de abrir o criador de perfil e otimizar.  Olhando para o futuro, direi que a maioria das otimiza√ß√µes foi uma surpresa para mim (como geralmente acontece). </p><br><p>  A cria√ß√£o de perfil foi realizada em 10 mil linhas, cada uma contendo elementos estilizados.  O n√∫mero total de elementos DOM √© de cerca de 100k. </p><br><p>  Nenhuma abordagem e ferramentas especiais foram usadas.  Somente o Chrome Dev Tools e algumas ativa√ß√µes para cada medi√ß√£o.  Na pr√°tica, apenas os valores absolutos de medi√ß√£o (quantos segundos para concluir) diferiam nos lan√ßamentos, mas n√£o uma propor√ß√£o percentual entre os m√©todos.  Portanto, considero essa t√©cnica condicionalmente suficiente. </p><br><p>  Abaixo, gostaria de abordar com mais detalhes as melhorias mais interessantes.  E, para come√ßar, um gr√°fico do que era: <br><img src="https://habrastorage.org/webt/me/xk/ot/mexkotdhezc4pwxhw4xczkzv9ie.png"></p><br><p>  <em>Todos os gr√°ficos de cria√ß√£o de perfil foram criados ap√≥s a implementa√ß√£o, otimizando o c√≥digo da mem√≥ria.</em> </p><br><h4 id="stringtrim">  string.trim </h4><br><p>  Primeiro de tudo, me deparei com uma string.trim incompreens√≠vel que consumia uma quantidade muito percept√≠vel de CPU (parece-me que isso era de 10 a 20%) <br><img src="https://habrastorage.org/webt/ue/nq/6b/uenq6brmlm8fxzxxjklulp7ccly.png"></p><br><p>  trim () √© a fun√ß√£o b√°sica do idioma.  Por que est√° usando algum tipo de biblioteca?  E mesmo que seja algum tipo de polyfill, por que ativou a vers√£o mais recente do chrome? </p><br><p> Um pouco de pesquisa e a resposta √© encontrada: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://babeljs.io/docs/en/babel-preset-env</a> .  Por padr√£o, ele habilita o polyfill para um n√∫mero bastante grande de navegadores e faz isso no est√°gio de compila√ß√£o.  A solu√ß√£o para mim foi especificar <code>'targets': '&gt; 0.25%, not dead'</code> <br>  Mas, no final, exclu√≠ a chamada de corte completamente, como desnecess√°ria. </p><br><h4 id="vuejs">  Vue.js </h4><br><p>  No ano passado, transferi o componente terminal para o Vue.js.  Agora eu tive que transferi-lo de volta para baunilha, o motivo est√° na captura de tela abaixo (veja o n√∫mero de linhas envolvendo o Vue.js): </p><br><p><img src="https://habrastorage.org/webt/ll/oq/i8/lloqi8k2igkme2q616eooswyogg.png"></p><br><p>  Deixei apenas wrapper, estilos e processamento de mouse no componente Vue.  Tudo o que se refere √† cria√ß√£o de elementos DOM foi para JS puro, que √© conectado ao componente Vue como um campo normal (que n√£o √© monitorado pela estrutura). </p><br><pre> <code class="plaintext hljs">created() { this.terminalModel = new TerminalModel(); this.terminal = new Terminal(this.terminalModel); },</code> </pre> <br><p>  Eu n√£o considero isso um sinal de menos ou uma falha no Vue.js.  S√≥ que estruturas e desempenho em si n√£o se misturam bem.  Bem, quando voc√™ coloca dezenas e centenas de milhares de objetos em uma estrutura reativa, √© muito dif√≠cil esperar o processamento dentro de alguns milissegundos.  E, para ser sincero, fico surpreso que o Vue.js tenha se sa√≠do muito bem. </p><br><h4 id="dobavlenie-novyh-elementov">  Adicionando novos itens </h4><br><p>  Tudo √© simples aqui - se voc√™ possui v√°rios milhares de novos elementos e deseja adicion√°-los ao componente pai, fazer appendChild n√£o √© uma boa ideia.  O navegador precisa fazer o processamento um pouco mais frequentemente e gastar mais tempo na renderiza√ß√£o.  Um dos efeitos colaterais no meu caso foi uma desacelera√ß√£o na rolagem autom√°tica, pois  for√ßa uma recontagem de todos os componentes adicionados. </p><br><p><img src="https://habrastorage.org/webt/v_/5k/uj/v_5kujs_plen-j5zoxhq0ixv9um.png"></p><br><p>  Para resolver o problema, existe um DocumentFragment.  Primeiro, adicionamos todos os elementos a ele e depois ao componente pai.  O navegador cuidar√° da linha dos componentes recebidos. </p><br><p>  Essa abordagem reduz a quantidade de tempo que o navegador gasta na renderiza√ß√£o e organiza√ß√£o dos elementos. <br>  Eu tamb√©m tentei outras maneiras de acelerar a adi√ß√£o de itens.  Nenhum deles poderia adicionar nada sobre o DocumentFragment. </p><br><h4 id="span-vs-div">  span vs div </h4><br><p>  De fato, isso poderia ser chamado de <code>display:inline</code> (span) vs <code>display:block</code> (div). </p><br><p>  Inicialmente, eu tinha todas as linhas no intervalo e terminei com um caractere de quebra de linha.  No entanto, em termos de desempenho, isso n√£o √© muito eficaz: o navegador precisa descobrir onde o elemento come√ßa e termina.  Com display: block, esses c√°lculos s√£o muito mais simples. </p><br><p>  A substitui√ß√£o por uma renderiza√ß√£o acelerada por div quase duas vezes. </p><br><p>  Infelizmente, no caso de <code>display:block</code> destacar v√°rias linhas de texto parece pior: </p><br><p><img src="https://habrastorage.org/webt/dm/kj/nq/dmkjnq9up61pc-ic0jalnfi3jw8.png"></p><br><p>  Durante muito tempo, n√£o pude decidir qual √© o melhor - mais 2 segundos de renderiza√ß√£o ou sele√ß√£o humana.  Como resultado, a praticidade derrotou a beleza. </p><br><h4 id="master-css-10-go-urovnya">  Assistente CSS de n√≠vel 10 </h4><br><p>  Outros ~ 10% do tempo de renderiza√ß√£o foram cortados pela "otimiza√ß√£o" do CSS, que eu uso para formatar o texto. </p><br><p>  Inexperi√™ncia no desenvolvimento web e compreens√£o do b√°sico jogado contra mim.  Eu pensei que quanto mais precisos os seletores, melhor, mas especificamente no meu caso, n√£o era assim. </p><br><p>  Para formatar o texto no terminal, usei os seguintes seletores: </p><br><pre> <code class="plaintext hljs">#script-panel-container .log-content &gt; div &gt; span.text_color_green,</code> </pre> <br><p>  Mas (no chrome), a seguinte op√ß√£o √© um pouco mais r√°pida: </p><br><pre> <code class="plaintext hljs">span.text_color_green</code> </pre> <br><p>  Eu realmente n√£o gosto desse seletor, porque  global demais, mas o desempenho √© mais caro. </p><br><h4 id="stringsplit">  string.split </h4><br><p>  Se voc√™ tem um d√©j√† vu devido a um dos pontos anteriores, √© falso.  Desta vez, n√£o se trata de polyfill, mas da implementa√ß√£o padr√£o no chrome: </p><br><p><img src="https://habrastorage.org/webt/i8/jk/lh/i8jklht2lc0hhc9h6p1la3zuk6o.png"></p><br><p>  <em>(Embrulhei string.split em defSplit para que a fun√ß√£o apare√ßa no criador de perfil)</em> </p><br><p>  1% s√£o triviais.  Mas o ciclista idealista em mim foi assombrado.  No meu caso, a divis√£o √© sempre feita um caractere de cada vez e sem regulares.  Portanto, implementei uma op√ß√£o simples.  Aqui est√° o resultado: </p><br><p><img src="https://habrastorage.org/webt/hu/fd/_r/hufd_rbij0khcfqcudcnpfkjisa.png"></p><br><div class="spoiler">  <b class="spoiler_title">fastSplit</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">function fastSplit(str, separatorChar) { if (str === '') { return ['']; } let result = []; let lastIndex = 0; for (let i = 0; i &lt; str.length; i++) { const char = str[i]; if (char === separatorChar) { const chunk = str.substr(lastIndex, i - lastIndex); lastIndex = i + 1; result.push(chunk); } } if (lastIndex &lt; str.length) { const lastChunk = str.substr(lastIndex, str.length - lastIndex); result.push(lastChunk); } return result; }</code> </pre> </div></div><br><p>  Acredito que, depois disso, eles sejam obrigados a me levar √† equipe do Google Chrome sem uma entrevista. </p><br><h4 id="optimizaciya-posleslovie">  Otimiza√ß√£o, posf√°cio </h4><br><p>  A otimiza√ß√£o √© um processo sem fim e algo pode ser melhorado indefinidamente.  Especialmente considerando que diferentes casos de uso requerem otimiza√ß√µes diferentes (e conflitantes). </p><br><p>  No meu caso, escolhi o caso de uso principal e otimizei o tempo de opera√ß√£o de 15 segundos para 5 segundos.  Por isso, decidi parar. <br><img src="https://habrastorage.org/webt/ol/ri/j3/olrij3u8nfgpdrbm5-0db4vkpra.png"></p><br><p>  Ainda pretendo melhorar alguns lugares, mas isso se deve √† experi√™ncia adquirida. </p><br><h2 id="bonus-mutacionnoe-testirovanie">  B√¥nus  Teste de muta√ß√£o. </h2><br><p>  Aconteceu que, nos √∫ltimos meses, encontrei frequentemente o termo "teste mutacional".  E eu decidi que esta tarefa √© uma √≥tima maneira de experimentar esta fera.  Especialmente depois que n√£o recebi cobertura de c√≥digo no Webstorm, para testes de carma. </p><br><p>  Como a t√©cnica e a biblioteca s√£o novas para mim, decidi me dar bem com um pouco de sangue: testar apenas um componente - o modelo.  Nesse caso, voc√™ pode indicar claramente qual arquivo estamos testando e qual su√≠te de teste se destina a ele. </p><br><p>  Mas o que quer que se possa dizer, eu tive que mexer muito para conseguir a integra√ß√£o com o karma e o webpack. </p><br><p>  No final, tudo come√ßou e depois de meia hora eu vi resultados tristes: cerca de metade dos mutantes sobreviveram.  Eu matei parte imediatamente, parte deixada para o futuro (quando implementei os comandos ANSI ausentes). </p><br><p>  Depois disso, a pregui√ßa venceu e, no momento, os resultados s√£o os seguintes (para 128 testes): </p><br><pre> <code class="plaintext hljs">Ran 79.04 tests per mutant on average. ------------------|---------|----------|-----------|------------|---------| File | % score | # killed | # timeout | # survived | # error | ------------------|---------|----------|-----------|------------|---------| terminal_model.js | 73.10 | 312 | 25 | 124 | 1 | ------------------|---------|----------|-----------|------------|---------| 23:01:08 (18212) INFO Stryker Done in 26 minutes 32 seconds.</code> </pre> <br><p>  Em geral, essa abordagem me pareceu muito √∫til (obviamente melhor que a cobertura de c√≥digo) e engra√ßada.  O √∫nico aspecto negativo √© um tempo terrivelmente longo - 30 minutos por aula √© demais. </p><br><p>  E o mais importante, essa abordagem me fez pensar novamente em 100% de cobertura e se vale a pena cobrir tudo com testes: agora minha opini√£o est√° ainda mais pr√≥xima de "sim" ao responder a essa pergunta. </p><br><h2 id="zaklyuchenie">  Conclus√£o </h2><br><p>  A otimiza√ß√£o de desempenho, na minha opini√£o, √© uma boa maneira de aprender algo mais profundo.  Tamb√©m √© um bom treino para o c√©rebro.  E √© uma pena que isso raramente seja realmente necess√°rio (pelo menos nos meus projetos). </p><br><p>  E, como sempre, a abordagem de ‚Äúprimeiro perfil e depois otimiza√ß√£o‚Äù funciona muito melhor do que a intui√ß√£o. </p><br><h4 id="ssylki">  Refer√™ncias </h4><br><p>  Implementa√ß√£o antiga: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">terminal_formatter.py</a> </li><li>  <a href="">log_panel.vue</a> </li></ul><br><p>  Nova implementa√ß√£o: </p><br><ul><li>  <a href="">terminal_model.js</a> </li><li>  <a href="">terminal_view.js</a> </li></ul><br><p>  Infelizmente, n√£o h√° demonstra√ß√£o de componentes da web, ent√£o voc√™ n√£o poder√° cutuc√°-la.  Ent√£o pe√ßo desculpas antecipadamente </p><br><p>  Obrigado pelo seu tempo, terei prazer em coment√°rios, sugest√µes e cr√≠ticas razo√°veis! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt448030/">https://habr.com/ru/post/pt448030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt448016/index.html">An√°lise cl√≠nica da urina em casa em tiras de teste: pr√≥s e contras</a></li>
<li><a href="../pt448018/index.html">Eventos digitais em Moscou, de 15 a 21 de abril</a></li>
<li><a href="../pt448022/index.html">Compilador angular de 200 linhas</a></li>
<li><a href="../pt448024/index.html">Reguladores europeus se op√µem a banners de cookies</a></li>
<li><a href="../pt448026/index.html">Projeto de Software e Evolu√ß√£o OOP</a></li>
<li><a href="../pt448032/index.html">Mais rob√¥s: o Walmart apresenta milhares de m√°quinas para operar em suas lojas</a></li>
<li><a href="../pt448034/index.html">Procure tarefas no JIRA (linguagem simples). Parte 1: Pesquisa r√°pida e b√°sica</a></li>
<li><a href="../pt448036/index.html">Importar para J. Connect do arquivo da lista de usu√°rios via API</a></li>
<li><a href="../pt448038/index.html">Novos recursos para autores de extens√£o no Visual Studio 2019 v.16.1</a></li>
<li><a href="../pt448040/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel # 294 (de 8 a 14 de abril)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>