<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❕ 🆘 🤽🏾 Usando a função connect () do react-redux 🚹 👏🏽 🧐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O artigo que estamos traduzindo hoje discutirá como criar componentes de contêiner em aplicativos React relacionados ao estado do Redux. Este material...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Usando a função connect () do react-redux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/423157/">  O artigo que estamos traduzindo hoje discutirá como criar componentes de contêiner em aplicativos React relacionados ao estado do Redux.  Este material é baseado na descrição do mecanismo de gerenciamento de estado no React usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pacote react-redux</a> .  Supõe-se que você já tenha um entendimento básico da arquitetura e API das bibliotecas sobre as quais falaremos.  Se não for esse o caso, consulte a documentação <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">React</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Redux</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/35f/0eb/fea/35f0ebfea2178696cb95ede9f78407c9.jpg" alt="imagem"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Sobre gerenciamento de estado em aplicativos JavaScript</font> </h2><br>  O React fornece ao desenvolvedor dois mecanismos principais para transferir dados para componentes.  Estas são propriedades (adereços) e estado.  As propriedades são somente leitura e permitem que os componentes pai transmitam atributos aos componentes filhos.  Um estado é uma entidade local encapsulada dentro de um componente que pode mudar a qualquer momento no ciclo de vida do componente. <br><br>  Como o estado é um mecanismo extremamente útil usado para criar poderosos aplicativos dinâmicos do React, é necessário gerenciá-lo adequadamente.  Atualmente, existem várias bibliotecas que fornecem uma arquitetura bem estruturada para gerenciar a integridade do aplicativo.  Entre eles estão o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Flux</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Redux</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MobX</a> . <br><br>  Redux é uma biblioteca projetada para criar contêineres usados ​​para armazenar o estado do aplicativo.  Ele oferece ao desenvolvedor ferramentas de gerenciamento de estado compreensíveis que se comportam de maneira previsível.  Essa biblioteca é adequada para aplicativos escritos em JavaScript puro, bem como para projetos no desenvolvimento dos quais algumas estruturas foram usadas.  Redux é pequeno, mas permite escrever aplicativos confiáveis ​​que funcionam em diferentes ambientes. <br><br>  Veja como criar repositórios Redux: <br><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createStore } from <span class="hljs-string"><span class="hljs-string">'redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initialState = {    auth: { loggedIn: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = createStore((state = initialState, action) =&gt; {    switch (action.type) {        case <span class="hljs-string"><span class="hljs-string">"LOG_IN"</span></span>:            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, auth: { loggedIn: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } };            <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;        case <span class="hljs-string"><span class="hljs-string">"LOG_OUT"</span></span>:            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, auth: { loggedIn: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } };            <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;        <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>:            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state;            <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;    }    })</code> </pre> <br><h2>  <font color="#3AC1EF">Pacote React-redux</font> </h2><br>  O pacote react-redux fornece ligações React para o contêiner de estado Redux, tornando extremamente fácil conectar o aplicativo React ao repositório Redux.  Isso permite que você separe os componentes de um aplicativo React com base no relacionamento deles com o repositório.  Ou seja, estamos falando dos seguintes tipos de componentes: <br><br><ol><li>  Componentes de apresentação.  Eles são responsáveis ​​apenas pela aparência do aplicativo e não têm conhecimento do estado do Redux.  Eles recebem dados através de propriedades e podem chamar retornos de chamada, que também são transmitidos a eles através de propriedades. </li><li>  Componentes do contêiner.  Eles são responsáveis ​​pela operação dos mecanismos internos do aplicativo e interagem com o estado do Redux.  Eles geralmente são criados usando o react-redux, eles podem despachar ações do Redux.  Além disso, eles assinam alterações de estado. </li></ol><br>  Detalhes sobre essa abordagem da divisão de responsabilidade dos componentes podem ser encontrados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Neste artigo, falaremos principalmente sobre componentes de contêiner conectados ao estado Redux usando react-redux. <br><br>  O pacote react-redux tem uma interface muito simples.  Em particular, o mais interessante dessa interface se resume ao seguinte: <br><br><ol><li>  <code>&lt;Provider store&gt;</code> - permite criar um wrapper para um aplicativo React e disponibilizar o estado Redux para todos os componentes do contêiner em sua hierarquia. </li><li>  <code>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</code> - permite criar componentes de ordem superior.  Isso é necessário para criar componentes de contêiner com base nos componentes básicos do React. </li></ol><br>  Instale o react-redux para usar este pacote no projeto da seguinte maneira: <br><br><pre> <code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> react-redux <span class="hljs-comment"><span class="hljs-comment">--save</span></span></code> </pre> <br>  Com base na suposição de que você já configurou o repositório Redux para seu aplicativo React, aqui está um exemplo de conexão do aplicativo ao repositório Redux: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-dom'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Provider } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> createStore <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./createReduxStore'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = createStore(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rootElement = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'root'</span></span>); ReactDOM.render(( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">store</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">AppRootComponent</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ), rootElement);</code> </pre> <br>  Agora você pode criar componentes de contêiner que estão conectados ao repositório Redux.  Isso é feito dentro da hierarquia do <code>AppRootComponent</code> usando a API <code>connect()</code> . <br><br><h2>  <font color="#3AC1EF">Quando usar o connect ()?</font> </h2><br><h3>  <font color="#3AC1EF">Criando componentes de contêiner</font> </h3><br>  Como já mencionado, a API react-redux <code>connect()</code> é usada para criar componentes de contêiner que estão conectados ao repositório Redux.  O armazenamento ao qual você está se conectando é obtido do ancestral mais alto do componente usando o mecanismo de contexto React.  A função <code>connect()</code> não será necessária se você criar apenas componentes de apresentação. <br><br>  Se você, no componente React, precisar receber dados do armazenamento, despachar ações ou executar as duas ações, poderá converter um componente regular em um componente de contêiner, envolvendo-o em um componente de ordem superior retornado por <code>connect()</code> de reagir-redux.  Aqui está o que parece: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Profile <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./components/Profile'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> ProfileContainer(props) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   props.loggedIn     ? &lt;Profile profile={props.profile} /&gt;     : &lt;div&gt;Please <span class="hljs-keyword"><span class="hljs-keyword">login</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> profile.&lt;/div&gt; ) } const mapStateToProps = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(state) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   profile: state.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.profile,   loggedIn: state.auth.loggedIn } } export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(mapStateToProps)(ProfileContainer);</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Eliminando a necessidade de assinar manualmente o armazenamento Redux</font> </h3><br>  Você pode criar o componente do contêiner e assinar manualmente o componente no repositório Redux usando o comando <code>store.subscribe()</code> .  No entanto, usar a função <code>connect()</code> significa aplicar algumas melhorias e otimizações de desempenho que talvez você não consiga usar ao usar outros mecanismos. <br><br>  No exemplo a seguir, tentamos criar manualmente um componente de contêiner e conectá-lo ao repositório Redux, assinando-o.  Aqui nos esforçamos para implementar a mesma funcionalidade, como mostrado no exemplo anterior. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { Component } from <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> store from <span class="hljs-string"><span class="hljs-string">'./reduxStore'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Profile from <span class="hljs-string"><span class="hljs-string">'./components/Profile'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfileContainer</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ state = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getCurrentStateFromStore() getCurrentStateFromStore() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {     profile: store.getState().user.profile,     loggedIn: store.getState().auth.loggedIn   } } updateStateFromStore = () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> currentState = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getCurrentStateFromStore();     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state !== currentState) {     <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState(currentState);   } } componentDidMount() {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unsubscribeStore = store.subscribe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.updateStateFromStore); } componentWillUnmount() {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unsubscribeStore(); } render() {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { loggedIn, profile } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state;     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     loggedIn       ? &lt;Profile profile={profile} /&gt;       : &lt;div&gt;Please login to view profile.&lt;/div&gt;   ) } } export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> ProfileContainer;</code> </pre> <br>  A função <code>connect()</code> , além disso, oferece ao desenvolvedor flexibilidade adicional, permitindo configurar componentes de contêiner para receber propriedades dinâmicas com base nas propriedades que foram originalmente passadas para eles.  Isso acaba sendo muito útil para obter seleções de um estado com base em propriedades ou para vincular geradores de ação a uma variável específica das propriedades. <br><br>  Se seu aplicativo React usar vários repositórios Redux, o <code>connect()</code> facilita a especificação do repositório específico ao qual o componente do contêiner deve ser conectado. <br><br><h2>  <font color="#3AC1EF">Anatomia connect ()</font> </h2><br>  A função <code>connect()</code> fornecida pelo pacote react-redux pode levar até quatro argumentos, cada um dos quais é opcional.  Após chamar a função <code>connect()</code> , é retornado um componente de ordem superior que pode ser usado para quebrar qualquer componente React. <br><br>  Como a função retorna um componente de ordem superior, ela precisa ser chamada novamente, passando o componente React básico para convertê-lo em um componente de contêiner: <br><br><pre> <code class="hljs lisp">const ContainerComponent = connect()(<span class="hljs-name"><span class="hljs-name">BaseComponent</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Aqui está a assinatura da função <code>connect()</code> : <br><br><pre> <code class="hljs powershell">connect([<span class="hljs-type"><span class="hljs-type">mapStateToProps</span></span>], [<span class="hljs-type"><span class="hljs-type">mapDispatchToProps</span></span>], [<span class="hljs-type"><span class="hljs-type">mergeProps</span></span>], [<span class="hljs-type"><span class="hljs-type">options</span></span>])</code> </pre> <br><h3>  <font color="#3AC1EF">Argument argumento mapStateToProps</font> </h3><br>  O argumento <code>mapStateToProps</code> é uma função que retorna um objeto regular ou outra função.  Passar esse argumento <code>connect()</code> inscreve o componente do contêiner nas atualizações do repositório Redux.  Isso significa que a função <code>mapStateToProps</code> será chamada sempre que o estado do repositório for alterado.  Se você não estiver interessado em monitorar atualizações de status, passe <code>connect()</code> como o valor desse argumento para <code>undefined</code> ou <code>null</code> . <br><br>  A função <code>mapStateToProps</code> declarada com dois parâmetros, o segundo dos quais é opcional.  O primeiro parâmetro é o estado atual do repositório Redux.  O segundo parâmetro, se passado, é um objeto das propriedades passadas para o componente: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   <span class="hljs-attr"><span class="hljs-attr">profile</span></span>: state.user.profile,   <span class="hljs-attr"><span class="hljs-attr">loggedIn</span></span>: state.auth.loggedIn } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> connect(mapStateToProps)(ProfileComponent);</code> </pre> <br>  Se um objeto regular for retornado de <code>mapStateToProps</code> , o objeto <code>stateProps</code> retornado <code>stateProps</code> combinado com as propriedades do componente.  Você pode acessar essas propriedades no componente da seguinte maneira: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfileComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   props.loggedIn     ? <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Profile</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">profile</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{props.profile}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">     : </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Please login to view profile.</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ) }</span></span></code> </pre> <br>  Se <code>mapStateToProps</code> retornar uma função, essa função será usada como <code>mapStateToProps</code> para cada instância do componente.  Isso pode ser útil para melhorar o desempenho da renderização e memorizar. <br><br><h3>  <font color="#3AC1EF">Argument argumento mapDispatchToProps</font> </h3><br>  O argumento <code>mapDispatchToProps</code> pode ser um objeto ou uma função que retorna um objeto regular ou outra função.  Para ilustrar melhor o <code>mapDispatchToProps</code> , precisamos de geradores de ação.  Suponha que tenhamos os seguintes geradores: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> writeComment = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">comment</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ comment, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'WRITE_COMMENT'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> updateComment = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id, comment</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ id, comment, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'UPDATE_COMMENT'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> deleteComment = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ id, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'DELETE_COMMENT'</span></span> });</code> </pre> <br>  Agora considere os vários usos do <code>mapDispatchToProps</code> . <br><br><h4>  Implementação padrão padrão </h4><br>  Se você não usar sua própria implementação <code>mapDispatchToProps</code> , representada por um objeto ou função, será usada uma implementação padrão, que implementará o método de repositório <code>dispatch()</code> como uma propriedade do componente.  Você pode usar esta propriedade em um componente como este: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { updateComment, deleteComment } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./actions'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>(props) { const { id, content } = props.<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>; //    props.dispatch() const editComment = () =&gt; props.dispatch(updateComment(id, content)); const removeComment = () =&gt; props.dispatch(deleteComment(id)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   &lt;div&gt;     &lt;p&gt;{ content }&lt;/p&gt;     &lt;button <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="button" onClick={editComment}&gt;Edit <span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>&lt;/button&gt;     &lt;button <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="button" onClick={removeComment}&gt;Remove <span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>&lt;/button&gt;   &lt;/div&gt; ) } export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>()(<span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>);</code> </pre> <br><h4>  Transferência de objeto </h4><br>  Se um objeto for usado como argumento para <code>mapDispatchToProps</code> , cada função no objeto será tomada como um gerador de ação Redux e envolvida em uma chamada de método de repositório <code>dispatch()</code> , que permitirá que ele seja chamado diretamente.  O objeto resultante com geradores de ação, <code>dispatchProps</code> , será combinado com as propriedades do componente. <br><br>  O exemplo a seguir mostra um exemplo de construção do argumento <code>mapDispatchToProps</code> , que é um objeto com geradores de ação, além de como os geradores podem ser usados ​​como propriedades do componente React: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { updateComment, deleteComment } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./actions'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>(props) { const { id, content } = props.<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>; // ,   ,   const editComment = () =&gt; props.updatePostComment(id, content); const removeComment = () =&gt; props.deletePostComment(id); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   &lt;div&gt;     &lt;p&gt;{ content }&lt;/p&gt;     &lt;button <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="button" onClick={editComment}&gt;Edit <span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>&lt;/button&gt;     &lt;button <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="button" onClick={removeComment}&gt;Remove <span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>&lt;/button&gt;   &lt;/div&gt; ) } //     const mapDispatchToProps = { updatePostComment: updateComment, deletePostComment: deleteComment } export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, mapDispatchToProps)(<span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>);</code> </pre> <br><h4>  Transferência de função </h4><br>  Ao usar a função <code>mapDispatchToProps</code> como argumento <code>mapDispatchToProps</code> o programador deve cuidar do retorno do objeto <code>dispatchProps</code> , que implementa a ligação dos geradores de ação usando o método de armazenamento <code>dispatch()</code> .  Esta função aceita, como primeiro parâmetro, o método de repositório <code>dispatch()</code> .  Assim como no <code>mapStateToProps</code> , a função também pode aceitar o segundo parâmetro opcional <code>ownProps</code> , que descreve o mapeamento com as propriedades originais passadas para o componente. <br><br>  Se essa função retornar outra função, a função retornada será usada como <code>mapDispatchToProps</code> , que pode ser útil para melhorar o desempenho da renderização e a memorização. <br><br>  A função auxiliar <code>bindActionCreators()</code> do Redux pode ser usada dentro desta função para vincular geradores de ação ao método de repositório <code>dispatch()</code> . <br><br>  O exemplo a seguir mostra o uso, na função de <code>mapDispatchToProps</code> , de uma função.  Também demonstra o trabalho com a função auxiliar <code>bindActionCreators()</code> , usada para ligar geradores de ação para trabalhar com comentários sobre os <code>props.actions</code> do componente React: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { bindActionCreators } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> commentActions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./actions'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>(props) { const { id, content } = props.<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>; const { updateComment, deleteComment } = props.actions; //    props.actions const editComment = () =&gt; updateComment(id, content); const removeComment = () =&gt; deleteComment(id); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   &lt;div&gt;     &lt;p&gt;{ content }&lt;/p&gt;     &lt;button <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="button" onClick={editComment}&gt;Edit <span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>&lt;/button&gt;     &lt;button <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="button" onClick={removeComment}&gt;Remove <span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>&lt;/button&gt;   &lt;/div&gt; ) } const mapDispatchToProps = (dispatch) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   actions: bindActionCreators(commentActions, dispatch) } } export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, mapDispatchToProps)(<span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>);</code> </pre> <br><h3>  <font color="#3AC1EF">MerArgument mergeProps</font> </h3><br>  Se o argumento <code>mergeProps</code> for passado para <code>connect()</code> , é uma função que aceita os três parâmetros a seguir: <br><br><ul><li>  <code>stateProps</code> é o objeto de propriedade retornado da chamada <code>mapStateToProps()</code> . </li><li>  <code>dispatchProps</code> - um objeto de propriedade com geradores de ação de <code>mapDispatchToProps()</code> . </li><li>  <code>ownProps</code> - As propriedades originais obtidas pelo componente. </li></ul><br>  Esta função retorna um objeto simples com propriedades que serão passadas para o componente agrupado.  Isso é útil para mapear condicionalmente parte do estado de um repositório Redux ou geradores de ação baseados em propriedades. <br><br>  Se <code>connect()</code> não passar nesta função, sua implementação padrão será usada: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mergeProps = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stateProps, dispatchProps, ownProps</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, ownProps, stateProps, dispatchProps) }</code> </pre> <br><h3>  <font color="#3AC1EF">RepresentingArgumento representando um objeto com parâmetros</font> </h3><br>  Um objeto opcional, passado para a função <code>connect()</code> como o quarto argumento, contém parâmetros projetados para alterar o comportamento dessa função.  Portanto, <code>connect()</code> é uma implementação especial da função <code>connectAdvanced()</code> , que aceita a maioria dos parâmetros disponíveis para <code>connectAdvanced()</code> , além de alguns parâmetros adicionais. <br><br>  <a href="">Aqui está a</a> página <a href="">da</a> documentação, após a leitura, que você pode descobrir quais parâmetros podem ser usados ​​com o <code>connect()</code> e como eles modificam o comportamento dessa função. <br><br><h2>  <font color="#3AC1EF">Usando a função connect ()</font> </h2><br><h3>  <font color="#3AC1EF">▍Criar armazenamento</font> </h3><br>  Antes de converter um componente React regular em um componente de contêiner usando <code>connect()</code> , você precisa criar um repositório Redux ao qual esse componente será conectado. <br><br>  Suponha que tenhamos um componente de contêiner <code>NewComment</code> , que é usado para adicionar novos comentários à publicação e, além disso, exibe um botão para enviar comentários.  O código que descreve esse componente pode ser assim: <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">React</span></span> from <span class="hljs-symbol"><span class="hljs-symbol">'reac</span></span>t'; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { connect } from <span class="hljs-symbol"><span class="hljs-symbol">'react</span></span>-redux'; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewComment</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ input = <span class="hljs-literal"><span class="hljs-literal">null</span></span> writeComment = evt =&gt; {   evt.preventDefault();   const comment = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.input.value;     comment &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.dispatch({ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>: <span class="hljs-symbol"><span class="hljs-symbol">'WRITE_COMMEN</span></span>T', comment }); } render() {   const { id, content } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.comment;     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       &lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> ref={e =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.input = e} placeholder=<span class="hljs-string"><span class="hljs-string">"Write a comment"</span></span> /&gt;       &lt;button <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"button"</span></span> onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writeComment}&gt;<span class="hljs-type"><span class="hljs-type">Submit</span></span> <span class="hljs-type"><span class="hljs-type">Comment</span></span>&lt;/button&gt;     &lt;/div&gt;   ) } } export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> connect()(<span class="hljs-type"><span class="hljs-type">NewComment</span></span>);</code> </pre> <br>  Para que este componente seja usado no aplicativo, será necessário descrever o repositório Redux ao qual esse componente deve estar conectado.  Caso contrário, ocorrerá um erro.  Isso pode ser feito de duas maneiras, que consideraremos agora. <br><br><h4>  Configurando a propriedade da loja em um componente de contêiner </h4><br>  A primeira maneira de equipar um componente com um repositório Redux é passar um link para um repositório como o valor da propriedade de <code>store</code> do componente: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> store <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./reduxStore'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> NewComment <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./components/NewComment'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CommentsApp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">NewComment</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">store</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> }</span></span></code> </pre> <br><h4>  Definindo a propriedade da loja no componente &lt;Provider&gt; </h4><br>  Se você deseja configurar o repositório Redux para o aplicativo apenas uma vez, estará interessado no método que consideraremos agora.  Geralmente é adequado para aplicativos que usam apenas um repositório Redux. <br><br>  O pacote react-redux fornece ao desenvolvedor o componente <code>&lt;Provider&gt;</code> , que pode ser usado para agrupar o componente raiz do aplicativo.  Aceita a propriedade da <code>store</code> .  Supõe-se que seja um link para o repositório Redux, que está planejado para ser usado no aplicativo.  A propriedade <code>store</code> é passada, de acordo com a hierarquia do aplicativo, para os componentes do contêiner, usando o mecanismo de contexto React: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-dom'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> store <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./reduxStore'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Provider } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> NewComment <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./components/NewComment'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CommentsApp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">NewComment</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> } ReactDOM.render(( </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">store</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">CommentsApp</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ), document.getElementById('root'))</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">OrganizationOpenProps Access Organization</font> </h3><br>  Como já mencionado, as funções <code>mapDispatchToProps</code> e <code>mapDispatchToProps</code> <code>mapStateToProps</code> para <code>connect()</code> podem ser declaradas com o segundo parâmetro <code>ownProps</code> , que é as propriedades do componente. <br>  No entanto, há um problema.  Se o número de parâmetros necessários da função declarada for menor que 2, o <code>ownProps</code> não será transmitido.  Mas se uma função for declarada sem parâmetros obrigatórios ou com pelo menos 2 parâmetros, <code>ownProps</code> será passado. <br><br>  Considere várias opções para trabalhar com <code>ownProps</code> . <br><br><h4>  Declaração de função sem parâmetros </h4><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// state console.log(arguments[1]); // ownProps };</span></span></code> </pre> <br>  Nessa situação, <code>ownProps</code> passado, pois a função é declarada sem os parâmetros necessários.  Como resultado, o seguinte código escrito usando a nova sintaxe para os demais parâmetros ES6 funcionará: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...args</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ console.log(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// state console.log(args[1]); // ownProps };</span></span></code> </pre> <br><h4>  Declaração de função com um parâmetro </h4><br>  Considere o seguinte exemplo: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(state); <span class="hljs-comment"><span class="hljs-comment">// state console.log(arguments[1]); // undefined };</span></span></code> </pre> <br>  Existe apenas um parâmetro, <code>state</code> .  Como resultado, os <code>arguments[1]</code> assumem o valor <code>undefined</code> devido ao fato de o <code>ownProps</code> não ser transmitido. <br><br><h4>  Declaração de função com parâmetro padrão </h4><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, ownProps = {}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(state); <span class="hljs-comment"><span class="hljs-comment">// state console.log(ownProps); // {} };</span></span></code> </pre> <br>  Existe apenas um parâmetro necessário, <code>state</code> , pois o segundo parâmetro, <code>ownProps</code> , é opcional porque possui um valor padrão.  Como resultado, como existe apenas um parâmetro necessário, <code>ownProps</code> não <code>ownProps</code> passado e o mapeamento é executado com o valor padrão que foi designado a ele, ou seja, com um objeto vazio. <br><br><h4>  Declarando uma função com dois parâmetros </h4><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, ownProps</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(state); <span class="hljs-comment"><span class="hljs-comment">// state console.log(ownProps); // ownProps };</span></span></code> </pre> <br>  Tudo é organizado de maneira muito simples.  Ou seja, nessa situação, a transferência de <code>ownProps</code> devido ao fato de a função ser declarada com dois parâmetros necessários. <br><br><h2>  <font color="#3AC1EF">Sumário</font> </h2><br>  Depois de dominar este material, você aprendeu sobre quando e como usar a API <code>connect()</code> fornecida pelo pacote react-redux e projetada para criar componentes de contêiner conectados ao estado Redux.  Aqui conversamos detalhadamente sobre a estrutura da função <code>connect()</code> e como trabalhar com ela, no entanto, se você quiser saber mais sobre esse mecanismo, em particular, se familiarizar com seus casos de uso, dê uma olhada <a href="">nesta</a> seção da documentação do react-redux. <br><br>  <b>Caros leitores!</b>  Você usa react-redux em seus projetos? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt423157/">https://habr.com/ru/post/pt423157/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt423147/index.html">Sobre a estratégia e o formato de armazenamento na era Hadoop</a></li>
<li><a href="../pt423149/index.html">Comparação direta dos métodos de correção da miopia a laser ou o que você paga ao escolher o ReLEx SMILE</a></li>
<li><a href="../pt423151/index.html">Objetos globais em PHP</a></li>
<li><a href="../pt423153/index.html">Guia do Node.js, parte 2: JavaScript, V8, alguns truques de desenvolvimento</a></li>
<li><a href="../pt423155/index.html">Curso MIT "Segurança de sistemas de computadores". Aula 8: Modelo de Segurança de Rede, Parte 2</a></li>
<li><a href="../pt423159/index.html">Feliz dia do programador! Ame seus desenvolvedores</a></li>
<li><a href="../pt423161/index.html">As empresas querem dados pessoais</a></li>
<li><a href="../pt423163/index.html">Conectando o CryptoPro ao Mono</a></li>
<li><a href="../pt423165/index.html">Desenho de malha dinâmica no Unreal Engine 4</a></li>
<li><a href="../pt423167/index.html">O que Mark Zuckerberg fala sobre questões do Facebook. Artigo essencial do The New Yorker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>