<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÖ üë©üèø‚Äç‚öïÔ∏è ‚ô•Ô∏è Application r√©active sans Redux / NgRx ‚òòÔ∏è üôéüèº üéóÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui nous analyserons en d√©tail une application angulaire r√©active ( r√©f√©rentiel github ), enti√®rement √©crite sur la strat√©gie OnPush . Une aut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Application r√©active sans Redux / NgRx</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/426819/"><img src="https://habrastorage.org/webt/d4/ck/od/d4ckodq4-ei9nntgvweinv65mdu.jpeg"><br><br>  Aujourd'hui nous analyserons en d√©tail une application angulaire r√©active ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©f√©rentiel github</a> ), enti√®rement √©crite sur la strat√©gie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OnPush</a> .  Une autre application utilise des formulaires r√©actifs, ce qui est assez typique d'une application d'entreprise. <br><br>  Nous n'utiliserons pas Flux, Redux, NgRx et profiterons plut√¥t des capacit√©s d√©j√† disponibles dans Typescript, Angular et RxJS.  Le fait est que ces outils ne sont pas une solution miracle et peuvent ajouter une complexit√© inutile m√™me aux applications simples.  Nous en sommes honn√™tement avertis par l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un des auteurs de Flux</a> , l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">auteur de Redux</a> et l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">auteur de NgRx</a> . <br><br>  Mais ces outils donnent √† nos applications de tr√®s belles fonctionnalit√©s: <br><br><ul><li>  Flux de donn√©es pr√©visible; </li><li>  Soutenez OnPush par conception; </li><li>  L'immutabilit√© des donn√©es, le manque d'effets secondaires accumul√©s et d'autres choses agr√©ables. </li></ul><br>  Nous allons essayer d'obtenir les m√™mes caract√©ristiques, mais sans introduire de complexit√© suppl√©mentaire. <br><br>  Comme vous le verrez √† la fin de l'article, c'est une t√¢che assez simple - si vous supprimez les d√©tails d'Angular et d'OnPush de l'article, il n'y a que quelques id√©es simples. <br><a name="habracut"></a><br>  L'article n'offre pas un nouveau mod√®le universel, mais partage seulement avec le lecteur plusieurs id√©es qui, pour toute sa simplicit√©, pour une raison quelconque ne sont pas imm√©diatement venues √† l'esprit.  De plus, la solution d√©velopp√©e ne contredit ni ne remplace Flux / Redux / NgRx.  Ils peuvent √™tre connect√©s, si cela est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vraiment n√©cessaire</a> . <br><br>  <i>Pour une lecture confortable de l'article, une compr√©hension des termes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">composants intelligents, de pr√©sentation et de conteneur est</a> requise.</i> <br><br><h2>  Plan d'action </h2><br>  La logique de la candidature, ainsi que la s√©quence de pr√©sentation du mat√©riel, peuvent √™tre d√©crites sous la forme des √©tapes suivantes: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Donn√©es s√©par√©es pour la lecture (GET) et l'√©criture (PUT / POST)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Charger l'√©tat sous forme de flux dans le composant conteneur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Distribuer l'√©tat √† une hi√©rarchie de composants OnPush</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Avertissez Angular des changements de composants</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√âdition de donn√©es encapsul√©es</a> </li></ol><br>  Pour impl√©menter OnPush, nous devons analyser toutes les fa√ßons d'ex√©cuter la d√©tection de changement dans Angular.  Il n'existe que quatre m√©thodes de ce type et nous les examinerons successivement tout au long de l'article. <br><br>  Alors allons-y. <br><br><a name="backend"></a><h2>  Partager des donn√©es pour la lecture et l'√©criture </h2><br>  En r√®gle g√©n√©rale, les applications frontend et backend utilisent des contrats typ√©s (sinon pourquoi dactylographi√©?). <br><br>  Le projet de d√©monstration que nous envisageons n'a pas de v√©ritable backend, mais il contient un fichier de description pr√©-pr√©par√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">swagger.json</a> .  Sur cette base, les contrats dactylographi√©s sont g√©n√©r√©s par l'utilitaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sw2dts</a> . <br><br>  Les contrats g√©n√©r√©s ont deux propri√©t√©s importantes. <br><br>  Premi√®rement, la lecture et l'√©criture sont effectu√©es √† l'aide de diff√©rents contrats.  Nous utilisons une petite convention et nous nous r√©f√©rons √† la lecture des contrats avec le suffixe ¬´State¬ª et √† la r√©daction des contrats avec le suffixe ¬´Model¬ª. <br><br>  En s√©parant les contrats de cette mani√®re, nous partageons le flux de donn√©es dans l'application.  De haut en bas, un √©tat en lecture seule est propag√© dans la hi√©rarchie des composants.  Pour modifier les donn√©es, un mod√®le est cr√©√© qui est initialement rempli avec des donn√©es d'√©tat, mais existe en tant qu'objet distinct.  √Ä la fin de l'√©dition, le mod√®le est envoy√© au backend sous forme de commande. <br><br>  Le deuxi√®me point important est que tous les champs d'√©tat sont marqu√©s avec un modificateur en lecture seule.  Nous obtenons donc un support d'immunit√© au niveau du texte.  D√©sormais, nous ne pourrons plus modifier accidentellement l'√©tat du code ni le lier √† l'aide de [(ngModel)] - lors de la compilation de l'application en mode AOT, nous obtiendrons une erreur. <br><br><a name="container"></a><h2>  Charger l'√©tat sous forme de flux dans le composant conteneur </h2><br>  Pour charger et initialiser l'√©tat, nous utiliserons des services angulaires ordinaires.  Ils seront responsables des sc√©narios suivants: <br><br><ul><li>  Un exemple classique est le chargement via HttpClient en utilisant le param√®tre id obtenu par le composant du routeur. </li><li>  Initialisation d'un √©tat vide lors de la cr√©ation d'une nouvelle entit√©.  Par exemple, si les champs ont des valeurs par d√©faut ou pour initialiser, vous devez demander des donn√©es suppl√©mentaires au backend. </li><li>  Red√©marrage d'un √©tat d√©j√† charg√© apr√®s que l'utilisateur a effectu√© une op√©ration qui modifie les donn√©es vers le backend. </li><li>  Red√©marrage de l'√©tat par notification push, par exemple lors de la co-√©dition de donn√©es.  Dans ce cas, le service fusionne l'√©tat local et l'√©tat obtenu √† partir du backend. </li></ul><br>  Dans l'application de d√©monstration, nous consid√©rerons les deux premiers sc√©narios comme les plus typiques.  De plus, ces sc√©narios sont simples et permettent au service d'√™tre impl√©ment√© comme de simples objets sans √©tat et de ne pas √™tre distrait par la complexit√©, ce qui n'est pas le sujet de cet article particulier. <br><br>  Un exemple de service se trouve dans le fichier <a href="">some-entity.service.ts</a> . <br><br>  Il reste √† obtenir le service via DI dans le composant conteneur et l'√©tat de chargement.  Cela se fait g√©n√©ralement comme ceci: <br><br><pre><code class="plaintext hljs">route.params .pipe( pluck('id'), filter((id: any) =&gt; { return !!id; }), switchMap((id: string) =&gt; { return myFormService.get(id); }) ) .subscribe(state =&gt; { this.state = state; });</code> </pre> <br>  Mais avec cette approche, deux probl√®mes se posent: <br><br><ul><li>  Vous devez vous d√©sabonner manuellement de l'abonnement cr√©√©, sinon une fuite de m√©moire se produira. </li><li>  Si vous basculez le composant vers la strat√©gie OnPush, il cessera de r√©pondre au chargement des donn√©es. </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le tuyau asynchrone</a> vient √† la rescousse.  Il √©coute directement l'Observable et se d√©sabonne de lui si n√©cessaire.  De plus, lorsque vous utilisez un canal asynchrone, Angular d√©clenche automatiquement la d√©tection de changement chaque fois que l'Observable publie une nouvelle valeur. <br><br>  Un exemple d'utilisation du canal asynchrone peut √™tre trouv√© dans le mod√®le du <a href="">composant some-entity.component</a> . <br><br>  Et dans le code du composant, nous avons supprim√© la logique r√©p√©t√©e dans les op√©rateurs RxJS personnalis√©s, ajout√© le script pour cr√©er un √©tat vide, fusionnant les deux sources d'√©tat en un seul flux avec l'op√©rateur de fusion et cr√©ant un formulaire pour l'√©dition, dont nous discuterons plus tard: <br><br><pre> <code class="plaintext hljs">this.state$ = merge( route.params.pipe( switchIfNotEmpty("id", (requestId: string) =&gt; requestService.get(requestId) ) ), route.params.pipe( switchIfEmpty("id", () =&gt; requestService.getEmptyState()) ) ).pipe( tap(state =&gt; { this.form = new SomeEntityFormGroup(state); }) );</code> </pre><br>  C'est tout ce qui devait √™tre fait dans le composant conteneur.  Et nous avons mis dans la tirelire la premi√®re fa√ßon d'appeler la d√©tection de changement dans le composant OnPush - le tuyau asynchrone.  Il nous sera utile plus d'une fois. <br><br><a name="presentation"></a><h2>  Distribuer l'√©tat √† une hi√©rarchie de composants OnPush </h2><br>  Lorsque vous devez afficher un √©tat complexe, nous cr√©ons une hi√©rarchie de petits composants - c'est ainsi que nous g√©rons la complexit√©. <br><br>  En r√®gle g√©n√©rale, les composants sont divis√©s en une hi√©rarchie similaire √† la hi√©rarchie des donn√©es, et chaque composant re√ßoit sa propre donn√©e via les param√®tres d'entr√©e pour les afficher dans le mod√®le. <br><br>  Puisque nous allons impl√©menter tous les composants en tant que OnPush, nous allons nous √©loigner un instant et discuter de ce que c'est et comment Angular fonctionne avec les composants OnPush.  Si vous connaissez d√©j√† ce mat√©riel - n'h√©sitez pas √† faire d√©filer jusqu'√† la fin de la section. <br><br>  Lors de la compilation de l'application, Angular g√©n√®re un d√©tecteur de changement de classe sp√©cial pour chaque composant, qui ¬´se souvient¬ª de toutes les liaisons utilis√©es dans le mod√®le de composant.  Au moment de l'ex√©cution, la classe g√©n√©r√©e commence √† v√©rifier les expressions stock√©es √† chaque boucle de d√©tection de changement.  Si la v√©rification a montr√© que le r√©sultat d'une expression a chang√©, Angular redessine le composant. <br><br>  Par d√©faut, Angular ne sait rien de nos composants et ne peut pas d√©terminer quels composants il affectera, par exemple, le setTimeout qui vient d'√™tre d√©clench√© ou une requ√™te AJAX qui s'est termin√©e.  Par cons√©quent, il est oblig√© de v√©rifier l'application enti√®re litt√©ralement pour chaque √©v√©nement √† l'int√©rieur de l'application - m√™me un simple d√©filement de fen√™tre d√©clenche √† plusieurs reprises la d√©tection de changement pour la hi√©rarchie enti√®re des composants de l'application. <br><br>  Ici se trouve une source potentielle de probl√®mes de performances - plus les mod√®les de composants sont complexes, plus les v√©rifications du d√©tecteur de changement sont difficiles.  Et s'il y a beaucoup de composants et que les contr√¥les sont ex√©cut√©s souvent, la d√©tection des modifications commence alors √† prendre un temps consid√©rable. <br><br>  Que faire? <br><br>  Si le composant ne d√©pend d'aucun effet global (en passant, il est pr√©f√©rable de concevoir les composants de cette mani√®re), alors son √©tat interne est d√©termin√© par: <br><br><ul><li>  Param√®tres d'entr√©e ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@Input</a> ); </li><li>  √âv√©nements qui se sont produits dans le composant lui-m√™me ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@Output</a> ). </li></ul><br>  Nous allons reporter le deuxi√®me point pour l'instant et supposons que l'√©tat de notre composant ne d√©pend que des param√®tres d'entr√©e. <br><br>  Si tous les param√®tres d'entr√©e du composant sont des objets immuables, nous pouvons marquer le composant comme OnPush.  Ensuite, avant d'ex√©cuter la d√©tection des modifications, Angular v√©rifiera si les liens vers les param√®tres d'entr√©e du composant ont chang√© depuis la v√©rification pr√©c√©dente.  Et, s'ils n'ont pas chang√©, Angular ignorera la d√©tection de changement pour le composant lui-m√™me et tous ses composants enfants. <br><br>  Ainsi, si nous construisons l'int√©gralit√© de notre application selon la strat√©gie OnPush, nous √©liminerons toute une classe de probl√®mes de performances d√®s le d√©but. <br><br>  √âtant donn√© que l'√©tat dans notre application est d√©j√† immuable, les objets immuables sont √©galement transf√©r√©s vers les param√®tres d'entr√©e des composants enfants.  Autrement dit, nous sommes pr√™ts √† activer OnPush pour les composants enfants et ils r√©agiront aux changements d'√©tat. <br>  Par exemple, il s'agit des <a href="">composants readonly</a> <a href="">-info.component</a> et <a href="">nested-items.component</a> <br><br>  Voyons maintenant comment impl√©menter la modification de l'√©tat des composants dans le paradigme OnPush. <br><br><a name="output"></a><h2>  Parlez √† Angular de votre √©tat </h2><br>  √âtat de pr√©sentation - ce sont les param√®tres qui sont responsables de l'apparence du composant: indicateurs de chargement, drapeaux de visibilit√© des √©l√©ments ou accessibilit√© √† l'utilisateur de l'une ou l'autre action, coll√©s de trois champs √† une ligne, nom complet de l'utilisateur, etc. <br><br>  Chaque fois que l'√©tat de pr√©sentation d'un composant change, nous devons en informer Angular afin qu'il puisse afficher les modifications sur l'interface utilisateur. <br><br>  Selon la source de l'√©tat du composant, il existe plusieurs fa√ßons de notifier Angular. <br><br><h4>  √âtat de pr√©sentation, calcul√© en fonction des param√®tres d'entr√©e </h4><br>  C'est l'option la plus simple.  Nous pla√ßons la logique de calcul de l'√©tat de pr√©sentation dans le crochet ngOnChanges.  La d√©tection de changement commencera d'elle-m√™me en changeant @ Input-parameters.  Dans la d√©mo, c'est <a href="">readonly-info.component</a> . <br><br><pre> <code class="plaintext hljs">export class ReadOnlyInfoComponent implements OnChanges { @Input() public state: Backend.SomeEntityState; public traits: ReadonlyInfoTraits; public ngOnChanges(changes: { state: SimpleChange }): void { this.traits = new ReadonlyInfoTraits(changes.state.currentValue); } }</code> </pre><br>  Tout est extr√™mement simple, mais il y a un point auquel il faut pr√™ter attention. <br><br>  Si l'√©tat de pr√©sentation du composant est complexe, et surtout si certains de ses champs sont calcul√©s sur la base d'autres, √©galement calcul√©s par les param√®tres Input, mettez l'√©tat du composant dans une classe distincte, rendez-le immuable et recr√©ez ngOnChanges √† chaque d√©marrage.  Dans un projet de d√©monstration, un exemple est la classe <a href="">ReadonlyInfoComponentTraits</a> .  En utilisant cette approche, vous vous prot√©gez de la n√©cessit√© de synchroniser les donn√©es d√©pendantes lorsqu'elles changent. <br><br>  Dans le m√™me temps, cela vaut la peine d'√™tre consid√©r√©: peut-√™tre que le composant a un √©tat difficile en raison du fait qu'il contient trop de logique.  Un exemple typique est une tentative dans un composant d'ajuster des repr√©sentations pour diff√©rents utilisateurs qui ont des mani√®res tr√®s diff√©rentes de travailler avec le syst√®me. <br><br><h4>  √âv√©nements natifs des composants </h4><br>  Pour la communication entre les composants d'application, nous utilisons des √©v√©nements de sortie.  C'est √©galement la troisi√®me fa√ßon d'ex√©cuter la d√©tection des modifications.  Angular suppose raisonnablement que si un composant g√©n√®re un √©v√©nement, alors quelque chose pourrait avoir chang√© dans son √©tat.  Par cons√©quent, Angular √©coute tous les √©v√©nements de sortie de composant et les d√©clencheurs modifient la d√©tection lorsqu'ils se produisent. <br><br>  Dans le projet de d√©monstration, il est enti√®rement synth√©tique, mais un exemple est le composant <a href="">submit-button.component</a> , qui g√©n√®re un √©v√©nement <i>formSaved</i> .  Le composant conteneur s'abonne √† cet √©v√©nement et affiche une alerte avec une notification. <br><br>  Utilisez les √©v√©nements de sortie pour leur objectif, c'est-√†-dire, cr√©ez-les pour la communication avec les composants parents, et non pour d√©clencher la d√©tection des modifications.  Sinon, il est probable, apr√®s des mois et des ann√©es, de ne pas se rappeler pourquoi cet √©v√©nement est inutile pour quiconque ici, et de le supprimer, de tout casser. <br><br><h4>  Changements dans les composants intelligents </h4><br>  Parfois, l'√©tat d'un composant est d√©termin√© par une logique complexe: appel asynchrone du service, connexion √† une socket Web, v√©rifie l'ex√©cution de setInterval, mais on ne sait jamais quoi d'autre.  Ces composants sont appel√©s composants intelligents. <br><br>  En g√©n√©ral, moins les composants intelligents de l'application ne sont pas des composants de conteneur, plus il sera facile de vivre.  Mais parfois, vous ne pouvez pas vous en passer. <br><br>  Le moyen le plus simple d'associer l'√©tat d'un composant intelligent √† la d√©tection de changement est de le transformer en observable et d'utiliser le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">canal asynchrone</a> d√©j√† discut√© ci-dessus.  Par exemple, si la source des modifications est un appel de service ou un √©tat de formulaire r√©actif, il s'agit d'un observable pr√™t √† l'emploi.  Si l'√©tat est form√© de quelque chose de plus complexe, vous pouvez utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fromPromise</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">websocket</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">timer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interval</a> from the composition of RxJS.  Ou g√©n√©rez vous-m√™me un flux √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Subject</a> . <br><br><h4>  Si aucune des options ne convient </h4><br>  Dans les cas o√π aucune des trois m√©thodes d√©j√† √©tudi√©es ne convient, nous avons toujours une option pare-balles - en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ChangeDetectorRef</a> directement.  Nous parlons des m√©thodes detectChanges et markForCheck de cette classe. <br><br>  Une documentation compl√®te r√©pond √† toutes les questions, nous ne nous attarderons donc pas sur son travail.  Mais notez que l'utilisation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ChangeDetectorRef</a> devrait √™tre limit√©e aux cas o√π vous comprenez clairement ce que vous faites, car il s'agit toujours de la cuisine angulaire interne. <br><br>  Pour le moment, nous n'avons trouv√© que quelques cas o√π cette m√©thode peut √™tre n√©cessaire: <br><br><ol><li>  Travail manuel avec d√©tection de changement - utilis√© dans la mise en ≈ìuvre de composants de bas niveau et c'est juste le cas ¬´vous comprenez clairement ce que vous faites¬ª. </li><li>  Relations complexes entre les composants - par exemple, lorsque vous devez cr√©er un lien vers un composant dans un mod√®le et le transmettre en tant que param√®tre √† un autre composant situ√© plus haut dans la hi√©rarchie ou m√™me dans une autre branche de la hi√©rarchie des composants.  Cela semble compliqu√©?  Il en est ainsi.  Et il est pr√©f√©rable de simplement refactoriser un tel code, car cela causera de la douleur non seulement avec la d√©tection des modifications. </li><li>  Les sp√©cificit√©s du comportement d'Angular lui-m√™me - par exemple, lors de l'impl√©mentation d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ControlValueAccessor</a> personnalis√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">,</a> vous pouvez rencontrer que la valeur de contr√¥le est modifi√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">par Angular de mani√®re asynchrone</a> et les modifications ne sont pas appliqu√©es au cycle de d√©tection de changement souhait√©. </li></ol><br>  Comme exemples d'utilisation dans l'application de d√©monstration, il existe la classe de base <a href="">OnPushControlValueAccessor</a> , qui r√©sout le probl√®me d√©crit dans le dernier paragraphe.  Toujours dans le projet, il y a un h√©ritier de cette classe - <a href="">radio-button.component personnalis√©</a> . <br><br>  Nous avons maintenant discut√© des quatre fa√ßons d'ex√©cuter la d√©tection des modifications et les options d'impl√©mentation OnPush pour les trois types de composants: conteneur, intelligent, de pr√©sentation.  Nous passons au point final - l'√©dition des donn√©es avec des formes r√©actives. <br><br><a name="form"></a><h2>  √âdition de donn√©es encapsul√©es </h2><br>  Les formes r√©actives ont un certain nombre de limites, mais c'est quand m√™me l'une des meilleures choses qui se soient produites dans l'√©cosyst√®me angulaire. <br><br>  Tout d'abord, ils r√©sument bien le travail avec l'√âtat et fournissent tous les outils n√©cessaires pour r√©pondre aux changements de mani√®re r√©active. <br><br>  En fait, la forme r√©active est une sorte de mini-magasin qui encapsule le travail avec l'√©tat: donn√©es et statuts d√©sactiv√©s / valides / en attente. <br><br>  Il nous reste √† supporter autant que possible cette encapsulation et √† √©viter de m√©langer pr√©sentation-logique et logique de la forme. <br><br>  Dans l'application de d√©monstration, vous pouvez voir <a href="">des classes de formulaire individuelles</a> qui encapsulent les sp√©cificit√©s de leur travail: validation, cr√©ation de groupes de formulaires enfants, utilisation de l'√©tat d√©sactiv√© des champs de saisie. <br><br>  Nous cr√©ons le formulaire racine dans le composant conteneur au moment o√π l'√©tat est charg√©, et √† chaque red√©marrage de l'√©tat, le formulaire est recr√©√©.  Ce n'est pas une condition pr√©alable, mais de cette fa√ßon, nous pouvons √™tre s√ªrs qu'il n'y a aucun effet accumul√© dans la logique de formulaire qui reste de l'√©tat charg√© pr√©c√©dent. <br><br>  √Ä l'int√©rieur du formulaire lui-m√™me, nous construisons les contr√¥les et ¬´poussons¬ª les donn√©es qui en d√©coulent, en les convertissant du contrat d'√âtat au contrat mod√®le.  La structure des formes correspond autant que possible aux contrats des mod√®les.  Par cons√©quent, la propri√©t√© value du formulaire nous donne un mod√®le pr√™t √† l'emploi pour l'envoi au backend. <br><br>  Si √† l'avenir l'√©tat ou la structure du mod√®le change, nous obtiendrons une erreur de compilation typographique exactement √† l'endroit o√π nous devons ajouter / supprimer des champs, ce qui est tr√®s pratique. <br><br>  De plus, si les objets state et model ont une structure absolument identique, le typage structurel utilis√© dans le script dactylographi√© √©limine la n√©cessit√© de cr√©er un mappage sans signification les uns des autres. <br><br>  Au total, la logique de forme est isol√©e de la logique de pr√©sentation dans les composants et vit ¬´par elle-m√™me¬ª, sans augmenter la complexit√© du flux de donn√©es de notre application dans son ensemble. <br><br>  C‚Äôest presque tout.  Il reste des cas limites lorsque nous ne pouvons pas isoler la logique du formulaire du reste de l'application: <br><br><ol><li>  Changements de forme entra√Ænant un changement d'√©tat de pr√©sentation - par exemple, visibilit√© d'un bloc de donn√©es en fonction de la valeur entr√©e.  Nous l'impl√©mentons dans le composant en souscrivant aux √©v√©nements de formulaire.  Vous pouvez le faire √† travers les traits immuables discut√©s pr√©c√©demment. </li><li>  Si vous avez besoin d'un validateur asynchrone qui appelle le backend, nous construisons AsyncValidatorFn dans le composant et le transmettons au constructeur de formulaire, pas au service. </li></ol><br>  Ainsi, toute logique ¬´limite¬ª reste √† la place la plus importante - dans les composants. <br><br><h2>  Conclusions </h2><br>  R√©sumons ce que nous avons obtenu et les autres points √† √©tudier et √† d√©velopper. <br><br>  Tout d'abord, le d√©veloppement de la strat√©gie OnPush nous oblige √† concevoir soigneusement le flux de donn√©es de l'application, puisque maintenant nous dictons les r√®gles du jeu √† Angular, et non √† lui. <br><br>  Il y a deux cons√©quences √† cette situation. <br><br>  Tout d'abord, nous obtenons une agr√©able sensation de contr√¥le sur l'application.  Il n'y a plus de magie qui ¬´fonctionne d'une mani√®re ou d'une autre¬ª.  Vous √™tes clairement conscient de ce qui se passe √† tout moment dans votre candidature.  L'intuition se d√©veloppe progressivement, ce qui vous permet de comprendre la raison du bogue trouv√©, avant m√™me d'ouvrir le code. <br><br>  Deuxi√®mement, nous devons maintenant consacrer plus de temps √† la conception de l'application, mais le r√©sultat sera toujours la solution la plus ¬´directe¬ª, et donc la plus simple.  Cela met sensiblement √† z√©ro la probabilit√© d'une situation o√π, √† mesure que l'application se d√©veloppe, elle devient un monstre d'une √©norme complexit√©, les d√©veloppeurs ont perdu le contr√¥le de cette complexit√© et le d√©veloppement ressemble d√©sormais davantage √† des rites mystiques. <br><br>  La complexit√© contr√¥l√©e et l'absence de ¬´magie¬ª r√©duisent la probabilit√© que toute une classe de probl√®mes survienne, par exemple, √† partir de mises √† jour cycliques de donn√©es ou d'accumulations d'effets secondaires.  Au lieu de cela, nous traitons des probl√®mes d√©j√† perceptibles pendant le d√©veloppement, lorsque l'application ne fonctionne tout simplement pas.  Et forc√©ment, vous devez faire fonctionner l'application simplement et clairement. <br><br>  Nous avons √©galement mentionn√© de bons effets sur les performances.  D√©sormais, √† l'aide d'outils tr√®s simples, tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">profiler.timeChangeDetection</a> , nous pouvons √† tout moment v√©rifier que notre application est toujours en bon √©tat. <br><br>  C'est aussi un p√©ch√© de ne pas essayer de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©sactiver NgZone</a> .  Tout d'abord, il vous permettra de ne pas charger toute la biblioth√®que au d√©marrage de l'application.  Deuxi√®mement, cela supprimera une bonne quantit√© de magie de votre application. <br><br>  C'est l√† que nous terminons notre histoire. <br><br>  Nous serons en contact! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426819/">https://habr.com/ru/post/fr426819/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426809/index.html">Zeev Surasky: L'avenir du moteur et du framework Zend</a></li>
<li><a href="../fr426811/index.html">Parkour, danse et travaux de construction de Boston Dynamics</a></li>
<li><a href="../fr426813/index.html">? Skype est devenu un semblant ennuyeux ... et un produit qui vous permet d'avoir un acc√®s complet √† votre syst√®me? Y a-t-il un espoir?</a></li>
<li><a href="../fr426815/index.html">Comment obtenir une bourse de d√©veloppement de projet si vous √™tes un √©tudiant pauvre? Et √ßa vaut le coup</a></li>
<li><a href="../fr426817/index.html">Cl√©s priv√©es et API Web CommuniGate Pro</a></li>
<li><a href="../fr426821/index.html">Comment organiser CI / CD sur un projet: de la d√©finition des t√¢ches √† la configuration du pipeline de d√©ploiement</a></li>
<li><a href="../fr426825/index.html">Quelques conseils pour les pigistes</a></li>
<li><a href="../fr426831/index.html">Conversation d√©sagr√©able, herp√©tologue et surprise totale</a></li>
<li><a href="../fr426835/index.html">Analyse comparative et d√©taill√©e des plugins de mise en cache pour WordPress</a></li>
<li><a href="../fr426837/index.html">Diffusion vid√©o sur votre site qui fonctionne</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>