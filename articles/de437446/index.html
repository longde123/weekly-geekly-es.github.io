<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📕 🧜🏻 📨 Apache Kafka und RabbitMQ: Semantik und Garantie der Nachrichtenübermittlung 🆓 🤜🏾 🎌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben die Übersetzung des nächsten Teils des Serienartikels vorbereitet, in dem die Funktionalität von Apache Kafka und RabbitMQ verglichen wird. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apache Kafka und RabbitMQ: Semantik und Garantie der Nachrichtenübermittlung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/437446/"><img src="https://habrastorage.org/webt/9w/ar/yb/9warybopprmxno4cvxzuvswgexu.jpeg"><br><br>  Wir haben die Übersetzung des nächsten Teils des Serienartikels vorbereitet, in dem die Funktionalität von Apache Kafka und RabbitMQ verglichen wird.  Diese Veröffentlichung befasst sich mit Semantik- und Nachrichtenübermittlungsgarantien.  Bitte beachten Sie, dass der Autor Kafka bis einschließlich Version 0.10 berücksichtigt hat und genau einmal in Version 0.11 erschienen ist.  Trotzdem bleibt der Artikel relevant und enthält viele Punkte, die aus praktischer Sicht nützlich sind. <br>  Vorherige Teile: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstens</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweitens</a> . <br><a name="habracut"></a><br>  Sowohl RabbitMQ als auch Kafka bieten zuverlässige Garantien für die Zustellung von Nachrichten.  Beide Plattformen bieten Garantien nach den Grundsätzen „höchstens einmalige Lieferung“ und „mindestens einmalige Lieferung“. Mit dem Prinzip „ausschließlich einmalige Lieferung“ gelten die Garantien von Kafka jedoch in einem sehr begrenzten Szenario. <br><br>  Lassen Sie uns zunächst herausfinden, was diese Garantien bedeuten: <br><br><ul><li>  Höchstens einmalige Lieferung.  Dies bedeutet, dass die Nachricht nur einmal zugestellt werden kann.  Die Nachricht kann jedoch verloren gehen. </li><li>  Mindestens einmalige Lieferung.  Dies bedeutet, dass die Nachricht niemals verloren geht.  In diesem Fall kann die Nachricht mehrmals zugestellt werden. </li><li>  Genau einmalige Lieferung.  Der heilige Gral der Nachrichtensysteme.  Alle Nachrichten werden ausschließlich einmal zugestellt. </li></ul><br>  Das Wort "Lieferung" ist hier wahrscheinlich kein genauer Begriff.  Es wäre genauer, "Verarbeitung" zu sagen.  In jedem Fall interessiert uns jetzt, ob der Verbraucher Nachrichten verarbeiten kann und nach welchem ​​Prinzip dies geschieht: „nicht mehr als eine“, „mindestens eine“ oder „streng einmal“.  Das Wort "Verarbeitung" erschwert jedoch die Wahrnehmung, und der Ausdruck "Zustellung nach dem Prinzip" streng einmal "" ist in diesem Fall keine genaue Definition, da die Nachricht möglicherweise zweimal zugestellt werden muss, um sie einmal ordnungsgemäß zu verarbeiten.  Wenn der Empfänger während der Verarbeitung die Verbindung getrennt hat, muss die Nachricht erneut an den neuen Empfänger gesendet werden. <br><br>  Der zweite.  Wenn wir das Problem der Nachrichtenverarbeitung diskutieren, kommen wir zum Thema Teilfehler, was Entwicklern Kopfschmerzen bereitet.  Bei der Verarbeitung der Nachricht gibt es mehrere Stufen.  Es besteht aus Kommunikationssitzungen zwischen der Anwendung und dem Nachrichtensystem am Anfang und am Ende und der Anwendung selbst, die mit den Daten in der Mitte arbeitet.  Teilanwendungsfehlerszenarien müssen von der Anwendung selbst behandelt werden.  Wenn die ausgeführten Operationen vollständig transaktional sind und die Ergebnisse nach dem Prinzip „Alles oder Nichts“ formuliert sind, können Teilfehler in der Anwendungslogik vermieden werden.  Viele Phasen umfassen jedoch häufig die Interaktion mit anderen Systemen, in denen Transaktionsmöglichkeiten unmöglich sind.  Wenn wir die Beziehungen zwischen Nachrichtensystemen, Anwendungen, Cache und Datenbank in die Interaktion einbeziehen, können wir die Verarbeitung nur einmal garantieren?  Die Antwort ist nein. <br><br>  Die Strategie "streng einmal" beschränkt sich auf ein Szenario, in dem der einzige Empfänger verarbeiteter Nachrichten die Messaging-Plattform selbst ist und diese Plattform selbst vollständige Transaktionen bereitstellt.  In diesem eingeschränkten Szenario können Sie Nachrichten verarbeiten, schreiben und Signale senden, dass sie im Rahmen einer Transaktion verarbeitet wurden, die nach dem Prinzip "Alles oder Nichts" durchgeführt wurde.  Es wird von der Kafka Streams-Bibliothek bereitgestellt. <br><br>  Wenn die Nachrichtenverarbeitung jedoch immer idempotent ist, können Sie vermeiden, dass die Strategie „nur einmal“ durch Transaktionen implementiert werden muss.  Wenn die endgültige Verarbeitung von Nachrichten idempotent ist, können Sie sich Sorgen machen, Duplikate zu akzeptieren.  Es können jedoch nicht alle Aktionen idempotent implementiert werden. <br><br>  <b>End-to-End-Alarm</b> <br><br>  Was auf keinem Gerät aller Messagingsysteme, mit denen ich gearbeitet habe, dargestellt wird, ist eine End-to-End-Bestätigung.  Da eine Nachricht in RabbitMQ in die Warteschlange gestellt werden kann, ist eine End-to-End-Benachrichtigung nicht sinnvoll.  In Kafka können auf ähnliche Weise mehrere verschiedene Empfängergruppen gleichzeitig Informationen aus einem Thema lesen.  Nach meiner Erfahrung sind End-to-End-Warnungen das, wonach Personen, die mit dem Konzept des Messaging noch nicht vertraut sind, häufig fragen.  In solchen Fällen ist es am besten, sofort zu erklären, dass dies nicht möglich ist. <br><br>  <b>Verantwortungskette</b> <br><br>  Im Großen und Ganzen können Nachrichtenquellen nicht wissen, dass ihre Nachrichten an Empfänger übermittelt werden.  Sie können nur wissen, dass das Nachrichtensystem ihre Nachrichten empfangen und die Verantwortung für die sichere Speicherung und Zustellung übernommen hat.  Es gibt eine Verantwortungskette, die mit der Quelle beginnt, das Nachrichtensystem durchläuft und beim Empfänger endet.  Jeder sollte seine Pflichten korrekt erfüllen und die Botschaft klar an den nächsten weitergeben.  Dies bedeutet, dass Sie als Entwickler Ihre Anwendungen korrekt gestalten müssen, um den Verlust oder Missbrauch von Nachrichten zu verhindern, während diese unter Ihrer Kontrolle stehen. <br><br>  <b>Verfahren zur Nachrichtenübertragung</b> <br><br>  Dieser Artikel befasst sich hauptsächlich damit, wie jede Plattform Sendestrategien "mindestens eine" und "nicht mehr als eine" bereitstellt.  Es gibt jedoch noch eine Nachrichtenreihenfolge.  In den vorherigen Teilen dieser Serie habe ich über die Reihenfolge, in der Nachrichten gesendet werden, und die Reihenfolge, in der sie verarbeitet werden, geschrieben. Ich rate Ihnen, auf diese Teile zu verweisen. <br><br>  Kurz gesagt, sowohl RabbitMQ als auch Kafka bieten eine FIFO-Garantie (First In First Out).  RabbitMQ behält diese Reihenfolge auf Warteschlangenebene und Kafka auf Segmentierungsebene bei.  Die Auswirkungen solcher Entwurfsentscheidungen wurden in früheren Artikeln erörtert. <br><br>  <b>Liefergarantien in RabbitMQ</b> <br><br>  Liefergarantien werden gegeben: <br><br><ul><li>  Nachrichtenzuverlässigkeit - Sie verschwinden nicht, während sie auf RabbitMQ gespeichert sind. </li><li>  Nachrichtenbenachrichtigungen - RabbitMQ tauscht Signale mit Absendern und Empfängern aus. </li></ul><br><h4>  Zuverlässigkeitselemente </h4><br>  <b>Warteschlangenspiegelung</b> <br><br>  Warteschlangen können auf vielen Knoten (Servern) gespiegelt (repliziert) werden.  Jede Warteschlange hat eine führende Warteschlange an einem der Knoten.  Beispielsweise gibt es drei Knoten, 10 Warteschlangen und zwei Replikate pro Warteschlange.  10 Steuerwarteschlangen und 20 Replikate werden auf drei Knoten verteilt.  Die Verteilung der Steuerwarteschlangen nach Knoten kann konfiguriert werden.  Im Falle eines Knotenstopps: <br><br><ul><li>  Anstelle jeder führenden Warteschlange auf dem blockierten Knoten wird eine Replik dieser Warteschlange auf einem anderen Knoten bereitgestellt. </li><li>  Auf anderen Knoten werden neue Replikate erstellt, um die verlorenen Replikate auf dem ausgehenden Knoten zu ersetzen und so den Replikationsfaktor zu unterstützen. </li></ul><br>  Das Problem der Fehlertoleranz wird im nächsten Teil des Artikels erörtert. <br><br>  <b>Vertrauenswürdige Warteschlangen</b> <br><br>  Es gibt zwei Arten von Warteschlangen in RabbitMQ: zuverlässig und unzuverlässig.  Zuverlässige Warteschlangen werden auf die Festplatte geschrieben und bei einem Neustart des Knotens gespeichert.  Wenn der Knoten gestartet wird, werden sie überschrieben. <br><br>  <b>Dauerhafte Beiträge</b> <br><br>  Wenn die Warteschlange zuverlässig ist, bedeutet dies nicht, dass ihre Nachrichten beim Neustart des Knotens gespeichert werden.  Es werden nur Nachrichten wiederhergestellt, die vom Absender als dauerhaft markiert wurden. <br><br>  Bei der Arbeit an RabbitMQ ist die mögliche Leistung umso geringer, je zuverlässiger die Nachricht ist.  Wenn es einen Strom von Echtzeitereignissen gibt und es nicht kritisch ist, mehrere davon oder ein kleines Zeitintervall des Stroms zu verlieren, ist es besser, die Warteschlangenreplikation nicht zu verwenden und alle Nachrichten als instabil zu übertragen.  Wenn es jedoch unerwünscht ist, Nachrichten aufgrund einer Fehlfunktion eines Knotens zu verlieren, ist es besser, zuverlässige Warteschlangen mit Replikation und stabilen Nachrichten zu verwenden. <br><br><h4>  Nachrichtenbenachrichtigungen </h4><br>  <b>Messaging</b> <br><br>  Nachrichten können während der Übertragung verloren gehen oder dupliziert werden.  Dies hängt vom Verhalten des Absenders ab. <br><br>  <i>"Geschossen und vergessen"</i> <br><br>  Die Quelle kann beschließen, keine Bestätigung vom Empfänger anzufordern (Benachrichtigung über den Empfang einer Nachricht an den Absender) und die Nachricht einfach automatisch zu senden.  Nachrichten werden nicht dupliziert, können jedoch verloren gehen (was der Strategie „maximal einmalige Zustellung“ entspricht). <br><br>  <i>Bestätigungen an den Absender</i> <br><br>  Wenn der Absender einen Kanal für den Warteschlangenbroker öffnet, kann er denselben Kanal zum Senden von Bestätigungen verwenden.  Als Antwort auf die empfangene Nachricht muss der Warteschlangenbroker nun eines von zwei Dingen bereitstellen: <br><br><ul><li>  basic.ack.  Positive Bestätigung.  Die Nachricht wird empfangen, die Verantwortung dafür liegt jetzt bei RabbitMQ; </li><li>  basic.nack.  Negative Bestätigung.  Es ist etwas passiert und die Nachricht wurde nicht verarbeitet.  Die Verantwortung dafür bleibt bei der Quelle.  Auf Wunsch kann er ein zweites Mal eine Nachricht senden. </li></ul><br>  Zusätzlich zu den positiven und negativen Zustellbenachrichtigungen wird eine basic.return-Nachricht bereitgestellt.  Manchmal muss der Absender nicht nur wissen, dass die Nachricht in RabbitMQ angekommen ist, sondern auch, dass sie wirklich in eine oder mehrere Warteschlangen gefallen ist.  Es kann vorkommen, dass die Quelle eine Nachricht an das Themenaustauschsystem sendet, in dem die Nachricht nicht an eine der Übermittlungswarteschlangen weitergeleitet wird.  In dieser Situation verwirft der Broker die Nachricht einfach.  In einigen Szenarien ist dies normal, in anderen muss die Quelle wissen, ob die Nachricht verworfen wurde, und entsprechend weiter vorgehen.  Sie können das Flag "Obligatorisch" für einzelne Nachrichten setzen. Wenn die Nachricht in keiner Zustellwarteschlange definiert wurde, wird basic.return an den Absender zurückgegeben. <br><br>  Die Quelle wartet möglicherweise nach dem Senden jeder Nachricht auf eine Bestätigung, dies verringert jedoch die Leistung erheblich.  Stattdessen können Quellen einen stetigen Strom von Nachrichten senden, wodurch die Anzahl der nicht bestätigten Nachrichten begrenzt wird.  Wenn das Limit für die Zwischennachricht erreicht ist, wird das Senden angehalten, bis alle Bestätigungen eingegangen sind. <br><br>  Da jetzt viele Nachrichten vom Absender an RabbitMQ übertragen werden, werden Bestätigungen mithilfe des Mehrfachflags gruppiert, um die Leistung zu verbessern.  Allen über den Kanal gesendeten Nachrichten wird ein monoton ansteigender ganzzahliger Wert zugewiesen, die „Sequenznummer“.  Die Benachrichtigung einer Nachricht enthält die Sequenznummer der entsprechenden Nachricht.  Und wenn gleichzeitig der Wert multiple = true ist, muss der Absender die Sequenznummern seiner Nachrichten verfolgen, um zu wissen, welche Nachrichten erfolgreich zugestellt wurden und welche nicht.  Ich habe einen ausführlichen Artikel zu diesem Thema geschrieben. <br><br>  Dank Bestätigungen vermeiden wir Nachrichtenverlust auf folgende Weise: <br><br><ul><li>  erneutes Senden von Nachrichten im Falle einer negativen Benachrichtigung; </li><li>  Fortsetzung der Speicherung von Nachrichten irgendwo im Falle einer negativen Benachrichtigung oder einer grundlegenden Rückgabe. </li></ul><br>  <i>Transaktionen</i> <br><br>  Transaktionen werden in RabbitMQ aus folgenden Gründen selten verwendet: <br><br><ul><li>  Schwache Garantien.  Wenn Nachrichten an mehrere Warteschlangen weitergeleitet werden oder ein obligatorisches Symbol haben, wird die Transaktionskontinuität nicht unterstützt. </li><li>  Geringe Produktivität. </li></ul><br>  Ehrlich gesagt, ich habe sie nie verwendet, sie geben keine zusätzlichen Garantien, außer Bestätigungen an den Absender, und erhöhen nur die Unsicherheit in der Frage, wie die Bestätigung des Empfangs von Nachrichten zu interpretieren ist, die sich aus dem Abschluss von Transaktionen ergeben. <br><br>  <i>Kommunikations- / Kanalfehler</i> <br><br>  Zusätzlich zu den Benachrichtigungen über den Empfang von Nachrichten muss der Absender die Fehler von Kommunikationstools und Brokern berücksichtigen.  Beide Faktoren führen zum Verlust des Kommunikationskanals.  Mit dem Verlust von Kanälen verschwindet die Möglichkeit, noch nicht empfangene Benachrichtigungen über den Empfang von Nachrichten zu erhalten.  Hier muss der Absender zwischen dem Risiko eines Nachrichtenverlusts und dem Risiko einer Vervielfältigung wählen. <br><br>  Ein Brokerfehler kann auftreten, wenn sich die Nachricht im Betriebssystempuffer befand oder vorverarbeitet wurde und die Nachricht dann verloren geht.  Oder vielleicht wurde die Nachricht in die Warteschlange gestellt, aber der Nachrichtenbroker ist vor dem Senden einer Bestätigung gestorben.  In diesem Fall wird die Nachricht erfolgreich zugestellt. <br><br>  Ebenso wirkt sich der Ausfall der Kommunikationsmittel auf die Situation aus.  Ist während der Übertragung der Nachricht ein Fehler aufgetreten?  Oder nachdem die Nachricht in die Warteschlange gestellt wurde, aber bevor eine positive Benachrichtigung empfangen wurde? <br><br>  Der Absender kann dies nicht feststellen und muss daher eine der folgenden Optionen auswählen: <br><br><ul><li>  Leiten Sie die Nachricht nicht weiter, da sonst das Risiko eines Verlusts besteht. </li><li>  Senden Sie die Nachricht erneut und es besteht die Gefahr von Duplikaten. </li></ul><br>  Wenn viele Absendernachrichten übertragen werden, wird das Problem komplizierter.  Der Absender kann den Empfängern nur einen Hinweis geben, indem er der Nachricht einen speziellen Header hinzufügt, der angibt, dass die Nachricht ein zweites Mal gesendet wird.  Empfänger können entscheiden, Nachrichten auf das Vorhandensein solcher Header zu überprüfen und, falls sie gefunden werden, zusätzlich nach empfangenen Nachrichten auf Duplikate zu suchen (falls eine solche Überprüfung zuvor nicht durchgeführt wurde). <br><br><h4>  Empfänger </h4><br>  Empfängern stehen zwei Optionen zum Empfangen von Benachrichtigungen zur Verfügung: <br><br><ul><li>  kein Benachrichtigungsmodus; </li><li>  manueller Benachrichtigungsmodus. </li></ul><br>  <i>Kein Benachrichtigungsmodus</i> <br><br>  Er ist ein Modus für automatische Benachrichtigungen.  Und er ist gefährlich.  Erstens, denn wenn eine Nachricht in Ihre Anwendung gelangt, wird sie aus der Warteschlange entfernt.  Dies kann zu Nachrichtenverlust führen, wenn: <br><br><ul><li>  Die Verbindung wurde unterbrochen, bevor die Nachricht empfangen wurde. </li><li>  Die Nachricht befindet sich noch im internen Puffer und die Anwendung wurde deaktiviert. </li><li>  Nachrichtenverarbeitung fehlgeschlagen. </li></ul><br>  Darüber hinaus verlieren wir Gegendruckmechanismen, um die Qualität der Nachrichtenübermittlung zu überwachen.  Durch Einstellen des Modus zum manuellen Senden von Benachrichtigungen können Sie einen Prefetch (oder die Stufe der bereitgestellten Dienste, QoS) festlegen, um die einmalige Anzahl von Nachrichten zu begrenzen, deren Empfang vom System noch nicht bestätigt wurde.  Ohne dies sendet RabbitMQ Nachrichten so schnell, wie es die Verbindung zulässt, und dies kann schneller sein, als der Empfänger sie verarbeiten kann.  Infolgedessen sind die Puffer voll und es treten Speicherfehler auf. <br><br>  <i>Manueller Benachrichtigungsmodus</i> <br><br>  Der Empfänger muss manuell eine Benachrichtigung über den Empfang jeder Nachricht senden.  Er kann einen Prefetch festlegen, falls die Anzahl der Nachrichten mehr als eins beträgt, und viele Nachrichten gleichzeitig verarbeiten.  Er kann entscheiden, für jede Nachricht eine Benachrichtigung zu senden, oder er kann das Mehrfachflag anwenden und mehrere Benachrichtigungen gleichzeitig senden.  Das Gruppieren von Benachrichtigungen verbessert die Leistung. <br><br>  Wenn der Empfänger den Kanal öffnet, enthalten die Nachrichten, die ihn durchlaufen, den Parameter Delivery Tag, dessen Wert eine ganzzahlige, monoton ansteigende Zahl ist.  Es ist in jeder Empfangsbestätigung enthalten und wird als Nachrichtenkennung verwendet. <br><br>  Benachrichtigungen können wie folgt sein: <br><br><ul><li>  basic.ack.  Danach entfernt RabbitMQ die Nachricht aus der Warteschlange.  Das Mehrfachflag kann hier angewendet werden. </li><li>  basic.nack.  Der Empfänger muss ein Flag setzen, um RabbitMQ mitzuteilen, ob die Nachricht erneut in die Warteschlange gestellt werden soll.  Beim Zurücksetzen geht die Nachricht an den Anfang der Warteschlange.  Von dort wird es erneut an den Empfänger gesendet (sogar an denselben Empfänger).  Die basic.nack-Benachrichtigung unterstützt das Mehrfachflag. </li><li>  basic.reject.  Entspricht basic.nack, unterstützt jedoch nicht das Mehrfachflag. </li></ul><br>  Somit sind semantisch basic.ack und basic.nack mit Requeue = false identisch.  Beide Operatoren bedeuten das Entfernen einer Nachricht aus der Warteschlange. <br><br>  Die nächste Frage ist, wann Empfangsbestätigungen gesendet werden sollen.  Wenn die Nachricht schnell verarbeitet wurde, möchten Sie möglicherweise sofort nach Abschluss dieses Vorgangs eine Benachrichtigung senden (erfolgreich oder nicht erfolgreich).  Aber wenn sich die Nachricht in der RabbitMQ-Warteschlange befand und die Verarbeitung viele Minuten dauert?  Das Senden einer Benachrichtigung danach ist problematisch, da beim Schließen des Kanals alle Nachrichten, an die keine Benachrichtigungen gesendet wurden, an die Warteschlange zurückgegeben werden und das Senden ein zweites Mal erfolgt. <br><br>  <b>Verbindungs- / Nachrichtenbrokerfehler</b> <br><br>  Wenn die Verbindung getrennt wurde oder ein Fehler im Broker aufgetreten ist, nach dem der Kanal nicht mehr funktioniert, werden alle Nachrichten, deren Empfang nicht bestätigt wurde, erneut in die Warteschlange gestellt und weitergeleitet.  Dies ist gut, weil es Datenverlust verhindert, aber schlecht, weil es übermäßige Duplizierung verursacht. <br><br>  Je länger der Empfänger über einen längeren Zeitraum Nachrichten hat, deren Empfang er nicht bestätigt hat, desto höher ist das Risiko einer Weiterleitung.  Wenn eine Nachricht erneut gesendet wird, wird RabbitMQ für das Weiterleitungsflag auf true gesetzt.  Aus diesem Grund hat der Empfänger zumindest einen Hinweis darauf, dass die Nachricht möglicherweise bereits verarbeitet wurde. <br><br>  <b>Idempotenz</b> <br><br>  Wenn eine Idempotenz erforderlich ist und garantiert, dass keine Nachricht verloren geht, sollten einige doppelte Überprüfungen oder andere idempotente Schemata eingebaut werden.  Wenn das Überprüfen auf doppelte Nachrichten zu teuer ist, können Sie eine Strategie anwenden, bei der der Absender immer einen speziellen Header zum erneuten Senden von Nachrichten hinzufügt und der Empfänger die empfangenen Nachrichten auf das Vorhandensein eines solchen Headers und eines erneuten Sendeflags überprüft. <br><br><h4>  Fazit </h4><br>  RabbitMQ bietet zuverlässige, langfristige Messaging-Garantien, aber es gibt viele Situationen, in denen sie nicht helfen. <br><br>  Hier ist eine Liste von Punkten, an die Sie sich erinnern sollten: <br><br><ul><li>  Sie sollten Warteschlangenspiegelung, zuverlässige Warteschlangen, dauerhafte Nachrichten, Bestätigungen für den Absender, ein Bestätigungsflag und eine erzwungene Benachrichtigung des Empfängers verwenden, wenn zuverlässige Garantien für die Strategie "mindestens einmalige Zustellung" erforderlich sind. </li><li>  Wenn das Senden im Rahmen der Strategie „mindestens einmalige Zustellung“ durchgeführt wird, müssen Sie möglicherweise einen Mechanismus für die Deduplizierung oder Idempotenz hinzufügen, wenn Sie die gesendeten Daten duplizieren. </li><li>  Wenn das Problem des Nachrichtenverlusts nicht so wichtig ist wie das Problem der Zustellgeschwindigkeit und der hohen Skalierbarkeit, denken Sie an Systeme ohne Redundanz, ohne persistente Nachrichten und ohne Bestätigung auf der Quellseite.  Trotzdem würde ich es vorziehen, erzwungene Benachrichtigungen vom Empfänger zu hinterlassen, um den Fluss empfangener Nachrichten durch Ändern der Prefetch-Einschränkungen zu steuern.  In diesem Fall müssen Sie Benachrichtigungen stapelweise senden und das Flag "Mehrfach" verwenden. </li></ul><br>  <b>Liefergarantien in Kafka</b> <br><br>  Liefergarantien werden gegeben: <br><br><ul><li>  Nachrichtenbeständigkeit - In einem Segment gespeicherte Nachrichten gehen nicht verloren. </li><li>  Nachrichtenbenachrichtigungen - der Austausch von Signalen zwischen Kafka (und möglicherweise dem Apache Zookeeper-Repository) einerseits und der Quelle / dem Empfänger andererseits. </li></ul><br>  <b>Zwei Worte zur Nachrichtenverpackung</b> <br><br>  Einer der Unterschiede zwischen RabbitMQ und Kafka ist die Verwendung von Paketen für Messaging. <br><br>  RabbitMQ bietet etwas Ähnliches wie Verpackung dank: <br><br><ul><li>  Unterbrechen Sie das Senden aller X-Nachrichten, bis alle Benachrichtigungen empfangen wurden.  RabbitMQ gruppiert Benachrichtigungen normalerweise mit dem Flag "multiple". </li><li>    «prefetch»      «multiple». </li></ul><br>       .                  “multiple”.     TCP. <br><br> Kafka     .    ,           .     RabbitMQ,      ,    ,      .         ,         . <br><br> Kafka        ,      ,     .      ,          .     RabbitMQ   API    ,                  . RabbitMQ         . <br><br> <b>,  </b> <br><br> <i> </i> <br><br>      Kafka   -    ,       ,      .       .   ,   ,  , ,        ,      . <br><br> Kafka     (In Sync Replicas, ISR).          .        ,   ,     (   10 ).    ,      .    -  ,       ..               .        . <br><br> <i>      </i> <br><br>  ,  Kafka  ,  ,    , Kafka               . <br><br> <i>     </i> <br><br>    ,     Kafka,      ,    : <br><br><ul><li>  ,  . Acks=0. </li><li>     . Acks=1 </li><li>           . Acks=All </li></ul><br>          ,    RabbitMQ.         ,      ,        (   ,    ).   ,          . <br><br>   Kafka       .        : <br><br><ul><li>  enable.idempotence   “true”, </li><li>  max.in.flight.requests.per.connection   5  , </li><li>  retries   1  , </li><li>  acks   “all”. </li></ul><br> ,          acks=0/1   ,     . <br><br> <i>  </i> <br><br>        ,           ,   .       ZooKeeper    Kafka. <br><br>        (),       ,       : <br><br><ul><li>  In regelmäßigen Abständen.          .                 .          .         ,      . </li><li> ,    .      “   ”.    ,      ;     ,    . ,  10         ,    4 ,   ,      ,     ; </li><li>  ,    .      “   ”.  ,      ,      ,           . ,  10         ,       ,  4    ; </li><li> .    ,     . </li></ul><br>  “  ”  Kafka Streams,    Java.   Java      .    “  ”,      ,    ,           . ,         ,      “  ”  .           ,       ,   ()      . <br><br> ,  Kafka Streams,          ,       ,      “  ”.       Kafka:             .    ,    .    ,    ,   ,        (   ),   . <br><br> <b>    </b> <br><br>      Kafka     “--”.         .   ,   ,  . <br><br>        “ ”,    ,      (,  , ).      “ ”,    ,      .       . <br><br>   :    “  ”      ?    .        ,     ,    .     .     (Last Stable Offset, LSO) —      ;     “  ”      . <br><br>  <b>Schlussfolgerungen</b> <br><br>         .   ,    ,      .   ,     Kafka      ,                . <br><br><h4>  Zusammenfassend </h4><br><ul><li>      “   ”  “   ”. </li><li>     . </li><li>      ,              . Kafka    ,      . </li><li>       ,   ,        . </li><li>        . </li><li> Kafka   ,      “--”.          . </li><li>  Kafka,       -         ,        (   ).  RabbitMQ    . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kafka kann die Vorteile der Paketierung aufgrund seiner Paketverteilungsfunktionen erhöhen, und RabbitMQ verfügt aufgrund eines passiven Empfangsmodells, das Empfängerkonflikte nicht verhindert, nicht über eine Paketierung. </font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437446/">https://habr.com/ru/post/de437446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437436/index.html">Ausführen des Bildbetrachters unter Windows XP unter modernem Windows</a></li>
<li><a href="../de437438/index.html">Audiotechnologie: Wie werden Kunststoffteile mit Ultraschall bewegt und warum wird sie benötigt?</a></li>
<li><a href="../de437440/index.html">Glücklicher Studententag, Programmierer</a></li>
<li><a href="../de437442/index.html">Antworten des technischen Supports von 3CX: Konfigurieren Sie den Router für den PBX-VoIP-Server</a></li>
<li><a href="../de437444/index.html">Ein Eimer Teer in einem Fass Honig oder Über einen möglichen kulturellen Schock für Traktorbesitzer</a></li>
<li><a href="../de437448/index.html">28. Januar in Russland, das System der schnellen Zahlungen ohne Provision (per Telefonnummer)</a></li>
<li><a href="../de437450/index.html">Wie ich OpenCV kennengelernt habe oder auf der Suche nach ColorChecker</a></li>
<li><a href="../de437454/index.html">Arithmometer Felix M Bewertung</a></li>
<li><a href="../de437456/index.html">Jünger: Überprüfung der Snom D315- und D305-IP-Telefone</a></li>
<li><a href="../de437458/index.html">Obligatorische Registrierung durch IMEI bieten an, bezahlt zu machen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>