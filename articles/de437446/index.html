<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“• ğŸ§œğŸ» ğŸ“¨ Apache Kafka und RabbitMQ: Semantik und Garantie der NachrichtenÃ¼bermittlung ğŸ†“ ğŸ¤œğŸ¾ ğŸŒ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben die Ãœbersetzung des nÃ¤chsten Teils des Serienartikels vorbereitet, in dem die FunktionalitÃ¤t von Apache Kafka und RabbitMQ verglichen wird. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apache Kafka und RabbitMQ: Semantik und Garantie der NachrichtenÃ¼bermittlung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/437446/"><img src="https://habrastorage.org/webt/9w/ar/yb/9warybopprmxno4cvxzuvswgexu.jpeg"><br><br>  Wir haben die Ãœbersetzung des nÃ¤chsten Teils des Serienartikels vorbereitet, in dem die FunktionalitÃ¤t von Apache Kafka und RabbitMQ verglichen wird.  Diese VerÃ¶ffentlichung befasst sich mit Semantik- und NachrichtenÃ¼bermittlungsgarantien.  Bitte beachten Sie, dass der Autor Kafka bis einschlieÃŸlich Version 0.10 berÃ¼cksichtigt hat und genau einmal in Version 0.11 erschienen ist.  Trotzdem bleibt der Artikel relevant und enthÃ¤lt viele Punkte, die aus praktischer Sicht nÃ¼tzlich sind. <br>  Vorherige Teile: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstens</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweitens</a> . <br><a name="habracut"></a><br>  Sowohl RabbitMQ als auch Kafka bieten zuverlÃ¤ssige Garantien fÃ¼r die Zustellung von Nachrichten.  Beide Plattformen bieten Garantien nach den GrundsÃ¤tzen â€hÃ¶chstens einmalige Lieferungâ€œ und â€mindestens einmalige Lieferungâ€œ. Mit dem Prinzip â€ausschlieÃŸlich einmalige Lieferungâ€œ gelten die Garantien von Kafka jedoch in einem sehr begrenzten Szenario. <br><br>  Lassen Sie uns zunÃ¤chst herausfinden, was diese Garantien bedeuten: <br><br><ul><li>  HÃ¶chstens einmalige Lieferung.  Dies bedeutet, dass die Nachricht nur einmal zugestellt werden kann.  Die Nachricht kann jedoch verloren gehen. </li><li>  Mindestens einmalige Lieferung.  Dies bedeutet, dass die Nachricht niemals verloren geht.  In diesem Fall kann die Nachricht mehrmals zugestellt werden. </li><li>  Genau einmalige Lieferung.  Der heilige Gral der Nachrichtensysteme.  Alle Nachrichten werden ausschlieÃŸlich einmal zugestellt. </li></ul><br>  Das Wort "Lieferung" ist hier wahrscheinlich kein genauer Begriff.  Es wÃ¤re genauer, "Verarbeitung" zu sagen.  In jedem Fall interessiert uns jetzt, ob der Verbraucher Nachrichten verarbeiten kann und nach welchem â€‹â€‹Prinzip dies geschieht: â€nicht mehr als eineâ€œ, â€mindestens eineâ€œ oder â€streng einmalâ€œ.  Das Wort "Verarbeitung" erschwert jedoch die Wahrnehmung, und der Ausdruck "Zustellung nach dem Prinzip" streng einmal "" ist in diesem Fall keine genaue Definition, da die Nachricht mÃ¶glicherweise zweimal zugestellt werden muss, um sie einmal ordnungsgemÃ¤ÃŸ zu verarbeiten.  Wenn der EmpfÃ¤nger wÃ¤hrend der Verarbeitung die Verbindung getrennt hat, muss die Nachricht erneut an den neuen EmpfÃ¤nger gesendet werden. <br><br>  Der zweite.  Wenn wir das Problem der Nachrichtenverarbeitung diskutieren, kommen wir zum Thema Teilfehler, was Entwicklern Kopfschmerzen bereitet.  Bei der Verarbeitung der Nachricht gibt es mehrere Stufen.  Es besteht aus Kommunikationssitzungen zwischen der Anwendung und dem Nachrichtensystem am Anfang und am Ende und der Anwendung selbst, die mit den Daten in der Mitte arbeitet.  Teilanwendungsfehlerszenarien mÃ¼ssen von der Anwendung selbst behandelt werden.  Wenn die ausgefÃ¼hrten Operationen vollstÃ¤ndig transaktional sind und die Ergebnisse nach dem Prinzip â€Alles oder Nichtsâ€œ formuliert sind, kÃ¶nnen Teilfehler in der Anwendungslogik vermieden werden.  Viele Phasen umfassen jedoch hÃ¤ufig die Interaktion mit anderen Systemen, in denen TransaktionsmÃ¶glichkeiten unmÃ¶glich sind.  Wenn wir die Beziehungen zwischen Nachrichtensystemen, Anwendungen, Cache und Datenbank in die Interaktion einbeziehen, kÃ¶nnen wir die Verarbeitung nur einmal garantieren?  Die Antwort ist nein. <br><br>  Die Strategie "streng einmal" beschrÃ¤nkt sich auf ein Szenario, in dem der einzige EmpfÃ¤nger verarbeiteter Nachrichten die Messaging-Plattform selbst ist und diese Plattform selbst vollstÃ¤ndige Transaktionen bereitstellt.  In diesem eingeschrÃ¤nkten Szenario kÃ¶nnen Sie Nachrichten verarbeiten, schreiben und Signale senden, dass sie im Rahmen einer Transaktion verarbeitet wurden, die nach dem Prinzip "Alles oder Nichts" durchgefÃ¼hrt wurde.  Es wird von der Kafka Streams-Bibliothek bereitgestellt. <br><br>  Wenn die Nachrichtenverarbeitung jedoch immer idempotent ist, kÃ¶nnen Sie vermeiden, dass die Strategie â€nur einmalâ€œ durch Transaktionen implementiert werden muss.  Wenn die endgÃ¼ltige Verarbeitung von Nachrichten idempotent ist, kÃ¶nnen Sie sich Sorgen machen, Duplikate zu akzeptieren.  Es kÃ¶nnen jedoch nicht alle Aktionen idempotent implementiert werden. <br><br>  <b>End-to-End-Alarm</b> <br><br>  Was auf keinem GerÃ¤t aller Messagingsysteme, mit denen ich gearbeitet habe, dargestellt wird, ist eine End-to-End-BestÃ¤tigung.  Da eine Nachricht in RabbitMQ in die Warteschlange gestellt werden kann, ist eine End-to-End-Benachrichtigung nicht sinnvoll.  In Kafka kÃ¶nnen auf Ã¤hnliche Weise mehrere verschiedene EmpfÃ¤ngergruppen gleichzeitig Informationen aus einem Thema lesen.  Nach meiner Erfahrung sind End-to-End-Warnungen das, wonach Personen, die mit dem Konzept des Messaging noch nicht vertraut sind, hÃ¤ufig fragen.  In solchen FÃ¤llen ist es am besten, sofort zu erklÃ¤ren, dass dies nicht mÃ¶glich ist. <br><br>  <b>Verantwortungskette</b> <br><br>  Im GroÃŸen und Ganzen kÃ¶nnen Nachrichtenquellen nicht wissen, dass ihre Nachrichten an EmpfÃ¤nger Ã¼bermittelt werden.  Sie kÃ¶nnen nur wissen, dass das Nachrichtensystem ihre Nachrichten empfangen und die Verantwortung fÃ¼r die sichere Speicherung und Zustellung Ã¼bernommen hat.  Es gibt eine Verantwortungskette, die mit der Quelle beginnt, das Nachrichtensystem durchlÃ¤uft und beim EmpfÃ¤nger endet.  Jeder sollte seine Pflichten korrekt erfÃ¼llen und die Botschaft klar an den nÃ¤chsten weitergeben.  Dies bedeutet, dass Sie als Entwickler Ihre Anwendungen korrekt gestalten mÃ¼ssen, um den Verlust oder Missbrauch von Nachrichten zu verhindern, wÃ¤hrend diese unter Ihrer Kontrolle stehen. <br><br>  <b>Verfahren zur NachrichtenÃ¼bertragung</b> <br><br>  Dieser Artikel befasst sich hauptsÃ¤chlich damit, wie jede Plattform Sendestrategien "mindestens eine" und "nicht mehr als eine" bereitstellt.  Es gibt jedoch noch eine Nachrichtenreihenfolge.  In den vorherigen Teilen dieser Serie habe ich Ã¼ber die Reihenfolge, in der Nachrichten gesendet werden, und die Reihenfolge, in der sie verarbeitet werden, geschrieben. Ich rate Ihnen, auf diese Teile zu verweisen. <br><br>  Kurz gesagt, sowohl RabbitMQ als auch Kafka bieten eine FIFO-Garantie (First In First Out).  RabbitMQ behÃ¤lt diese Reihenfolge auf Warteschlangenebene und Kafka auf Segmentierungsebene bei.  Die Auswirkungen solcher Entwurfsentscheidungen wurden in frÃ¼heren Artikeln erÃ¶rtert. <br><br>  <b>Liefergarantien in RabbitMQ</b> <br><br>  Liefergarantien werden gegeben: <br><br><ul><li>  NachrichtenzuverlÃ¤ssigkeit - Sie verschwinden nicht, wÃ¤hrend sie auf RabbitMQ gespeichert sind. </li><li>  Nachrichtenbenachrichtigungen - RabbitMQ tauscht Signale mit Absendern und EmpfÃ¤ngern aus. </li></ul><br><h4>  ZuverlÃ¤ssigkeitselemente </h4><br>  <b>Warteschlangenspiegelung</b> <br><br>  Warteschlangen kÃ¶nnen auf vielen Knoten (Servern) gespiegelt (repliziert) werden.  Jede Warteschlange hat eine fÃ¼hrende Warteschlange an einem der Knoten.  Beispielsweise gibt es drei Knoten, 10 Warteschlangen und zwei Replikate pro Warteschlange.  10 Steuerwarteschlangen und 20 Replikate werden auf drei Knoten verteilt.  Die Verteilung der Steuerwarteschlangen nach Knoten kann konfiguriert werden.  Im Falle eines Knotenstopps: <br><br><ul><li>  Anstelle jeder fÃ¼hrenden Warteschlange auf dem blockierten Knoten wird eine Replik dieser Warteschlange auf einem anderen Knoten bereitgestellt. </li><li>  Auf anderen Knoten werden neue Replikate erstellt, um die verlorenen Replikate auf dem ausgehenden Knoten zu ersetzen und so den Replikationsfaktor zu unterstÃ¼tzen. </li></ul><br>  Das Problem der Fehlertoleranz wird im nÃ¤chsten Teil des Artikels erÃ¶rtert. <br><br>  <b>VertrauenswÃ¼rdige Warteschlangen</b> <br><br>  Es gibt zwei Arten von Warteschlangen in RabbitMQ: zuverlÃ¤ssig und unzuverlÃ¤ssig.  ZuverlÃ¤ssige Warteschlangen werden auf die Festplatte geschrieben und bei einem Neustart des Knotens gespeichert.  Wenn der Knoten gestartet wird, werden sie Ã¼berschrieben. <br><br>  <b>Dauerhafte BeitrÃ¤ge</b> <br><br>  Wenn die Warteschlange zuverlÃ¤ssig ist, bedeutet dies nicht, dass ihre Nachrichten beim Neustart des Knotens gespeichert werden.  Es werden nur Nachrichten wiederhergestellt, die vom Absender als dauerhaft markiert wurden. <br><br>  Bei der Arbeit an RabbitMQ ist die mÃ¶gliche Leistung umso geringer, je zuverlÃ¤ssiger die Nachricht ist.  Wenn es einen Strom von Echtzeitereignissen gibt und es nicht kritisch ist, mehrere davon oder ein kleines Zeitintervall des Stroms zu verlieren, ist es besser, die Warteschlangenreplikation nicht zu verwenden und alle Nachrichten als instabil zu Ã¼bertragen.  Wenn es jedoch unerwÃ¼nscht ist, Nachrichten aufgrund einer Fehlfunktion eines Knotens zu verlieren, ist es besser, zuverlÃ¤ssige Warteschlangen mit Replikation und stabilen Nachrichten zu verwenden. <br><br><h4>  Nachrichtenbenachrichtigungen </h4><br>  <b>Messaging</b> <br><br>  Nachrichten kÃ¶nnen wÃ¤hrend der Ãœbertragung verloren gehen oder dupliziert werden.  Dies hÃ¤ngt vom Verhalten des Absenders ab. <br><br>  <i>"Geschossen und vergessen"</i> <br><br>  Die Quelle kann beschlieÃŸen, keine BestÃ¤tigung vom EmpfÃ¤nger anzufordern (Benachrichtigung Ã¼ber den Empfang einer Nachricht an den Absender) und die Nachricht einfach automatisch zu senden.  Nachrichten werden nicht dupliziert, kÃ¶nnen jedoch verloren gehen (was der Strategie â€maximal einmalige Zustellungâ€œ entspricht). <br><br>  <i>BestÃ¤tigungen an den Absender</i> <br><br>  Wenn der Absender einen Kanal fÃ¼r den Warteschlangenbroker Ã¶ffnet, kann er denselben Kanal zum Senden von BestÃ¤tigungen verwenden.  Als Antwort auf die empfangene Nachricht muss der Warteschlangenbroker nun eines von zwei Dingen bereitstellen: <br><br><ul><li>  basic.ack.  Positive BestÃ¤tigung.  Die Nachricht wird empfangen, die Verantwortung dafÃ¼r liegt jetzt bei RabbitMQ; </li><li>  basic.nack.  Negative BestÃ¤tigung.  Es ist etwas passiert und die Nachricht wurde nicht verarbeitet.  Die Verantwortung dafÃ¼r bleibt bei der Quelle.  Auf Wunsch kann er ein zweites Mal eine Nachricht senden. </li></ul><br>  ZusÃ¤tzlich zu den positiven und negativen Zustellbenachrichtigungen wird eine basic.return-Nachricht bereitgestellt.  Manchmal muss der Absender nicht nur wissen, dass die Nachricht in RabbitMQ angekommen ist, sondern auch, dass sie wirklich in eine oder mehrere Warteschlangen gefallen ist.  Es kann vorkommen, dass die Quelle eine Nachricht an das Themenaustauschsystem sendet, in dem die Nachricht nicht an eine der Ãœbermittlungswarteschlangen weitergeleitet wird.  In dieser Situation verwirft der Broker die Nachricht einfach.  In einigen Szenarien ist dies normal, in anderen muss die Quelle wissen, ob die Nachricht verworfen wurde, und entsprechend weiter vorgehen.  Sie kÃ¶nnen das Flag "Obligatorisch" fÃ¼r einzelne Nachrichten setzen. Wenn die Nachricht in keiner Zustellwarteschlange definiert wurde, wird basic.return an den Absender zurÃ¼ckgegeben. <br><br>  Die Quelle wartet mÃ¶glicherweise nach dem Senden jeder Nachricht auf eine BestÃ¤tigung, dies verringert jedoch die Leistung erheblich.  Stattdessen kÃ¶nnen Quellen einen stetigen Strom von Nachrichten senden, wodurch die Anzahl der nicht bestÃ¤tigten Nachrichten begrenzt wird.  Wenn das Limit fÃ¼r die Zwischennachricht erreicht ist, wird das Senden angehalten, bis alle BestÃ¤tigungen eingegangen sind. <br><br>  Da jetzt viele Nachrichten vom Absender an RabbitMQ Ã¼bertragen werden, werden BestÃ¤tigungen mithilfe des Mehrfachflags gruppiert, um die Leistung zu verbessern.  Allen Ã¼ber den Kanal gesendeten Nachrichten wird ein monoton ansteigender ganzzahliger Wert zugewiesen, die â€Sequenznummerâ€œ.  Die Benachrichtigung einer Nachricht enthÃ¤lt die Sequenznummer der entsprechenden Nachricht.  Und wenn gleichzeitig der Wert multiple = true ist, muss der Absender die Sequenznummern seiner Nachrichten verfolgen, um zu wissen, welche Nachrichten erfolgreich zugestellt wurden und welche nicht.  Ich habe einen ausfÃ¼hrlichen Artikel zu diesem Thema geschrieben. <br><br>  Dank BestÃ¤tigungen vermeiden wir Nachrichtenverlust auf folgende Weise: <br><br><ul><li>  erneutes Senden von Nachrichten im Falle einer negativen Benachrichtigung; </li><li>  Fortsetzung der Speicherung von Nachrichten irgendwo im Falle einer negativen Benachrichtigung oder einer grundlegenden RÃ¼ckgabe. </li></ul><br>  <i>Transaktionen</i> <br><br>  Transaktionen werden in RabbitMQ aus folgenden GrÃ¼nden selten verwendet: <br><br><ul><li>  Schwache Garantien.  Wenn Nachrichten an mehrere Warteschlangen weitergeleitet werden oder ein obligatorisches Symbol haben, wird die TransaktionskontinuitÃ¤t nicht unterstÃ¼tzt. </li><li>  Geringe ProduktivitÃ¤t. </li></ul><br>  Ehrlich gesagt, ich habe sie nie verwendet, sie geben keine zusÃ¤tzlichen Garantien, auÃŸer BestÃ¤tigungen an den Absender, und erhÃ¶hen nur die Unsicherheit in der Frage, wie die BestÃ¤tigung des Empfangs von Nachrichten zu interpretieren ist, die sich aus dem Abschluss von Transaktionen ergeben. <br><br>  <i>Kommunikations- / Kanalfehler</i> <br><br>  ZusÃ¤tzlich zu den Benachrichtigungen Ã¼ber den Empfang von Nachrichten muss der Absender die Fehler von Kommunikationstools und Brokern berÃ¼cksichtigen.  Beide Faktoren fÃ¼hren zum Verlust des Kommunikationskanals.  Mit dem Verlust von KanÃ¤len verschwindet die MÃ¶glichkeit, noch nicht empfangene Benachrichtigungen Ã¼ber den Empfang von Nachrichten zu erhalten.  Hier muss der Absender zwischen dem Risiko eines Nachrichtenverlusts und dem Risiko einer VervielfÃ¤ltigung wÃ¤hlen. <br><br>  Ein Brokerfehler kann auftreten, wenn sich die Nachricht im Betriebssystempuffer befand oder vorverarbeitet wurde und die Nachricht dann verloren geht.  Oder vielleicht wurde die Nachricht in die Warteschlange gestellt, aber der Nachrichtenbroker ist vor dem Senden einer BestÃ¤tigung gestorben.  In diesem Fall wird die Nachricht erfolgreich zugestellt. <br><br>  Ebenso wirkt sich der Ausfall der Kommunikationsmittel auf die Situation aus.  Ist wÃ¤hrend der Ãœbertragung der Nachricht ein Fehler aufgetreten?  Oder nachdem die Nachricht in die Warteschlange gestellt wurde, aber bevor eine positive Benachrichtigung empfangen wurde? <br><br>  Der Absender kann dies nicht feststellen und muss daher eine der folgenden Optionen auswÃ¤hlen: <br><br><ul><li>  Leiten Sie die Nachricht nicht weiter, da sonst das Risiko eines Verlusts besteht. </li><li>  Senden Sie die Nachricht erneut und es besteht die Gefahr von Duplikaten. </li></ul><br>  Wenn viele Absendernachrichten Ã¼bertragen werden, wird das Problem komplizierter.  Der Absender kann den EmpfÃ¤ngern nur einen Hinweis geben, indem er der Nachricht einen speziellen Header hinzufÃ¼gt, der angibt, dass die Nachricht ein zweites Mal gesendet wird.  EmpfÃ¤nger kÃ¶nnen entscheiden, Nachrichten auf das Vorhandensein solcher Header zu Ã¼berprÃ¼fen und, falls sie gefunden werden, zusÃ¤tzlich nach empfangenen Nachrichten auf Duplikate zu suchen (falls eine solche ÃœberprÃ¼fung zuvor nicht durchgefÃ¼hrt wurde). <br><br><h4>  EmpfÃ¤nger </h4><br>  EmpfÃ¤ngern stehen zwei Optionen zum Empfangen von Benachrichtigungen zur VerfÃ¼gung: <br><br><ul><li>  kein Benachrichtigungsmodus; </li><li>  manueller Benachrichtigungsmodus. </li></ul><br>  <i>Kein Benachrichtigungsmodus</i> <br><br>  Er ist ein Modus fÃ¼r automatische Benachrichtigungen.  Und er ist gefÃ¤hrlich.  Erstens, denn wenn eine Nachricht in Ihre Anwendung gelangt, wird sie aus der Warteschlange entfernt.  Dies kann zu Nachrichtenverlust fÃ¼hren, wenn: <br><br><ul><li>  Die Verbindung wurde unterbrochen, bevor die Nachricht empfangen wurde. </li><li>  Die Nachricht befindet sich noch im internen Puffer und die Anwendung wurde deaktiviert. </li><li>  Nachrichtenverarbeitung fehlgeschlagen. </li></ul><br>  DarÃ¼ber hinaus verlieren wir Gegendruckmechanismen, um die QualitÃ¤t der NachrichtenÃ¼bermittlung zu Ã¼berwachen.  Durch Einstellen des Modus zum manuellen Senden von Benachrichtigungen kÃ¶nnen Sie einen Prefetch (oder die Stufe der bereitgestellten Dienste, QoS) festlegen, um die einmalige Anzahl von Nachrichten zu begrenzen, deren Empfang vom System noch nicht bestÃ¤tigt wurde.  Ohne dies sendet RabbitMQ Nachrichten so schnell, wie es die Verbindung zulÃ¤sst, und dies kann schneller sein, als der EmpfÃ¤nger sie verarbeiten kann.  Infolgedessen sind die Puffer voll und es treten Speicherfehler auf. <br><br>  <i>Manueller Benachrichtigungsmodus</i> <br><br>  Der EmpfÃ¤nger muss manuell eine Benachrichtigung Ã¼ber den Empfang jeder Nachricht senden.  Er kann einen Prefetch festlegen, falls die Anzahl der Nachrichten mehr als eins betrÃ¤gt, und viele Nachrichten gleichzeitig verarbeiten.  Er kann entscheiden, fÃ¼r jede Nachricht eine Benachrichtigung zu senden, oder er kann das Mehrfachflag anwenden und mehrere Benachrichtigungen gleichzeitig senden.  Das Gruppieren von Benachrichtigungen verbessert die Leistung. <br><br>  Wenn der EmpfÃ¤nger den Kanal Ã¶ffnet, enthalten die Nachrichten, die ihn durchlaufen, den Parameter Delivery Tag, dessen Wert eine ganzzahlige, monoton ansteigende Zahl ist.  Es ist in jeder EmpfangsbestÃ¤tigung enthalten und wird als Nachrichtenkennung verwendet. <br><br>  Benachrichtigungen kÃ¶nnen wie folgt sein: <br><br><ul><li>  basic.ack.  Danach entfernt RabbitMQ die Nachricht aus der Warteschlange.  Das Mehrfachflag kann hier angewendet werden. </li><li>  basic.nack.  Der EmpfÃ¤nger muss ein Flag setzen, um RabbitMQ mitzuteilen, ob die Nachricht erneut in die Warteschlange gestellt werden soll.  Beim ZurÃ¼cksetzen geht die Nachricht an den Anfang der Warteschlange.  Von dort wird es erneut an den EmpfÃ¤nger gesendet (sogar an denselben EmpfÃ¤nger).  Die basic.nack-Benachrichtigung unterstÃ¼tzt das Mehrfachflag. </li><li>  basic.reject.  Entspricht basic.nack, unterstÃ¼tzt jedoch nicht das Mehrfachflag. </li></ul><br>  Somit sind semantisch basic.ack und basic.nack mit Requeue = false identisch.  Beide Operatoren bedeuten das Entfernen einer Nachricht aus der Warteschlange. <br><br>  Die nÃ¤chste Frage ist, wann EmpfangsbestÃ¤tigungen gesendet werden sollen.  Wenn die Nachricht schnell verarbeitet wurde, mÃ¶chten Sie mÃ¶glicherweise sofort nach Abschluss dieses Vorgangs eine Benachrichtigung senden (erfolgreich oder nicht erfolgreich).  Aber wenn sich die Nachricht in der RabbitMQ-Warteschlange befand und die Verarbeitung viele Minuten dauert?  Das Senden einer Benachrichtigung danach ist problematisch, da beim SchlieÃŸen des Kanals alle Nachrichten, an die keine Benachrichtigungen gesendet wurden, an die Warteschlange zurÃ¼ckgegeben werden und das Senden ein zweites Mal erfolgt. <br><br>  <b>Verbindungs- / Nachrichtenbrokerfehler</b> <br><br>  Wenn die Verbindung getrennt wurde oder ein Fehler im Broker aufgetreten ist, nach dem der Kanal nicht mehr funktioniert, werden alle Nachrichten, deren Empfang nicht bestÃ¤tigt wurde, erneut in die Warteschlange gestellt und weitergeleitet.  Dies ist gut, weil es Datenverlust verhindert, aber schlecht, weil es Ã¼bermÃ¤ÃŸige Duplizierung verursacht. <br><br>  Je lÃ¤nger der EmpfÃ¤nger Ã¼ber einen lÃ¤ngeren Zeitraum Nachrichten hat, deren Empfang er nicht bestÃ¤tigt hat, desto hÃ¶her ist das Risiko einer Weiterleitung.  Wenn eine Nachricht erneut gesendet wird, wird RabbitMQ fÃ¼r das Weiterleitungsflag auf true gesetzt.  Aus diesem Grund hat der EmpfÃ¤nger zumindest einen Hinweis darauf, dass die Nachricht mÃ¶glicherweise bereits verarbeitet wurde. <br><br>  <b>Idempotenz</b> <br><br>  Wenn eine Idempotenz erforderlich ist und garantiert, dass keine Nachricht verloren geht, sollten einige doppelte ÃœberprÃ¼fungen oder andere idempotente Schemata eingebaut werden.  Wenn das ÃœberprÃ¼fen auf doppelte Nachrichten zu teuer ist, kÃ¶nnen Sie eine Strategie anwenden, bei der der Absender immer einen speziellen Header zum erneuten Senden von Nachrichten hinzufÃ¼gt und der EmpfÃ¤nger die empfangenen Nachrichten auf das Vorhandensein eines solchen Headers und eines erneuten Sendeflags Ã¼berprÃ¼ft. <br><br><h4>  Fazit </h4><br>  RabbitMQ bietet zuverlÃ¤ssige, langfristige Messaging-Garantien, aber es gibt viele Situationen, in denen sie nicht helfen. <br><br>  Hier ist eine Liste von Punkten, an die Sie sich erinnern sollten: <br><br><ul><li>  Sie sollten Warteschlangenspiegelung, zuverlÃ¤ssige Warteschlangen, dauerhafte Nachrichten, BestÃ¤tigungen fÃ¼r den Absender, ein BestÃ¤tigungsflag und eine erzwungene Benachrichtigung des EmpfÃ¤ngers verwenden, wenn zuverlÃ¤ssige Garantien fÃ¼r die Strategie "mindestens einmalige Zustellung" erforderlich sind. </li><li>  Wenn das Senden im Rahmen der Strategie â€mindestens einmalige Zustellungâ€œ durchgefÃ¼hrt wird, mÃ¼ssen Sie mÃ¶glicherweise einen Mechanismus fÃ¼r die Deduplizierung oder Idempotenz hinzufÃ¼gen, wenn Sie die gesendeten Daten duplizieren. </li><li>  Wenn das Problem des Nachrichtenverlusts nicht so wichtig ist wie das Problem der Zustellgeschwindigkeit und der hohen Skalierbarkeit, denken Sie an Systeme ohne Redundanz, ohne persistente Nachrichten und ohne BestÃ¤tigung auf der Quellseite.  Trotzdem wÃ¼rde ich es vorziehen, erzwungene Benachrichtigungen vom EmpfÃ¤nger zu hinterlassen, um den Fluss empfangener Nachrichten durch Ã„ndern der Prefetch-EinschrÃ¤nkungen zu steuern.  In diesem Fall mÃ¼ssen Sie Benachrichtigungen stapelweise senden und das Flag "Mehrfach" verwenden. </li></ul><br>  <b>Liefergarantien in Kafka</b> <br><br>  Liefergarantien werden gegeben: <br><br><ul><li>  NachrichtenbestÃ¤ndigkeit - In einem Segment gespeicherte Nachrichten gehen nicht verloren. </li><li>  Nachrichtenbenachrichtigungen - der Austausch von Signalen zwischen Kafka (und mÃ¶glicherweise dem Apache Zookeeper-Repository) einerseits und der Quelle / dem EmpfÃ¤nger andererseits. </li></ul><br>  <b>Zwei Worte zur Nachrichtenverpackung</b> <br><br>  Einer der Unterschiede zwischen RabbitMQ und Kafka ist die Verwendung von Paketen fÃ¼r Messaging. <br><br>  RabbitMQ bietet etwas Ã„hnliches wie Verpackung dank: <br><br><ul><li>  Unterbrechen Sie das Senden aller X-Nachrichten, bis alle Benachrichtigungen empfangen wurden.  RabbitMQ gruppiert Benachrichtigungen normalerweise mit dem Flag "multiple". </li><li>    Â«prefetchÂ»      Â«multipleÂ». </li></ul><br>       .                  â€œmultipleâ€.     TCP. <br><br> Kafka     .    ,           .     RabbitMQ,      ,    ,      .         ,         . <br><br> Kafka        ,      ,     .      ,          .     RabbitMQ   API    ,                  . RabbitMQ         . <br><br> <b>,  </b> <br><br> <i> </i> <br><br>      Kafka   -    ,       ,      .       .   ,   ,  , ,        ,      . <br><br> Kafka     (In Sync Replicas, ISR).          .        ,   ,     (   10 ).    ,      .    -  ,       ..               .        . <br><br> <i>      </i> <br><br>  ,  Kafka  ,  ,    , Kafka               . <br><br> <i>     </i> <br><br>    ,     Kafka,      ,    : <br><br><ul><li>  ,  . Acks=0. </li><li>     . Acks=1 </li><li>           . Acks=All </li></ul><br>          ,    RabbitMQ.         ,      ,        (   ,    ).   ,          . <br><br>   Kafka       .        : <br><br><ul><li>  enable.idempotence   â€œtrueâ€, </li><li>  max.in.flight.requests.per.connection   5  , </li><li>  retries   1  , </li><li>  acks   â€œallâ€. </li></ul><br> ,          acks=0/1   ,     . <br><br> <i>  </i> <br><br>        ,           ,   .       ZooKeeper    Kafka. <br><br>        (),       ,       : <br><br><ul><li>  In regelmÃ¤ÃŸigen AbstÃ¤nden.          .                 .          .         ,      . </li><li> ,    .      â€œ   â€.    ,      ;     ,    . ,  10         ,    4 ,   ,      ,     ; </li><li>  ,    .      â€œ   â€.  ,      ,      ,           . ,  10         ,       ,  4    ; </li><li> .    ,     . </li></ul><br>  â€œ  â€  Kafka Streams,    Java.   Java      .    â€œ  â€,      ,    ,           . ,         ,      â€œ  â€  .           ,       ,   ()      . <br><br> ,  Kafka Streams,          ,       ,      â€œ  â€.       Kafka:             .    ,    .    ,    ,   ,        (   ),   . <br><br> <b>    </b> <br><br>      Kafka     â€œ--â€.         .   ,   ,  . <br><br>        â€œ â€,    ,      (,  , ).      â€œ â€,    ,      .       . <br><br>   :    â€œ  â€      ?    .        ,     ,    .     .     (Last Stable Offset, LSO) â€”      ;     â€œ  â€      . <br><br>  <b>Schlussfolgerungen</b> <br><br>         .   ,    ,      .   ,     Kafka      ,                . <br><br><h4>  Zusammenfassend </h4><br><ul><li>      â€œ   â€  â€œ   â€. </li><li>     . </li><li>      ,              . Kafka    ,      . </li><li>       ,   ,        . </li><li>        . </li><li> Kafka   ,      â€œ--â€.          . </li><li>  Kafka,       -         ,        (   ).  RabbitMQ    . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kafka kann die Vorteile der Paketierung aufgrund seiner Paketverteilungsfunktionen erhÃ¶hen, und RabbitMQ verfÃ¼gt aufgrund eines passiven Empfangsmodells, das EmpfÃ¤ngerkonflikte nicht verhindert, nicht Ã¼ber eine Paketierung. </font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437446/">https://habr.com/ru/post/de437446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437436/index.html">AusfÃ¼hren des Bildbetrachters unter Windows XP unter modernem Windows</a></li>
<li><a href="../de437438/index.html">Audiotechnologie: Wie werden Kunststoffteile mit Ultraschall bewegt und warum wird sie benÃ¶tigt?</a></li>
<li><a href="../de437440/index.html">GlÃ¼cklicher Studententag, Programmierer</a></li>
<li><a href="../de437442/index.html">Antworten des technischen Supports von 3CX: Konfigurieren Sie den Router fÃ¼r den PBX-VoIP-Server</a></li>
<li><a href="../de437444/index.html">Ein Eimer Teer in einem Fass Honig oder Ãœber einen mÃ¶glichen kulturellen Schock fÃ¼r Traktorbesitzer</a></li>
<li><a href="../de437448/index.html">28. Januar in Russland, das System der schnellen Zahlungen ohne Provision (per Telefonnummer)</a></li>
<li><a href="../de437450/index.html">Wie ich OpenCV kennengelernt habe oder auf der Suche nach ColorChecker</a></li>
<li><a href="../de437454/index.html">Arithmometer Felix M Bewertung</a></li>
<li><a href="../de437456/index.html">JÃ¼nger: ÃœberprÃ¼fung der Snom D315- und D305-IP-Telefone</a></li>
<li><a href="../de437458/index.html">Obligatorische Registrierung durch IMEI bieten an, bezahlt zu machen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>