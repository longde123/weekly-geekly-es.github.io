<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßë üë®üèø‚Äçüíº üßëüèΩ‚Äçü§ù‚Äçüßëüèº Redes de Kubernetes: Pods ü§±üèº üë®üèΩ‚Äçüè≠ üëÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El material, cuya traducci√≥n publicamos hoy, est√° dedicado a las caracter√≠sticas de la red de hogares Kubernetes. Est√° destinado a aquellos que ya tie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Redes de Kubernetes: Pods</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/441576/">  El material, cuya traducci√≥n publicamos hoy, est√° dedicado a las caracter√≠sticas de la red de hogares Kubernetes.  Est√° destinado a aquellos que ya tienen algo de experiencia con Kubernetes.  Si no est√° muy versado en Kubernetes, entonces probablemente valga la pena leer este tutorial de Kubernetes antes de leer este material, donde trabajar con esta plataforma se considera para principiantes. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/0_/ch/6q/0_ch6qrxl9vydilgtpyci7diugw.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Vainas</font> </h2><br>  ¬øQu√© hay debajo de (pod) Kubernetes?  Sub es una entidad que consta de uno o m√°s contenedores alojados en el mismo host y configurados para compartir recursos de pila de red y otros recursos como vol√∫menes.  Los pods son los componentes b√°sicos que componen las aplicaciones que se ejecutan en la plataforma Kubernetes.  Las vainas comparten una pila de red.  En la pr√°ctica, esto significa que todos los contenedores que forman el hogar pueden comunicarse entre s√≠ a trav√©s de <code>localhost</code> .  Si hay un contenedor en el hogar que ejecuta nginx, escuchando en el puerto 80, y otro contenedor que ejecuta scrapyd, este contenedor puede acceder al primer contenedor en <code>http://localhost:80</code> .  No se ve tan dif√≠cil.  Ahora pregunt√©monos c√≥mo funciona esto realmente.  Echemos un vistazo a una situaci√≥n t√≠pica cuando el contenedor Docker se inicia en la m√°quina local. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/641/7fe/52a/6417fe52a2e9de3296187860905907f7.png"></div><br>  <i><font color="#999999">Contenedor Docker ejecut√°ndose en una m√°quina local</font></i> <br><br>  Si observa este esquema de arriba a abajo, resulta que hay una interfaz de red f√≠sica <code>eth0</code> .  El puente <code>docker0</code> est√° <code>docker0</code> y la interfaz de red virtual <code>docker0</code> est√° <code>veth0</code> al puente.  Tenga en cuenta que las <code>veth0</code> <code>docker0</code> y <code>veth0</code> est√°n en la misma red, en este ejemplo es <code>172.17.0.0/24</code> .  En esta red, a <code>docker0</code> asigna la direcci√≥n IP <code>172.17.0.1</code> , esta interfaz es la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puerta</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace predeterminada</a> para <code>veth0</code> , a la que se le asigna la direcci√≥n <code>172.17.0.2</code> .  Debido a las peculiaridades de configurar espacios de nombres de red al iniciar el contenedor, los procesos dentro del contenedor solo ven la interfaz <code>veth0</code> e interact√∫an con el mundo exterior a trav√©s de las interfaces <code>docker0</code> y <code>eth0</code> .  Ahora ejecuta el segundo contenedor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b4/33a/915/8b433a91572e4afa0f9652d4e729a8b3.png"></div><br>  <i><font color="#999999">Dos contenedores Docker ejecut√°ndose en la m√°quina local.</font></i> <br><br>  Como puede ver en el diagrama anterior, la nueva interfaz de red virtual <code>veth1</code> se asigna al segundo contenedor, que est√° conectado al mismo puente que el primer contenedor, a <code>docker0</code> .  Esta es una descripci√≥n bastante concisa de lo que realmente est√° sucediendo.  Adem√°s, debe tenerse en cuenta que la conexi√≥n entre el contenedor y el puente se establece gracias a un par de interfaces Ethernet virtuales conectadas, una de las cuales est√° en el espacio de nombres del contenedor y la otra en el espacio de nombres de la red ra√≠z.  Los detalles sobre esto se pueden encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  Todo esto es bueno, pero a√∫n no describe lo que, cuando se aplica a los pods de Kubernetes, llamamos "pila de red compartida".  Afortunadamente, los espacios de nombres son muy flexibles.  Docker puede iniciar un contenedor y, en lugar de crear una nueva interfaz de red virtual para √©l, hacer que use la interfaz existente junto con otros contenedores.  Con este enfoque, tendremos que cambiar el esquema anterior como se muestra a continuaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/456/4f6/5fb/4564f65fb5ed8773794f98f7655f0523.png"></div><br>  <i><font color="#999999">Los contenedores usan una interfaz de red com√∫n</font></i> <br><br>  Ahora el segundo contenedor interact√∫a con la interfaz <code>veth0</code> ya existente, y no con su propia interfaz <code>veth1</code> , como lo fue en el ejemplo anterior.  El uso de tal esquema conlleva varias consecuencias.  Para empezar, ahora podemos decir que ambos contenedores son visibles externamente en la misma direcci√≥n: <code>172.17.0.2</code> , y dentro de cada uno de ellos pueden acceder a los puertos en <code>localhost</code> abiertos por otro contenedor.  Adem√°s, esto significa que estos contenedores no pueden abrir los mismos puertos.  Esto, por supuesto, es una limitaci√≥n, pero no difiere de una limitaci√≥n similar en la situaci√≥n cuando varios procesos abren puertos en el mismo host.  Con este enfoque, un conjunto de procesos obtiene todas las ventajas asociadas con la ejecuci√≥n de estos procesos en contenedores, como la conectividad y el aislamiento deficientes, pero al mismo tiempo, los procesos pueden organizar la colaboraci√≥n en los entornos de red existentes m√°s simples. <br><br>  Kubernetes implementa este patr√≥n creando un contenedor especial para cada hogar cuyo √∫nico prop√≥sito es proporcionar una interfaz de red para otros contenedores de hogar.  Si se conecta al nodo del cl√∫ster de Kubernetes al que ssh le asigna un sub espec√≠fico y ejecuta el <code>docker ps</code> , ver√° al menos un contenedor ejecut√°ndose con el comando de <code>pause</code> .  Este comando detiene el proceso actual hasta que llega una se√±al <code>SIGTERM</code> .  Dichos contenedores no hacen absolutamente nada, est√°n en un estado de "suspensi√≥n" y est√°n esperando esta se√±al.  A pesar de que los contenedores "suspendidos" no hacen nada, son, por as√≠ decirlo, el "coraz√≥n" del hogar, proporcionando a otros contenedores una interfaz de red virtual que pueden usar para interactuar entre ellos o con el mundo exterior.  Como resultado, resulta que en un entorno hipot√©tico parecido a nuestro esquema anterior, se ver√≠a como el que se muestra a continuaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b0/e06/d66/3b0e06d66041a5dd0946f43c94314dae.png"></div><br>  <i><font color="#999999">Contenedores hipot√©ticos</font></i> <br><br><h2>  <font color="#3AC1EF">Red de hogar</font> </h2><br>  Uno debajo, lleno de contenedores, es el componente b√°sico de un determinado sistema, pero hasta ahora no es este sistema en s√≠.  La arquitectura de Kubernetes se basa en el requisito de que los pods puedan interactuar con otros pods independientemente de si se ejecutan en la misma computadora o en m√°quinas diferentes.  Para aprender c√≥mo funciona todo esto, necesitamos ir a un nivel m√°s alto de abstracci√≥n y hablar sobre c√≥mo funcionan los nodos en el cl√∫ster de Kubernetes.  Aqu√≠ cubriremos el tema del enrutamiento y las rutas de la red.  Este tema a menudo se evita en materiales como este, ya que lo considera demasiado complejo.  No es f√°cil encontrar una gu√≠a comprensible y no demasiado larga para el enrutamiento IP, pero si desea ver una breve descripci√≥n general de este problema, puede echar un vistazo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> material. <br><br>  El cl√∫ster de Kubernetes consta de un nodo o m√°s nodos.  Un nodo es un sistema host, f√≠sico o virtual, que contiene varias herramientas de software y sus dependencias (principalmente Docker), as√≠ como varios componentes del sistema Kubernetes.  El nodo est√° conectado a la red, lo que le permite intercambiar datos con otros nodos en el cl√∫ster.  As√≠ es como podr√≠a verse un cl√∫ster simple de dos nodos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/477/db1/b20/477db1b2030b13c41178a48821916fcc.png"></div><br>  <i><font color="#999999">Un cl√∫ster simple de dos nodos</font></i> <br><br>  Si el cl√∫ster en cuesti√≥n se ejecuta en un entorno de nube como GCP o AWS, entonces este esquema transmite con bastante precisi√≥n la esencia de la arquitectura de red predeterminada para proyectos individuales.  Para fines de demostraci√≥n, <code>10.100.0.0/24</code> utiliz√≥ la red privada <code>10.100.0.0/24</code> en este ejemplo.  Como resultado, la direcci√≥n <code>10.100.0.1</code> asigna al <code>10.100.0.1</code> y las direcciones <code>10.100.0.2</code> y <code>10.100.0.3</code> dos nodos.  Usando esta arquitectura, cada uno de los nodos puede interactuar con el otro usando su interfaz de red <code>eth0</code> .  Ahora recordemos que debajo, ejecut√°ndose en el host, no est√° en esta red privada.  Est√° conectado al puente en una red completamente diferente.  Esta es una red virtual que existe solo dentro de un nodo espec√≠fico.  Para hacerlo m√°s claro, redibujemos el esquema anterior, agregando lo que llamamos un hogar hipot√©tico arriba. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff6/721/c32/ff6721c32b5d74bc80fccfbf6164e486.png"></div><br>  <i><font color="#999999">Vainas y nodos</font></i> <br><br>  El host ubicado a la izquierda de este diagrama tiene una interfaz <code>eht0</code> con la direcci√≥n <code>10.100.0.2</code> , <code>10.100.0.2</code> puerta de enlace predeterminada es el enrutador con la direcci√≥n <code>10.100.0.1</code> .  El puente <code>docker0</code> con la direcci√≥n <code>172.17.0.1</code> conectado a esta interfaz y, a trav√©s de la interfaz virtual <code>veth0</code> con la direcci√≥n <code>172.17.0.2</code> , est√° conectado lo que aqu√≠ llamamos hogar.  La interfaz <code>veth0</code> se cre√≥ en un contenedor suspendido.  Es visible en los tres contenedores a trav√©s de una pila de red compartida.  Debido al hecho de que las reglas de enrutamiento local se configuran al crear el puente, cualquier paquete que llegue a <code>eth0</code> y tenga la direcci√≥n de destino <code>172.17.0.2</code> ser√° redirigido al puente, que lo reenviar√° a la interfaz virtual <code>veth0</code> .  Si bien todo esto parece bastante decente.  Si se sabe que el host que estamos discutiendo tiene una direcci√≥n <code>172.17.0.2</code> , entonces podemos agregar una regla a la configuraci√≥n del enrutador que describa que la pr√≥xima transici√≥n para esta direcci√≥n es <code>10.100.0.2</code> , despu√©s de lo cual los paquetes desde all√≠ deben redirigirse a <code>veth0</code> .  Excelente  Ahora echemos un vistazo a otro host. <br><br>  El host que se muestra en el diagrama de la derecha tiene una interfaz f√≠sica <code>eth0</code> con la direcci√≥n <code>10.100.0.3</code> .  Utiliza la misma puerta de enlace predeterminada: <code>10.100.0.1</code> y, de nuevo, est√° conectada al puente <code>docker0</code> con la direcci√≥n <code>172.17.0.1</code> .  Existe la sensaci√≥n de que no todo va tan bien.  Esta direcci√≥n, de hecho, puede diferir de la utilizada en el host ubicado a la izquierda.  Las direcciones de los puentes aqu√≠ se hacen las mismas para demostrar el peor escenario posible, que, por ejemplo, puede ocurrir si acaba de instalar Docker y lo deja funcionar como le plazca.  Pero incluso si las redes en cuesti√≥n son diferentes, nuestro ejemplo resalta un problema m√°s profundo, que es que los nodos generalmente no saben nada sobre qu√© direcciones privadas se asignan a los puentes ubicados en otros nodos.  Y necesitamos saber sobre esto, para poder enviar paquetes a estos puentes y asegurarnos de que llegar√°n a donde necesitan.  Obviamente, aqu√≠ necesitamos alg√∫n tipo de entidad, que nos permita garantizar la configuraci√≥n correcta de las direcciones en diferentes nodos. <br><br>  La plataforma Kubernetes nos brinda una soluci√≥n de dos pasos para este problema.  Primero, esta plataforma asigna un espacio de direcci√≥n com√∫n para puentes en cada nodo y luego asigna a los puentes las direcciones en este espacio en funci√≥n del nodo en el que se encuentra el puente.  En segundo lugar, Kubernetes agrega reglas de enrutamiento a la puerta de enlace ubicada, en nuestro caso, en <code>10.100.0.1</code> .  Estas reglas definen las reglas para enrutar paquetes destinados a cada uno de los puentes.  Es decir, describen a trav√©s de qu√© interfaz f√≠sica <code>eth0</code> se puede contactar con cada uno de los puentes.  Esta combinaci√≥n de interfaces de red virtual, puentes y reglas de enrutamiento se denomina com√∫nmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">red superpuesta</a> .  Hablando de Kubernetes, generalmente llamo a esta red una "red de hogar", ya que es una red superpuesta que permite que las unidades ubicadas en diferentes nodos se comuniquen entre s√≠.  As√≠ es como se ver√° el diagrama anterior despu√©s de que los mecanismos de Kubernetes se pongan manos a la obra. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9c/f87/c96/b9cf87c96d0169dbcd0846f8bb3cd323.png"></div><br>  <i><font color="#999999">Red de hogar</font></i> <br><br>  Inmediatamente llama la atenci√≥n que los nombres de los puentes se cambian de <code>docker0</code> a <code>cbr0</code> .  Kubernetes no utiliza puentes Docker est√°ndar.  Lo que llamamos <code>cbr</code> es una abreviatura de "puente personalizado", es decir, estamos hablando de algunos puentes especiales.  No estoy listo para dar una lista completa de las diferencias entre lanzar contenedores Docker en pods y ejecutarlos en computadoras comunes, pero de lo que estamos hablando aqu√≠ es de una de las diferencias similares importantes.  Adem√°s, debe prestar atenci√≥n al hecho de que el espacio de direcciones asignado a los puentes en este ejemplo es <code>10.0.0.0/14</code> .  Esta direcci√≥n est√° tomada de uno de nuestros cl√∫steres de etapas, que se implementan en la plataforma Google Cloud, por lo que lo anterior es un ejemplo muy real de una red de hogares.  A su cl√∫ster se le puede asignar un rango de direcciones completamente diferente.  Desafortunadamente, en este momento no hay forma de obtener informaci√≥n sobre estas direcciones usando la utilidad <code>kubectl</code> , pero, por ejemplo, si usa GCP, puede ejecutar un comando como los <code>gcloud container clusters describe &lt;cluster&gt;</code> y eche un vistazo a la propiedad <code>clusterIpv4Cidr</code> . <br><br>  En general, se puede observar que generalmente no tiene que pensar en c√≥mo funciona la red de hogares.  Cuando un subintercambio intercambia datos con otro hogar, la mayor√≠a de las veces esto sucede a trav√©s de los servicios de Kubernetes.  Este es un poco un proxy definido por software.  Pero las direcciones de red de los hogares aparecen en los registros.  En algunas situaciones, en particular durante la depuraci√≥n, es posible que deba establecer expl√≠citamente reglas de enrutamiento en redes de hogares.  Por ejemplo, el tr√°fico que deja a Kubernetes vinculado a cualquier direcci√≥n en el rango 10.0.0.0/8 no se procesa de manera predeterminada mediante NAT.  Por lo tanto, si interact√∫a con servicios ubicados en otra red privada que tiene el mismo rango de direcciones, es posible que necesite configurar reglas de enrutamiento que le permitir√°n organizar la entrega correcta de paquetes. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Hoy hablamos sobre los pods de Kubernetes y las caracter√≠sticas de sus redes.  Esperamos que este material lo ayude a dar los pasos correctos para implementar escenarios complejos de interacci√≥n de hogares en las redes de Kubernetes. <br><br>  <b>Estimados lectores!</b>  Este art√≠culo es el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primero de una</a> serie de redes de Kubernetes.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La segunda</a> parte de este ciclo ya ha sido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducida</a> .  Estamos pensando en traducir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tercera</a> parte.  Le pedimos que comente sobre esto en los comentarios. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441576/">https://habr.com/ru/post/441576/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441566/index.html">12 conceptos de JavaScript para conocer</a></li>
<li><a href="../441568/index.html">Gesti√≥n de memoria Python</a></li>
<li><a href="../441570/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 353 (del 17 al 24 de febrero de 2019)</a></li>
<li><a href="../441572/index.html">Frontend Weekly Digest (18-24 de febrero de 2019)</a></li>
<li><a href="../441574/index.html">Learning Docker Parte 6: Trabajar con datos</a></li>
<li><a href="../441578/index.html">Tutorial de React Parte 19: M√©todos del ciclo de vida de los componentes</a></li>
<li><a href="../441580/index.html">Tutorial React Parte 20: primera lecci√≥n de renderizado condicional</a></li>
<li><a href="../441582/index.html">Optimizaci√≥n del sistema de control LQR</a></li>
<li><a href="../441584/index.html">PHP Digest No. 150 (del 11 al 25 de febrero de 2019)</a></li>
<li><a href="../441586/index.html">C√≥mo recomendar m√∫sica que casi nadie escuch√≥. Informe Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>