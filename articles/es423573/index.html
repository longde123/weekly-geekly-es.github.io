<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôüÔ∏è üí† üí∏ La sincronicidad es un mito. ‚èèÔ∏è üñïüèø üëâüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! 

 Hoy encontrar√° un texto largo sin im√°genes (ligeramente acortado en comparaci√≥n con el original), donde se analiza en detalle la tesi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La sincronicidad es un mito.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/423573/"> Hola a todos! <br><br>  Hoy encontrar√° un texto largo sin im√°genes (ligeramente acortado en comparaci√≥n con el original), donde se analiza en detalle la tesis presentada en el encabezado.  El veterano de Microsoft, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Terry Crowley,</a> describe la esencia de la programaci√≥n asincr√≥nica y explica por qu√© este enfoque es mucho m√°s realista y m√°s apropiado que el sincr√≥nico y secuencial. <br><br>  Aquellos que deseen o piensen en escribir un libro que aborde tales temas, escriban de manera personal. <br><a name="habracut"></a><br>  La sincronicidad es un mito.  No pasa nada al instante.  Todo lleva tiempo. <br>  Algunas caracter√≠sticas de los sistemas inform√°ticos y los entornos de programaci√≥n se basan fundamentalmente en el hecho de que los c√°lculos se producen en el mundo f√≠sico tridimensional y est√°n limitados por los l√≠mites de la velocidad de la luz y las leyes de la termodin√°mica. <br><br>  Tal arraigo en el mundo f√≠sico significa que algunos aspectos no pierden su relevancia incluso con el advenimiento de nuevas tecnolog√≠as que brindan nuevas oportunidades y acceso a nuevas fronteras de productividad.  Siguen siendo v√°lidas porque no son solo "opciones elegidas durante el dise√±o", sino la realidad subyacente del Universo f√≠sico. <br><br>  La diferencia entre sincronismo y asincron√≠a en el lenguaje y la creaci√≥n de sistemas es solo un aspecto del dise√±o que tiene bases f√≠sicas profundas.  La mayor√≠a de los programadores comienzan inmediatamente a trabajar con dichos programas y lenguajes, donde la ejecuci√≥n s√≠ncrona est√° impl√≠cita.  De hecho, esto es tan natural que nadie lo menciona ni habla directamente.  El t√©rmino "s√≠ncrono" en este contexto significa que el c√°lculo se lleva a cabo de inmediato, como una serie de pasos sucesivos, y nada m√°s sucede antes de que se complete.  Ejecuto <code>‚Äúc = a + b‚Äù  ‚Äúx = f(y)‚Äù</code> , y nada m√°s suceder√° hasta que se complete esta instrucci√≥n. <br><br>  Por supuesto, nada sucede instant√°neamente en el Universo f√≠sico.  Todos los procesos est√°n asociados con algunos retrasos: debe navegar por la jerarqu√≠a de memoria, ejecutar un ciclo de procesador, leer informaci√≥n de una unidad de disco o conectarse a otro nodo a trav√©s de la red, lo que tambi√©n causa retrasos en la transferencia de datos.  Todo esto es una consecuencia fundamental de la velocidad de la luz y la propagaci√≥n de la se√±al en tres dimensiones. <br><br>  Todos los procesos llegan un poco tarde; todo lleva tiempo.  Al definir algunos procesos como sincr√≥nicos, nosotros, en esencia, decimos que vamos a ignorar este retraso y describiremos nuestro c√°lculo como instant√°neo.  De hecho, en los sistemas inform√°ticos, a menudo se establece una infraestructura seria, que le permite continuar utilizando activamente el hardware b√°sico, incluso cuando intentan optimizar la interfaz de programaci√≥n presentando los eventos que ocurren en √©l como s√≠ncronos. <br><br>  La idea misma de que la sincronizaci√≥n se proporciona utilizando un mecanismo especial y est√° asociada con los costos puede parecer il√≥gica para el programador, que est√° m√°s acostumbrado al hecho de que es una asincron√≠a que requiere un control externo activo.  De hecho, esto es lo que sucede realmente cuando se proporciona una interfaz asincr√≥nica: la asincron√≠a fundamental genuina se abre para el programador un poco m√°s claramente que antes, y tiene que procesarla manualmente, en lugar de confiar en un programa que pueda hacerlo autom√°ticamente.  La provisi√≥n directa de asincron√≠a est√° asociada con costos adicionales para el programador, pero al mismo tiempo le permite distribuir de manera m√°s competente los costos y compensaciones inherentes a esta √°rea tem√°tica, y no dejar esto a merced de un sistema que equilibrar√≠a dichos costos y compensaciones.  La interfaz asincr√≥nica a menudo corresponde con mayor precisi√≥n a los eventos que ocurren f√≠sicamente en el sistema base y, en consecuencia, abre posibilidades de optimizaci√≥n adicionales. <br><br>  Por ejemplo, el procesador y el sistema de memoria cuentan con una infraestructura justa responsable de leer y escribir datos en la memoria, teniendo en cuenta su jerarqu√≠a.  En el nivel 1 (L1), el enlace de cach√© puede tomar varios nanosegundos, mientras que el enlace de memoria en s√≠ debe atravesar L2, L3 y la memoria principal, que puede tomar cientos de nanosegundos.  Si solo espera hasta que se resuelva el enlace de memoria, el procesador estar√° inactivo durante un porcentaje significativo del tiempo. <br><br>  Se utilizan mecanismos serios para optimizar tales fen√≥menos: canalizaci√≥n con una vista principal del flujo de comandos, m√∫ltiples operaciones simult√°neas de recuperaci√≥n de la memoria y el almacenamiento de datos actual, predicci√≥n de rama e intentos para optimizar a√∫n m√°s el programa, incluso cuando salta a otra ubicaci√≥n de memoria, control preciso de las barreras de memoria para garantizar que todo este complejo mecanismo continuar√° proporcionando un modelo de memoria consistente para un entorno de programaci√≥n de nivel superior.  Todas estas cosas se hacen en un esfuerzo por optimizar el rendimiento y aprovechar al m√°ximo el hardware para ocultar estos retrasos de 10-100 nanosegundos en la jerarqu√≠a de la memoria y proporcionar un sistema en el que se supone que se produzca una ejecuci√≥n sincr√≥nica, mientras exprimen un rendimiento decente del n√∫cleo del procesador. <br><br>  No siempre est√° claro cu√°n efectivas son tales optimizaciones para un c√≥digo en particular, y a menudo se requieren herramientas muy espec√≠ficas para analizar el rendimiento para responder a esta pregunta.  Tal trabajo anal√≠tico se proporciona en el desarrollo de algunos c√≥digos muy valiosos (por ejemplo, como en el motor de conversi√≥n para Excel, algunas opciones de compresi√≥n en el n√∫cleo o rutas criptogr√°ficas en el c√≥digo). <br><br>  Las operaciones con un retraso m√°s significativo, por ejemplo, leer datos de un disco giratorio, requieren el uso de otros mecanismos.  En tales casos, cuando solicite leer desde el disco del sistema operativo, ser√° necesario cambiar completamente a otro hilo o proceso, y la solicitud sincr√≥nica permanecer√° sin enviar.  Los altos costos de conmutaci√≥n y soporte de este mecanismo como tal son aceptables, ya que la latencia oculta en este caso puede alcanzar varios milisegundos en lugar de nanosegundos.  Tenga en cuenta: estos costos no se reducen a simplemente cambiar entre subprocesos, sino que incluyen el costo de toda la memoria y los recursos, que de hecho permanecen inactivos hasta que se completa la operaci√≥n.  Todos estos costos tienen que ir para proporcionar una interfaz supuestamente sincr√≥nica. <br><br>  Hay una serie de razones fundamentales por las que puede ser necesario revelar la asincron√≠a b√°sica real en el sistema y para las cuales ser√≠a preferible usar una interfaz asincr√≥nica con un determinado componente, nivel o aplicaci√≥n, incluso teniendo en cuenta la necesidad de hacer frente directamente a la creciente complejidad. <br><br>  <b>Concurrencia</b>  Si el recurso proporcionado est√° dise√±ado para un verdadero paralelismo, la interfaz asincr√≥nica permite al cliente emitir varias solicitudes y gestionarlas de forma m√°s simult√°nea, para hacer un uso completo de los recursos b√°sicos. <br><br>  <b>Transportaci√≥n</b> .  La forma habitual de reducir el retraso real en alguna interfaz es asegurarse de que varias solicitudes est√°n esperando ser enviadas en un momento dado (cu√°nto depende realmente de esto en t√©rminos de rendimiento depende de d√≥nde obtengamos la fuente del retraso).  En cualquier caso, si el sistema est√° adaptado para la canalizaci√≥n, la demora real puede reducirse en un factor igual al n√∫mero de solicitudes que esperan ser enviadas.  Por lo tanto, puede llevar 10 ms completar una solicitud espec√≠fica, pero si escribe 10 solicitudes en la tuber√≠a, la respuesta puede llegar cada milisegundo.  El rendimiento total es una funci√≥n de la canalizaci√≥n disponible, y no solo un retraso de "transferencia" por solicitud.  Una interfaz s√≠ncrona que emite una solicitud y espera una respuesta siempre dar√° un mayor retraso de extremo a extremo. <br><br>  <b>Embalaje (local o remoto)</b> .  La interfaz as√≠ncrona proporciona de forma m√°s natural la implementaci√≥n de un sistema de empaquetado de consultas, localmente o en un recurso remoto (nota: en este caso, el "disco" en el otro extremo de la interfaz de E / S puede ser "remoto").  El hecho es que la aplicaci√≥n ya deber√≠a poder recibir la respuesta, y al mismo tiempo habr√° alg√∫n retraso, ya que la aplicaci√≥n no interrumpir√° el procesamiento actual.  Dicho procesamiento adicional se puede combinar con solicitudes adicionales que naturalmente se agrupar√≠an. <br><br>  El procesamiento por lotes local puede proporcionar una transferencia m√°s eficiente de series de solicitudes, o incluso la compresi√≥n y eliminaci√≥n de solicitudes duplicadas directamente en la m√°quina local.  Para poder acceder simult√°neamente a un conjunto completo de solicitudes en un recurso remoto, puede ser necesaria una optimizaci√≥n seria.  Un ejemplo cl√°sico: un controlador de disco reordena una serie de operaciones de lectura y escritura para aprovechar la posici√≥n de la cabeza del disco en una placa giratoria y minimizar el tiempo de alimentaci√≥n de la cabeza.  En cualquier interfaz de almacenamiento de datos que opere a nivel de bloque, puede mejorar seriamente el rendimiento agrupando una serie de consultas en las que todas las operaciones de lectura y escritura caen en el mismo bloque. <br><br>  Naturalmente, el empaquetado local tambi√©n se puede implementar en la interfaz s√≠ncrona, pero para esto tendr√° que "ocultar la verdad" en gran medida o empaquetar paquetes de programas como una caracter√≠stica especial de la interfaz, lo que puede complicar a todo el cliente.  Un ejemplo cl√°sico de ocultar la verdad es la E / S almacenada.  La aplicaci√≥n llama a <code>‚Äúwrite(byte)‚Äù</code> , y la interfaz devuelve el <code>success</code> , pero, de hecho, el registro en s√≠ (as√≠ como la informaci√≥n sobre si se aprob√≥ con √©xito) no tendr√° lugar hasta que el b√∫fer se llene o se vac√≠e expl√≠citamente, y esto sucede cuando el archivo est√° cerrado .  Muchas aplicaciones pueden ignorar tales detalles: solo se produce un desastre cuando la aplicaci√≥n necesita garantizar algunas secuencias de operaciones interactivas, as√≠ como una idea real de lo que est√° sucediendo en los niveles inferiores. <br><br>  <b>Desbloquear / Desatar</b> .  Uno de los usos m√°s comunes de la asincron√≠a en el contexto de las interfaces gr√°ficas de usuario es evitar que el hilo principal de la interfaz de usuario se bloquee para que el usuario pueda continuar interactuando con la aplicaci√≥n.  Los retrasos en las operaciones a largo plazo (como las comunicaciones de red) no se pueden ocultar detr√°s de una interfaz s√≠ncrona.  En este caso, el hilo de la interfaz de usuario debe gestionar expl√≠citamente tales operaciones asincr√≥nicas y hacer frente a la complejidad adicional que se introduce en el programa. <br><br>  La interfaz de usuario es solo un ejemplo en el que el componente debe continuar respondiendo a solicitudes adicionales y, por lo tanto, no puede confiar en alg√∫n mecanismo est√°ndar que oculte demoras para simplificar el trabajo del programador. <br>  Un componente de servidor web que recibe nuevas conexiones a sockets, como regla general, transferir√° muy r√°pidamente dicha conexi√≥n a otro componente as√≠ncrono que proporciona comunicaci√≥n en el socket y volver√° a procesar nuevas solicitudes. <br><br>  En los modelos s√≠ncronos, los componentes y sus modelos de procesamiento suelen estar estrechamente relacionados. <br>  Las interacciones asincr√≥nicas son un mecanismo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">utilizado a menudo para aflojar la uni√≥n</a> . <br><br>  Reducci√≥n de costos y gesti√≥n.  Como se mencion√≥ anteriormente, cualquier mecanismo para ocultar la asincron√≠a implica cierta asignaci√≥n de recursos y sobrecarga.  Para una aplicaci√≥n en particular, tal sobrecarga puede no ser aceptable, y el dise√±ador de esa aplicaci√≥n debe encontrar una manera de controlar la asincron√≠a natural. <br><br>  Un ejemplo interesante es la historia de los servidores web.  Los primeros servidores web (creados en Unix) generalmente usaban un proceso separado para administrar las solicitudes entrantes.  Entonces este proceso podr√≠a leer esta conexi√≥n y escribirle, sucedi√≥, en esencia, sincr√≥nicamente.  Dicho dise√±o se desarroll√≥ y los costos se redujeron cuando los hilos comenzaron a usarse en lugar de los procesos, pero el modelo general de ejecuci√≥n s√≠ncrona se conserv√≥.  En las opciones de dise√±o moderno, se reconoce que la atenci√≥n principal no debe prestarse al modelo de c√°lculo, sino, en primer lugar, a la entrada / salida relacionada con la lectura y escritura al intercambiar informaci√≥n con una base de datos, sistema de archivos o transmitir informaci√≥n a trav√©s de una red, mientras se formula una respuesta .  Por lo general, se usan colas de trabajo para esto, en las que se permite un cierto l√≠mite en el n√∫mero de subprocesos, y en este caso, es posible construir m√°s claramente la administraci√≥n de recursos. <br><br>  El √©xito de NodeJS en el desarrollo de back-end se explica no solo por el soporte de este motor por parte de numerosos desarrolladores de JavaScript que crecieron creando interfaces web para clientes.  En NodeJS, como en las secuencias de comandos del navegador, se presta gran atenci√≥n al dise√±o de forma as√≠ncrona, lo que va bien con las opciones t√≠picas de carga del servidor: la administraci√≥n de los recursos del servidor depende principalmente de E / S y no del procesamiento. <br><br>  Hay otro aspecto interesante: tales compensaciones son m√°s expl√≠citas y mejor ajustadas por el desarrollador de la aplicaci√≥n, si se adhiere al enfoque asincr√≥nico.  En el ejemplo con retrasos en la jerarqu√≠a de memoria, el retraso real (medido en ciclos de procesador en t√©rminos de una solicitud en memoria) aument√≥ dram√°ticamente durante varias d√©cadas.  Los desarrolladores de procesadores luchan por agregar nuevos niveles de cach√© y mecanismos adicionales que impulsan cada vez m√°s el modelo de memoria proporcionado por el procesador para que la apariencia del procesamiento sincr√≥nico se mantenga a√∫n m√°s. <br><br>  El cambio de contexto en los l√≠mites de la E / S sincr√≥nica es otro ejemplo en el que las compensaciones reales han cambiado dr√°sticamente con el tiempo.  El aumento en los ciclos del procesador es m√°s r√°pido que la lucha contra los retrasos, y esto significa que ahora la aplicaci√≥n pierde muchas m√°s capacidades computacionales, mientras est√° inactiva en una forma bloqueada, esperando la finalizaci√≥n del IO.  El mismo problema relacionado con el costo relativo de los compromisos ha llevado a los dise√±adores de sistemas operativos a apegarse a esquemas de administraci√≥n de memoria que son mucho m√°s similares a los modelos anteriores con el intercambio de procesos (donde toda la imagen del proceso se carga completamente en la memoria, despu√©s de lo cual el proceso comienza), en lugar de intercambiar p√°ginas  Es muy dif√≠cil ocultar los retrasos que pueden ocurrir en el borde de cada p√°gina.  El rendimiento total dram√°ticamente mejorado logrado con grandes solicitudes de E / S secuenciales (en comparaci√≥n con el uso de solicitudes aleatorias) tambi√©n contribuye a tales cambios. <br><br>  <i><b>Otros temas</b></i> <br><br>  <b>Cancelar</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La cancelaci√≥n es un tema complejo</a> .  Hist√≥ricamente, los sistemas orientados sincr√≥nicamente hicieron un mal trabajo con el proceso de cancelaci√≥n, y algunos ni siquiera admitieron la cancelaci√≥n.  La cancelaci√≥n esencialmente ten√≠a que ser dise√±ada "fuera de banda", para tal operaci√≥n se requer√≠a llamar a un hilo separado de ejecuci√≥n.  Como alternativa, los modelos asincr√≥nicos son adecuados, donde el soporte para la cancelaci√≥n se organiza de forma m√°s natural, en particular, se utiliza un enfoque tan trivial: simplemente ignora qu√© respuesta finalmente regresa (y si regresa en absoluto).  La cancelaci√≥n se vuelve cada vez m√°s importante cuando aumenta la variabilidad de los retrasos, y en la pr√°ctica tambi√©n aumenta la tasa de error, lo que da una muy buena porci√≥n hist√≥rica que demuestra c√≥mo se desarrollaron nuestros entornos de red. <br><br>  <b>Regulaci√≥n / Gesti√≥n de recursos</b> <br><br>  El dise√±o s√≠ncrono, por definici√≥n, impone cierta limitaci√≥n, evitando que la aplicaci√≥n emita solicitudes adicionales hasta que se complete la solicitud actual.  En un dise√±o asincr√≥nico, el estrangulamiento no ocurre por nada, por lo que a veces es necesario implementarlo expl√≠citamente.  Esta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n</a> describe la situaci√≥n con Word Web App como un ejemplo, donde la transici√≥n del dise√±o sincr√≥nico a asincr√≥nico caus√≥ serios problemas con la administraci√≥n de recursos.  Si la aplicaci√≥n utiliza una interfaz s√≠ncrona, es posible que no reconozca que la limitaci√≥n est√° impl√≠citamente incrustada en el c√≥digo.  Al eliminar dicha limitaci√≥n impl√≠cita, es posible (o necesario) organizar la gesti√≥n de recursos de manera m√°s expl√≠cita. <br><br>  Tuve que lidiar con esto al comienzo de mi carrera cuando transportamos un editor de texto de la API gr√°fica s√≠ncrona de Sun a X Windows.  Al utilizar la API de Sun, la operaci√≥n de representaci√≥n era sincr√≥nica, de modo que el cliente no recuperaba el control hasta que se completaba.  En X Windows, se envi√≥ una solicitud gr√°fica de forma as√≠ncrona a trav√©s de una conexi√≥n de red y luego el servidor de visualizaci√≥n la ejecut√≥ (que podr√≠a estar en la misma m√°quina o en otra diferente). <br><br>  Para garantizar un buen rendimiento interactivo, nuestra aplicaci√≥n debe proporcionar algo de representaci√≥n (es decir, asegurarse de que la l√≠nea donde est√° el cursor ahora se actualiza y representa), y luego verifica si hay alguna otra entrada de teclado que deba leerse.    ,       (         ,     ),      ,        .           API.        ,     , -       .         ,            . UI  ,          . <br><br>       ,   30   (-,  Facebook  iPhone          ).   ‚Äì       (  ,     ),             ,         .         ,     ,     . <br><br> <b></b> <br><br>            ,    .      ,        Microsoft,  ,   API ‚Äì     ,      ,     .     ,   ,      ‚Äì   : ¬´,      !¬ª          ,        ,       . <br><br>    ,    .  ‚Äì  ,        .  ,   :     ,   ,     ,    .   ,    - .        , , <code>async/await</code>  .  ¬´¬ª , ,   ,     JavaScript.      :        ,         . <code>Async/await</code>    ,      ,    .           .        ,        ,     ,    . <br><br>           .  ,    ,    .      ,   , ,        .       ,    ,         ( !).   ()  ,      ,     . <br><br> ,      .       ,           .    async/await,     ,      ,     ,    . <br><br>      ,    ,      ,   ‚Äì  .           ,             .   ‚Äì      ,  ,    ,         ( ,      ‚Äì    Word     Excel).   ,       ,    -  ,        ,     ,    . <br> ,       ,    ,    ,      . <br>      ,       ‚Äì      .       . <br><br>  <b>Conclusiones</b> <br><br>  .  ‚Äì  ,  ,      . ,        ,      ,        .      ,    ;          ,     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es423573/">https://habr.com/ru/post/es423573/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es423563/index.html">VPS.today - cat√°logo de servidores virtuales</a></li>
<li><a href="../es423565/index.html">Gamepad de Sega Mega Drive y Raspberry Pi Parte 1 (preparatoria y de tres botones)</a></li>
<li><a href="../es423567/index.html">Una vez m√°s sobre inteligencia artificial</a></li>
<li><a href="../es423569/index.html">Definimos de manera simple y precisa el lenguaje de los mensajes.</a></li>
<li><a href="../es423571/index.html">Todo tipo de cosas en MetaPost</a></li>
<li><a href="../es423575/index.html">Est√°ndares de dise√±o en microelectr√≥nica: ¬ød√≥nde hay realmente 7 nan√≥metros en tecnolog√≠a de 7 nm?</a></li>
<li><a href="../es423577/index.html">Creando un juego de l√≥gica para una plataforma de juego</a></li>
<li><a href="../es423579/index.html">Servicios en la nube para WebGL? No gracias</a></li>
<li><a href="../es423583/index.html">Conseguir accidentes a trav√©s de NotificationIRP en OSS</a></li>
<li><a href="../es423585/index.html">Live: CI / CD en iOS y Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>