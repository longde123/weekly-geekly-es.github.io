<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üàµ ü§∏üèæ üåí Depuraci√≥n de implementaci√≥n de software con strace üßíüèæ üë©üèæ‚Äç‚úàÔ∏è üë®üèº‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mi trabajo principal es, en su mayor parte, el despliegue de sistemas de software, es decir, paso mucho tiempo tratando de responder estas preguntas: ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Depuraci√≥n de implementaci√≥n de software con strace</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/478626/"><p><img src="https://habrastorage.org/webt/zi/se/d3/zised39h1shd8invmnqtcvxxdgu.jpeg"></p><br><p>  Mi trabajo principal es, en su mayor parte, el despliegue de sistemas de software, es decir, paso mucho tiempo tratando de responder estas preguntas: </p><br><ul><li>  Este software funciona para el desarrollador, pero no para m√≠.  Por qu√© </li><li>  Ayer este software funcion√≥ para m√≠, pero no hoy.  Por qu√© </li></ul><br><p>  Este es un tipo de depuraci√≥n que es ligeramente diferente de la depuraci√≥n de software normal.  La depuraci√≥n normal se trata de la l√≥gica del c√≥digo, pero la depuraci√≥n de la implementaci√≥n se trata de la interacci√≥n del c√≥digo y el entorno.  Incluso si la ra√≠z del problema es un error l√≥gico, el hecho de que todo funcione en una m√°quina y no en otra significa que el problema est√° de alguna manera en el medio ambiente. </p><br><p>  Entonces, en lugar de las herramientas de depuraci√≥n habituales como <strong>gdb</strong> , tengo un conjunto diferente de herramientas para depurar la implementaci√≥n.  Y mi herramienta favorita para tratar un problema como "¬øPor qu√© no funciona este software?"  llamado <strong>strace</strong> . </p><a name="habracut"></a><br><h3 id="chto-zhe-takoe-strace">  ¬øQu√© es strace? </h3><br><p>  <a href="https://strace.io/">strace</a> es una herramienta para rastrear una llamada al sistema.  Inicialmente creado bajo Linux, pero los mismos chips de depuraci√≥n pueden rotarse con herramientas para otros sistemas ( <a href="http://dtrace.org/blogs/about/">DTrace</a> o <a href="https://man.openbsd.org/ktrace">ktrace</a> ). </p><br><p>  La aplicaci√≥n principal es muy simple.  Solo necesita ejecutar strace con cualquier comando y enviar√° todas las llamadas del sistema al volcado (aunque, primero, probablemente tenga que instalar <strong>strace</strong> ): </p><br><pre><code class="plaintext hljs">$ strace echo Hello ...Snip lots of stuff... write(1, "Hello\n", 6) = 6 close(1) = 0 close(2) = 0 exit_group(0) = ? +++ exited with 0 +++</code> </pre> <br><p>  ¬øQu√© son estas llamadas al sistema?  Es un tipo de API para el n√∫cleo del sistema operativo.  √ârase una vez, el software ten√≠a acceso directo al hardware en el que funcionaba.  Si, por ejemplo, necesita mostrar algo en la pantalla, se reproduce con puertos y / o registros de memoria para dispositivos de video.  Cuando los sistemas inform√°ticos multitarea se hicieron populares, el caos rein√≥ porque varias aplicaciones lucharon por el hardware.  Los errores en una aplicaci√≥n podr√≠an afectar el trabajo de otros, si no todo el sistema.  Luego aparecieron modos de privilegio (o "protecci√≥n de anillo") en la CPU.  El n√∫cleo se convirti√≥ en el m√°s privilegiado: obtuvo acceso completo al hardware, creando aplicaciones menos privilegiadas que ya ten√≠an que solicitar el acceso del n√∫cleo para interactuar con el hardware a trav√©s de llamadas al sistema. </p><br><p>  A nivel binario, una llamada al sistema es ligeramente diferente de una simple llamada a funci√≥n, sin embargo, la mayor√≠a de los programas usan un contenedor en la biblioteca est√°ndar.  Es decir  la biblioteca est√°ndar POSIX C contiene una llamada a la funci√≥n <strong>write ()</strong> , que contiene todo el c√≥digo espec√≠fico de la arquitectura para la llamada al sistema de <strong>escritura</strong> . </p><br><p><img src="https://habrastorage.org/webt/cr/qx/_-/crqx_-ucgqzecn4942nlgmuhaek.png"></p><br><p>  En resumen, cualquier interacci√≥n entre la aplicaci√≥n y su entorno (sistemas inform√°ticos) se lleva a cabo mediante llamadas al sistema.  Por lo tanto, cuando el software funciona en una m√°quina y no en otra, ser√≠a bueno ver los resultados de las llamadas del sistema de rastreo.  Para ser m√°s espec√≠ficos, aqu√≠ hay una lista de puntos t√≠picos que se pueden analizar mediante el seguimiento de llamadas del sistema: </p><br><ul><li>  Consola de E / S </li><li>  Entrada / salida de red </li><li>  Acceso al sistema de archivos y E / S de archivos </li><li>  Gesti√≥n de vida √∫til de procesos / subprocesos </li><li>  Gesti√≥n de memoria de bajo nivel </li><li>  Acceso a controladores de dispositivos espec√≠ficos. </li></ul><br><h3 id="kogda-ispolzovat-strace">  ¬øCu√°ndo usar strace? </h3><br><p>  En teor√≠a, <strong>strace se</strong> usa con cualquier programa en el espacio del usuario, porque cualquier programa en el espacio del usuario debe hacer llamadas al sistema.  Funciona de manera m√°s eficiente con programas compilados de bajo nivel, pero tambi√©n funciona con lenguajes de nivel superior como Python si puede superar el ruido adicional del tiempo de ejecuci√≥n y el int√©rprete. </p><br><p>  En todo su esplendor, <strong>strace se</strong> manifiesta durante la depuraci√≥n de software que funciona bien en una m√°quina, pero de repente deja de funcionar en otra, dando mensajes confusos sobre archivos, permisos o intentos fallidos de ejecutar algunos comandos o algo ... Es una pena, pero no tan bueno. se combina con problemas de alto nivel, como errores de verificaci√≥n de certificados.  Esto generalmente requiere una combinaci√≥n de <strong>herramientas strace</strong> , a veces <a href="https://linux.die.net/man/1/ltrace">ltrace,</a> y de nivel superior (como la herramienta de l√≠nea de comandos <strong>openssl</strong> para depurar un certificado). </p><br><p>  Por ejemplo, trabajamos en un servidor independiente, pero las llamadas del sistema de rastreo a menudo se pueden realizar en plataformas de implementaci√≥n m√°s complejas.  Solo necesita elegir el kit de herramientas adecuado. </p><br><h3 id="primer-prostoy-otladki">  Ejemplo de depuraci√≥n simple </h3><br><p>  Digamos que desea ejecutar la incre√≠ble aplicaci√≥n de servidor foo, pero resulta esto: </p><br><pre> <code class="plaintext hljs">$ foo Error opening configuration file: No such file or directory</code> </pre> <br><p>  Obviamente, no pudo encontrar el archivo de configuraci√≥n que escribi√≥.  Esto sucede porque a veces, cuando los administradores de paquetes compilan una aplicaci√≥n, anulan la ubicaci√≥n esperada de los archivos.  Y si sigue la gu√≠a de instalaci√≥n para una distribuci√≥n, en otra encontrar√° los archivos completamente, no donde esperaba.  Ser√≠a posible resolver el problema en un par de segundos si el mensaje de error dec√≠a d√≥nde buscar el archivo de configuraci√≥n, pero no dice.  Entonces, ¬ød√≥nde mirar? </p><br><p>  Si tiene acceso al c√≥digo fuente, puede leerlo y averiguarlo.  Un buen plan de respaldo, pero no la soluci√≥n m√°s r√°pida.  Puede recurrir a un depurador paso a paso como <strong>gdb</strong> y ver qu√© hace el programa, pero es mucho m√°s eficiente usar una herramienta especialmente dise√±ada para mostrar la interacci√≥n con el entorno: <strong>strace</strong> . </p><br><p>  La conclusi√≥n de <strong>strace</strong> puede parecer redundante, pero la buena noticia es que la mayor parte se puede ignorar con seguridad.  A menudo es √∫til usar el operador -o para guardar los resultados de seguimiento en un archivo separado: </p><br><pre> <code class="plaintext hljs">$ strace -o /tmp/trace foo Error opening configuration file: No such file or directory $ cat /tmp/trace execve("foo", ["foo"], 0x7ffce98dc010 /* 16 vars */) = 0 brk(NULL) = 0x56363b3fb000 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory) openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3 fstat(3, {st_mode=S_IFREG|0644, st_size=25186, ...}) = 0 mmap(NULL, 25186, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f2f12cf1000 close(3) = 0 openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3 read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\260A\2\0\0\0\0\0"..., 832) = 832 fstat(3, {st_mode=S_IFREG|0755, st_size=1824496, ...}) = 0 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f2f12cef000 mmap(NULL, 1837056, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f2f12b2e000 mprotect(0x7f2f12b50000, 1658880, PROT_NONE) = 0 mmap(0x7f2f12b50000, 1343488, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x22000) = 0x7f2f12b50000 mmap(0x7f2f12c98000, 311296, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x16a000) = 0x7f2f12c98000 mmap(0x7f2f12ce5000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b6000) = 0x7f2f12ce5000 mmap(0x7f2f12ceb000, 14336, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f2f12ceb000 close(3) = 0 arch_prctl(ARCH_SET_FS, 0x7f2f12cf0500) = 0 mprotect(0x7f2f12ce5000, 16384, PROT_READ) = 0 mprotect(0x56363b08b000, 4096, PROT_READ) = 0 mprotect(0x7f2f12d1f000, 4096, PROT_READ) = 0 munmap(0x7f2f12cf1000, 25186) = 0 openat(AT_FDCWD, "/etc/foo/config.json", O_RDONLY) = -1 ENOENT (No such file or directory) dup(2) = 3 fcntl(3, F_GETFL) = 0x2 (flags O_RDWR) brk(NULL) = 0x56363b3fb000 brk(0x56363b41c000) = 0x56363b41c000 fstat(3, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x8), ...}) = 0 write(3, "Error opening configuration file"..., 60) = 60 close(3) = 0 exit_group(1) = ? +++ exited with 1 +++</code> </pre> <br><p>  Casi toda la primera p√°gina de salida de <strong>strace</strong> suele ser una preparaci√≥n de bajo nivel para el lanzamiento.  (Hay muchas llamadas <strong>mmap</strong> , <strong>mprotect</strong> , <strong>brk</strong> para cosas como detectar memoria de bajo nivel y mostrar bibliotecas din√°micas). De hecho, durante la depuraci√≥n, <strong>las</strong> salidas de <strong>strace</strong> se leen mejor desde el final.  En la parte inferior hay una llamada para <strong>escribir</strong> , que muestra un mensaje de error.  Miramos arriba y vemos la primera llamada de sistema err√≥nea: una llamada de <strong>openat</strong> que <strong>arroja</strong> un error <strong>ENOENT</strong> ("archivo o directorio no encontrado"), intentando abrir <strong>/etc/foo/config.json</strong> .  Aqu√≠, aqu√≠ debe estar el archivo de configuraci√≥n. </p><br><p>  Fue solo un ejemplo, pero dir√≠a que el 90% del tiempo que uso <strong>strace</strong> , nada es mucho m√°s dif√≠cil de hacer y no tiene que hacerlo.  A continuaci√≥n se muestra una gu√≠a completa de depuraci√≥n paso a paso: </p><br><ul><li>  Frustrado por un mensaje de error de sistema-slurred de un programa </li><li>  Reinicia el programa con <strong>strace</strong> </li><li>  Encuentra el mensaje de error en los resultados de seguimiento </li><li>  Ve m√°s alto hasta que te topes con la primera llamada fallida del sistema </li></ul><br><p>  Es muy probable que la llamada al sistema en el paso 4 muestre lo que sali√≥ mal. </p><br><h3 id="podskazki">  Consejos </h3><br><p>  Antes de mostrar un ejemplo de depuraci√≥n m√°s compleja, te contar√© algunos trucos para usar <strong>strace de manera</strong> efectiva: </p><br><p>  <strong>el hombre es tu amigo</strong> </p><br><p>  En muchos sistemas * nix, se puede obtener una lista completa de las llamadas al sistema kernel ejecutando <strong>man syscalls</strong> .  Ver√° cosas como <strong>brk (2)</strong> , lo que significa que puede obtener m√°s informaci√≥n ejecutando <strong>man 2 brk</strong> . </p><br><p>  Un peque√±o rake: <strong>man 2 fork</strong> me muestra una p√°gina para el shell <strong>fork ()</strong> en <strong>GNU libc</strong> , que resulta ser implementado usando la llamada <strong>clone ()</strong> .  La sem√°ntica de la llamada <strong>fork</strong> sigue siendo la misma si escribe un programa que usa <strong>fork ()</strong> y comienza a rastrear: no encontrar√© llamadas <strong>fork</strong> , en lugar de ellas habr√° <strong>clone ()</strong> .  Tal rastrillo solo se confunde si comienzas a comparar la fuente con la salida de <strong>strace</strong> . </p><br><p>  <strong>Use -o para guardar la salida en un archivo</strong> </p><br><p>  <strong>strace</strong> puede generar una salida extensa, por lo que a menudo es √∫til almacenar resultados de rastreo en archivos separados (como en el ejemplo anterior).  Y ayuda a no confundir la salida del programa con la salida de la consola. </p><br><p>  <strong>Use -s para ver m√°s datos de argumentos</strong> </p><br><p>  Probablemente haya notado que la segunda mitad del mensaje de error no se muestra en el ejemplo de seguimiento anterior.  Esto se debe a que <strong>strace</strong> solo muestra los primeros 32 bytes del argumento de cadena de forma predeterminada.  Si desea ver m√°s, agregue algo como <strong>-s 128</strong> a la llamada de <strong>strace</strong> . </p><br><p>  <strong>-y facilita el seguimiento de archivos \ sockets \ y as√≠ sucesivamente.</strong> </p><br><p>  "Todo es un archivo" significa que los sistemas * nix realizan todas las E / S utilizando descriptores de archivo, ya sea que se aplique a un archivo o red, o a canales de interproceso.  Esto es conveniente para la programaci√≥n, pero hace que sea dif√≠cil hacer un seguimiento de lo que realmente sucede cuando ve la <strong>lectura</strong> y <strong>escritura</strong> generales en los resultados de seguimiento de una llamada al sistema. </p><br><p>  Al agregar el operador -u, fuerza a <strong>strace a</strong> anotar cada descriptor de archivo en la salida con una nota de lo que apunta. </p><br><p>  Adjuntar a un proceso que ya se est√° ejecutando con -p ** </p><br><p>  Como se ver√° en el siguiente ejemplo, a veces necesita rastrear un programa que ya se est√° ejecutando.  Si sabe que se est√° ejecutando como el proceso 1337 (por ejemplo, de las conclusiones de <strong>ps</strong> ), puede rastrearlo as√≠: </p><br><pre> <code class="plaintext hljs">$ strace -p 1337 ...system call trace output...</code> </pre> <br><p>  Quiz√°s necesite privilegios de root. </p><br><p>  <strong>Use -f para monitorear procesos secundarios</strong> </p><br><p>  <strong>strace</strong> de forma predeterminada solo rastrea un proceso.  Si este proceso genera procesos secundarios, puede ver la llamada del sistema para generar el proceso secundario, pero las llamadas del sistema del proceso secundario no se mostrar√°n. </p><br><p>  Si cree que el error est√° en el proceso secundario, use el operador <strong>-f</strong> , esto habilitar√° su rastreo.  La desventaja de esto es que la conclusi√≥n te confundir√° a√∫n m√°s.  Cuando <strong>strace</strong> rastrea un proceso o un hilo, muestra una secuencia √∫nica de eventos de llamada.  Cuando rastrea varios procesos a la vez, probablemente ver√° el comienzo de la llamada interrumpida por el mensaje <strong>&lt;inacabado ...&gt;</strong> , luego un mont√≥n de llamadas para otras ramas de ejecuci√≥n, y solo entonces el final de la primera con <strong>&lt;... foocall resume&gt;</strong> .  O separe todos los resultados de rastreo en diferentes archivos, utilizando tambi√©n el operador <strong>-ff</strong> ( <strong>consulte el</strong> <a href="https://linux.die.net/man/1/strace">manual de</a> <strong>strace</strong> para m√°s detalles). </p><br><p>  <strong>Filtre la traza con -e</strong> </p><br><p>  Como puede ver, el resultado del rastreo es un grupo real de todas las llamadas posibles del sistema.  Con la bandera <strong>-e</strong> , puede filtrar la traza (consulte el <a href="https://linux.die.net/man/1/strace">manual de</a> <strong>strace</strong> ).  La principal ventaja es que ejecutar una traza con filtrado es m√°s r√°pido que hacer una traza completa, y luego <strong>grep</strong> .  Para ser honesto, casi siempre no me importa. </p><br><p>  <strong>No todos los errores son malos.</strong> </p><br><p>  Un ejemplo simple y com√∫n es un programa que busca un archivo en varios lugares a la vez, como un shell que busca, en el que el directorio basket / contiene un archivo ejecutable: </p><br><pre> <code class="plaintext hljs">$ strace sh -c uname ... stat("/home/user/bin/uname", 0x7ffceb817820) = -1 ENOENT (No such file or directory) stat("/usr/local/bin/uname", 0x7ffceb817820) = -1 ENOENT (No such file or directory) stat("/usr/bin/uname", {st_mode=S_IFREG|0755, st_size=39584, ...}) = 0 ...</code> </pre> <br><p>  Una heur√≠stica de "√∫ltima solicitud fallida antes del mensaje de error" es buena para encontrar errores relevantes.  Sea como fuere, es l√≥gico comenzar desde el final. </p><br><p>  <strong>Las gu√≠as de programaci√≥n de C ayudan a comprender las llamadas al sistema</strong> </p><br><p>  Las llamadas est√°ndar a las bibliotecas C no son llamadas del sistema, sino solo una capa superficial delgada.  Entonces, si comprende al menos un poco c√≥mo y qu√© hacer en C, ser√° m√°s f√°cil para usted comprender los resultados de rastrear una llamada al sistema.  Por ejemplo, si tiene problemas para depurar llamadas a sistemas en red, consulte la misma <a href="https://beej.us/guide/bgnet/html/index.html">"Gu√≠a de programaci√≥n de red" de Bija</a> . </p><br><h3 id="primer-otladki-poslozhnee">  Ejemplo de depuraci√≥n m√°s complicado </h3><br><p>  Ya he dicho que un ejemplo de depuraci√≥n simple es un ejemplo de algo con lo que, en su mayor parte, tengo que lidiar con <strong>strace</strong> .  Sin embargo, a veces se requiere una investigaci√≥n real, as√≠ que aqu√≠ hay un ejemplo real de depuraci√≥n m√°s complicada. </p><br><p>  <a href="https://untroubled.org/bcron/">bcron</a> es un programador de procesamiento de tareas, otra implementaci√≥n del <strong>demonio</strong> * nix <strong>cron</strong> .  Est√° instalado en el servidor, pero cuando alguien intenta editar la programaci√≥n, esto es lo que sucede: </p><br><pre> <code class="plaintext hljs"># crontab -e -u logs bcrontab: Fatal: Could not create temporary file</code> </pre> <br><p>  Bien, entonces <strong>Bcron</strong> trat√≥ de escribir cierto archivo, pero no funcion√≥ y no admite por qu√©.  Descubrir <strong>strace</strong> : </p><br><pre> <code class="plaintext hljs"># strace -o /tmp/trace crontab -e -u logs bcrontab: Fatal: Could not create temporary file # cat /tmp/trace ... openat(AT_FDCWD, "bcrontab.14779.1573691864.847933", O_RDONLY) = 3 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f82049b4000 read(3, "#Ansible: logsagg\n20 14 * * * lo"..., 8192) = 150 read(3, "", 8192) = 0 munmap(0x7f82049b4000, 8192) = 0 close(3) = 0 socket(AF_UNIX, SOCK_STREAM, 0) = 3 connect(3, {sa_family=AF_UNIX, sun_path="/var/run/bcron-spool"}, 110) = 0 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f82049b4000 write(3, "156:Slogs\0#Ansible: logsagg\n20 1"..., 161) = 161 read(3, "32:ZCould not create temporary f"..., 8192) = 36 munmap(0x7f82049b4000, 8192) = 0 close(3) = 0 write(2, "bcrontab: Fatal: Could not creat"..., 49) = 49 unlink("bcrontab.14779.1573691864.847933") = 0 exit_group(111) = ? +++ exited with 111 +++</code> </pre> <br><p>  Al final, hay un mensaje de error de <strong>escritura</strong> , pero esta vez algo es diferente.  En primer lugar, no hay un error de llamada al sistema relevante que generalmente ocurra antes de esto.  En segundo lugar, est√° claro que en alg√∫n lugar alguien ya ha le√≠do el mensaje de error.  Parece que el verdadero problema est√° en otro lugar, y <strong>bcrontab</strong> solo reproduce el mensaje. </p><br><p>  Si observa la <strong>lectura de man 2</strong> , puede ver que el primer argumento (3) es el descriptor de archivo que * nix usa para todo el procesamiento de E / S.  ¬øC√≥mo saber qu√© representa el descriptor de archivo 3?  En este caso particular, puede ejecutar <strong>strace</strong> con el operador <strong>-u</strong> (ver arriba), y autom√°ticamente le dir√°, sin embargo, para calcular tales cosas, es √∫til saber c√≥mo leer y analizar los resultados de la traza. </p><br><p>  La fuente del descriptor de archivo puede ser una de las muchas llamadas al sistema (todo depende de cu√°l sea el descriptor para la consola, el socket de red, el archivo en s√≠ mismo u otra cosa), pero sea como sea, estamos buscando llamadas que devuelvan 3 (t .e. busque "= 3" en los resultados del seguimiento).  Como resultado, hay 2 de ellos: <strong>openat</strong> en la parte superior y <strong>socket</strong> en el medio.  <strong>openat</strong> abre el archivo, pero <strong>cerrar</strong> (3) despu√©s de eso mostrar√° que se cierra nuevamente.  (Rastrillo: los descriptores de archivo se pueden reutilizar cuando se abren y cierran).  La llamada <strong>socket ()</strong> es adecuada, ya que es la √∫ltima antes de <strong>read ()</strong> , y resulta que bcrontab funciona con algo a trav√©s del socket.  La siguiente l√≠nea muestra que el descriptor de archivo est√° asociado con el <strong>socket del dominio Unix a lo</strong> largo de la ruta <strong>/ var / run / bcron-spool</strong> . </p><br><p>  Por lo tanto, debe encontrar el proceso conectado al <strong>z√≥calo Unix</strong> por otro lado.  Hay un par de trucos ingeniosos para este prop√≥sito, y ambos son √∫tiles para depurar implementaciones de servidores.  El primero es usar <strong>netstat</strong> o <strong>ss</strong> m√°s reciente (estado del socket).  Ambos comandos muestran las conexiones de red activas del sistema y toman el operador <strong>-l</strong> para describir los z√≥calos de escucha, y el operador <strong>-p</strong> para mostrar los programas conectados al z√≥calo como cliente.  (Hay muchas m√°s opciones √∫tiles, pero estas dos son suficientes para esta tarea). </p><br><pre> <code class="plaintext hljs"># ss -pl | grep /var/run/bcron-spool u_str LISTEN 0 128 /var/run/bcron-spool 1466637 * 0 users:(("unixserver",pid=20629,fd=3))</code> </pre> <br><p>  Esto sugiere que el oyente es un comando <strong>inixserver</strong> que funciona con el ID de proceso 20629. (Y, por coincidencia, utiliza el descriptor de archivo 3 como socket). </p><br><p>  La segunda herramienta realmente √∫til para encontrar la misma informaci√≥n se llama <strong>lsof</strong> .  Enumera todos los archivos abiertos (o descriptores de archivos) en el sistema.  O puede obtener informaci√≥n sobre un archivo espec√≠fico: </p><br><pre> <code class="plaintext hljs"># lsof /var/run/bcron-spool COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME unixserve 20629 cron 3u unix 0x000000005ac4bd83 0t0 1466637 /var/run/bcron-spool type=STREAM</code> </pre> <br><p>  El proceso 20629 es un servidor de larga duraci√≥n, por lo que puede adjuntar <strong>strace</strong> utilizando algo como <strong>strace -o / tmp / trace -p 20629</strong> .  Si editamos la tarea cron en otro terminal, obtenemos la salida de los resultados de seguimiento con un error.  Y aqu√≠ est√° el resultado: </p><br><pre> <code class="plaintext hljs">accept(3, NULL, NULL) = 4 clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7faa47c44810) = 21181 close(4) = 0 accept(3, NULL, NULL) = ? ERESTARTSYS (To be restarted if SA_RESTART is set) --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=21181, si_uid=998, si_status=0, si_utime=0, si_stime=0} --- wait4(0, [{WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 0}], WNOHANG|WSTOPPED, NULL) = 21181 wait4(0, 0x7ffe6bc36764, WNOHANG|WSTOPPED, NULL) = -1 ECHILD (No child processes) rt_sigaction(SIGCHLD, {sa_handler=0x55d244bdb690, sa_mask=[CHLD], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7faa47ab9840}, {sa_handler=0x55d244bdb690, sa_mask=[CHLD], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7faa47ab9840}, 8) = 0 rt_sigreturn({mask=[]}) = 43 accept(3, NULL, NULL) = 4 clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7faa47c44810) = 21200 close(4) = 0 accept(3, NULL, NULL) = ? ERESTARTSYS (To be restarted if SA_RESTART is set) --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=21200, si_uid=998, si_status=111, si_utime=0, si_stime=0} --- wait4(0, [{WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 111}], WNOHANG|WSTOPPED, NULL) = 21200 wait4(0, 0x7ffe6bc36764, WNOHANG|WSTOPPED, NULL) = -1 ECHILD (No child processes) rt_sigaction(SIGCHLD, {sa_handler=0x55d244bdb690, sa_mask=[CHLD], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7faa47ab9840}, {sa_handler=0x55d244bdb690, sa_mask=[CHLD], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7faa47ab9840}, 8) = 0 rt_sigreturn({mask=[]}) = 43 accept(3, NULL, NULL</code> </pre> <br><p>  (La √∫ltima <strong>aceptaci√≥n ()</strong> no se completar√° al rastrear). Y nuevamente, lamentablemente, este resultado no contiene el error que estamos buscando.  No vemos ning√∫n mensaje que bcrontag env√≠e o reciba de un socket.  En su lugar, complete el control del proceso ( <strong>clone</strong> , <strong>wait4</strong> , <strong>SIGCHLD</strong> , etc.) Este proceso genera un proceso hijo, que, como puede suponer, hace el trabajo real.  Y si necesita atrapar su rastro, agregue <strong>strace -f</strong> a la llamada.  Esto es lo que encontramos al buscar el mensaje de error en el nuevo resultado con strace <strong>-f -o / tmp / trace -p 20629</strong> : </p><br><pre> <code class="plaintext hljs">21470 openat(AT_FDCWD, "tmp/spool.21470.1573692319.854640", O_RDWR|O_CREAT|O_EXCL, 0600) = -1 EACCES (Permission denied) 21470 write(1, "32:ZCould not create temporary f"..., 36) = 36 21470 write(2, "bcron-spool[21470]: Fatal: logs:"..., 84) = 84 21470 unlink("tmp/spool.21470.1573692319.854640") = -1 ENOENT (No such file or directory) 21470 exit_group(111) = ? 21470 +++ exited with 111 +++</code> </pre> <br><p>  Ahora, esto es algo.  El proceso 21470 recibe un error de "acceso denegado" cuando intenta crear un archivo en la ruta <strong>tmp / spool.21470.1573692319.854640</strong> (en referencia al directorio de trabajo actual).  Si simplemente supi√©ramos el directorio de trabajo actual, habr√≠amos conocido la ruta completa y podr√≠amos descubrir por qu√© el proceso no puede crear su propio archivo temporal.  Desafortunadamente, el proceso ya se ha cerrado, por lo que no puede usar <strong>lsof -p 21470</strong> para encontrar el directorio actual, sino que puede trabajar en la direcci√≥n opuesta: busque las llamadas al sistema PID 21470 que cambian el directorio.  (Si no hay ninguno, el PID 21470 debe haberlos heredado del padre, y esto no se puede resolver a trav√©s de <strong>lsof -p</strong> .) Esta llamada al sistema es <strong>chdir</strong> (que es f√°cil de encontrar con la ayuda de los motores de b√∫squeda de red modernos).  Y aqu√≠ est√° el resultado de b√∫squedas inversas basadas en los resultados de seguimiento, hasta el servidor PID 20629: </p><br><pre> <code class="plaintext hljs">20629 clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7faa47c44810) = 21470 ... 21470 execve("/usr/sbin/bcron-spool", ["bcron-spool"], 0x55d2460807e0 /* 27 vars */) = 0 ... 21470 chdir("/var/spool/cron") = 0 ... 21470 openat(AT_FDCWD, "tmp/spool.21470.1573692319.854640", O_RDWR|O_CREAT|O_EXCL, 0600) = -1 EACCES (Permission denied) 21470 write(1, "32:ZCould not create temporary f"..., 36) = 36 21470 write(2, "bcron-spool[21470]: Fatal: logs:"..., 84) = 84 21470 unlink("tmp/spool.21470.1573692319.854640") = -1 ENOENT (No such file or directory) 21470 exit_group(111) = ? 21470 +++ exited with 111 +++</code> </pre> <br><p>  (Si se pierde, es posible que deba leer mi publicaci√≥n anterior <a href="https://theartofmachinery.com/2018/11/07/writing_a_nix_shell.html">sobre el control de procesos y los shells * nix</a> ). Entonces, el servidor PID 20629 no obtuvo permiso para crear un archivo a lo largo de la ruta <strong>/var/spool/cron/tmp/spool.21470.1573692319.854640</strong> .  ,   ‚Äî     . : </p><br><pre> <code class="plaintext hljs"># ls -ld /var/spool/cron/tmp/ drwxr-xr-x 2 root root 4096 Nov 6 05:33 /var/spool/cron/tmp/ # ps u -p 20629 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND cron 20629 0.0 0.0 2276 752 ? Ss Nov14 0:00 unixserver -U /var/run/bcron-spool -- bcron-spool</code> </pre> <br><p>    !     cron,    root      <strong>/var/spool/cron/tmp/</strong> .   <strong>chown cron /var/spool/cron/tmp/</strong>  <strong>bcron</strong>  . (     ,      ‚Äî     SELinux  AppArmor,           <strong>dmesg</strong> .) </p><br><h3 id="itogo">  Total </h3><br><p>        ,  , , ,   ‚Äî         . ,     <strong>bcron</strong> ,   . </p><br><p>            ,     ,  ,  <strong>strace</strong> ,        ,   .   , <strong>strace</strong>       . ,      . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/478626/">https://habr.com/ru/post/478626/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../478606/index.html">"Buenas noches": c√≥mo los dispositivos inteligentes privan a las personas del sue√±o</a></li>
<li><a href="../478616/index.html">Windows UAC nunca deja de sorprender, o C√≥mo detectar una informaci√≥n privilegiada</a></li>
<li><a href="../478618/index.html">School of Magic PHP</a></li>
<li><a href="../478620/index.html">¬øPor qu√© deber√≠as probar FastAPI?</a></li>
<li><a href="../478622/index.html">Pruebas A / B, canalizaci√≥n y venta minorista: trimestre de marca para Big Data de GeekBrains y X5 Retail Group</a></li>
<li><a href="../478628/index.html">Alto CRI en chino</a></li>
<li><a href="../478630/index.html">Pascal juega Go. Implementaci√≥n de m√©todos e interfaces en un compilador aficionado.</a></li>
<li><a href="../478634/index.html">Errores en la gesti√≥n de proyectos de aprendizaje autom√°tico</a></li>
<li><a href="../478638/index.html">db-tree: busca y navega por la base de datos</a></li>
<li><a href="../478640/index.html">Autos aut√≥nomos en c√≥digo abierto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>