<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕠 👨🏾‍💻 ✖️ Utilitaire anglais multiplateforme pour visualiser les certificats qualifiés russes x509 ✌🏾 🚕 😂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui, l'utilisation des certificats numériques X509 v.3 est devenue courante. De plus en plus de personnes les utilisent pour accéder au site I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utilitaire anglais multiplateforme pour visualiser les certificats qualifiés russes x509</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440754/"><img src="https://habrastorage.org/webt/tj/bp/mp/tjbpmpejv6ig2dqs8r22x1zcmzw.png" alt="image" align="left">  Aujourd'hui, l'utilisation des certificats numériques X509 v.3 est devenue courante.  De plus en plus de personnes les utilisent pour accéder au site Internet du Service d'État, du Service fédéral des impôts, des enchères électroniques, etc.  Et de plus en plus de gens veulent savoir ce qu'il y a dans ce «coffre» appelé certificat.  Et si le certificat est un analogue d'un passeport, comment peut-il être lu / consulté?  Oui, dans les systèmes d'exploitation, il existe différents utilitaires de visualisation.  Mais ils donneront peu au citoyen ordinaire.  Prenons par exemple l'utilitaire gcr-viewer, qui, en fait, est l'outil standard pour la visualisation sur les systèmes Linux, et donc dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les OS nationaux</a> : <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/lf/7g/nf/lf7gnfqkvwpo2cuhy_mcvulf_a8.png"><br><br><h3>  Visionneuse standard </h3><br>  L'utilitaire est bien fait, pratique.  En général, il est conçu comme un utilitaire universel pour visualiser des fichiers contenant des données dans divers formats cryptographiques (certificats, demandes, signatures électroniques / PKCS # 7, conteneurs protégés PKCS # 12, etc.).  Mais, malheureusement, il est conçu pour la cryptographie occidentale et ne prend pas en compte les OID qui sont entrés dans votre pays.  Et si vous regardez la capture d'écran, lorsque les informations sur le titulaire du certificat s'affichent, des caractères incompréhensibles apparaissent.  A gauche se trouvent les oides eux-mêmes et à droite sous la 16e forme, la structure asn1 avec leurs valeurs.  Dans ce cas, ce sont OGRN (1.2.643.100.1), SNILS (1.2.643.100.3) et TIN (1.2.643.3.131.1.1).  Et c'est ainsi qu'un citoyen ordinaire doit s'assurer qu'il s'agit bien de ses données.  Ne pensez pas que ce soit uniquement sous Linux, c'est une caractéristique courante de tout visualiseur de certificats.  Et si vous regardez plus loin, alors tout devient incompréhensible: <br><br><img src="https://habrastorage.org/webt/55/6s/ib/556sib6y76f81ohud2laq0knsho.png"><br><br>  Certaines extensions, identificateurs et valeurs apparaissent.  Dans ce cas, oid om 1.2.643.100.111 cache le nom du CIPF, qui a été utilisé par l'utilisateur pour générer la paire de clés, la clé privée à partir de laquelle a été utilisée pour signer la demande de certificat et la clé publique à partir de laquelle se trouve le certificat: <br><br><img src="https://habrastorage.org/webt/yv/yx/uu/yvyxuu6hjoasxtytu7foy-s1o20.png"><br><br>  Et ici, le détenteur du certificat ne comprend pas grand-chose.  Il ne comprend même pas quel algorithme a été utilisé pour générer la clé, GOST R 34.10-2001 ou GOST R 34.10-2012 et avec quelle longueur de clé. <br><br>  Vous pouvez continuer à donner des exemples.  Par exemple, si la validité du certificat est claire, alors où est la clé? <br><br>  Il y a deux autres questions auxquelles les détenteurs de certificats aimeraient avoir une réponse: où puis-je obtenir une chaîne de certificats racine (ou mieux encore en obtenir un) et une question similaire sur la liste des certificats révoqués. <br><br>  Et enfin, je voudrais avoir un utilitaire universel qui prend en compte les caractéristiques de la PKI / PKI russe, qui est vraiment multiplateforme et fonctionne sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des OS</a> nationaux et non <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">domestiques</a> .  Que développer?  Bien sûr, dans un langage de script, ne serait-ce qu'en raison de leur nature multiplateforme. <br><br>  Puis je me suis souvenu que le magnifique langage de script Tcl (Tool Command Language) avait récemment fêté ses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">30 ans</a> .  C'est un plaisir de le programmer.  Il a un grand nombre d'extensions (package) qui permettent presque tout.  Donc, pour travailler avec les structures ASN, il y a un paquet asn.  De plus, pour travailler avec des certificats (nous sommes intéressés à les analyser dans ce cas), il y a un paquet pki.  Et pour développer une interface graphique, il existe un package Tk. <br><br>  On peut en dire autant de Pyton avec Tkinter, de perl et de rubis.  Chacun peut choisir selon son goût.  Nous nous arrêtons à un tas de Tcl / Tk. <br><br>  Nous emprunterons la conception graphique de l'utilitaire à l'utilitaire gcr-viewer.  Et encore une exigence. <br><br>  Comme Habr avait une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version anglaise</a> , je voulais que l'utilitaire ait différentes interfaces (russe / anglais).  Mais ce n'est pas la raison principale.  Plus important encore, de plus en plus de citoyens du monde occidental deviennent des citoyens de la Fédération de Russie, par exemple le célèbre acteur Depardieu.  Ils peuvent objecter: c'est un Français.  Mais je suis aussi traducteur militaire du français: <br><br><img src="https://habrastorage.org/webt/ma/xr/4d/maxr4dvthbpwapmxmodkjceujh4.png"><br><br>  Il est donc facile d'ajouter une interface en français.  Mais je pense que Depardieu n'a aucun problème avec la langue anglaise.  D'un autre côté, notre pays est multinational et ce serait bien que le logiciel domestique et l'OS domestique aient au moins plusieurs interfaces nationales. <br>  Avançant un peu, voici ce qui en est ressorti: <br><br><img src="https://habrastorage.org/webt/-e/d8/df/-ed8dfn1in3wl7iwa2wmf-w0w-w.png"><br><br><h3>  Nous invitons un traducteur </h3><br>  Commençons donc par le «traducteur».  Dans la capture d'écran, il se cache sous le drapeau national.  La principale exigence pour un traducteur est la synchronisation de la traduction, c'est-à-dire  la possibilité de passer à une autre langue à tout moment.  Les fonctions du traducteur en Tcl / Tk sont exécutées par le package msgcat: <br><br><pre><code class="plaintext hljs">package require msgcat</code> </pre> <br>  Pour définir la langue actuelle, utilisez la commande suivante: <br><br><pre> <code class="plaintext hljs">msgcat::mclocale ru</code> </pre> <br>  Le vocabulaire du «traducteur» est stocké dans le fichier ru.msg comme suit: <br><br><pre> <code class="plaintext hljs">#  msgcat::mcset      #     mcset namespace import -force msgcat::mcset #     mcset ru "Language" "" …</code> </pre> <br>  Ce qui suit est le texte du test <div class="spoiler">  <b class="spoiler_title">script avec traducteur:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#!/usr/bin/wish -f #  msgcat package require msgcat #   ru msgcat::mclocale ru #  ::msgcat::mc      #     mc namespace import msgcat::mc #    [msgcat::mclocale].msg. #       . msgcat::mcload [file join [file dirname [info script]]] #  image create photo rf_32x21_f -file rf_32x21.png image create photo gb_32x21_f -file gb_32x21.png #,      label .lab -text "[mc Language]: " -relief flat -bd 0 –bg snow -anchor sw -width 10 button .but_lang -image rf_32x21_f -command ::changelang -relief flat -bd 0 pack .lab -side left -pady {2 0} pack .but_lang -side left #      proc ::changelang {} { #     #    if {[msgcat::mclocale] == "ru"} { msgcat::mclocale en .but_lang configure -image gb_32x21_f } else { msgcat::mclocale ru .but_lang configure -image rf_32x21_f } #  .lab configure -text "[mc Language]: " }</code> </pre> <br></div></div><br>  Dans ce script, la procédure :: changelang agit en tant que traducteur, qui est appelée lorsque le bouton .but_lang avec l'indicateur est enfoncé. <br><br>  Si vous exécutez ce script, vous verrez clairement comment fonctionne le traducteur: <br><br><img src="https://habrastorage.org/webt/hs/4y/e6/hs4ye6p49e5soy4ud6aje91-e2i.png"><br><br><h3>  Obtenez la clé publique </h3><br>  Maintenant que nous avons choisi un traducteur, procédons à l'analyse du certificat.  Pour ce faire, nous avons besoin du package pki: <br><br><pre> <code class="plaintext hljs">package require pki).</code> </pre> <br>  Le package pki est conçu pour fonctionner avec les clés et certificats d'algorithme RSA.  Si le certificat (proc :: pki :: x509 :: parse_cert) a été créé avec un type de clé différent, nous ne recevrons pas d'informations sur cette clé: <br><br><pre> <code class="plaintext hljs"># Handle RSA public keys by extracting N and E switch -- $ret(pubkey_algo) { "rsaEncryption" { set pubkey [binary format B* $pubkey] binary scan $pubkey H* ret(pubkey) ::asn::asnGetSequence pubkey pubkey_parts ::asn::asnGetBigInteger pubkey_parts ret(n) ::asn::asnGetBigInteger pubkey_parts ret(e) set ret(n) [::math::bignum::tostr $ret(n)] set ret(e) [::math::bignum::tostr $ret(e)] set ret(l) [expr {int([::pki::_bits $ret(n)] / 8.0000 + 0.5) * 8}] set ret(type) rsa } }</code> </pre> <br>  Étonnamment, l'algorithme de clé publique renvoie toujours (ret (pubkey_algo)) <br>  La situation est la même avec l'analyse de la demande de certificat (proc :: pki :: pkcs :: parse_csr): <br><br><pre> <code class="plaintext hljs"># Parse public key, based on type switch -- $pubkey_type { "rsaEncryption" { set pubkey [binary format B* $pubkey] ::asn::asnGetSequence pubkey pubkey_parts ::asn::asnGetBigInteger pubkey_parts key(n) ::asn::asnGetBigInteger pubkey_parts key(e) set key(n) [::math::bignum::tostr $key(n)] set key(e) [::math::bignum::tostr $key(e)] set key(l) [expr {2**int(ceil(log([::pki::_bits $key(n)])/log(2)))}] set key(type) rsa } default { return -code error "Unsupported key type: $pubkey_type" } }</code> </pre> <br>  Mais ici, il retourne même des informations sur l'erreur.  Mais aujourd'hui, en plus de RSA, par exemple, des touches sur les courbes elliptiques de l'UE, y compris GOST R 34.10-2012 (GOST R 34.10-2001 existe également pour l'instant), sont utilisées. <br><br>  Mais il suffit par défaut de renvoyer la structure ASN de la clé publique qui se trouve dans le certificat ou la demande, et l'utilisateur lui-même analysera la clé publique en fonction du type de clé.  Pour ce faire, ajoutez simplement la structure de clé publique ASN en valeurs hexadécimales aux valeurs retournées: <br><br><pre> <code class="plaintext hljs">proc ::pki::x509::parse_cert {cert} { . . . ::asn::asnGetSequence cert subject ::asn::asnGetSequence cert pubkeyinfo #    ASN-  . binary scan $pubkeyinfo H* ret(pubkey_pubkeyinfo) . . . }</code> </pre> <br>  Tout, rien d'autre à faire.  De cette façon, la procédure :: pki :: x509 :: parse_cert renvoie la plupart des extensions de certificat pour la simple raison qu'elle ne sait pas comment les analyser (par exemple, subjectSignTool avec nos certificats qualifiés), c'est-à-dire  donne à la discrétion de l'utilisateur. <br><br>  En revanche, la procédure :: pki :: x509 :: parse_cert renvoie l'un des résultats d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">certificat tbs</a> qui contient toutes les informations du certificat, à l'exception de sa signature (signature) et de son type (signature_algo): <br><br><pre> <code class="plaintext hljs">#    set fd [open «cert.pem» r] chan configure –translation binary set datacert [read $fd] close $fd #  array set cert_parse [::pki::x509::parse_cert $datacert] # tbs- set cert_tbs_hex $cert_parse(cert)</code> </pre> <br>  Nous écrivons la procédure pour extraire les informations de clé publique d'un certificat tbs: <br><br><pre> <code class="plaintext hljs">proc ::pki::x509::parse_cert_pubkeyinfo {cert_tbs_hex} { array set ret [list] set wholething [binary format H* $cert_tbs_hex] ::asn::asnGetSequence wholething cert ::asn::asnPeekByte cert peek_tag if {$peek_tag != 0x02} { # Version number is optional, if missing assumed to be value of 0 ::asn::asnGetContext cert - asn_version ::asn::asnGetInteger asn_version ret(version) } ::asn::asnGetBigInteger cert ret(serial_number) ::asn::asnGetSequence cert data_signature_algo_seq ::asn::asnGetObjectIdentifier data_signature_algo_seq ret(data_signature_algo) ::asn::asnGetSequence cert issuer ::asn::asnGetSequence cert validity ::asn::asnGetUTCTime validity ret(notBefore) ::asn::asnGetUTCTime validity ret(notAfter) ::asn::asnGetSequence cert subject ::asn::asnGetSequence cert pubkeyinfo #    hex asn-   binary scan $pubkeyinfo H* ret(pubkeyinfo) return $ret(pubkeyinfo) }</code> </pre> <br>  Et comme nous nous intéressons à la cryptographie russe, nous écrirons immédiatement la procédure d'analyse de la clé publique GOST: <br><br><pre> <code class="plaintext hljs">proc parse_key_gost {pubkeyinfo_hex} { array set ret [list] set pubkeyinfo [binary format H* $pubkeyinfo_hex] ::asn::asnGetSequence pubkeyinfo pubkey_algoid ::asn::asnGetObjectIdentifier pubkey_algoid ret(pubkey_algo) #,   - if {[string first "1 2 643 " $ret(pubkey_algo)] == -1} { return [array get ret] } ::asn::asnGetBitString pubkeyinfo pubkey set pubkey [binary format B* $pubkey] #   binary scan $pubkey H* ret(pubkey) ::asn::asnGetSequence pubkey_algoid pubalgost #OID -  ::asn::asnGetObjectIdentifier pubalgost ret(paramkey) #OID -   ::asn::asnGetObjectIdentifier pubalgost ret(hashkey) #puts "ret(paramkey)=$ret(paramkey)\n" #puts "ret(hashkey)=$ret(hashkey)\n" #parray ret #  :  ,     return [array get ret] }</code> </pre><br>  Oui, je l'ai presque manqué: après avoir téléchargé le paquet pki, vous devez ajouter au tableau :: pki :: oids des oids qui caractérisent le certificat GOST et qualifié ou qui ne sont tout simplement pas dans ce tableau: <br><br><pre> <code class="plaintext hljs">package require pki # oid- set ::pki::oids(1.2.643.100.1) "OGRN" set ::pki::oids(1.2.643.100.5) "OGRNIP" set ::pki::oids(1.2.643.3.131.1.1) "INN" set ::pki::oids(1.2.643.100.3) "SNILS" set ::pki::oids(1.2.643.2.2.19) "GOST R 34.10-2001" set ::pki::oids(1.2.643.7.1.1.1.1) "GOST R 34.10-2012-256" set ::pki::oids(1.2.643.7.1.1.1.2) "GOST R 34.10-2012-512" set ::pki::oids(1.2.643.2.2.3) "GOST R 34.10-2001 with GOST R 34.11-94" set ::pki::oids(1.2.643.7.1.1.3.2) "GOST R 34.10-2012-256 with GOSTR 34.11-2012-256" set ::pki::oids(1.2.643.7.1.1.3.3) "GOST R 34.10-2012-512 with GOSTR 34.11-2012-512" set ::pki::oids(1.2.643.100.113.1) "KC1 Class Sign Tool" set ::pki::oids(1.2.643.100.113.2) "KC2 Class Sign Tool" . . .</code> </pre> <br>  Vous pouvez également reconstituer le vocabulaire du traducteur en ajoutant au fichier ru.msg: <br><br><pre> <code class="plaintext hljs">mcset ru "GOST R 34.10-2001" "  34.10-2001" mcset ru "GOST R 34.10-2012-256" "  34.10-2012-256" mcset ru "GOST R 34.10-2012-512" "  34.10-2012-512" mcset ru "GOST R 34.10-2001 with GOST R 34.11-94" "  34.10-2001    34.11-94" mcset ru "GOST R 34.10-2012-256 with GOSTR 34.11-2012-256" "  34.10-2012-256    34.11-2012-256" mcset ru "GOST R 34.10-2012-512 with GOSTR 34.11-2012-512" "  34.10-2012-512    34.11-2012-512" . . .</code> </pre>  : <br><img src="https://habrastorage.org/webt/am/gu/td/amgutdxuj-xkszh1qpmeaa-hf1g.png"><br><br><h3>  Chaîne de certificats racine et liste de révocation de certificats </h3><br>  Comment obtenir une chaîne de certificats racine a déjà été discuté précédemment.  Par analogie, une procédure est écrite pour obtenir une liste des certificats COS / CRL révoqués.  Le code source de l'utilitaire et ses distributions pour Linux, OS X (macOS) et MS Windows peuvent être trouvés <br><br><div class="spoiler">  <b class="spoiler_title">ici</b> <div class="spoiler_text"><ul><li>  <a href="">code source</a> </li><li>  <a href="">Linux32</a> </li><li>  <a href="">Linux64</a> </li><li>  <a href="">OS X</a> </li><li>  <a href="">WIN32</a> </li><li>  <a href="">WIN64</a> </li></ul><br></div></div><br>  Dans le code source, vous pouvez trouver toutes les procédures d'analyse des extensions de certificat. <br>  Aux opposants à Tk (Tcl / Tk, Python / Tkinter, etc.), je propose de trouver, comme on dit, 10 (dix) différences entre les deux utilitaires: l'utilitaire gcr-viewer écrit en gtk et l'utilitaire certViewer développé en Tk: <br><br><img src="https://habrastorage.org/webt/pq/k5/a5/pqk5a5yrh7fbjhlrfipmdvu5tyg.png"><br><br><h3>  Certificats PKCS # 11 Token / Smartcard </h3><br>  Ci-dessus, nous avons parlé de travailler avec des certificats (parcourir, obtenir la chaîne de certificats racine, listes de certificats révoqués, empreintes digitales par sha1 et sha256, etc.) stockés dans des fichiers.  Mais il reste des certificats stockés sur les jetons / cartes à puce PKCS # 11.  Et le désir naturel n'est pas seulement de les voir, puis de les exporter dans un fichier.  Comment faire cela, nous décrirons dans l'article suivant: <br><br><img src="https://habrastorage.org/webt/vx/25/cu/vx25culnj3anfl_jwbkgd-t8nk4.png"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440754/">https://habr.com/ru/post/fr440754/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440742/index.html">Pages AMP et Turbo: avantages, inconvénients et résultats de la mise en œuvre</a></li>
<li><a href="../fr440744/index.html">PHP pour les débutants. Gestion des erreurs</a></li>
<li><a href="../fr440746/index.html">La technologie de gestion des connaissances de Gartner utilise des études de cas sur KnowledgeConf</a></li>
<li><a href="../fr440748/index.html">Le supercalculateur le plus rapide du monde bat le record de l'IA</a></li>
<li><a href="../fr440752/index.html">Sélection de la priorité de la demande de l'utilisateur</a></li>
<li><a href="../fr440756/index.html">CI / CD sans serveur sur AWS</a></li>
<li><a href="../fr440758/index.html">Allez Meetup à Acronis! (Moscou, Fiztehpark)</a></li>
<li><a href="../fr440760/index.html">Le nouvel âge d'or de l'architecture informatique</a></li>
<li><a href="../fr440762/index.html">Avis des employeurs: la nature et le non-sens des avis anonymes</a></li>
<li><a href="../fr440766/index.html">Des geeks aux geeks: des cadeaux pour le 23 février</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>