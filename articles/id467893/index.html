<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👍🏾 🌭 📙 Hanya pembungkus Qt lain untuk gRPC dan protobuf 😡 ✍🏻 🤳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Belum lama ini, saya bingung dengan kenyataan bahwa tidak ada cukup pembungkus dan generator yang nyaman dan sederhana untuk protobuf dan gRPC, berbas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hanya pembungkus Qt lain untuk gRPC dan protobuf</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467893/"><img src="https://habrastorage.org/webt/5l/o2/cn/5lo2cnubwwz2llx4ufpcbm2g_-m.png"><br><br>  Belum lama ini, saya bingung dengan kenyataan bahwa tidak ada cukup pembungkus dan generator yang nyaman dan sederhana untuk protobuf dan gRPC, berbasis dan sepenuhnya kompatibel dengan Qt.  Saya menemukan artikel, termasuk  di sini tentang pembungkus, tetapi penggunaannya bagi saya jauh kurang praktis daripada bahkan C ++ API yang ada. <br><a name="habracut"></a><br><h2>  Sedikit tentang gRPC dan protobuf </h2><br>  Mari kita simulasikan sebuah situasi: Anda akan menulis proyek multi-platform dan Anda perlu memilih kerangka kerja RPC untuk berkomunikasi dengan layanan Anda.  Anda selalu dapat meninju dada Anda dan mengatakan "Saya adalah kerangka kerja saya sendiri," tetapi bagi saya sepertinya kita hidup di era solusi siap pakai.  Salah satu solusi semacam itu dipresentasikan kepada kami oleh perusahaan terkenal untuk waktu yang lama.  Saya tidak berasumsi untuk membandingkan kerangka kerja RPC, ini bukan tujuan dari artikel ini.  Cukup untuk daftar apa yang saya suka tentang gRPC: <br><br><ul><li>  IDL ringkas dan jelas </li><li>  Kehadiran sejumlah besar generator untuk berbagai platform </li><li>  Kode klien / server yang dihasilkan untuk pembuatan prototipe dan penulisan aplikasi pengujian yang cepat dan mudah </li></ul><br><h2>  Ke intinya </h2><br>  Karena fakta bahwa Qt melakukan dengan cukup baik dengan jenis refleksi, dan jumlah meta-informasi umumnya pada tingkat tertinggi, itu sampai pada kesadaran bahwa Anda memerlukan generator Anda sendiri yang akan menghasilkan kode Qt "murni", tanpa menyelingi perpustakaan pihak ketiga.  Jadi qtprotobufgen lahir. <br><br><h3>  qtprotobufgen </h3><br>  qtprotobufgen adalah generator inheren yang paling sederhana, yang didasarkan pada API yang disediakan oleh libprotoc.  Jika Anda ingin membuat sesuatu seperti itu untuk kebutuhan Anda, saya akan meninggalkan sedikit kecurangan. <br><br><ul><li>  Anda memiliki satu titik masuk ke kelas plugin :: google :: protobuf :: compiler :: CodeGenerator, dari mana Anda perlu mewarisi </li><li>  Menghasilkan metode virtual menentukan pembuatan ketika bekerja dengan file .proto terpisah </li><li>  Metode virtual GenerateAll menentukan pembuatan ketika bekerja dengan array penuh file .proto yang disediakan untuk pembuatan atau menjadi dependensi </li><li>  Metode HasGenerateAll virtual pada dasarnya adalah peninggalan yang bertahan dari versi sebelumnya.  Kembali benar </li></ul><br>  Saya harus segera mengatakan bahwa tidak ada keinginan untuk menulis parser / generator saya sendiri dari awal, karena ada solusi siap pakai dari pengembang protobuf.  Tetapi jika Anda mau, Anda bisa membaca aliran biner yang memproteksi masalah, atau menulis parser file proto Anda sendiri. <br><br>  Selama pengembangan, satu kelemahan signifikan dari generator yang ditulis dalam bahasa yang dikompilasi muncul: sulit untuk menempatkan generasi dan kompilasi dalam satu tumpukan CMake.  Karena fakta bahwa Qt menghasilkan informasi meta-objek, berdasarkan file header yang memiliki makro Q_OBJECT di dalam tubuh kelas yang dinyatakan dalam file header, perlu pada tahap konfigurasi (baca cmake) untuk memiliki gambaran tentang file yang akan disediakan oleh moc untuk pembuatan kode lebih lanjut.  Sebagai solusi, saya harus menggunakan bahasa yang ditafsirkan Go (Lang), yang tidak menciptakan dependensi tambahan dan melakukan tugasnya dengan sempurna, tetapi tidak lulus pengujian yang cukup. <br><br>  Generator tunduk pada aturan protoc yang ada, dan pada saat penulisan, tidak memperkenalkan opsi generasi tambahan apa pun: <br><br><pre><code class="bash hljs">protoc --plugin=protoc-gen-qtprotobuf=&lt;path/to/bin&gt;/qtprotobufgen --qtprotobuf_out=&lt;output_dir&gt; &lt;protofile&gt;.proto [--qtprotobuf_opt=out=&lt;output_dir&gt;]</code> </pre> <br>  Untuk kesederhanaan dan kemudahan penggunaan, Anda dapat menggunakan rutin cmake yang disiapkan khusus untuk menghasilkan kode, dan menanamkannya dalam proyek cmake.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Lebih detail ...</a> <br><br><h3>  Tentang Perpustakaan </h3><br>  Saya tidak melihat banyak gunanya dalam menggambarkan API secara rinci.  Mereka yang ingin dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">menghasilkan</a> dokumentasi dan membaca lebih banyak tentang API yang saat ini tersedia. <br><br>  Proyek ini dibagi menjadi 2 bagian logis qtprotobuf dan qtgrpc.  Dari namanya, saya pikir tujuan masing-masing komponen jelas.  Kami mencoba membuat penggunaan senyaman mungkin, karena ada opsi integrasi dengan pustaka yang dirakit sebelumnya dan diinstal dalam sistem, dan integrasi subproyek ke dalam proyek cmake Anda. <br><br>  Kode yang dihasilkan sepenuhnya <font color="#ff0000"><b>*</b></font> diekspor ke QML, yang membuat bekerja dengan API gRPC jauh lebih mudah. <br><br><h3>  Gunakan </h3><br>  Setelah berintegrasi dengan proyek dan melakukan pembuatan, Anda akan menerima satu set file sumber, yang nantinya akan dikumpulkan di perpustakaan statis dan ditautkan ke file biner Anda.  Perubahan terbaru mengecualikan kemungkinan pendaftaran statis yang dihasilkan dan tipe proto.  Karena itu, Anda perlu mengurus pendaftaran mereka di proyek: <br><br><pre> <code class="cpp hljs">... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QtProtobufTypes&gt; ... int main(int argc, char *argv[]) { QtProtobuf::registerProtoTypes(); ... //   Qt  }</span></span></span></span></code> </pre><br>  Pada saat penulisan, tidak ada metode tunggal untuk mendaftarkan semua jenis yang dihasilkan untuk paket proto, jadi Anda perlu memanggil metode qRegisterProtobufType untuk semua jenis yang digunakan dalam aplikasi: <br><br><pre> <code class="cpp hljs">... qRegisterProtobufType&lt;MyProtoType&gt;(); ...</code> </pre><br>  Penggunaan perpustakaan dan generator dijelaskan dalam README, dan beberapa contoh menyertai proyek.  Bagi mereka yang sama sekali tidak akrab dengan gRPC / protobuf saya sarankan Anda membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">dokumentasi resmi</a> <br><br><h3>  Untuk pengembang </h3><br>  Kami mencoba mematuhi TDD selama pengembangan, dan tidak ingin menyimpang darinya.  Seperti yang ditunjukkan oleh pengalaman kami, TDD menyelamatkan Anda saat refactoring atau memperbarui API, itu membantu mendeteksi masalah tersembunyi.  Karena itu, jika ada keinginan untuk berkontribusi, bersiaplah untuk menulis unit, unit dan tes fungsional. <br><br><h3>  <font color="#ff0000"><b>*</b></font> Masalah yang diketahui </h3><br>  Saat ini ada sejumlah masalah terkait Qt.  Beberapa dari mereka diselesaikan, dengan kami atau tanpa partisipasi kami, tetapi tidak semuanya dimasukkan dalam rilis Qt saat ini.  Yang utama adalah tidak dapat diaksesnya beberapa jenis protobuf dasar dari kode qml.  Saya pikir bukan rahasia bagi siapa pun bahwa rangkaian tipe yang tersedia di QML sangat terbatas, sebagian karena penggunaan V8 sebagai mesin JS.  Upaya untuk membuat QML sedikit lebih ramah untuk tipe yang dikustomisasi (misalnya, fixed32, sint32) gagal, tetapi ternyata memperbaiki sumber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">masalah</a> .  Implementasi QtNetwork saat ini juga memiliki sejumlah masalah, tetapi tim Qt segera memperbaikinya. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">QTBUG-77852</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">QTBUG-76303</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">QTBUG-78310</a> <br><br><h3>  Paket </h3><br>  Semua aktivitas saat ini terkait dengan pemecahan masalah dalam kode proyek atau dalam kode Qt.  Tetapi ada sejumlah besar pekerjaan yang terkait dengan fungsi baru: <br><br><ol><li>  <s>Transisi ke sepasang file .h / .cpp untuk kode yang dihasilkan</s> </li><li>  Implementasi server GRPC </li><li>  <s>Daur ulang API untuk kredensial gRPC</s> </li><li>  Distribusi kode yang dihasilkan ke direktori dan pembuatan plug-in sub-proyek untuk pemuatan paket dan modul yang dihasilkan secara terpisah </li><li>  <s>Integrasi Qmake</s> </li><li>  <s>Implementasi CI</s> </li></ol><br>  Ada beberapa simpanan, yang masih disimpan di repositori proyeknya sendiri. <br><br>  Alih-alih kesimpulan, saya ingin mengucapkan terima kasih kepada kawan-kawan dari PVS-Studio untuk kunci yang disediakan untuk proyek OSS.  Dengan bantuan mereka, mereka menemukan bug yang agak kritis dalam kode yang dihasilkan. <br><br>  Unduh, lihat proyeknya dan mainkan dengan contoh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">sini</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467893/">https://habr.com/ru/post/id467893/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467881/index.html">Tutu.ru backend meetup</a></li>
<li><a href="../id467883/index.html">Kubernetes 1.16 - cara memutakhirkan dan tidak merusak apa pun</a></li>
<li><a href="../id467885/index.html">Tambang produk dan segmen</a></li>
<li><a href="../id467887/index.html">Refleksi Caustic Realistis</a></li>
<li><a href="../id467891/index.html">FAQ tentang tanda tangan cloud [elektronik]</a></li>
<li><a href="../id467895/index.html">Pola apa yang ditemukan jaringan saraf?</a></li>
<li><a href="../id467897/index.html">Alat uji otomatis, integrasi Yandex Mapkit 3, desain keren, dan pendekatan UI Berbasis Server - Pengumuman mitap Android</a></li>
<li><a href="../id467901/index.html">Sanggah empat stereotip tentang bahasa pemrograman Rust</a></li>
<li><a href="../id467903/index.html">20 fitur navigasi teratas di IntelliJ IDEA. Bagian 1</a></li>
<li><a href="../id467905/index.html">Bagaimana kami membuat pengakuan tengara di Cloud Mail.ru, dan mengapa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>