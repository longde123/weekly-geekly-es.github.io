<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔 🏌️ 😨 DCF77: Wie funktioniert das genaue Zeitsignalübertragungssystem? 👩🏾‍🎤 🏂🏼 💀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr. 

 Wahrscheinlich haben viele Leute, die eine Uhr oder eine Wetterstation kaufen, das Logo der ferngesteuerten Uhr oder sogar die Atomuhr ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DCF77: Wie funktioniert das genaue Zeitsignalübertragungssystem?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445470/">  Hallo Habr. <br><br>  Wahrscheinlich haben viele Leute, die eine Uhr oder eine Wetterstation kaufen, das Logo der ferngesteuerten Uhr oder sogar die Atomuhr auf der Verpackung gesehen.  Dies ist sehr praktisch, da es ausreicht, die Uhr auf den Tisch zu stellen, und nach einer Weile werden sie automatisch auf die genaue Zeit eingestellt. <br><br><img src="https://habrastorage.org/webt/ev/vs/ia/evvsia3kcrvsnw_gxwoe_jen5r0.png"><br><br>  Mal sehen, wie es funktioniert und einen Decoder in Python schreiben. <br><a name="habracut"></a><br>  Es gibt verschiedene Zeitsynchronisationssysteme.  Das beliebteste in Europa ist das deutsche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DCF-77-System</a> , Japan hat ein eigenes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JJY-</a> System, die USA haben ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WWVB-</a> System und so weiter.  Darüber hinaus handelt es sich um DCF77, das an einigen Orten im europäischen Teil Russlands und in den Nachbarländern am relevantesten und für den Empfang zugänglich ist (die Bewohner des Fernen Ostens mögen die gegenteilige Meinung vertreten, können jedoch wiederum das japanische Signal akzeptieren und analysieren;). <br><br>  Alles, was unten geschrieben steht, handelt von DCF77. <br><br><h2>  Signalempfang </h2><br>  DCF77 ist eine langwellige Station, die mit einer Frequenz von 77,5 kHz arbeitet und Signale in Amplitudenmodulation überträgt.  Die Station mit einer Leistung von 50 kW befindet sich 25 km von Frankfurt entfernt und wurde bereits 1959 in Betrieb genommen. 1973 wurden die Datumsangaben zur genauen Uhrzeit hinzugefügt.  Die Wellenlänge bei einer Frequenz von 77 kHz ist sehr groß, daher sind auch die Abmessungen des Antennenfeldes sehr anständig (Foto aus Wikipedia): <br><br><img src="https://habrastorage.org/webt/df/du/2l/dfdu2lbixopwvordolwij3w_ncs.png"><br><br>  Mit einer solchen Antenne und Stromversorgung deckt der Empfangsbereich fast ganz Europa, Weißrussland, die Ukraine und einen Teil Russlands ab. <br><br><img src="https://habrastorage.org/webt/my/xz/wu/myxzwuf8yjqunjcn5rah1f1oyry.png"><br><br>  Jeder kann ein Signal aufnehmen.  Gehen Sie dazu einfach zum Online-Empfänger <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://websdr.ewi.utwente.nl:8901/</a> , wählen Sie dort die Frequenz 76,5 kHz und die USB-Modulation aus.  Ein Bild von so etwas sollte sich öffnen: <br><br><img src="https://habrastorage.org/webt/d4/yt/lc/d4ytlcfvkgf_7ea-vgytr-eljum.png"><br><br>  Dort drücken wir den Download-Button und nehmen ein mehrere Minuten langes Fragment auf.  Wenn Sie einen „echten“ Empfänger haben, der eine Frequenz von 77,5 kHz aufnehmen kann, können Sie ihn natürlich verwenden. <br><br>  Wenn wir über das Internet Funksignale der genauen Zeit empfangen, erhalten wir natürlich keine wirklich genaue Zeit - das Signal wird mit einer Verzögerung übertragen.  Unser Ziel ist es jedoch nur, die Struktur des Signals zu verstehen. Dafür ist die Internetaufzeichnung mehr als ausreichend.  Im wirklichen Leben werden natürlich spezielle Geräte zum Empfangen und Decodieren verwendet, auf die weiter unten eingegangen wird. <br><br>  Also haben wir den Datensatz, fangen wir an, ihn zu verarbeiten. <br><br><h2>  Signaldecodierung </h2><br>  Laden Sie die Datei mit Python herunter und sehen Sie sich ihre Struktur an: <br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wavfile <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> signal <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np sample_rate, data = wavfile.read(<span class="hljs-string"><span class="hljs-string">"dcf_websdr_2019-03-26T20_25_34Z_76.6kHz.wav"</span></span>) plt.plot(data[:<span class="hljs-number"><span class="hljs-number">100000</span></span>]) plt.show()</code> </pre> <br>  Wir sehen eine typische Amplitudenmodulation: <br><br><img src="https://habrastorage.org/webt/ls/ew/oz/lsewoz-zrzcjvpfcr4pbtnmbmva.png"><br><br>  Um die Decodierung zu vereinfachen, nehmen wir die Hüllkurve des Signals mit der Hilbert-Transformation: <br><br><pre> <code class="python hljs">analytic_signal = signal.hilbert(data) A = np.abs(analytic_signal) plt.plot(A[:<span class="hljs-number"><span class="hljs-number">100000</span></span>])</code> </pre> <br>  Ergebnis in vergrößerter Ansicht: <br><br><img src="https://habrastorage.org/webt/ny/gn/ac/nygnacnm-kwcoba12j6vks-ixk0.png"><br><br>  Wir glätten die Interferenzemissionen mithilfe eines Tiefpassfilters. Gleichzeitig berechnen wir den Durchschnittswert, der später zum Parsen nützlich sein wird. <br><br><pre> <code class="python hljs">b, a = signal.butter(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">20.0</span></span>/sample_rate) zi = signal.lfilter_zi(b, a) A, _ = signal.lfilter(b, a, A, zi=zi*A[<span class="hljs-number"><span class="hljs-number">0</span></span>]) avg = (np.amax(A) + np.amin(A))/<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Ergebnis (gelbe Linie): Ein fast rechteckiges Signal, das ziemlich einfach zu analysieren ist. <br><br><img src="https://habrastorage.org/webt/fa/yp/wn/faypwn97babbqqgosvekm7eys90.png"><br><br><h2>  Parsen </h2><br>  Zuerst müssen Sie die Bitfolge erhalten.  Die Signalstruktur selbst ist sehr einfach. <br><br><img src="https://habrastorage.org/webt/hm/hy/s5/hmhys54d9zic5a6ltn7e32oyklg.png"><br><br>  Impulse werden in zweite Intervalle unterteilt.  Wenn der Abstand zwischen den Impulsen 0,1 s beträgt (dh die Impulslänge beträgt 0,9 s), fügen Sie der Bitsequenz „0“ hinzu. Wenn der Abstand 0,2 s (dh 0,8 s Länge) beträgt, fügen Sie „1“ hinzu.  Das Ende jeder Minute wird durch einen "langen" Impuls angezeigt, der 2 Sekunden lang ist, die Bitsequenz wird auf Null zurückgesetzt und das Füllen beginnt erneut. <br><br>  Das Obige ist einfach in Python zu schreiben. <br><br><pre> <code class="python hljs">sig_start, sig_stop = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span> bits_str = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> pos &lt; cnt - <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> A[pos] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> A[pos+<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: <span class="hljs-comment"><span class="hljs-comment"># Signal begin sig_start = pos if A[pos] &gt; avg and A[pos+1] &lt; avg: # Signal end sig_stop = pos diff = sig_stop - sig_start if diff &lt; 0.85*sample_rate: bits_str += "1" if diff &gt; 0.85*sample_rate and diff &lt; 1.25*sample_rate: bits_str += "0" if diff &gt; 1.5*sample_rate: print(bits_str) bits_str = "" pos += 1</span></span></code> </pre><br>  Als Ergebnis erhalten wir eine Folge von Bits. In unserem Beispiel sieht es zwei Minuten lang so aus: <br><br> <code>0011110110111000001011000001010000100110010101100010011000 <br> 0001111100110110001010100001010000100110010101100010011000</code> <br> <br>  Interessant ist übrigens, dass das Signal eine „zweite Datenschicht“ enthält.  Die Bitfolge wird auch mittels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phasenmodulation</a> codiert.  Theoretisch sollte dies auch bei einem geschwächten Signal zu einer stabileren Decodierung führen. <br><br>  Unser letzter Schritt: Holen Sie sich die tatsächlichen Daten.  Bits werden einmal pro Sekunde übertragen, sodass wir nur 59 Bits haben, in denen viele Informationen codiert sind: <br><br><img src="https://habrastorage.org/webt/e2/r1/le/e2r1le0xrrrgenjxxlpmwo5h3v0.png"><br><br>  Die Bits sind auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> beschrieben und ziemlich neugierig.  Die ersten 15 Bits werden nicht verwendet, obwohl geplant war, sie für Warnsysteme <s>und den Zivilschutz zu verwenden</s> .  Bit A1 zeigt an, dass in der nächsten Stunde die Uhr auf Sommerzeit eingestellt wird.  Bit A2 zeigt an, dass in der nächsten Stunde eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zusätzliche Sekunde</a> hinzugefügt wird, die manchmal verwendet wird, um die Zeit entsprechend der Erdrotation zu korrigieren.  Die verbleibenden Bits codieren Stunden, Minuten und Datum. <br><br><img src="https://habrastorage.org/webt/fh/ti/oj/fhtiojtscjytfzu1rk4a_0yt4pw.png"><br><br>  Für diejenigen, die alleine experimentieren möchten, wird der Code zum Decodieren unter dem Spoiler angegeben. <br><br><div class="spoiler">  <b class="spoiler_title">Quellcode</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bits)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bits[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">'0'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> bits[<span class="hljs-number"><span class="hljs-number">20</span></span>] != <span class="hljs-string"><span class="hljs-string">'1'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> minutes, hours, day_of_month, weekday, month, year = map(convert_block, (bits[<span class="hljs-number"><span class="hljs-number">21</span></span>:<span class="hljs-number"><span class="hljs-number">28</span></span>], bits[<span class="hljs-number"><span class="hljs-number">29</span></span>:<span class="hljs-number"><span class="hljs-number">35</span></span>], bits[<span class="hljs-number"><span class="hljs-number">36</span></span>:<span class="hljs-number"><span class="hljs-number">42</span></span>], bits[<span class="hljs-number"><span class="hljs-number">42</span></span>:<span class="hljs-number"><span class="hljs-number">45</span></span>], bits[<span class="hljs-number"><span class="hljs-number">45</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span>], bits[<span class="hljs-number"><span class="hljs-number">50</span></span>:<span class="hljs-number"><span class="hljs-number">58</span></span>])) days = (<span class="hljs-string"><span class="hljs-string">'Sunday'</span></span>, <span class="hljs-string"><span class="hljs-string">'Monday'</span></span>, <span class="hljs-string"><span class="hljs-string">'Tuesday'</span></span>, <span class="hljs-string"><span class="hljs-string">'Wednesday'</span></span>, <span class="hljs-string"><span class="hljs-string">'Thursday'</span></span>, <span class="hljs-string"><span class="hljs-string">'Friday'</span></span>, <span class="hljs-string"><span class="hljs-string">'Saturday'</span></span>, <span class="hljs-string"><span class="hljs-string">'Sunday'</span></span>) print(<span class="hljs-string"><span class="hljs-string">'{dow}, {dom:02}.{mon:02}.{y}, {h:02}:{m:02}'</span></span>.format(h=hours, m=minutes, dow=days[weekday], dom=day_of_month, mon=month, y=year)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert_ones</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bits)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum(<span class="hljs-number"><span class="hljs-number">2</span></span>**i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, bit <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(bits) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bit == <span class="hljs-string"><span class="hljs-string">'1'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert_tens</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bits)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>*convert_ones(bits) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">right_parity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bits, parity_bit)</span></span></span><span class="hljs-function">:</span></span> num_of_ones = sum(int(bit) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> bit <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> bits) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num_of_ones % <span class="hljs-number"><span class="hljs-number">2</span></span> == int(parity_bit) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert_block</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bits, parity=False)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> parity <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> right_parity(bits[:<span class="hljs-number"><span class="hljs-number">-1</span></span>], bits[<span class="hljs-number"><span class="hljs-number">-1</span></span>]): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> ones = bits[:<span class="hljs-number"><span class="hljs-number">4</span></span>] tens = bits[<span class="hljs-number"><span class="hljs-number">4</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> convert_tens(tens) + convert_ones(ones)</code> </pre><br></div></div><br>  Wenn wir das Programm ausführen, sehen wir ungefähr Folgendes: <br><br> <code>0011110110111000001011000001010000100110010101100010011000 <br> Tuesday, 26.03.19, 21:41 <br> 0001111100110110001010100001010000100110010101100010011000 <br> Tuesday, 26.03.19, 21:42</code> <br> <br>  Eigentlich ist das alles Magie.  Der Vorteil eines solchen Systems besteht darin, dass die Decodierung äußerst einfach ist und auf jedem der unkompliziertesten Mikrocontroller durchgeführt werden kann.  Zählen Sie einfach die Länge der Impulse, akkumulieren Sie 60 Bits und am Ende jeder Minute erhalten wir die genaue Zeit.  Im Vergleich zu anderen Methoden der Zeitsynchronisation (z. B. GPS oder Gott bewahre das Internet :) benötigt eine solche Funksynchronisation praktisch keinen Strom - zum Beispiel arbeitet eine gewöhnliche Wetterstation zu Hause etwa ein Jahr lang mit 2 AA-Batterien.  Daher wird sogar eine Armbanduhr mit Funksynchronisation hergestellt, ganz zu schweigen von einer Wand- oder Straßenstation. <br><br>  Der Komfort und die Einfachheit von DCF ziehen Liebhaber hausgemachter Produkte an.  Für nur 10 bis 20 US-Dollar können Sie ein fertiges Modul von einer Antenne mit einem fertigen Empfänger und einem TTL-Ausgang kaufen, der an einen Arduino oder einen anderen Controller angeschlossen werden kann. <br><br><img src="https://habrastorage.org/webt/po/ph/mk/pophmk5x_xmgb3dzozwu34sbxya.png"><br><br>  Für Arduino wurden bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorgefertigte Bibliotheken</a> geschrieben.  Es ist jedoch bereits bekannt, dass Sie unabhängig davon, was Sie auf dem Mikrocontroller tun, entweder eine Uhr oder eine Wetterstation erhalten.  Mit einem solchen Gerät ist es sehr einfach, die genaue Uhrzeit zu ermitteln, vorausgesetzt, Sie befinden sich im Empfangsbereich.  Nun, Sie können die Aufschrift „Atomic Clock“ an die Uhr hängen und gleichzeitig allen, die es wollen, erklären, dass das Gerät wirklich mit einer Atomuhr synchronisiert ist. <br><br>  Wer möchte, kann sogar die Uhren seiner alten Großmutter aufrüsten, indem er einen neuen Mechanismus mit Funksynchronisation installiert: <br><br><img src="https://habrastorage.org/webt/om/5w/2k/om5w2k-nno2ueo5tpxk6pkrrpls.png"><br><br>  Sie finden eine bei ebay unter den Stichwörtern „Radio Controlled Movement“. <br><br>  Und schließlich ein Lebenshack für diejenigen, die hier gelesen haben.  Selbst wenn es in den nächsten paar tausend Kilometern keinen einzigen Sender eines Funksignals gibt, ist ein solches Signal leicht unabhängig zu erzeugen.  Google Play hat ein Programm namens "DCF77 Emulator", das ein Signal an die Kopfhörer ausgibt.  Wenn Sie das Kopfhörerkabel um die Uhr wickeln, werden sie laut Autor ein Signal empfangen (ich frage mich, wie, weil gewöhnliche Kopfhörer kein 77-kHz-Signal geben, aber der Empfang wahrscheinlich über Oberwellen erfolgt).  Mein Programm funktionierte unter Android 9 überhaupt nicht - es gab einfach keinen Ton (oder ich habe ihn vielleicht nicht gehört - schließlich 77 kHz :), aber vielleicht hat jemand mehr Glück.  Einige machen sich jedoch selbst zu einem vollwertigen DCF-Signalgenerator, was mit demselben Arduino oder ESP32 einfach zu bewerkstelligen ist: <br><br><img src="https://habrastorage.org/webt/vs/ye/jk/vsyejk6pr6mxfymg55fqscbzn1i.png"><br>  (Quelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sgfantasytoys.wordpress.com/2015/05/13/synchronize-radio-controlled-watch-without-access</a> ) <br><br><h2>  Fazit </h2><br>  Das DCF-System erwies sich als sehr einfach und bequem.  Mit Hilfe eines einfachen und günstigen Empfängers können Sie die genaue Zeit jederzeit und überall im Empfangsbereich abrufen.  Trotz der weit verbreiteten Digitalisierung und des „Internet der Dinge“ scheinen solche einfachen Lösungen noch lange gefragt zu sein. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445470/">https://habr.com/ru/post/de445470/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445458/index.html">Electronic Arts wird 350 Mitarbeiter beschäftigen und seine Präsenz in Russland reduzieren</a></li>
<li><a href="../de445460/index.html">Gadget-freie Interaktivität</a></li>
<li><a href="../de445464/index.html">Verringerung der Stichprobengröße experimenteller Daten ohne Informationsverlust</a></li>
<li><a href="../de445466/index.html">Herzlichen Glückwunsch Imagine Cup EMEA Regional Final Champions: Team Finderr aus Großbritannien! Das russische Team ist Dritter</a></li>
<li><a href="../de445468/index.html">Ein Team aus Russland belegte beim Imagine Cup-Wettbewerb in Europa, Afrika und im Nahen Osten den dritten Platz</a></li>
<li><a href="../de445472/index.html">YouTube Entscheidung getroffen, Zensur sein! und wie immer konnte Russland nicht darauf verzichten</a></li>
<li><a href="../de445474/index.html">MODX Digest # 2.1 (11. März - 25. März 2019)</a></li>
<li><a href="../de445478/index.html">Das Europäische Parlament nimmt weiterhin Änderungen des EU-Urheberrechts an</a></li>
<li><a href="../de445480/index.html">Matte mit einem Elefanten und einem Pferd. Dreiecke deletan</a></li>
<li><a href="../de445482/index.html">6 Grundlegende Python-Bibliotheken für die Python-Programmierung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>