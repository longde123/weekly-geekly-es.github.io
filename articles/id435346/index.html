<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍙 🚄 🌺 Berlangganan Kafka melalui HTTP atau cara menyederhanakan kait web Anda ⌚️ 🏿 👊🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada banyak cara untuk memproses pesan dari sistem Pub-Sub: menggunakan layanan terpisah, mengisolasi proses yang terisolasi, mengatur kumpulan proses ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Berlangganan Kafka melalui HTTP atau cara menyederhanakan kait web Anda</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435346/">  Ada banyak cara untuk memproses pesan dari sistem Pub-Sub: menggunakan layanan terpisah, mengisolasi proses yang terisolasi, mengatur kumpulan proses / aliran, IPC kompleks, Poll-over-Http dan banyak lainnya.  Hari ini saya ingin berbicara tentang cara menggunakan Pub-Sub melalui HTTP dan tentang layanan saya yang ditulis khusus untuk ini. <br><br>  Dalam beberapa kasus, menggunakan backend layanan HTTP yang sudah jadi adalah solusi ideal untuk memproses antrian pesan: <br><br><ol><li>  Seimbang di luar kotak.  Biasanya, backend sudah di belakang penyeimbang dan memiliki infrastruktur siap-untuk-memuat, yang sangat menyederhanakan pekerjaan dengan pesan. </li><li>  Menggunakan pengontrol REST reguler (sumber daya HTTP apa pun).  Mengkonsumsi pesan HTTP meminimalkan biaya penerapan compumer untuk berbagai bahasa jika backend tercampur. </li><li>  Penyederhanaan penggunaan kait Web dari layanan lain.  Sekarang hampir setiap layanan (Jira, Gitlab, Mattermost, Slack ...) entah bagaimana mendukung kait Web untuk berinteraksi dengan dunia luar.  Anda dapat membuat hidup lebih mudah jika Anda mengajarkan antrean untuk melakukan fungsi-fungsi pengirim HTTP. </li></ol><br>  Pendekatan ini juga memiliki kelemahan: <br><br><ol><li>  Anda bisa melupakan ringannya solusinya.  HTTP adalah protokol yang berat, dan penggunaan kerangka kerja di sisi konsumen akan secara instan meningkatkan latensi dan pemuatan. </li><li>  Kami kehilangan kekuatan dari pendekatan Polling, mendapatkan kelemahan dari Push. </li><li>  Memproses pesan dengan instance layanan yang sama yang memproses klien dapat memengaruhi responsif.  Ini tidak signifikan, karena diperlakukan dengan penyeimbangan dan isolasi. </li></ol><br>  Saya menerapkan ide itu sebagai layanan Antrian-Over-Http, yang akan dibahas nanti.  Proyek ini ditulis dalam Kotlin menggunakan Spring Boot 2.1.  Sebagai broker, hanya Apache Kafka yang saat ini tersedia. <br><a name="habracut"></a><br>  <i>Lebih lanjut dalam artikel tersebut, diasumsikan bahwa pembaca telah mengenal Kafka dan mengetahui tentang komit (komit) dan offset (offset) pesan, prinsip-prinsip grup (grup) dan konsumen (konsumen), dan juga memahami bagaimana partisi (partisi) berbeda dari topik (topik) .</i>  <i>Jika ada celah, saya sarankan Anda untuk membaca bagian dokumentasi Kafka ini sebelum melanjutkan.</i> <br><br><h1>  Isi </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ulasan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berkomitmen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menangani kesalahan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pesan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Performa</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Demonstrasi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesimpulan</a> </li></ul><br><a name="overview"></a><h1>  Ulasan </h1><br>  Queue-Over-Http adalah layanan yang bertindak sebagai perantara antara broker pesan dan pengguna HTTP akhir (layanan ini memudahkan implementasi dukungan untuk mengirim pesan ke konsumen dengan cara lain, misalnya, dalam berbagai * RPC).  Saat ini, hanya berlangganan, berhenti berlangganan, dan melihat daftar konsumen yang tersedia. Mengirim pesan ke broker (produksi) melalui HTTP belum dilaksanakan karena ketidakmampuan untuk menjamin urutan pesan tanpa dukungan khusus dari produsen. <br><br>  Tokoh utama dari layanan ini adalah konsumen, yang dapat berlangganan partisi tertentu atau hanya untuk topik (pola topik didukung).  Dalam kasus pertama, keseimbangan otomatis partisi dimatikan.  Setelah berlangganan, sumber daya HTTP yang ditentukan mulai menerima pesan dari partisi Kafka yang ditetapkan.  Secara arsitektur, setiap pelanggan dikaitkan dengan klien Kafka Java asli. <br><br><div class="spoiler">  <b class="spoiler_title">cerita menghibur tentang KafkaConsumer</b> <div class="spoiler_text">  Kafka memiliki klien Java yang luar biasa yang dapat melakukan banyak hal.  Saya menggunakannya dalam adaptor antrian untuk menerima pesan dari broker dan kemudian mengirimkannya ke antrian layanan lokal.  Perlu disebutkan bahwa klien bekerja secara eksklusif dalam konteks utas tunggal. <br><br>  Gagasan adaptornya sederhana.  Kami mulai dalam satu utas, kami menulis penjadwal paling sederhana dari klien asli, dengan fokus pada pengurangan latensi.  Yaitu, kami menulis sesuatu yang serupa: <br><br><pre><code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hasWork = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (consumer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> kafkaConsumers) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> queueGroup = consumers[consumer] ?: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> invalidateSubscription(consumer, queueGroup) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> records = consumer.poll(Duration.ZERO) <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!records.isEmpty) { hasWork = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> committed = doCommit() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasWork &amp;&amp; committed == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// ,    Thread.sleep(1) } }</span></span></code> </pre> <br>  Tampaknya semuanya indah, latensi minimal bahkan dengan puluhan konsumen.  Dalam praktiknya, ternyata <code>KafkaConsumer</code> untuk mode operasi ini dan memberikan tingkat alokasi sekitar 1,5 MB / s dalam waktu idle.  Dengan 100 kurir, tingkat alokasi mencapai 150 MB / s dan membuat GC sering memikirkan aplikasi.  Tentu saja, semua sampah ini ada di area muda, GC cukup mampu menangani ini, tetapi tetap saja, solusinya tidak sempurna. <br><br>  Jelas, Anda harus pergi cara khas untuk <code>KafkaConsumer</code> dan sekarang saya menempatkan setiap pelanggan di aliran saya.  Ini memberikan overhead untuk memori dan penjadwalan, tetapi tidak ada cara lain. <br><br>  Saya menulis ulang kode dari atas, menghapus lingkaran dalam dan mengubah <code>Duration.ZERO</code> ke <code>Duration.ofMillis(100)</code> .  Ternyata dengan baik, tingkat alokasi turun menjadi 80-150 KB / s yang dapat diterima per konsumen.  Namun, Polling dengan batas waktu 100ms menunda seluruh antrian komit ke 100ms yang sama, dan ini tidak dapat diterima banyak. <br><br>  Dalam proses mencari solusi untuk masalah ini, saya ingat <code>KafkaConsumer::wakeup</code> , yang melempar <code>WakeupException</code> dan mengganggu operasi pemblokiran apa pun pada konsumen.  Dengan metode ini, jalur menuju latensi rendah mudah: ketika permintaan baru untuk komit tiba, kami memasukkannya ke dalam antrian, dan pada konsumen asli yang kami sebut <code>wakeup</code> .  Dalam siklus kerja, tangkap <code>WakeupException</code> dan lakukan apa yang telah terakumulasi.  Untuk transfer kontrol dengan bantuan pengecualian, Anda harus segera memberikannya di tangan Anda, tetapi karena tidak ada yang lain ... <br><br>  Ternyata opsi ini jauh dari sempurna, karena setiap operasi pada konsumen asli sekarang melempar <code>WakeupException</code> , termasuk komit itu sendiri.  Memproses situasi ini akan mengacaukan kode dengan bendera yang memungkinkan <code>wakeup</code> dilakukan. <br><br>  Saya sampai pada kesimpulan bahwa akan lebih baik untuk memodifikasi metode <code>KafkaConsumer::poll</code> sehingga dapat diinterupsi secara normal, sesuai dengan flag tambahan.  Akibatnya, <a href="https://github.com/viirtus/queue-over-">Frankenstein</a> lahir dari refleksi, yang persis menyalin metode polling asli, menambahkan jalan keluar dari lingkaran oleh bendera.  Bendera ini diatur oleh metode interruptPoll terpisah, yang, selain itu, memanggil wakeup pada pemilih klien untuk melepaskan kunci utas pada operasi I / O. <br><br>  Setelah menerapkan klien dengan cara ini, saya mendapatkan kecepatan reaksi dari saat permintaan untuk komit tiba hingga pemrosesan hingga 100 mikrodetik, dan latensi yang sangat baik untuk mengambil pesan dari broker, yang cukup baik. <br></div></div><br>  Setiap partisi diwakili oleh antrian lokal yang terpisah, di mana adaptor menulis pesan dari broker.  Pekerja mengambil pesan darinya dan mengirimkannya untuk dieksekusi, yaitu untuk dikirim melalui HTTP. <br><br>  Layanan ini mendukung pemrosesan pesan batch untuk meningkatkan throughput.  Saat berlangganan, Anda dapat menentukan <code>concurrencyFactor</code> setiap topik (berlaku untuk setiap partisi yang ditugaskan secara independen).  Misalnya, <code>concurrencyFactor=1000</code> berarti bahwa 1000 pesan dalam bentuk permintaan HTTP dapat dikirim ke konsumen secara bersamaan.  Segera setelah semua pesan dari paket tersebut dikerjakan dengan jelas oleh konsumen, layanan memutuskan komit berikutnya dari offset pesan terakhir di Kafka.  Oleh karena itu nilai kedua <code>concurrencyFactor</code> adalah jumlah maksimum pesan yang diproses oleh konsumen jika terjadi kecelakaan Kafka atau Queue-Over-Http. <br><br>  Untuk mengurangi penundaan, antrian <code>loadFactor = concurrencyFactor * 2</code> , yang memungkinkan Anda membaca pesan dua kali lebih banyak dari broker yang dapat dikirim.  Karena autocommit dinonaktifkan pada klien asli, skema seperti itu tidak melanggar jaminan At-Least-Once. <br>  Nilai <code>concurrencyFactor</code> tinggi meningkatkan throughput antrian dengan mengurangi jumlah komit yang memakan waktu hingga 10 ms dalam kasus terburuk.  Pada saat yang sama, beban pada konsumen meningkat. <br><br>  Urutan pengiriman pesan dalam bundel tidak dijamin, tetapi dapat dicapai dengan mengatur <code>concurrencyFactor=1</code> . <br><br><a name="commits"></a><h1>  Berkomitmen </h1><br>  Komit adalah bagian penting dari layanan.  Ketika paket data berikutnya siap, offset dari pesan terakhir dari paket tersebut langsung dikomit ke Kafka, dan hanya setelah komit yang berhasil barulah paket berikutnya tersedia untuk diproses.  Seringkali ini tidak cukup dan komitmen otomatis diperlukan.  Untuk melakukan ini, ada parameter <code>autoCommitPeriodMs</code> , yang tidak ada hubungannya dengan periode autocommit klasik untuk klien asli yang melakukan pesan terakhir yang dibaca dari partisi.  Bayangkan <code>concurrencyFactor=10</code> .  Layanan telah mengirim semua 10 pesan dan menunggu masing-masing untuk siap.  Pemrosesan pesan 3 selesai terlebih dahulu, lalu pesan 1, dan kemudian pesan 10. Pada titik ini, saatnya untuk komit otomatis.  Adalah penting untuk tidak melanggar semantik At-Least-Once.  Oleh karena itu, Anda hanya dapat melakukan pesan pertama, yaitu, offset 2, karena hanya berhasil diproses pada saat itu.  Lebih lanjut, hingga autocommit berikutnya, pesan 2, 5, 6, 4, dan 8. diproses. Sekarang Anda hanya perlu komit untuk mengimbangi 7, dan seterusnya.  Autocommit hampir tidak berpengaruh pada throughput. <br><br><a name="errors"></a><h1>  Menangani kesalahan </h1><br>  Dalam mode operasi normal, layanan mengirim pesan ke penyelia sekali.  Jika karena alasan tertentu menyebabkan kesalahan 4xx atau 5xx, layanan akan mengirim ulang pesan, menunggu pemrosesan berhasil.  Waktu antara upaya dapat dikonfigurasi sebagai parameter terpisah. <br><br>  Dimungkinkan juga untuk mengatur jumlah upaya setelah mana pesan akan ditandai sebagai diproses, yang akan menghentikan pengiriman ulang terlepas dari status respons.  Saya tidak menyarankan menggunakan ini untuk data sensitif, situasi kegagalan konsumen harus selalu disesuaikan secara manual.  Pesan tempel dapat dipantau oleh log layanan dan pemantauan status respons konsumen. <br><br><div class="spoiler">  <b class="spoiler_title">tentang menempel</b> <div class="spoiler_text">  Biasanya, server HTTP, memberikan status respons 4xx atau 5xx, juga mengirim <code>Connection: close</code> header.  Koneksi TCP yang ditutup dengan cara ini tetap dalam status <code>TIME_WAITED</code> sampai dihapus oleh sistem operasi setelah beberapa waktu.  Masalahnya adalah bahwa koneksi tersebut menempati seluruh port yang tidak dapat digunakan kembali sampai dirilis.  Ini dapat menyebabkan tidak adanya port bebas pada mesin untuk membuat koneksi TCP dan layanan akan dibuang dengan pengecualian dalam log untuk setiap pengiriman.  Dalam praktiknya, pada Windows 10, port berakhir setelah 10-20 ribu mengirim pesan yang salah dalam 1-2 menit.  Dalam mode standar, ini bukan masalah. <br></div></div><br><a name="messages"></a><h1>  Pesan </h1><br>  Setiap pesan yang diambil dari broker dikirim ke penasihat melalui HTTP ke sumber yang ditentukan selama berlangganan.  Secara default, pesan dikirim oleh permintaan POST di badan.  Perilaku ini dapat diubah dengan menentukan metode lain apa pun.  Jika metode ini tidak mendukung pengiriman data dalam tubuh, Anda dapat menentukan nama parameter string di mana pesan akan dikirim.  Selain itu, saat berlangganan, Anda dapat menentukan header tambahan yang akan ditambahkan ke setiap pesan, yang sesuai untuk otorisasi dasar menggunakan token.  Header ditambahkan ke setiap pesan dengan pengidentifikasi konsumen, topik dan partisi, di mana pesan itu dibaca, nomor pesan, kunci partisi, jika berlaku, serta nama broker. <br><br><a name="performance"></a><h1>  Performa </h1><br>  Untuk mengevaluasi kinerja, saya menggunakan PC (Windows 10, OpenJDK-11 (G1 tanpa tuning), i7-6700K, 16GB), yang menjalankan layanan dan laptop (Windows 10, i5-8250U, 8GB), di mana produsen pesan, HTTP berputar. Resource Consumer dan Kafka dengan pengaturan default.  PC terhubung ke router melalui koneksi kabel 1Gb / s, laptop melalui 802.11ac.  Produser menulis setiap 110 ms setiap 100 ms untuk 110 byte pesan ke topik yang ditentukan di mana pengikut berlangganan ( <code>concurrencyFactor=500</code> , komit otomatis dimatikan) dari grup yang berbeda.  Stand jauh dari ideal, tetapi Anda bisa mendapatkan beberapa gambar. <br><br>  Parameter pengukuran utama adalah efek layanan pada latensi. <br><br>  Biarkan: <br>  - t <sub>q</sub> - cap waktu layanan menerima pesan dari klien asli <br>  - d <sub>t0</sub> adalah waktu antara t <sub>q</sub> dan waktu pesan dikirim dari antrian lokal ke kumpulan eksekutif <br>  - d <sub>t</sub> adalah waktu antara t <sub>q</sub> dan waktu permintaan HTTP dikirim.  Itu adalah pengaruh layanan terhadap latensi pesan. <br><br>  Selama pengukuran, hasil berikut diperoleh (konsumen - C, topik - T, pesan - M): <br><br><img src="https://habrastorage.org/webt/p4/r7/pq/p4r7pqavkke1d3glzc7u8o6a5gu.png"><br><br>  Dalam mode operasi standar, layanan itu sendiri hampir tidak mempengaruhi latensi, dan konsumsi memori minimal.  Nilai maksimum dt (sekitar 60ms) tidak secara khusus ditunjukkan, karena mereka bergantung pada operasi GC, dan bukan pada layanan itu sendiri.  Penyesuaian khusus GC atau mengganti G1 dengan Shenandoah dapat membantu memuluskan penyebaran nilai maksimum. <br><br>  Semuanya berubah secara dramatis ketika konsumen tidak mengatasi aliran pesan dari antrian dan layanan mengaktifkan mode pelambatan.  Dalam mode ini, konsumsi memori meningkat, karena waktu respons terhadap permintaan meningkat secara signifikan, yang mencegah pembersihan sumber daya secara tepat waktu.  Efek pada latensi di sini tetap pada tingkat dengan hasil sebelumnya, dan nilai-nilai dt tinggi disebabkan oleh pesan preloading di antrian lokal. <br><br>  Sayangnya, tidak mungkin untuk menguji pada beban yang lebih tinggi, karena laptop membungkuk sudah di 1.300 RPS.  Jika seseorang dapat membantu pengaturan pengukuran pada beban tinggi, saya dengan senang hati akan menyediakan perakitan untuk pengujian. <br><br><a name="demo"></a><h1>  Demonstrasi </h1><br>  Sekarang mari kita beralih ke demonstrasi.  Untuk ini kita perlu: <br><br><ul><li>  Kafka broker, siap berangkat.  Saya akan mengambil contoh yang diangkat pada 192.168.99.100:9092 dari Bitnami. </li><li>  Sumber daya HTTP yang akan menerima pesan.  Untuk lebih jelasnya, saya mengambil Web-hooks dari Slack. </li></ul><br>  Pertama-tama, Anda perlu meningkatkan layanan Queue-Over-Http itu sendiri.  Untuk melakukan ini, buat konten berikut di direktori <code>application.yml</code> kosong: <br><br><pre> <code class="plaintext hljs">spring: profiles: default logging: level: com: viirrtus: queueOverHttp: DEBUG app: persistence: file: storageDirectory: "persist" brokers: - name: "Kafka" origin: "kafka" config: bootstrap.servers: "192.168.99.100:9092"</code> </pre><br>  Di sini kami menunjukkan kepada layanan parameter koneksi dari broker tertentu, serta tempat menyimpan pelanggan sehingga mereka tidak hilang di antara permulaan.  Dalam `app.brokers []. Config`, Anda dapat menentukan parameter koneksi yang didukung oleh klien Kafka asli; daftar lengkap dapat ditemukan di <a href="">sini</a> . <br><br>  Karena file konfigurasi diproses oleh Spring, Anda dapat menulis banyak hal menarik di sana.  Termasuk, mengkonfigurasi logging. <br><br>  Sekarang jalankan layanan itu sendiri.  Kami menggunakan cara termudah - <code>docker-compose.yml</code> : <br><br><pre> <code class="plaintext hljs">version: "2" services: app: image: viirrtus/queue-over-http:0.1.3 restart: unless-stopped command: --debug ports: - "8080:8080" volumes: - ./application.yml:/application.yml - ./persist:/persist</code> </pre><br>  <i>Jika opsi ini tidak sesuai dengan Anda, Anda dapat mengkompilasi layanan dari sumbernya.</i>  <i>Instruksi perakitan di proyek Readme, tautan yang diberikan di akhir artikel.</i> <br><br>  Langkah selanjutnya adalah mendaftarkan pelanggan pertama.  Untuk melakukan ini, Anda perlu melakukan permintaan HTTP ke layanan dengan deskripsi Konsumen: <br><br><pre> <code class="plaintext hljs">POST localhost:8080/broker/subscription Content-Type: application/json { "id": "my-first-consumer", "group": { "id": "consumers" }, "broker": "Kafka", "topics": [ { "name": "slack.test", "config": { "concurrencyFactor": 10, "autoCommitPeriodMs": 100 } } ], "subscriptionMethod": { "type": "http", "delayOnErrorMs": 1000, "retryBeforeCommit": 10, "uri": "&lt;slack-wh-uri&gt;", "additionalHeaders": { "Content-Type": "application/json" } } }</code> </pre><br>  Jika semuanya berjalan dengan baik, responsnya akan hampir sama dengan konten yang dikirim. <br><br>  Mari kita lihat setiap parameter: <br><br><ul><li>  <code>Consumer.id</code> - ID pelanggan kami </li><li>  <code>Consumer.group.id</code> - pengidentifikasi grup </li><li>  <code>Consumer.broker</code> - menunjukkan broker layanan mana yang Anda butuhkan </li><li>  <code>Consumer.topics[0].name</code> - nama topik dari mana kami ingin menerima pesan </li><li> <code>Consumer.topics[0].config. concurrencyFactor</code>  <code>Consumer.topics[0].config. concurrencyFactor</code> - jumlah pesan maksimum yang dikirim secara bersamaan </li><li> <code>Consumer.topics[0].config. autoCommitPeriodMs</code>  <code>Consumer.topics[0].config. autoCommitPeriodMs</code> - periode komit paksa untuk pesan siap </li><li>  <code>Consumer.subscriptionMethod.type</code> - jenis langganan.  Hanya HTTP yang saat ini tersedia. </li><li>  <code>Consumer.subscriptionMethod.delayOnErrorMs</code> - waktu sebelum mengirim ulang pesan yang berakhir dengan kesalahan </li><li>  <code>Consumer.subscriptionMethod.retryBeforeCommit</code> - jumlah upaya untuk mengirim ulang pesan kesalahan.  Jika 0 - pesan akan berputar hingga pemrosesan berhasil.  Dalam kasus kami, jaminan pengiriman penuh tidak sepenting keteguhan aliran. </li><li>  <code>Consumer.subscriptionMethod.uri</code> - sumber daya tempat pesan akan dikirim </li><li>  <code>Consumer.subscriptionMethod.additionalHeader</code> - header tambahan yang akan dikirim dengan setiap pesan.  Perhatikan bahwa akan ada JSON di badan setiap pesan sehingga Slack dapat menginterpretasikan permintaan dengan benar. </li></ul><br>  <i>Dalam permintaan ini, metode HTTP dihilangkan, karena standarnya, POST, Slack cukup baik.</i> <br><br>  Mulai saat ini, layanan memonitor partisi yang ditugaskan untuk topik slack.test untuk pesan baru. <br><br>  Untuk menulis pesan ke topik, saya akan menggunakan utilitas <code>/opt/bitnami/kafka/bin</code> di Kafka yang terletak di <code>/opt/bitnami/kafka/bin</code> gambar Kafka yang diluncurkan (lokasi utilitas dalam contoh Kafka lain mungkin berbeda): <br><br><pre> <code class="plaintext hljs">kafka-console-producer.sh --broker-list localhost:9092 --topic slack.test &gt; {“text”: “Hello!”}</code> </pre><br>  Pada saat yang sama, Slack akan memberi tahu Anda tentang pesan baru: <br><br><img src="https://habrastorage.org/webt/kl/eh/z7/klehz7ev6x1y2eaqpf_ylpnjic4.png"><br><br>  <i>Untuk berhenti berlangganan konsumen, cukup membuat permintaan POST untuk `broker / berhenti berlangganan` dengan konten yang sama dengan yang selama berlangganan.</i> <br><br><a name="the-end"></a><h1>  Kesimpulan </h1><br>  Saat ini, hanya fungsi dasar yang diimplementasikan.  Lebih lanjut direncanakan untuk meningkatkan batching, mencoba untuk menerapkan semantik sekali-tepat, menambahkan kemampuan untuk mengirim pesan ke broker melalui HTTP dan, yang paling penting, menambahkan dukungan untuk Pub-Sub populer lainnya. <br><br>  Layanan Queue-Over-Http saat ini sedang dalam pengembangan aktif.  Versi 0.1.3 cukup stabil untuk pengujian pada stan dev dan stage.  Kinerja telah diuji pada Windows 10, Debian 9, dan Ubuntu 18.04.  Anda dapat menggunakan prod dengan risiko Anda sendiri.  Jika Anda ingin membantu pengembangan atau memberikan umpan balik tentang layanan - selamat datang di proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://github.com/viirtus/queue-over-">Github</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435346/">https://habr.com/ru/post/id435346/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435334/index.html">Reaksi terhadap surat dingin</a></li>
<li><a href="../id435336/index.html">Sesuatu Ditemukan: Makalah dengan Pertemuan Elasticsearch Moscow di OZON</a></li>
<li><a href="../id435338/index.html">Kami menciptakan sistem pemilihan waktu ras elektronik</a></li>
<li><a href="../id435340/index.html">Peneliti menerbitkan contoh kode cacing untuk Facebook</a></li>
<li><a href="../id435344/index.html">Amazon memperkenalkan Showroom, atau mengapa kami akan segera membeli semua perabotan online</a></li>
<li><a href="../id435348/index.html">MCerver sederhana - shell kecil untuk server Minecraft</a></li>
<li><a href="../id435352/index.html">Konferensi DEFCON 18. Spionase praktis menggunakan ponsel. Bagian 2</a></li>
<li><a href="../id435354/index.html">Konferensi DEFCON 18. Spionase praktis menggunakan ponsel. Bagian 1</a></li>
<li><a href="../id435358/index.html">Antiquities: Minidisk in the Age of iPod</a></li>
<li><a href="../id435360/index.html">Cuplikan vs Clover - kalahkan kuis waktu-nyata paling populer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>