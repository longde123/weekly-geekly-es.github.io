<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛳️ 👘 👏 Rust 1.30 Release 🤶🏿 👎🏼 👩🏻‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'équipe de développement de Rust est heureuse d'annoncer la sortie d'une nouvelle version de Rust: 1.30.0. Rust est un langage de programmation systè...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust 1.30 Release</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428073/"><p>  L'équipe de développement de Rust est heureuse d'annoncer la sortie d'une nouvelle version de Rust: 1.30.0.  Rust est un langage de programmation système destiné à la sécurité, la vitesse et l'exécution de code parallèle. </p><br><p> Si vous avez une version précédente de Rust installée à l'aide de <code>rustup</code> , alors pour mettre à niveau Rust vers la version 1.30.0, il vous suffit de faire: </p><br><pre> <code class="bash hljs">$ rustup update stable</code> </pre> <br><p>  Si vous n'avez pas encore installé <code>rustup</code> , vous pouvez l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">installer à</a> partir de la page correspondante de notre site Web.  <a href="">Des notes de version détaillées pour Rust 1.30.0</a> sont disponibles sur GitHub. </p><br><h2 id="chto-voshlo-v-stabilnuyu-versiyu-1300">  Ce qui est inclus dans la version stable 1.30.0 </h2><br><p>  Rust 1.30 est une version exceptionnelle avec un certain nombre d'innovations importantes.  Mais lundi, le blog officiel sera publié une demande de vérification de la version bêta de Rust 1.31, qui sera la première version de "Rust 2018".  Vous trouverez plus d'informations à ce sujet dans notre publication précédente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«What is Rust 2018»</a> . </p><br><h3 id="procedurnye-makrosy">  Macros procédurales </h3><br><p>  De retour dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rust 1.15,</a> nous avons ajouté la possibilité de définir des "macros de dérivation personnalisées".  Par exemple, en utilisant <code>serde_derive</code> , vous pouvez déclarer: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize, Deserialize, Debug)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span></span> { name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre> <br><p>  Et convertissez <code>Pet</code> en JSON et revenez à la structure en utilisant <code>serde_json</code> .  Ceci est possible grâce à l'inférence automatique des <code>Deserialize</code> <code>Serialize</code> et <code>Deserialize</code> aide de macros procédurales dans <code>serde_derive</code> . </p><br><p>  Rust 1.30 étend les fonctionnalités des macros procédurales en ajoutant la possibilité de définir deux autres types de macros: «macros procédurales attributaires» et «macros procédurales fonctionnelles». </p><a name="habracut"></a><br><p>  Les macros d'attributs sont similaires aux macros dérivées pour la sortie automatique, mais au lieu de générer du code uniquement pour l'attribut <code>#[derive]</code> , elles permettent aux utilisateurs de créer leurs propres nouveaux attributs.  Cela les rend plus flexibles: les macros dérivées ne fonctionnent que pour les structures et les énumérations, mais les attributs peuvent être appliqués à d'autres objets, tels que des fonctions.  Par exemple, les macros d'attributs vous permettront d'effectuer les opérations suivantes lors de l'utilisation d'un framework Web: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[route(GET, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span></span>() {</code> </pre> <br><p>  Cet attribut <code>#[route]</code> sera défini dans le cadre lui-même comme une macro procédurale.  Sa signature ressemblera à ceci: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[proc_macro_attribute]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">route</span></span></span></span>(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code> </pre> <br><p>  Ici, nous avons deux paramètres d'entrée de type <code>TokenStream</code> : le premier est pour le contenu de l'attribut lui-même, c'est-à-dire, ce sont les paramètres <code>GET, "/"</code> .  Le second est le corps de l'objet auquel l'attribut est appliqué.  Dans notre cas, il s'agit de <code>fn index() {}</code> et du reste du corps de la fonction. </p><br><p>  Les macros fonctionnelles définissent des macros dont l'utilisation ressemble à un appel de fonction.  Par exemple, la <code>sql!</code>  : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sql = sql!(SELECT * FROM posts WHERE id=<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  Cette macro en elle-même analysera les expressions SQL et vérifiera leur exactitude syntaxique.  Une macro similaire doit être déclarée comme suit: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[proc_macro]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sql</span></span></span></span>(input: TokenStream) -&gt; TokenStream {</code> </pre> <br><p>  Ceci est similaire à la signature de la macro dérivée: nous obtenons les jetons qui sont à l'intérieur des crochets et retournons le code généré par eux. </p><br><h3 id="makrosy-i-use">  Macros et <code>use</code> </h3><br><p>  Vous pouvez maintenant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">importer des macros dans la portée à l'aide du mot clé use</a> .  Par exemple, pour utiliser la macro <code>serde-json</code> package <code>serde-json</code> , l'entrée était: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> john = json!({ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"John Doe"</span></span>, <span class="hljs-string"><span class="hljs-string">"age"</span></span>: <span class="hljs-number"><span class="hljs-number">43</span></span>, <span class="hljs-string"><span class="hljs-string">"phones"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"+44 1234567"</span></span>, <span class="hljs-string"><span class="hljs-string">"+44 2345678"</span></span> ] });</code> </pre> <br><p>  Et maintenant vous devrez écrire: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> serde_json::json; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> john = json!({ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"John Doe"</span></span>, <span class="hljs-string"><span class="hljs-string">"age"</span></span>: <span class="hljs-number"><span class="hljs-number">43</span></span>, <span class="hljs-string"><span class="hljs-string">"phones"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"+44 1234567"</span></span>, <span class="hljs-string"><span class="hljs-string">"+44 2345678"</span></span> ] });</code> </pre> <br><p>  Ici, la macro est importée ainsi que d'autres éléments, il n'est donc pas nécessaire d'utiliser l'annotation <code>macro_use</code> . </p><br><p>  Enfin, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le package proc_macro est stabilisé</a> , ce qui fournit l'API nécessaire à l'écriture des macros procédurales.  Il a également considérablement amélioré l'API de gestion des erreurs et des packages tels que <code>syn</code> et <code>quote</code> utilisent déjà.  Par exemple, plus tôt: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span></span> { ok: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, bad: std::thread::Thread, }</code> </pre> <br><p>  conduit à cette erreur: </p><br><pre> <code class="hljs rust">error[E0277]: the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bound</span></span></span></span> `std::thread::Thread: _IMPL_SERIALIZE_FOR_Demo::_serde::Serialize` is not satisfied --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">3</span></span> | <span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize)]</span></span> | ^^^^^^^^^ the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> `</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_IMPL_SERIALIZE_FOR_Demo</span></span></span></span>::_serde::Serialize` is not implemented <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `std::thread::Thread`</code> </pre> <br><p>  Maintenant, il sera publié: </p><br><pre> <code class="hljs cpp">error[E0277]: the trait bound `<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::Thread: serde::Serialize` is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> satisfied --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span> | <span class="hljs-number"><span class="hljs-number">7</span></span> | bad: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::Thread, | ^^^ the trait `serde::Serialize` is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> implemented <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::Thread`</code> </pre> <br><h2 id="uluchshenie-sistemy-moduley">  Amélioration du système de modules </h2><br><p>  Le système de modules a longtemps été un point sensible pour les débutants à Rust;  certaines de ses règles n'étaient pas pratiques dans la pratique.  Ces changements sont la première étape que nous prenons pour simplifier le système de modules. </p><br><p>  En plus du changement ci-dessus pour les macros, il y a deux nouvelles améliorations à <code>use</code> .  Tout d'abord, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des packages externes sont désormais ajoutés au prélude</a> , à savoir: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//  let json = ::serde_json::from_str("..."); //  let json = serde_json::from_str("...");</span></span></code> </pre> <br><p>  Le hic, c'est que l'ancien style n'était pas toujours nécessaire en raison des caractéristiques du système de modules Rust: </p><br><pre> <code class="hljs powershell">extern crate serde_json; fn main() { //   ;     ,  `serde_json` //     let json = serde_json::from_str(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } mod foo { fn bar() { //   ;     `foo`,  `serde_json` //    let json = serde_json::from_str(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } //   -        `use` use serde_json; fn baz() { //   -   `::serde_json`,   //  ,   let json = ::serde_json::from_str(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } }</code> </pre> <br><p>  C'était ennuyeux d'obtenir du code cassé en déplaçant simplement la fonction vers un sous-module.  Maintenant, la première partie du chemin sera vérifiée, et si elle correspond à une <code>extern crate</code> , elle sera utilisée quelle que soit la position de l'appel dans la hiérarchie du module. </p><br><p>  Enfin, l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilisation a commencé à prendre en charge l'importation d'éléments dans la portée actuelle avec des chemins qui commencent sur la caisse</a> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> foo { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">// ... } } //  use ::foo::bar; //  use foo::bar; //  use crate::foo::bar;</span></span></code> </pre> <br><p>  Le mot clé <code>crate</code> au début du chemin indique que le chemin commencera à la racine du paquet.  Auparavant, les chemins indiqués dans la ligne d'importation d'importation étaient toujours spécifiés par rapport à la racine du package, mais les chemins dans le reste du code qui se réfèrent directement aux éléments étaient spécifiés par rapport au module actuel, ce qui entraînait un comportement de chemin conflictuel: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> foo { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">// ... } } mod baz { pub fn qux() { //  ::foo::bar(); //  ,    `use`: // foo::bar(); //  crate::foo::bar(); } }</span></span></code> </pre> <br><p>  Dès que le nouveau style sera largement utilisé, nous espérons que les chemins absolus seront plus clairs sans avoir à utiliser le préfixe laid <code>::</code> . </p><br><p>  L'ensemble de ces modifications simplifie la compréhension de la résolution des chemins.  Partout où vous voyez le chemin <code>a::b::c</code> , à l'exception de l'instruction <code>use</code> , vous pouvez demander: </p><br><ul><li>  Est un nom de package?  Ensuite, vous devez rechercher <code>b::c</code> intérieur. </li><li>  Est-ce <code>a</code> <code>crate</code> mots <code>a</code> clés?  Ensuite, vous devez rechercher <code>b::c</code> à la racine du package actuel. </li><li>  Sinon, vous devez rechercher <code>a::b::c</code> partir de la position actuelle dans la hiérarchie du module. </li></ul><br><p>  L'ancien comportement des chemins <code>use</code> , toujours en commençant à la racine du package, est toujours applicable.  Mais avec une transition unique vers un nouveau style, ces règles seront appliquées aux chemins partout de manière uniforme, et vous devrez vous soucier beaucoup moins des importations lors du déplacement de code. </p><br><h2 id="syrye-identifikatory">  Identifiants bruts </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vous pouvez désormais utiliser des mots clés comme identifiants</a> à l'aide de la nouvelle syntaxe suivante: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//      `for` let r#for = true; //     `for` fn r#for() { // ... } //    r#for();</span></span></code> </pre> <br><p>  Jusqu'à présent, il n'y a pas beaucoup de cas où cela vous est utile.  Mais un jour, vous essaierez d'utiliser le package pour Rust 2015 dans un projet pour Rust 2018 ou vice versa, leur ensemble de mots clés sera différent.  Nous en parlerons plus dans la prochaine annonce de Rust 2018. </p><br><h2 id="prilozheniya-bez-standartnoy-biblioteki">  Applications sans bibliothèque standard </h2><br><p>  De retour dans Rust 1.6, nous avons annoncé la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stabilisation de "no_std" et de libcore</a> pour créer des projets sans bibliothèque standard.  Cependant, avec une précision: il était possible de créer uniquement des bibliothèques, mais pas des applications. </p><br><p>  Dans Rust 1.30, vous pouvez utiliser l'attribut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>#[panic_handler]</code></a> pour implémenter indépendamment la panique.  Cela signifie que vous pouvez maintenant créer des applications, pas seulement des bibliothèques qui n'utilisent pas la bibliothèque standard. </p><br><h2 id="drugoe">  Autre </h2><br><p>  Une dernière chose: dans les macros, vous pouvez désormais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mapper des modificateurs de portée</a> , tels que <code>pub</code> , à l'aide du qualificateur <code>vis</code> .  De plus, les "attributs d'outils", tels que <code>#[rustfmt::skip]</code> , sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">désormais stabilisés</a> .  Vrai pour une utilisation avec <em>des outils d'analyse statique</em> , comme <code>#[allow(clippy::something)]</code> , ils ne sont pas encore stables. </p><br><p>  Voir <a href="">les notes de version pour plus de</a> détails. </p><br><h3 id="stabilizaciya-standartnoy-biblioteki">  Stabilisation de la bibliothèque standard </h3><br><p>  Les <a href="">API suivantes</a> ont été <a href="">stabilisées</a> dans cette version: </p><br><ul><li> <code>Ipv4Addr::{BROADCAST, LOCALHOST, UNSPECIFIED}</code> </li> <li> <code>Ipv6Addr::{BROADCAST, LOCALHOST, UNSPECIFIED}</code> </li> <li> <code>Iterator::find_map</code> </li> </ul><br><p>  De plus, la bibliothèque standard possède depuis longtemps des fonctions pour supprimer les espaces sur un côté du texte, comme <code>trim_left</code> .  Cependant, pour les langues RTL, la signification de «droite» et «gauche» ici crée de la confusion.  Par conséquent, nous introduisons de nouveaux noms pour ces fonctions: </p><br><ul><li>  <code>trim_left</code> -&gt; <code>trim_start</code> </li><li>  <code>trim_right</code> -&gt; <code>trim_end</code> </li><li>  <code>trim_left_matches</code> -&gt; <code>trim_start_matches</code> </li><li>  <code>trim_right_matches</code> -&gt; <code>trim_end_matches</code> </li></ul><br><p>  Nous prévoyons de déclarer les anciens noms obsolètes (mais pas de les supprimer, bien sûr) dans Rust 1.33. </p><br><p>  Voir <a href="">les notes de version pour plus de</a> détails. </p><br><h3 id="uluchsheniya-v-cargo">  Améliorations du fret </h3><br><p>  La plus grande amélioration de Cargo dans cette version est que nous avons maintenant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une barre de progression!</a> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/84f/4ce/626/84f4ce6263525deded821b6007735dec.gif" alt="gif de démonstration"></p><br><p>  Voir <a href="">les notes de version pour plus de</a> détails. </p><br><h2 id="razrabotchiki-1300">  Développeurs 1.30.0 </h2><br><p>  Beaucoup de gens ont créé ensemble Rust 1.30.  Nous n'aurions pas pu terminer le travail sans chacun de vous.  <a href="">Je vous remercie!</a> </p><br><p>  <em>De la part d'un traducteur: J'exprime une gratitude particulière aux membres de la communauté Rustycrate et personnellement à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">vitvakatu</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Virtuos86</a> pour leur aide dans la traduction et la relecture.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428073/">https://habr.com/ru/post/fr428073/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428061/index.html">Gérer les coûts du projet avec la gestion de la valeur acquise</a></li>
<li><a href="../fr428063/index.html">Les navigateurs refusent la prise en charge de TLS 1.0 et 1.1</a></li>
<li><a href="../fr428065/index.html">Moins ne signifie pas pire: skyrmions et murs de domaine dans les ferromagnétiques</a></li>
<li><a href="../fr428067/index.html">AntiFuzzing: la sécurité par l'obscurité!?</a></li>
<li><a href="../fr428069/index.html">Optimiser l'équilibrage de charge dans l'infrastructure Veeam Backup & Replication</a></li>
<li><a href="../fr428075/index.html">Vous ne pouvez tout de même pas le faire! - Utilisation d'interfaces et d'injection de dépendances pour une conception à long terme</a></li>
<li><a href="../fr428077/index.html">React.js: Guide du débutant</a></li>
<li><a href="../fr428079/index.html">Appliquer les principes SOLID pour réagir au développement d'applications</a></li>
<li><a href="../fr428081/index.html">Utilisation de RxJS dans React Development pour gérer l'état de l'application</a></li>
<li><a href="../fr428083/index.html">Matrice d'influence de l'analyse Web - Système stratégique d'Avinash Koshik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>