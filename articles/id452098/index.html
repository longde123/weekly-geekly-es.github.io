<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😻 👩🏽‍🤝‍👨🏾 😬 Log Habr pengembang front-end: refactor dan reflex 👨🏽‍🏫 👾 🐸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya selalu tertarik pada bagaimana Habr diatur dari dalam, bagaimana alur kerja dibangun, bagaimana komunikasi dibangun, standar apa yang diterapkan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Log Habr pengembang front-end: refactor dan reflex</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/habr/blog/452098/"><img src="https://habrastorage.org/webt/bu/8e/tl/bu8etlfvktvmkcjotmzz6al7rgg.jpeg"><br><br>  Saya selalu tertarik pada bagaimana Habr diatur dari dalam, bagaimana alur kerja dibangun, bagaimana komunikasi dibangun, standar apa yang diterapkan dan bagaimana kode ditulis di sini.  Untungnya, kesempatan seperti itu muncul pada saya, karena baru-baru ini saya menjadi bagian dari habracommand.  Menggunakan contoh refactoring kecil dari versi seluler, saya akan mencoba menjawab pertanyaan: bagaimana rasanya bekerja di sini di bagian depan.  Dalam program ini: Node, Vue, Vuex dan SSR dengan saus dari catatan tentang pengalaman pribadi di Habré. <a name="habracut"></a><br><br>  Hal pertama yang perlu Anda ketahui tentang tim pengembangan adalah kami sedikit.  Sedikit tiga front, dua backs dan teknis dari semua Habr - Bucksley.  Tentu saja, ada juga tester, perancang, tiga Vadim, sapu ajaib, seorang pemasar dan Bumburum lainnya.  Tetapi hanya ada enam kontributor langsung untuk jenis Habra.  Ini sangat jarang - sebuah proyek dengan audiensi jutaan dolar yang terlihat seperti perusahaan raksasa dari luar sebenarnya lebih mirip startup yang nyaman dengan struktur organisasi paling datar. <br><br>  Seperti banyak perusahaan IT lainnya, Habr menyatakan ide-ide Agile, praktik CI, dan itu saja.  Tetapi menurut perasaan saya, Habr sebagai sebuah produk berkembang lebih besar daripada terus menerus.  Jadi untuk beberapa sprint berturut-turut, kami bekerja keras dalam mengkodekan, mendesain, dan mendesain ulang, memecahkan sesuatu dan memperbaiki, menyelesaikan tiket dan memulai yang baru, menginjak penggaruk dan menembak diri kami di kaki untuk akhirnya merilis fitur dalam prod.  Dan kemudian muncul jeda, masa pembangunan kembali, waktu untuk melakukan apa yang ada di kuadran "penting-tidak-mendesak". <br><br>  Tentang sprint "off-season" akan dibahas di bawah ini.  Kali ini mendapat refactoring versi mobile Habr.  Secara umum, perusahaan memiliki harapan tinggi untuk itu, dan di masa depan ia harus menggantikan seluruh kebun binatang inkarnasi Habr dan menjadi solusi lintas platform universal.  Suatu hari akan muncul tata letak adaptif, dan PWA, dan mode offline, dan kustomisasi pengguna, dan banyak hal menarik. <br><br><h3>  Kami mengatur tugas </h3><br>  Suatu ketika, di stand-up biasa, salah satu front berbicara tentang masalah dalam arsitektur komponen komentar versi mobile.  Dari presentasi ini, kami mengadakan pertemuan mikro dalam format psikoterapi kelompok.  Masing-masing mengatakan di mana dia merasakan sakit, semuanya tertata di atas kertas, bersimpati, mengerti, kecuali bahwa tidak ada yang bertepuk tangan.  Hasilnya adalah daftar 20 masalah, yang membuatnya jelas bahwa Habr ponsel harus menempuh jalan panjang dan sulit menuju kesuksesan. <br><br>  Perhatian utama saya adalah efisiensi sumber daya dan apa yang disebut antarmuka yang halus.  Setiap hari di rute "rumah-kerja-rumah", saya melihat telepon lama saya berusaha menampilkan 20 judul di sungai.  Itu terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/v8/zr/nvv8zr5uneyynf4ntntk9sp3gzs.gif" alt="gambar"></div>  <sub><font color="grey"><i>Antarmuka Habr Mobile sebelum refactoring</i></font></sub> <br><br>  Apa yang sedang terjadi di sini?  Singkatnya, server memberikan halaman HTML kepada semua orang dengan cara yang sama, terlepas dari apakah pengguna masuk atau tidak.  Kemudian JS klien dimuat dan sekali lagi meminta data yang diperlukan, tetapi dengan amandemen untuk otorisasi.  Faktanya, kami melakukan pekerjaan yang sama dua kali.  Antarmukanya berkedip, dan pengguna mengunduh seratus kilobyte yang bagus.  Secara detail, semuanya tampak lebih menyeramkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0k/py/d8/0kpyd8h81q0_sgb8dd2gt7wfhvw.jpeg"></div>  <sub><font color="grey"><i>Sirkuit SSR-CSR lama.</i></font></sub>  <sub><font color="grey"><i>Otorisasi hanya dimungkinkan pada tahap C3 dan C4, ketika Node JS tidak sibuk menghasilkan HTML dan dapat mem-proxy permintaan API.</i></font></sub> <br><br>  Arsitektur kami saat itu sangat akurat dijelaskan oleh salah satu pengguna Habr: <br><blockquote>  Versi selulernya sial.  Saya berbicara apa adanya.  Kombinasi yang buruk dari RSK bersama dengan CSR. </blockquote><br>  Kami harus mengakuinya, betapapun menyedihkannya itu. <br><br>  Saya menemukan opsi, menetapkan diri saya tiket di "Jira" dengan deskripsi di tingkat "Sekarang itu buruk, buat peraturan" dan dengan pukulan lebar saya menguraikan tugas: <br><br><ul><li>  menggunakan kembali data </li><li>  meminimalkan jumlah redraws, </li><li>  kecualikan permintaan duplikat </li><li>  buat proses memuat lebih jelas. </li></ul><br><h3>  Gunakan kembali data </h3><br>  Secara teori, rendering sisi server dirancang untuk menyelesaikan dua masalah: tidak menderita keterbatasan mesin pencari terkait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengindeksan SPA</a> dan untuk meningkatkan metrik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FMP</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TTI yang semakin</a> buruk).  Dalam skenario klasik, yang akhirnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dirumuskan di Airbnb pada tahun 2013</a> (kembali di Backbone.js), SSR adalah aplikasi JS isomorfik yang sama yang berjalan di lingkungan Node.  Server hanya mengembalikan tata letak yang dihasilkan sebagai respons terhadap permintaan.  Kemudian rehidrasi terjadi di sisi klien, dan kemudian semuanya berfungsi tanpa memuat ulang laman.  Untuk Habr, dan juga untuk banyak sumber daya lain yang berisi teks, rendering server adalah elemen penting dalam membangun hubungan yang bersahabat dengan mesin pencari. <br><br>  Terlepas dari kenyataan bahwa lebih dari enam tahun telah berlalu sejak munculnya teknologi, dan selama ini, benar-benar banyak air telah mengalir di dunia frontend, bagi banyak pengembang ide ini masih tertutup oleh selubung kerahasiaan.  Kami tidak berdiri di samping, dan meluncurkan aplikasi Vue dengan dukungan SSR ke prod, kehilangan satu detail kecil: kami tidak melemparkan keadaan awal ke klien. <br><br>  Mengapa  Tidak ada jawaban pasti untuk pertanyaan ini.  Entah mereka tidak ingin meningkatkan ukuran respon dari server, atau karena banyak masalah arsitektur lainnya, atau hanya tidak lepas landas.  Dengan satu atau lain cara, melemparkan keadaan dan menggunakan kembali segala sesuatu yang dilakukan server tampaknya cukup tepat dan berguna.  Tugas ini sebenarnya sepele - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">negara hanya menyuntikkan dirinya</a> ke dalam konteks eksekusi, dan Vue secara otomatis menambahkannya ke tata letak yang dihasilkan sebagai variabel global: <code>window.__INITIAL_STATE__</code> . <br><br>  Salah satu masalah yang muncul adalah ketidakmampuan untuk mengubah struktur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lingkaran</a> menjadi JSON;  diselesaikan dengan hanya mengganti struktur tersebut dengan analog datar mereka. <br><br>  Selain itu, ketika berurusan dengan konten UGC, ingatlah bahwa data harus dikonversi ke entitas HTML agar tidak merusak HTML.  Untuk tujuan ini kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dia</a> . <br><br><h3>  Minimalkan redraws </h3><br>  Seperti yang dapat dilihat dari diagram di atas, dalam kasus kami, satu instance Node JS melakukan dua fungsi: SSR dan "proxy" di API, di mana pengguna diotorisasi.  Keadaan ini membuat otorisasi tidak mungkin pada saat eksekusi kode JS di server, karena node adalah single-threaded dan fungsi SSR sinkron.  Artinya, server tidak bisa mengirim permintaan ke dirinya sendiri sementara tumpukan panggilan sibuk dengan sesuatu.  Ternyata kami melewatkan negara, tetapi antarmuka tidak berhenti berkedut, karena data pada klien harus diperbarui dengan mempertimbangkan sesi pengguna.  Itu perlu untuk mengajar aplikasi kita untuk memasukkan data yang benar dalam keadaan awal, dengan mempertimbangkan login pengguna. <br><br>  Hanya ada dua solusi untuk masalah ini: <br><br><ul><li>  untuk melekatkan data otorisasi ke permintaan interserver; </li><li>  Membagi layer Node JS menjadi dua instance terpisah. </li></ul><br>  Solusi pertama membutuhkan penggunaan variabel global di server, dan yang kedua memperpanjang waktu yang dibutuhkan untuk menyelesaikan tugas setidaknya satu bulan. <br><br>  Bagaimana cara membuat pilihan?  Habr sering bergerak di sepanjang jalan yang paling tidak resistan.  Secara informal, ada keinginan umum tertentu untuk meminimalkan siklus dari ide ke prototipe.  Model sikap terhadap produk agak mengingatkan pada postulat booking.com, dengan satu-satunya perbedaan adalah bahwa Habr jauh lebih serius tentang umpan balik pengguna dan memercayai adopsi keputusan seperti itu kepada Anda sebagai pengembang. <br><br>  Mengikuti logika ini dan keinginan saya sendiri untuk menyelesaikan masalah dengan cepat, saya memilih variabel global.  Dan, seperti ini sering terjadi, cepat atau lambat mereka harus membayarnya.  Kami segera membayar: kami bekerja pada akhir pekan, mengambil konsekuensinya, menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">post mortem</a> dan mulai membagi server menjadi dua bagian.  Kesalahannya sangat bodoh, dan bug dengan partisipasinya tidak mudah untuk direproduksi.  Dan ya, untuk memalukan, tapi entah bagaimana, tersandung dan mendengus, PoC saya dengan variabel global masih masuk ke produksi dan cukup berhasil bekerja dalam mengantisipasi pindah ke arsitektur "dua hari" yang baru.  Ini adalah langkah penting, karena secara formal tujuan tercapai - SSR belajar untuk memberikan halaman yang benar-benar siap untuk digunakan, dan UI menjadi jauh lebih tenang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rm/rx/d-/rmrxd-fkzne7vbcj-jxxrbbwid8.gif" alt="gambar"></div>  <sub><font color="grey"><i>Antarmuka Habr Mobile setelah tahap pertama refactoring</i></font></sub> <br><br>  Pada akhirnya, arsitektur SSR-CSR versi seluler mengarah ke gambar ini: <br><br>  ￼ <div style="text-align:center;"><img src="https://habrastorage.org/webt/7t/jb/km/7tjbkmkiq4n5atanzsj3ylkwrke.jpeg" alt="gambar"></div>  <sub><font color="grey"><i>Skema SSR-CSR "dua hari".</i></font></sub>  <sub><font color="grey"><i>Node JS API selalu siap untuk asynchronous I / O dan tidak diblokir oleh fungsi SSR, karena yang terakhir adalah dalam contoh terpisah.</i></font></sub>  <sub><font color="grey"><i>Rantai kueri # 3 tidak diperlukan.</i></font></sub> <br><br><h3>  Kecualikan permintaan duplikat </h3><br>  Setelah manipulasi, rendering halaman awal berhenti memprovokasi epilepsi.  Tetapi penggunaan lebih lanjut dari Habr dalam mode SPA masih menyebabkan kebingungan. <br><br>  Karena aliran pengguna didasarkan pada transisi dari <i>daftar</i> bentuk <i>artikel → artikel → komentar</i> dan sebaliknya, penting untuk mengoptimalkan konsumsi sumber daya rantai ini di tempat pertama. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uk/eo/01/ukeo01u79_olhiv1eo9vxao4yv4.gif" alt="gambar"></div>  <sub><font color="grey"><i>Pengembalian ke umpan posting memicu permintaan data baru</i></font></sub> <br><br>  Saya tidak perlu menggali lebih dalam.  Pada screencast di atas, dapat dilihat bahwa aplikasi meminta kembali daftar artikel ketika menggesek kembali, dan selama permintaan kita tidak melihat artikel, sehingga data sebelumnya menghilang di suatu tempat.  Sepertinya komponen daftar artikel menggunakan negara bagian dan kehilangannya saat dihancurkan.  Sebenarnya, aplikasi menggunakan negara global, tetapi arsitektur Vuex dibangun di dahi: modul diikat ke halaman, yang pada gilirannya terkait dengan rute.  Selain itu, semua modul adalah "satu kali" - setiap kunjungan berikutnya ke halaman menulis ulang seluruh modul: <br><br><pre> <code class="javascript hljs">ArticlesList: [ { Article1 }, ... ], <span class="hljs-attr"><span class="hljs-attr">PageArticle</span></span>: { ArticleFull1 },</code> </pre><br>  Secara total, kami memiliki modul <i>ArticleList</i> , yang berisi objek dari tipe <i>artikel</i> dan modul <i>PageArticle</i> , yang merupakan versi diperpanjang dari objek <i>Article</i> , semacam <i>ArticleFull</i> .  Secara umum, implementasi ini tidak membawa sesuatu yang mengerikan dalam dirinya sendiri - sangat sederhana, orang bahkan dapat mengatakan secara naif, tetapi sangat jelas.  Jika Anda memotong zeroing modul dengan setiap perubahan rute, maka Anda bahkan dapat hidup dengan itu.  Namun, transisi di antara umpan artikel, misalnya <i>/ feed → / semua</i> , dijamin akan membuang segala sesuatu yang terkait dengan umpan pribadi, karena kami hanya memiliki satu <i>ArticleList</i> untuk memasukkan data baru.  Ini lagi mengarah ke permintaan duplikat. <br><br>  Menyusun segala sesuatu yang berhasil saya gali pada topik, saya merumuskan struktur negara baru dan menyajikannya kepada rekan-rekan saya.  Diskusi itu panjang, tetapi pada akhirnya, argumen "untuk" melebihi keraguan, dan saya mulai implementasi. <br><br>  Logika solusi terbaik diungkapkan dalam dua tahap.  Pertama, kami mencoba membuka ikatan modul Vuex dari halaman dan mengikat langsung ke rute.  Ya, akan ada sedikit lebih banyak data di toko, getter akan menjadi sedikit lebih rumit, tetapi kami tidak akan memuat artikel dua kali.  Untuk versi seluler, ini mungkin argumen yang paling kuat.  Akan terlihat seperti ini: <br><br><pre> <code class="javascript hljs">ArticlesList: { <span class="hljs-attr"><span class="hljs-attr">ROUTE_FEED</span></span>: [ { Article1 }, ... ], <span class="hljs-attr"><span class="hljs-attr">ROUTE_ALL</span></span>: [ { Article2 }, ... ], }</code> </pre><br>  Tetapi bagaimana jika daftar artikel dapat tumpang tindih antara beberapa rute, dan bagaimana jika kita ingin menggunakan kembali data objek <i>Artikel</i> untuk membuat halaman posting, mengubahnya menjadi <i>ArticleFull</i> ?  Dalam hal ini, akan lebih logis untuk menggunakan struktur seperti itu: <br><br><pre> <code class="javascript hljs">ArticlesIds: { <span class="hljs-attr"><span class="hljs-attr">ROUTE_FEED</span></span>: [ <span class="hljs-string"><span class="hljs-string">'1'</span></span>, ... ], <span class="hljs-attr"><span class="hljs-attr">ROUTE_ALL</span></span>: [ <span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-string"><span class="hljs-string">'2'</span></span>, ... ], }, <span class="hljs-attr"><span class="hljs-attr">ArticlesList</span></span>: { <span class="hljs-string"><span class="hljs-string">'1'</span></span>: { Article1 }, <span class="hljs-string"><span class="hljs-string">'2'</span></span>: { Article2 }, ... }</code> </pre><br>  <i>ArtikelDaftar di</i> sini hanya semacam repositori artikel.  Semua artikel yang diunggah selama sesi pengguna.  Kami memperlakukan mereka dengan hati-hati, karena ini adalah lalu lintas yang mungkin telah dimuat melalui rasa sakit di suatu tempat di kereta bawah tanah antara stasiun, dan kami pasti tidak ingin menyebabkan rasa sakit pengguna ini lagi, memaksanya untuk memuat data yang telah ia unduh.  Objek ArticleIds hanyalah array pengidentifikasi (seperti "tautan") ke objek <i>Artikel</i> .  Struktur ini memungkinkan Anda untuk tidak menduplikasi data yang umum untuk rute dan menggunakan kembali objek <i>artikel</i> saat merender halaman posting dengan menggabungkan data yang diperluas ke dalamnya. <br><br>  Output dari daftar artikel juga menjadi lebih transparan: komponen iterator iterates atas array dengan ID artikel dan menggambar komponen artikel penggoda, melewati Id sebagai alat peraga, dan komponen anak pada gilirannya mengambil data yang diperlukan dari <i>ArticleList</i> .  Ketika Anda pergi ke halaman publikasi, kami mendapatkan tanggal yang ada dari <i>ArtikelList</i> , membuat permintaan untuk data yang hilang, dan hanya menambahkannya ke objek yang ada. <br><br>  Mengapa pendekatan ini lebih baik?  Seperti yang saya tulis di atas, pendekatan ini lebih berhati-hati dalam kaitannya dengan data yang diunduh dan memungkinkan Anda untuk menggunakannya kembali.  Tapi selain itu, ini membuka jalan ke beberapa peluang baru yang sangat cocok dengan arsitektur seperti itu.  Misalnya, polling dan mengunggah artikel ke feed saat muncul.  Kami hanya dapat menambahkan posting baru ke “store” ArticleList, menyimpan daftar ID baru yang terpisah di <i>ArticleIds</i> dan memberi tahu pengguna tentang hal ini.  Ketika Anda mengklik tombol "Tampilkan publikasi baru", kami cukup memasukkan Id baru di awal array daftar artikel saat ini dan semuanya akan bekerja hampir secara ajaib. <br><br><h3>  Menjadikan unduhan lebih menyenangkan </h3><br>  Ceri pada kue refactoring adalah konsep kerangka, yang membuat proses mengunduh konten di Internet lambat sedikit kurang menjijikkan.  Tidak ada diskusi tentang hal ini, perjalanan dari ide ke prototipe memakan waktu dua jam.  Desainnya hampir dibuat sendiri, dan kami mengajarkan komponen kami cara membuat blok div yang sederhana, tidak berkedip-kedip sambil menunggu data.  Secara subyektif, pendekatan pemuatan ini benar-benar mengurangi jumlah hormon stres dalam tubuh pengguna.  Kerangka terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/yn/gn/ey/yngneyh8sftpmyyyj4ur_ihjo2c.jpeg" alt="gambar"><br>  <sub><font color="grey"><i>Habraloading</i></font></sub> <br><br><h3>  Renungkan </h3><br>  Saya telah bekerja di Habré selama enam bulan dan teman-teman masih bertanya: baik, bagaimana Anda menyukainya?  Bagus, nyaman - ya.  Tetapi ada sesuatu yang membedakan pekerjaan ini dari yang lain.  Saya bekerja di tim yang sama sekali tidak peduli dengan produk mereka, tidak tahu dan tidak mengerti siapa pengguna mereka.  Tapi di sini semuanya berbeda.  Di sini Anda merasa bertanggung jawab atas apa yang Anda lakukan.  Dalam proses mengembangkan fitur, Anda sebagian menjadi pemiliknya, ikut serta dalam semua rapat produk yang terkait dengan fungsi Anda, membuat saran, dan membuat keputusan sendiri.  Membuat produk yang Anda gunakan sendiri setiap hari sangat keren, dan menulis kode untuk orang yang mungkin lebih baik hanya perasaan yang luar biasa (tidak ada sarkasme). <br><br>  Setelah rilis semua perubahan ini, kami menerima umpan balik positif, dan itu sangat, sangat bagus.  Menginspirasi.  Terima kasih  Menulis lebih banyak <br><br>  Biarkan saya mengingatkan Anda bahwa setelah variabel global, kami memutuskan untuk mengubah arsitektur dan memisahkan lapisan proksi menjadi contoh terpisah.  Arsitektur "dua hari" telah mencapai rilis dalam bentuk pengujian beta publik.  Sekarang siapa pun dapat beralih ke sana dan membantu kami menjadikan Habr seluler lebih baik.  Itu saja untuk hari ini.  Saya akan dengan senang hati menjawab semua pertanyaan Anda di komentar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452098/">https://habr.com/ru/post/id452098/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452086/index.html">Apa yang ada di pixel saya untuk Anda: membuat nanopixels menggunakan metasurfaces plasmon</a></li>
<li><a href="../id452088/index.html">Pengenalan jalan melalui segmentasi semantik</a></li>
<li><a href="../id452090/index.html">Membuat generator puzzle prosedural</a></li>
<li><a href="../id452092/index.html">Pembaruan Dalam Aplikasi: Mempercepat Pembaruan Aplikasi Android</a></li>
<li><a href="../id452094/index.html">.NET: Alat untuk bekerja dengan multithreading dan asynchrony. Bagian 1</a></li>
<li><a href="../id452102/index.html">Permainan foto untuk mereka yang menyukai drone: secara singkat tentang AirSelfie 2</a></li>
<li><a href="../id452106/index.html">Kami mengundang pembicara ke pertemuan DIY musim panas pada 16 Juni 2019</a></li>
<li><a href="../id452108/index.html">Docker: saran tidak berbahaya</a></li>
<li><a href="../id452110/index.html">Mengotomatiskan penggantian disk dengan Ansible</a></li>
<li><a href="../id452112/index.html">CRM ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>