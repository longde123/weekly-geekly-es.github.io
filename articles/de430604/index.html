<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚫️ 🎳 🙋🏿 Technologien, die im PVS-Studio Code Analyzer verwendet werden, um nach Fehlern und potenziellen Schwachstellen zu suchen 👨‍👨‍👧‍👦 👩🏽‍🎤 🙇🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine kurze Beschreibung der im PVS-Studio-Tool verwendeten Technologien, mit denen eine große Anzahl von Fehlermustern und potenziellen Schwachstellen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Technologien, die im PVS-Studio Code Analyzer verwendet werden, um nach Fehlern und potenziellen Schwachstellen zu suchen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/430604/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a1/4fa/337/7a14fa3372efbf1ac176cf551b982a81.png" alt="Technologie und Magie"></div><br>  Eine kurze Beschreibung der im PVS-Studio-Tool verwendeten Technologien, mit denen eine große Anzahl von Fehlermustern und potenziellen Schwachstellen effektiv erkannt werden kann.  Der Artikel beschreibt die Implementierung des Analysators für C- und C ++ - Code. Die obigen Informationen gelten jedoch auch für die Module, die für die Analyse von C # - und Java-Code verantwortlich sind. <br><a name="habracut"></a><br><h2>  Einführung </h2><br>  Es gibt falsche Vorstellungen, dass statische Codeanalysatoren eher einfache Programme sind, die auf der Suche nach Codemustern unter Verwendung regulärer Ausdrücke basieren.  Das ist weit von der Wahrheit entfernt.  Darüber hinaus ist es einfach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht möglich</a> , die überwiegende Mehrheit der Fehler mithilfe regulärer Ausdrücke zu identifizieren. <br><br>  Der Fehler entstand aufgrund der Erfahrung von Programmierern bei der Arbeit mit einigen Tools, die vor 10 bis 20 Jahren existierten.  Bei der Arbeit von Tools ging es oft wirklich darum, gefährliche <i>Codemuster</i> und Funktionen wie <i>strcpy</i> , <i>strcat</i> usw. zu finden.  Als Vertreter dieser Werkzeugklasse kann man <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RATS nennen</a> . <br><br>  Solche Tools waren zwar nützlich, aber im Allgemeinen dumm und ineffektiv.  Aus dieser Zeit haben viele Programmierer immer noch Erinnerungen daran, dass statische Analysatoren sehr nutzlose Werkzeuge sind, die die Arbeit mehr stören als helfen. <br><br>  Die Zeit verging und statische Analysatoren stellten komplexe Lösungen dar, die eine eingehende Codeanalyse durchführen und Fehler finden, die auch nach einer sorgfältigen Codeüberprüfung im Code verbleiben.  Leider halten viele Programmierer die statische Analysemethode aufgrund negativer Erfahrungen in der Vergangenheit immer noch für nutzlos und haben es nicht eilig, sie in den Entwicklungsprozess einzuführen. <br><br>  In diesem Artikel werde ich versuchen, die Situation ein wenig zu beheben.  Ich bitte die Leser, sich 15 Minuten Zeit zu nehmen, um sich mit den Technologien vertraut zu machen, die im statischen Code-Analysator PVS-Studio zur Erkennung von Fehlern verwendet werden.  Vielleicht werfen Sie danach einen neuen Blick auf die Werkzeuge der statischen Analyse und möchten sie in Ihrer Arbeit anwenden. <br><br><h2>  Datenflussanalyse </h2><br>  Durch die Analyse des Datenstroms können Sie eine Vielzahl von Fehlern finden.  Darunter: Überschreiten der Grenzen eines Arrays, Speicherlecks, immer wahre / falsche Bedingungen, Dereferenzieren eines Nullzeigers und so weiter. <br><br>  Die Datenanalyse kann auch verwendet werden, um nach Situationen zu suchen, in denen nicht überprüfte Daten verwendet werden, die von außen an das Programm gesendet wurden.  Ein Angreifer kann einen solchen Satz von Eingabedaten vorbereiten, damit das Programm so funktioniert, wie es benötigt wird.  Mit anderen Worten, es kann den Fehler einer unzureichenden Eingabesteuerung als Sicherheitsanfälligkeit verwenden.  Um nach der Verwendung nicht verifizierter Daten in PVS-Studio zu suchen, wurde die spezialisierte Diagnose <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1010</a> implementiert und wird weiter verbessert. <br><br>  Die Analyse des Datenflusses (Datenflussanalyse) dient zur Berechnung der möglichen Werte von Variablen an verschiedenen Punkten in einem Computerprogramm.  Wenn der Zeiger beispielsweise dereferenziert ist und bekannt ist, dass er zu diesem Zeitpunkt Null sein kann, handelt es sich um einen Fehler, der vom statischen Analysator gemeldet wird. <br><br>  Schauen wir uns ein praktisches Beispiel für die Verwendung der Datenflussanalyse an, um nach Fehlern zu suchen.  Vor uns liegt eine Funktion aus dem Projekt Protocol Buffers (protobuf), mit der die Richtigkeit des Datums überprüft werden soll. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kDaysInMonth[<span class="hljs-number"><span class="hljs-number">13</span></span>] = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateDateTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DateTime&amp; time)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.year &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.year &gt; <span class="hljs-number"><span class="hljs-number">9999</span></span> || time.month &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.month &gt; <span class="hljs-number"><span class="hljs-number">12</span></span> || time.day &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.day &gt; <span class="hljs-number"><span class="hljs-number">31</span></span> || time.hour &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.hour &gt; <span class="hljs-number"><span class="hljs-number">23</span></span> || time.minute &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.minute &gt; <span class="hljs-number"><span class="hljs-number">59</span></span> || time.second &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.second &gt; <span class="hljs-number"><span class="hljs-number">59</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.month == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; IsLeapYear(time.year)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.month &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.month &lt;= kDaysInMonth[time.month]; } }</code> </pre> <br>  Der PVS-Studio-Analysator hat zwei logische Fehler in der Funktion gleichzeitig erkannt und zeigt die folgenden Meldungen an: <br><br><ul><li>  V547 / CWE-571 Der Ausdruck 'time.month &lt;= kDaysInMonth [time.month] + 1' ist immer wahr.  time.cc 83 </li><li>  V547 / CWE-571 Der Ausdruck 'time.month &lt;= kDaysInMonth [time.month]' ist immer wahr.  time.cc 85 </li></ul><br>  Beachten Sie den Unterausdruck „time.month &lt;1 ||  time.month&gt; 12 ".  Wenn der <i>Monatswert</i> außerhalb des Bereichs [1..12] liegt, beendet die Funktion ihre Arbeit.  Der Analysator berücksichtigt dies und weiß, dass der <i>Monatswert</i> genau im Bereich [1..12] liegt, wenn die zweite <i>if-Anweisung</i> ausgeführt wurde.  Ebenso kennt er den Bereich anderer Variablen (Jahr, Tag usw.), aber sie sind für uns jetzt nicht interessant. <br><br>  Schauen wir uns nun zwei identische Operatoren für den Zugriff auf Array-Elemente an: <i>kDaysInMonth [time.month]</i> . <br><br>  Das Array ist statisch festgelegt und der Analysator kennt die Werte aller seiner Elemente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kDaysInMonth[<span class="hljs-number"><span class="hljs-number">13</span></span>] = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span> };</code> </pre> <br>  Da die Monate von 1 nummeriert sind, berücksichtigt der Analysator am Anfang des Arrays nicht 0.  Es stellt sich heraus, dass ein Wert im Bereich [28..31] aus dem Array extrahiert werden kann. <br><br>  Je nachdem, ob das Jahr ein Schaltjahr ist oder nicht, wird 1 zur Anzahl der Tage addiert. Dies ist aber auch für uns jetzt nicht interessant.  Die Vergleiche selbst sind wichtig: <br><br><pre> <code class="cpp hljs">time.month &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; time.month &lt;= kDaysInMonth[time.month];</code> </pre> <br>  Der Bereich [1..12] (Monatszahl) wird mit der Anzahl der Tage im Monat verglichen. <br><br>  Wenn man bedenkt, dass im ersten Fall der Monat immer Februar ist ( <i>time.month == 2</i> ), werden die folgenden Bereiche verglichen: <br><br><ul><li>  2 &lt;= 29 </li><li>  [1..12] &lt;= [28..31] </li></ul><br>  Wie Sie sehen, ist das Ergebnis des Vergleichs immer wahr, wovor der PVS-Studio-Analysator warnt.  In der Tat enthält der Code zwei identische Tippfehler.  Die linke Seite des Ausdrucks sollte ein Mitglied der <i>Tagesklasse verwenden</i> , überhaupt keinen <i>Monat</i> . <br><br>  Der richtige Code sollte folgendermaßen aussehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.month == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; IsLeapYear(time.year)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.day &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.day &lt;= kDaysInMonth[time.month]; }</code> </pre> <br>  Der hier diskutierte Fehler wurde auch zuvor im Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">31. Februar</a> " beschrieben. <br><br><h2>  Symbolische Ausführung </h2><br>  Im vorherigen Abschnitt haben wir eine Methode betrachtet, bei der der Analysator die möglichen Werte von Variablen berechnet.  Um jedoch einige Fehler zu finden, müssen die Werte der Variablen nicht bekannt sein.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Symbolische Ausführung</a> bedeutet das Lösen von Gleichungen in symbolischer Form. <br><br>  Ich habe in unserer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehlerdatenbank</a> keine passende Demo gefunden. Betrachten Sie daher ein Beispiel für einen synthetischen Code. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> A, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> B)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == B) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> / (A - B); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Der PVS-Studio-Analysator generiert eine Warnung V609 / CWE-369 Teilen durch Null.  Nenner 'A - B' == 0. test.cpp 12 <br><br>  Die Werte der Variablen <i>A</i> und <i>B sind</i> dem Analysator unbekannt.  Der Analysator weiß jedoch, dass zum Zeitpunkt der Berechnung des Ausdrucks <i>10 / (A - B) die</i> Variablen <i>A</i> und <i>B</i> gleich sind.  Daher erfolgt eine Division durch 0. <br><br>  Ich sagte, dass die Werte von <i>A</i> und <i>B</i> unbekannt sind.  Für den allgemeinen Fall ist dies wahr.  Wenn der Analysator jedoch einen Funktionsaufruf mit bestimmten Werten der tatsächlichen Argumente sieht, wird dies berücksichtigt.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Div</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> / X; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i) Div(i); }</code> </pre> <br>  Der PVS-Studio-Analysator warnt vor einer Division durch Null: V609 CWE-628 Division durch Null.  Nenner 'X' == 0. Die Funktion 'Div' verarbeitet den Wert '[0..4]'.  Überprüfen Sie das erste Argument.  Überprüfen Sie die Zeilen: 106, 110. consoleapplication2017.cpp 106 <br><br>  Hier funktioniert bereits eine Mischung von Technologien: Datenflussanalyse, symbolische Ausführung und automatische Methodenanmerkung (wir werden diese Technologie im nächsten Abschnitt diskutieren).  Der Analysator sieht, dass die Variable <i>X</i> als Divisor in der <i>Div-</i> Funktion verwendet wird.  Auf dieser Grundlage wird automatisch eine spezielle Anmerkung für die <i>Div-</i> Funktion erstellt.  Es wird ferner berücksichtigt, dass ein Wertebereich [0..4] als Argument <i>X</i> an die Funktion übergeben wird.  Der Analysator kommt zu dem Schluss, dass eine Division durch 0 erfolgen sollte. <br><br><h2>  Methodenanmerkungen </h2><br>  Unser Team hat Tausende von Funktionen und Klassen kommentiert, die in folgenden Bereichen bereitgestellt werden: <br><br><ul><li>  Winapi </li><li>  C Standardbibliothek </li><li>  Standard Template Library (STL), </li><li>  glibc (GNU C Bibliothek) </li><li>  Qt </li><li>  Mfc </li><li>  zlib </li><li>  libpng </li><li>  Öffnet </li><li>  usw </li></ul><br>  Alle Funktionen werden manuell mit Anmerkungen versehen, sodass Sie viele Merkmale festlegen können, die für das Auffinden von Fehlern wichtig sind.  Beispielsweise wird angegeben, dass die Größe des an die <i>Fread-</i> Funktion übergebenen Puffers nicht geringer sein sollte als die Anzahl der Bytes, die aus der Datei gelesen werden sollen.  Die Beziehung zwischen dem 2. und 3. Argument und dem Wert, den die Funktion zurückgeben kann, wird ebenfalls angegeben.  Es sieht alles so aus: <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d4/a9c/684/4d4a9c6844fcfa694009f2ccace9d436.png" alt="PVS-Studio: Funktionsmarkierung"></div><br>  Dank dieser Anmerkung werden im folgenden Code, der die <i>Fread-</i> Funktion verwendet, sofort zwei Fehler <i>angezeigt</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE *f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = fread(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>), <span class="hljs-number"><span class="hljs-number">1000</span></span>, f); buf[i] = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... }</code> </pre> <br>  PVS-Studio-Warnungen: <ul><li>  V512 CWE-119 Ein Aufruf der Funktion 'fread' führt zum Überlaufen des Puffers 'buf'.  test.cpp 116 </li><li>  V557 CWE-787 Array-Überlauf ist möglich.  Der Wert des 'i'-Index könnte 1000 erreichen. Test.cpp 117 </li></ul><br>  Zunächst multiplizierte der Analysator das 2. und 3. tatsächliche Argument und berechnete, dass die Funktion bis zu 1000 Datenbytes lesen kann.  In diesem Fall beträgt die Puffergröße nur 100 Byte und kann überlaufen. <br><br>  Zweitens ist der Bereich möglicher Werte der Variablen <i>i</i> [0..1000], da die Funktion bis zu 1000 Bytes lesen kann.  Dementsprechend kann der Zugriff auf das Array am falschen Index erfolgen. <br><br>  Schauen wir uns ein weiteres einfaches Beispiel für einen Fehler an, dessen Erkennung durch das Markup der <i>Memset-</i> Funktion ermöglicht wurde.  Hier ist ein Codefragment des CryEngine V.-Projekts. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableFloatExceptions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... CONTEXT ctx; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;ctx, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ctx), <span class="hljs-number"><span class="hljs-number">0</span></span>); .... }</code> </pre> <br>  Der PVS-Studio-Analysator hat einen Tippfehler gefunden: V575 Die Funktion 'memset' verarbeitet '0'-Elemente.  Untersuchen Sie das dritte Argument.  crythreadutil_win32.h 294 <br><br>  Verwechselt das 2. und 3. Argument der Funktion.  Infolgedessen verarbeitet die Funktion 0 Bytes und unternimmt nichts.  Der Analysator bemerkt diese Anomalie und warnt Programmierer davor.  Wir haben diesen Fehler bereits im Artikel "Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lang erwartete Überprüfung von CryEngine V</a> " beschrieben. <br><br>  PVS-Studio Analyzer ist nicht auf die manuell festgelegten Anmerkungen beschränkt.  Darüber hinaus versucht er unabhängig, Anmerkungen zu erstellen, indem er die Funktionskörper untersucht.  Auf diese Weise können Sie Fehler bei unsachgemäßer Verwendung von Funktionen finden.  Der Analysator merkt sich beispielsweise, dass eine Funktion nullptr zurückgeben kann.  Wenn der von dieser Funktion zurückgegebene Zeiger ohne vorherige Überprüfung verwendet wird, warnt der Analysator davor.  Ein Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> GlobalInt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (rand() % <span class="hljs-number"><span class="hljs-number">2</span></span>) ? <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> : &amp;GlobalInt; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Use</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ *Get() = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Warnung: V522 CWE-690 Möglicherweise wird ein potenzieller Nullzeiger 'Get ()' dereferenziert.  test.cpp 129 <br><br>  <b>Hinweis</b>  Sie können die Suche nach dem gerade untersuchten Fehler auf die entgegengesetzte Weise durchführen.  Erinnern Sie sich an nichts und analysieren Sie jedes Mal, wenn ein Aufruf der <i>Get-</i> Funktion auftritt, diese unter Kenntnis der tatsächlichen Argumente.  Ein solcher Algorithmus ermöglicht es Ihnen theoretisch, mehr Fehler zu finden, hat jedoch eine exponentielle Komplexität.  Die Zeit für die Programmanalyse wächst hunderttausendfach, und wir betrachten diesen Ansatz aus praktischer Sicht als Sackgasse.  In PVS-Studio entwickeln wir die Richtung der automatischen Annotation von Funktionen. <br><br><h2>  Mustervergleich </h2><br>  Technologie, die mit einem Muster übereinstimmt, scheint auf den ersten Blick wie eine Suche mit regulären Ausdrücken.  In der Tat ist dies nicht so und alles ist viel komplizierter. <br><br>  Erstens sind reguläre Ausdrücke, wie ich bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sagte</a> , im Allgemeinen wertlos.  Zweitens arbeiten Analysatoren nicht mit Textzeilen, sondern mit Syntaxbäumen, die es ermöglichen, komplexere und übergeordnete Fehlermuster zu erkennen. <br><br>  Betrachten Sie zwei Beispiele, eines einfacher und eines komplexer.  Der erste Fehler, den ich beim Überprüfen des Quellcodes für Android gefunden habe. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TagMonitor::parseTagsToMonitor(String8 tagNames) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(mMonitorMutex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> end = tagNames.find(<span class="hljs-string"><span class="hljs-string">","</span></span>, idx); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* start = tagNames.lockBuffer(tagNames.size()); start[idx] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... } .... }</code> </pre> <br>  Der PVS-Studio-Analysator erkennt das klassische Fehlermuster, das mit dem Missverständnis eines Programmierers über die Priorität von Operationen in C ++ verbunden ist: V593 / CWE-783. Überprüfen Sie den Ausdruck vom Typ 'A = B! = C'.  Der Ausdruck wird wie folgt berechnet: 'A = (B! = C)'.  TagMonitor.cpp 50 <br><br>  Schauen Sie sich diese Zeile genau an: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) {</code> </pre> <br>  Der Programmierer geht davon aus, dass zu Beginn eine Zuordnung durchgeführt wird und erst dann ein Vergleich mit <i>-1</i> .  In der Tat steht der Vergleich an erster Stelle.  Klassisch  Dieser Fehler wird ausführlicher in dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> zur Android-Überprüfung beschrieben (siehe Kapitel "Andere Fehler"). <br><br>  Betrachten Sie nun eine übergeordnete Mustervergleichsoption. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha1ProcessChunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... quint8 chunkBuffer[<span class="hljs-number"><span class="hljs-number">64</span></span>]; .... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SHA1_WIPE_VARIABLES .... memset(chunkBuffer, 0, 64); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br>  PVS-Studio Warnung: V597 CWE-14 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem der 'chunkBuffer'-Puffer geleert wird.  Die Funktion RtlSecureZeroMemory () sollte verwendet werden, um die privaten Daten zu löschen.  sha1.cpp 189 <br><br>  Das Wesentliche des Problems ist, dass nach dem Füllen eines Puffers mit Nullen mithilfe der <i>Memset-</i> Funktion dieser Puffer nirgendwo verwendet wird.  Beim Kompilieren von Code mit Optimierungsflags entscheidet der Compiler, dass dieser Funktionsaufruf redundant ist, und löscht ihn.  Er hat das Recht dazu, da der Aufruf einer Funktion aus Sicht der C ++ - Sprache kein beobachtbares Verhalten im Programm hat.  Unmittelbar nach dem Ausfüllen des <i>chunkBuffer-</i> Puffers endet die Funktion <i>sha1ProcessChunk</i> .  Da der Puffer nach dem Beenden der Funktion auf dem Stapel erstellt wird, kann er nicht mehr verwendet werden.  Aus Sicht des Compilers ist es daher nicht sinnvoll, ihn mit Nullen zu füllen. <br><br>  Infolgedessen bleiben irgendwo auf dem Stapel private Daten, was zu Problemen führen kann.  Dieses Thema wird im Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sichere Bereinigung privater Daten</a> " ausführlicher behandelt. <br><br>  Dies ist ein Beispiel für eine Musterübereinstimmung auf hoher Ebene.  Zunächst sollte der Analysator über das Vorhandensein dieser Sicherheitslücke informiert sein, die gemäß der Common Weakness Enumeration als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-14: Compiler-Entfernung von Code zum Löschen von Puffern</a> klassifiziert wurde. <br><br>  Zweitens muss es im Code alle Stellen finden, an denen der Puffer auf dem Stapel erstellt wird. Er wird mit der <i>Memset-</i> Funktion <i>gelöscht</i> und nirgendwo anders verwendet. <br><br><h2>  Fazit </h2><br>  Wie Sie sehen können, ist die statische Analyse eine sehr interessante und nützliche Methode.  Sie können so früh wie möglich eine große Anzahl von Fehlern und potenziellen Schwachstellen beseitigen (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SAST</a> ).  Wenn Sie immer noch nicht vollständig von statischen Analysen durchdrungen sind, lade ich Sie ein, unseren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> zu lesen, in dem wir regelmäßig Fehler analysieren, die mit PVS-Studio in verschiedenen Projekten festgestellt wurden.  Sie können einfach nicht gleichgültig bleiben. <br><br>  Wir freuen uns, Ihr Unternehmen bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unseren Kunden zu sehen</a> und Ihre Anwendungen besser, zuverlässiger und sicherer zu machen. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel einem englischsprachigen Publikum zugänglich machen möchten, verwenden Sie bitte den Link zur Übersetzung: Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Im PVS-Studio-Code-Analysator verwendete Technologien zum Auffinden von Fehlern und potenziellen Schwachstellen</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430604/">https://habr.com/ru/post/de430604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430590/index.html">In Deutschland entwickelten sich die Anforderungen für Heimrouter</a></li>
<li><a href="../de430592/index.html">Client-Internet in einer QEMU-isolierten virtuellen Maschine mithilfe von Port-Tunneling über einen SPICE-Kanal</a></li>
<li><a href="../de430596/index.html">Wie bereite ich eine Produktstrategie vor? Produktmanager-Handbuch</a></li>
<li><a href="../de430600/index.html">Mars - von Schokolade zu Robotern</a></li>
<li><a href="../de430602/index.html">Sicherheitslücken in Etherium Smart-Verträgen. Codebeispiele</a></li>
<li><a href="../de430606/index.html">Group-IB-Webinar: „Forensische Untersuchung von RDP-Artefakten unter Windows“</a></li>
<li><a href="../de430610/index.html">So entfernen Sie Ihre elektronischen Geräte sicher</a></li>
<li><a href="../de430612/index.html">Wie in den 1980er Jahren Menschen Spiele aus dem Radio heruntergeladen haben</a></li>
<li><a href="../de430614/index.html">Schwarzer Freitag 2018 bei Madrobots.</a></li>
<li><a href="../de430616/index.html">Seminar "Testen und Überwachen", 27. November, Moskau</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>