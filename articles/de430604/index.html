<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ö´Ô∏è üé≥ üôãüèø Technologien, die im PVS-Studio Code Analyzer verwendet werden, um nach Fehlern und potenziellen Schwachstellen zu suchen üë®‚Äçüë®‚Äçüëß‚Äçüë¶ üë©üèΩ‚Äçüé§ üôáüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine kurze Beschreibung der im PVS-Studio-Tool verwendeten Technologien, mit denen eine gro√üe Anzahl von Fehlermustern und potenziellen Schwachstellen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Technologien, die im PVS-Studio Code Analyzer verwendet werden, um nach Fehlern und potenziellen Schwachstellen zu suchen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/430604/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a1/4fa/337/7a14fa3372efbf1ac176cf551b982a81.png" alt="Technologie und Magie"></div><br>  Eine kurze Beschreibung der im PVS-Studio-Tool verwendeten Technologien, mit denen eine gro√üe Anzahl von Fehlermustern und potenziellen Schwachstellen effektiv erkannt werden kann.  Der Artikel beschreibt die Implementierung des Analysators f√ºr C- und C ++ - Code. Die obigen Informationen gelten jedoch auch f√ºr die Module, die f√ºr die Analyse von C # - und Java-Code verantwortlich sind. <br><a name="habracut"></a><br><h2>  Einf√ºhrung </h2><br>  Es gibt falsche Vorstellungen, dass statische Codeanalysatoren eher einfache Programme sind, die auf der Suche nach Codemustern unter Verwendung regul√§rer Ausdr√ºcke basieren.  Das ist weit von der Wahrheit entfernt.  Dar√ºber hinaus ist es einfach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht m√∂glich</a> , die √ºberwiegende Mehrheit der Fehler mithilfe regul√§rer Ausdr√ºcke zu identifizieren. <br><br>  Der Fehler entstand aufgrund der Erfahrung von Programmierern bei der Arbeit mit einigen Tools, die vor 10 bis 20 Jahren existierten.  Bei der Arbeit von Tools ging es oft wirklich darum, gef√§hrliche <i>Codemuster</i> und Funktionen wie <i>strcpy</i> , <i>strcat</i> usw. zu finden.  Als Vertreter dieser Werkzeugklasse kann man <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RATS nennen</a> . <br><br>  Solche Tools waren zwar n√ºtzlich, aber im Allgemeinen dumm und ineffektiv.  Aus dieser Zeit haben viele Programmierer immer noch Erinnerungen daran, dass statische Analysatoren sehr nutzlose Werkzeuge sind, die die Arbeit mehr st√∂ren als helfen. <br><br>  Die Zeit verging und statische Analysatoren stellten komplexe L√∂sungen dar, die eine eingehende Codeanalyse durchf√ºhren und Fehler finden, die auch nach einer sorgf√§ltigen Code√ºberpr√ºfung im Code verbleiben.  Leider halten viele Programmierer die statische Analysemethode aufgrund negativer Erfahrungen in der Vergangenheit immer noch f√ºr nutzlos und haben es nicht eilig, sie in den Entwicklungsprozess einzuf√ºhren. <br><br>  In diesem Artikel werde ich versuchen, die Situation ein wenig zu beheben.  Ich bitte die Leser, sich 15 Minuten Zeit zu nehmen, um sich mit den Technologien vertraut zu machen, die im statischen Code-Analysator PVS-Studio zur Erkennung von Fehlern verwendet werden.  Vielleicht werfen Sie danach einen neuen Blick auf die Werkzeuge der statischen Analyse und m√∂chten sie in Ihrer Arbeit anwenden. <br><br><h2>  Datenflussanalyse </h2><br>  Durch die Analyse des Datenstroms k√∂nnen Sie eine Vielzahl von Fehlern finden.  Darunter: √úberschreiten der Grenzen eines Arrays, Speicherlecks, immer wahre / falsche Bedingungen, Dereferenzieren eines Nullzeigers und so weiter. <br><br>  Die Datenanalyse kann auch verwendet werden, um nach Situationen zu suchen, in denen nicht √ºberpr√ºfte Daten verwendet werden, die von au√üen an das Programm gesendet wurden.  Ein Angreifer kann einen solchen Satz von Eingabedaten vorbereiten, damit das Programm so funktioniert, wie es ben√∂tigt wird.  Mit anderen Worten, es kann den Fehler einer unzureichenden Eingabesteuerung als Sicherheitsanf√§lligkeit verwenden.  Um nach der Verwendung nicht verifizierter Daten in PVS-Studio zu suchen, wurde die spezialisierte Diagnose <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1010</a> implementiert und wird weiter verbessert. <br><br>  Die Analyse des Datenflusses (Datenflussanalyse) dient zur Berechnung der m√∂glichen Werte von Variablen an verschiedenen Punkten in einem Computerprogramm.  Wenn der Zeiger beispielsweise dereferenziert ist und bekannt ist, dass er zu diesem Zeitpunkt Null sein kann, handelt es sich um einen Fehler, der vom statischen Analysator gemeldet wird. <br><br>  Schauen wir uns ein praktisches Beispiel f√ºr die Verwendung der Datenflussanalyse an, um nach Fehlern zu suchen.  Vor uns liegt eine Funktion aus dem Projekt Protocol Buffers (protobuf), mit der die Richtigkeit des Datums √ºberpr√ºft werden soll. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kDaysInMonth[<span class="hljs-number"><span class="hljs-number">13</span></span>] = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateDateTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DateTime&amp; time)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.year &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.year &gt; <span class="hljs-number"><span class="hljs-number">9999</span></span> || time.month &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.month &gt; <span class="hljs-number"><span class="hljs-number">12</span></span> || time.day &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.day &gt; <span class="hljs-number"><span class="hljs-number">31</span></span> || time.hour &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.hour &gt; <span class="hljs-number"><span class="hljs-number">23</span></span> || time.minute &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.minute &gt; <span class="hljs-number"><span class="hljs-number">59</span></span> || time.second &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.second &gt; <span class="hljs-number"><span class="hljs-number">59</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.month == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; IsLeapYear(time.year)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.month &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.month &lt;= kDaysInMonth[time.month]; } }</code> </pre> <br>  Der PVS-Studio-Analysator hat zwei logische Fehler in der Funktion gleichzeitig erkannt und zeigt die folgenden Meldungen an: <br><br><ul><li>  V547 / CWE-571 Der Ausdruck 'time.month &lt;= kDaysInMonth [time.month] + 1' ist immer wahr.  time.cc 83 </li><li>  V547 / CWE-571 Der Ausdruck 'time.month &lt;= kDaysInMonth [time.month]' ist immer wahr.  time.cc 85 </li></ul><br>  Beachten Sie den Unterausdruck ‚Äûtime.month &lt;1 ||  time.month&gt; 12 ".  Wenn der <i>Monatswert</i> au√üerhalb des Bereichs [1..12] liegt, beendet die Funktion ihre Arbeit.  Der Analysator ber√ºcksichtigt dies und wei√ü, dass der <i>Monatswert</i> genau im Bereich [1..12] liegt, wenn die zweite <i>if-Anweisung</i> ausgef√ºhrt wurde.  Ebenso kennt er den Bereich anderer Variablen (Jahr, Tag usw.), aber sie sind f√ºr uns jetzt nicht interessant. <br><br>  Schauen wir uns nun zwei identische Operatoren f√ºr den Zugriff auf Array-Elemente an: <i>kDaysInMonth [time.month]</i> . <br><br>  Das Array ist statisch festgelegt und der Analysator kennt die Werte aller seiner Elemente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kDaysInMonth[<span class="hljs-number"><span class="hljs-number">13</span></span>] = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span> };</code> </pre> <br>  Da die Monate von 1 nummeriert sind, ber√ºcksichtigt der Analysator am Anfang des Arrays nicht 0.  Es stellt sich heraus, dass ein Wert im Bereich [28..31] aus dem Array extrahiert werden kann. <br><br>  Je nachdem, ob das Jahr ein Schaltjahr ist oder nicht, wird 1 zur Anzahl der Tage addiert. Dies ist aber auch f√ºr uns jetzt nicht interessant.  Die Vergleiche selbst sind wichtig: <br><br><pre> <code class="cpp hljs">time.month &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; time.month &lt;= kDaysInMonth[time.month];</code> </pre> <br>  Der Bereich [1..12] (Monatszahl) wird mit der Anzahl der Tage im Monat verglichen. <br><br>  Wenn man bedenkt, dass im ersten Fall der Monat immer Februar ist ( <i>time.month == 2</i> ), werden die folgenden Bereiche verglichen: <br><br><ul><li>  2 &lt;= 29 </li><li>  [1..12] &lt;= [28..31] </li></ul><br>  Wie Sie sehen, ist das Ergebnis des Vergleichs immer wahr, wovor der PVS-Studio-Analysator warnt.  In der Tat enth√§lt der Code zwei identische Tippfehler.  Die linke Seite des Ausdrucks sollte ein Mitglied der <i>Tagesklasse verwenden</i> , √ºberhaupt keinen <i>Monat</i> . <br><br>  Der richtige Code sollte folgenderma√üen aussehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.month == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; IsLeapYear(time.year)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.day &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.day &lt;= kDaysInMonth[time.month]; }</code> </pre> <br>  Der hier diskutierte Fehler wurde auch zuvor im Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">31. Februar</a> " beschrieben. <br><br><h2>  Symbolische Ausf√ºhrung </h2><br>  Im vorherigen Abschnitt haben wir eine Methode betrachtet, bei der der Analysator die m√∂glichen Werte von Variablen berechnet.  Um jedoch einige Fehler zu finden, m√ºssen die Werte der Variablen nicht bekannt sein.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Symbolische Ausf√ºhrung</a> bedeutet das L√∂sen von Gleichungen in symbolischer Form. <br><br>  Ich habe in unserer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehlerdatenbank</a> keine passende Demo gefunden. Betrachten Sie daher ein Beispiel f√ºr einen synthetischen Code. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> A, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> B)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == B) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> / (A - B); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Der PVS-Studio-Analysator generiert eine Warnung V609 / CWE-369 Teilen durch Null.  Nenner 'A - B' == 0. test.cpp 12 <br><br>  Die Werte der Variablen <i>A</i> und <i>B sind</i> dem Analysator unbekannt.  Der Analysator wei√ü jedoch, dass zum Zeitpunkt der Berechnung des Ausdrucks <i>10 / (A - B) die</i> Variablen <i>A</i> und <i>B</i> gleich sind.  Daher erfolgt eine Division durch 0. <br><br>  Ich sagte, dass die Werte von <i>A</i> und <i>B</i> unbekannt sind.  F√ºr den allgemeinen Fall ist dies wahr.  Wenn der Analysator jedoch einen Funktionsaufruf mit bestimmten Werten der tats√§chlichen Argumente sieht, wird dies ber√ºcksichtigt.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Div</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> / X; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i) Div(i); }</code> </pre> <br>  Der PVS-Studio-Analysator warnt vor einer Division durch Null: V609 CWE-628 Division durch Null.  Nenner 'X' == 0. Die Funktion 'Div' verarbeitet den Wert '[0..4]'.  √úberpr√ºfen Sie das erste Argument.  √úberpr√ºfen Sie die Zeilen: 106, 110. consoleapplication2017.cpp 106 <br><br>  Hier funktioniert bereits eine Mischung von Technologien: Datenflussanalyse, symbolische Ausf√ºhrung und automatische Methodenanmerkung (wir werden diese Technologie im n√§chsten Abschnitt diskutieren).  Der Analysator sieht, dass die Variable <i>X</i> als Divisor in der <i>Div-</i> Funktion verwendet wird.  Auf dieser Grundlage wird automatisch eine spezielle Anmerkung f√ºr die <i>Div-</i> Funktion erstellt.  Es wird ferner ber√ºcksichtigt, dass ein Wertebereich [0..4] als Argument <i>X</i> an die Funktion √ºbergeben wird.  Der Analysator kommt zu dem Schluss, dass eine Division durch 0 erfolgen sollte. <br><br><h2>  Methodenanmerkungen </h2><br>  Unser Team hat Tausende von Funktionen und Klassen kommentiert, die in folgenden Bereichen bereitgestellt werden: <br><br><ul><li>  Winapi </li><li>  C Standardbibliothek </li><li>  Standard Template Library (STL), </li><li>  glibc (GNU C Bibliothek) </li><li>  Qt </li><li>  Mfc </li><li>  zlib </li><li>  libpng </li><li>  √ñffnet </li><li>  usw </li></ul><br>  Alle Funktionen werden manuell mit Anmerkungen versehen, sodass Sie viele Merkmale festlegen k√∂nnen, die f√ºr das Auffinden von Fehlern wichtig sind.  Beispielsweise wird angegeben, dass die Gr√∂√üe des an die <i>Fread-</i> Funktion √ºbergebenen Puffers nicht geringer sein sollte als die Anzahl der Bytes, die aus der Datei gelesen werden sollen.  Die Beziehung zwischen dem 2. und 3. Argument und dem Wert, den die Funktion zur√ºckgeben kann, wird ebenfalls angegeben.  Es sieht alles so aus: <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d4/a9c/684/4d4a9c6844fcfa694009f2ccace9d436.png" alt="PVS-Studio: Funktionsmarkierung"></div><br>  Dank dieser Anmerkung werden im folgenden Code, der die <i>Fread-</i> Funktion verwendet, sofort zwei Fehler <i>angezeigt</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE *f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = fread(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>), <span class="hljs-number"><span class="hljs-number">1000</span></span>, f); buf[i] = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... }</code> </pre> <br>  PVS-Studio-Warnungen: <ul><li>  V512 CWE-119 Ein Aufruf der Funktion 'fread' f√ºhrt zum √úberlaufen des Puffers 'buf'.  test.cpp 116 </li><li>  V557 CWE-787 Array-√úberlauf ist m√∂glich.  Der Wert des 'i'-Index k√∂nnte 1000 erreichen. Test.cpp 117 </li></ul><br>  Zun√§chst multiplizierte der Analysator das 2. und 3. tats√§chliche Argument und berechnete, dass die Funktion bis zu 1000 Datenbytes lesen kann.  In diesem Fall betr√§gt die Puffergr√∂√üe nur 100 Byte und kann √ºberlaufen. <br><br>  Zweitens ist der Bereich m√∂glicher Werte der Variablen <i>i</i> [0..1000], da die Funktion bis zu 1000 Bytes lesen kann.  Dementsprechend kann der Zugriff auf das Array am falschen Index erfolgen. <br><br>  Schauen wir uns ein weiteres einfaches Beispiel f√ºr einen Fehler an, dessen Erkennung durch das Markup der <i>Memset-</i> Funktion erm√∂glicht wurde.  Hier ist ein Codefragment des CryEngine V.-Projekts. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableFloatExceptions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... CONTEXT ctx; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;ctx, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ctx), <span class="hljs-number"><span class="hljs-number">0</span></span>); .... }</code> </pre> <br>  Der PVS-Studio-Analysator hat einen Tippfehler gefunden: V575 Die Funktion 'memset' verarbeitet '0'-Elemente.  Untersuchen Sie das dritte Argument.  crythreadutil_win32.h 294 <br><br>  Verwechselt das 2. und 3. Argument der Funktion.  Infolgedessen verarbeitet die Funktion 0 Bytes und unternimmt nichts.  Der Analysator bemerkt diese Anomalie und warnt Programmierer davor.  Wir haben diesen Fehler bereits im Artikel "Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lang erwartete √úberpr√ºfung von CryEngine V</a> " beschrieben. <br><br>  PVS-Studio Analyzer ist nicht auf die manuell festgelegten Anmerkungen beschr√§nkt.  Dar√ºber hinaus versucht er unabh√§ngig, Anmerkungen zu erstellen, indem er die Funktionsk√∂rper untersucht.  Auf diese Weise k√∂nnen Sie Fehler bei unsachgem√§√üer Verwendung von Funktionen finden.  Der Analysator merkt sich beispielsweise, dass eine Funktion nullptr zur√ºckgeben kann.  Wenn der von dieser Funktion zur√ºckgegebene Zeiger ohne vorherige √úberpr√ºfung verwendet wird, warnt der Analysator davor.  Ein Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> GlobalInt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (rand() % <span class="hljs-number"><span class="hljs-number">2</span></span>) ? <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> : &amp;GlobalInt; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Use</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ *Get() = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Warnung: V522 CWE-690 M√∂glicherweise wird ein potenzieller Nullzeiger 'Get ()' dereferenziert.  test.cpp 129 <br><br>  <b>Hinweis</b>  Sie k√∂nnen die Suche nach dem gerade untersuchten Fehler auf die entgegengesetzte Weise durchf√ºhren.  Erinnern Sie sich an nichts und analysieren Sie jedes Mal, wenn ein Aufruf der <i>Get-</i> Funktion auftritt, diese unter Kenntnis der tats√§chlichen Argumente.  Ein solcher Algorithmus erm√∂glicht es Ihnen theoretisch, mehr Fehler zu finden, hat jedoch eine exponentielle Komplexit√§t.  Die Zeit f√ºr die Programmanalyse w√§chst hunderttausendfach, und wir betrachten diesen Ansatz aus praktischer Sicht als Sackgasse.  In PVS-Studio entwickeln wir die Richtung der automatischen Annotation von Funktionen. <br><br><h2>  Mustervergleich </h2><br>  Technologie, die mit einem Muster √ºbereinstimmt, scheint auf den ersten Blick wie eine Suche mit regul√§ren Ausdr√ºcken.  In der Tat ist dies nicht so und alles ist viel komplizierter. <br><br>  Erstens sind regul√§re Ausdr√ºcke, wie ich bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sagte</a> , im Allgemeinen wertlos.  Zweitens arbeiten Analysatoren nicht mit Textzeilen, sondern mit Syntaxb√§umen, die es erm√∂glichen, komplexere und √ºbergeordnete Fehlermuster zu erkennen. <br><br>  Betrachten Sie zwei Beispiele, eines einfacher und eines komplexer.  Der erste Fehler, den ich beim √úberpr√ºfen des Quellcodes f√ºr Android gefunden habe. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TagMonitor::parseTagsToMonitor(String8 tagNames) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(mMonitorMutex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> end = tagNames.find(<span class="hljs-string"><span class="hljs-string">","</span></span>, idx); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* start = tagNames.lockBuffer(tagNames.size()); start[idx] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... } .... }</code> </pre> <br>  Der PVS-Studio-Analysator erkennt das klassische Fehlermuster, das mit dem Missverst√§ndnis eines Programmierers √ºber die Priorit√§t von Operationen in C ++ verbunden ist: V593 / CWE-783. √úberpr√ºfen Sie den Ausdruck vom Typ 'A = B! = C'.  Der Ausdruck wird wie folgt berechnet: 'A = (B! = C)'.  TagMonitor.cpp 50 <br><br>  Schauen Sie sich diese Zeile genau an: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) {</code> </pre> <br>  Der Programmierer geht davon aus, dass zu Beginn eine Zuordnung durchgef√ºhrt wird und erst dann ein Vergleich mit <i>-1</i> .  In der Tat steht der Vergleich an erster Stelle.  Klassisch  Dieser Fehler wird ausf√ºhrlicher in dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> zur Android-√úberpr√ºfung beschrieben (siehe Kapitel "Andere Fehler"). <br><br>  Betrachten Sie nun eine √ºbergeordnete Mustervergleichsoption. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha1ProcessChunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... quint8 chunkBuffer[<span class="hljs-number"><span class="hljs-number">64</span></span>]; .... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SHA1_WIPE_VARIABLES .... memset(chunkBuffer, 0, 64); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br>  PVS-Studio Warnung: V597 CWE-14 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem der 'chunkBuffer'-Puffer geleert wird.  Die Funktion RtlSecureZeroMemory () sollte verwendet werden, um die privaten Daten zu l√∂schen.  sha1.cpp 189 <br><br>  Das Wesentliche des Problems ist, dass nach dem F√ºllen eines Puffers mit Nullen mithilfe der <i>Memset-</i> Funktion dieser Puffer nirgendwo verwendet wird.  Beim Kompilieren von Code mit Optimierungsflags entscheidet der Compiler, dass dieser Funktionsaufruf redundant ist, und l√∂scht ihn.  Er hat das Recht dazu, da der Aufruf einer Funktion aus Sicht der C ++ - Sprache kein beobachtbares Verhalten im Programm hat.  Unmittelbar nach dem Ausf√ºllen des <i>chunkBuffer-</i> Puffers endet die Funktion <i>sha1ProcessChunk</i> .  Da der Puffer nach dem Beenden der Funktion auf dem Stapel erstellt wird, kann er nicht mehr verwendet werden.  Aus Sicht des Compilers ist es daher nicht sinnvoll, ihn mit Nullen zu f√ºllen. <br><br>  Infolgedessen bleiben irgendwo auf dem Stapel private Daten, was zu Problemen f√ºhren kann.  Dieses Thema wird im Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sichere Bereinigung privater Daten</a> " ausf√ºhrlicher behandelt. <br><br>  Dies ist ein Beispiel f√ºr eine Muster√ºbereinstimmung auf hoher Ebene.  Zun√§chst sollte der Analysator √ºber das Vorhandensein dieser Sicherheitsl√ºcke informiert sein, die gem√§√ü der Common Weakness Enumeration als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-14: Compiler-Entfernung von Code zum L√∂schen von Puffern</a> klassifiziert wurde. <br><br>  Zweitens muss es im Code alle Stellen finden, an denen der Puffer auf dem Stapel erstellt wird. Er wird mit der <i>Memset-</i> Funktion <i>gel√∂scht</i> und nirgendwo anders verwendet. <br><br><h2>  Fazit </h2><br>  Wie Sie sehen k√∂nnen, ist die statische Analyse eine sehr interessante und n√ºtzliche Methode.  Sie k√∂nnen so fr√ºh wie m√∂glich eine gro√üe Anzahl von Fehlern und potenziellen Schwachstellen beseitigen (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SAST</a> ).  Wenn Sie immer noch nicht vollst√§ndig von statischen Analysen durchdrungen sind, lade ich Sie ein, unseren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> zu lesen, in dem wir regelm√§√üig Fehler analysieren, die mit PVS-Studio in verschiedenen Projekten festgestellt wurden.  Sie k√∂nnen einfach nicht gleichg√ºltig bleiben. <br><br>  Wir freuen uns, Ihr Unternehmen bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unseren Kunden zu sehen</a> und Ihre Anwendungen besser, zuverl√§ssiger und sicherer zu machen. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel einem englischsprachigen Publikum zug√§nglich machen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Im PVS-Studio-Code-Analysator verwendete Technologien zum Auffinden von Fehlern und potenziellen Schwachstellen</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430604/">https://habr.com/ru/post/de430604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430590/index.html">In Deutschland entwickelten sich die Anforderungen f√ºr Heimrouter</a></li>
<li><a href="../de430592/index.html">Client-Internet in einer QEMU-isolierten virtuellen Maschine mithilfe von Port-Tunneling √ºber einen SPICE-Kanal</a></li>
<li><a href="../de430596/index.html">Wie bereite ich eine Produktstrategie vor? Produktmanager-Handbuch</a></li>
<li><a href="../de430600/index.html">Mars - von Schokolade zu Robotern</a></li>
<li><a href="../de430602/index.html">Sicherheitsl√ºcken in Etherium Smart-Vertr√§gen. Codebeispiele</a></li>
<li><a href="../de430606/index.html">Group-IB-Webinar: ‚ÄûForensische Untersuchung von RDP-Artefakten unter Windows‚Äú</a></li>
<li><a href="../de430610/index.html">So entfernen Sie Ihre elektronischen Ger√§te sicher</a></li>
<li><a href="../de430612/index.html">Wie in den 1980er Jahren Menschen Spiele aus dem Radio heruntergeladen haben</a></li>
<li><a href="../de430614/index.html">Schwarzer Freitag 2018 bei Madrobots.</a></li>
<li><a href="../de430616/index.html">Seminar "Testen und √úberwachen", 27. November, Moskau</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>