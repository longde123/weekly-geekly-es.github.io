<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏽‍🤝‍🧑🏽 🛌🏾 🌅 API de pintura CSS 🛅 💪🏾 👆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Segundo o autor do material, cuja tradução estamos publicando hoje, a CSS Paint API é uma tecnologia incrivelmente interessante. Além disso, estamos f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>API de pintura CSS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/417075/">  Segundo o autor do material, cuja tradução estamos publicando hoje, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a CSS Paint API</a> é uma tecnologia incrivelmente interessante.  Além disso, estamos falando não apenas de suas capacidades atuais, mas também dos fenômenos apresentados a ela, e que sua aparência marca o início de mudanças muito notáveis ​​no mundo das CSS.  Aqui, falaremos sobre a API CSS Paint e os motivos de sua aparência, além de como usá-la. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/6c/1q/yu/6c1qyuo29pmcjmojwwou8qb034g.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">O que é a API do CSS Paint?</font> </h2><br>  A API em questão é apenas uma pequena parte do novo conjunto de especificações que está sendo desenvolvido como parte do projeto CSS Houdini.  Descrevendo brevemente esse projeto, sua essência se resume ao fato de oferecer aos desenvolvedores acesso de baixo nível aos mecanismos internos de CSS. <br><br>  A API CSS Paint permite chamar a função <code>paint()</code> em situações em que, em condições normais, o trabalho seria realizado, por exemplo, com um determinado valor que descreve algum tipo de imagem.  Um exemplo comum disso é a propriedade <code>background-image</code> , ao trabalhar com a qual você pode usar a função <code>url()</code> para transmitir ao sistema um link para o arquivo de imagem: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">area</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">url</span></span>(<span class="hljs-string"><span class="hljs-string">'assets/myimage.jpg'</span></span>); }</code> </pre> <br>  A CSS Paint API permite chamar, em vez de uma função semelhante, a função <code>paint()</code> e transmitir o chamado worklet, descrito por JavaScript.  Um vorklet pode ser percebido como um pedaço de código que permite que um desenvolvedor desenhe programaticamente quase tudo o que deseja.  E, como estamos falando de JavaScript, a imagem pode ser dinâmica.  Por si só, essa API é muito semelhante à API do HTML5 Canvas, e agora falaremos sobre como tudo funciona. <br><br><h2>  <font color="#3AC1EF">Recursos da API de pintura CSS</font> </h2><br>  Se agora você tem a sensação de que tudo isso soa bem, mas parece complicado, e acha que se sente bastante confortável ao usar imagens comuns, lembre-se de que as imagens comuns não perdem sua relevância com o advento da nova tecnologia.  Usá-los, como sempre, é perfeitamente normal.  O fato de algo novo ter aparecido no horizonte, e provavelmente promissor, não significa que todos precisem usar esse novo imediatamente para resolver todos os problemas existentes.  No entanto, imagens comuns são estáticas.  A nova API atrai a idéia de criar imagens dinâmicas. <br><br>  Vamos pensar sobre a função CSS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gradiente linear</a> .  A coisa é muito poderosa.  Dê uma olhada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nisso,</a> por exemplo.  Mas você pode imaginar o quão mais fácil seria obter o mesmo efeito formado por camadas sobrepostas se você não tivesse que usar muitas imagens de fundo?  No entanto, este não é o único ponto.  Se você se aprofundar na API do CSS Paint, poderá entender como essas imagens são criadas durante a execução do programa, e isso pode ser muito útil (na verdade, é isso que planejamos fazer aqui). <br><br>  E a função CSS de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gradiente cônico</a> ?  Pode-se dizer que ainda não é suportado por navegadores sem polyfill.  O uso da nova API permite criar gradientes cônicos, ajustar seus parâmetros, que não são particularmente diferentes do que está na especificação.  Tudo isso significa que, na prática, usando a nova API, você pode criar seu próprio polyfill nativo.  E isso é simplesmente maravilhoso. <br><br>  Lembre-se de que tudo isso faz parte de um grupo maior de recursos conhecido como CSS Houdini.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui está o</a> que a documentação do projeto diz sobre o assunto: "O objetivo da CSS-TAG Houdini Task Force (CSS Houdini) é desenvolver em conjunto mecanismos que quebrem o mistério da tecnologia de estilizar páginas da web e criar seus layouts". <br><br>  Parece bom, certo?  E, de fato, esses novos mecanismos visam permitir que os desenvolvedores estendam a funcionalidade do próprio CSS, oferecendo a eles melhores ferramentas de estilo, suporte a vários navegadores e a capacidade de criar polyfills. <br><br>  O processo de padronização de novas tecnologias pode levar algum tempo.  Primeiro, é feita uma sugestão para um novo recurso CSS.  Em seguida - uma especificação é escrita, outros processos ocorrem.  Como resultado, os fabricantes de navegadores estão implementando novas especificações.  E, como os desenvolvedores geralmente mal podem esperar para começar a usar novos recursos o mais rápido possível, precisam levar em consideração o fato de que navegadores mais antigos podem não suportar inovações e que, se alguma especificação ainda não estiver totalmente implementada, poderá, no decorrer de sua execução. desenvolvimento, mudar seriamente.  Talvez não haja nada a falar sobre as nuances típicas da implementação de diferentes tecnologias em diferentes navegadores.  O projeto Houdini pode ir muito longe na mitigação desses problemas, permitindo-nos desenvolver a funcionalidade do navegador por conta própria, usá-la e esperar com calma pelos fabricantes de navegadores para implementar determinados recursos.  Aqui estão alguns materiais sobre esse tópico.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O primeiro é</a> dedicado aos pontos fortes de Houdini, e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">segundo</a> é usar os recursos deste projeto para criar animações complexas. <br><br><h2>  <font color="#3AC1EF">Suporte à API CSS Paint pelos navegadores</font> </h2><br>  Posso usar a API CSS Paint hoje?  Podemos dar uma resposta positiva a essa pergunta, embora deva-se notar que longe de todos os navegadores suportam essa tecnologia.  Para obter informações de suporte para esta API, você pode usar o recurso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">caniuse.com</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55a/42a/4ea/55a42a4ea1ccc056652c9a7b463f8097.png"></div><br>  <i><font color="#999999">Suporte para a API do CSS Paint por vários navegadores (julho de 2018)</font></i> <br><br>  Como você pode ver, essa API suporta apenas o Chrome até o momento.  Seja como for, vamos falar sobre como usá-lo.  Abordaremos as construções de software necessárias para fazer a nova API funcionar.  Isso inclui novos recursos de CSS e alguns mecanismos JavaScript bastante recentes.  Nosso exemplo será dividido em três etapas. <br><br><h2>  <font color="#3AC1EF">Etapa 1: CSS</font> </h2><br>  Lembre-se de que, para criar uma imagem usando a API CSS Paint, os widgets são os fragmentos do código JS.  Portanto, para iniciantes, precisamos dar um nome ao worklet e chamá-lo em CSS.  <code>awesomePattern</code> chamá-lo <code>awesomePattern</code> .  Como resultado, o CSS ficará assim: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">section</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">url</span></span>(<span class="hljs-string"><span class="hljs-string">'fallback.png'</span></span>); <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">paint</span></span>(awesomePattern); };</code> </pre> <br>  Os preparativos preliminares foram concluídos, mas até o restante do nosso exemplo estar pronto, tudo isso não funcionará. <br><br><h2>  <font color="#3AC1EF">Etapa 2: JavaScript</font> </h2><br>  Agora precisamos descrever o worklet usando JS.  Aqui é mostrado como, no script principal, outro script é carregado que implementa a funcionalidade que precisamos. <br><br><pre> <code class="hljs cs">CSS.paintWorklet.addModule(<span class="hljs-string"><span class="hljs-string">'patternWorklet.js'</span></span>);</code> </pre> <br>  Nesse estágio, novamente, nada acontece, pois o mais interessante está oculto no arquivo <code>patternWorklet.js</code> . <br><br>  No arquivo <code>patternWorklet.js</code> precisamos registrar a classe do vorklet: <br><br><pre> <code class="hljs lisp">registerPaint('awesomePattern', Shape)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Aqui chamamos a função <code>registerPaint()</code> e passamos o que consideramos um worklet, neste caso <code>awesomePattern</code> .  Além disso, passamos a essa função um link para a classe que escreveremos, neste caso, <code>Shape</code> .  Este comando deve ser adicionado após a declaração da classe correspondente.  Ao declarar e usar classes, você não pode confiar em algo como um mecanismo para gerar declarações de função.  Antes de poder usar uma classe, você deve declará-la. <br><br>  Em seguida, usaremos a sintaxe para declarar as classes do ECMAScript 2015 e escreveremos uma classe que irá desenhar a imagem de fundo.  Como essa classe agora está registrada como uma classe da classe trabalhadora, podemos usar alguns mecanismos especiais que estarão automaticamente disponíveis nela. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> { paint(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">geom</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">properties</span></span></span><span class="hljs-class">) {   ctx.strokeStyle = 'white';   ctx.lineWidth = 4;   ctx.beginPath();   ctx.arc( 200, 200, 50, 0, 2*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Math</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PI</span></span></span><span class="hljs-class">);   ctx.stroke();   ctx.closePath(); } }</span></span></code> </pre> <br>  O retorno de chamada <code>paint()</code> possui os parâmetros <code>ctx</code> , <code>geom</code> e <code>properties</code> .  O parâmetro <code>ctx</code> é o mesmo que o contexto de renderização 2D que pode ser obtido no <code>&lt;canvas&gt;</code> .  Bem, é quase o mesmo.  O fato é que o <code>&lt;canvas&gt;</code> permite a leitura de dados de pixel, mas a CSS Paint API não permite isso.  Apesar das diferenças, usando <code>ctx</code> , podemos usar os mesmos métodos de saída gráfica usados ​​ao trabalhar com o <code>&lt;canvas&gt;</code> .  Neste exemplo, usando a função <code>arc()</code> , desenhamos um círculo. <br><br>  Os dois primeiros valores passados ​​para a função <code>arc()</code> são as coordenadas X e Y do centro do círculo, em pixels, em relação à origem localizada no canto superior esquerdo do elemento.  No entanto, quero que o círculo esteja no centro do elemento.  Para resolver esse problema, o parâmetro <code>geom</code> é útil para nós.  Dá acesso ao objeto <code>PaintSize</code> , que é uma descrição das configurações da imagem.  Em particular, referindo-se a ele, podemos ler os parâmetros de <code>width</code> e <code>height</code> , e é exatamente isso que precisamos para centralizar o círculo. <br><br>  Como resultado, chegamos a este código: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> { paint(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">geom</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">properties</span></span></span><span class="hljs-class">) {     let x = geom.width/2;   let y = geom.height/2;   ctx.strokeStyle = 'white';   ctx.lineWidth = 4;   ctx.beginPath();   ctx.arc(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">, 50, 0, 2*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Math</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PI</span></span></span><span class="hljs-class">);   ctx.stroke();   ctx.closePath();   } } registerPaint('</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">awesomePattern'</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class">);</span></span></code> </pre> <br>  Você pode ver a versão funcional do exemplo no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CodePen</a> .  Estritamente falando, é isso que esse código gera. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f2/18e/992/0f218e9927aa75625eb0ae0ae0ec8e4e.png"></div><br>  <i><font color="#999999">Círculo criado com APIs de pintura CSS</font></i> <br><br>  Tudo isso é bom, mas nosso exemplo é muito simples.  Vamos, em vez do círculo usual, desenhar algo mais interessante.  Por exemplo - como um asterisco - logotipo do site css-tricks.com. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/26e/5a7/a1f26e5a7d56b1d3d98717c890deabbf.png"></div><br>  <i><font color="#999999">Asterisco criado com APIs de pintura CSS</font></i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui está</a> um projeto CodePen que permite fazer isso. <br><br>  Ao olhar para o código JS deste projeto, preste atenção ao método <code>drawStar()</code> e às muitas funções usadas ao trabalhar com o <code>&lt;canvas&gt;</code> . <br><br><h2>  <font color="#3AC1EF">Etapa 3: Propriedades CSS personalizadas</font> </h2><br>  Usando a nova tecnologia, podemos ir muito mais além do que desenhar círculos e estrelas.  Podemos ver os recursos poderosos das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">propriedades CSS personalizadas</a> (variáveis).  Eles, a propósito, mesmo sozinhos, são muito interessantes.  No nosso caso, eles se mostram especialmente úteis. <br><br>  Suponha que desejamos poder alterar o tamanho ou a cor de um logotipo criado anteriormente.  Esses parâmetros podem ser colocados no código CSS na forma de propriedades personalizadas e, em seguida, usá-los no programa por meio do terceiro parâmetro, passado para o retorno de chamada <code>paint()</code> .  É sobre o parâmetro <code>properties</code> . <br><br>  Nós adicionamos a propriedade <code>--star-scale</code> ao nosso código CSS, que visa controlar o redimensionamento da imagem, e a propriedade <code>--star-color</code> , usada para organizar a alteração da cor do logotipo diretamente no CSS.  Aqui está o que temos: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">section</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">--star-scale</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">--star-color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">hsla</span></span>(200, 50%, 50%, 1); <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">paint</span></span>(awesomePattern) };</code> </pre> <br>  Agora, de volta à classe de pano de trabalho.  Aqui, precisamos interagir com as propriedades do usuário descritas acima.  Isso é feito usando o método <code>inputProperties</code> , que nos dá acesso a todas as propriedades CSS e seus valores atribuídos. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">get</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inputProperties</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'--star-scale'</span></span>,<span class="hljs-string"><span class="hljs-string">'--star-color'</span></span>]; }</code> </pre> <br>  Agora você pode trabalhar com eles no método <code>paint()</code> : <br><br><pre> <code class="hljs lisp">const size = parseInt(<span class="hljs-name"><span class="hljs-name">properties</span></span>.get('--shape-size').toString())<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Naturalmente, os valores obtidos podem ser utilizados no código responsável pela formação da imagem.  Isso leva ao fato de que se nós, no código CSS, <code>--star-scale</code> o valor da propriedade <code>--star-scale</code> ou <code>--start-color</code> , isso afetará imediatamente a aparência da imagem. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d2/7a0/676/7d27a06764d4888bcb66dc2a6d8d17b3.gif" alt="imagem"></div><br>  <i><font color="#999999">A influência das propriedades CSS personalizadas na imagem final</font></i> <br><br>  Essa funcionalidade é implementada no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mesmo</a> projeto CodePen que mencionamos acima. <br><br>  A propósito, vale a pena notar que, ao usar a nova API, todas as propriedades CSS comuns relacionadas à configuração do plano de fundo de elementos, como <code>background-size</code> <code>background-repeat</code> , funcionarão da mesma maneira que antes.  Eles não perderam relevância. <br><br><h2>  <font color="#3AC1EF">Sumário</font> </h2><br>  A CSS Paint API é uma tecnologia muito poderosa, cujos recursos não se limitam à criação de imagens de plano de fundo. <br><br>  Imagine que o elemento deva ter uma borda especial, por exemplo, uma que não seja totalmente visível ou dupla.  Talvez para obter esses efeitos, você geralmente use os pseudoelementos <code>::before</code> ou <code>::after</code> , ou talvez uma <code>box-shadow</code> especialmente configurada.  Bordas (e muito mais) podem ser implementadas usando a API CSS Paint e a propriedade <code>border-image</code> . <br><br>  A CSS Paint API reúne muitos recursos excelentes, como widgets, classes ECMAScript 2015 e os recursos do <code>&lt;canvas&gt;</code> .  Além disso, fornece ao desenvolvedor o software de gerenciamento de imagens baseado em JavaScript.  Por exemplo, usando o mecanismo de evento, você pode organizar a atualização de propriedades personalizadas, o que significa a própria imagem, como, por exemplo, feita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> , onde o evento <code>click</code> inicia o processo de atualização de propriedades na função <code>requestAnimationFrame</code> , que permite criar uma animação sempre que o usuário clica no botão.  Além disso, mesmo as coordenadas do cursor do mouse ao clicar são levadas em consideração. <br><br>  À primeira vista, tudo isso pode parecer um pouco confuso, mas vamos dar uma olhada em outras partes do projeto Houdini com as quais podemos nos deparar: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A API CSS Layout</a> permite que o desenvolvedor faça algo como <code>display: layout('myCustomLayout')</code> .  Um exemplo típico é a criação de seus próprios layouts de estilo de alvenaria, mas a variedade de uso desse recurso é muito maior. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A API CSS Properties and Values</a> permite definir tipos de propriedades personalizadas. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A API CSS Animation Worklet leva as</a> operações de processamento de animação além do fluxo principal, o que deve se traduzir em animações perfeitamente suaves. </li></ul><br>  Como resultado, podemos dizer que, literalmente diante de nossos olhos, há o surgimento de tecnologias que abrem muitas novas oportunidades para desenvolvedores da web.  Os processos de padronização e implementação nos navegadores não são tão rápidos, mas, possivelmente, terão um tremendo impacto em tudo relacionado ao estilo das páginas da web. <br><br>  <b>Caros leitores!</b>  Quais áreas do aplicativo CSS Paint API você acha mais interessantes? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/cp/zf/te/cpzfteyh2kzlthzniyap-5t1h6c.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt417075/">https://habr.com/ru/post/pt417075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt417063/index.html">Redes neurais para os menores</a></li>
<li><a href="../pt417065/index.html">Instruções do Splunk, ou Como e Onde Aprender o Splunk</a></li>
<li><a href="../pt417069/index.html">Mais uma vez sobre o OpenSSL</a></li>
<li><a href="../pt417071/index.html">Sexta-feira PHP: Webinars gratuitos do Skillbox</a></li>
<li><a href="../pt417073/index.html">Dia do desenvolvedor do Uber Mobile</a></li>
<li><a href="../pt417079/index.html">Gerenciador de Pacotes para Kubernetes - Helm: Passado, Presente, Futuro</a></li>
<li><a href="../pt417081/index.html">Norte, vontade, país sem fronteiras, ou Como os projetos são feitos em condições siberianas severas</a></li>
<li><a href="../pt417083/index.html">Cargas altas da Copa do Mundo de 2018</a></li>
<li><a href="../pt417085/index.html">Os navegadores silenciam o som no seu aplicativo WebRTC. Parar o que?</a></li>
<li><a href="../pt417087/index.html">HPE Digitize 2018: evento e transmissão ao vivo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>