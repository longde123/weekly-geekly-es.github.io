<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💋 🔊 👩🏽‍💻 Linux Kernel 5.0 - Schreiben von Simple Block Device unter blk-mq 👨🏿‍🏭 🕴️ 💪🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gute Nachrichten, alle zusammen! 

 Der Linux-Kernel 5.0 ist bereits vorhanden und erscheint in experimentellen Distributionen wie Arch, openSUSE Tumb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linux Kernel 5.0 - Schreiben von Simple Block Device unter blk-mq</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/446148/">  Gute Nachrichten, alle zusammen! <br><br>  Der Linux-Kernel 5.0 ist bereits vorhanden und erscheint in experimentellen Distributionen wie Arch, openSUSE Tumbleweed und Fedora. <br><br><img src="https://habrastorage.org/webt/me/zn/aq/meznaq4kak63su90hds63zvj1tq.png"><br><br>  Und wenn Sie sich die RC-Distributionen von Ubuntu Disko Dingo und Red Hat 8 ansehen, wird klar: Bald wird Kernel 5.0 auch von Fan-Desktops auf seriöse Server übertragen. <br>  Jemand wird sagen - na und.  Die nächste Veröffentlichung, nichts Besonderes.  Also sagte Linus Torvalds selbst: <blockquote>  Ich möchte (noch einmal) darauf hinweisen, dass wir keine funktionsbasierten Releases machen und dass „5.0“ nichts anderes bedeutet, als dass die 4.x-Zahlen so groß wurden, dass mir die Finger ausgegangen sind und Zehen. <br><br>  ( <i>Ich wiederhole noch einmal: Unsere Releases sind nicht an bestimmte Funktionen gebunden, daher bedeutet die Nummer der neuen Version 5.0 nur, dass ich für die Nummerierung der Versionen 4.x bereits nicht genügend Finger und Zehen habe.</i> ) <br></blockquote><br>  Das Modul für Disketten (wer weiß nicht - das sind Platten von der Größe eines Brusttaschenhemdes mit einer Kapazität von 1,44 MB) - korrigiert ... <br>  Und hier ist warum: <br><a name="habracut"></a><br>  Es dreht sich alles um die Blockschicht mit mehreren Warteschlangen (blk-mq).  Im Internet gibt es viele einführende Artikel über ihn. Kommen wir also gleich zur Sache.  Der Übergang zu blk-mq wurde vor langer Zeit begonnen und ging langsam voran.  Multi-Queue-scsi (Kernel-Parameter scsi_mod.use_blk_mq) erschien, neue Scheduler mq-Deadline, bfq und so weiter erschienen ... <br><br><pre><code class="dos hljs">[root@fedora-<span class="hljs-number"><span class="hljs-number">29</span></span> sblkdev]# cat /sys/block/sda/queue/scheduler [mq-deadline] none</code> </pre> <br>  Übrigens, was ist deins? <br><br>  Die Anzahl der Blockgerätetreiber, die auf die alte Art und Weise funktionieren, wurde reduziert.  In 5.0 wurde die Funktion blk_init_queue () als unnötig entfernt.  Und jetzt wird der alte glorreiche Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lwn.net/Articles/58720</a> aus dem Jahr 2003 nicht nur nicht, sondern auch an Relevanz verlieren.  Darüber hinaus verwenden die neuen Distributionen, die für die Veröffentlichung in diesem Jahr vorbereitet werden, in der Standardkonfiguration eine Blockschicht mit mehreren Warteschlangen.  Beispielsweise ist der Kernel auf dem 18. Manjaro, obwohl Version 4.19, standardmäßig blk-mq. <br><br>  Daher können wir davon ausgehen, dass der Übergang zu blk-mq in Kernel 5.0 abgeschlossen ist.  Und für mich ist dies ein wichtiges Ereignis, bei dem der Code neu geschrieben und zusätzliche Tests durchgeführt werden müssen.  Was an sich das Auftreten von großen und kleinen Fehlern sowie von mehreren abgestürzten Servern verspricht (Es ist notwendig, Fedya, es ist notwendig! (C)). <br><br>  Übrigens, wenn jemand denkt, dass dieser Wendepunkt für rhel8 nicht gekommen ist, da der Kernel dort durch Version 4.18 "geflasht" wurde, dann irren Sie sich.  In frischem RC auf rhel8 waren bereits neue Produkte von 5.0 migriert, und die Funktion blk_init_queue () wurde ebenfalls deaktiviert (wahrscheinlich beim Ziehen eines weiteren Check-ins von github.com/torvalds/linux zu seinen Quellen). <br>  Im Allgemeinen ist die "Freeze" -Version des Kernels für Linux-Distributoren wie SUSE und Red Hat seit langem ein Marketingkonzept.  Das System meldet, dass die Version beispielsweise 4.4 ist und die Funktionalität tatsächlich von einer frischen 4.8-Vanille stammt.  Gleichzeitig wird auf der offiziellen Website eine Inschrift angezeigt: "In der neuen Distribution haben wir einen stabilen 4.4-Kernel für Sie aufbewahrt." <br><br>  Aber wir waren abgelenkt ... <br><br>  Also.  Wir brauchen einen neuen einfachen Blockgerätetreiber, um klarer zu machen, wie das funktioniert. <br>  Also die Quelle auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/CodeImp/sblkdev</a> .  Ich schlage vor zu diskutieren, Pull-Anfragen zu stellen, Probleme zu starten - ich werde es beheben.  QA wurde noch nicht getestet. <br><br>  Später in diesem Artikel werde ich versuchen zu beschreiben, warum.  Daher gibt es viel Code. <br>  Ich entschuldige mich sofort dafür, dass der Codierungsstil des Linux-Kernels nicht vollständig respektiert wird, und ja - ich mag goto nicht. <br><br>  Beginnen wir also mit den Einstiegspunkten. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">init </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SUCCESS; _sblkdev_major = register_blkdev(_sblkdev_major, _sblkdev_name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_sblkdev_major &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>){ printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: unable to get major number\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EBUSY; } ret = sblkdev_add_device(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret) unregister_blkdev(_sblkdev_major, _sblkdev_name); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">exit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ sblkdev_remove_device(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_sblkdev_major &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) unregister_blkdev(_sblkdev_major, _sblkdev_name); } module_init(sblkdev_init); module_exit(sblkdev_exit);</code> </pre><br>  Wenn das Modul geladen wird, wird natürlich die Funktion sblkdev_init () gestartet, wenn sblkdev_exit () entladen wird. <br>  Die Funktion register_blkdev () registriert ein Blockgerät.  Ihm wird eine Hauptnummer zugewiesen.  unregister_blkdev () - gibt diese Nummer frei. <br><br>  Die Schlüsselstruktur unseres Moduls ist sblkdev_device_t. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// The internal representation of our device typedef struct sblkdev_device_s { sector_t capacity; // Device size in bytes u8* data; // The data aray. u8 - 8 bytes atomic_t open_counter; // How many openers struct blk_mq_tag_set tag_set; struct request_queue *queue; // For mutual exclusion struct gendisk *disk; // The gendisk structure } sblkdev_device_t;</span></span></code> </pre><br>  Es enthält alle Informationen über das Gerät, die für das Kernelmodul erforderlich sind, insbesondere: die Kapazität des Blockgeräts, die Daten selbst (es ist einfach), Zeiger auf die Festplatte und die Warteschlange. <br><br>  Alle Blockgeräteinitialisierungen werden in der Funktion sblkdev_add_device () durchgeführt. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_add_device</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SUCCESS; <span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>* dev = kzalloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>), GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: unable to allocate %ld bytes\n"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOMEM; } _sblkdev_device = dev; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>{ ret = sblkdev_allocate_buffer(dev); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ret) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//simply variant with helper function blk_mq_init_sq_queue. It`s available from kernel 4.20 (vanilla). {//configure tag_set struct request_queue *queue; dev-&gt;tag_set.cmd_size = sizeof(sblkdev_cmd_t); dev-&gt;tag_set.driver_data = dev; queue = blk_mq_init_sq_queue(&amp;dev-&gt;tag_set, &amp;_mq_ops, 128, BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE); if (IS_ERR(queue)) { ret = PTR_ERR(queue); printk(KERN_WARNING "sblkdev: unable to allocate and initialize tag set\n"); break; } dev-&gt;queue = queue; } #else // more flexible variant {//configure tag_set dev-&gt;tag_set.ops = &amp;_mq_ops; dev-&gt;tag_set.nr_hw_queues = 1; dev-&gt;tag_set.queue_depth = 128; dev-&gt;tag_set.numa_node = NUMA_NO_NODE; dev-&gt;tag_set.cmd_size = sizeof(sblkdev_cmd_t); dev-&gt;tag_set.flags = BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE; dev-&gt;tag_set.driver_data = dev; ret = blk_mq_alloc_tag_set(&amp;dev-&gt;tag_set); if (ret) { printk(KERN_WARNING "sblkdev: unable to allocate tag set\n"); break; } } {//configure queue struct request_queue *queue = blk_mq_init_queue(&amp;dev-&gt;tag_set); if (IS_ERR(queue)) { ret = PTR_ERR(queue); printk(KERN_WARNING "sblkdev: Failed to allocate queue\n"); break; } dev-&gt;queue = queue; } #endif dev-&gt;queue-&gt;queuedata = dev; {// configure disk struct gendisk *disk = alloc_disk(1); //only one partition if (disk == NULL) { printk(KERN_WARNING "sblkdev: Failed to allocate disk\n"); ret = -ENOMEM; break; } disk-&gt;flags |= GENHD_FL_NO_PART_SCAN; //only one partition //disk-&gt;flags |= GENHD_FL_EXT_DEVT; disk-&gt;flags |= GENHD_FL_REMOVABLE; disk-&gt;major = _sblkdev_major; disk-&gt;first_minor = 0; disk-&gt;fops = &amp;_fops; disk-&gt;private_data = dev; disk-&gt;queue = dev-&gt;queue; sprintf(disk-&gt;disk_name, "sblkdev%d", 0); set_capacity(disk, dev-&gt;capacity); dev-&gt;disk = disk; add_disk(disk); } printk(KERN_WARNING "sblkdev: simple block device was created\n"); }while(false); if (ret){ sblkdev_remove_device(); printk(KERN_WARNING "sblkdev: Failed add block device\n"); } return ret; }</span></span></span></span></code> </pre><br>  Wir weisen der Struktur Speicher zu, weisen einen Puffer zum Speichern von Daten zu.  Hier ist nichts Besonderes. <br>  Als Nächstes initialisieren wir die Anforderungsverarbeitungswarteschlange entweder mit einer blk_mq_init_sq_queue () -Funktion oder mit zwei gleichzeitig: blk_mq_alloc_tag_set () + blk_mq_init_queue (). <br><br>  Übrigens, wenn Sie sich den Quellcode der Funktion blk_mq_init_sq_queue () ansehen, werden Sie sehen, dass dies nur ein Wrapper über die Funktionen blk_mq_alloc_tag_set () und blk_mq_init_queue () ist, die im Kernel 4.20 erschienen sind.  Außerdem werden viele Parameter der Warteschlange ausgeblendet, aber es sieht viel einfacher aus.  Sie müssen wählen, welche Option besser ist, aber ich bevorzuge eine explizitere. <br><br>  Der Schlüssel in diesem Code ist die globale Variable _mq_ops. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blk_mq_ops</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mq_ops</span></span></span><span class="hljs-class"> = {</span></span> .queue_rq = queue_rq, };</code> </pre><br>  Hier befindet sich die Funktion, die die Verarbeitung von Anforderungen ermöglicht, aber etwas später mehr dazu.  Die Hauptsache ist, dass wir den Einstiegspunkt für den Request-Handler festgelegt haben. <br><br>  Nachdem wir die Warteschlange erstellt haben, können wir eine Instanz der Festplatte erstellen. <br><br>  Es gibt keine wesentlichen Änderungen.  Die Festplatte wird zugewiesen, Parameter werden festgelegt und die Festplatte wird dem System hinzugefügt.  Ich möchte den Parameter disk-&gt; flags erläutern.  Auf diese Weise können Sie dem System mitteilen, dass die Festplatte entfernbar ist oder beispielsweise keine Partitionen enthält und Sie dort nicht danach suchen müssen. <br><br>  Es gibt eine _fops-Struktur für die Datenträgerverwaltung. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">block_device_operations</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fops</span></span></span><span class="hljs-class"> = {</span></span> .owner = THIS_MODULE, .open = _open, .release = _release, .ioctl = _ioctl, #ifdef CONFIG_COMPAT .compat_ioctl = _compat_ioctl, #endif };</code> </pre><br>  Die Einstiegspunkte _open und _release für uns für ein einfaches Blockgerätemodul sind noch nicht sehr interessant.  Zusätzlich zum atomaren Inkrement- und Dekrementzähler gibt es dort nichts.  Ich habe auch compatible_ioctl ohne Implementierung gelassen, da mir die Version von Systemen mit einem 64-Bit-Kernel und einer 32-Bit-User-Space-Umgebung nicht vielversprechend erscheint. <br><br>  Mit _ioctl können Sie jedoch Systemanforderungen für dieses Laufwerk verarbeiten.  Wenn eine Festplatte angezeigt wird, versucht das System, mehr darüber zu erfahren.  Sie können einige Fragen nach Belieben beantworten (z. B. um sich als neue CD auszugeben). Die allgemeine Regel lautet jedoch: Wenn Sie keine Fragen beantworten möchten, die für Sie nicht von Interesse sind, geben Sie einfach den Fehlercode -ENOTTY zurück.  Übrigens können Sie hier bei Bedarf Ihre Request-Handler zu diesem bestimmten Laufwerk hinzufügen. <br><br>  Also haben wir das Gerät hinzugefügt - wir müssen uns um die Freigabe von Ressourcen kümmern.  Rust ist nicht <s>für</s> dich da. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_remove_device</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>* dev = _sblkdev_device; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;disk) del_gendisk(dev-&gt;disk); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>) { blk_cleanup_queue(dev-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>); dev-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span> = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;tag_set.tags) blk_mq_free_tag_set(&amp;dev-&gt;tag_set); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;disk) { put_disk(dev-&gt;disk); dev-&gt;disk = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } sblkdev_free_buffer(dev); kfree(dev); _sblkdev_device = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: simple block device was removed\n"</span></span>); } }</code> </pre><br>  Im Prinzip ist alles klar: Wir löschen das Festplattenobjekt aus dem System und geben die Warteschlange frei. Danach geben wir auch unsere Puffer (Datenbereiche) frei. <br><br>  Und jetzt ist das Wichtigste die Abfrageverarbeitung in der Funktion queue_rq (). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> blk_status_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queue_rq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct blk_mq_hw_ctx *hctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct blk_mq_queue_data* bd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">blk_status_t</span></span> status = BLK_STS_OK; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rq</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bd</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rq</span></span></span><span class="hljs-class">;</span></span> blk_mq_start_request(rq); <span class="hljs-comment"><span class="hljs-comment">//we cannot use any locks that make the thread sleep { unsigned int nr_bytes = 0; if (do_simple_request(rq, &amp;nr_bytes) != SUCCESS) status = BLK_STS_IOERR; printk(KERN_WARNING "sblkdev: request process %d bytes\n", nr_bytes); #if 0 //simply and can be called from proprietary module blk_mq_end_request(rq, status); #else //can set real processed bytes count if (blk_update_request(rq, status, nr_bytes)) //GPL-only symbol BUG(); __blk_mq_end_request(rq, status); #endif } return BLK_STS_OK;//always return ok }</span></span></code> </pre><br>  Betrachten Sie zunächst die Parameter.  Die erste ist struct blk_mq_hw_ctx * hctx - der Status der Hardware-Warteschlange.  In unserem Fall verzichten wir auf die Hardware-Warteschlange, die nicht verwendet wird. <br><br>  Der zweite Parameter ist const struct blk_mq_queue_data * bd - ein Parameter mit einer sehr prägnanten Struktur, den ich Ihnen nicht in seiner Gesamtheit vorstellen möchte: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blk_mq_queue_data</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rq</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> last; };</code> </pre><br>  Es stellt sich heraus, dass dies im Wesentlichen dieselbe Anfrage ist, die uns aus Zeiten gestellt wurde, an die sich der Chronist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">elixir.bootlin.com</a> nicht mehr erinnert.  Also nehmen wir die Anfrage und beginnen mit der Verarbeitung, über die wir den Kernel benachrichtigen, indem wir blk_mq_start_request () aufrufen.  Nach Abschluss der Anforderungsverarbeitung werden wir den Kernel darüber informieren, indem wir die Funktion blk_mq_end_request () aufrufen. <br><br>  Hier ein kleiner Hinweis: Die Funktion blk_mq_end_request () ist im Wesentlichen ein Wrapper für Aufrufe von blk_update_request () + __blk_mq_end_request ().  Bei Verwendung der Funktion blk_mq_end_request () können Sie nicht angeben, wie viele Bytes tatsächlich verarbeitet wurden.  Glaubt, dass alles verarbeitet wird. <br><br>  Die alternative Option verfügt über eine weitere Funktion: Die Funktion blk_update_request wird nur für Nur-GPL-Module exportiert.  Das heißt, wenn Sie ein proprietäres Kernelmodul erstellen möchten (lassen Sie sich von PM vor diesem heiklen Pfad retten), können Sie blk_update_request () nicht verwenden.  Sie haben also die Wahl. <br><br>  Direktes Verschieben der Bytes von der Anfrage in den Puffer und umgekehrt habe ich in die Funktion do_simple_request () eingefügt. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_simple_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct request *rq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *nr_bytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SUCCESS; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bio_vec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bvec</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">req_iterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iter</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span> *dev = rq-&gt;q-&gt;queuedata; <span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span> pos = blk_rq_pos(rq) &lt;&lt; SECTOR_SHIFT; <span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span> dev_size = (<span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span>)(dev-&gt;capacity &lt;&lt; SECTOR_SHIFT); printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: request start from sector %ld \n"</span></span>, blk_rq_pos(rq)); rq_for_each_segment(bvec, rq, iter) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> b_len = bvec.bv_len; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* b_buf = page_address(bvec.bv_page) + bvec.bv_offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((pos + b_len) &gt; dev_size) b_len = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)(dev_size - pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rq_data_dir(rq))<span class="hljs-comment"><span class="hljs-comment">//WRITE memcpy(dev-&gt;data + pos, b_buf, b_len); else//READ memcpy(b_buf, dev-&gt;data + pos, b_len); pos += b_len; *nr_bytes += b_len; } return ret; }</span></span></code> </pre><br>  Es gibt nichts Neues: rq_for_each_segment iteriert über alles Bio, und alle haben bio_vec-Strukturen, sodass wir zu den Seiten mit den Anforderungsdaten gelangen können. <br><br>  Was sind deine Eindrücke?  Alles scheint einfach?  Bei der Anforderungsverarbeitung werden im Allgemeinen einfach Daten zwischen den Seiten der Anforderung und dem internen Puffer kopiert.  Für einen einfachen Blockgerätetreiber durchaus würdig, oder? <br><br>  Aber es gibt ein Problem: <b>Dies ist nicht für den wirklichen Gebrauch!</b> <br><br>  Das Problem besteht im Wesentlichen darin, dass die Anforderungsverarbeitungsfunktion queue_rq () in einer Schleife aufgerufen wird, die Anforderungen aus der Liste verarbeitet.  Ich weiß nicht, welche Sperre für diese Liste dort verwendet wird, Spin oder RCU (ich möchte nicht lügen - wer weiß, korrigiere mich), aber wenn Sie versuchen, beispielsweise Mutex in der Anforderungsverarbeitungsfunktion zu verwenden, schwört und warnt der Debugging-Kernel: Einschlafen hier ist es unmöglich.  Das heißt, die Verwendung herkömmlicher Synchronisationstools oder eines virtuellen zusammenhängenden Speichers - einer, der mit vmalloc zugewiesen wird und mit allem, was dies impliziert, in einen Austausch geraten kann - ist unmöglich, da der Prozess nicht in den Standby-Zustand versetzt werden kann. <br><br>  Daher entweder nur Spin- oder RCU-Sperren und ein Puffer in Form eines Seitenarrays oder einer Liste oder eines Baums, wie in .. \ linux \ drivers \ block \ brd.c implementiert, oder verzögerte Verarbeitung in einem anderen Thread, wie in .. implementiert. \ linux \ drivers \ block \ loop.c. <br><br>  Ich denke, es ist nicht nötig zu beschreiben, wie man das Modul zusammenbaut, wie man es in das System lädt und wie man es entlädt.  An dieser Front gibt es keine neuen Produkte, und danke dafür :) Wenn also jemand es ausprobieren möchte, werde ich es sicher herausfinden.  <b>Mach es einfach nicht sofort auf deinem Lieblingslaptop!</b>  Erhöhen Sie eine Virtualochka oder machen Sie zumindest ein Backup auf einem Ball. <br><br>  Veeam Backup für Linux 3.0.1.1046 ist übrigens bereits verfügbar.  Versuchen Sie einfach nicht, VAL 3.0.1.1046 auf einem Kernel 5.0 oder höher auszuführen.  veeamsnap wird nicht zusammengebaut.  Einige Innovationen in mehreren Warteschlangen befinden sich noch in der Testphase. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446148/">https://habr.com/ru/post/de446148/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446132/index.html">92,7% machen Backups, der Datenverlust stieg um 30%. Was ist los?</a></li>
<li><a href="../de446134/index.html">Abhängigkeitsinjektion beim Flattern</a></li>
<li><a href="../de446136/index.html">Meine Marmormaschine 3D gedruckt</a></li>
<li><a href="../de446142/index.html">Flache Erde: Experimente und Beweise</a></li>
<li><a href="../de446144/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 292 (25. März - 31. März)</a></li>
<li><a href="../de446150/index.html">Maschinelles Lernen ohne Python, Anaconda und andere Reptilien</a></li>
<li><a href="../de446152/index.html">Commando VM - Kali Linux Alternative für Windows</a></li>
<li><a href="../de446162/index.html">Wie man ein "intelligenter Junior" wird. Persönliche Erfahrung</a></li>
<li><a href="../de446166/index.html">Einfacher Sprintf ASN1 Codec</a></li>
<li><a href="../de446172/index.html">Limit Messages API VK - was zu tun ist</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>