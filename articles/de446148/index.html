<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíã üîä üë©üèΩ‚Äçüíª Linux Kernel 5.0 - Schreiben von Simple Block Device unter blk-mq üë®üèø‚Äçüè≠ üï¥Ô∏è üí™üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gute Nachrichten, alle zusammen! 

 Der Linux-Kernel 5.0 ist bereits vorhanden und erscheint in experimentellen Distributionen wie Arch, openSUSE Tumb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linux Kernel 5.0 - Schreiben von Simple Block Device unter blk-mq</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/446148/">  Gute Nachrichten, alle zusammen! <br><br>  Der Linux-Kernel 5.0 ist bereits vorhanden und erscheint in experimentellen Distributionen wie Arch, openSUSE Tumbleweed und Fedora. <br><br><img src="https://habrastorage.org/webt/me/zn/aq/meznaq4kak63su90hds63zvj1tq.png"><br><br>  Und wenn Sie sich die RC-Distributionen von Ubuntu Disko Dingo und Red Hat 8 ansehen, wird klar: Bald wird Kernel 5.0 auch von Fan-Desktops auf seri√∂se Server √ºbertragen. <br>  Jemand wird sagen - na und.  Die n√§chste Ver√∂ffentlichung, nichts Besonderes.  Also sagte Linus Torvalds selbst: <blockquote>  Ich m√∂chte (noch einmal) darauf hinweisen, dass wir keine funktionsbasierten Releases machen und dass ‚Äû5.0‚Äú nichts anderes bedeutet, als dass die 4.x-Zahlen so gro√ü wurden, dass mir die Finger ausgegangen sind und Zehen. <br><br>  ( <i>Ich wiederhole noch einmal: Unsere Releases sind nicht an bestimmte Funktionen gebunden, daher bedeutet die Nummer der neuen Version 5.0 nur, dass ich f√ºr die Nummerierung der Versionen 4.x bereits nicht gen√ºgend Finger und Zehen habe.</i> ) <br></blockquote><br>  Das Modul f√ºr Disketten (wer wei√ü nicht - das sind Platten von der Gr√∂√üe eines Brusttaschenhemdes mit einer Kapazit√§t von 1,44 MB) - korrigiert ... <br>  Und hier ist warum: <br><a name="habracut"></a><br>  Es dreht sich alles um die Blockschicht mit mehreren Warteschlangen (blk-mq).  Im Internet gibt es viele einf√ºhrende Artikel √ºber ihn. Kommen wir also gleich zur Sache.  Der √úbergang zu blk-mq wurde vor langer Zeit begonnen und ging langsam voran.  Multi-Queue-scsi (Kernel-Parameter scsi_mod.use_blk_mq) erschien, neue Scheduler mq-Deadline, bfq und so weiter erschienen ... <br><br><pre><code class="dos hljs">[root@fedora-<span class="hljs-number"><span class="hljs-number">29</span></span> sblkdev]# cat /sys/block/sda/queue/scheduler [mq-deadline] none</code> </pre> <br>  √úbrigens, was ist deins? <br><br>  Die Anzahl der Blockger√§tetreiber, die auf die alte Art und Weise funktionieren, wurde reduziert.  In 5.0 wurde die Funktion blk_init_queue () als unn√∂tig entfernt.  Und jetzt wird der alte glorreiche Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lwn.net/Articles/58720</a> aus dem Jahr 2003 nicht nur nicht, sondern auch an Relevanz verlieren.  Dar√ºber hinaus verwenden die neuen Distributionen, die f√ºr die Ver√∂ffentlichung in diesem Jahr vorbereitet werden, in der Standardkonfiguration eine Blockschicht mit mehreren Warteschlangen.  Beispielsweise ist der Kernel auf dem 18. Manjaro, obwohl Version 4.19, standardm√§√üig blk-mq. <br><br>  Daher k√∂nnen wir davon ausgehen, dass der √úbergang zu blk-mq in Kernel 5.0 abgeschlossen ist.  Und f√ºr mich ist dies ein wichtiges Ereignis, bei dem der Code neu geschrieben und zus√§tzliche Tests durchgef√ºhrt werden m√ºssen.  Was an sich das Auftreten von gro√üen und kleinen Fehlern sowie von mehreren abgest√ºrzten Servern verspricht (Es ist notwendig, Fedya, es ist notwendig! (C)). <br><br>  √úbrigens, wenn jemand denkt, dass dieser Wendepunkt f√ºr rhel8 nicht gekommen ist, da der Kernel dort durch Version 4.18 "geflasht" wurde, dann irren Sie sich.  In frischem RC auf rhel8 waren bereits neue Produkte von 5.0 migriert, und die Funktion blk_init_queue () wurde ebenfalls deaktiviert (wahrscheinlich beim Ziehen eines weiteren Check-ins von github.com/torvalds/linux zu seinen Quellen). <br>  Im Allgemeinen ist die "Freeze" -Version des Kernels f√ºr Linux-Distributoren wie SUSE und Red Hat seit langem ein Marketingkonzept.  Das System meldet, dass die Version beispielsweise 4.4 ist und die Funktionalit√§t tats√§chlich von einer frischen 4.8-Vanille stammt.  Gleichzeitig wird auf der offiziellen Website eine Inschrift angezeigt: "In der neuen Distribution haben wir einen stabilen 4.4-Kernel f√ºr Sie aufbewahrt." <br><br>  Aber wir waren abgelenkt ... <br><br>  Also.  Wir brauchen einen neuen einfachen Blockger√§tetreiber, um klarer zu machen, wie das funktioniert. <br>  Also die Quelle auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/CodeImp/sblkdev</a> .  Ich schlage vor zu diskutieren, Pull-Anfragen zu stellen, Probleme zu starten - ich werde es beheben.  QA wurde noch nicht getestet. <br><br>  Sp√§ter in diesem Artikel werde ich versuchen zu beschreiben, warum.  Daher gibt es viel Code. <br>  Ich entschuldige mich sofort daf√ºr, dass der Codierungsstil des Linux-Kernels nicht vollst√§ndig respektiert wird, und ja - ich mag goto nicht. <br><br>  Beginnen wir also mit den Einstiegspunkten. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">init </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SUCCESS; _sblkdev_major = register_blkdev(_sblkdev_major, _sblkdev_name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_sblkdev_major &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>){ printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: unable to get major number\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EBUSY; } ret = sblkdev_add_device(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret) unregister_blkdev(_sblkdev_major, _sblkdev_name); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">exit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ sblkdev_remove_device(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_sblkdev_major &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) unregister_blkdev(_sblkdev_major, _sblkdev_name); } module_init(sblkdev_init); module_exit(sblkdev_exit);</code> </pre><br>  Wenn das Modul geladen wird, wird nat√ºrlich die Funktion sblkdev_init () gestartet, wenn sblkdev_exit () entladen wird. <br>  Die Funktion register_blkdev () registriert ein Blockger√§t.  Ihm wird eine Hauptnummer zugewiesen.  unregister_blkdev () - gibt diese Nummer frei. <br><br>  Die Schl√ºsselstruktur unseres Moduls ist sblkdev_device_t. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// The internal representation of our device typedef struct sblkdev_device_s { sector_t capacity; // Device size in bytes u8* data; // The data aray. u8 - 8 bytes atomic_t open_counter; // How many openers struct blk_mq_tag_set tag_set; struct request_queue *queue; // For mutual exclusion struct gendisk *disk; // The gendisk structure } sblkdev_device_t;</span></span></code> </pre><br>  Es enth√§lt alle Informationen √ºber das Ger√§t, die f√ºr das Kernelmodul erforderlich sind, insbesondere: die Kapazit√§t des Blockger√§ts, die Daten selbst (es ist einfach), Zeiger auf die Festplatte und die Warteschlange. <br><br>  Alle Blockger√§teinitialisierungen werden in der Funktion sblkdev_add_device () durchgef√ºhrt. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_add_device</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SUCCESS; <span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>* dev = kzalloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>), GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: unable to allocate %ld bytes\n"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOMEM; } _sblkdev_device = dev; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>{ ret = sblkdev_allocate_buffer(dev); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ret) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//simply variant with helper function blk_mq_init_sq_queue. It`s available from kernel 4.20 (vanilla). {//configure tag_set struct request_queue *queue; dev-&gt;tag_set.cmd_size = sizeof(sblkdev_cmd_t); dev-&gt;tag_set.driver_data = dev; queue = blk_mq_init_sq_queue(&amp;dev-&gt;tag_set, &amp;_mq_ops, 128, BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE); if (IS_ERR(queue)) { ret = PTR_ERR(queue); printk(KERN_WARNING "sblkdev: unable to allocate and initialize tag set\n"); break; } dev-&gt;queue = queue; } #else // more flexible variant {//configure tag_set dev-&gt;tag_set.ops = &amp;_mq_ops; dev-&gt;tag_set.nr_hw_queues = 1; dev-&gt;tag_set.queue_depth = 128; dev-&gt;tag_set.numa_node = NUMA_NO_NODE; dev-&gt;tag_set.cmd_size = sizeof(sblkdev_cmd_t); dev-&gt;tag_set.flags = BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE; dev-&gt;tag_set.driver_data = dev; ret = blk_mq_alloc_tag_set(&amp;dev-&gt;tag_set); if (ret) { printk(KERN_WARNING "sblkdev: unable to allocate tag set\n"); break; } } {//configure queue struct request_queue *queue = blk_mq_init_queue(&amp;dev-&gt;tag_set); if (IS_ERR(queue)) { ret = PTR_ERR(queue); printk(KERN_WARNING "sblkdev: Failed to allocate queue\n"); break; } dev-&gt;queue = queue; } #endif dev-&gt;queue-&gt;queuedata = dev; {// configure disk struct gendisk *disk = alloc_disk(1); //only one partition if (disk == NULL) { printk(KERN_WARNING "sblkdev: Failed to allocate disk\n"); ret = -ENOMEM; break; } disk-&gt;flags |= GENHD_FL_NO_PART_SCAN; //only one partition //disk-&gt;flags |= GENHD_FL_EXT_DEVT; disk-&gt;flags |= GENHD_FL_REMOVABLE; disk-&gt;major = _sblkdev_major; disk-&gt;first_minor = 0; disk-&gt;fops = &amp;_fops; disk-&gt;private_data = dev; disk-&gt;queue = dev-&gt;queue; sprintf(disk-&gt;disk_name, "sblkdev%d", 0); set_capacity(disk, dev-&gt;capacity); dev-&gt;disk = disk; add_disk(disk); } printk(KERN_WARNING "sblkdev: simple block device was created\n"); }while(false); if (ret){ sblkdev_remove_device(); printk(KERN_WARNING "sblkdev: Failed add block device\n"); } return ret; }</span></span></span></span></code> </pre><br>  Wir weisen der Struktur Speicher zu, weisen einen Puffer zum Speichern von Daten zu.  Hier ist nichts Besonderes. <br>  Als N√§chstes initialisieren wir die Anforderungsverarbeitungswarteschlange entweder mit einer blk_mq_init_sq_queue () -Funktion oder mit zwei gleichzeitig: blk_mq_alloc_tag_set () + blk_mq_init_queue (). <br><br>  √úbrigens, wenn Sie sich den Quellcode der Funktion blk_mq_init_sq_queue () ansehen, werden Sie sehen, dass dies nur ein Wrapper √ºber die Funktionen blk_mq_alloc_tag_set () und blk_mq_init_queue () ist, die im Kernel 4.20 erschienen sind.  Au√üerdem werden viele Parameter der Warteschlange ausgeblendet, aber es sieht viel einfacher aus.  Sie m√ºssen w√§hlen, welche Option besser ist, aber ich bevorzuge eine explizitere. <br><br>  Der Schl√ºssel in diesem Code ist die globale Variable _mq_ops. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blk_mq_ops</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mq_ops</span></span></span><span class="hljs-class"> = {</span></span> .queue_rq = queue_rq, };</code> </pre><br>  Hier befindet sich die Funktion, die die Verarbeitung von Anforderungen erm√∂glicht, aber etwas sp√§ter mehr dazu.  Die Hauptsache ist, dass wir den Einstiegspunkt f√ºr den Request-Handler festgelegt haben. <br><br>  Nachdem wir die Warteschlange erstellt haben, k√∂nnen wir eine Instanz der Festplatte erstellen. <br><br>  Es gibt keine wesentlichen √Ñnderungen.  Die Festplatte wird zugewiesen, Parameter werden festgelegt und die Festplatte wird dem System hinzugef√ºgt.  Ich m√∂chte den Parameter disk-&gt; flags erl√§utern.  Auf diese Weise k√∂nnen Sie dem System mitteilen, dass die Festplatte entfernbar ist oder beispielsweise keine Partitionen enth√§lt und Sie dort nicht danach suchen m√ºssen. <br><br>  Es gibt eine _fops-Struktur f√ºr die Datentr√§gerverwaltung. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">block_device_operations</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fops</span></span></span><span class="hljs-class"> = {</span></span> .owner = THIS_MODULE, .open = _open, .release = _release, .ioctl = _ioctl, #ifdef CONFIG_COMPAT .compat_ioctl = _compat_ioctl, #endif };</code> </pre><br>  Die Einstiegspunkte _open und _release f√ºr uns f√ºr ein einfaches Blockger√§temodul sind noch nicht sehr interessant.  Zus√§tzlich zum atomaren Inkrement- und Dekrementz√§hler gibt es dort nichts.  Ich habe auch compatible_ioctl ohne Implementierung gelassen, da mir die Version von Systemen mit einem 64-Bit-Kernel und einer 32-Bit-User-Space-Umgebung nicht vielversprechend erscheint. <br><br>  Mit _ioctl k√∂nnen Sie jedoch Systemanforderungen f√ºr dieses Laufwerk verarbeiten.  Wenn eine Festplatte angezeigt wird, versucht das System, mehr dar√ºber zu erfahren.  Sie k√∂nnen einige Fragen nach Belieben beantworten (z. B. um sich als neue CD auszugeben). Die allgemeine Regel lautet jedoch: Wenn Sie keine Fragen beantworten m√∂chten, die f√ºr Sie nicht von Interesse sind, geben Sie einfach den Fehlercode -ENOTTY zur√ºck.  √úbrigens k√∂nnen Sie hier bei Bedarf Ihre Request-Handler zu diesem bestimmten Laufwerk hinzuf√ºgen. <br><br>  Also haben wir das Ger√§t hinzugef√ºgt - wir m√ºssen uns um die Freigabe von Ressourcen k√ºmmern.  Rust ist nicht <s>f√ºr</s> dich da. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_remove_device</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>* dev = _sblkdev_device; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;disk) del_gendisk(dev-&gt;disk); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>) { blk_cleanup_queue(dev-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>); dev-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span> = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;tag_set.tags) blk_mq_free_tag_set(&amp;dev-&gt;tag_set); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;disk) { put_disk(dev-&gt;disk); dev-&gt;disk = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } sblkdev_free_buffer(dev); kfree(dev); _sblkdev_device = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: simple block device was removed\n"</span></span>); } }</code> </pre><br>  Im Prinzip ist alles klar: Wir l√∂schen das Festplattenobjekt aus dem System und geben die Warteschlange frei. Danach geben wir auch unsere Puffer (Datenbereiche) frei. <br><br>  Und jetzt ist das Wichtigste die Abfrageverarbeitung in der Funktion queue_rq (). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> blk_status_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queue_rq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct blk_mq_hw_ctx *hctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct blk_mq_queue_data* bd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">blk_status_t</span></span> status = BLK_STS_OK; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rq</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bd</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rq</span></span></span><span class="hljs-class">;</span></span> blk_mq_start_request(rq); <span class="hljs-comment"><span class="hljs-comment">//we cannot use any locks that make the thread sleep { unsigned int nr_bytes = 0; if (do_simple_request(rq, &amp;nr_bytes) != SUCCESS) status = BLK_STS_IOERR; printk(KERN_WARNING "sblkdev: request process %d bytes\n", nr_bytes); #if 0 //simply and can be called from proprietary module blk_mq_end_request(rq, status); #else //can set real processed bytes count if (blk_update_request(rq, status, nr_bytes)) //GPL-only symbol BUG(); __blk_mq_end_request(rq, status); #endif } return BLK_STS_OK;//always return ok }</span></span></code> </pre><br>  Betrachten Sie zun√§chst die Parameter.  Die erste ist struct blk_mq_hw_ctx * hctx - der Status der Hardware-Warteschlange.  In unserem Fall verzichten wir auf die Hardware-Warteschlange, die nicht verwendet wird. <br><br>  Der zweite Parameter ist const struct blk_mq_queue_data * bd - ein Parameter mit einer sehr pr√§gnanten Struktur, den ich Ihnen nicht in seiner Gesamtheit vorstellen m√∂chte: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blk_mq_queue_data</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rq</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> last; };</code> </pre><br>  Es stellt sich heraus, dass dies im Wesentlichen dieselbe Anfrage ist, die uns aus Zeiten gestellt wurde, an die sich der Chronist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">elixir.bootlin.com</a> nicht mehr erinnert.  Also nehmen wir die Anfrage und beginnen mit der Verarbeitung, √ºber die wir den Kernel benachrichtigen, indem wir blk_mq_start_request () aufrufen.  Nach Abschluss der Anforderungsverarbeitung werden wir den Kernel dar√ºber informieren, indem wir die Funktion blk_mq_end_request () aufrufen. <br><br>  Hier ein kleiner Hinweis: Die Funktion blk_mq_end_request () ist im Wesentlichen ein Wrapper f√ºr Aufrufe von blk_update_request () + __blk_mq_end_request ().  Bei Verwendung der Funktion blk_mq_end_request () k√∂nnen Sie nicht angeben, wie viele Bytes tats√§chlich verarbeitet wurden.  Glaubt, dass alles verarbeitet wird. <br><br>  Die alternative Option verf√ºgt √ºber eine weitere Funktion: Die Funktion blk_update_request wird nur f√ºr Nur-GPL-Module exportiert.  Das hei√üt, wenn Sie ein propriet√§res Kernelmodul erstellen m√∂chten (lassen Sie sich von PM vor diesem heiklen Pfad retten), k√∂nnen Sie blk_update_request () nicht verwenden.  Sie haben also die Wahl. <br><br>  Direktes Verschieben der Bytes von der Anfrage in den Puffer und umgekehrt habe ich in die Funktion do_simple_request () eingef√ºgt. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_simple_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct request *rq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *nr_bytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SUCCESS; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bio_vec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bvec</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">req_iterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iter</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span> *dev = rq-&gt;q-&gt;queuedata; <span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span> pos = blk_rq_pos(rq) &lt;&lt; SECTOR_SHIFT; <span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span> dev_size = (<span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span>)(dev-&gt;capacity &lt;&lt; SECTOR_SHIFT); printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: request start from sector %ld \n"</span></span>, blk_rq_pos(rq)); rq_for_each_segment(bvec, rq, iter) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> b_len = bvec.bv_len; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* b_buf = page_address(bvec.bv_page) + bvec.bv_offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((pos + b_len) &gt; dev_size) b_len = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)(dev_size - pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rq_data_dir(rq))<span class="hljs-comment"><span class="hljs-comment">//WRITE memcpy(dev-&gt;data + pos, b_buf, b_len); else//READ memcpy(b_buf, dev-&gt;data + pos, b_len); pos += b_len; *nr_bytes += b_len; } return ret; }</span></span></code> </pre><br>  Es gibt nichts Neues: rq_for_each_segment iteriert √ºber alles Bio, und alle haben bio_vec-Strukturen, sodass wir zu den Seiten mit den Anforderungsdaten gelangen k√∂nnen. <br><br>  Was sind deine Eindr√ºcke?  Alles scheint einfach?  Bei der Anforderungsverarbeitung werden im Allgemeinen einfach Daten zwischen den Seiten der Anforderung und dem internen Puffer kopiert.  F√ºr einen einfachen Blockger√§tetreiber durchaus w√ºrdig, oder? <br><br>  Aber es gibt ein Problem: <b>Dies ist nicht f√ºr den wirklichen Gebrauch!</b> <br><br>  Das Problem besteht im Wesentlichen darin, dass die Anforderungsverarbeitungsfunktion queue_rq () in einer Schleife aufgerufen wird, die Anforderungen aus der Liste verarbeitet.  Ich wei√ü nicht, welche Sperre f√ºr diese Liste dort verwendet wird, Spin oder RCU (ich m√∂chte nicht l√ºgen - wer wei√ü, korrigiere mich), aber wenn Sie versuchen, beispielsweise Mutex in der Anforderungsverarbeitungsfunktion zu verwenden, schw√∂rt und warnt der Debugging-Kernel: Einschlafen hier ist es unm√∂glich.  Das hei√üt, die Verwendung herk√∂mmlicher Synchronisationstools oder eines virtuellen zusammenh√§ngenden Speichers - einer, der mit vmalloc zugewiesen wird und mit allem, was dies impliziert, in einen Austausch geraten kann - ist unm√∂glich, da der Prozess nicht in den Standby-Zustand versetzt werden kann. <br><br>  Daher entweder nur Spin- oder RCU-Sperren und ein Puffer in Form eines Seitenarrays oder einer Liste oder eines Baums, wie in .. \ linux \ drivers \ block \ brd.c implementiert, oder verz√∂gerte Verarbeitung in einem anderen Thread, wie in .. implementiert. \ linux \ drivers \ block \ loop.c. <br><br>  Ich denke, es ist nicht n√∂tig zu beschreiben, wie man das Modul zusammenbaut, wie man es in das System l√§dt und wie man es entl√§dt.  An dieser Front gibt es keine neuen Produkte, und danke daf√ºr :) Wenn also jemand es ausprobieren m√∂chte, werde ich es sicher herausfinden.  <b>Mach es einfach nicht sofort auf deinem Lieblingslaptop!</b>  Erh√∂hen Sie eine Virtualochka oder machen Sie zumindest ein Backup auf einem Ball. <br><br>  Veeam Backup f√ºr Linux 3.0.1.1046 ist √ºbrigens bereits verf√ºgbar.  Versuchen Sie einfach nicht, VAL 3.0.1.1046 auf einem Kernel 5.0 oder h√∂her auszuf√ºhren.  veeamsnap wird nicht zusammengebaut.  Einige Innovationen in mehreren Warteschlangen befinden sich noch in der Testphase. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446148/">https://habr.com/ru/post/de446148/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446132/index.html">92,7% machen Backups, der Datenverlust stieg um 30%. Was ist los?</a></li>
<li><a href="../de446134/index.html">Abh√§ngigkeitsinjektion beim Flattern</a></li>
<li><a href="../de446136/index.html">Meine Marmormaschine 3D gedruckt</a></li>
<li><a href="../de446142/index.html">Flache Erde: Experimente und Beweise</a></li>
<li><a href="../de446144/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 292 (25. M√§rz - 31. M√§rz)</a></li>
<li><a href="../de446150/index.html">Maschinelles Lernen ohne Python, Anaconda und andere Reptilien</a></li>
<li><a href="../de446152/index.html">Commando VM - Kali Linux Alternative f√ºr Windows</a></li>
<li><a href="../de446162/index.html">Wie man ein "intelligenter Junior" wird. Pers√∂nliche Erfahrung</a></li>
<li><a href="../de446166/index.html">Einfacher Sprintf ASN1 Codec</a></li>
<li><a href="../de446172/index.html">Limit Messages API VK - was zu tun ist</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>