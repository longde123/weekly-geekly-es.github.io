<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍💻 🌾 🍌 التفاف تسلسل في سويفت 📠 💉 🎯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="مرحبا بالجميع. اليوم نريد أن نشارك الترجمة التي تم إعدادها عشية إطلاق الدورة التدريبية "iOS Developer. دورة متقدمة . " دعنا نذهب! 





 تتمثل إحدى ال...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>التفاف تسلسل في سويفت</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/464995/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  <em>مرحبا بالجميع.</em>  <em>اليوم نريد أن نشارك الترجمة التي تم إعدادها عشية إطلاق الدورة التدريبية <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">"iOS Developer.</a></em>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">دورة متقدمة</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">"</a></em>  <em>دعنا نذهب!</em> </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/sk/fh/uc/skfhuco7bg9_mhjmpvov6ie9qao.png"></p><br><p style=";text-align:right;direction:rtl">  تتمثل إحدى المزايا الرئيسية للتصميم المستند إلى بروتوكول Swift في أنه يتيح لنا كتابة تعليمات برمجية عامة متوافقة مع مجموعة واسعة من الأنواع ، ولا يتم تنفيذها على وجه التحديد للجميع.  خاصةً إذا كان هذا الكود العام مخصصًا لأحد البروتوكولات ، والذي يمكن العثور عليه في المكتبة القياسية ، والذي سيسمح باستخدامه مع كل من الأنواع المدمجة والأنواع المعرفة من قبل المستخدم. </p><a name="habracut"></a><br><p style=";text-align:right;direction:rtl">  مثال على هذا البروتوكول هو التسلسل ، وهو مقبول من قبل جميع أنواع المكتبات القياسية التي يمكن تكرارها ، مثل Array ، و Dictionary ، و Set ، وغيرها الكثير.  دعونا نلقي نظرة هذا الأسبوع على الطريقة التي يمكننا بها لف التسلسل في حاويات عالمية ، مما سيسمح لنا بتغليف العديد من الخوارزميات في قلب واجهات برمجة التطبيقات سهلة الاستخدام. </p><br><h3 id="iskusstvo-byt-lenivym" style=";text-align:right;direction:rtl">  فن كونك كسول </h3><br><p style=";text-align:right;direction:rtl">  من السهل أن تشعر بالارتباك من خلال التفكير في أن جميع التسلسلات تشبه Array ، حيث يتم تحميل جميع العناصر على الفور في الذاكرة عند إنشاء التسلسل.  نظرًا لأن الشرط الوحيد لبروتوكول التسلسل هو أن المستقبلات يجب أن تكون قادرة على التكرار ، لا يمكننا أن نضع أي افتراضات حول كيفية تحميل عناصر من تسلسل غير معروف أو تخزينها. <br>  على سبيل المثال ، كما غطينا في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Swift Sequences: The Art of Being Lazy</a> ، يمكن للتسلسل في بعض الأحيان تحميل عناصرها بتكاسل - إما لأسباب تتعلق بالأداء أو لأنه غير مضمون بأن التسلسل بأكمله يمكن أن يتلاءم مع الذاكرة.  فيما يلي بعض الأمثلة على هذه التسلسلات: </p><br><pre style=";text-align:right;direction:rtl"><code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,          ,           . let records = database.records(matching: searchQuery) //     ,       ,      . let folders = folder.subfolders //   ,     ,            . let nodes = node.children</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  نظرًا لأن جميع التسلسلات المذكورة أعلاه كسول لسبب ما ، فلن نرغب في فرضها في صفيف ، على سبيل المثال ، عن طريق استدعاء Array (folder.subfolders).  لكن ربما لا نزال نرغب في التعديل والعمل معهم بطرق مختلفة ، لذلك دعونا ننظر في كيفية القيام بذلك عن طريق إنشاء نوع من برامج التفاف التسلسل. </p><br><h3 id="sozdanie-osnovy" style=";text-align:right;direction:rtl">  إنشاء الأساس </h3><br><p style=";text-align:right;direction:rtl">  لنبدأ بإنشاء نوع أساسي يمكننا استخدامه لإنشاء جميع أنواع واجهات برمجة التطبيقات المريحة فوق أي تسلسل.  سوف نسميها WrappedSequence ، وسيكون نوعًا عالميًا يحتوي على كل من نوع التسلسل الذي نلفه ونوع العنصر الذي نريد إنشاء تسلسل جديد لدينا. <br>  ستكون الميزة الرئيسية للملف لدينا هي IteratorFunction ، والذي سيتيح لنا التحكم في البحث عن التسلسل الأساسي - تغيير Iterator المستخدم لكل تكرار: </p><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WrappedSequence</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapped</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class">&gt;: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">IteratorFunction</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> <span class="hljs-type"><span class="hljs-type">Wrapped</span></span>.<span class="hljs-type"><span class="hljs-type">Iterator</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Element?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wrapped: <span class="hljs-type"><span class="hljs-type">Wrapped</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iterator: <span class="hljs-type"><span class="hljs-type">IteratorFunction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(wrapping wrapped: <span class="hljs-type"><span class="hljs-type">Wrapped</span></span>, iterator: @escaping <span class="hljs-type"><span class="hljs-type">IteratorFunction</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.wrapped = wrapped <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.iterator = iterator } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeIterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Element</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrappedIterator = wrapped.makeIterator() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.iterator(&amp;wrappedIterator) } } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  <em>كما ترون أعلاه ، يستخدم Sequence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">نمط مصنع</a> بحيث ينشئ كل تسلسل نسخة متكررة جديدة لكل تكرار - باستخدام طريقة makeIterator ().</em> </p><br><p style=";text-align:right;direction:rtl">  في الأعلى ، نستخدم نوع AnyIterator في المكتبة القياسية ، وهو <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مكرر لمحو الكتابة</a> الذي يمكنه استخدام أي تطبيق IteratorProtocol أساسي للحصول على قيم Element.  في حالتنا ، سننشئ عنصرًا عن طريق استدعاء IteratorFunction لدينا ، بتمرير وسيطة خاصة بنا للتسلسل المُلتف ، وبما أن هذه الوسيطة مُعلَّمة بالداخل ، فيمكننا تغيير أداة التكرار الأساسية في مكانها داخل وظيفتنا. </p><br><p style=";text-align:right;direction:rtl">  نظرًا لأن WrappedSequence هو أيضًا تسلسل ، يمكننا استخدام جميع وظائف المكتبة القياسية المرتبطة بها ، مثل التكرار أو تحويل قيمها باستخدام الخريطة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> folderNames = <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>(wrapping: folders) { iterator <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iterator.next()?.name } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> folderNames { ... } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> uppercasedNames = folderNames.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.uppercased() }</code> </pre> <br><p style=";text-align:right;direction:rtl">  الآن دعونا نبدأ مع WrappedSequence الجديد! </p><br><h3 id="prefiksy-i-suffiksy" style=";text-align:right;direction:rtl">  البادئات واللواحق </h3><br><p style=";text-align:right;direction:rtl">  عند العمل بالتسلسلات في كثير من الأحيان ، هناك رغبة في إدراج بادئة أو لاحقة في التسلسل الذي نعمل به - لكن هل سيكون من الرائع أن نتمكن من القيام بذلك دون تغيير التسلسل الرئيسي؟  يمكن أن يؤدي هذا إلى أداء أفضل ويسمح لنا بإضافة بادئات ولاحقات إلى أي تسلسل ، وليس فقط الأنواع العامة مثل Array. </p><br><p style=";text-align:right;direction:rtl">  باستخدام WrappedSequence ، يمكننا القيام بذلك بسهولة تامة.  كل ما نحتاج إلى القيام به هو تمديد التسلسل بطريقة تنشئ تسلسلًا ملفوفًا من مجموعة من العناصر لإدراجها كبادئة.  بعد ذلك ، عندما نتكرر ، نبدأ في التكرار على جميع عناصر البادئة قبل المتابعة بالتسلسل الأساسي - مثل هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prefixed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( with prefixElements: Element... )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>, <span class="hljs-type"><span class="hljs-type">Element</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prefixIndex = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>(wrapping: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { iterator <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">//        ,   ,   ,   : guard prefixIndex &gt;= prefixElements.count else { let element = prefixElements[prefixIndex] prefixIndex += 1 return element } //           : return iterator.next() } } }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  <em>أعلاه ، نستخدم معلمة مع عدد متغير من الوسائط (إضافة ... إلى نوعه) للسماح بنقل عنصر أو أكثر إلى نفس الطريقة.</em> <br>  بنفس الطريقة ، يمكننا إنشاء طريقة تضيف مجموعة معينة من اللواحق إلى نهاية التسلسل - أولاً عن طريق إجراء التكرار الخاص بنا للتسلسل الأساسي ثم التكرار على العناصر اللاحقة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">suffixed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( with suffixElements: Element... )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>, <span class="hljs-type"><span class="hljs-type">Element</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> suffixIndex = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>(wrapping: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { iterator <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> next = iterator.next() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,     nil      : guard suffixIndex &lt; suffixElements.count else { return nil } let element = suffixElements[suffixIndex] suffixIndex += 1 return element } return next } } }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  باستخدام الطريقتين المذكورتين أعلاه ، يمكننا الآن إضافة بادئات ولاحقات إلى أي تسلسل نريد.  فيما يلي بعض الأمثلة عن كيفية استخدام واجهات برمجة التطبيقات الجديدة الخاصة بنا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//      : let allFolders = rootFolder.subfolders.prefixed(with: rootFolder) //       : let messages = inbox.messages.suffixed(with: composer.message) //       ,      : let characters = code.prefixed(with: "{").suffixed(with: "}")</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  على الرغم من أنه يمكن تنفيذ جميع الأمثلة المذكورة أعلاه باستخدام أنواع محددة (مثل Array و String) ، فإن ميزة استخدام نوع WrappedSequence لدينا هي أن كل شيء يمكن القيام به بتكاسل - نحن لا ننفذ أي طفرات أو نقيم أي تسلسلات لإضافة بادئات أو لاحقات - والتي يمكن أن تكون مفيدة حقًا في المواقف الحرجة للأداء ، أو عند العمل مع مجموعات البيانات الكبيرة. </p><br><h3 id="cegmentaciya" style=";text-align:right;direction:rtl">  Cegmentatsiya </h3><br><p style=";text-align:right;direction:rtl">  بعد ذلك ، دعونا نلقي نظرة على كيف يمكننا التفاف المتواليات لإنشاء إصدارات مجزأة منها.  في بعض التكرارات ، لا يكفي معرفة ماهية العنصر الحالي - فقد نحتاج أيضًا إلى معلومات حول العناصر التالية والسابقة. <br>  عند العمل بالتسلسلات المفهرسة ، يمكننا تحقيق ذلك غالبًا باستخدام واجهة برمجة التطبيقات التعدادية () التي تستخدم أيضًا برنامج تجميع تسلسلي لمنحنا الوصول إلى كل من العنصر الحالي وفهرسه: </p><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (index, current) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> list.items.enumerated() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> previous = (index &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ? list.items[index - <span class="hljs-number"><span class="hljs-number">1</span></span>] : <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> next = (index &lt; list.items.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) ? list.items[index + <span class="hljs-number"><span class="hljs-number">1</span></span>] : <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ... }</code> </pre> <br><p style=";text-align:right;direction:rtl">  ومع ذلك ، فإن الأسلوب أعلاه ليس مطوّلًا تمامًا من حيث الاحتجاج فحسب ، بل يعتمد أيضًا على استخدام المصفوفات مرة أخرى - أو على الأقل شكل من أشكال التسلسل الذي يمنحنا وصولًا عشوائيًا إلى عناصره - حيث أن العديد من التسلسلات ، لا سيما كسولها ، غير مرحب <br>  بدلاً من ذلك ، دعنا نستخدم WrappedSequence مرة أخرى - لإنشاء مجمّع تسلسلي يوفر كسلاً طرق عرض مجزأة في تسلسله الأساسي ، وتتبع العناصر السابقة والحالية وتحديثها مع استمرار التكرار: </p><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Segment</span></span> = ( previous: <span class="hljs-type"><span class="hljs-type">Element?</span></span>, current: <span class="hljs-type"><span class="hljs-type">Element</span></span>, next: <span class="hljs-type"><span class="hljs-type">Element?</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segmented: <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>, <span class="hljs-type"><span class="hljs-type">Segment</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> previous: <span class="hljs-type"><span class="hljs-type">Element?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> current: <span class="hljs-type"><span class="hljs-type">Element?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> endReached = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>(wrapping: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { iterator <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">//        ,      ,   ,        ,     . guard !endReached, let element = current ?? iterator.next() else { return nil } let next = iterator.next() let segment = (previous, element, next) //     ,    ,      : previous = element current = next endReached = (next == nil) return segment } } }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  الآن يمكننا استخدام واجهة برمجة التطبيقات المذكورة أعلاه لإنشاء نسخة مجزأة من أي تسلسل كلما احتجنا إلى التطلع إلى الأمام أو الخلف عند إجراء التكرار.  على سبيل المثال ، إليك كيفية استخدام التجزئة حتى نتمكن من تحديد متى وصلنا إلى نهاية القائمة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">for segment in list.items.segmented { addTopBorder() addView(for: segment.current) if segment.next == nil { //   ,     addBottomBorder() } } ```swift        ,   .    ,               : ```swift for segment in path.nodes.segmented { let directions = ( enter: segment.previous?.direction(to: segment.current), exit: segment.next.map(segment.current.direction) ) let nodeView = NodeView(directions: directions) nodeView.center = segment.current.position.cgPoint view.addSubview(nodeView) }</code> </pre> <br><p style=";text-align:right;direction:rtl">  لقد بدأنا الآن في رؤية القوة الحقيقية لتسلسل الالتفاف - حيث إنها تتيح لنا إخفاء خوارزميات أكثر وأكثر تعقيدًا في واجهة برمجة تطبيقات بسيطة حقًا.  يحتاج كل المتصل إلى تقسيم التسلسل إلى الوصول إلى الخاصية المقسمة في أي تسلسل ، وسوف يقوم تطبيقنا الأساسي بالعناية بالباقي. </p><br><h3 id="rekursiya" style=";text-align:right;direction:rtl">  العودية </h3><br><p style=";text-align:right;direction:rtl">  أخيرًا ، دعونا نلقي نظرة على كيف يمكن تكرار التكرارات المتكررة باستخدام غلافات التسلسل.  لنفترض أننا أردنا توفير طريقة بسيطة للتكرار بشكل متكرر على تسلسل هرمي من القيم يحتوي فيه كل عنصر في التسلسل الهرمي على سلسلة من العناصر الفرعية.  قد يكون من الصعب القيام بذلك بشكل صحيح ، لذلك سيكون من الرائع أن نتمكن من استخدام تطبيق واحد لتنفيذ كل هذه التكرارات في قاعدة الكود الخاصة بنا. <br>  باستخدام WrappedSequence ، يمكننا تحقيق ذلك عن طريق تمديد التسلسل بأسلوب يستخدم نفس القيد النوع العام للتأكد من أن كل عنصر يمكنه توفير تسلسل متداخل له نفس نوع التكرار مثل نوع التكرار الأصلي.  لتكون قادرًا على الوصول إلى كل تسلسل متداخل ديناميكيًا ، سنطلب أيضًا من المتصل تحديد KeyPath للخاصية التي يجب استخدامها للتكرار ، والتي ستمنحنا تنفيذًا يشبه هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recursive</span></span></span><span class="hljs-function">&lt;S: Sequence&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> keyPath: KeyPath&lt;Element, S&gt; )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>, <span class="hljs-type"><span class="hljs-type">Element</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-type"><span class="hljs-type">Iterator</span></span> == <span class="hljs-type"><span class="hljs-type">Iterator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parentIterators = [<span class="hljs-type"><span class="hljs-type">Iterator</span></span>]() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">moveUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; (iterator: <span class="hljs-type"><span class="hljs-type">Iterator</span></span>, element: <span class="hljs-type"><span class="hljs-type">Element</span></span>)? { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> !parentIterators.isEmpty <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iterator = parentIterators.removeLast() <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> element = iterator.next() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//          ,    ,      : return moveUp() } return (iterator, element) } return WrappedSequence(wrapping: self) { iterator in //       ,      ,      : let element = iterator.next() ?? { return moveUp().map { iterator = $0 return $1 } }() //       ,  ,         ,         . if let nested = element?[keyPath: keyPath].makeIterator() { let parent = iterator parentIterators.append(parent) iterator = nested } return element } } }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  باستخدام ما سبق ، يمكننا الآن التكرار بشكل متكرر على أي تسلسل ، بغض النظر عن كيفية بنائه في الداخل ، ودون الحاجة إلى تحميل التسلسل الهرمي بأكمله مقدمًا.  على سبيل المثال ، فيما يلي كيفية استخدام واجهة برمجة التطبيقات الجديدة هذه للتكرار بشكل متكرر من خلال التسلسل الهرمي للمجلدات: </p><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> allFolders = folder.subfolders.recursive(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: \.subfolders) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> folder <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> allFolders { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> loadContent(from: folder) }</code> </pre> <br><p style=";text-align:right;direction:rtl">  يمكننا أيضًا استخدامه للتكرار عبر جميع عقد الشجرة أو لاجتياز مجموعة من سجلات قاعدة البيانات بشكل متكرر - على سبيل المثال ، لسرد جميع مجموعات المستخدمين في مؤسسة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> allNodes = tree.recursive(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: \.children) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> allGroups = database.groups.recusive(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: \.subgroups)</code> </pre> <br><p style=";text-align:right;direction:rtl">  شيء واحد نحتاج إلى توخي الحذر عندما يتعلق الأمر التكرارات العودية هو منع المراجع الدائرية - عندما يعيدنا مسار معين إلى عنصر واجهناه بالفعل - والذي سيؤدي بنا إلى حلقة لا نهائية. <br>  تتمثل إحدى طرق إصلاح ذلك في تتبع جميع العناصر التي تحدث (ولكن قد يكون ذلك مشكلة في الذاكرة) ، لضمان عدم وجود إشارات دائرية في مجموعة البيانات الخاصة بنا ، أو معالجة مثل هذه الحالات في كل مرة من جانب الاتصال (باستخدام فاصل ، متابعة أو العودة لإكمال أي التكرار الدوري). </p><br><h3 id="zaklyuchenie" style=";text-align:right;direction:rtl">  استنتاج </h3><br><p style=";text-align:right;direction:rtl">  التسلسل هو واحد من أبسط البروتوكولات في المكتبة القياسية - فهو يتطلب طريقة واحدة فقط - لكنه لا يزال واحدًا من أقوى البروتوكولات ، خاصةً عندما يتعلق الأمر بكمية الوظائف التي يمكننا إنشاؤها بناءً عليها.  مثلما تحتوي المكتبة القياسية على تسلسلات مجمعة لأشياء مثل التعدادات ، يمكننا أيضًا إنشاء ملفات غلاف خاصة بنا - والتي تسمح لنا بإخفاء الوظائف المتقدمة باستخدام واجهات برمجة تطبيقات بسيطة حقًا. </p><br><p style=";text-align:right;direction:rtl">  على الرغم من أن التجريدات تأتي دائمًا بسعر ، ومن المهم مراعاة متى يكون من المهم (وربما الأهم - عندما لا يستحق ذلك) تقديمها ، إذا استطعنا بناء التجريدات الخاصة بنا مباشرةً على أعلى ما توفره المكتبة القياسية - باستخدام نفس الاتفاقيات - ثم التجريدية عادة ما تكون أكثر عرضة لاختبار الزمن. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar464995/">https://habr.com/ru/post/ar464995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar464985/index.html">إنترنت الأشياء (IoT) سوف يغير العالم. مستقبل إنترنت الأشياء</a></li>
<li><a href="../ar464987/index.html">المستودعات في Kubernetes: أوبن إي بي إس و روك (Ceph) و رانشر لونجهورن و ستوريجوس و روبن و بورتوركس و لينستور</a></li>
<li><a href="../ar464989/index.html">سياق الروعة</a></li>
<li><a href="../ar464991/index.html">المشاريع التي لم تقلع</a></li>
<li><a href="../ar464993/index.html">بناء حزمة RPM لـ Rosa Linux في الممارسة العملية</a></li>
<li><a href="../ar464997/index.html">حول تطوير تقنيات الواقع الافتراضي: أين يستخدمونها ، ولماذا يستخدم عمل الواقع الافتراضي وأي الأجهزة</a></li>
<li><a href="../ar464999/index.html">كيف تتغير تفاصيل العمل مع خوادم التطبيقات باستخدام مثال OpenLiberty</a></li>
<li><a href="../ar465001/index.html">يوم الأمازون برايم 2019 - بدعم من AWS</a></li>
<li><a href="../ar465003/index.html">الاهتمامات الخاصة بنوع ARPG</a></li>
<li><a href="../ar465007/index.html">Typechecking Django و DRF</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>