<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ô üëäüèø üé• Erstellen Sie ausdrucksstarke intelligente Zeiger f√ºr den Remotespeicher in C ++ üåó üë®üèª‚Äçüè´ üèñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 

 Heute ver√∂ffentlichen wir eine √úbersetzung einer interessanten Studie zur Arbeit mit Speicher und Zeigern in C ++. Das Material ist ein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen Sie ausdrucksstarke intelligente Zeiger f√ºr den Remotespeicher in C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/467421/">  Hallo Habr! <br><br>  Heute ver√∂ffentlichen wir eine √úbersetzung einer interessanten Studie zur Arbeit mit Speicher und Zeigern in C ++.  Das Material ist ein wenig akademisch, aber es wird offensichtlich f√ºr die Leser der B√ºcher von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Galowitz</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Williams</a> von Interesse sein. <br><br>  Folgen Sie der Werbung! <br><a name="habracut"></a><br>  In der Graduiertenschule besch√§ftige ich mich mit dem Aufbau verteilter Datenstrukturen.  Daher ist die Abstraktion, die den Remote-Zeiger darstellt, in meiner Arbeit √§u√üerst wichtig, um sauberen und aufger√§umten Code zu erstellen.  In diesem Artikel werde ich erkl√§ren, warum intelligente Zeiger ben√∂tigt werden, erl√§utern, wie ich Remote-Zeigerobjekte f√ºr meine Bibliothek in C ++ geschrieben habe, und sicherstellen, dass sie genau wie normale C ++ - Zeiger funktionieren.  Dies erfolgt √ºber Remote-Link-Objekte.  Au√üerdem werde ich erkl√§ren, in welchen F√§llen diese Abstraktion aus dem einfachen Grund fehlschl√§gt, dass mein eigener Zeiger (bisher) die Aufgaben, die gew√∂hnliche Zeiger ausf√ºhren k√∂nnen, nicht bew√§ltigt.  Ich hoffe, dieser Artikel wird Leser interessieren, die an der Entwicklung von Abstraktionen auf hoher Ebene beteiligt sind. <br><br><h3>  Low Level APIs </h3><br>  Wenn Sie mit verteilten Computern oder mit Netzwerkhardware arbeiten, haben Sie h√§ufig Lese- und Schreibzugriff auf einen Speicher √ºber die C-API. Ein Beispiel dieser Art ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MPI-</a> API f√ºr die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einwegkommunikation</a> .  Diese API verwendet Funktionen, die den direkten Zugriff auf das Lesen und Schreiben aus dem Speicher anderer Knoten in einem verteilten Cluster erm√∂glichen.  So sieht es etwas vereinfacht aus. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remote_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> target_node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remote_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> target_node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>;</code> </pre> <br>  Bei dem angegebenen <i>Versatz</i> in das gemeinsam genutzte Speichersegment des <code>remote_read</code> eine bestimmte Anzahl von Bytes daraus und <code>remote_write</code> schreibt eine bestimmte Anzahl von Bytes. <br><br>  Diese APIs sind gro√üartig, weil sie uns Zugriff auf wichtige Grundelemente erm√∂glichen, die f√ºr die Implementierung von Programmen, die auf einem Computercluster ausgef√ºhrt werden, n√ºtzlich sind.  Sie sind auch sehr gut, weil sie sehr schnell arbeiten und die auf Hardwareebene angebotenen Funktionen genau widerspiegeln: Remote Direct Memory Access (RDMA).  Moderne Supercomputernetzwerke wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cray Aries</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mellanox EDR</a> erm√∂glichen es uns zu berechnen, dass die Verz√∂gerung beim Lesen / Schreiben 1-2 Œºs nicht √ºberschreitet.  Diese Anzeige wird durch die Tatsache erreicht, dass die Netzwerkkarte (NIC) direkt in den RAM lesen und schreiben kann, ohne darauf zu warten, dass die Remote-CPU aufwacht und auf Ihre Netzwerkanforderung reagiert. <br><br>  Solche APIs sind jedoch in Bezug auf die Anwendungsprogrammierung nicht so gut.  Selbst bei solchen einfachen APIs wie oben beschrieben kostet das versehentliche L√∂schen von Daten nichts, da f√ºr jedes im Speicher gespeicherte Objekt kein separater Name vorhanden ist, sondern nur ein gro√üer zusammenh√§ngender Puffer.  Dar√ºber hinaus ist die Schnittstelle untypisiert, dh Sie haben keine weitere konkrete Hilfe mehr: Wenn der Compiler schw√∂rt, wenn Sie den Wert des falschen Typs an der falschen Stelle notieren.  Ihr Code wird sich einfach als falsch herausstellen, und Fehler werden mysteri√∂ser und katastrophaler Natur sein.  Die Situation ist noch komplizierter, da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese APIs</a> in Wirklichkeit etwas komplizierter sind und es bei der Arbeit mit ihnen durchaus m√∂glich ist, zwei oder mehr Parameter f√§lschlicherweise neu anzuordnen. <br><br><h3>  Gel√∂schte Zeiger </h3><br>  Zeiger sind eine wichtige und notwendige Abstraktionsebene, die beim Erstellen von Programmierwerkzeugen auf hoher Ebene ben√∂tigt wird.  Die direkte Verwendung von Zeigern ist manchmal schwierig, und Sie k√∂nnen viele Fehler machen, aber Zeiger sind die Grundbausteine ‚Äã‚Äãdes Codes.  Datenstrukturen und sogar C ++ - Links verwenden h√§ufig Zeiger unter der Haube. <br><br>  Angenommen, wir haben eine API √§hnlich der oben beschriebenen, wird eine eindeutige Position im Speicher durch zwei ‚ÄûKoordinaten‚Äú angezeigt: (1) den <i>Rang</i> oder die Prozess-ID und (2) den Versatz zu dem gemeinsam genutzten Teil des Remote-Speichers, der vom Prozess mit diesem Rang belegt wird .  Sie k√∂nnen dort nicht anhalten und eine vollwertige Struktur erstellen. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remote_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rank_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset_; };</code> </pre> <br>  Zu diesem Zeitpunkt ist es bereits m√∂glich, eine API zum Lesen und Schreiben in Remote-Zeiger zu entwerfen. Diese API ist sicherer als die urspr√ºnglich verwendete. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> remote_ptr&lt;T&gt; src)</span></span></span><span class="hljs-function"> </span></span>{ T rv; remote_read(&amp;rv, src.rank_, src.offset_, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;T&gt; dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; src)</span></span></span><span class="hljs-function"> </span></span>{ remote_write(&amp;src, dst.rank_, dst.offset_, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)); }</code> </pre> <br>  Blocktransfers sehen sehr √§hnlich aus, und hier lasse ich sie der K√ºrze halber weg.  Zum Lesen und Schreiben von Werten k√∂nnen Sie nun den folgenden Code schreiben: <br><br><pre> <code class="cpp hljs"> remote_ptr&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; ptr = ...; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rval = rget(ptr); rval++; rput(ptr, rval);</code> </pre> <br>  Es ist bereits besser als die urspr√ºngliche API, da wir hier mit typisierten Objekten arbeiten.  Jetzt ist es nicht so einfach, einen Wert vom falschen Typ zu schreiben oder zu lesen oder nur einen Teil eines Objekts zu schreiben. <br><br><h3>  Zeigerarithmetik </h3><br>  Zeigerarithmetik ist die wichtigste Technik, mit der ein Programmierer Wertesammlungen im Speicher verwalten kann.  Wenn wir ein Programm f√ºr verteilte Arbeit im Speicher schreiben, werden wir vermutlich mit gro√üen Wertesammlungen arbeiten. <br>  Was bedeutet das Erh√∂hen oder Verringern eines gel√∂schten Zeigers um eins?  Die einfachste M√∂glichkeit besteht darin, die Arithmetik der gel√∂schten Zeiger als die Arithmetik gew√∂hnlicher Zeiger zu betrachten: p + 1 zeigt einfach auf die n√§chste <code>sizeof(T)</code> -ausgerichteten Speichers nach p im gemeinsam genutzten Segment des urspr√ºnglichen Ranges. <br><br>  Obwohl dies nicht die einzig m√∂gliche Definition der Arithmetik von Remote-Zeigern ist, wurde sie k√ºrzlich am aktivsten √ºbernommen, und die auf diese Weise verwendeten Remote-Zeiger sind in Bibliotheken wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UPC ++</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DASH</a> und BCL enthalten.  Die UPC-Sprache ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unified Parallel C</a> ), die in der Community der HPC-Spezialisten (High Performance Computing) ein reiches Erbe hinterlassen hat, enth√§lt jedoch eine ausf√ºhrlichere Definition der Zeigerarithmetik [1]. <br><br>  Das Implementieren der Zeigerarithmetik auf diese Weise ist einfach und beinhaltet nur das √Ñndern des Zeigerversatzes. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; remote_ptr&lt;T&gt; remote_ptr&lt;T&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> diff) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> new_offset = offset_ + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)*diff; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> remote_ptr&lt;T&gt;{rank_, new_offset}; }</code> </pre> <br>  In diesem Fall haben wir die M√∂glichkeit, auf Datenarrays im verteilten Speicher zuzugreifen.  Wir konnten also erreichen, dass jeder Prozess im SPMD-Programm eine Schreib- oder Leseoperation f√ºr seine Variable in dem Array ausf√ºhrt, auf das der Remote-Zeiger gerichtet ist [2]. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (my_rank() &lt; len) { rput(ptr + my_rank(), my_rank()); } }</code> </pre> <br>  Es ist auch einfach, andere Operatoren zu implementieren, die den gesamten Satz von arithmetischen Operationen unterst√ºtzen, die in gew√∂hnlicher Zeigerarithmetik ausgef√ºhrt werden. <br><br><h3>  W√§hlen Sie nullptr </h3><br>  Bei regul√§ren Zeigern ist der Wert <code>nullptr</code> <code>NULL</code> , was normalerweise bedeutet, dass <code>#define</code> auf 0x0 reduziert wird, da dieser Abschnitt im Speicher wahrscheinlich nicht verwendet wird.  In unserem Schema mit Remote-Zeigern k√∂nnen wir entweder einen bestimmten Zeigerwert als <code>nullptr</code> , wodurch dieser Speicherort im Speicher nicht verwendet wird, oder ein spezielles boolesches <code>nullptr</code> , das angibt, ob der Zeiger null ist.  Trotz der Tatsache, dass es nicht der beste Ausweg ist, einen bestimmten Speicherort nicht zu verwenden, ber√ºcksichtigen wir auch, dass sich die Gr√∂√üe des Remote-Zeigers beim Hinzuf√ºgen nur eines Booleschen Werts aus Sicht der meisten Compiler verdoppelt und von 128 auf 256 Bit w√§chst, um die Ausrichtung aufrechtzuerhalten.  Dies ist besonders unerw√ºnscht.  In meiner Bibliothek habe ich <code>{0, 0}</code> , <code>nullptr</code> einen Offset von 0 mit einem Rang von 0 als Wert <code>nullptr</code> . <br><br>  Es kann m√∂glich sein, andere Optionen f√ºr <code>nullptr</code> zu <code>nullptr</code> , die genauso gut funktionieren.  Dar√ºber hinaus sind in einigen Programmierumgebungen wie UPC schmale Zeiger implementiert, die jeweils in 64 Bit passen.  Somit k√∂nnen sie in Atomvergleichsoperationen mit Austausch verwendet werden.  Wenn Sie mit einem schmalen Zeiger arbeiten, m√ºssen Sie Kompromisse eingehen: Entweder der Versatzbezeichner oder der Rangbezeichner sollten in 32 Bit oder weniger passen, was die Skalierbarkeit einschr√§nkt. <br><br><h3>  Gel√∂schte Links </h3><br>  In Sprachen wie Python dient die Klammeranweisung als syntaktischer Zucker zum Aufrufen der <code>__getitem__</code> <code>__setitem__</code> und <code>__getitem__</code> , je nachdem, ob Sie das Objekt lesen oder darauf schreiben.  In C ++ unterscheidet <code>operator[]</code> nicht, zu welcher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Wertkategorien</a> ein Objekt geh√∂rt und ob der zur√ºckgegebene Wert sofort unter Lesen oder Schreiben f√§llt.  Um dieses Problem zu l√∂sen, geben C ++ - Datenstrukturen Links zur√ºck, die auf den im Container enthaltenen Speicher verweisen und geschrieben oder gelesen werden k√∂nnen.  Die <code>operator[]</code> -Implementierung f√ºr <code>std::vector</code> k√∂nnte ungef√§hr so ‚Äã‚Äãaussehen. <br><br><pre> <code class="cpp hljs"> T&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data_[idx]; }</code> </pre><br>  Die wichtigste Tatsache hierbei ist, dass wir eine Entit√§t vom Typ <code>T&amp;</code> , bei der es sich um eine rohe C ++ - Verkn√ºpfung handelt, √ºber die Sie schreiben k√∂nnen, und keine Entit√§t vom Typ <code>T</code> , die lediglich den Wert der Quelldaten darstellt. <br><br>  In unserem Fall k√∂nnen wir keine rohe C ++ - Verkn√ºpfung zur√ºckgeben, da wir uns auf Speicher beziehen, der sich auf einem anderen Knoten befindet und nicht in unserem virtuellen Adressraum dargestellt ist.  Nat√ºrlich k√∂nnen wir unsere eigenen benutzerdefinierten Referenzobjekte erstellen. <br>  Ein Link ist ein Objekt, das als Wrapper um einen Zeiger dient und zwei wichtige Funktionen ausf√ºhrt: Er kann in einen Wert vom Typ <code>T</code> konvertiert werden und Sie k√∂nnen ihn auch einem Wert vom Typ <code>T</code> zuweisen <code>T</code>  Im Fall einer Remote-Referenz m√ºssen wir nur einen impliziten Konvertierungsoperator implementieren, der den Wert liest, und einen Zuweisungsoperator erstellen, der in den Wert schreibt. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remote_ref</span></span></span><span class="hljs-class"> {</span></span> remote_ptr&lt;T&gt; ptr_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rget(ptr_); } remote_ref&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) { rput(ptr_, value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } };</code> </pre><br>  Auf diese Weise k√∂nnen wir unseren Remote-Zeiger mit neuen leistungsstarken Funktionen anreichern, bei deren Vorhandensein er genau wie gew√∂hnliche Zeiger dereferenziert werden kann. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; remote_ref&lt;T&gt; remote_ptr&lt;T&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> remote_ref&lt;T&gt;{*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; remote_ref&lt;T&gt; remote_ptr&lt;T&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> remote_ref&lt;T&gt;{*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> + idx}; }</code> </pre> <br>  Jetzt haben wir das gesamte Bild wiederhergestellt und gezeigt, wie Sie Remote-Zeiger wie gewohnt verwenden k√∂nnen.  Wir k√∂nnen das einfache Programm oben umschreiben. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (my_rank() &lt; len) { ptr[my_rank()] = my_rank(); } }</code> </pre> <br>  Nat√ºrlich k√∂nnen wir mit unserer neuen Zeiger-API komplexere Programme schreiben, beispielsweise eine Funktion zum Durchf√ºhren einer parallelen Reduktion basierend auf einem Baum [3].  Implementierungen, die unsere Remote-Zeigerklasse verwenden, sind sicherer und sauberer als diejenigen, die normalerweise mit der oben beschriebenen C-API erhalten werden. <br><br><h3>  Kosten, die zur Laufzeit anfallen (oder fehlen!) </h3><br>  Was w√ºrde es uns jedoch kosten, eine solche Abstraktion auf hoher Ebene zu verwenden?  Jedes Mal, wenn wir auf den Speicher zugreifen, rufen wir die Dereferenzierungsmethode auf, geben das Zwischenobjekt zur√ºck, das den Zeiger umschlie√üt, und rufen dann den Konvertierungsoperator oder den Zuweisungsoperator auf, der das Zwischenobjekt beeinflusst.  Was kostet es uns zur Laufzeit? <br><br>  Es stellt sich heraus, dass bei sorgf√§ltiger Festlegung der Zeiger- und Referenzklassen zur Laufzeit kein Aufwand f√ºr diese Abstraktion entsteht - moderne C ++ - Compiler verarbeiten diese Zwischenobjekte und Methodenaufrufe durch aggressive Einbettung.  Um zu bewerten, was uns eine solche Abstraktion kostet, k√∂nnen wir ein einfaches Beispielprogramm kompilieren und √ºberpr√ºfen, wie die Assembly abl√§uft, um festzustellen, welche Objekte und Methoden zur Laufzeit vorhanden sind.  In dem hier beschriebenen Beispiel mit baumbasierter Reduktion, die mit Klassen von Remote-Zeigern und <code>remote_read</code> kompiliert wurde, reduzieren moderne Compiler die baumbasierte Reduktion auf mehrere <code>remote_read</code> und <code>remote_write</code> [4].  Zur Laufzeit werden keine Klassenmethoden aufgerufen, keine Referenzobjekte vorhanden. <br><br><h3>  Interaktion mit Datenstrukturbibliotheken </h3><br>  Erfahrene C ++ - Programmierer denken daran, dass in der Standard-C ++ - Vorlagenbibliothek Folgendes angegeben ist: STL-Container m√ºssen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benutzerdefinierte C ++ - Allokatoren unterst√ºtzen</a> .  Mit Allokatoren k√∂nnen Sie Speicher zuweisen, und dann kann auf diesen Speicher mithilfe der von uns erstellten Zeigertypen verwiesen werden.  Bedeutet dies, dass Sie einfach einen "Remote-Allokator" erstellen und ihn verbinden k√∂nnen, um Daten mithilfe von STL-Containern im Remote-Speicher zu speichern? <br><br>  Leider gibt es keine.  Vermutlich erfordert der C ++ - Standard aus Leistungsgr√ºnden keine Unterst√ºtzung mehr f√ºr benutzerdefinierte Referenztypen, und in den meisten Implementierungen der C ++ - Standardbibliothek werden sie wirklich nicht unterst√ºtzt.  Wenn Sie beispielsweise libstdc ++ von GCC verwenden, k√∂nnen Sie auf benutzerdefinierte Zeiger zur√ºckgreifen, es stehen Ihnen jedoch nur normale C ++ - Links zur Verf√ºgung, sodass Sie keine STL-Container im Remotespeicher verwenden k√∂nnen.  Einige √ºbergeordnete C ++ - Vorlagenbibliotheken, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Agency</a> , die benutzerdefinierte Zeigertypen und Referenztypen verwenden, enthalten eigene Implementierungen einiger Datenstrukturen aus STL, mit denen Sie wirklich mit Remote-Referenztypen arbeiten k√∂nnen.  In diesem Fall erh√§lt der Programmierer mehr Freiheit bei der kreativen Erstellung von Zuordnertypen, Zeigern und Verkn√ºpfungen sowie eine Sammlung von Datenstrukturen, die automatisch mit ihnen verwendet werden k√∂nnen. <br><br><h3>  Breiter Kontext </h3><br>  In diesem Artikel haben wir eine Reihe allgemeinerer und noch nicht gel√∂ster Probleme angesprochen. <br><br><ul><li>  <b>Speicherzuordnung</b> .  Wie k√∂nnen wir nun, da wir Objekte im Remote-Speicher referenzieren k√∂nnen, einen solchen Remote-Speicher reservieren oder zuweisen? </li><li>  <b>Unterst√ºtzung f√ºr Objekte</b> .  Was ist mit der Speicherung solcher Objekte im Remote-Speicher, deren Typ komplizierter ist als int?  Ist eine ordentliche Unterst√ºtzung f√ºr komplexe Typen m√∂glich?  K√∂nnen einfache Typen gleichzeitig unterst√ºtzt werden, ohne Ressourcen f√ºr die Serialisierung zu verschwenden? </li><li>  <b>Entwerfen verteilter Datenstrukturen</b> .  Welche Datenstrukturen und Anwendungen k√∂nnen Sie mit diesen Abstraktionen erstellen?  Welche Abstraktionen sollten f√ºr die Datenverteilung verwendet werden? </li></ul><br><h3>  Anmerkungen </h3><br>  [1] In UPC haben Zeiger eine Phase, die bestimmt, auf welchen Rang der Zeiger gerichtet wird, nachdem er um eins erh√∂ht wurde.  Aufgrund der Phasen k√∂nnen verteilte Arrays in Zeigern eingekapselt werden, und die Verteilungsmuster in ihnen k√∂nnen sehr unterschiedlich sein.  Diese Funktionen sind sehr leistungsf√§hig, aber f√ºr Anf√§nger m√∂gen sie magisch erscheinen.  Obwohl einige UPC-Asse diesen Ansatz wirklich bevorzugen, besteht ein vern√ºnftigerer objektorientierter Ansatz darin, zuerst eine einfache Remote-Zeigerklasse zu schreiben und dann sicherzustellen, dass die Daten basierend auf speziell daf√ºr entwickelten Datenstrukturen zugewiesen werden. <br><br>  [2] Die meisten Anwendungen in HPC sind im Stil von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SPMD geschrieben</a> . Dieser Name bedeutet "ein Programm, verschiedene Daten".  Die SPMD-API bietet eine Funktion oder Variable <code>my_rank()</code> , die dem Prozess, der das Programm ausf√ºhrt, einen eindeutigen Rang oder eine eindeutige ID mitteilt, anhand derer er dann vom Hauptprogramm verzweigen kann. <br><br>  [3] Hier ist eine einfache Baumreduktion, die im SPMD-Stil unter Verwendung der Remote-Zeigerklasse geschrieben wurde.  Der Code basiert auf einem Programm, das urspr√ºnglich von meinem Kollegen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andrew Belt geschrieben wurde</a> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parallel_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;T&gt; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> k = len; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { k = (k + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (my_rank() &lt; k &amp;&amp; my_rank() + k &lt; len) { a[my_rank()] += a[my_rank() + k]; } len = k; barrier(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre><br>  [4] Das kompilierte Ergebnis des obigen Codes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">finden Sie hier</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467421/">https://habr.com/ru/post/de467421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467407/index.html">Wir arbeiten mit dem Cobot Dobot M1</a></li>
<li><a href="../de467409/index.html">Um im Silicon Valley Gesch√§fte zu machen, m√ºssen Sie sich benehmen</a></li>
<li><a href="../de467413/index.html">PHP Microservice Framework - "Hallo Welt" von Swoft</a></li>
<li><a href="../de467415/index.html">Moderner Devisenmarkt</a></li>
<li><a href="../de467419/index.html">Jakarta EE 8 Final Release ver√∂ffentlicht</a></li>
<li><a href="../de467423/index.html">Xamarin.Forms - bequeme Verwendung von Symbolschriftarten in der Anwendung</a></li>
<li><a href="../de467425/index.html">STEM Intensive Learning Approach</a></li>
<li><a href="../de467427/index.html">BudgetTracker - ein weiteres Open-Source-Tool f√ºr die pers√∂nliche Finanzbuchhaltung</a></li>
<li><a href="../de467429/index.html">Habrastatistik: Erkundung der am meisten und am wenigsten besuchten Abschnitte der Website</a></li>
<li><a href="../de467435/index.html">Wir senden Berichte von Veeam Agent Linux per Post oder per Telegramm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>