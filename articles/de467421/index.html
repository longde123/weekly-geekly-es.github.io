<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥙 👊🏿 🎥 Erstellen Sie ausdrucksstarke intelligente Zeiger für den Remotespeicher in C ++ 🌗 👨🏻‍🏫 🏖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 

 Heute veröffentlichen wir eine Übersetzung einer interessanten Studie zur Arbeit mit Speicher und Zeigern in C ++. Das Material ist ein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen Sie ausdrucksstarke intelligente Zeiger für den Remotespeicher in C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/467421/">  Hallo Habr! <br><br>  Heute veröffentlichen wir eine Übersetzung einer interessanten Studie zur Arbeit mit Speicher und Zeigern in C ++.  Das Material ist ein wenig akademisch, aber es wird offensichtlich für die Leser der Bücher von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Galowitz</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Williams</a> von Interesse sein. <br><br>  Folgen Sie der Werbung! <br><a name="habracut"></a><br>  In der Graduiertenschule beschäftige ich mich mit dem Aufbau verteilter Datenstrukturen.  Daher ist die Abstraktion, die den Remote-Zeiger darstellt, in meiner Arbeit äußerst wichtig, um sauberen und aufgeräumten Code zu erstellen.  In diesem Artikel werde ich erklären, warum intelligente Zeiger benötigt werden, erläutern, wie ich Remote-Zeigerobjekte für meine Bibliothek in C ++ geschrieben habe, und sicherstellen, dass sie genau wie normale C ++ - Zeiger funktionieren.  Dies erfolgt über Remote-Link-Objekte.  Außerdem werde ich erklären, in welchen Fällen diese Abstraktion aus dem einfachen Grund fehlschlägt, dass mein eigener Zeiger (bisher) die Aufgaben, die gewöhnliche Zeiger ausführen können, nicht bewältigt.  Ich hoffe, dieser Artikel wird Leser interessieren, die an der Entwicklung von Abstraktionen auf hoher Ebene beteiligt sind. <br><br><h3>  Low Level APIs </h3><br>  Wenn Sie mit verteilten Computern oder mit Netzwerkhardware arbeiten, haben Sie häufig Lese- und Schreibzugriff auf einen Speicher über die C-API. Ein Beispiel dieser Art ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MPI-</a> API für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einwegkommunikation</a> .  Diese API verwendet Funktionen, die den direkten Zugriff auf das Lesen und Schreiben aus dem Speicher anderer Knoten in einem verteilten Cluster ermöglichen.  So sieht es etwas vereinfacht aus. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remote_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> target_node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remote_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> target_node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>;</code> </pre> <br>  Bei dem angegebenen <i>Versatz</i> in das gemeinsam genutzte Speichersegment des <code>remote_read</code> eine bestimmte Anzahl von Bytes daraus und <code>remote_write</code> schreibt eine bestimmte Anzahl von Bytes. <br><br>  Diese APIs sind großartig, weil sie uns Zugriff auf wichtige Grundelemente ermöglichen, die für die Implementierung von Programmen, die auf einem Computercluster ausgeführt werden, nützlich sind.  Sie sind auch sehr gut, weil sie sehr schnell arbeiten und die auf Hardwareebene angebotenen Funktionen genau widerspiegeln: Remote Direct Memory Access (RDMA).  Moderne Supercomputernetzwerke wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cray Aries</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mellanox EDR</a> ermöglichen es uns zu berechnen, dass die Verzögerung beim Lesen / Schreiben 1-2 μs nicht überschreitet.  Diese Anzeige wird durch die Tatsache erreicht, dass die Netzwerkkarte (NIC) direkt in den RAM lesen und schreiben kann, ohne darauf zu warten, dass die Remote-CPU aufwacht und auf Ihre Netzwerkanforderung reagiert. <br><br>  Solche APIs sind jedoch in Bezug auf die Anwendungsprogrammierung nicht so gut.  Selbst bei solchen einfachen APIs wie oben beschrieben kostet das versehentliche Löschen von Daten nichts, da für jedes im Speicher gespeicherte Objekt kein separater Name vorhanden ist, sondern nur ein großer zusammenhängender Puffer.  Darüber hinaus ist die Schnittstelle untypisiert, dh Sie haben keine weitere konkrete Hilfe mehr: Wenn der Compiler schwört, wenn Sie den Wert des falschen Typs an der falschen Stelle notieren.  Ihr Code wird sich einfach als falsch herausstellen, und Fehler werden mysteriöser und katastrophaler Natur sein.  Die Situation ist noch komplizierter, da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese APIs</a> in Wirklichkeit etwas komplizierter sind und es bei der Arbeit mit ihnen durchaus möglich ist, zwei oder mehr Parameter fälschlicherweise neu anzuordnen. <br><br><h3>  Gelöschte Zeiger </h3><br>  Zeiger sind eine wichtige und notwendige Abstraktionsebene, die beim Erstellen von Programmierwerkzeugen auf hoher Ebene benötigt wird.  Die direkte Verwendung von Zeigern ist manchmal schwierig, und Sie können viele Fehler machen, aber Zeiger sind die Grundbausteine ​​des Codes.  Datenstrukturen und sogar C ++ - Links verwenden häufig Zeiger unter der Haube. <br><br>  Angenommen, wir haben eine API ähnlich der oben beschriebenen, wird eine eindeutige Position im Speicher durch zwei „Koordinaten“ angezeigt: (1) den <i>Rang</i> oder die Prozess-ID und (2) den Versatz zu dem gemeinsam genutzten Teil des Remote-Speichers, der vom Prozess mit diesem Rang belegt wird .  Sie können dort nicht anhalten und eine vollwertige Struktur erstellen. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remote_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rank_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset_; };</code> </pre> <br>  Zu diesem Zeitpunkt ist es bereits möglich, eine API zum Lesen und Schreiben in Remote-Zeiger zu entwerfen. Diese API ist sicherer als die ursprünglich verwendete. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> remote_ptr&lt;T&gt; src)</span></span></span><span class="hljs-function"> </span></span>{ T rv; remote_read(&amp;rv, src.rank_, src.offset_, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;T&gt; dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; src)</span></span></span><span class="hljs-function"> </span></span>{ remote_write(&amp;src, dst.rank_, dst.offset_, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)); }</code> </pre> <br>  Blocktransfers sehen sehr ähnlich aus, und hier lasse ich sie der Kürze halber weg.  Zum Lesen und Schreiben von Werten können Sie nun den folgenden Code schreiben: <br><br><pre> <code class="cpp hljs"> remote_ptr&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; ptr = ...; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rval = rget(ptr); rval++; rput(ptr, rval);</code> </pre> <br>  Es ist bereits besser als die ursprüngliche API, da wir hier mit typisierten Objekten arbeiten.  Jetzt ist es nicht so einfach, einen Wert vom falschen Typ zu schreiben oder zu lesen oder nur einen Teil eines Objekts zu schreiben. <br><br><h3>  Zeigerarithmetik </h3><br>  Zeigerarithmetik ist die wichtigste Technik, mit der ein Programmierer Wertesammlungen im Speicher verwalten kann.  Wenn wir ein Programm für verteilte Arbeit im Speicher schreiben, werden wir vermutlich mit großen Wertesammlungen arbeiten. <br>  Was bedeutet das Erhöhen oder Verringern eines gelöschten Zeigers um eins?  Die einfachste Möglichkeit besteht darin, die Arithmetik der gelöschten Zeiger als die Arithmetik gewöhnlicher Zeiger zu betrachten: p + 1 zeigt einfach auf die nächste <code>sizeof(T)</code> -ausgerichteten Speichers nach p im gemeinsam genutzten Segment des ursprünglichen Ranges. <br><br>  Obwohl dies nicht die einzig mögliche Definition der Arithmetik von Remote-Zeigern ist, wurde sie kürzlich am aktivsten übernommen, und die auf diese Weise verwendeten Remote-Zeiger sind in Bibliotheken wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UPC ++</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DASH</a> und BCL enthalten.  Die UPC-Sprache ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unified Parallel C</a> ), die in der Community der HPC-Spezialisten (High Performance Computing) ein reiches Erbe hinterlassen hat, enthält jedoch eine ausführlichere Definition der Zeigerarithmetik [1]. <br><br>  Das Implementieren der Zeigerarithmetik auf diese Weise ist einfach und beinhaltet nur das Ändern des Zeigerversatzes. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; remote_ptr&lt;T&gt; remote_ptr&lt;T&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> diff) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> new_offset = offset_ + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)*diff; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> remote_ptr&lt;T&gt;{rank_, new_offset}; }</code> </pre> <br>  In diesem Fall haben wir die Möglichkeit, auf Datenarrays im verteilten Speicher zuzugreifen.  Wir konnten also erreichen, dass jeder Prozess im SPMD-Programm eine Schreib- oder Leseoperation für seine Variable in dem Array ausführt, auf das der Remote-Zeiger gerichtet ist [2]. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (my_rank() &lt; len) { rput(ptr + my_rank(), my_rank()); } }</code> </pre> <br>  Es ist auch einfach, andere Operatoren zu implementieren, die den gesamten Satz von arithmetischen Operationen unterstützen, die in gewöhnlicher Zeigerarithmetik ausgeführt werden. <br><br><h3>  Wählen Sie nullptr </h3><br>  Bei regulären Zeigern ist der Wert <code>nullptr</code> <code>NULL</code> , was normalerweise bedeutet, dass <code>#define</code> auf 0x0 reduziert wird, da dieser Abschnitt im Speicher wahrscheinlich nicht verwendet wird.  In unserem Schema mit Remote-Zeigern können wir entweder einen bestimmten Zeigerwert als <code>nullptr</code> , wodurch dieser Speicherort im Speicher nicht verwendet wird, oder ein spezielles boolesches <code>nullptr</code> , das angibt, ob der Zeiger null ist.  Trotz der Tatsache, dass es nicht der beste Ausweg ist, einen bestimmten Speicherort nicht zu verwenden, berücksichtigen wir auch, dass sich die Größe des Remote-Zeigers beim Hinzufügen nur eines Booleschen Werts aus Sicht der meisten Compiler verdoppelt und von 128 auf 256 Bit wächst, um die Ausrichtung aufrechtzuerhalten.  Dies ist besonders unerwünscht.  In meiner Bibliothek habe ich <code>{0, 0}</code> , <code>nullptr</code> einen Offset von 0 mit einem Rang von 0 als Wert <code>nullptr</code> . <br><br>  Es kann möglich sein, andere Optionen für <code>nullptr</code> zu <code>nullptr</code> , die genauso gut funktionieren.  Darüber hinaus sind in einigen Programmierumgebungen wie UPC schmale Zeiger implementiert, die jeweils in 64 Bit passen.  Somit können sie in Atomvergleichsoperationen mit Austausch verwendet werden.  Wenn Sie mit einem schmalen Zeiger arbeiten, müssen Sie Kompromisse eingehen: Entweder der Versatzbezeichner oder der Rangbezeichner sollten in 32 Bit oder weniger passen, was die Skalierbarkeit einschränkt. <br><br><h3>  Gelöschte Links </h3><br>  In Sprachen wie Python dient die Klammeranweisung als syntaktischer Zucker zum Aufrufen der <code>__getitem__</code> <code>__setitem__</code> und <code>__getitem__</code> , je nachdem, ob Sie das Objekt lesen oder darauf schreiben.  In C ++ unterscheidet <code>operator[]</code> nicht, zu welcher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Wertkategorien</a> ein Objekt gehört und ob der zurückgegebene Wert sofort unter Lesen oder Schreiben fällt.  Um dieses Problem zu lösen, geben C ++ - Datenstrukturen Links zurück, die auf den im Container enthaltenen Speicher verweisen und geschrieben oder gelesen werden können.  Die <code>operator[]</code> -Implementierung für <code>std::vector</code> könnte ungefähr so ​​aussehen. <br><br><pre> <code class="cpp hljs"> T&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data_[idx]; }</code> </pre><br>  Die wichtigste Tatsache hierbei ist, dass wir eine Entität vom Typ <code>T&amp;</code> , bei der es sich um eine rohe C ++ - Verknüpfung handelt, über die Sie schreiben können, und keine Entität vom Typ <code>T</code> , die lediglich den Wert der Quelldaten darstellt. <br><br>  In unserem Fall können wir keine rohe C ++ - Verknüpfung zurückgeben, da wir uns auf Speicher beziehen, der sich auf einem anderen Knoten befindet und nicht in unserem virtuellen Adressraum dargestellt ist.  Natürlich können wir unsere eigenen benutzerdefinierten Referenzobjekte erstellen. <br>  Ein Link ist ein Objekt, das als Wrapper um einen Zeiger dient und zwei wichtige Funktionen ausführt: Er kann in einen Wert vom Typ <code>T</code> konvertiert werden und Sie können ihn auch einem Wert vom Typ <code>T</code> zuweisen <code>T</code>  Im Fall einer Remote-Referenz müssen wir nur einen impliziten Konvertierungsoperator implementieren, der den Wert liest, und einen Zuweisungsoperator erstellen, der in den Wert schreibt. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remote_ref</span></span></span><span class="hljs-class"> {</span></span> remote_ptr&lt;T&gt; ptr_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rget(ptr_); } remote_ref&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) { rput(ptr_, value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } };</code> </pre><br>  Auf diese Weise können wir unseren Remote-Zeiger mit neuen leistungsstarken Funktionen anreichern, bei deren Vorhandensein er genau wie gewöhnliche Zeiger dereferenziert werden kann. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; remote_ref&lt;T&gt; remote_ptr&lt;T&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> remote_ref&lt;T&gt;{*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; remote_ref&lt;T&gt; remote_ptr&lt;T&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> remote_ref&lt;T&gt;{*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> + idx}; }</code> </pre> <br>  Jetzt haben wir das gesamte Bild wiederhergestellt und gezeigt, wie Sie Remote-Zeiger wie gewohnt verwenden können.  Wir können das einfache Programm oben umschreiben. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (my_rank() &lt; len) { ptr[my_rank()] = my_rank(); } }</code> </pre> <br>  Natürlich können wir mit unserer neuen Zeiger-API komplexere Programme schreiben, beispielsweise eine Funktion zum Durchführen einer parallelen Reduktion basierend auf einem Baum [3].  Implementierungen, die unsere Remote-Zeigerklasse verwenden, sind sicherer und sauberer als diejenigen, die normalerweise mit der oben beschriebenen C-API erhalten werden. <br><br><h3>  Kosten, die zur Laufzeit anfallen (oder fehlen!) </h3><br>  Was würde es uns jedoch kosten, eine solche Abstraktion auf hoher Ebene zu verwenden?  Jedes Mal, wenn wir auf den Speicher zugreifen, rufen wir die Dereferenzierungsmethode auf, geben das Zwischenobjekt zurück, das den Zeiger umschließt, und rufen dann den Konvertierungsoperator oder den Zuweisungsoperator auf, der das Zwischenobjekt beeinflusst.  Was kostet es uns zur Laufzeit? <br><br>  Es stellt sich heraus, dass bei sorgfältiger Festlegung der Zeiger- und Referenzklassen zur Laufzeit kein Aufwand für diese Abstraktion entsteht - moderne C ++ - Compiler verarbeiten diese Zwischenobjekte und Methodenaufrufe durch aggressive Einbettung.  Um zu bewerten, was uns eine solche Abstraktion kostet, können wir ein einfaches Beispielprogramm kompilieren und überprüfen, wie die Assembly abläuft, um festzustellen, welche Objekte und Methoden zur Laufzeit vorhanden sind.  In dem hier beschriebenen Beispiel mit baumbasierter Reduktion, die mit Klassen von Remote-Zeigern und <code>remote_read</code> kompiliert wurde, reduzieren moderne Compiler die baumbasierte Reduktion auf mehrere <code>remote_read</code> und <code>remote_write</code> [4].  Zur Laufzeit werden keine Klassenmethoden aufgerufen, keine Referenzobjekte vorhanden. <br><br><h3>  Interaktion mit Datenstrukturbibliotheken </h3><br>  Erfahrene C ++ - Programmierer denken daran, dass in der Standard-C ++ - Vorlagenbibliothek Folgendes angegeben ist: STL-Container müssen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benutzerdefinierte C ++ - Allokatoren unterstützen</a> .  Mit Allokatoren können Sie Speicher zuweisen, und dann kann auf diesen Speicher mithilfe der von uns erstellten Zeigertypen verwiesen werden.  Bedeutet dies, dass Sie einfach einen "Remote-Allokator" erstellen und ihn verbinden können, um Daten mithilfe von STL-Containern im Remote-Speicher zu speichern? <br><br>  Leider gibt es keine.  Vermutlich erfordert der C ++ - Standard aus Leistungsgründen keine Unterstützung mehr für benutzerdefinierte Referenztypen, und in den meisten Implementierungen der C ++ - Standardbibliothek werden sie wirklich nicht unterstützt.  Wenn Sie beispielsweise libstdc ++ von GCC verwenden, können Sie auf benutzerdefinierte Zeiger zurückgreifen, es stehen Ihnen jedoch nur normale C ++ - Links zur Verfügung, sodass Sie keine STL-Container im Remotespeicher verwenden können.  Einige übergeordnete C ++ - Vorlagenbibliotheken, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Agency</a> , die benutzerdefinierte Zeigertypen und Referenztypen verwenden, enthalten eigene Implementierungen einiger Datenstrukturen aus STL, mit denen Sie wirklich mit Remote-Referenztypen arbeiten können.  In diesem Fall erhält der Programmierer mehr Freiheit bei der kreativen Erstellung von Zuordnertypen, Zeigern und Verknüpfungen sowie eine Sammlung von Datenstrukturen, die automatisch mit ihnen verwendet werden können. <br><br><h3>  Breiter Kontext </h3><br>  In diesem Artikel haben wir eine Reihe allgemeinerer und noch nicht gelöster Probleme angesprochen. <br><br><ul><li>  <b>Speicherzuordnung</b> .  Wie können wir nun, da wir Objekte im Remote-Speicher referenzieren können, einen solchen Remote-Speicher reservieren oder zuweisen? </li><li>  <b>Unterstützung für Objekte</b> .  Was ist mit der Speicherung solcher Objekte im Remote-Speicher, deren Typ komplizierter ist als int?  Ist eine ordentliche Unterstützung für komplexe Typen möglich?  Können einfache Typen gleichzeitig unterstützt werden, ohne Ressourcen für die Serialisierung zu verschwenden? </li><li>  <b>Entwerfen verteilter Datenstrukturen</b> .  Welche Datenstrukturen und Anwendungen können Sie mit diesen Abstraktionen erstellen?  Welche Abstraktionen sollten für die Datenverteilung verwendet werden? </li></ul><br><h3>  Anmerkungen </h3><br>  [1] In UPC haben Zeiger eine Phase, die bestimmt, auf welchen Rang der Zeiger gerichtet wird, nachdem er um eins erhöht wurde.  Aufgrund der Phasen können verteilte Arrays in Zeigern eingekapselt werden, und die Verteilungsmuster in ihnen können sehr unterschiedlich sein.  Diese Funktionen sind sehr leistungsfähig, aber für Anfänger mögen sie magisch erscheinen.  Obwohl einige UPC-Asse diesen Ansatz wirklich bevorzugen, besteht ein vernünftigerer objektorientierter Ansatz darin, zuerst eine einfache Remote-Zeigerklasse zu schreiben und dann sicherzustellen, dass die Daten basierend auf speziell dafür entwickelten Datenstrukturen zugewiesen werden. <br><br>  [2] Die meisten Anwendungen in HPC sind im Stil von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SPMD geschrieben</a> . Dieser Name bedeutet "ein Programm, verschiedene Daten".  Die SPMD-API bietet eine Funktion oder Variable <code>my_rank()</code> , die dem Prozess, der das Programm ausführt, einen eindeutigen Rang oder eine eindeutige ID mitteilt, anhand derer er dann vom Hauptprogramm verzweigen kann. <br><br>  [3] Hier ist eine einfache Baumreduktion, die im SPMD-Stil unter Verwendung der Remote-Zeigerklasse geschrieben wurde.  Der Code basiert auf einem Programm, das ursprünglich von meinem Kollegen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andrew Belt geschrieben wurde</a> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parallel_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;T&gt; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> k = len; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { k = (k + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (my_rank() &lt; k &amp;&amp; my_rank() + k &lt; len) { a[my_rank()] += a[my_rank() + k]; } len = k; barrier(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre><br>  [4] Das kompilierte Ergebnis des obigen Codes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">finden Sie hier</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467421/">https://habr.com/ru/post/de467421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467407/index.html">Wir arbeiten mit dem Cobot Dobot M1</a></li>
<li><a href="../de467409/index.html">Um im Silicon Valley Geschäfte zu machen, müssen Sie sich benehmen</a></li>
<li><a href="../de467413/index.html">PHP Microservice Framework - "Hallo Welt" von Swoft</a></li>
<li><a href="../de467415/index.html">Moderner Devisenmarkt</a></li>
<li><a href="../de467419/index.html">Jakarta EE 8 Final Release veröffentlicht</a></li>
<li><a href="../de467423/index.html">Xamarin.Forms - bequeme Verwendung von Symbolschriftarten in der Anwendung</a></li>
<li><a href="../de467425/index.html">STEM Intensive Learning Approach</a></li>
<li><a href="../de467427/index.html">BudgetTracker - ein weiteres Open-Source-Tool für die persönliche Finanzbuchhaltung</a></li>
<li><a href="../de467429/index.html">Habrastatistik: Erkundung der am meisten und am wenigsten besuchten Abschnitte der Website</a></li>
<li><a href="../de467435/index.html">Wir senden Berichte von Veeam Agent Linux per Post oder per Telegramm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>