<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔜 🦅 👨🏽‍🚒 如何轻松创建AI种族主义者 🤸🏿 ✌🏾 🐅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="警示课。 

 让我们做一个音调分类器！ 

 情感分析（sentiment analysis）是自然语言处理（NLP）中非常常见的任务，这并不奇怪。 对企业而言，重要的是要了解人们在说什么：正面或负面。 这样的分析用于监视社交网络，客户反馈，甚至用于算法股票交易（因此，机器人在上一部电影中对安妮·...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何轻松创建AI种族主义者</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436506/">警示课。 <br><br>  <b>让我们做一个音调分类器！</b> <br><br> 情感分析（sentiment analysis）是自然语言处理（NLP）中非常常见的任务，这并不奇怪。 对企业而言，重要的是要了解人们在说什么：正面或负面。 这样的分析用于监视社交网络，客户反馈，甚至用于算法股票交易（因此，机器人<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在上一部电影中对安妮·海瑟薇的角色发表正面评价后</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">购买了伯克希尔·哈撒韦的股票</a> ）。 <br><br> 分析方法有时过于简化，但这是获得可测量结果的最简单方法之一。 只需提交文本-输出为正和负。 无需处理解析树，构建图或其他复杂的表示形式。 <br><a name="habracut"></a><br> 这就是我们要做的。 我们将遵循阻力最小的路径，并建立最简单的分类器，对于参与NLP领域相关开发的所有人来说，这看起来似乎非常熟悉。 例如，可以在文章《 <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">深度平均网络》</a></i> （Iyyer等人，2015）中找到这种模型。 我们绝不试图挑战他们的结果或批评模型。 我们只是简单地给出一种众所周知的单词向量表示方法。 <br><br> 工作计划： <br><br><ul><li> 介绍一种典型<b>的单词向量表示法，</b>用于意义（意义）。 </li><li> 介绍带有正负词标准列表的<b>训练和测试数据集</b> 。 </li><li>  <b>训练</b>梯度下降<b>分类器</b>以基于其向量表示来识别其他正负词。 </li><li> 使用此分类器可以计算文本句子的<b>语气等级</b> 。 </li><li>  <b>看看</b>我们创造<b>的怪物</b> 。 </li></ul><br> 然后我们将看到，“如何在无需特殊努力的情况下创建AI种族主义者”。 当然，您不能以如此怪异的形式离开系统，因此我们将要： <br><br><ul><li>  <b>对问题进行</b>统计<b>评估</b> ，以便<b>在解决问题时</b>衡量进度。 </li><li>  <b>改进数据</b>以获得更准确和更少种族主义的语义模型。 </li></ul><br><h1> 软件依赖 </h1><br> 本教程使用Python编写，并且依赖于典型的Python机器学习堆栈：用于数值计算的<code>numpy</code>和<code>scipy</code> ，用于数据管理的<code>pandas</code>和用于机器学习的<code>scikit-learn</code> 。 最后，我们还将<code>seaborn</code> <code>matplotlib</code>和<code>seaborn</code>构建图。 <br><br> 原则上，可以用TensorFlow或Keras或类似的东西代替<code>scikit-learn</code> ：它们还能够在梯度下降时训练分类器。 但是我们不需要它们的抽象，因为这里的培训是在一个阶段进行的。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> seaborn <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> re <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> statsmodels.formula.api <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.linear_model <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SGDClassifier <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.model_selection <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> train_test_split <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.metrics <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> accuracy_score <span class="hljs-comment"><span class="hljs-comment">#     %matplotlib inline seaborn.set_context('notebook', rc={'figure.figsize': (10, 6)}, font_scale=1.5)</span></span></code> </pre> <br><h1> 步骤1.单词的矢量表示 </h1><br> 输入文本时通常使用矢量表示。 单词成为多维空间中的向量，其中相邻的向量表示相似的含义。 使用向量表示法，您可以（大致）通过单词的含义来比较单词，而不仅仅是完全匹配。 <br><br> 成功的学习需要数百GB的文本。 幸运的是，各种研究团队已经完成了这项工作，并提供了可下载的预先训练的矢量表示模型。 <br><br> 英文的两个最著名的数据集是<b>word2vec</b> （在Google新闻文本上受过训练）和<b>GloVe</b> （在Common Crawl网页上）。 它们中的任何一个都会给出类似的结果，但是我们将采用GloVe模型，因为它具有更透明的数据源。 <br><br>  GloVe分为三种规模：60亿，420亿和8400亿，最新的模型功能最强大，但需要大量的处理资源。  420亿个版本相当不错，字典整齐地裁剪成100万个单词。 我们正走在阻力最小的道路上，因此采用420亿美元的版本。 <br><br><blockquote>  <b>-为什么使用“知名”模型如此重要？</b> <br><br>  “我很高兴您询问这个假想的对话者！” 在每个步骤中，我们都尝试做一些非常典型的事情，并且由于某种原因，还没有确定单词向量表示的最佳模型。 我希望本文能引起人们对使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">现代高质量模型</a>的渴望，尤其是那些考虑了算法错误并试图对其进行纠正的模型。 但是，稍后会详细介绍。 </blockquote><br> 从GloVe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">网站</a>下载Gloves.42B.300d.zip并解压缩文件<code>data/glove.42B.300d.txt</code> 。 接下来，我们定义一个用于以简单格式读取向量的函数。 <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_embeddings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""  DataFrame      ,   word2vec, GloVe, fastText  ConceptNet Numberbatch.            . """</span></span> labels = [] rows = [] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(filename, encoding=<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> infile: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(infile): items = line.rstrip().split(<span class="hljs-string"><span class="hljs-string">' '</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(items) == <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-comment"><span class="hljs-comment"># This is a header row giving the shape of the matrix continue labels.append(items[0]) values = np.array([float(x) for x in items[1:]], 'f') rows.append(values) arr = np.vstack(rows) return pd.DataFrame(arr, index=labels, dtype='f') embeddings = load_embeddings('data/glove.42B.300d.txt') embeddings.shape</span></span></code> </pre> <br> <code>(1917494, 300)</code> <br> <h1> 步骤2.黄金标准音调词典 </h1><br> 现在我们需要知道哪些单词被认为是肯定的，哪些单词被认为是负面的信息。 此类词典很多，但是我们将使用一个非常简单的词典（Hu and Liu，2004），该文章在<i>Deep Averaging Networks中使用</i> 。 <br><br> 从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">刘冰的网站上</a>下载字典，然后将数据提取到<code>data/positive-words.txt</code>和<code>data/negative-words.txt</code> 。 <br><br> 接下来，我们确定如何读取这些文件并将它们分配为<code>pos_words</code>和<code>neg_words</code> ： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_lexicon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""       (https://www.cs.uic.edu/~liub/FBS/sentiment-analysis.html)      Latin-1.      ,    - .    ,    ';'   ,   . """</span></span> lexicon = [] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(filename, encoding=<span class="hljs-string"><span class="hljs-string">'latin-1'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> infile: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> infile: line = line.rstrip() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> line.startswith(<span class="hljs-string"><span class="hljs-string">';'</span></span>): lexicon.append(line) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lexicon pos_words = load_lexicon(<span class="hljs-string"><span class="hljs-string">'data/positive-words.txt'</span></span>) neg_words = load_lexicon(<span class="hljs-string"><span class="hljs-string">'data/negative-words.txt'</span></span>)</code> </pre> <br><h1> 步骤3.我们训练模型以预测音调 </h1><br> 基于正词和负词的向量，我们使用Pandas <code>.loc[]</code>命令搜索所有词的向量表示。 <br><br>  GloVe词典中缺少某些单词。 最常见的是这些拼写错误，例如“幻想”。 在这里，我们看到了一堆<code>NaN</code> ，表示没有向量，并使用<code>.dropna()</code>命令将其删除。 <br><br> <code>pos_vectors = embeddings.loc[pos_words].dropna() <br> neg_vectors = embeddings.loc[neg_words].dropna()</code> <br> <br> 现在我们在输入（向量表示）和输出（正数为1，负数为-1）处创建数据数组。 我们还检查矢量是否附加在单词上，以便我们可以解释结果。 <br><br> <code>vectors = pd.concat([pos_vectors, neg_vectors]) <br> targets = np.array([1 for entry in pos_vectors.index] + [-1 for entry in neg_vectors.index]) <br> labels = list(pos_vectors.index) + list(neg_vectors.index)</code> <br> <br><blockquote>  <b>-等一下</b>  <b>有些话既不积极也不消极，它们是中立的。</b>  <b>不应该为中性单词创建第三类吗？</b> <br><br>  “我认为他会派上用场的。” 稍后我们将看到由于将中性词分配了音调而引起的问题。 如果我们能够可靠地识别中性词，那么很有可能将分类器的复杂度提高到三个类别。 但是您需要找到一个中性词字典，因为在Liu的字典中只有正负词。 <br><br> 因此，我尝试了800个单词示例，并增加了预测中性单词的权重。 但是最终结果与您现在看到的并没有很大不同。 <br><br>  <b>-此列表如何区分肯定和否定词？</b>  <b>这不取决于上下文吗？</b> <br><br>  -好问题。 通用键的分析并不像看起来那样简单。 在某些地方边界是任意的。 在此列表中，“无礼”一词被标记为“坏”，而“雄心勃勃”则被标记为“好”。  “漫画”不好，“滑稽”好。  “退款”是好的，尽管当您欠某人的钱或欠某人的钱时，通常会在不好的背景下提到“退款”。 <br><br> 每个人都知道音调是由上下文决定的，但是在一个简单的模型中，您必须忽略上下文，并希望可以正确猜测平均音调。 </blockquote><br> 使用<code>train_test_split</code>函数， <code>train_test_split</code>可以同时将输入向量，输出值和标签划分为训练数据和测试数据，而剩下的10％用于测试。 <br><br><pre> <code class="python hljs">train_vectors, test_vectors, train_targets, test_targets, train_labels, test_labels = \ train_test_split(vectors, targets, labels, test_size=<span class="hljs-number"><span class="hljs-number">0.1</span></span>, random_state=<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br> 现在创建一个分类器，并将向量传递给迭代器。 我们使用逻辑损失函数，以便最终的分类器可以推断出单词为正或负的概率。 <br><br><pre> <code class="python hljs">model = SGDClassifier(loss=<span class="hljs-string"><span class="hljs-string">'log'</span></span>, random_state=<span class="hljs-number"><span class="hljs-number">0</span></span>, n_iter=<span class="hljs-number"><span class="hljs-number">100</span></span>) model.fit(train_vectors, train_targets) SGDClassifier(alpha=<span class="hljs-number"><span class="hljs-number">0.0001</span></span>, average=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, class_weight=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, epsilon=<span class="hljs-number"><span class="hljs-number">0.1</span></span>, eta0=<span class="hljs-number"><span class="hljs-number">0.0</span></span>, fit_intercept=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, l1_ratio=<span class="hljs-number"><span class="hljs-number">0.15</span></span>, learning_rate=<span class="hljs-string"><span class="hljs-string">'optimal'</span></span>, loss=<span class="hljs-string"><span class="hljs-string">'log'</span></span>, n_iter=<span class="hljs-number"><span class="hljs-number">100</span></span>, n_jobs=<span class="hljs-number"><span class="hljs-number">1</span></span>, penalty=<span class="hljs-string"><span class="hljs-string">'l2'</span></span>, power_t=<span class="hljs-number"><span class="hljs-number">0.5</span></span>, random_state=<span class="hljs-number"><span class="hljs-number">0</span></span>, shuffle=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, verbose=<span class="hljs-number"><span class="hljs-number">0</span></span>, warm_start=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>)</code> </pre> <br> 我们在测试向量上评估分类器。 它显示了95％的精度。 还不错 <br><br> <code>accuracy_score(model.predict(test_vectors), test_targets) <br> 0.95022624434389136</code> <br> <br> 我们为某些单词定义了音调预测功能，然后将其用于测试数据中的一些示例。 <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vecs_to_sentiment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vecs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># predict_log_proba  log-    predictions = model.predict_log_proba(vecs) #        #  log-    . return predictions[:, 1] - predictions[:, 0] def words_to_sentiment(words): vecs = embeddings.loc[words].dropna() log_odds = vecs_to_sentiment(vecs) return pd.DataFrame({'sentiment': log_odds}, index=vecs.index) #  20      words_to_sentiment(test_labels).ix[:20]</span></span></code> </pre> <br><table border="1" width="350"><thead><tr><th></th><th> 音调 </th></tr></thead><tbody><tr><th> 坐立不安 </th><td>  -9.931679 </td></tr><tr><th> 打断 </th><td>  -9.634706 </td></tr><tr><th> 坚定不移 </th><td>  1.466919 </td></tr><tr><th> 虚构的 </th><td>  -2.989215 </td></tr><tr><th> 税收 </th><td>  0.468522 </td></tr><tr><th> 世界闻名 </th><td>  6.908561 </td></tr><tr><th> 便宜的 </th><td>  9.237223 </td></tr><tr><th> 失望的 </th><td>  -8.737182 </td></tr><tr><th> 极权主义者 </th><td>  -10.851580 </td></tr><tr><th> 好战的 </th><td>  -8.328674 </td></tr><tr><th> 冻结 </th><td>  -8.456981 </td></tr><tr><th> 罪过 </th><td>  -7.839670 </td></tr><tr><th> 脆弱的 </th><td>  -4.018289 </td></tr><tr><th> 上当 </th><td>  -4.309344 </td></tr><tr><th> 未解决 </th><td>  -2.816172 </td></tr><tr><th> 巧妙地 </th><td>  2.339609 </td></tr><tr><th> 妖魔化 </th><td>  -2.102152 </td></tr><tr><th> 无忧无虑 </th><td>  8.747150 </td></tr><tr><th> 不受欢迎 </th><td>  -7.887475 </td></tr><tr><th> 同情 </th><td>  1.790899 </td></tr></tbody></table><br> 可以看到分类器正在工作。 他学会了在训练数据之外用语音概括音调。 <br><br><h1> 步骤4.获得文本的音调分数。 </h1><br> 有很多方法可以将向量添加到总体估计中。 同样，我们遵循阻力最小的路径，因此取平均值。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> re TOKEN_RE = re.compile(<span class="hljs-string"><span class="hljs-string">r"\w.*?\b"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># regex  ,     (\w)   #   (.+?)    (\b).   #       . def text_to_sentiment(text): tokens = [token.casefold() for token in TOKEN_RE.findall(text)] sentiments = words_to_sentiment(tokens) return sentiments['sentiment'].mean()</span></span></code> </pre> <br> 有很多要求优化的地方： <br><br><ul><li> 引入单词权重及其频率之间的反比关系，以使相同的介词不会严重影响音调。 </li><li> 设置为使短句子不以极端音调值结尾。 </li><li> 会计短语。 </li><li> 撇号不会击倒的更可靠的分词算法。 </li><li> 排除负面因素，例如“不满意”。 </li></ul><br> 但是，所有内容都需要其他代码，并且不会从根本上改变结果。 至少现在您可以大致比较不同的报价： <br><br><pre> <code class="python hljs">text_to_sentiment(<span class="hljs-string"><span class="hljs-string">"this example is pretty cool"</span></span>) <span class="hljs-number"><span class="hljs-number">3.889968926086298</span></span></code> </pre> <br><pre> <code class="python hljs">text_to_sentiment(<span class="hljs-string"><span class="hljs-string">"this example is okay"</span></span>) <span class="hljs-number"><span class="hljs-number">2.7997773492425186</span></span></code> </pre> <br><pre> <code class="python hljs">text_to_sentiment(<span class="hljs-string"><span class="hljs-string">"meh, this example sucks"</span></span>) <span class="hljs-number"><span class="hljs-number">-1.1774475917460698</span></span></code> </pre> <br><h1> 步骤5。看我们创造的怪物 </h1><br> 并非每个句子都有明显的语调。 让我们看看中性句子会发生什么： <br><br><pre> <code class="python hljs">text_to_sentiment(<span class="hljs-string"><span class="hljs-string">"Let's go get Italian food"</span></span>) <span class="hljs-number"><span class="hljs-number">2.0429166109408983</span></span></code> </pre> <br><pre> <code class="python hljs">text_to_sentiment(<span class="hljs-string"><span class="hljs-string">"Let's go get Chinese food"</span></span>) <span class="hljs-number"><span class="hljs-number">1.4094033658140972</span></span></code> </pre> <br><pre> <code class="python hljs">text_to_sentiment(<span class="hljs-string"><span class="hljs-string">"Let's go get Mexican food"</span></span>) <span class="hljs-number"><span class="hljs-number">0.38801985560121732</span></span></code> </pre> <br> 当我考虑到单词的矢量表示来分析餐厅的评论时，我已经遇到过这种现象。 毫无道理<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，所有墨西哥餐馆的总体得分较低</a> 。 <br><br> 向量表示捕获上下文中的细微语义差异。 因此，它们反映了我们社会的偏见。 <br><br> 以下是一些其他中立的建议： <br><br><pre> <code class="python hljs">text_to_sentiment(<span class="hljs-string"><span class="hljs-string">"My name is Emily"</span></span>) <span class="hljs-number"><span class="hljs-number">2.2286179364745311</span></span></code> </pre> <br><pre> <code class="python hljs">text_to_sentiment(<span class="hljs-string"><span class="hljs-string">"My name is Heather"</span></span>) <span class="hljs-number"><span class="hljs-number">1.3976291151079159</span></span></code> </pre> <br><pre> <code class="python hljs">text_to_sentiment(<span class="hljs-string"><span class="hljs-string">"My name is Yvette"</span></span>) <span class="hljs-number"><span class="hljs-number">0.98463802132985556</span></span></code> </pre> <br><pre> <code class="python hljs">text_to_sentiment(<span class="hljs-string"><span class="hljs-string">"My name is Shaniqua"</span></span>) <span class="hljs-number"><span class="hljs-number">-0.47048131775890656</span></span></code> </pre> <br> 好该死... <br><br> 与名字相关的人的系统完全不同。 您可以查看这些示例以及许多其他示例，并发现通常在定型白色名称中音调较高，而在定型黑色名称中音调较低。 <br><br>  Caliscan，Bryson和Narayanan在2017年4月的《 <i>科学</i> 》杂志上发表的研究论文中使用了该测试。 证明<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">语言语料库</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">语义包含社会偏见</a> 。 我们将使用这种方法。 <br><br><h1> 步骤6.评估问题 </h1><br> 我们想了解如何避免此类错误。 让我们通过分类器传递更多数据，并统计测量其“偏差”。 <br><br> 在这里，我们有四个名称列表，这些名称反映了不同的种族背景，主要是在美国。 前两个是主要由“白色”和“黑色”命名的列表，根据Kaliskan等人的文章进行了改编。我还从阿拉伯语和乌尔都语中添加了西班牙和穆斯林的名字。 <br><br> 此数据用于验证ConceptNet构建过程中算法的偏差：可以在<code>conceptnet5.vectors.evaluation.bias</code>模块中找到它。 有一个想法可以将字典扩展到其他种族，不仅要考虑名字，还要考虑姓氏。 <br><br> 这里是清单： <br><br><pre> <code class="python hljs">NAMES_BY_ETHNICITY = { <span class="hljs-comment"><span class="hljs-comment">#           . 'White': [ 'Adam', 'Chip', 'Harry', 'Josh', 'Roger', 'Alan', 'Frank', 'Ian', 'Justin', 'Ryan', 'Andrew', 'Fred', 'Jack', 'Matthew', 'Stephen', 'Brad', 'Greg', 'Jed', 'Paul', 'Todd', 'Brandon', 'Hank', 'Jonathan', 'Peter', 'Wilbur', 'Amanda', 'Courtney', 'Heather', 'Melanie', 'Sara', 'Amber', 'Crystal', 'Katie', 'Meredith', 'Shannon', 'Betsy', 'Donna', 'Kristin', 'Nancy', 'Stephanie', 'Bobbie-Sue', 'Ellen', 'Lauren', 'Peggy', 'Sue-Ellen', 'Colleen', 'Emily', 'Megan', 'Rachel', 'Wendy' ], 'Black': [ 'Alonzo', 'Jamel', 'Lerone', 'Percell', 'Theo', 'Alphonse', 'Jerome', 'Leroy', 'Rasaan', 'Torrance', 'Darnell', 'Lamar', 'Lionel', 'Rashaun', 'Tyree', 'Deion', 'Lamont', 'Malik', 'Terrence', 'Tyrone', 'Everol', 'Lavon', 'Marcellus', 'Terryl', 'Wardell', 'Aiesha', 'Lashelle', 'Nichelle', 'Shereen', 'Temeka', 'Ebony', 'Latisha', 'Shaniqua', 'Tameisha', 'Teretha', 'Jasmine', 'Latonya', 'Shanise', 'Tanisha', 'Tia', 'Lakisha', 'Latoya', 'Sharise', 'Tashika', 'Yolanda', 'Lashandra', 'Malika', 'Shavonn', 'Tawanda', 'Yvette' ], #         . 'Hispanic': [ 'Juan', 'José', 'Miguel', 'Luís', 'Jorge', 'Santiago', 'Matías', 'Sebastián', 'Mateo', 'Nicolás', 'Alejandro', 'Samuel', 'Diego', 'Daniel', 'Tomás', 'Juana', 'Ana', 'Luisa', 'María', 'Elena', 'Sofía', 'Isabella', 'Valentina', 'Camila', 'Valeria', 'Ximena', 'Luciana', 'Mariana', 'Victoria', 'Martina' ], #       # ,   .     . # #          # -   .    #   ,    . # #       . 'Arab/Muslim': [ 'Mohammed', 'Omar', 'Ahmed', 'Ali', 'Youssef', 'Abdullah', 'Yasin', 'Hamza', 'Ayaan', 'Syed', 'Rishaan', 'Samar', 'Ahmad', 'Zikri', 'Rayyan', 'Mariam', 'Jana', 'Malak', 'Salma', 'Nour', 'Lian', 'Fatima', 'Ayesha', 'Zahra', 'Sana', 'Zara', 'Alya', 'Shaista', 'Zoya', 'Yasmin' ] }</span></span></code> </pre> <br> 使用熊猫，我们将编译一个名称表，它们的主要族裔血统和音调等级： <br><br><pre> <code class="plaintext hljs">def name_sentiment_table(): frames = [] for group, name_list in sorted(NAMES_BY_ETHNICITY.items()): lower_names = [name.lower() for name in name_list] sentiments = words_to_sentiment(lower_names) sentiments['group'] = group frames.append(sentiments) #           return pd.concat(frames) name_sentiments = name_sentiment_table()</code> </pre> <br> 样本数据： <br><br> <code>name_sentiments.ix[::25]</code> <br> <table border="1" width="350"><thead><tr><th></th><th> 音调 </th><th> 小组 </th></tr></thead><tbody><tr><th> 穆罕默德 </th><td>  0.834974 </td><td> 阿拉伯/穆斯林 </td></tr><tr><th> 艾莉亚 </th><td>  3.916803 </td><td> 阿拉伯/穆斯林 </td></tr><tr><th> 特里尔 </th><td>  -2.858010 </td><td> 黑色的 </td></tr><tr><th> 何塞 </th><td>  0.432956 </td><td> 西班牙裔 </td></tr><tr><th> 露西安娜 </th><td>  1.086073 </td><td> 西班牙裔 </td></tr><tr><th>  k </th><td>  0.391858 </td><td> 白 </td></tr><tr><th> 梅根 </th><td>  2.158679 </td><td> 白 </td></tr></tbody></table><br> 我们将绘制每个名称的音调分布图。 <br><br><pre> <code class="python hljs">plot = seaborn.swarmplot(x=<span class="hljs-string"><span class="hljs-string">'group'</span></span>, y=<span class="hljs-string"><span class="hljs-string">'sentiment'</span></span>, data=name_sentiments) plot.set_ylim([<span class="hljs-number"><span class="hljs-number">-10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>])</code> </pre> <br> <code>(-10, 10)</code> <br> <br><img src="https://habrastorage.org/webt/qv/y7/ge/qvy7gel8rrvm5txo-nou6g0i0re.png"><br><br> 或作为具有置信区间平均为95％的直方图。 <br><br><pre> <code class="python hljs">plot = seaborn.barplot(x=<span class="hljs-string"><span class="hljs-string">'group'</span></span>, y=<span class="hljs-string"><span class="hljs-string">'sentiment'</span></span>, data=name_sentiments, capsize=<span class="hljs-number"><span class="hljs-number">.1</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/uv/ib/n6/uvibn6olthaxt6cxbd96szehq94.png"><br><br> 最后，运行严重的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">statsmodels</a>统计信息包。 它将显示算法的偏差有多大（以及许多其他统计数据）。 <br><br><br>  <font color="gray">OLS回归结果</font> <br><table><tbody><tr><th> 部门 变数： </th><td> 感悟 </td><th>  R平方： </th><td>  0.208 </td></tr><tr><th> 型号： </th><td> 最小二乘 </td><th> 调整  R平方： </th><td>  0.192 </td></tr><tr><th> 方法： </th><td> 最小二乘 </td><th>  F统计： </th><td>  04/13 </td></tr><tr><th> 日期： </th><td>  2017年7月13日，星期四 </td><th> 概率（F统计）： </th><td>  1.31e-07 </td></tr><tr><th> 时间： </th><td>  11:31:17 </td><th> 对数似然： </th><td>  -356.78 </td></tr><tr><th> 不行 观察结果： </th><td>  153 </td><th>  AIC： </th><td>  721.6 </td></tr><tr><th>  Df残留物： </th><td>  149 </td><th>  BIC： </th><td>  733.7 </td></tr><tr><th>  DF型号： </th><td>  3 </td><th></th><td></td></tr><tr><th> 协方差类型： </th><td> 不稳健 </td><th></th><td></td></tr></tbody></table><br>  F统计量是组间差异与组内差异的比率，可以作为偏差的一般评估。 <br><br> 紧随其后的是表明我们将在无假设的情况下看到最大F统计量的可能性：也就是说，在比较的选项之间不存在差异。 可能性非常非常低。 在科学文章中，我们将结果称为“非常统计显著”。 <br><br> 我们需要提高F值。 越低越好。 <br><br> <code>ols_model.fvalue <br> 13.041597745167659</code> <br> <br><h1> 步骤7.尝试其他数据。 </h1><br> 现在，我们有机会以数字方式测量模型的有害偏差。 让我们尝试调整它。 为此，您需要重复一堆过去只是Python记事本中单独步骤的操作。 <br><br> 如果我编写了良好的受支持的代码，则不会使用诸如<code>model</code>和<code>embeddings</code>类的全局变量。 但是，当前的意大利面条代码使您可以更好地检查每个步骤并了解正在发生的事情。 我们重用部分代码，至少定义一个函数来重复一些步骤： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrain_model</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(new_embs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""      . """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> model, embeddings, name_sentiments embeddings = new_embs pos_vectors = embeddings.loc[pos_words].dropna() neg_vectors = embeddings.loc[neg_words].dropna() vectors = pd.concat([pos_vectors, neg_vectors]) targets = np.array([<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> entry <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pos_vectors.index] + [<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> entry <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> neg_vectors.index]) labels = list(pos_vectors.index) + list(neg_vectors.index) train_vectors, test_vectors, train_targets, test_targets, train_labels, test_labels = \ train_test_split(vectors, targets, labels, test_size=<span class="hljs-number"><span class="hljs-number">0.1</span></span>, random_state=<span class="hljs-number"><span class="hljs-number">0</span></span>) model = SGDClassifier(loss=<span class="hljs-string"><span class="hljs-string">'log'</span></span>, random_state=<span class="hljs-number"><span class="hljs-number">0</span></span>, n_iter=<span class="hljs-number"><span class="hljs-number">100</span></span>) model.fit(train_vectors, train_targets) accuracy = accuracy_score(model.predict(test_vectors), test_targets) print(<span class="hljs-string"><span class="hljs-string">"Accuracy of sentiment: {:.2%}"</span></span>.format(accuracy)) name_sentiments = name_sentiment_table() ols_model = statsmodels.formula.api.ols(<span class="hljs-string"><span class="hljs-string">'sentiment ~ group'</span></span>, data=name_sentiments).fit() print(<span class="hljs-string"><span class="hljs-string">"F-value of bias: {:.3f}"</span></span>.format(ols_model.fvalue)) print(<span class="hljs-string"><span class="hljs-string">"Probability given null hypothesis: {:.3}"</span></span>.format(ols_model.f_pvalue)) <span class="hljs-comment"><span class="hljs-comment">#        Y plot = seaborn.swarmplot(x='group', y='sentiment', data=name_sentiments) plot.set_ylim([-10, 10])</span></span></code> </pre> <br><h3> 我们尝试word2vec </h3><br> 可以假设只有GloVe有问题。  Common Crawl数据库中可能有很多可疑站点，并且至少有20本《街头语城市词典》。 也许在不同的基础上会更好：在Google新闻上训练好的旧word2vec呢？ <br><br> 似乎word2vec数据最权威的来源是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Google云端硬盘上的此文件</a> 。 下载并保存为<code>data/word2vec-googlenews-300.bin.gz</code> 。 <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   ConceptNet   word2vec   Pandas     from conceptnet5.vectors.formats import load_word2vec_bin w2v = load_word2vec_bin('data/word2vec-googlenews-300.bin.gz', nrows=2000000) #  word2vec    w2v.index = [label.casefold() for label in w2v.index] #  ,    w2v = w2v.reset_index().drop_duplicates(subset='index', keep='first').set_index('index') retrain_model(w2v)</span></span></code> </pre> <br> <code>Accuracy of sentiment: 94.30% <br> F-value of bias: 15.573 <br> Probability given null hypothesis: 7.43e-09</code> <br> <br> 因此word2vec的F值大于15时甚至更糟。 <br><br> 原则上，期望<i>新闻</i>能够更好地免受偏见是愚蠢的。 <br><br><h3> 尝试ConceptNet Numberbatch </h3><br> 最后，我可以谈谈我自己的单词向量表示项目。 <br><br> 具有矢量表示功能的ConceptNet是我正在研究的知识图。 它将在训练阶段对向量表示进行归一化，识别并消除算法种族主义和性别歧视的某些来源。 这种校正偏差的方法是基于Bulukbashi等人的文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“去偏置词嵌入”，</a>并且被普遍采用以同时消除多种类型的偏差。 据我所知，这是唯一具有类似内容的语义系统。 <br><br> 我们有时会从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ConceptNet</a>导出预先计算的向量-这些版本称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ConceptNet Numberbatch</a> 。  2017年4月，发布了带有偏差校正的第一个版本，因此我们将加载英语向量并重新训练模型。 <br><br>  <code><a href="">numberbatch-en-17.04b.txt.gz</a></code> ，将其保存在<code>data/</code>目录中并重新训练模型： <br><br><pre> <code class="python hljs">retrain_model(load_embeddings(<span class="hljs-string"><span class="hljs-string">'data/numberbatch-en-17.04b.txt'</span></span>))</code> </pre> <br> <code>Accuracy of sentiment: 97.46% <br> F-value of bias: 3.805 <br> Probability given null hypothesis: 0.0118</code> <br> <br><img src="https://habrastorage.org/webt/5d/iu/uq/5diuuqrst8bca5-m7fljox--pro.png"><br><br> 那么，ConceptNet Numberbatch是否已完全解决问题？ 没有其他算法种族主义了吗？  <b>不行</b> <br><br> 种族主义变得越来越少了吗？  <b>绝对可以</b> 。 <br><br> 与GloVe或word2vec向量相比，族裔的键范围重叠得多。 与GloVe相比，F的值下降了三倍以上，而与word2vec相比，下降了四倍以上。 通常，在比较不同名称时，我们会看到音调上的差异小得多：应该是这样，因为名称确实不会影响分析结果。 <br><br> 但是仍然存在轻微的相关性。 也许我可以选择似乎可以解决问题的数据和训练参数。 但这将是一个糟糕的选择，因为<i>实际上</i>问题仍然存在，因为在ConceptNet中，我们并未发现并弥补算法种族主义的所有原因。 但这是一个好的开始。 <br><br><h3> 没有陷阱 </h3><br> 请注意，切换到ConceptNet Numberbatch可以提高音调预测的准确性。 <br><br> 可能有人建议纠正算法种族主义会以其他方式恶化结果。 但是没有 您可能拥有更好和更少种族主义的数据。      .     word2vec  GloVe        . <br><br><h1>   </h1><br> ,      . -    . <br><br>                . ,         . <br><br>         ,        . ,       —    .      ,    .         (recall),         —   . <br><br>                    ,   -   .    .   ,   ,   . ,       . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN436506/">https://habr.com/ru/post/zh-CN436506/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN436496/index.html">PVS-Studio for Java</a></li>
<li><a href="../zh-CN436498/index.html">Software AG：不仅是ARIS</a></li>
<li><a href="../zh-CN436500/index.html">古墓丽影：崛起的框架如何呈现</a></li>
<li><a href="../zh-CN436502/index.html">订阅纵容或如何向相同的客户销售更多商品</a></li>
<li><a href="../zh-CN436504/index.html">系统级封装还是芯片封装下的封装？</a></li>
<li><a href="../zh-CN436508/index.html">1000万美元的投资和沃兹尼亚克的赞誉-为儿童创造了一款教育计算机</a></li>
<li><a href="../zh-CN436510/index.html">核心数据详细</a></li>
<li><a href="../zh-CN436512/index.html">我们如何找到Graphite和Moira的有问题的版本。 体验Yandex.Money</a></li>
<li><a href="../zh-CN436514/index.html">通过PHP为Instagram创建故事</a></li>
<li><a href="../zh-CN436518/index.html">Haikuβ1-使/ b / OS再次出色</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>