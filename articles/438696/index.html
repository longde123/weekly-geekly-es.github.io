<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë© üõÑ üè≥Ô∏è‚Äçüåà Dispositivo compilador r√°pido. Parte 3 üë©üèø‚Äçüéì üßëüèæ‚Äçü§ù‚ÄçüßëüèΩ ‚úåüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuamos estudiando el compilador Swift. Esta parte est√° dedicada al lenguaje intermedio r√°pido. 


 Si no ha visto los anteriores, le recomiendo q...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dispositivo compilador r√°pido. Parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/438696/"><img src="https://habrastorage.org/webt/w6/d3/5f/w6d35fpnglkxq8suebz-fhsl2de.png"><br><p>  Continuamos estudiando el compilador Swift.  Esta parte est√° dedicada al lenguaje intermedio r√°pido. </p><br><p>  Si no ha visto los anteriores, le recomiendo que siga el enlace y lea: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Resumen general de componentes</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Analizando el archivo fuente</a> . <a name="habracut"></a></li></ul><br><h1 id="silgen">  Silgen </h1><br><p>  El siguiente paso es convertir el AST escrito a SIL sin procesar.  Swift Intermediate Language (SIL) es una representaci√≥n intermedia especialmente creada para Swift.  Puede encontrar una descripci√≥n de todas las instrucciones en la <a href="">documentaci√≥n</a> . </p><br><p>  SIL tiene un formulario SSA.  Asignaci√≥n √∫nica est√°tica (SSA): una representaci√≥n de c√≥digo en la que a cada variable se le asigna un valor solo una vez.  Se crea a partir del c√≥digo regular agregando variables adicionales.  Por ejemplo, usando un sufijo num√©rico que indica la versi√≥n de una variable despu√©s de cada asignaci√≥n. </p><br><p>  Gracias a este formulario, es m√°s f√°cil para el compilador optimizar el c√≥digo.  A continuaci√≥n se muestra un ejemplo de pseudoc√≥digo.  Obviamente, la primera l√≠nea es innecesaria: </p><br><pre><code class="plaintext hljs">a = 1 a = 2 b = a</code> </pre> <br><p>  Pero esto es solo para nosotros.  Para ense√±arle al compilador a determinar esto, uno tendr√≠a que escribir algoritmos no triviales.  Pero con SSA, esto es mucho m√°s f√°cil.  Ahora, incluso para un compilador simple, ser√° obvio que el valor de la variable <strong>a1</strong> no se usa, y esta l√≠nea se puede eliminar: </p><br><pre> <code class="plaintext hljs">a1 = 1 a2 = 2 b1 = a2</code> </pre> <br><p>  SIL le permite aplicar optimizaciones y comprobaciones espec√≠ficas al c√≥digo Swift que ser√≠an dif√≠ciles o imposibles de completar en la fase AST. </p><br><h3 id="ispolzovanie-generatora-sil">  Usando el generador SIL </h3><br><p>  Para generar SIL, use la <strong>bandera -emit-silgen</strong> : </p><br><pre> <code class="plaintext hljs">swiftc -emit-silgen main.swift</code> </pre> <br><p>  El resultado del comando: </p><br><pre> <code class="plaintext hljs">sil_stage raw import Builtin import Swift import SwiftShims let x: Int // x sil_global hidden [let] @$S4main1xSivp : $Int // main sil @main : $@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 { bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;): alloc_global @$S4main1xSivp // id: %2 %3 = global_addr @$S4main1xSivp : $*Int // user: %8 %4 = metatype $@thin Int.Type // user: %7 %5 = integer_literal $Builtin.Int2048, 16 // user: %7 // function_ref Int.init(_builtinIntegerLiteral:) %6 = function_ref @$SSi22_builtinIntegerLiteralSiBi2048__tcfC : $@convention(method) (Builtin.Int2048, @thin Int.Type) -&gt; Int // user: %7 %7 = apply %6(%5, %4) : $@convention(method) (Builtin.Int2048, @thin Int.Type) -&gt; Int // user: %8 store %7 to [trivial] %3 : $*Int // id: %8 %9 = integer_literal $Builtin.Int32, 0 // user: %10 %10 = struct $Int32 (%9 : $Builtin.Int32) // user: %11 return %10 : $Int32 // id: %11 } // end sil function 'main' // Int.init(_builtinIntegerLiteral:) sil [transparent] [serialized] @$SSi22_builtinIntegerLiteralSiBi2048__tcfC : $@convention(method) (Builtin.Int2048, @thin Int.Type) -&gt; Int</code> </pre> <br><p>  SIL, como LLVM IR, se puede generar como c√≥digo fuente.  Puede encontrar en √©l que en esta etapa se agreg√≥ la importaci√≥n de los m√≥dulos Swift Builtin, Swift y SwiftShims. </p><br><p>  A pesar de que el c√≥digo Swift se puede escribir directamente en el √°mbito global, SILGen genera la funci√≥n principal: el punto de entrada al programa.  Todo el c√≥digo estaba ubicado dentro de √©l, excepto para declarar una constante, ya que es global y deber√≠a estar accesible en todas partes. </p><br><p>  La mayor√≠a de las l√≠neas tienen una estructura similar.  A la izquierda hay un pseudo registro en el que se guarda el resultado de la instrucci√≥n.  A continuaci√≥n, la instrucci√≥n en s√≠ y sus par√°metros, y al final, un comentario que indica el registro para el que se utilizar√° este registro. </p><br><p>  Por ejemplo, en esta l√≠nea se crea un literal entero de tipo Int2048 y un valor de 16. Este literal se almacena en el quinto registro y se usar√° para calcular el valor del s√©ptimo: </p><br><pre> <code class="plaintext hljs">%5 = integer_literal $Builtin.Int2048, 16 // user: %7</code> </pre> <br><p>  Una declaraci√≥n de funci√≥n comienza con la palabra clave sil.  El siguiente es el nombre con el prefijo @, convenci√≥n de llamada, par√°metros, tipo de retorno y c√≥digo de funci√≥n.  Para el inicializador <strong>Int.init (_builtinIntegerLiteral :),</strong> por supuesto, no se especifica, ya que esta funci√≥n es de otro m√≥dulo, y solo necesita ser declarada, pero no definida.  Un signo de d√≥lar indica el comienzo de una indicaci√≥n de tipo: </p><br><pre> <code class="plaintext hljs">// Int.init(_builtinIntegerLiteral:) sil [transparent] [serialized] @$SSi22_builtinIntegerLiteralSiBi2048__tcfC : $@convention(method) (Builtin.Int2048, @thin Int.Type) -&gt; Int</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La convenci√≥n de llamada</a> indica c√≥mo llamar correctamente a una funci√≥n.  Esto es necesario para generar c√≥digo de m√°quina.  Una descripci√≥n detallada de estos principios est√° m√°s all√° del alcance de este art√≠culo. </p><br><p>  El nombre de los inicializadores, as√≠ como los nombres de las estructuras, clases, m√©todos, protocolos, est√°n distorsionados (cambio de nombre).  Esto resuelve varios problemas a la vez. </p><br><p>  En primer lugar, permite usar los mismos nombres en diferentes m√≥dulos y entidades anidadas.  Por ejemplo, para el primer m√©todo <strong>fff</strong> , <strong>se usa</strong> el nombre <strong>S4main3AAAV3fffSiyF</strong> , y para el segundo, se <strong>usa S4main3BBBVVffffSiyF</strong> : </p><br><pre> <code class="plaintext hljs">struct AAA { func fff() -&gt; Int { return 8 } } struct BBB { func fff() -&gt; Int { return 8 } }</code> </pre> <br><p>  <strong>S</strong> significa Swift, 4 es el n√∫mero de caracteres en el nombre del m√≥dulo y 3 es el nombre de la clase.  En el inicializador literal, <strong>Si</strong> denota el tipo est√°ndar Swift.Int. </p><br><p>  En segundo lugar, los nombres y tipos de argumentos de funciones se agregan al nombre.  Esto permite el uso de sobrecarga.  Por ejemplo, para el primer m√©todo, <strong>se</strong> genera <strong>S4main3AAAV3fff3iiiS2i_tF</strong> , y para el segundo - <strong>S4main3AAAV3fff3dddSiSd_tF</strong> : </p><br><pre> <code class="plaintext hljs">struct AAA { func fff(iii internalName: Int) -&gt; Int { return 8 } func fff(ddd internalName: Double) -&gt; Int { return 8 } }</code> </pre> <br><p>  Despu√©s de los nombres de los par√°metros, se indica el tipo del valor de retorno, seguido de los tipos de par√°metros.  Sin embargo, sus nombres internos no est√°n indicados.  Desafortunadamente, no hay documentaci√≥n sobre el cambio de nombre en Swift, y su implementaci√≥n puede cambiar en cualquier momento. </p><br><p>  El nombre de la funci√≥n es seguido por su definici√≥n.  Consiste en uno o m√°s bloques b√°sicos.  Un bloque b√°sico es una secuencia de instrucciones con un punto de entrada, un punto de salida, que no contiene instrucciones de rama ni condiciones para una salida anticipada. </p><br><p>  La funci√≥n principal tiene una unidad base, que toma todos los par√°metros pasados ‚Äã‚Äãa la funci√≥n como entrada y contiene todo su c√≥digo, ya que no tiene ramas: </p><br><pre> <code class="plaintext hljs">bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;):</code> </pre> <br><p>  Podemos suponer que cada √°mbito limitado por llaves es una unidad base separada.  Supongamos que el c√≥digo contiene una rama: </p><br><pre> <code class="plaintext hljs">// before if 2 &gt; 5 { // true } else { // false } // after</code> </pre> <br><p>  En este caso, se generar√°n al menos 4 bloques base para: </p><br><ul><li>  c√≥digo antes de ramificar, </li><li>  casos cuando la expresi√≥n es verdadera </li><li>  casos cuando la expresi√≥n es falsa </li><li>  c√≥digo despu√©s de ramificar. </li></ul><br><p>  <strong>cond_br</strong> - instrucci√≥n para salto condicional.  Si el valor del pseudo-registro% 14 es verdadero, entonces se realiza la transici√≥n al bloque <strong>bb1</strong> .  Si no, entonces en <strong>bb2</strong> .  br: salto incondicional que inicia la ejecuci√≥n del bloque base especificado: </p><br><pre> <code class="plaintext hljs">// before cond_br %14, bb1, bb2 // id: %15 bb1: // true br bb3 // id: %21 bb2: // Preds: bb0 // false br bb3 // id: %27 bb3: // Preds: bb2 bb1 // after</code> </pre> <br><p>  C√≥digo fuente: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Archivos de implementaci√≥n de SILGen</a> , </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Archivos de encabezado SIL</a> , </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Archivos de implementaci√≥n SIL</a> , </li><li>  <a href="">Documentaci√≥n SIL</a> . </li></ul><br><h1 id="sil-guaranteed-transformations">  SIL transformaciones garantizadas </h1><br><p>  La representaci√≥n intermedia en bruto que se obtuvo en la √∫ltima etapa se analiza para su correcci√≥n y se transforma en can√≥nica: las funciones marcadas como transparentes est√°n en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">l√≠nea</a> (la llamada a la funci√≥n se reemplaza por su cuerpo), se calculan los valores de las expresiones constantes, se verifica que las funciones que devuelven los valores haga esto en todas las ramas de c√≥digo, etc. </p><br><p>  Estas conversiones son obligatorias y se realizan incluso si la optimizaci√≥n del c√≥digo est√° deshabilitada. </p><br><h3 id="generaciya-kanonichnogo-sil">  Canon SIL Generation </h3><br><p>  Para generar SIL can√≥nico, se usa la bandera <strong>-emit-sil</strong> : </p><br><pre> <code class="plaintext hljs">swiftc -emit-sil main.swift</code> </pre> <br><p>  El resultado del comando: </p><br><pre> <code class="plaintext hljs">sil_stage canonical import Builtin import Swift import SwiftShims let x: Int // x sil_global hidden [let] @$S4main1xSivp : $Int // main sil @main : $@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 { bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;): alloc_global @$S4main1xSivp // id: %2 %3 = global_addr @$S4main1xSivp : $*Int // user: %6 %4 = integer_literal $Builtin.Int64, 16 // user: %5 %5 = struct $Int (%4 : $Builtin.Int64) // user: %6 store %5 to %3 : $*Int // id: %6 %7 = integer_literal $Builtin.Int32, 0 // user: %8 %8 = struct $Int32 (%7 : $Builtin.Int32) // user: %9 return %8 : $Int32 // id: %9 } // end sil function 'main' // Int.init(_builtinIntegerLiteral:) sil public_external [transparent] [serialized] @$SSi22_builtinIntegerLiteralSiBi2048__tcfC : $@convention(method) (Builtin.Int2048, @thin Int.Type) -&gt; Int { // %0 // user: %2 bb0(%0 : $Builtin.Int2048, %1 : $@thin Int.Type): %2 = builtin "s_to_s_checked_trunc_Int2048_Int64"(%0 : $Builtin.Int2048) : $(Builtin.Int64, Builtin.Int1) // user: %3 %3 = tuple_extract %2 : $(Builtin.Int64, Builtin.Int1), 0 // user: %4 %4 = struct $Int (%3 : $Builtin.Int64) // user: %5 return %4 : $Int // id: %5 } // end sil function '$SSi22_builtinIntegerLiteralSiBi2048__tcfC'</code> </pre> <br><p>  Hay pocos cambios en un ejemplo tan simple.  Para ver el trabajo real del optimizador, debe complicar un poco el c√≥digo.  Por ejemplo, agregue la suma: </p><br><pre> <code class="plaintext hljs">let x = 16 + 8</code> </pre> <br><p>  En su SIL sin procesar, puede encontrar la adici√≥n de estos literales: </p><br><pre> <code class="plaintext hljs">%13 = function_ref @$SSi1poiyS2i_SitFZ : $@convention(method) (Int, Int, @thin Int.Type) -&gt; Int // user: %14 %14 = apply %13(%8, %12, %4) : $@convention(method) (Int, Int, @thin Int.Type) -&gt; Int // user: %15</code> </pre> <br><p>  Pero en lo can√≥nico ya no est√° all√≠.  En cambio, se usa un valor constante de 24: </p><br><pre> <code class="plaintext hljs">%4 = integer_literal $Builtin.Int64, 24 // user: %5</code> </pre> <br><p>  C√≥digo fuente: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Optimizador SIL obligatorio</a> </li></ul><br><h1 id="sil-optimization">  Optimizaci√≥n de sil </h1><br><p>  Se aplican transformaciones adicionales espec√≠ficas de Swift si la optimizaci√≥n est√° habilitada.  Entre ellos se encuentran la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especializaci√≥n de gen√©ricos</a> (optimizaci√≥n del c√≥digo gen√©rico para un tipo particular de par√°metro), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desvirtualizaci√≥n</a> (reemplazo de llamadas din√°micas por est√°ticas), inlining, <a href="">optimizaci√≥n ARC</a> y mucho m√°s.  Una explicaci√≥n de estas t√©cnicas no encaja en un art√≠culo ya cubierto. </p><br><p>  C√≥digo fuente: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Encabezados del optimizador SIL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Archivos de implementaci√≥n de SIL Optimizer</a> </li></ul><br><p>  Como SIL es una caracter√≠stica de Swift, esta vez no mostr√© ejemplos de implementaci√≥n.  Volveremos al compilador de par√©ntesis en la siguiente parte cuando nos involucraremos en la generaci√≥n de LLVM IR. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438696/">https://habr.com/ru/post/438696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438682/index.html">Jubileo lanza astron√°utica iran√≠</a></li>
<li><a href="../438688/index.html">Bus PCIe 5.0 listo para la puesta en marcha</a></li>
<li><a href="../438690/index.html">Si el m√≥dulo CRT de Pascal estaba en JavaScript</a></li>
<li><a href="../438692/index.html">Platillo volador inercial. Empuja todo</a></li>
<li><a href="../438694/index.html">C√≥mo ha cambiado el proceso de soporte del sitio en los √∫ltimos veinte a√±os</a></li>
<li><a href="../438698/index.html">Sistema de tragedia</a></li>
<li><a href="../438700/index.html">Mapa de accidentes</a></li>
<li><a href="../438708/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 350 (28 de enero - 3 de febrero de 2019)</a></li>
<li><a href="../438710/index.html">Resumen semanal de Frontend (28 de enero - 3 de febrero de 2019)</a></li>
<li><a href="../438714/index.html">Veeam Backup & Replication 9.5 Actualizaci√≥n 4 Descripci√≥n general</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>