<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗝️ 👩🏽‍🏫 ⌨️ 左递归PEG语法 🙌🏻 🙅🏽 🥃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我多次提到左递归是绊脚石，是时候弄清楚了。 主要问题是具有左递归下降的解析器由于堆栈溢出而立即崩溃。 
 Python PEG解析器系列内容 

- 钉解析器 
- PEG解析器实现 
- PEG解析器生成 
- PEG解析器可视化 
- 左递归PEG语法 
- 向PEG语法添加动作 
- PEG解...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>左递归PEG语法</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471986/"><p> 我多次提到左递归是绊脚石，是时候弄清楚了。 主要问题是具有左递归下降的解析器由于堆栈溢出而立即崩溃。 </p><br><div class="spoiler">  <b class="spoiler_title">Python PEG解析器系列内容</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">钉解析器</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PEG解析器实现</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PEG解析器生成</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PEG解析器可视化</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">左递归PEG语法</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">向PEG语法添加动作</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PEG解析器的元语法</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实施PEG的其余功能</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">核心开发者Sprint上的PEG</a> </li></ul></div></div><br><p> 请考虑以下假设的语法规则： </p><br><pre><code class="plaintext hljs">expr: expr '+' term | term</code> </pre> <a name="habracut"></a><br><p> 如果我们将这种语法实现到左递归解析器方法中，则将得到如下所示的内容： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> expr() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expect(<span class="hljs-string"><span class="hljs-string">'+'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p> 因此， <code>expr()</code>以对<code>expr()</code>的调用开始，该调用以<code>expr()</code>的调用为开始，该调用以调用...开始。这只能以栈溢出结束，表示为<code>RecursionError</code>异常。 </p><br><p> 传统的解决方案是重写语法。 在前面的部分中，我只是这样做的。 实际上，上面的语法规则可以重写如下： </p><br><pre> <code class="plaintext hljs">expr: term '+' expr | term</code> </pre> <br><p> 但是，在构造解析树的步骤中，其形状将有所不同。 如果我们在语法中添加<code>'-'</code>运算符，这可能会破坏情况（因为a- <code>a - (b - c)</code>与<code>(a - b) - c</code>不相同）。 这通常可以通过更强大的PEG功能（例如分组和迭代）来解决，我们可以将上述规则重写为： </p><br><pre> <code class="plaintext hljs">expr: term ('+' term)*</code> </pre> <br><p> 实际上，这就是为pgen解析器编写当前Python语法的方式（与左递归规则存在相同的问题）。 </p><br><p> 但是，存在一个小问题：由于运算符<code>'+'</code>和<code>'-'</code> （在Python中）大多是二进制的，因此当我们分析<code>a + b + c</code>类<code>a + b + c</code>东西时，我们必须经历解析的结果（本质上是<code>['a', '+', 'b', '+', 'c']</code>以创建左递归解析树（看起来像这样的<code>[['a', '+', 'b'] , '+', 'c']</code> ）。 </p><br><p> 原始的左递归语法已经暗示了所需的关联性，因此直接从此形式生成解析器将是很好的选择。 而且我们可以！ 一位读者指出了一个简单易行的数学证明。 现在我将尝试解释。 </p><br><p> 让我们看一下输入<code>foo + bar + baz</code>的示例。 我们想从中得到的解析树对应于<code>(foo + bar) + baz</code> 。 这需要对<code>expr()</code>函数进行三个左递归调用：一个对应于顶级运算符<code>'+'</code> （即第二个）；第二个对应于顶级运算符<code>'+'</code> 。 一个-内部运算符<code>'+'</code> （即第一个）； 第三是第二种选择（即<code>term</code> ）的选择。 </p><br><p> 由于我不擅长使用特殊工具绘制实际图表，因此我将在这里使用ASCII文字进行演示： </p><br><pre> <code class="plaintext hljs">expr------------+------+ | \ \ expr--+------+ '+' term | \ \ | expr '+' term | | | | term | | | | | 'foo' 'bar' 'baz'</code> </pre> <br><p> 这个想法是，在<code>expr()</code>函数中，我们需要一个“ oracle”来告诉我们选择第一个选择（即对<code>expr()</code>的递归调用）还是选择第二个选择（即<code>term()</code>调用）。 在第一次调用<code>expr()</code> oracle应告诉我们遵循第一个选择（ <code>expr()</code> ）； 在第二个（递归）调用中-类似，但是在第三个调用中，它应该提示我们调用<code>term()</code> 。 在代码中，它将如下所示： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> oracle() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expr() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expect(<span class="hljs-string"><span class="hljs-string">'+'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p> 怎么写这样的甲骨文？ 让我们看看...我们可以尝试跟踪调用堆栈中（左递归） <code>expr()</code>调用的数量，并将其与以下表达式中的<code>'+'</code>运算符进行比较。 如果调用堆栈的深度大于语句数，则oracle应该返回false（迫使我们选择<code>term()</code> ）。 我迫不及待地想用<code>sys._getframe()</code>实现它，但是有一个更好的方法：让我们翻转调用堆栈！ </p><br><p> 这个想法是，我们从oracle返回false的调用开始，然后保存结果。 这给了我们序列<code>expr() -&gt; term() -&gt; 'foo'</code> 。  （它应该为初始<code>term</code>即<code>'foo'</code>返回一个分析树。上面的代码仅返回<code>True</code> ，但是在系列文章的第二部分中，我已经展示了如何返回该分析树。）这样的oracle易于实现，因为它应该只需在第一次调用时返回<code>False</code>无需进行堆栈检查或查看将来的内容。 </p><br><p> 然后，我们再次调用<code>expr()</code> ，这一次oracle返回<code>True</code> ，但不是用左递归调用<code>expr()</code> ，而是<code>expr()</code>一次调用保存的结果代替。 并且由于还存在期望的运算符<code>'+'</code>和下一个合适的令牌，因此这将为我们提供<code>foo + bar</code>的解析树。 </p><br><p> 再次重复该算法，然后一切都变得正确了：这次我们得到了完整表达式的解析树，它实际上是左递归（ <code>(foo + bar) + baz</code> ）。 </p><br><p> 然后，我们再次重复该算法。 但是这一次，尽管Oracle返回<code>True</code> ，并且上一次调用的保存结果也可用，但是不再有<code>'+'</code>运算符，并且第一种选择失败。 因此，我们尝试第二个选项，该选项成功，并且仅找到初始项（ <code>'foo'</code> ）。 该结果比从第一种方法获得的结果差，因此在此阶段我们停止并保存最长的分析（即<code>(foo + bar) + baz</code> ）。 </p><br><p> 为了将其转换为工作代码，我首先对算法进行了一些修改，以将<code>oracle()</code>调用与对<code>expr()</code>的左递归调用相结合。 我们称之为<code>oracle_expr()</code> 。 代码： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> oracle_expr() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expect(<span class="hljs-string"><span class="hljs-string">'+'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p> 接下来，我们将编写一个实现上述逻辑的包装器。 它使用了一个全局变量（不用担心，我稍后会删除它）。  <code>oracle_expr()</code>函数将读取全局变量，然后包装程序将对其进行控制： </p><br><pre> <code class="python hljs">saved_result = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oracle_expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> saved_result <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saved_result <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> saved_result saved_result = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> parsed_length = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: new_result = expr() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> new_result: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> new_parsed_length = &lt;calculate size of new_result&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> new_parsed_length &lt;= parsed_length: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> saved_result = new_result parsed_length = new_parsed_length <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saved_result</code> </pre> <br><p> 代码当然很糟糕，但是至少它传达了算法的本质。 让我们对其进行重构，以便我们为此感到自豪。 </p><br><p> 最重要的理解（尽管我可能不是第一个注意到这一点的人，这属于我）是我们可以使用备忘录缓存而不是全局变量。 在其中，我们将存储呼叫之间的结果。 因此，我们摆脱了单独的函数<code>oracle_expr()</code> ，因为 我们可以生成对<code>expr()</code>的标准调用，而不管它是位于左侧还是右侧的递归位置。 </p><br><p> 因此，我们需要一个单独的<code>@memoize_left_rec</code>装饰器，该装饰器仅用于左递归规则。 它调用<code>oracle_expr()</code>函数，从备注缓存中提取存储的值，并包含一个循环，该循环多次调用<code>expr()</code>函数，直到每个新结果都可与输入数据中比前一个部分更长的时间相媲美。 而且，当然，由于每个输入位置和每种解析方法都是分别缓存的，因此它不必担心回溯或一些递归规则（例如，在我使用的玩具语法中， <code>expr</code>和<code>term</code>都是递归的）。 </p><br><p> 我在第三部分中创建的原型的另一个优点是，它使得检查新结果是否比旧结果更容易： <code>mark()</code>方法返回输入令牌数组中的索引，因此我们可以使用它代替<code>parsed_length</code> 。 </p><br><p> 我忽略了无论语法多么疯狂，该算法为何始终有效的证明。 实际上，我什至没有看过。 我看到这适用于简单的情况，例如我的玩具语法中的<code>expr</code> ，以及更复杂的情况（例如，使用左递归隐藏在可选元素的后面，或者使用多个规则之间的相互递归）。 这个算法仍然可以解决我在Python语法中可以回忆到的最困难的情况，所以我只相信定理和证明它的人。 </p><br><p> 让我们编写战斗代码。 </p><br><p> 首先，解析器生成器必须确定哪些规则是递归的。 这是图论中已解决的问题。 我不会在这里展示该算法，实际上，我什至想进一步简化它。 我假设语法中唯一的左递归规则就是直接左递归，就像我们的玩具语法中的<code>expr</code>一样。 然后，要检查左递归性，您只需要查找一个以当前规则的名称开头的替代方法： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_left_recursive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rule)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> alt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rule.alts: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> alt[<span class="hljs-number"><span class="hljs-number">0</span></span>] == rule.name: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p> 现在，我们将更改解析器生成器，以便为左递归规则生成另一个装饰器。 回想一下，在第三部分中，我们将所有解析器方法包装在<code>@memoize</code> 。 现在，我们将对生成器进行一个小的更改，以便对于左递归规则，我们使用<code>@memoize_left_rec</code> ，然后在<code>memoize_left_rec</code>装饰器中实现魔术。 生成器的其余部分和其他代码无需更改！  （尽管我不得不修改可视化代码） </p><br><p> 作为参考，这是<code>@memoize</code>从第3部分复制而来的原始<code>@memoize</code>装饰器。请记住， <code>self</code>是一个具有<code>memo</code>属性（用空字典初始化）和<code>mark()</code>和<code>reset()</code>方法的获取和设置当前位置的<code>Parser</code>实例。标记器： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() memo = self.memos.get(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> memo <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: memo = self.memos[pos] = {} key = (func, args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memo: res, endpos = memo[key] self.reset(endpos) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: res = func(self, *args) endpos = self.mark() memo[key] = res, endpos <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memoize_wrapper</code> </pre> <br><p>  <code>@memoize</code>装饰器会记住先前对输入流中每个位置的调用-对于输入令牌的（懒散）数组中的每个位置，都有一个单独的<code>memo</code>字典。  <code>memoize_wrapper</code>的前四行专用于获取正确的<code>memo</code>字典。 </p><br><p> 这是<code>@memoize_left_rec</code> 。 只有<code>else</code>分支与上面<code>@memoize</code>的实现略有不同： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_left_rec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_left_rec_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() memo = self.memos.get(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> memo <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: memo = self.memos[pos] = {} key = (func, args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memo: res, endpos = memo[key] self.reset(endpos) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-comment"><span class="hljs-comment"># Prime the cache with a failure. memo[key] = lastres, lastpos = None, pos # Loop until no longer parse is obtained. while True: self.reset(pos) res = func(self, *args) endpos = self.mark() if endpos &lt;= lastpos: break memo[key] = lastres, lastpos = res, endpos res = lastres self.reset(lastpos) return res return memoize_left_rec_wrapper</span></span></code> </pre> <br><p> 这对于<code>expr()</code>方法的工作方式可能很有趣。 让我们看看下面的代码将如何执行： </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta"> @memoize_left_rec def expr(self): pos = self.mark() if ((expr := self.expr()) and self.expect('+') and (term := self.term())): return Node('expr', [expr, term]) self.reset(pos) if term := self.term(): return Node('term', [term]) self.reset(pos) return None</span></span></code> </pre> <br><p> 在解析<code>foo + bar + baz</code>的示例中。 </p><br><p> 每当您调用<code>expr()</code>函数时，装饰者都会“调用”该呼叫，该装饰者正在当前位置寻找上一个呼叫。 在第一次调用时，我们到达<code>else</code>分支，在这里我们反复调用装饰函数<code>expr()</code> 。 显然，我们将再次首先到达装饰器，但是这次缓存中已经有一些值，因此递归被中断了。 </p><br><p> 接下来会发生什么？ 初始缓存值是在以下行上计算的： </p><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment"># Prime the cache with a failure. memo[key] = lastres, lastpos = None, pos</span></span></code> </pre> <br><p> 这导致装饰的<code>expr()</code>返回<code>None</code> ，然后在<code>expr()</code>的第一个<code>if</code>下降（当<code>expr: = self.expr()</code> ）。 也就是说，我们继续第二个<code>if</code> ，它成功识别出该<code>term</code> （在我们的示例中为<code>'foo'</code> ），并且<code>expr</code>返回<code>Node</code>一个实例。 我们从哪里回来？ 到装饰器中的<code>while</code> 。 我们使用新结果（ <code>Node</code>实例）更新备忘录缓存，然后运行下一个迭代。 </p><br><p> 再次调用<code>expr()</code> ，这次拦截的递归调用返回<code>Node</code> （term）的缓存实例，然后继续进行<code>expect('+')</code>的调用<code>expect('+')</code> 。 一切都井井有条，因为我们现在是第一个<code>'+'</code>运算符。 之后，我们寻找一个也会成功的术语（找到<code>'bar'</code> ）。 </p><br><p> 因此，现在已经识别出<code>foo + bar</code> <code>expr()</code>返回<code>while</code> ，该<code>while</code>执行相同的操作：它使用新的（更长的）结果更新备注缓存，并开始下一次迭代。 </p><br><p> 再次重复该游戏。 再次，拦截的递归调用<code>expr()</code>从缓存中检索新结果（这次是<code>foo + bar</code> ），我们希望看到另一个<code>'+'</code> （第二个）和另一个<code>term</code> （ <code>'baz'</code> ）。 我们创建一个表示<code>(foo + bar) + baz</code>的<code>Node</code> ，将其返回到<code>while</code> ，将其放入缓存中并再次重复。 </p><br><p> 但是现在，我们将继续该算法的另一个分支。 我们希望遇到另一个<code>'+'</code> ，但找不到它！ 因此，对<code>expr()</code>此调用返回其第二个选择，并且仅返回<code>term</code> 。 当这在<code>while</code>之前弹出<code>while</code> ，表明结果比最后一个要短。 因此，它会中断并向发起<code>expr()</code>调用的用户返回更长的结果（ <code>(foo + bar) + baz</code> ）（例如，此处未显示<code>statement()</code>调用）。 </p><br><p> 因此，这就是今天的故事的结尾：我们在PEG解析器中成功实现了左递归。 下周，我计划讨论在语法中添加“动作”的方法，这将使我们能够自定义解析器方法针对此替代方法返回的结果（而不是始终返回<code>Node</code>实例）。 </p><br><p> 如果您想使用这些代码，请查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub存储库</a> 。  （我还为左递归添加了可视化代码，但我对此不太满意，因此在此不提供指向它的链接。） </p><br><p> 本文和引用代码的许可： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN471986/">https://habr.com/ru/post/zh-CN471986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN471974/index.html">两位船长如何成为将军：白色和红色</a></li>
<li><a href="../zh-CN471976/index.html">IT专家如何在国外找到工作？</a></li>
<li><a href="../zh-CN471978/index.html">我们不能相信仅基于深度学习的AI系统</a></li>
<li><a href="../zh-CN471980/index.html">电话骗子。 第四幕，决赛...</a></li>
<li><a href="../zh-CN471982/index.html">讨论PHP的未来</a></li>
<li><a href="../zh-CN471988/index.html">向PEG语法添加动作</a></li>
<li><a href="../zh-CN471990/index.html">PEG解析器的元语法</a></li>
<li><a href="../zh-CN471992/index.html">实施PEG的其余功能</a></li>
<li><a href="../zh-CN471994/index.html">在核心开发者Sprint上进行PEG工作</a></li>
<li><a href="../zh-CN471998/index.html">F＃10：列表</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>