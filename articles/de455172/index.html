<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵🏿 🧚🏿 ⏸️ Ausgewogene binäre Suchbäume: Implementierung auf Julia 💅🏻 👩🏼‍🚀 👨‍👩‍👧‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Illustration aus der Arbeit von G.M. Adelson-Welsky und E.M. Landis 1962 


 Suchbäume sind Datenstrukturen für die ordnungsgemäße Speicherung und ein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ausgewogene binäre Suchbäume: Implementierung auf Julia</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455172/"><p><img src="https://habrastorage.org/webt/5q/ek/4n/5qek4nssuu4dsjepoaa2g9tgmw0.png"><br>  <em>Illustration aus der Arbeit von G.M.</em>  <em>Adelson-Welsky und E.M.</em>  <em>Landis 1962</em> </p><br><p>  Suchbäume sind Datenstrukturen für die ordnungsgemäße Speicherung und einfache Suche nach Elementen.  <em>Binäre</em> Suchbäume sind weit verbreitet, bei denen jeder Knoten nur zwei untergeordnete Knoten hat.  In diesem Artikel betrachten wir zwei Methoden zum Organisieren von binären Suchbäumen: die Adelson-Welsky- und Landis-Algorithmen (AVL-Bäume) und geschwächte AVL-Bäume (WAVL-Bäume). </p><a name="habracut"></a><br><p>  Beginnen wir mit den Definitionen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Binärbaum</a> besteht aus <em>Knoten</em> , jeder Knoten speichert einen <em>Datensatz</em> in Form von <em>Schlüssel-Wert-</em> Paaren (oder im einfachen Fall nur Werten) und hat nicht mehr als zwei untergeordnete Knoten.  Nachkommenknoten werden durch <em>rechts</em> und <em>links unterschieden</em> , und die Bedingung für die Reihenfolge der Schlüssel ist erfüllt: Der Schlüssel des linken Nachkommen ist nicht mehr und der rechte ist nicht kleiner als der Schlüssel des übergeordneten Knotens.  Darüber hinaus können Dienstinformationen in Knoten gespeichert werden (und normalerweise in Knoten gespeichert werden) - beispielsweise eine Verknüpfung zum übergeordneten Knoten oder andere Daten.  Sonderfälle sind der <em>Stammknoten,</em> von dem aus der Baum eingegeben wird, und <em>ein leerer Knoten</em> , der keine Informationen speichert.  Knoten, in denen beide Nachkommen leer sind, werden Baumblätter genannt.  Ein Knoten mit allen Nachkommen bildet einen <em>Teilbaum</em> .  Somit ist jeder Knoten entweder die Wurzel eines Teilbaums oder eines Blattes. </p><br><p> Mit dieser Definition können Sie eine einfache Struktur zum Speichern von Knoten und des Baums selbst erstellen.  Wir nehmen an, dass ein leerer Knoten den speziellen Wert <code>nothing</code> Typ <code>Nothing</code> .  Dann reicht es aus, im Knoten Verweise auf den rechten und linken Nachwuchs sowie auf den Elternteil zu speichern.  Die Struktur zum Speichern des Baums enthält nur eine Verknüpfung zum Stammknoten. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># K -   # V -    mutable struct BSTNode{K, V} key::K value::V left::Union{Nothing, BSTNode{K,V}} right::Union{Nothing, BSTNode{K,V}} parent::BSTNode{K,V} end mutable struct BST{K, V} root::BSTNode{K,V} end</span></span></code> </pre> <br><p>  In diesem Fall stellt sich die Frage, wie ein leerer Baum dargestellt werden soll.  Dazu verwenden wir den Ansatz aus dem Buch "Algorithmen: Konstruktion und Analyse" und fügen als Eintrittspunkt in den Baum keine Wurzel, sondern einen Dummy-Knoten ein, der sein eigenes übergeordnetes Element sein wird.  Fügen Sie der BSTNode-Strukturbeschreibung Konstruktoren hinzu, um einen solchen Knoten zu erstellen: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">mutable struct</span></span> BSTNode{K, V} key::K value::V left::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing, BSTNode{K,V}} right::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing, BSTNode{K,V}} parent::BSTNode{K,V} <span class="hljs-comment"><span class="hljs-comment">#   function BSTNode{K,V}() where {K,V} node = new{K,V}() node.parent = node node.left = node.right = nothing return node end #    - function BSTNode{K,V}(key, value) where {K, V} node = new{K,V}() node.parent = node node.left = node.right = nothing node.key, node.value = key, value return node end end BSTNode() = BSTNode{Any, Any}() #     ! struct BST{K, V} entry::BSTNode{K,V} BST{K,V}() where {K,V} = new{K,V}(BSTNode{K,V}()) end BST() = BST{Any, Any}() Base.isempty(bst::BST) = bst.entry.left == nothing</span></span></code> </pre> <br><p>  In diesem Fall kann die <code>BST</code> Struktur unverändert gemacht werden, weil  Der Link zum Einstiegspunkt muss nicht mehr geändert werden.  Ferner nehmen wir an, dass der Wurzelknoten des Baums unmittelbar der rechte und linke Nachkomme des Eingabeknotens ist. </p><br><p>  Die Hauptoperation, für die Suchbäume benötigt werden, ist natürlich die Suche nach Elementen.  Da der Schlüssel des linken untergeordneten Elements nicht mehr und der rechte nicht kleiner als der übergeordnete Schlüssel ist, wird die Elementsuchprozedur sehr einfach geschrieben: Vergleichen Sie ausgehend von der Wurzel des Baums den Eingabeschlüssel mit dem Schlüssel des aktuellen Knotens;  Wenn die Schlüssel übereinstimmen, geben wir den Wert zurück. Andernfalls gehen Sie je nach Reihenfolge der Schlüssel zum linken oder rechten Teilbaum.  Wenn sie gleichzeitig einen leeren Knoten erreicht haben - es gibt keinen Schlüssel im Baum, lösen Sie eine Ausnahme aus. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#   Base.getindex()    #      tree[key] function Base.getindex(bst::BST{K,V}, key) where {K,V} key = convert(K, key) node = bst.entry.left while node != nothing key == node.key &amp;&amp; return node.value node = (key &lt; node.key ? node.left : node.right) end throw(KeyError(key)) end</span></span></code> </pre> <br><p>  Das Suchen nach einem Element mit einem Schlüssel dauert offensichtlich <em>O</em> ( <em>h</em> ) Zeit, wobei <em>h</em> die Höhe des Baums ist, d.h.  maximaler Abstand von Wurzel zu Blatt.  Es ist leicht zu berechnen, dass ein Binärbaum der Höhe <em>h</em> höchstens 2 <sup>h + 1</sup> -1 Knoten enthalten kann, wenn er <em>dicht besiedelt ist</em> , d. H.  Alle Knoten außer vielleicht der extremsten Schicht haben beide Nachkommen.  Darüber hinaus ist klar, dass jede gegebene Tastenfolge im Voraus zu einem so dichten Baum führen kann.  Dies ergibt ein sehr optimistisches asymptotisches Verhalten bei der Suche nach einem Element in einem Baum mit seiner optimalen Konstruktion in der Zeit <em>O</em> (log <sub>2</sub> <em>N</em> ), wobei <em>N</em> die Anzahl der Elemente ist. </p><br><p>  Natürlich muss der Algorithmus zum Hinzufügen eines Elements zum Suchbaum so konstruiert sein, dass die Bedingung für die Reihenfolge der Schlüssel erfüllt ist.  Schreiben wir eine naive Implementierung des Einfügens eines Elements per Schlüssel: </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#   Base.setindex!()    #       tree[key] = value function Base.setindex!(bst::BST{K,V}, val::SV, key::SK) where {K, V} key, value = convert(K, key), convert(V, val) parent = bst.entry.left #   -     if parent == nothing newnode.parent = bst.entry bst.entry.left = bst.entry.right = newnode return val end key_found = false while !key_found if key &lt; parent.key if parent.left == nothing parent.left = BSTNode{K,V}(key, value) parent.left.parent = parent key_found = true else parent = parent.left end elseif key &gt; parent.key if parent.right == nothing parent.right = BSTNode{K,V}(key, value) newnode.parent = parent key_found = true else parent = parent.right end else key_found = true parent.value = value end end return val end</span></span></code> </pre> <br><p>  Leider ergibt die naive Konstruktion des Baums die gewünschte Struktur nur bei zufälligen Eingabedaten, aber in Wirklichkeit sind sie oft recht strukturiert.  Im schlimmsten Fall, wenn die eingehenden Schlüssel streng geordnet sind (zumindest in aufsteigender, mindestens in absteigender Reihenfolge), sendet die naive Baumkonstruktion ständig neue Elemente in eine Richtung und sammelt tatsächlich eine lineare Liste.  Es ist leicht zu erraten, dass das Einfügen von Elementen, dass die Suche mit einer solchen Struktur während <em>O</em> ( <em>N</em> ) stattfinden wird, was alle Bemühungen zum Aufbau einer komplexen Datenstruktur zunichte macht. </p><br><p>  Schlussfolgerung: Der Suchbaum muss während der Erstellung <em>ausgeglichen</em> werden, d. H.  Richten Sie die Höhe des rechten und linken Teilbaums an jedem Knoten aus.  Es gibt verschiedene Ansätze zum Auswuchten.  Am einfachsten ist es, eine bestimmte Anzahl von Einfüge- oder Löschvorgängen anzugeben, nach denen der Baum neu ausgeglichen wird.  In diesem Fall befindet sich der Baum vor dem Auswuchten in einem eher "laufenden" Zustand, weshalb das Auswuchten im schlimmsten Fall etwa <em>0</em> ( <em>N</em> ) Zeit in Anspruch nimmt, aber nachfolgende Operationen bis zu einem bestimmten Einfüge- / Löschschwellenwert in logarithmischer Zeit ausgeführt werden.  Eine andere Möglichkeit besteht darin, die Einfüge- und Löschalgorithmen sofort so zu erstellen, dass der Baum immer ausgeglichen bleibt, was die <em>garantierte</em> Zeitkomplexität <em>O</em> (log <sub>2</sub> <em>N</em> ) für jede Operation ergibt. </p><br><p>  Aufgrund der Tatsache, dass es Algorithmen gibt, bei denen der Baum „wild werden“ darf, aber danach Operationen für eine ziemlich lange Zeit in einer logarithmischen Zeit ausgeführt werden können, bevor der Baum für eine lange Zeit wieder in einen ausgeglichenen Zustand gebracht werden muss, wird die <em>garantierte</em> und <em>amortisierte</em> Zeit des Einfügens / Löschens eines Elements unterschieden.  Bei einigen Implementierungen von Operationen mit binären Suchbäumen ist die Komplexität des Einfügens und Löschens von <em>O</em> (log <sub>2</sub> <em>N</em> ) garantiert, bei einigen wird es mit einer Verschlechterung auf <em>O</em> ( <em>N</em> ) abgeschrieben. </p><br><h3 id="algoritm-adelson-velskogo-i-landisa-avl">  Adelson-Welsky- und Landis-Algorithmus (AVL) </h3><br><p>  Die erste Implementierung eines selbstausgleichenden binären Suchbaums wurde 1962 von Adelson-Welsky und Landis vorgeschlagen.  In der modernen Literatur zu den Anfangsbuchstaben von Nachnamen wird diese Struktur als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AVL-Bäume bezeichnet</a> .  Die Struktur wird durch die folgenden Eigenschaften beschrieben: </p><br><ol><li>  Reihenfolge: Für jeden Knoten ist der Schlüssel oben im linken Teilbaum kleiner als der Schlüssel oben im rechten Teilbaum (wenn die Nachkommen keine leeren Knoten sind). </li><li>  Höhenerhöhung: Die Höhe des übergeordneten Knotens ist um eins höher als die maximale Höhe seiner Nachkommen.  Die Höhe der leeren Knoten kann als gleich Null betrachtet werden. </li><li>  AVL-Balance: Für jeden Knoten unterscheiden sich die Höhen der rechten und linken Teilbäume um nicht mehr als 1. </li></ol><br><p>  Aus diesen Eigenschaften folgt, dass die Höhe des gesamten Baums <em>O ist</em> (log <sub>2</sub> <em>N</em> ), wobei <em>N</em> die Anzahl der im Baum gespeicherten Datensätze ist, was bedeutet, dass der Datensatz in logarithmischer Zeit gesucht wird.  Damit der Zustand des ABL-Gleichgewichts nach jedem Einsetzen erhalten bleibt, wird jedes Einsetzen von einem <em>Ausgleichsvorgang</em> begleitet.  Für die effektive Implementierung dieser Operation muss jeder Knoten Dienstinformationen speichern.  Halten Sie der Einfachheit halber einfach die Höhe des Knotens dort. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">mutable struct</span></span> AVLNode{K,V} <span class="hljs-comment"><span class="hljs-comment"># ,       255 # (  10^38 ) height::UInt8 key::K value::V left::Union{Nothing, AVLNode{K,V}} right::Union{Nothing, AVLNode{K,V}} parent::AVLNode{K,V} #   function AVLNode{K,V}() where {K,V} node = new{K,V}() node.height = 1 node.parent = node node.left = node.right = nothing return node end #    - function AVLNode{K,V}(key::SK, value::SV) where {K, V, SK&lt;:K, SV&lt;:V} node = new{K,V}() node.height = 1 node.parent = node node.left = node.right = nothing node.key, node.value = key, value return node end end avlheight(node::Union{Nothing,AVLNode}) = node == nothing ? 0 : Int(node.height)</span></span></code> </pre> <br><h4 id="vstavka-zapisi">  Datensatz einfügen </h4><br><p>  Das grundlegende Einfügen erfolgt gemäß dem Standardalgorithmus. Gehen Sie den Baum nach unten, suchen Sie, wo Sie einen neuen Knoten einfügen und einfügen können.  Wir werden Wrapper schreiben, um untergeordnete Knoten mithilfe der Indizes -1 und 1 anstelle von links und rechts abzurufen und zu ersetzen: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> child(root::AVLNode, side::<span class="hljs-built_in"><span class="hljs-built_in">Signed</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> side == -<span class="hljs-number"><span class="hljs-number">1</span></span> root.left <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> side == <span class="hljs-number"><span class="hljs-number">1</span></span> root.right <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> throw(<span class="hljs-built_in"><span class="hljs-built_in">ArgumentError</span></span>(<span class="hljs-string"><span class="hljs-string">"Expecting side=-1 to get the left child or side=1 to get the right child"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> insert_child!(root::AVLNode{K,V}, newnode::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing,AVLNode{K,V}}, side::<span class="hljs-built_in"><span class="hljs-built_in">Signed</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {K,V} newnode == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> || (newnode.parent = root) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> side == -<span class="hljs-number"><span class="hljs-number">1</span></span> root.left = newnode <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> side == <span class="hljs-number"><span class="hljs-number">1</span></span> root.right = newnode <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> throw(<span class="hljs-built_in"><span class="hljs-built_in">ArgumentError</span></span>(<span class="hljs-string"><span class="hljs-string">"Expecting side=-1 for inserting node to the left or side=1 for inserting to the right"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Als nächstes gehen wir den Baum hinauf und suchen nach Verstößen gegen die Bedingungen 2 und 3. Als nächstes betrachten wir die Optionen, die möglicherweise angezeigt werden (in den Abbildungen zeigt Grün den Knoten an, der die Höhe geändert hat, der Knoten, der verarbeitet wird, ist sein übergeordneter Knoten). </p><br><p>  <strong>Fall 0</strong> <br>  Nach dem Einfügen wurde die Höhe des Knotens dieselbe wie die der Schwester und 1 kleiner als die (alte) Höhe des übergeordneten Knotens. </p><br><p><img src="https://habrastorage.org/webt/uf/9_/iq/uf9_iqcs1ydiwszzfl8ub8dbxj8.png"></p><br><p>  Im besten Fall müssen Sie nichts weiter berühren.  Auch oben kann man da nicht mehr gucken  dort wird sich nichts ändern. </p><br><p>  <strong>Fall 1</strong> <br>  Vor dem Einsetzen war die Höhe des Knotens gleich der Höhe des Schwesterknotens.  Durch das Einfügen wird die Wurzel des Teilbaums angehoben und die Höhe des Knotens mit der Höhe des übergeordneten Knotens verglichen. </p><br><p><img src="https://habrastorage.org/webt/s4/nv/t4/s4nvt4y-m1znfln4g4ajf2346d0.png"></p><br><p>  In diesem Fall reicht es aus, den übergeordneten Knoten zu „erhöhen“ und seine Höhe um 1 zu erhöhen. Gleichzeitig müssen Sie weiter zur Wurzel des Baums wechseln, da eine Änderung der Höhe des übergeordneten Knotens zu einer Verletzung von Bedingung 2 führen kann, die eine Ebene höher liegt. </p><br><p><img src="https://habrastorage.org/webt/v-/j9/0s/v-j90s0nar7w4mgas4oujggl3h8.png"></p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="julia hljs">fucntion promote!(nd::AVLNode, by::<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span>) nd.height += by <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> fucntion demote!(nd::AVLNode, by::<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span>) nd.height -= by <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>  <strong>Fall 2</strong> </p><br><p>  Nach dem Einfügen wurde der Höhenunterschied zum Schwester-Teilbaum 2, und der linke Teilbaum wurde nach oben „gedrückt“: </p><br><p><img src="https://habrastorage.org/webt/la/bl/aj/lablajxlzp2lgvbhm4nlh5j-3ks.png"></p><br><p>  Das Problem wird mit einer Operation behandelt, die als "einfache Drehung" bezeichnet wird und den Baum wie folgt transformiert: </p><br><p><img src="https://habrastorage.org/webt/8j/zc/yt/8jzcytyqgke3xpcikei8zrbvbrq.png"></p><br><p>  Eine einfache Drehung erfordert 6 Zeigerwechsel. </p><br><p>  Beachten Sie, dass bei der Projektion auf die horizontale Achse die Reihenfolge der Eckpunkte <em>n</em> , <em>p</em> und der Bäume <em>T</em> <sub>1</sub> - <em>T</em> <sub>3</sub> vor und nach der Drehung gleich bleibt.  Dies ist die Erfüllung der Bestellbedingung.  Wie Sie sehen, ist nach dem Aufdrehen des Baumes kein Ausgleich mehr erforderlich. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># pivot       function rotate!(pivot::AVLNode, dir::Signed) dir in (-1, 1) || throw(ArgumentError("Unknown rotation direction")) p = pivot.parent g = p.parent p.height = avlheight(child(pivot, dir)) + 1 pivot.height = p.height + 1 # "" pivot  g pivot.parent = g g.left === p &amp;&amp; (g.left = pivot) g.right === p &amp;&amp; (g.right = pivot) c = child(pivot, dir) #  c  p insert_child!(p, c, -dir) #  p  pivot insert_child!(pivot, p, dir) pivot end</span></span></code> </pre> </div></div><br><p>  <strong>Fall 3</strong> <br>  Nach dem Einfügen wurde der Höhenunterschied zum Schwester-Teilbaum 2 und der rechte Teilbaum "hochgeschoben": </p><br><p><img src="https://habrastorage.org/webt/cs/el/1u/csel1u39enlepfhdrc4bdw_legq.png"></p><br><p>  In diesem Fall hilft eine einzelne einfache Kurve nicht mehr, aber Sie können eine einfache Linkskurve um den rechten Nachkommen machen, was zu Fall 2 führt, der bereits mit einer einfachen Rechtskurve behandelt wird. </p><br><p>  Um die Anzahl der "Übergewichtungen" von Knoten zu verringern, können zwei Windungen zu einer Operation kombiniert werden, die als große oder doppelte Windung bezeichnet wird.  Anstelle von 12 Zeigeränderungen werden dann nur 10 benötigt. Als Ergebnis einer doppelten Drehung nimmt der Baum die folgende Form an: </p><br><p><img src="https://habrastorage.org/webt/ub/ds/7i/ubds7iawqzg9uqgned3mxiqs_8m.png"></p><br><p>  Wie Sie sehen, ist nach einer doppelten Umdrehung auch kein weiterer Ausgleich des Baumes erforderlich. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># pivot       funtion double_rotate!(pivot::AVLNode, dir::Signed) dir in (-1, 1) || throw(ArgumentError("Unknown rotation direction")) n = pivot.parent p = n.parent g = p.parent pivot.height = n.height n.height = p.height = pivot.height - 1 # "" pivot  g pivot.parent = g g.left === p &amp;&amp; (g.left = pivot) g.right === p &amp;&amp; (g.right = pivot) t2, t3 = child(pivot, -dir), child(pivot, dir) #  n  pivot  t2  n insert_child!(n, t2, dir) insert_child!(pivot, n, -dir) #  p  pivot  t3  p insert_child!(p, t3, -dir) insert_child!(pivot, p, dir) pivot end</span></span></code> </pre> </div></div><br><p>  Wenn Sie also einen Datensatz in den AVL-Baum einfügen, benötigen Sie <em>O</em> (log <sub>2</sub> <em>N</em> ) Änderungen in den Informationen über die Höhe der Knoten und nicht mehr als zwei Rotationsvorgänge.  Kombinieren Sie alles zu einer Einfügefunktion.  Sie unterscheidet sich von der Grundeinfügung nur dadurch, dass nach dem Einfügen eines neuen Knotens die Funktion <code>fix_insertion!()</code> wird, die vom neu eingefügten Knoten zur Wurzel übergeht, das Gleichgewicht überprüft und gegebenenfalls korrigiert. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.setindex!(avlt::AVLTree{K,V}, val, key) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {K,V} key, value = convert(K, key), convert(V, val) parent = avlt.entry.left <span class="hljs-comment"><span class="hljs-comment">#   -     if parent == nothing newnode = AVLNode{K,V}(key, value) newnode.parent = avlt.entry avlt.entry.left = avlt.entry.right = newnode return val end key_found = false while !key_found key_found = key == parent.key if key_found parent.value = value else side = (key &gt; parent.key) * 2 - 1 # true == 1, false == 0 next = child(parent, side) if next == nothing newnode = AVLNode{K,V}(key, value) insert_child!(parent, newnode, side) fix_insertion!(newnode) key_found = true else parent = next end end end return val end</span></span></code> </pre> <br><p>  Die Funktion <code>fix_insertion!()</code> Überprüft den Höhenunterschied zwischen zwei <code>fix_insertion!()</code> Knoten, beginnend mit dem übergeordneten Knoten und dem eingefügten.  Wenn es gleich 1 ist - wir sind in Fall 1, müssen Sie die Höhe des Knotens erhöhen und höher gehen.  Wenn es Null ist, ist der Baum ausgeglichen.  Wenn es gleich 2 ist - dies ist Fall 2 oder 3 - müssen Sie die entsprechende Drehung anwenden, und der Baum wird in einen ausgeglichenen Zustand versetzt. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#     -  , #   -  imbalance(node::AVLNode) = avlheight(node.right) - avlheight(node.left) function fix_insertion!(start::AVLNode) node = start.parent skew = imbalance(node) #      0 - ..        while abs(skew) == 1 node.height += 1 node = node.parent skew = imbalance(node) end @assert abs(skew) == 2 || skew == 0 if skew != 0 #       , # ..   dir = -skew ÷ 2 n = child(node, -dir) prev_skew = imbalance(n) @assert abs(prev_skew) == 1 if prev_skew == dir double_rotate!(child(n, dir), dir) else rotate!(n, dir) end end end</span></span></code> </pre> <br><h4 id="udalenie-zapisi">  Datensatz löschen </h4><br><p>  Das Entfernen ist etwas schwieriger als das Einsetzen. </p><br><p>  Betrachten Sie zunächst das übliche Löschen eines Eintrags aus einem binären Suchbaum. </p><br><ol><li>  Befindet sich der gelöschte Datensatz im Blatt, wird der Datensatz einfach gelöscht, hier ist alles einfach. </li><li>  Befindet sich der gelöschte Datensatz in einem Knoten mit nur einem Nachkommen, wird dieser Nachkomme zusammen mit seinem gesamten Teilbaum an die Stelle des Remote-Knotens gesetzt. </li><li>  Wenn zwei Nachkommen vorhanden sind, wird entweder das maximale Element im linken Teilbaum oder das minimale Element im rechten Teilbaum aus dem Baum extrahiert (durch die Eigenschaft des Suchbaums wird garantiert, dass der Knoten mit dem maximalen Element keinen rechten Nachkommen hat, und mit einem minimalen Element nach links, sodass das Löschen einfach ist) und anstelle des gelöschten Datensatzes setzen. </li></ol><br><p>  Danach kann das Baumgleichgewicht jedoch gestört sein. Sie müssen daher vom übergeordneten Knoten des Remote-Knotens aufsteigen und ihn wiederherstellen.  Beachten Sie, dass zu Beginn garantiert ist, dass einer der Nachkommen des betreffenden Elternteils die Höhe um 1 verringert hat. Vor diesem Hintergrund müssen Sie die Optionen berücksichtigen (die Knoten, die die Höhe geändert haben, werden rot angezeigt, der verarbeitete Knoten ist der Elternteil von rot): </p><br><p>  <strong>Fall 1</strong> <br>  Kein Ungleichgewicht.  Vor dem Entfernen war es also 1 Modulo, und jetzt sind die untergeordneten Knoten 2 niedriger als die übergeordneten. </p><br><p><img src="https://habrastorage.org/webt/mo/cm/a_/mocma_jzetjrizjwiesbdtx1rtu.png"></p><br><p>  Sie müssen den übergeordneten Knoten um 1 senken und weiter nach oben gehen. </p><br><p><img src="https://habrastorage.org/webt/j8/6y/yi/j86yyi7cxkzasggld6pzo9fldwu.png"></p><br><p>  <strong>Fall 2</strong> <br>  Ungleichgewicht 1 Modulo. </p><br><p><img src="https://habrastorage.org/webt/hn/8v/cx/hn8vcxpvolbjnafm9h3u08kpnoo.png"></p><br><p>  Wenn die AVL-Bedingung erfüllt ist, können Sie aufhören. </p><br><p>  <strong>Fall 3</strong> <br>  Das Ungleichgewicht 2 ist modulo, der Schwesterknoten zum absteigenden Knoten hat ein Ungleichgewicht ungleich Null. </p><br><p><img src="https://habrastorage.org/webt/vr/_f/jc/vr_fjcvwl3zxc6ocy622l2sszrw.png"></p><br><p>  Wir stellen das Gleichgewicht durch einfaches (wenn T <sub>1</sub> niedriger als T <sub>2 ist</sub> ) oder durch doppelte (ansonsten) Drehung wieder her, wie dies beim Einsetzen geschehen ist.  Die Höhe des Teilbaums nimmt ab, d.h.  Über dem Baum kann eine Verletzung auftreten. </p><br><p><img src="https://habrastorage.org/webt/h9/5f/qx/h95fqxdbbqukr_eyjbhbjyyoju4.png"></p><br><p>  <strong>Fall 4</strong> <br>  Ungleichgewicht 2 Modulo, der Schwesterknoten hat kein Ungleichgewicht. </p><br><p><img src="https://habrastorage.org/webt/o6/rl/mq/o6rlmq62rxnxxyh6knsz3xne4te.png"></p><br><p>  Eine einfache Drehung stellt den Ausgleichszustand wieder her, während sich die Höhe des Teilbaums nicht ändert - wir hören auf, uns nach oben zu bewegen. </p><br><p><img src="https://habrastorage.org/webt/sw/c-/d5/swc-d56rswsunltv7_3g60tvufq.png"></p><br><div class="spoiler">  <b class="spoiler_title">Code zum Entfernen von Schlüsseln</b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> next_node(node::AVLNode) next = node.right <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> p = node.parent next = p.parent <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next !== p) &amp;&amp; (next.key &lt; p.key) p, next = next, next.parent <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (next === p ? <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> : next) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> next.left != <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> next = next.left <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.delete!(avlt::AVLTree{K,V}, key) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {K,V} key = convert(K, key) candidate = avlt.entry.left dir = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> candidate.key != key dir = <span class="hljs-number"><span class="hljs-number">2</span></span> * (key &gt; candidate.key) - <span class="hljs-number"><span class="hljs-number">1</span></span> candidate = child(candidate, dir) candidate == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> val = candidate.value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> side <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> child(candidate, side) == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> p, s = candidate.parent, child(candidate, -side) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p === p.parent insert_child!(p, s, <span class="hljs-number"><span class="hljs-number">1</span></span>) insert_child!(p, s, -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insert_child!(p, s, dir) fix_deletion!(p) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> swap = next_node(candidate) cp, sp, sr = candidate.parent, swap.parent, swap.right swap.height = candidate.height insert_child!(swap, candidate.left, -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> side <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) child(cp, side) === candidate &amp;&amp; insert_child!(cp, swap, side) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sp === candidate fix_deletion!(swap) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insert_child!(swap, candidate.right, <span class="hljs-number"><span class="hljs-number">1</span></span>) insert_child!(sp, sr, -<span class="hljs-number"><span class="hljs-number">1</span></span>) fix_deletion!(sp) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> fix_deletion!(start::AVLNode) node = start skew = imbalance(node) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (node !== node.parent) &amp;&amp; (abs(skew) != <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> skew != <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-meta"><span class="hljs-meta">@assert</span></span> abs(skew) == <span class="hljs-number"><span class="hljs-number">2</span></span> dir = -skew ÷ <span class="hljs-number"><span class="hljs-number">2</span></span> n = child(node, -dir) prev_skew = imbalance(n) <span class="hljs-meta"><span class="hljs-meta">@assert</span></span> abs(prev_skew) &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> prev_skew == dir node = double_rotate!(child(n, dir), dir) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> node = rotate!(n, dir) prev_skew != <span class="hljs-number"><span class="hljs-number">0</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> node.height -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> node = node.parent skew = imbalance(node) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><h3 id="vzlyot-i-padenie-avl-derevev">  Aufstieg und Fall von AVL-Bäumen </h3><br><p>  Ein nicht sehr schönes Merkmal klassischer AVL-Bäume ist die Schwierigkeit, einen Datensatz zu löschen:  Eine Rotation kann den gesamten Teilbaum um eine Ebene nach unten "zurücksetzen". Im schlimmsten Fall erfordert das Löschen <em>O</em> (log <sub>2</sub> <em>N</em> ) <code>fix_deletion!()</code> - jedes Mal, wenn Sie in <code>fix_deletion!()</code> um eine Ebene nach <code>fix_deletion!()</code> . </p><br><p>  Aufgrund dieses nicht so guten asymptotischen Verhaltens wichen AVL-Bäume rot-schwarzen Bäumen, die in den 1970er Jahren auftauchten und einen schwächeren Ausgleichszustand aufwiesen - der Weg von der Wurzel zum am weitesten entfernten Blatt ist nicht mehr als doppelt so lang wie der Weg von der Wurzel zum nächsten Blatt.  Aus diesem Grund beträgt die Höhe von rot-schwarzen Bäumen im schlimmsten Fall <sub>2</sub> log <sub>2</sub> <em>N</em> gegenüber 1,44 log <sub>2</sub> <em>N</em> für AVL-Bäume. Das Löschen eines Datensatzes erfordert jedoch nicht mehr als drei einfache Umdrehungen.  Daher verlieren Suche und Einfügung aufgrund einer höheren Baumhöhe möglicherweise an Leistung, aber es gibt einen potenziellen Gewinn, wenn Einfügungen häufig mit Löschungen durchsetzt sind. </p><br><h3 id="avl-nanosyat-otvetnyy-udar">  AVL schlägt zurück </h3><br><p>  Es stellt sich heraus, dass der „ideale“ Algorithmus zum Erstellen von binären Suchbäumen eine geringe Höhe (auf der Ebene des klassischen AVL-Baums) und eine konstante Anzahl von Umdrehungen sowohl beim Hinzufügen als auch beim Löschen eines Datensatzes gewährleisten sollte.  Dies wurde noch nicht erfunden, aber 2015 wurde eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeit</a> veröffentlicht, die eine Struktur vorschlug, die die Eigenschaften von AVL- und rot-schwarzen Bäumen verbessert.  Die Idee liegt näher an den AVL-Bäumen, aber die Balance-Bedingung wird gelockert, um ein effizienteres Löschen von Datensätzen zu ermöglichen.  Die Eigenschaften einer Struktur, die als "schwacher AVL-Baum" (W (eak) AVL-Baum) bezeichnet wird, werden wie folgt formuliert: </p><br><ol><li>  Reihenfolge: Für jeden Knoten ist der Schlüssel oben im linken Teilbaum kleiner als der Schlüssel oben im rechten Teilbaum (wenn die Nachkommen keine leeren Knoten sind). </li><li>  Aufsteigender Rang.  Jedem Knoten wird ein Rang zugewiesen.  Der Rang aller leeren Knoten ist Null, der Rang der Blätter ist 1. Der Rang des Elternknotens ist streng höher als der Rang des Kindes. </li><li>  Schwaches ABL-Gleichgewicht: Der Rang eines Knotens unterscheidet sich vom Rang der untergeordneten Knoten um nicht mehr als 2. </li></ol><br><p>  Es stellt sich heraus, dass eine solche Struktur die Eigenschaften sowohl klassischer AVL-Bäume als auch rot-schwarzer Bäume umfasst.  Insbesondere wenn wir die Bedingung einführen, dass sich <em>beide</em> untergeordneten Knoten im Rang nicht um 2 vom übergeordneten Knoten unterscheiden können, erhalten wir einen regulären AVL-Baum, und der Rang entspricht genau der Höhe des Teilbaums. </p><br><p>  Das Schöne an SAVL-Bäumen ist, dass durch eine leichte Abschwächung des AVL-Zustands der Baum ausgeglichen werden kann, wenn ein Datensatz um nicht mehr als zwei Umdrehungen gelöscht wird!  Die Baumhöhenschätzung ist h &lt;min (1,44 log <sub>2</sub> <em>M</em> , <sub>2</sub> log <sub>2</sub> <em>N</em> ), wobei <em>N</em> die Anzahl der Einträge im Baum ist, <em>M</em> die Anzahl der Einfügungen ist, verglichen mit h &lt; <sub>2</sub> log <sub>2</sub> <em>N</em> für rot-schwarze Bäume.  ,  -   ,       ,      . </p><br><p>  -             ,          .  -        . </p><br><h4 id="struktura-hraneniya">  . </h4><br><p>     -,  ""    "".  ,   : </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">mutable struct</span></span> WAVLNode rank::<span class="hljs-built_in"><span class="hljs-built_in">UInt8</span></span> key::K value::V left::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing, WAVLNode{K,V}} right::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing, WAVLNode{K,V}} parent::WAVLNode{K,V} <span class="hljs-comment"><span class="hljs-comment">#   function WAVLNode{K,V}() where {K,V} node = new{K,V}() node.rank = 1 node.parent = node node.left = node.right = nothing return node end #    - function WAVLNode{K,V}(key, value) where {K,V} key, value = convert(K, key), convert(V, value) node = new{K,V}() node.rank = 1 node.parent = node node.left = node.right = nothing node.key, node.value = key, value return node end end struct WAVLTree{K, V} entry::WAVLNode{K,V} WAVLTree{K,V}() where {K,V} = new{K,V}(WAVLNode{K,V}()) end function child(root::WAVLNode, side::Signed) if side == -1 root.left elseif side == 1 root.right else throw(ArgumentError("Expecting side=-1 to get the left child or side=1 to get the right child")) end end function Base.getindex(avlt::WAVLTree{K,V}, key) where {K,V} key = convert(K, key) node = avlt.entry.left while node != nothing key == node.key &amp;&amp; return node.value node = (key &lt; node.key ? node.left : node.right) end throw(KeyError(key)) end</span></span></code> </pre> <br><h4 id="vstavka-zapisi-1">   </h4><br><p>    ,     -.  :      1    ,      —      ,          0 (  )  1 (    ).      <code>imbalance()</code> ,     ,  . </p><br><pre> <code class="julia hljs">wavlrank(node::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing,WAVLNode}) = node == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>(node.rank) <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> imbalance(node::WAVLNode) rr, lr = wavlrank(node.right), wavlrank(node.left) skew = rr - lr diff = node.rank - max(rr, lr) skew, diff <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>    ,           .  ,  ,    ,    ,    -,   - . </p><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># pivot       function rotate!(pivot::AVLNode, dir::Signed) dir in (-1, 1) || throw(ArgumentError("Unknown rotation direction")) p = pivot.parent g = p.parent p.height = avlheight(child(pivot, dir)) + 1 pivot.height = p.height + 1 # "" pivot  g pivot.parent = g g.left === p &amp;&amp; (g.left = pivot) g.right === p &amp;&amp; (g.right = pivot) c = child(pivot, dir) #  c  p insert_child!(p, c, -dir) #  p  pivot insert_child!(pivot, p, dir) pivot end # pivot       function double_rotate!(pivot::AVLNode, dir::Signed) dir in (-1, 1) || throw(ArgumentError("Unknown rotation direction")) n = pivot.parent p = n.parent g = p.parent pivot.height = n.height n.height = p.height = pivot.height - 1 # "" pivot  g pivot.parent = g g.left === p &amp;&amp; (g.left = pivot) g.right === p &amp;&amp; (g.right = pivot) t2, t3 = child(pivot, -dir), child(pivot, dir) #  n  pivot  t2  n insert_child!(n, t2, dir) insert_child!(pivot, n, -dir) #  p  pivot  t3  p insert_child!(p, t3, -dir) insert_child!(pivot, p, dir) pivot end imbalance(node::AVLNode) = avlheight(node.right) - avlheight(node.left) function fix_insertion!(start::AVLNode) node = start.parent skew = imbalance(node) while abs(skew) == 1 node.height += 1 node = node.parent skew = imbalance(node) end @assert abs(skew) == 2 || skew == 0 if skew != 0 dir = -skew ÷ 2 n = child(node, -dir) prev_skew = imbalance(n) @assert abs(prev_skew) == 1 if prev_skew == dir double_rotate!(child(n, dir), dir) else rotate!(n, dir) end end end function Base.setindex!(avlt::AVLTree{K,V}, val, key) where {K,V} key, value = convert(K, key), convert(V, val) parent = avlt.entry.left #   -     if parent == nothing newnode = AVLNode{K,V}(key, value) newnode.parent = avlt.entry avlt.entry.left = avlt.entry.right = newnode return val end key_found = false while !key_found key_found = key == parent.key if key_found parent.value = value else side = (key &gt; parent.key) * 2 - 1 next = child(parent, side) if next == nothing newnode = AVLNode{K,V}(key, value) insert_child!(parent, newnode, side) fix_insertion!(newnode) key_found = true else parent = next end end end return val end</span></span></code> </pre> </div></div><br><h4 id="udalenie-zapisi-1">   </h4><br><p>    ,     —    -.        . </p><br><p> <strong> 0</strong> <br>       , ..: </p><br><ol><li>  1,     1   </li><li>  0,    2  ,     . <br>    . </li></ol><br><p> <strong> 1</strong> <br>     2 ( 0,   2   ). <br>    1   . </p><br><p> <strong> 2</strong> <br>  1,     2. </p><br><p><img src="https://habrastorage.org/webt/q0/gq/3h/q0gq3hi6g7k8modechdmavys-to.png"></p><br><p>      1,  . </p><br><p><img src="https://habrastorage.org/webt/28/ss/oc/28ssoc1ki3flzroiinnigcsguhg.png"></p><br><p> <strong> 3</strong> <br>  2 (     1, ..          ),         2  . </p><br><p><img src="https://habrastorage.org/webt/oi/tl/qd/oitlqdhhc83lttdsw6s0az_kr5y.png"></p><br><p>       ,    .  . </p><br><p><img src="https://habrastorage.org/webt/st/pn/se/stpnsenr-ygtamabscwra_yd2dy.png"></p><br><p> <strong> 4</strong> <br><img src="https://habrastorage.org/webt/fp/l-/h1/fpl-h1yg-9gl3wrucoiq-lhefwq.png"></p><br><p>   . </p><br><p><img src="https://habrastorage.org/webt/s3/qy/0u/s3qy0uwfz87t5uroqynp4rvchwi.png"></p><br><p>  ,          ,      , ..      . </p><br><p>   —   T <sub>1</sub>  T <sub>2</sub>  ,  <em>p</em>     2,    <em>p</em>     1. </p><br><p> <strong> 5</strong> <br><img src="https://habrastorage.org/webt/5m/pn/sb/5mpnsb8edlrtcazgox852h6rrsm.png"></p><br><p>   . </p><br><p><img src="https://habrastorage.org/webt/im/vt/7c/imvt7cnylf5_dja5jc6xx9km-xo.png"></p><br><p> ,    ,      . </p><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> next_node(node::WAVLNode) next = node.right <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> p = node.parent next = p.parent <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next !== p) &amp;&amp; (next.key &lt; p.key) p, next = next, next.parent <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (next === p ? <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> : next) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> next.left != <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> next = next.left <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.delete!(avlt::WAVLTree{K,V}, key) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {K,V} key = convert(K, key) candidate = avlt.entry.left dir = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> candidate.key != key dir = <span class="hljs-number"><span class="hljs-number">2</span></span> * (key &gt; candidate.key) - <span class="hljs-number"><span class="hljs-number">1</span></span> candidate = child(candidate, dir) candidate == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> val = candidate.value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> side <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> child(candidate, side) == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> p, s = candidate.parent, child(candidate, -side) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p === p.parent insert_child!(p, s, <span class="hljs-number"><span class="hljs-number">1</span></span>) insert_child!(p, s, -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insert_child!(p, s, dir) fix_deletion!(p) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> swap = next_node(candidate) cp, sp, sr = candidate.parent, swap.parent, swap.right swap.height = candidate.height insert_child!(swap, candidate.left, -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> side <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) child(cp, side) === candidate &amp;&amp; insert_child!(cp, swap, side) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sp === candidate fix_deletion!(swap) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insert_child!(swap, candidate.right, <span class="hljs-number"><span class="hljs-number">1</span></span>) insert_child!(sp, sr, -<span class="hljs-number"><span class="hljs-number">1</span></span>) fix_deletion!(sp) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> fix_deletion!(start::WAVLNode) node = start skew, diff = imbalance(node) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (node !== node.parent) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> skew == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.right == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> node.rank = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> abs(skew) == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> diff == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> node.rank -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> dir = -skew ÷ <span class="hljs-number"><span class="hljs-number">2</span></span> n = child(node, -dir) prev_skew, prev_diff = imbalance(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> prev_diff == <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-meta"><span class="hljs-meta">@assert</span></span> prev_skew == <span class="hljs-number"><span class="hljs-number">0</span></span> n.rank -= <span class="hljs-number"><span class="hljs-number">1</span></span> node.rank -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> prev_skew == dir double_rotate!(child(n, dir), dir) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> rotate!(n, dir) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> node = node.parent skew, diff = imbalance(node) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>      -. </p><br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wavl = WAVLTree{<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>}() julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> avl = AVLTree{<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>}() julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dd = <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>}() julia&gt; x = trues(<span class="hljs-number"><span class="hljs-number">1_000_000</span></span>) <span class="hljs-comment"><span class="hljs-comment">#       ~  julia&gt; for i = 1:1_000_000; dd[i] = avl[i] = wavl[i] = i * i; end julia&gt; for i=1:500_000 k = rand(1:1_000_000) x[k] = false delete!(avl, k) delete!(wavl, k) delete!(dd, k) end # ,     julia&gt; const y = Int[] julia&gt; for i in eachindex(x); if x[i] push!(y, i); end; end julia&gt; @btime let s = 0.0; for idx in y; s += dd[idx]; end; s; end 57.626 ms (0 allocations: 0 bytes) 2.0238199367708794e17 julia&gt; @btime let s = 0.0; for idx in y; s += wavl[idx]; end; s; end 57.796 ms (0 allocations: 0 bytes) 2.0238199367708794e17 julia&gt; @btime let s = 0.0; for idx in y; s += avl[idx]; end; s; end 53.884 ms (0 allocations: 0 bytes) 2.0238199367708794e17</span></span></code> </pre> <br><p> ,        ,    . , ,   -    ,   -,    . </p><br><h3 id="primenenie-derevev-poiska">    </h3><br><p>    —   ? <br>   —   ,   . ,   ,  . </p><br><p>           . </p><br><h4 id="uporyadochennoe-mnozhestvo">   </h4><br><p>    —   ,           .      <em>n</em> -   . ,     , ..  ,       . </p><br><div class="scrollable-table"><table><thead><tr><th>  Bedienung </th><th>   </th><th>   </th></tr></thead><tbody><tr><td>    </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>  Einfügen </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>  </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td> <em>n</em> -  </td><td> <em>O</em> (log <em>N</em> )* </td><td> <em>O</em> (1) </td></tr></tbody></table></div><br><p> *         </p><br><h4 id="associativnyy-massiv">   </h4><br><p>   —   ,      "   ", "    ", "  -", " ".    ,      ,        -.      .   ,          . </p><br><div class="scrollable-table"><table><thead><tr><th>  Bedienung </th><th>   </th><th> - </th><th>  Liste </th><th>   </th></tr></thead><tbody><tr><td>  Suche </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (1)* </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td></tr><tr><td>  Einfügen </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (1)* </td><td> <em>O</em> (1) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>  </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (1)* </td><td> <em>O</em> ( <em>N</em> )** </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>    </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td></tr></tbody></table></div><br><p> *    <br> **     <em>O</em> (1),     ... </p><br><h4 id="ochered-s-prioritetami">    </h4><br><p>    ,       " — ".      ,    .   —     ( ) ,       ,  ,   .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . </p><br><div class="scrollable-table"><table><thead><tr><th>  Bedienung </th><th>   </th><th>   </th><th>  Liste </th><th>  / </th></tr></thead><tbody><tr><td>   </td><td> <em>O</em> (1)* </td><td> <em>O</em> (1) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> (1) </td></tr><tr><td>   </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> (1)** </td></tr><tr><td>   </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (1) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>   </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td></tr></tbody></table></div><br><p> *        <br> **  ,       </p><br><h3 id="vyvod">  </h3><br><p> ()    —       ,   , ,   , ,    .      —     , ..  ,         ,   . </p><br><h2 id="ssylki">  Referenzen </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"-"</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">nickme</a> </li><li> Rank-Balanced Trees by Bernhard Haeupler, Siddhartha Sen, Robert E. Tarjan // ACM Transactions on Algorithms | June 2015, Vol 11(4) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pdf</a> </li><li> Goodrich MT, Tamassia R. Algorithm Design and Applications </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455172/">https://habr.com/ru/post/de455172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455160/index.html">Entity Framework 6 mit Volltextsuche über LINQ</a></li>
<li><a href="../de455164/index.html">Elena Balashova: „Aktivisten haben die Frage aufgeworfen, dass die Daten unseres GIS-Portals für OpenStreetMap offen sein sollten.“</a></li>
<li><a href="../de455166/index.html">VPN auf dem Beeline-Router zur Umgehung von Sperren</a></li>
<li><a href="../de455168/index.html">492-Byte-Demo auf ATtiny5</a></li>
<li><a href="../de455170/index.html">Neue Architektur für den Bytezugriff auf SSD - wie es funktioniert</a></li>
<li><a href="../de455176/index.html">Ist es ohne Redux möglich?</a></li>
<li><a href="../de455178/index.html">Fang mich, wenn du kannst. Director-Version</a></li>
<li><a href="../de455184/index.html">250 US-Dollar 3D-Drucker in Raumgröße</a></li>
<li><a href="../de455186/index.html">MIT 3D-Drucker: Bis zu 10 Materialien pro Modell</a></li>
<li><a href="../de455190/index.html">3D-Druck von Herzmuskelzellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>