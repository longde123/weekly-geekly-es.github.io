<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïµüèø üßöüèø ‚è∏Ô∏è Ausgewogene bin√§re Suchb√§ume: Implementierung auf Julia üíÖüèª üë©üèº‚ÄçüöÄ üë®‚Äçüë©‚Äçüëß‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Illustration aus der Arbeit von G.M. Adelson-Welsky und E.M. Landis 1962 


 Suchb√§ume sind Datenstrukturen f√ºr die ordnungsgem√§√üe Speicherung und ein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ausgewogene bin√§re Suchb√§ume: Implementierung auf Julia</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455172/"><p><img src="https://habrastorage.org/webt/5q/ek/4n/5qek4nssuu4dsjepoaa2g9tgmw0.png"><br>  <em>Illustration aus der Arbeit von G.M.</em>  <em>Adelson-Welsky und E.M.</em>  <em>Landis 1962</em> </p><br><p>  Suchb√§ume sind Datenstrukturen f√ºr die ordnungsgem√§√üe Speicherung und einfache Suche nach Elementen.  <em>Bin√§re</em> Suchb√§ume sind weit verbreitet, bei denen jeder Knoten nur zwei untergeordnete Knoten hat.  In diesem Artikel betrachten wir zwei Methoden zum Organisieren von bin√§ren Suchb√§umen: die Adelson-Welsky- und Landis-Algorithmen (AVL-B√§ume) und geschw√§chte AVL-B√§ume (WAVL-B√§ume). </p><a name="habracut"></a><br><p>  Beginnen wir mit den Definitionen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Bin√§rbaum</a> besteht aus <em>Knoten</em> , jeder Knoten speichert einen <em>Datensatz</em> in Form von <em>Schl√ºssel-Wert-</em> Paaren (oder im einfachen Fall nur Werten) und hat nicht mehr als zwei untergeordnete Knoten.  Nachkommenknoten werden durch <em>rechts</em> und <em>links unterschieden</em> , und die Bedingung f√ºr die Reihenfolge der Schl√ºssel ist erf√ºllt: Der Schl√ºssel des linken Nachkommen ist nicht mehr und der rechte ist nicht kleiner als der Schl√ºssel des √ºbergeordneten Knotens.  Dar√ºber hinaus k√∂nnen Dienstinformationen in Knoten gespeichert werden (und normalerweise in Knoten gespeichert werden) - beispielsweise eine Verkn√ºpfung zum √ºbergeordneten Knoten oder andere Daten.  Sonderf√§lle sind der <em>Stammknoten,</em> von dem aus der Baum eingegeben wird, und <em>ein leerer Knoten</em> , der keine Informationen speichert.  Knoten, in denen beide Nachkommen leer sind, werden Baumbl√§tter genannt.  Ein Knoten mit allen Nachkommen bildet einen <em>Teilbaum</em> .  Somit ist jeder Knoten entweder die Wurzel eines Teilbaums oder eines Blattes. </p><br><p> Mit dieser Definition k√∂nnen Sie eine einfache Struktur zum Speichern von Knoten und des Baums selbst erstellen.  Wir nehmen an, dass ein leerer Knoten den speziellen Wert <code>nothing</code> Typ <code>Nothing</code> .  Dann reicht es aus, im Knoten Verweise auf den rechten und linken Nachwuchs sowie auf den Elternteil zu speichern.  Die Struktur zum Speichern des Baums enth√§lt nur eine Verkn√ºpfung zum Stammknoten. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># K -   # V -    mutable struct BSTNode{K, V} key::K value::V left::Union{Nothing, BSTNode{K,V}} right::Union{Nothing, BSTNode{K,V}} parent::BSTNode{K,V} end mutable struct BST{K, V} root::BSTNode{K,V} end</span></span></code> </pre> <br><p>  In diesem Fall stellt sich die Frage, wie ein leerer Baum dargestellt werden soll.  Dazu verwenden wir den Ansatz aus dem Buch "Algorithmen: Konstruktion und Analyse" und f√ºgen als Eintrittspunkt in den Baum keine Wurzel, sondern einen Dummy-Knoten ein, der sein eigenes √ºbergeordnetes Element sein wird.  F√ºgen Sie der BSTNode-Strukturbeschreibung Konstruktoren hinzu, um einen solchen Knoten zu erstellen: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">mutable struct</span></span> BSTNode{K, V} key::K value::V left::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing, BSTNode{K,V}} right::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing, BSTNode{K,V}} parent::BSTNode{K,V} <span class="hljs-comment"><span class="hljs-comment">#   function BSTNode{K,V}() where {K,V} node = new{K,V}() node.parent = node node.left = node.right = nothing return node end #    - function BSTNode{K,V}(key, value) where {K, V} node = new{K,V}() node.parent = node node.left = node.right = nothing node.key, node.value = key, value return node end end BSTNode() = BSTNode{Any, Any}() #     ! struct BST{K, V} entry::BSTNode{K,V} BST{K,V}() where {K,V} = new{K,V}(BSTNode{K,V}()) end BST() = BST{Any, Any}() Base.isempty(bst::BST) = bst.entry.left == nothing</span></span></code> </pre> <br><p>  In diesem Fall kann die <code>BST</code> Struktur unver√§ndert gemacht werden, weil  Der Link zum Einstiegspunkt muss nicht mehr ge√§ndert werden.  Ferner nehmen wir an, dass der Wurzelknoten des Baums unmittelbar der rechte und linke Nachkomme des Eingabeknotens ist. </p><br><p>  Die Hauptoperation, f√ºr die Suchb√§ume ben√∂tigt werden, ist nat√ºrlich die Suche nach Elementen.  Da der Schl√ºssel des linken untergeordneten Elements nicht mehr und der rechte nicht kleiner als der √ºbergeordnete Schl√ºssel ist, wird die Elementsuchprozedur sehr einfach geschrieben: Vergleichen Sie ausgehend von der Wurzel des Baums den Eingabeschl√ºssel mit dem Schl√ºssel des aktuellen Knotens;  Wenn die Schl√ºssel √ºbereinstimmen, geben wir den Wert zur√ºck. Andernfalls gehen Sie je nach Reihenfolge der Schl√ºssel zum linken oder rechten Teilbaum.  Wenn sie gleichzeitig einen leeren Knoten erreicht haben - es gibt keinen Schl√ºssel im Baum, l√∂sen Sie eine Ausnahme aus. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#   Base.getindex()    #      tree[key] function Base.getindex(bst::BST{K,V}, key) where {K,V} key = convert(K, key) node = bst.entry.left while node != nothing key == node.key &amp;&amp; return node.value node = (key &lt; node.key ? node.left : node.right) end throw(KeyError(key)) end</span></span></code> </pre> <br><p>  Das Suchen nach einem Element mit einem Schl√ºssel dauert offensichtlich <em>O</em> ( <em>h</em> ) Zeit, wobei <em>h</em> die H√∂he des Baums ist, d.h.  maximaler Abstand von Wurzel zu Blatt.  Es ist leicht zu berechnen, dass ein Bin√§rbaum der H√∂he <em>h</em> h√∂chstens 2 <sup>h + 1</sup> -1 Knoten enthalten kann, wenn er <em>dicht besiedelt ist</em> , d. H.  Alle Knoten au√üer vielleicht der extremsten Schicht haben beide Nachkommen.  Dar√ºber hinaus ist klar, dass jede gegebene Tastenfolge im Voraus zu einem so dichten Baum f√ºhren kann.  Dies ergibt ein sehr optimistisches asymptotisches Verhalten bei der Suche nach einem Element in einem Baum mit seiner optimalen Konstruktion in der Zeit <em>O</em> (log <sub>2</sub> <em>N</em> ), wobei <em>N</em> die Anzahl der Elemente ist. </p><br><p>  Nat√ºrlich muss der Algorithmus zum Hinzuf√ºgen eines Elements zum Suchbaum so konstruiert sein, dass die Bedingung f√ºr die Reihenfolge der Schl√ºssel erf√ºllt ist.  Schreiben wir eine naive Implementierung des Einf√ºgens eines Elements per Schl√ºssel: </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#   Base.setindex!()    #       tree[key] = value function Base.setindex!(bst::BST{K,V}, val::SV, key::SK) where {K, V} key, value = convert(K, key), convert(V, val) parent = bst.entry.left #   -     if parent == nothing newnode.parent = bst.entry bst.entry.left = bst.entry.right = newnode return val end key_found = false while !key_found if key &lt; parent.key if parent.left == nothing parent.left = BSTNode{K,V}(key, value) parent.left.parent = parent key_found = true else parent = parent.left end elseif key &gt; parent.key if parent.right == nothing parent.right = BSTNode{K,V}(key, value) newnode.parent = parent key_found = true else parent = parent.right end else key_found = true parent.value = value end end return val end</span></span></code> </pre> <br><p>  Leider ergibt die naive Konstruktion des Baums die gew√ºnschte Struktur nur bei zuf√§lligen Eingabedaten, aber in Wirklichkeit sind sie oft recht strukturiert.  Im schlimmsten Fall, wenn die eingehenden Schl√ºssel streng geordnet sind (zumindest in aufsteigender, mindestens in absteigender Reihenfolge), sendet die naive Baumkonstruktion st√§ndig neue Elemente in eine Richtung und sammelt tats√§chlich eine lineare Liste.  Es ist leicht zu erraten, dass das Einf√ºgen von Elementen, dass die Suche mit einer solchen Struktur w√§hrend <em>O</em> ( <em>N</em> ) stattfinden wird, was alle Bem√ºhungen zum Aufbau einer komplexen Datenstruktur zunichte macht. </p><br><p>  Schlussfolgerung: Der Suchbaum muss w√§hrend der Erstellung <em>ausgeglichen</em> werden, d. H.  Richten Sie die H√∂he des rechten und linken Teilbaums an jedem Knoten aus.  Es gibt verschiedene Ans√§tze zum Auswuchten.  Am einfachsten ist es, eine bestimmte Anzahl von Einf√ºge- oder L√∂schvorg√§ngen anzugeben, nach denen der Baum neu ausgeglichen wird.  In diesem Fall befindet sich der Baum vor dem Auswuchten in einem eher "laufenden" Zustand, weshalb das Auswuchten im schlimmsten Fall etwa <em>0</em> ( <em>N</em> ) Zeit in Anspruch nimmt, aber nachfolgende Operationen bis zu einem bestimmten Einf√ºge- / L√∂schschwellenwert in logarithmischer Zeit ausgef√ºhrt werden.  Eine andere M√∂glichkeit besteht darin, die Einf√ºge- und L√∂schalgorithmen sofort so zu erstellen, dass der Baum immer ausgeglichen bleibt, was die <em>garantierte</em> Zeitkomplexit√§t <em>O</em> (log <sub>2</sub> <em>N</em> ) f√ºr jede Operation ergibt. </p><br><p>  Aufgrund der Tatsache, dass es Algorithmen gibt, bei denen der Baum ‚Äûwild werden‚Äú darf, aber danach Operationen f√ºr eine ziemlich lange Zeit in einer logarithmischen Zeit ausgef√ºhrt werden k√∂nnen, bevor der Baum f√ºr eine lange Zeit wieder in einen ausgeglichenen Zustand gebracht werden muss, wird die <em>garantierte</em> und <em>amortisierte</em> Zeit des Einf√ºgens / L√∂schens eines Elements unterschieden.  Bei einigen Implementierungen von Operationen mit bin√§ren Suchb√§umen ist die Komplexit√§t des Einf√ºgens und L√∂schens von <em>O</em> (log <sub>2</sub> <em>N</em> ) garantiert, bei einigen wird es mit einer Verschlechterung auf <em>O</em> ( <em>N</em> ) abgeschrieben. </p><br><h3 id="algoritm-adelson-velskogo-i-landisa-avl">  Adelson-Welsky- und Landis-Algorithmus (AVL) </h3><br><p>  Die erste Implementierung eines selbstausgleichenden bin√§ren Suchbaums wurde 1962 von Adelson-Welsky und Landis vorgeschlagen.  In der modernen Literatur zu den Anfangsbuchstaben von Nachnamen wird diese Struktur als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AVL-B√§ume bezeichnet</a> .  Die Struktur wird durch die folgenden Eigenschaften beschrieben: </p><br><ol><li>  Reihenfolge: F√ºr jeden Knoten ist der Schl√ºssel oben im linken Teilbaum kleiner als der Schl√ºssel oben im rechten Teilbaum (wenn die Nachkommen keine leeren Knoten sind). </li><li>  H√∂henerh√∂hung: Die H√∂he des √ºbergeordneten Knotens ist um eins h√∂her als die maximale H√∂he seiner Nachkommen.  Die H√∂he der leeren Knoten kann als gleich Null betrachtet werden. </li><li>  AVL-Balance: F√ºr jeden Knoten unterscheiden sich die H√∂hen der rechten und linken Teilb√§ume um nicht mehr als 1. </li></ol><br><p>  Aus diesen Eigenschaften folgt, dass die H√∂he des gesamten Baums <em>O ist</em> (log <sub>2</sub> <em>N</em> ), wobei <em>N</em> die Anzahl der im Baum gespeicherten Datens√§tze ist, was bedeutet, dass der Datensatz in logarithmischer Zeit gesucht wird.  Damit der Zustand des ABL-Gleichgewichts nach jedem Einsetzen erhalten bleibt, wird jedes Einsetzen von einem <em>Ausgleichsvorgang</em> begleitet.  F√ºr die effektive Implementierung dieser Operation muss jeder Knoten Dienstinformationen speichern.  Halten Sie der Einfachheit halber einfach die H√∂he des Knotens dort. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">mutable struct</span></span> AVLNode{K,V} <span class="hljs-comment"><span class="hljs-comment"># ,       255 # (  10^38 ) height::UInt8 key::K value::V left::Union{Nothing, AVLNode{K,V}} right::Union{Nothing, AVLNode{K,V}} parent::AVLNode{K,V} #   function AVLNode{K,V}() where {K,V} node = new{K,V}() node.height = 1 node.parent = node node.left = node.right = nothing return node end #    - function AVLNode{K,V}(key::SK, value::SV) where {K, V, SK&lt;:K, SV&lt;:V} node = new{K,V}() node.height = 1 node.parent = node node.left = node.right = nothing node.key, node.value = key, value return node end end avlheight(node::Union{Nothing,AVLNode}) = node == nothing ? 0 : Int(node.height)</span></span></code> </pre> <br><h4 id="vstavka-zapisi">  Datensatz einf√ºgen </h4><br><p>  Das grundlegende Einf√ºgen erfolgt gem√§√ü dem Standardalgorithmus. Gehen Sie den Baum nach unten, suchen Sie, wo Sie einen neuen Knoten einf√ºgen und einf√ºgen k√∂nnen.  Wir werden Wrapper schreiben, um untergeordnete Knoten mithilfe der Indizes -1 und 1 anstelle von links und rechts abzurufen und zu ersetzen: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> child(root::AVLNode, side::<span class="hljs-built_in"><span class="hljs-built_in">Signed</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> side == -<span class="hljs-number"><span class="hljs-number">1</span></span> root.left <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> side == <span class="hljs-number"><span class="hljs-number">1</span></span> root.right <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> throw(<span class="hljs-built_in"><span class="hljs-built_in">ArgumentError</span></span>(<span class="hljs-string"><span class="hljs-string">"Expecting side=-1 to get the left child or side=1 to get the right child"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> insert_child!(root::AVLNode{K,V}, newnode::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing,AVLNode{K,V}}, side::<span class="hljs-built_in"><span class="hljs-built_in">Signed</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {K,V} newnode == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> || (newnode.parent = root) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> side == -<span class="hljs-number"><span class="hljs-number">1</span></span> root.left = newnode <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> side == <span class="hljs-number"><span class="hljs-number">1</span></span> root.right = newnode <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> throw(<span class="hljs-built_in"><span class="hljs-built_in">ArgumentError</span></span>(<span class="hljs-string"><span class="hljs-string">"Expecting side=-1 for inserting node to the left or side=1 for inserting to the right"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Als n√§chstes gehen wir den Baum hinauf und suchen nach Verst√∂√üen gegen die Bedingungen 2 und 3. Als n√§chstes betrachten wir die Optionen, die m√∂glicherweise angezeigt werden (in den Abbildungen zeigt Gr√ºn den Knoten an, der die H√∂he ge√§ndert hat, der Knoten, der verarbeitet wird, ist sein √ºbergeordneter Knoten). </p><br><p>  <strong>Fall 0</strong> <br>  Nach dem Einf√ºgen wurde die H√∂he des Knotens dieselbe wie die der Schwester und 1 kleiner als die (alte) H√∂he des √ºbergeordneten Knotens. </p><br><p><img src="https://habrastorage.org/webt/uf/9_/iq/uf9_iqcs1ydiwszzfl8ub8dbxj8.png"></p><br><p>  Im besten Fall m√ºssen Sie nichts weiter ber√ºhren.  Auch oben kann man da nicht mehr gucken  dort wird sich nichts √§ndern. </p><br><p>  <strong>Fall 1</strong> <br>  Vor dem Einsetzen war die H√∂he des Knotens gleich der H√∂he des Schwesterknotens.  Durch das Einf√ºgen wird die Wurzel des Teilbaums angehoben und die H√∂he des Knotens mit der H√∂he des √ºbergeordneten Knotens verglichen. </p><br><p><img src="https://habrastorage.org/webt/s4/nv/t4/s4nvt4y-m1znfln4g4ajf2346d0.png"></p><br><p>  In diesem Fall reicht es aus, den √ºbergeordneten Knoten zu ‚Äûerh√∂hen‚Äú und seine H√∂he um 1 zu erh√∂hen. Gleichzeitig m√ºssen Sie weiter zur Wurzel des Baums wechseln, da eine √Ñnderung der H√∂he des √ºbergeordneten Knotens zu einer Verletzung von Bedingung 2 f√ºhren kann, die eine Ebene h√∂her liegt. </p><br><p><img src="https://habrastorage.org/webt/v-/j9/0s/v-j90s0nar7w4mgas4oujggl3h8.png"></p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="julia hljs">fucntion promote!(nd::AVLNode, by::<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span>) nd.height += by <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> fucntion demote!(nd::AVLNode, by::<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span>) nd.height -= by <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>  <strong>Fall 2</strong> </p><br><p>  Nach dem Einf√ºgen wurde der H√∂henunterschied zum Schwester-Teilbaum 2, und der linke Teilbaum wurde nach oben ‚Äûgedr√ºckt‚Äú: </p><br><p><img src="https://habrastorage.org/webt/la/bl/aj/lablajxlzp2lgvbhm4nlh5j-3ks.png"></p><br><p>  Das Problem wird mit einer Operation behandelt, die als "einfache Drehung" bezeichnet wird und den Baum wie folgt transformiert: </p><br><p><img src="https://habrastorage.org/webt/8j/zc/yt/8jzcytyqgke3xpcikei8zrbvbrq.png"></p><br><p>  Eine einfache Drehung erfordert 6 Zeigerwechsel. </p><br><p>  Beachten Sie, dass bei der Projektion auf die horizontale Achse die Reihenfolge der Eckpunkte <em>n</em> , <em>p</em> und der B√§ume <em>T</em> <sub>1</sub> - <em>T</em> <sub>3</sub> vor und nach der Drehung gleich bleibt.  Dies ist die Erf√ºllung der Bestellbedingung.  Wie Sie sehen, ist nach dem Aufdrehen des Baumes kein Ausgleich mehr erforderlich. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># pivot       function rotate!(pivot::AVLNode, dir::Signed) dir in (-1, 1) || throw(ArgumentError("Unknown rotation direction")) p = pivot.parent g = p.parent p.height = avlheight(child(pivot, dir)) + 1 pivot.height = p.height + 1 # "" pivot  g pivot.parent = g g.left === p &amp;&amp; (g.left = pivot) g.right === p &amp;&amp; (g.right = pivot) c = child(pivot, dir) #  c  p insert_child!(p, c, -dir) #  p  pivot insert_child!(pivot, p, dir) pivot end</span></span></code> </pre> </div></div><br><p>  <strong>Fall 3</strong> <br>  Nach dem Einf√ºgen wurde der H√∂henunterschied zum Schwester-Teilbaum 2 und der rechte Teilbaum "hochgeschoben": </p><br><p><img src="https://habrastorage.org/webt/cs/el/1u/csel1u39enlepfhdrc4bdw_legq.png"></p><br><p>  In diesem Fall hilft eine einzelne einfache Kurve nicht mehr, aber Sie k√∂nnen eine einfache Linkskurve um den rechten Nachkommen machen, was zu Fall 2 f√ºhrt, der bereits mit einer einfachen Rechtskurve behandelt wird. </p><br><p>  Um die Anzahl der "√úbergewichtungen" von Knoten zu verringern, k√∂nnen zwei Windungen zu einer Operation kombiniert werden, die als gro√üe oder doppelte Windung bezeichnet wird.  Anstelle von 12 Zeiger√§nderungen werden dann nur 10 ben√∂tigt. Als Ergebnis einer doppelten Drehung nimmt der Baum die folgende Form an: </p><br><p><img src="https://habrastorage.org/webt/ub/ds/7i/ubds7iawqzg9uqgned3mxiqs_8m.png"></p><br><p>  Wie Sie sehen, ist nach einer doppelten Umdrehung auch kein weiterer Ausgleich des Baumes erforderlich. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># pivot       funtion double_rotate!(pivot::AVLNode, dir::Signed) dir in (-1, 1) || throw(ArgumentError("Unknown rotation direction")) n = pivot.parent p = n.parent g = p.parent pivot.height = n.height n.height = p.height = pivot.height - 1 # "" pivot  g pivot.parent = g g.left === p &amp;&amp; (g.left = pivot) g.right === p &amp;&amp; (g.right = pivot) t2, t3 = child(pivot, -dir), child(pivot, dir) #  n  pivot  t2  n insert_child!(n, t2, dir) insert_child!(pivot, n, -dir) #  p  pivot  t3  p insert_child!(p, t3, -dir) insert_child!(pivot, p, dir) pivot end</span></span></code> </pre> </div></div><br><p>  Wenn Sie also einen Datensatz in den AVL-Baum einf√ºgen, ben√∂tigen Sie <em>O</em> (log <sub>2</sub> <em>N</em> ) √Ñnderungen in den Informationen √ºber die H√∂he der Knoten und nicht mehr als zwei Rotationsvorg√§nge.  Kombinieren Sie alles zu einer Einf√ºgefunktion.  Sie unterscheidet sich von der Grundeinf√ºgung nur dadurch, dass nach dem Einf√ºgen eines neuen Knotens die Funktion <code>fix_insertion!()</code> wird, die vom neu eingef√ºgten Knoten zur Wurzel √ºbergeht, das Gleichgewicht √ºberpr√ºft und gegebenenfalls korrigiert. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.setindex!(avlt::AVLTree{K,V}, val, key) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {K,V} key, value = convert(K, key), convert(V, val) parent = avlt.entry.left <span class="hljs-comment"><span class="hljs-comment">#   -     if parent == nothing newnode = AVLNode{K,V}(key, value) newnode.parent = avlt.entry avlt.entry.left = avlt.entry.right = newnode return val end key_found = false while !key_found key_found = key == parent.key if key_found parent.value = value else side = (key &gt; parent.key) * 2 - 1 # true == 1, false == 0 next = child(parent, side) if next == nothing newnode = AVLNode{K,V}(key, value) insert_child!(parent, newnode, side) fix_insertion!(newnode) key_found = true else parent = next end end end return val end</span></span></code> </pre> <br><p>  Die Funktion <code>fix_insertion!()</code> √úberpr√ºft den H√∂henunterschied zwischen zwei <code>fix_insertion!()</code> Knoten, beginnend mit dem √ºbergeordneten Knoten und dem eingef√ºgten.  Wenn es gleich 1 ist - wir sind in Fall 1, m√ºssen Sie die H√∂he des Knotens erh√∂hen und h√∂her gehen.  Wenn es Null ist, ist der Baum ausgeglichen.  Wenn es gleich 2 ist - dies ist Fall 2 oder 3 - m√ºssen Sie die entsprechende Drehung anwenden, und der Baum wird in einen ausgeglichenen Zustand versetzt. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#     -  , #   -  imbalance(node::AVLNode) = avlheight(node.right) - avlheight(node.left) function fix_insertion!(start::AVLNode) node = start.parent skew = imbalance(node) #      0 - ..        while abs(skew) == 1 node.height += 1 node = node.parent skew = imbalance(node) end @assert abs(skew) == 2 || skew == 0 if skew != 0 #       , # ..   dir = -skew √∑ 2 n = child(node, -dir) prev_skew = imbalance(n) @assert abs(prev_skew) == 1 if prev_skew == dir double_rotate!(child(n, dir), dir) else rotate!(n, dir) end end end</span></span></code> </pre> <br><h4 id="udalenie-zapisi">  Datensatz l√∂schen </h4><br><p>  Das Entfernen ist etwas schwieriger als das Einsetzen. </p><br><p>  Betrachten Sie zun√§chst das √ºbliche L√∂schen eines Eintrags aus einem bin√§ren Suchbaum. </p><br><ol><li>  Befindet sich der gel√∂schte Datensatz im Blatt, wird der Datensatz einfach gel√∂scht, hier ist alles einfach. </li><li>  Befindet sich der gel√∂schte Datensatz in einem Knoten mit nur einem Nachkommen, wird dieser Nachkomme zusammen mit seinem gesamten Teilbaum an die Stelle des Remote-Knotens gesetzt. </li><li>  Wenn zwei Nachkommen vorhanden sind, wird entweder das maximale Element im linken Teilbaum oder das minimale Element im rechten Teilbaum aus dem Baum extrahiert (durch die Eigenschaft des Suchbaums wird garantiert, dass der Knoten mit dem maximalen Element keinen rechten Nachkommen hat, und mit einem minimalen Element nach links, sodass das L√∂schen einfach ist) und anstelle des gel√∂schten Datensatzes setzen. </li></ol><br><p>  Danach kann das Baumgleichgewicht jedoch gest√∂rt sein. Sie m√ºssen daher vom √ºbergeordneten Knoten des Remote-Knotens aufsteigen und ihn wiederherstellen.  Beachten Sie, dass zu Beginn garantiert ist, dass einer der Nachkommen des betreffenden Elternteils die H√∂he um 1 verringert hat. Vor diesem Hintergrund m√ºssen Sie die Optionen ber√ºcksichtigen (die Knoten, die die H√∂he ge√§ndert haben, werden rot angezeigt, der verarbeitete Knoten ist der Elternteil von rot): </p><br><p>  <strong>Fall 1</strong> <br>  Kein Ungleichgewicht.  Vor dem Entfernen war es also 1 Modulo, und jetzt sind die untergeordneten Knoten 2 niedriger als die √ºbergeordneten. </p><br><p><img src="https://habrastorage.org/webt/mo/cm/a_/mocma_jzetjrizjwiesbdtx1rtu.png"></p><br><p>  Sie m√ºssen den √ºbergeordneten Knoten um 1 senken und weiter nach oben gehen. </p><br><p><img src="https://habrastorage.org/webt/j8/6y/yi/j86yyi7cxkzasggld6pzo9fldwu.png"></p><br><p>  <strong>Fall 2</strong> <br>  Ungleichgewicht 1 Modulo. </p><br><p><img src="https://habrastorage.org/webt/hn/8v/cx/hn8vcxpvolbjnafm9h3u08kpnoo.png"></p><br><p>  Wenn die AVL-Bedingung erf√ºllt ist, k√∂nnen Sie aufh√∂ren. </p><br><p>  <strong>Fall 3</strong> <br>  Das Ungleichgewicht 2 ist modulo, der Schwesterknoten zum absteigenden Knoten hat ein Ungleichgewicht ungleich Null. </p><br><p><img src="https://habrastorage.org/webt/vr/_f/jc/vr_fjcvwl3zxc6ocy622l2sszrw.png"></p><br><p>  Wir stellen das Gleichgewicht durch einfaches (wenn T <sub>1</sub> niedriger als T <sub>2 ist</sub> ) oder durch doppelte (ansonsten) Drehung wieder her, wie dies beim Einsetzen geschehen ist.  Die H√∂he des Teilbaums nimmt ab, d.h.  √úber dem Baum kann eine Verletzung auftreten. </p><br><p><img src="https://habrastorage.org/webt/h9/5f/qx/h95fqxdbbqukr_eyjbhbjyyoju4.png"></p><br><p>  <strong>Fall 4</strong> <br>  Ungleichgewicht 2 Modulo, der Schwesterknoten hat kein Ungleichgewicht. </p><br><p><img src="https://habrastorage.org/webt/o6/rl/mq/o6rlmq62rxnxxyh6knsz3xne4te.png"></p><br><p>  Eine einfache Drehung stellt den Ausgleichszustand wieder her, w√§hrend sich die H√∂he des Teilbaums nicht √§ndert - wir h√∂ren auf, uns nach oben zu bewegen. </p><br><p><img src="https://habrastorage.org/webt/sw/c-/d5/swc-d56rswsunltv7_3g60tvufq.png"></p><br><div class="spoiler">  <b class="spoiler_title">Code zum Entfernen von Schl√ºsseln</b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> next_node(node::AVLNode) next = node.right <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> p = node.parent next = p.parent <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next !== p) &amp;&amp; (next.key &lt; p.key) p, next = next, next.parent <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (next === p ? <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> : next) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> next.left != <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> next = next.left <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.delete!(avlt::AVLTree{K,V}, key) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {K,V} key = convert(K, key) candidate = avlt.entry.left dir = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> candidate.key != key dir = <span class="hljs-number"><span class="hljs-number">2</span></span> * (key &gt; candidate.key) - <span class="hljs-number"><span class="hljs-number">1</span></span> candidate = child(candidate, dir) candidate == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> val = candidate.value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> side <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> child(candidate, side) == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> p, s = candidate.parent, child(candidate, -side) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p === p.parent insert_child!(p, s, <span class="hljs-number"><span class="hljs-number">1</span></span>) insert_child!(p, s, -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insert_child!(p, s, dir) fix_deletion!(p) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> swap = next_node(candidate) cp, sp, sr = candidate.parent, swap.parent, swap.right swap.height = candidate.height insert_child!(swap, candidate.left, -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> side <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) child(cp, side) === candidate &amp;&amp; insert_child!(cp, swap, side) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sp === candidate fix_deletion!(swap) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insert_child!(swap, candidate.right, <span class="hljs-number"><span class="hljs-number">1</span></span>) insert_child!(sp, sr, -<span class="hljs-number"><span class="hljs-number">1</span></span>) fix_deletion!(sp) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> fix_deletion!(start::AVLNode) node = start skew = imbalance(node) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (node !== node.parent) &amp;&amp; (abs(skew) != <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> skew != <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-meta"><span class="hljs-meta">@assert</span></span> abs(skew) == <span class="hljs-number"><span class="hljs-number">2</span></span> dir = -skew √∑ <span class="hljs-number"><span class="hljs-number">2</span></span> n = child(node, -dir) prev_skew = imbalance(n) <span class="hljs-meta"><span class="hljs-meta">@assert</span></span> abs(prev_skew) &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> prev_skew == dir node = double_rotate!(child(n, dir), dir) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> node = rotate!(n, dir) prev_skew != <span class="hljs-number"><span class="hljs-number">0</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> node.height -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> node = node.parent skew = imbalance(node) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><h3 id="vzlyot-i-padenie-avl-derevev">  Aufstieg und Fall von AVL-B√§umen </h3><br><p>  Ein nicht sehr sch√∂nes Merkmal klassischer AVL-B√§ume ist die Schwierigkeit, einen Datensatz zu l√∂schen:  Eine Rotation kann den gesamten Teilbaum um eine Ebene nach unten "zur√ºcksetzen". Im schlimmsten Fall erfordert das L√∂schen <em>O</em> (log <sub>2</sub> <em>N</em> ) <code>fix_deletion!()</code> - jedes Mal, wenn Sie in <code>fix_deletion!()</code> um eine Ebene nach <code>fix_deletion!()</code> . </p><br><p>  Aufgrund dieses nicht so guten asymptotischen Verhaltens wichen AVL-B√§ume rot-schwarzen B√§umen, die in den 1970er Jahren auftauchten und einen schw√§cheren Ausgleichszustand aufwiesen - der Weg von der Wurzel zum am weitesten entfernten Blatt ist nicht mehr als doppelt so lang wie der Weg von der Wurzel zum n√§chsten Blatt.  Aus diesem Grund betr√§gt die H√∂he von rot-schwarzen B√§umen im schlimmsten Fall <sub>2</sub> log <sub>2</sub> <em>N</em> gegen√ºber 1,44 log <sub>2</sub> <em>N</em> f√ºr AVL-B√§ume. Das L√∂schen eines Datensatzes erfordert jedoch nicht mehr als drei einfache Umdrehungen.  Daher verlieren Suche und Einf√ºgung aufgrund einer h√∂heren Baumh√∂he m√∂glicherweise an Leistung, aber es gibt einen potenziellen Gewinn, wenn Einf√ºgungen h√§ufig mit L√∂schungen durchsetzt sind. </p><br><h3 id="avl-nanosyat-otvetnyy-udar">  AVL schl√§gt zur√ºck </h3><br><p>  Es stellt sich heraus, dass der ‚Äûideale‚Äú Algorithmus zum Erstellen von bin√§ren Suchb√§umen eine geringe H√∂he (auf der Ebene des klassischen AVL-Baums) und eine konstante Anzahl von Umdrehungen sowohl beim Hinzuf√ºgen als auch beim L√∂schen eines Datensatzes gew√§hrleisten sollte.  Dies wurde noch nicht erfunden, aber 2015 wurde eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeit</a> ver√∂ffentlicht, die eine Struktur vorschlug, die die Eigenschaften von AVL- und rot-schwarzen B√§umen verbessert.  Die Idee liegt n√§her an den AVL-B√§umen, aber die Balance-Bedingung wird gelockert, um ein effizienteres L√∂schen von Datens√§tzen zu erm√∂glichen.  Die Eigenschaften einer Struktur, die als "schwacher AVL-Baum" (W (eak) AVL-Baum) bezeichnet wird, werden wie folgt formuliert: </p><br><ol><li>  Reihenfolge: F√ºr jeden Knoten ist der Schl√ºssel oben im linken Teilbaum kleiner als der Schl√ºssel oben im rechten Teilbaum (wenn die Nachkommen keine leeren Knoten sind). </li><li>  Aufsteigender Rang.  Jedem Knoten wird ein Rang zugewiesen.  Der Rang aller leeren Knoten ist Null, der Rang der Bl√§tter ist 1. Der Rang des Elternknotens ist streng h√∂her als der Rang des Kindes. </li><li>  Schwaches ABL-Gleichgewicht: Der Rang eines Knotens unterscheidet sich vom Rang der untergeordneten Knoten um nicht mehr als 2. </li></ol><br><p>  Es stellt sich heraus, dass eine solche Struktur die Eigenschaften sowohl klassischer AVL-B√§ume als auch rot-schwarzer B√§ume umfasst.  Insbesondere wenn wir die Bedingung einf√ºhren, dass sich <em>beide</em> untergeordneten Knoten im Rang nicht um 2 vom √ºbergeordneten Knoten unterscheiden k√∂nnen, erhalten wir einen regul√§ren AVL-Baum, und der Rang entspricht genau der H√∂he des Teilbaums. </p><br><p>  Das Sch√∂ne an SAVL-B√§umen ist, dass durch eine leichte Abschw√§chung des AVL-Zustands der Baum ausgeglichen werden kann, wenn ein Datensatz um nicht mehr als zwei Umdrehungen gel√∂scht wird!  Die Baumh√∂hensch√§tzung ist h &lt;min (1,44 log <sub>2</sub> <em>M</em> , <sub>2</sub> log <sub>2</sub> <em>N</em> ), wobei <em>N</em> die Anzahl der Eintr√§ge im Baum ist, <em>M</em> die Anzahl der Einf√ºgungen ist, verglichen mit h &lt; <sub>2</sub> log <sub>2</sub> <em>N</em> f√ºr rot-schwarze B√§ume.  ,  -   ,       ,      . </p><br><p>  -             ,          .  -        . </p><br><h4 id="struktura-hraneniya">  . </h4><br><p>     -,  ""    "".  ,   : </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">mutable struct</span></span> WAVLNode rank::<span class="hljs-built_in"><span class="hljs-built_in">UInt8</span></span> key::K value::V left::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing, WAVLNode{K,V}} right::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing, WAVLNode{K,V}} parent::WAVLNode{K,V} <span class="hljs-comment"><span class="hljs-comment">#   function WAVLNode{K,V}() where {K,V} node = new{K,V}() node.rank = 1 node.parent = node node.left = node.right = nothing return node end #    - function WAVLNode{K,V}(key, value) where {K,V} key, value = convert(K, key), convert(V, value) node = new{K,V}() node.rank = 1 node.parent = node node.left = node.right = nothing node.key, node.value = key, value return node end end struct WAVLTree{K, V} entry::WAVLNode{K,V} WAVLTree{K,V}() where {K,V} = new{K,V}(WAVLNode{K,V}()) end function child(root::WAVLNode, side::Signed) if side == -1 root.left elseif side == 1 root.right else throw(ArgumentError("Expecting side=-1 to get the left child or side=1 to get the right child")) end end function Base.getindex(avlt::WAVLTree{K,V}, key) where {K,V} key = convert(K, key) node = avlt.entry.left while node != nothing key == node.key &amp;&amp; return node.value node = (key &lt; node.key ? node.left : node.right) end throw(KeyError(key)) end</span></span></code> </pre> <br><h4 id="vstavka-zapisi-1">   </h4><br><p>    ,     -.  :      1    ,      ‚Äî      ,          0 (  )  1 (    ).      <code>imbalance()</code> ,     ,  . </p><br><pre> <code class="julia hljs">wavlrank(node::<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{Nothing,WAVLNode}) = node == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>(node.rank) <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> imbalance(node::WAVLNode) rr, lr = wavlrank(node.right), wavlrank(node.left) skew = rr - lr diff = node.rank - max(rr, lr) skew, diff <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>    ,           .  ,  ,    ,    ,    -,   - . </p><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># pivot       function rotate!(pivot::AVLNode, dir::Signed) dir in (-1, 1) || throw(ArgumentError("Unknown rotation direction")) p = pivot.parent g = p.parent p.height = avlheight(child(pivot, dir)) + 1 pivot.height = p.height + 1 # "" pivot  g pivot.parent = g g.left === p &amp;&amp; (g.left = pivot) g.right === p &amp;&amp; (g.right = pivot) c = child(pivot, dir) #  c  p insert_child!(p, c, -dir) #  p  pivot insert_child!(pivot, p, dir) pivot end # pivot       function double_rotate!(pivot::AVLNode, dir::Signed) dir in (-1, 1) || throw(ArgumentError("Unknown rotation direction")) n = pivot.parent p = n.parent g = p.parent pivot.height = n.height n.height = p.height = pivot.height - 1 # "" pivot  g pivot.parent = g g.left === p &amp;&amp; (g.left = pivot) g.right === p &amp;&amp; (g.right = pivot) t2, t3 = child(pivot, -dir), child(pivot, dir) #  n  pivot  t2  n insert_child!(n, t2, dir) insert_child!(pivot, n, -dir) #  p  pivot  t3  p insert_child!(p, t3, -dir) insert_child!(pivot, p, dir) pivot end imbalance(node::AVLNode) = avlheight(node.right) - avlheight(node.left) function fix_insertion!(start::AVLNode) node = start.parent skew = imbalance(node) while abs(skew) == 1 node.height += 1 node = node.parent skew = imbalance(node) end @assert abs(skew) == 2 || skew == 0 if skew != 0 dir = -skew √∑ 2 n = child(node, -dir) prev_skew = imbalance(n) @assert abs(prev_skew) == 1 if prev_skew == dir double_rotate!(child(n, dir), dir) else rotate!(n, dir) end end end function Base.setindex!(avlt::AVLTree{K,V}, val, key) where {K,V} key, value = convert(K, key), convert(V, val) parent = avlt.entry.left #   -     if parent == nothing newnode = AVLNode{K,V}(key, value) newnode.parent = avlt.entry avlt.entry.left = avlt.entry.right = newnode return val end key_found = false while !key_found key_found = key == parent.key if key_found parent.value = value else side = (key &gt; parent.key) * 2 - 1 next = child(parent, side) if next == nothing newnode = AVLNode{K,V}(key, value) insert_child!(parent, newnode, side) fix_insertion!(newnode) key_found = true else parent = next end end end return val end</span></span></code> </pre> </div></div><br><h4 id="udalenie-zapisi-1">   </h4><br><p>    ,     ‚Äî    -.        . </p><br><p> <strong> 0</strong> <br>       , ..: </p><br><ol><li>  1,     1   </li><li>  0,    2  ,     . <br>    . </li></ol><br><p> <strong> 1</strong> <br>     2 ( 0,   2   ). <br>    1   . </p><br><p> <strong> 2</strong> <br>  1,     2. </p><br><p><img src="https://habrastorage.org/webt/q0/gq/3h/q0gq3hi6g7k8modechdmavys-to.png"></p><br><p>      1,  . </p><br><p><img src="https://habrastorage.org/webt/28/ss/oc/28ssoc1ki3flzroiinnigcsguhg.png"></p><br><p> <strong> 3</strong> <br>  2 (     1, ..          ),         2  . </p><br><p><img src="https://habrastorage.org/webt/oi/tl/qd/oitlqdhhc83lttdsw6s0az_kr5y.png"></p><br><p>       ,    .  . </p><br><p><img src="https://habrastorage.org/webt/st/pn/se/stpnsenr-ygtamabscwra_yd2dy.png"></p><br><p> <strong> 4</strong> <br><img src="https://habrastorage.org/webt/fp/l-/h1/fpl-h1yg-9gl3wrucoiq-lhefwq.png"></p><br><p>   . </p><br><p><img src="https://habrastorage.org/webt/s3/qy/0u/s3qy0uwfz87t5uroqynp4rvchwi.png"></p><br><p>  ,          ,      , ..      . </p><br><p>   ‚Äî   T <sub>1</sub>  T <sub>2</sub>  ,  <em>p</em>     2,    <em>p</em>     1. </p><br><p> <strong> 5</strong> <br><img src="https://habrastorage.org/webt/5m/pn/sb/5mpnsb8edlrtcazgox852h6rrsm.png"></p><br><p>   . </p><br><p><img src="https://habrastorage.org/webt/im/vt/7c/imvt7cnylf5_dja5jc6xx9km-xo.png"></p><br><p> ,    ,      . </p><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> next_node(node::WAVLNode) next = node.right <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> p = node.parent next = p.parent <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next !== p) &amp;&amp; (next.key &lt; p.key) p, next = next, next.parent <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (next === p ? <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> : next) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> next.left != <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> next = next.left <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.delete!(avlt::WAVLTree{K,V}, key) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {K,V} key = convert(K, key) candidate = avlt.entry.left dir = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> candidate.key != key dir = <span class="hljs-number"><span class="hljs-number">2</span></span> * (key &gt; candidate.key) - <span class="hljs-number"><span class="hljs-number">1</span></span> candidate = child(candidate, dir) candidate == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> val = candidate.value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> side <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> child(candidate, side) == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> p, s = candidate.parent, child(candidate, -side) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p === p.parent insert_child!(p, s, <span class="hljs-number"><span class="hljs-number">1</span></span>) insert_child!(p, s, -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insert_child!(p, s, dir) fix_deletion!(p) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> swap = next_node(candidate) cp, sp, sr = candidate.parent, swap.parent, swap.right swap.height = candidate.height insert_child!(swap, candidate.left, -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> side <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) child(cp, side) === candidate &amp;&amp; insert_child!(cp, swap, side) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sp === candidate fix_deletion!(swap) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insert_child!(swap, candidate.right, <span class="hljs-number"><span class="hljs-number">1</span></span>) insert_child!(sp, sr, -<span class="hljs-number"><span class="hljs-number">1</span></span>) fix_deletion!(sp) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> fix_deletion!(start::WAVLNode) node = start skew, diff = imbalance(node) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (node !== node.parent) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> skew == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.right == <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> node.rank = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> abs(skew) == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> diff == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> node.rank -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> dir = -skew √∑ <span class="hljs-number"><span class="hljs-number">2</span></span> n = child(node, -dir) prev_skew, prev_diff = imbalance(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> prev_diff == <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-meta"><span class="hljs-meta">@assert</span></span> prev_skew == <span class="hljs-number"><span class="hljs-number">0</span></span> n.rank -= <span class="hljs-number"><span class="hljs-number">1</span></span> node.rank -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> prev_skew == dir double_rotate!(child(n, dir), dir) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> rotate!(n, dir) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> node = node.parent skew, diff = imbalance(node) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>      -. </p><br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wavl = WAVLTree{<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>}() julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> avl = AVLTree{<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>}() julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dd = <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>}() julia&gt; x = trues(<span class="hljs-number"><span class="hljs-number">1_000_000</span></span>) <span class="hljs-comment"><span class="hljs-comment">#       ~  julia&gt; for i = 1:1_000_000; dd[i] = avl[i] = wavl[i] = i * i; end julia&gt; for i=1:500_000 k = rand(1:1_000_000) x[k] = false delete!(avl, k) delete!(wavl, k) delete!(dd, k) end # ,     julia&gt; const y = Int[] julia&gt; for i in eachindex(x); if x[i] push!(y, i); end; end julia&gt; @btime let s = 0.0; for idx in y; s += dd[idx]; end; s; end 57.626 ms (0 allocations: 0 bytes) 2.0238199367708794e17 julia&gt; @btime let s = 0.0; for idx in y; s += wavl[idx]; end; s; end 57.796 ms (0 allocations: 0 bytes) 2.0238199367708794e17 julia&gt; @btime let s = 0.0; for idx in y; s += avl[idx]; end; s; end 53.884 ms (0 allocations: 0 bytes) 2.0238199367708794e17</span></span></code> </pre> <br><p> ,        ,    . , ,   -    ,   -,    . </p><br><h3 id="primenenie-derevev-poiska">    </h3><br><p>    ‚Äî   ? <br>   ‚Äî   ,   . ,   ,  . </p><br><p>           . </p><br><h4 id="uporyadochennoe-mnozhestvo">   </h4><br><p>    ‚Äî   ,           .      <em>n</em> -   . ,     , ..  ,       . </p><br><div class="scrollable-table"><table><thead><tr><th>  Bedienung </th><th>   </th><th>   </th></tr></thead><tbody><tr><td>    </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>  Einf√ºgen </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>  </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td> <em>n</em> -  </td><td> <em>O</em> (log <em>N</em> )* </td><td> <em>O</em> (1) </td></tr></tbody></table></div><br><p> *         </p><br><h4 id="associativnyy-massiv">   </h4><br><p>   ‚Äî   ,      "   ", "    ", "  -", " ".    ,      ,        -.      .   ,          . </p><br><div class="scrollable-table"><table><thead><tr><th>  Bedienung </th><th>   </th><th> - </th><th>  Liste </th><th>   </th></tr></thead><tbody><tr><td>  Suche </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (1)* </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td></tr><tr><td>  Einf√ºgen </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (1)* </td><td> <em>O</em> (1) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>  </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (1)* </td><td> <em>O</em> ( <em>N</em> )** </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>    </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td></tr></tbody></table></div><br><p> *    <br> **     <em>O</em> (1),     ... </p><br><h4 id="ochered-s-prioritetami">    </h4><br><p>    ,       " ‚Äî ".      ,    .   ‚Äî     ( ) ,       ,  ,   .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . </p><br><div class="scrollable-table"><table><thead><tr><th>  Bedienung </th><th>   </th><th>   </th><th>  Liste </th><th>  / </th></tr></thead><tbody><tr><td>   </td><td> <em>O</em> (1)* </td><td> <em>O</em> (1) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> (1) </td></tr><tr><td>   </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> (1)** </td></tr><tr><td>   </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (1) </td><td> <em>O</em> ( <em>N</em> ) </td></tr><tr><td>   </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> (log <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td><td> <em>O</em> ( <em>N</em> ) </td></tr></tbody></table></div><br><p> *        <br> **  ,       </p><br><h3 id="vyvod">  </h3><br><p> ()    ‚Äî       ,   , ,   , ,    .      ‚Äî     , ..  ,         ,   . </p><br><h2 id="ssylki">  Referenzen </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"-"</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">nickme</a> </li><li> Rank-Balanced Trees by Bernhard Haeupler, Siddhartha Sen, Robert E. Tarjan // ACM Transactions on Algorithms | June 2015, Vol 11(4) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pdf</a> </li><li> Goodrich MT, Tamassia R. Algorithm Design and Applications </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455172/">https://habr.com/ru/post/de455172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455160/index.html">Entity Framework 6 mit Volltextsuche √ºber LINQ</a></li>
<li><a href="../de455164/index.html">Elena Balashova: ‚ÄûAktivisten haben die Frage aufgeworfen, dass die Daten unseres GIS-Portals f√ºr OpenStreetMap offen sein sollten.‚Äú</a></li>
<li><a href="../de455166/index.html">VPN auf dem Beeline-Router zur Umgehung von Sperren</a></li>
<li><a href="../de455168/index.html">492-Byte-Demo auf ATtiny5</a></li>
<li><a href="../de455170/index.html">Neue Architektur f√ºr den Bytezugriff auf SSD - wie es funktioniert</a></li>
<li><a href="../de455176/index.html">Ist es ohne Redux m√∂glich?</a></li>
<li><a href="../de455178/index.html">Fang mich, wenn du kannst. Director-Version</a></li>
<li><a href="../de455184/index.html">250 US-Dollar 3D-Drucker in Raumgr√∂√üe</a></li>
<li><a href="../de455186/index.html">MIT 3D-Drucker: Bis zu 10 Materialien pro Modell</a></li>
<li><a href="../de455190/index.html">3D-Druck von Herzmuskelzellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>