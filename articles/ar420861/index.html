<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔹 🤶🏽 🎞️ الاستعداد لـ C ++ 20. دراسة حالة Coroutines TS Real ⏫ 👩‍❤️‍👨 🏠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="في C ++ 20 ، فرصة العمل مع coroutines خارج منطقة الجزاء على وشك الظهور. هذا الموضوع قريب ومثير للاهتمام بالنسبة لنا في Yandex.Taxi (لتلبية احتياجاتنا ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>الاستعداد لـ C ++ 20. دراسة حالة Coroutines TS Real</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/420861/" style=";text-align:right;direction:rtl">  في C ++ 20 ، فرصة العمل مع coroutines خارج منطقة الجزاء على وشك الظهور.  هذا الموضوع قريب ومثير للاهتمام بالنسبة لنا في Yandex.Taxi (لتلبية احتياجاتنا الخاصة ، نقوم بتطوير إطار غير متزامن).  لذلك ، سوف نظهر اليوم لقراء هبر باستخدام مثال حقيقي لكيفية العمل مع Coruteines C ++ بدون مكدس. <br><br>  كمثال ، لنأخذ شيئًا بسيطًا: بدون العمل مع واجهات شبكة غير متزامنة ، مؤقتات غير متزامنة ، تتكون من وظيفة واحدة.  على سبيل المثال ، دعنا نحاول تحقيق وإعادة كتابة "المعكرونة" هذه من عمليات الاستدعاء: <br><br><img align="right" src="https://habrastorage.org/webt/za/0m/kp/za0mkphg8qyitvudyvv-dhunfae.jpeg"><br><pre style=";text-align:right;direction:rtl"><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FuncToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); writerQueue.PushTask([=]() { InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> finally = [=]() { InWriterThread2(); ShutdownAll(); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { networkQueue.PushTask([=](){ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetworkThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { UIQueue.PushTask([=](){ InUIThread(); writerQueue.PushTask(finally); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { writerQueue.PushTask(finally); } }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { finally(); } }); }</code> </pre> <br><a name="habracut"></a><br><h2 style=";text-align:right;direction:rtl">  مقدمة </h2><br>  Coroutines أو coroutines هي القدرة على إيقاف وظيفة من التنفيذ في مكان محدد سلفا ؛  تمر في مكان ما بالحالة الكاملة لوظيفة التوقف مع المتغيرات المحلية ؛  تشغيل الوظيفة من نفس المكان الذي أوقفناها فيه. <br>  هناك العديد من النكهات من coroutines: مكدسة ومكدسة.  سنتحدث عن هذا في وقت لاحق. <br><br><h2 style=";text-align:right;direction:rtl">  بيان المشكلة </h2><br>  لدينا العديد من قوائم انتظار المهام.  تحتوي كل مهمة على مهام معينة: هناك قائمة انتظار لرسم الرسومات ، وهناك قائمة انتظار لتفاعلات الشبكة ، وهناك قائمة انتظار للعمل مع قرص.  جميع قوائم الانتظار هي أمثلة لفئة WorkQueue التي تحتوي على طريقة PushTask باطلة (std :: function &lt;void ()&gt; مهمة) ؛.  تعيش قوائم الانتظار لفترة أطول من جميع المهام الموضوعة فيها (يجب ألا يحدث الموقف الذي دمرناه قائمة انتظار عندما تكون هناك مهام معلقة فيها). <br><br>  تقوم الدالة FuncToDealWith () من المثال بتنفيذ بعض المنطق في قوائم انتظار مختلفة ، وبناءً على نتائج التنفيذ ، تضع مهمة جديدة في قائمة الانتظار. <br><br>  نعيد كتابة "المعكرونة" لرد الاتصال في شكل رمز زائف خطي ، وضع علامة في قائمة الانتظار التي يجب تنفيذ التعليمات البرمجية الأساسية: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); <span class="hljs-comment"><span class="hljs-comment">// =&gt;   writerQueue InWriterThread1(); if (NeedNetwork()) { // =&gt;   networkQueue auto v = InNetworkThread(); if (v) { // =&gt;   UIQueue InUIThread(); } } // =&gt;   writerQueue InWriterThread2(); ShutdownAll(); }</span></span></code> </pre> <br>  أريد تحقيق هذه النتيجة تقريبًا. <br><br>  هناك قيود: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  لا يمكن تغيير واجهات قائمة الانتظار - يتم استخدامها في أجزاء أخرى من التطبيق من قبل مطوري الطرف الثالث.  لا يمكنك كسر رمز المطور أو إضافة مثيلات قائمة انتظار جديدة. </li><li style=";text-align:right;direction:rtl">  لا يمكنك تغيير الطريقة التي تستخدم بها الدالة FuncToDealWith.  يمكنك فقط تغيير اسمه ، ولكن لا يمكنك جعله يعيد أي أشياء يجب على المستخدم الاحتفاظ بها في المنزل. </li><li style=";text-align:right;direction:rtl">  يجب أن يكون الكود الناتج منتجًا مثل الكود الأصلي (أو حتى أكثر إنتاجية). </li></ul><br><h2 style=";text-align:right;direction:rtl">  الحل </h2><br><h3 style=";text-align:right;direction:rtl">  إعادة كتابة الدالة FuncToDealWith </h3><br>  في Coroutines TS ، يتم ضبط Coroutine عن طريق تعيين نوع القيمة المرجعة للدالة.  إذا كان النوع يفي بمتطلبات معينة ، فعندئذٍ يمكنك استخدام الكلمات الرئيسية الجديدة co_await / co_return / co_yield داخل نص الوظيفة.  في هذا المثال ، للتبديل بين قوائم الانتظار ، سنستخدم co_yield: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CoroTask </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); co_yield writerQueue; InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { co_yield networkQueue; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetworkThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { co_yield UIQueue; InUIThread(); } } co_yield writerQueue; InWriterThread2(); ShutdownAll(); }</code> </pre> <br>  اتضح أنه مشابه جدًا للرمز الكاذب من القسم الأخير.  يتم إخفاء كل "السحر" للعمل مع coroutines في فئة CoroTask. <br><br><h3 style=";text-align:right;direction:rtl">  CoroTask </h3><br>  في أبسط (في حالتنا) ، تتكون محتويات فئة "الموالف" من coroutine من اسم مستعار واحد فقط: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;experimental/coroutine&gt; struct CoroTask { using promise_type = PromiseType; };</span></span></span></span></code> </pre> <br><br>  promo_type هو نوع بيانات يجب أن نكتبه بأنفسنا.  يحتوي على منطق يصف: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  ماذا تفعل عند الخروج من coroutine </li><li style=";text-align:right;direction:rtl">  ما يجب القيام به عند إدخال كوروتين لأول مرة </li><li style=";text-align:right;direction:rtl">  الذي يحرر الموارد </li><li style=";text-align:right;direction:rtl">  ماذا تفعل مع الاستثناءات التي تطير من coroutine </li><li style=";text-align:right;direction:rtl">  كيفية إنشاء كائن CoroTask </li><li style=";text-align:right;direction:rtl">  ماذا تفعل إذا كانت داخل corutins تسمى co_yield </li></ul><br>  يجب تسمية نوع الاسم المستعار الواعد بهذه الطريقة.  إذا قمت بتغيير الاسم المستعار إلى شيء آخر ، فسوف يقسم المحول البرمجي ويقول أنك كتبت CoroTask بشكل غير صحيح.  يمكن تغيير اسم CoroTask كيفما تشاء. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">لكن لماذا يعتبر CoroTask ضروريًا إذا تم وصف كل شيء في نوع الوعد؟</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  في الحالات الأكثر تعقيدًا ، يمكنك إنشاء CoroTask التي ستسمح لك بالتواصل مع روتين موقوف ، وإرسال واستقبال البيانات منه ، وإيقاظه وتدميره. <br></div></div><br><h3 style=";text-align:right;direction:rtl">  PromiseType </h3><br>  الوصول إلى الجزء الممتع.  نصف سلوك كوروتين: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkQueue</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">// forward declaration class PromiseType { public: //      `co_return;`     , ... void return_void() const { /* ...    :) */ } //        ,  CoroTask, ... auto initial_suspend() const { // ...       . return std::experimental::suspend_never{}; } //      - , ... auto final_suspend() const { // ...        //      . return std::experimental::suspend_never{}; } //     , ... void unhandled_exception() const { // ...   (  ). std::terminate(); } //    CoroTask,    , ... auto get_return_object() const { // ...  CoroTask. return CoroTask{}; } //     co_yield, ... auto yield_value(WorkQueue&amp; wq) const; // ... &lt;  &gt; };</span></span></code> </pre> <br>  في الكود أعلاه ، يمكنك ملاحظة نوع البيانات std :: التجريبية التجريبية :: suspend_never.  هذا هو نوع بيانات خاص يقول أن Corutin لا يحتاج إلى إيقاف.  هناك أيضًا نقيضها - النوع std :: التجريبية التجريبية :: suspend_always ، الذي يخبرك بإيقاف corutin.  هذه الأنواع هي ما يسمى بانتظار.  إذا كنت مهتمًا ببنيتها الداخلية ، فلا داعي للقلق ، فسوف نكتب Awaitables قريبًا. <br><br>  أكثر مكان غير تافه في الكود أعلاه هو final_suspend ().  الوظيفة لها تأثيرات غير متوقعة.  لذا ، إذا لم نوقف التنفيذ في هذه الوظيفة ، فإن الموارد المخصصة للمرتب من قبل المترجم ستنظف المترجم من أجلنا.  ولكن إذا أوقفنا في هذه الوظيفة تنفيذ coroutine (على سبيل المثال ، عن طريق إرجاع std :: التجريبية التجريبية :: suspend_always {}) ، فسيتعين عليك تحرير الموارد يدويًا من مكان ما في الخارج: سيكون عليك حفظ مؤشر ذكي إلى coroutine في مكان ما والاتصال به صراحة تدمير ().  لحسن الحظ ، هذا ليس ضروريا لمثالنا. <br><br><h3 style=";text-align:right;direction:rtl">  <b>غير</b> صحيح PromiseType :: المحصول_قيمة </h3><br>  يبدو أن كتابة PromiseType :: extract_value بسيطة للغاية.  لدينا خط.  coroutine ، الذي يجب تعليقه ، وبالتالي وضع: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PromiseType::yield_value(WorkQueue&amp; wq) { <span class="hljs-comment"><span class="hljs-comment">//        std::experimental::coroutine_handle&lt;&gt; this_coro = std::experimental::coroutine_handle&lt;&gt;::from_promise(*this); //    .  this_coro  operator(),    // wq      .   , //     ,  operator(),  //   . wq.PushTask(this_coro); //     . return std::experimental::suspend_always{}; }</span></span></code> </pre> <br>  وهنا نواجه مشكلة كبيرة جدًا ويصعب اكتشافها.  والحقيقة هي أننا وضعنا أولاً اللقاحات في الطابور ثم نعلقها فقط.  قد يحدث أن يتم إزالة coroutine من قائمة الانتظار ويبدأ تنفيذه حتى قبل أن نعلقه في الخيط الحالي.  سيؤدي هذا إلى حالة سباق ، وسلوك غير محدد وأخطاء وقت التشغيل المجنونة تمامًا. <br><br><h3 style=";text-align:right;direction:rtl">  PromiseType <b>الصحيح</b> : * الناتج_القيمة </h3><br>  لذلك ، نحتاج أولاً إلى إيقاف corutin ثم إضافته فقط إلى قائمة الانتظار.  للقيام بذلك ، سوف نكتب Awaitable الخاص بنا ونطلق عليه الجدول الزمني_للإعدام: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PromiseType::yield_value(WorkQueue&amp; wq) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">schedule_for_execution</span></span></span><span class="hljs-class"> {</span></span> WorkQueue&amp; wq; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_ready</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_suspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::experimental::coroutine_handle&lt;&gt; this_coro)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ wq.PushTask(this_coro); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> schedule_for_execution{wq}; }</code> </pre> <br>  يجب أن تحتوي الفئات std :: التجريبية التجريبية :: suspend_always و std :: التجريبية التجريبية :: suspend_never و Schedule_for_execution و Awaitables الأخرى على 3 وظائف.  يتم استدعاء await_ready للتحقق مما إذا كان يجب إيقاف coroutine.  يتم استدعاء await_suspend بعد إيقاف البرنامج ، ويتم تمرير مقبض coroutine توقف إليه.  يسمى await_resume عند استئناف تنفيذ coroutine. <br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">وماذا يمكن كتابته في skrabs الثلاثي std :: التجريبية :: coroutine_handle &lt;&gt;؟</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  يمكنك تحديد نوع PromiseType هناك ، وسيعمل المثال بنفس الطريقة تمامًا :) <br><br>  std :: التجريبية: :: coroutine_handle &lt;&gt; (الملقب بـ std :: التجريبية: :: coroutine_handle &lt;void&gt;) هو النوع الأساسي لجميع std :: التجريبية: :: coroutine_handle &lt;DataType&gt; ، حيث يجب أن يكون DataType هو نوع_النوع لـ coroutine الحالي.  إذا لم تكن بحاجة إلى الوصول إلى المحتويات الداخلية لـ DataType ، فيمكنك كتابة std :: التجريبية التجريبية :: coroutine_handle &lt;&gt;.  يمكن أن يكون ذلك مفيدًا في الأماكن التي تريد فيها التجريد من نوع معين من نوع prom_type واستخدام نوع المحو. <br></div></div><br><h3 style=";text-align:right;direction:rtl">  تم </h3><br>  يمكنك <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تجميع وتشغيل المثال عبر الإنترنت والتجربة بكل طريقة</a> . <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">وإذا لم أكن أحب co_yield ، فهل يمكنني استبداله بشيء؟</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  يمكن استبداله ب co_await.  للقيام بذلك ، قم بإضافة الوظيفة التالية إلى PromiseType: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WorkQueue&amp; wq)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> yield_value(wq); }</code> </pre><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">ولكن ماذا لو لم أكن أحب co_await؟</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  الشيء سيئ.  لا شيء يتغير. <br></div></div><br></div></div><br><h3 style=";text-align:right;direction:rtl">  ورقة الغش </h3><br>  CoroTask هي فئة تضبط سلوك كوروتين.  في الحالات الأكثر تعقيدًا ، يسمح لك بالتواصل مع كوروتين متوقف وأخذ أي بيانات منه. <br><br>  CoroTask :: وعد_يصف كيف ومتى تتوقف coroutines ، وكيفية تحرير الموارد ، وكيفية بناء CoroTask. <br><br>  Awaitables (std :: التجريبية: :: suspend_always و std :: التجريبية: suspend_never و Schedule_for_execution وغيرها) تخبر المترجم بما يجب فعله مع coroutine في نقطة معينة (ما إذا كان من الضروري إيقاف corutin ، وما يجب فعله مع توقف corutin وما يجب فعله عندما يستيقظ corutin) . <br><br><h3 style=";text-align:right;direction:rtl">  التحسينات </h3><br>  يوجد خلل في PromiseType.  حتى إذا كنا نعمل حاليًا في قائمة انتظار المهام الصحيحة ، فسيستمر استدعاء co_yield في تعليق النظام الأساسي وإعادة وضعه في قائمة انتظار المهام نفسها.  سيكون من الأفضل بكثير عدم إيقاف تنفيذ coroutine ، ولكن لمواصلة التنفيذ على الفور. <br><br>  دعونا نصلح هذا العيب.  للقيام بذلك ، قم بإضافة حقل خاص إلى PromiseType: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">WorkQueue* current_queue_ = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>;</code> </pre> <br>  في ذلك ، سوف نحتفظ بمؤشر إلى قائمة الانتظار التي نقوم بتنفيذها حاليًا. <br><br>  بعد ذلك ، قرص نوع PromiseType ::: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PromiseType::yield_value(WorkQueue&amp; wq) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">schedule_for_execution</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> do_resume; WorkQueue&amp; wq; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_ready</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_resume; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_suspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::experimental::coroutine_handle&lt;&gt; this_coro)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ wq.PushTask(this_coro); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> do_not_suspend = (current_queue_ == &amp;wq); current_queue_ = &amp;wq; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> schedule_for_execution{do_not_suspend, wq}; }</code> </pre> <br>  هنا قمنا بتعديل الجدول الزمني للالتنفيذ :: await_ready ().  الآن تخبر هذه الوظيفة المترجم أنه لا يلزم تعليق coroutine إذا كانت قائمة انتظار المهام الحالية تتطابق مع تلك التي نحاول البدء بها. <br><br>  تم.  يمكنك <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تجربة بكل طريقة</a> . <br><br><h2 style=";text-align:right;direction:rtl">  عن الأداء </h2><br>  في المثال الأصلي ، مع كل استدعاء لـ WorkQueue :: PushTask (std :: function &lt;void ()&gt; f) ، أنشأنا مثيلًا للفئة std :: function &lt;void ()&gt; من lambda.  في الشفرة الحقيقية ، غالبًا ما تكون هذه الأحجار الكبيرة كبيرة الحجم ، ولهذا السبب يضطر std :: function &lt;void ()&gt; إلى تخصيص الذاكرة ديناميكيًا لتخزين lambdas. <br><br>  في مثال Coroutine ، نقوم بإنشاء حالات std :: function &lt;void ()&gt; من std :: التجريبية التجريبية :: coroutine_handle &lt;&gt;.  يعتمد حجم std :: التجريبية: :: coroutine_handle &lt;&gt; على التنفيذ ، لكن معظم التطبيقات تحاول إبقاء حجمها عند الحد الأدنى.  لذا ، في صلصلة ، حجمها يساوي sizeof (باطل *).  عند إنشاء std :: function &lt;void ()&gt; ، لا يتم التخصيص الديناميكي من الكائنات الصغيرة. <br>  الإجمالي - مع Coroutines ، تخلصنا من العديد من التخصيصات الديناميكية غير الضرورية. <br><br>  لكن!  لا يستطيع المحول البرمجي في الغالب حفظ كل المحتوى على المكدس.  وبسبب هذا ، يمكن تخصيص ديناميكي إضافي واحد عند دخول CoroToDealWith. <br><br><h2 style=";text-align:right;direction:rtl">  مكدس مقابل مكدس </h2><br>  لقد عملنا للتو مع Coroutines Stackless ، والتي تتطلب الدعم من المترجم للعمل معها.  هناك أيضًا Coroutines المكدسة التي يمكن تنفيذها بالكامل على مستوى المكتبة. <br><br>  أولها يسمح بتخصيص أكثر اقتصادية للذاكرة ، ومن المحتمل أن يتم تحسينها بشكل أفضل من قبل المترجم.  أما الثانية فهي أسهل في التنفيذ في المشاريع القائمة ، لأنها تتطلب تعديلات أقل على الكود.  ومع ذلك ، في هذا المثال لا يمكنك أن تشعر بالفرق ، فهناك حاجة إلى أمثلة أكثر تعقيدًا. <br><br><h2 style=";text-align:right;direction:rtl">  الملخص </h2><br>  لقد درسنا المثال الأساسي وحصلنا على CoroTask من فئة عالمية ، والتي يمكن استخدامها لإنشاء كوروتينات أخرى. <br><br>  تصبح الشفرة معها أكثر قابلية للقراءة وأكثر إنتاجية قليلاً من النهج الساذج: <br><table style=";text-align:right;direction:rtl"><tbody><tr><th>  كان </th><th>  مع coroutines </th></tr><tr><td><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FuncToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); writerQueue.PushTask([=]() { InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> fin = [=]() { InWriterThread2(); ShutdownAll(); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { networkQueue.PushTask([=](){ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { UIQueue.PushTask([=](){ InUIThread(); writerQueue.PushTask(fin); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { writerQueue.PushTask(fin); } }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fin(); } }); }</code> </pre></td><td><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CoroTask </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); co_yield writerQueue; InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { co_yield networkQueue; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { co_yield UIQueue; InUIThread(); } } co_yield writerQueue; InWriterThread2(); ShutdownAll(); }</code> </pre> </td></tr></tbody></table><br>  كانت هناك لحظات: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  كيفية استدعاء coroutine آخر من corutin وانتظار اكتماله </li><li style=";text-align:right;direction:rtl">  ما هي الأشياء المفيدة التي يمكنك حشرها في CoroTask </li><li style=";text-align:right;direction:rtl">  مثال يجعل الفرق بين Stackless و Stackful </li></ul><br><h2 style=";text-align:right;direction:rtl">  أخرى </h2><br>  إذا كنت ترغب في التعرف على المستجدات الأخرى للغة C ++ أو التواصل شخصيًا مع زملائك على الإيجابيات ، فقم بإلقاء نظرة على مؤتمر C ++ Russia.  وستعقد الجلسة التالية <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">في 6 أكتوبر في نيجني نوفغورود</a> . <br><br>  إذا كان لديك ألم مرتبط بـ C ++ وتريد تحسين شيء ما في اللغة أو تريد فقط مناقشة الابتكارات المحتملة ، فمرحبًا بك في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://stdcpp.ru/</a> . <br><br>  حسنًا ، إذا فاجأك أن Yandex.Taxi لديه عدد كبير من المهام التي لا تتعلق بالرسوم البيانية ، فعندئذ آمل أن يكون هذا مفاجأة سارة لك :) تعال <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">لزيارتنا في 11 أكتوبر</a> ، سنتحدث عن C ++ والمزيد. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar420861/">https://habr.com/ru/post/ar420861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar420845/index.html">ترويض المولود باستخدام عكاز: فتحة محول Wi-Fi WF2190 (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../ar420847/index.html">مقدمة في برمجة Shader للتخطيطات</a></li>
<li><a href="../ar420853/index.html">تعرف على Windows Pseudo Console (ConPTY)</a></li>
<li><a href="../ar420857/index.html">التجوال السلس عبر شبكة Wi-Fi: النظرية في التطبيق</a></li>
<li><a href="../ar420859/index.html">لمسألة ويرث وسلاسل</a></li>
<li><a href="../ar420863/index.html">كما فعلنا أول هاتف ذكي روسي ، تابع</a></li>
<li><a href="../ar420865/index.html">مبدأ العمل الأقل. الجزء الأول</a></li>
<li><a href="../ar420867/index.html">حساب التكاملات المحددة: الخوارزميات الأساسية</a></li>
<li><a href="../ar420869/index.html">الإخلاء ، HAMR و MAMR - ثلاث طرق لزيادة قدرة محركات الأقراص الصلبة الحديثة إلى الحد الأقصى</a></li>
<li><a href="../ar420871/index.html">كيف نقلنا استوديو الويب في بالي</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>