<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👍 👨🏿‍🔧 🖱️ LogRock：通过记录进行测试 🧑🏽‍🤝‍🧑🏽 📘 👨🏽‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="LogRock：通过记录进行测试 
 两年多来，我们一直在进行Cleverbrush项目。 这是用于处理矢量图形的软件。 使用图形编辑器意味着大量的应用程序用例。 我们试图节省金钱和时间，因此我们优化了包括测试在内的所有内容。 用每个选项覆盖测试用例过于昂贵且不合理，尤其是因为不可能覆盖所有选项。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>LogRock：通过记录进行测试</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453652/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a0/8fe/e87/0a08fee87984969110aef2080f4687ae.png" alt="洛格洛克"></div><br><h2>  LogRock：通过记录进行测试 </h2><br> 两年多来，我们一直<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在进行Cleverbrush</a>项目。 这是用于处理矢量图形的软件。 使用图形编辑器意味着大量的应用程序用例。 我们试图节省金钱和时间，因此我们优化了包括测试在内的所有内容。 用每个选项覆盖测试用例过于昂贵且不合理，尤其是因为不可能覆盖所有选项。 <br><br> 在开发过程中，创建了一个用于React JS应用程序的模块<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-LogRock（github）</a> 。 <br><br> 该模块允许您组织现代日志记录应用程序。 根据日志，我们进行测试。 在本文中，我将向您介绍使用此模块的复杂性以及如何通过日志记录组织测试。 <br><a name="habracut"></a><br><h2> 怎么了 </h2><br> 如果将程序与活生物体进行比较，则其中的错误是一种疾病。 该“疾病”的原因可能是多种因素，包括特定用户的环境。 如果我们正在考虑使用Web平台，则尤其如此。 有时因果关系非常复杂，并且在测试过程中发现的错误是许多事件的结果。 <br><br> 与人类疾病一样，没有人会比患者更好地解释其症状，没有测试者能够比程序本身更好地说明发生了什么。 <br><br><h2> 怎么办 </h2><br> 要了解正在发生的事情，我们需要用户在我们的应用程序中执行的操作的列表。 <br><br> 为了使我们的程序本身可以告诉我们它的“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">缺点</a> ”，我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LogRock</a>模块<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">（github）</a>并将其与ElasticSearch，LogStash和Kibana关联。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d4/1d6/7ea/6d41d67ea5bd247827fd03948fc8b0dd.png" alt="图片"></div><br>  <b>ElasticSearch</b>是功能强大的全文本搜索引擎。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>观看ElasticSearch教程。 <br>  <b>LogStash</b>是一个用于从各种来源收集日志的系统，该系统可以将日志发送到ElasticSearch。 <br>  <b>Kibana</b>是带有许多附加组件的<b>ElasticSearch</b>的Web界面。 <br><br><h2> 如何运作？ </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcf/06e/706/dcf06e706a5ae052a2f15eaf09e45c93.png" alt="图片"></div><br> 如果发生错误（或仅按需提供），则应用程序会将日志发送到服务器，然后将日志保存到文件中。  Logstash将ElasticSearch中的数据逐步保存到数据库中。 用户登录到Kibana并查看保存的日志。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e19/0b0/244/e190b0244b22db314385b5156e5c56cd.png" alt="图片"></div><br> 看起来像是经过精心调校的Kibana。 它显示来自ElasticSearch的数据。  Kibana可以表格，图表，地图等形式显示数据，这对于分析和了解我们的应用程序正在发生的事情非常方便。 <br><br>  <b><u>在本文中，我不会讨论设置ElasticStack！</u></b> <br><br><h2> 创建一个日志系统 </h2><br> 作为示例，我们将日志记录系统集成到用React编写的一页JS应用程序中。 您的应用程序将在哪种框架上编写都没有关系。 我将尝试描述构建日志系统本身的方法。 <br><br><h3>  1.客户 </h3><br><h4>  1.0 LogRock。 安装方式 </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接到LogRock</a> <br><br> 要安装，您必须执行： <br><br><pre><code class="bash hljs">npm install logrock  yarn add logrock</code> </pre> <br><h4>  1.1 LogRock。 应用设置 </h4><br> 首先，将我们的应用程序包装在一个组件中 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LoggerContainer } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"logrock"</span></span>; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LoggerContainer</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LoggerContainer</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  LoggerContainer是响应您的应用程序错误并形成堆栈的组件。 <br><br> 堆栈是一个对象，其中包含有关用户的操作系统，浏览器，按下的鼠标或键盘按钮以及操作子数组的信息，其中记录了他在我们的系统中执行的所有用户操作。 <br><br>  LoggerContainer有许多设置，请考虑其中的一些 <br><br><pre> <code class="javascript hljs">&lt;LoggerContainer active={<span class="hljs-literal"><span class="hljs-literal">true</span></span>|<span class="hljs-literal"><span class="hljs-literal">false</span></span>} limit={<span class="hljs-number"><span class="hljs-number">20</span></span>} onError={stack =&gt; { sendToServer(stack); }} &gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LoggerContainer</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  active-启用或禁用记录器 <br><br> 限制-设置用户最近保存的操作数量的限制。 如果用户执行21个动作，则该数组中的第一个动作将被自动删除。 因此，我们将获得错误之前的最后20个动作。 <br><br>  onError-发生错误时调用的回调。  Stack对象进入其中，其中存储了有关环境，用户操作等的所有信息。 正是从此回调中，我们需要将此数据发送到ElasticSearch或后端，或将其保存到文件中以进行进一步的分析和监视。 <br><br><h4>  1.2 LogRock。 记录中 </h4><br> 为了对用户操作进行高质量的日志记录，我们将不得不通过日志调用覆盖我们的代码。 <br><br>  LogRock模块随附与LoggerContainer关联的记录器 <br><br> 假设我们有一个组件 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { useState } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [toggleState, setToggleState] = useState(<span class="hljs-string"><span class="hljs-string">"off"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toggle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ setToggleState(toggleState === <span class="hljs-string"><span class="hljs-string">"off"</span></span> ? <span class="hljs-string"><span class="hljs-string">"on"</span></span> : <span class="hljs-string"><span class="hljs-string">"off"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">`</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">switch</span></span></span></span><span class="xml"><span class="hljs-tag"> ${</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">toggleState</span></span></span></span><span class="xml"><span class="hljs-tag">}`} </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{toggle}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">; }</span></span></code> </pre> <br> 为了用日志正确覆盖它，我们需要修改toggle方法 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toggle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = toggleState === <span class="hljs-string"><span class="hljs-string">"off"</span></span> ? <span class="hljs-string"><span class="hljs-string">"on"</span></span> : <span class="hljs-string"><span class="hljs-string">"off"</span></span>; logger.info(<span class="hljs-string"><span class="hljs-string">`React.Toggle|Toggle component changed state </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${state}</span></span></span><span class="hljs-string">`</span></span>); setToggleState(state); }</code> </pre> <br> 我们添加了一个记录器，其中信息分为两部分。  React.Toggle向我们展示了该动作发生在React的Toggle组件级别，然后我们对该动作和该组件的当前状态进行了口头解释。 这样的分层是没有必要的，但是通过这种方法，将更清楚地知道我们的代码在何处执行。 <br><br> 如果发生错误，我们还可以使用React版本16中引入的“ componentDidCatch”方法。 <br><br><h4>  2.服务器交互 </h4><br> 考虑以下示例。 <br><br> 假设我们有一个从后端收集用户数据的方法。 该方法是异步的，部分逻辑隐藏在后端中。 如何正确记录此代码？ <br><br> 首先，由于我们有一个客户端应用程序，所有发送到服务器的请求都将通过一个用户会话，而无需重新加载页面。 为了将客户端上的操作与服务器上的操作相关联，我们必须创建一个全局SessionID并将其添加到对服务器的每个请求的标头中。 在服务器上，我们可以使用任何记录器来记录我们的逻辑，例如从前端获取示例，并且在发生错误的情况下，将带有Elastic中附加的sessionID的该数据发送到后端板。 <br><br>  1.我们在客户端上生成SessionID <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.SESSION_ID = <span class="hljs-string"><span class="hljs-string">`sessionid-</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">Math</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.random().toString(</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">36</span></span></span></span><span class="hljs-string"><span class="hljs-subst">).substr(</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">9</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">`</span></span>;</code> </pre> <br>  2.我们必须为对服务器的所有请求设置SessionID。 如果我们使用库进行查询，则通过为所有查询声明一个SessionID非常简单。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fetch = axios.create({...}); fetch.defaults.headers.common.sessionId = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.SESSION_ID;</code> </pre> <br>  3.在LoggerContainer中，SessionID有一个特殊字段 <br><br><pre> <code class="javascript hljs">&lt;LoggerContainer active={<span class="hljs-literal"><span class="hljs-literal">true</span></span>|<span class="hljs-literal"><span class="hljs-literal">false</span></span>} sessionID={<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.SESSION_ID} limit={<span class="hljs-number"><span class="hljs-number">20</span></span>} onError={stack =&gt; { sendToServer(stack); }} &gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LoggerContainer</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  4.请求本身（在客户端上）将如下所示： <br><br><pre> <code class="javascript hljs">logger.info(<span class="hljs-string"><span class="hljs-string">`store.getData|User is ready for loading... User ID is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${id}</span></span></span><span class="hljs-string">`</span></span>); getData(<span class="hljs-string"><span class="hljs-string">'/api/v1/user'</span></span>, { id }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">userData</span></span></span><span class="hljs-function"> =&gt;</span></span> { logger.info(<span class="hljs-string"><span class="hljs-string">`store.getData|User have already loaded. User count is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">JSON</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.stringify(userData)}</span></span></span><span class="hljs-string">`</span></span>); }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> { logger.error(<span class="hljs-string"><span class="hljs-string">`store.getData|User loaded fail </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${err.message}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre> <br> 一切如何工作：我们在客户端请求之前记录日志。 根据我们的代码，我们看到现在将开始从服务器加载数据。 我们已将SessionID附加到请求。 如果我们的后端被添加了该SessionID的日志覆盖，并且请求失败，那么我们可以看到后端发生了什么。 <br><br> 因此，我们不仅在客户端而且还在后端监视应用程序的整个周期。 <br><br><h4>  3.测试人员 </h4><br> 与测试人员一起工作应该对过程进行单独描述。 <br><br> 由于我们有一家初创公司，所以我们没有正式的要求，有时工作中的一切都不合逻辑。 <br><br> 如果测试人员不了解该行为，则至少需要考虑这种情况。 同样，测试人员经常无法重复一种情况两次。 由于导致不正确行为的步骤可能很繁琐，而且很简单。 而且，并非所有错误都会导致严重后果，例如Exception。 其中一些只能更改应用程序的行为，而不能被系统解释为错误。 为此，在登台时，您可以在应用程序标题中添加一个按钮以强制发送日志。 测试人员发现有些东西无法正常工作，单击按钮，然后将包含操作的堆栈发送到ElasticSearch。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/553/154/7f0/5531547f03a044eda98449e829d67839.png" alt="图片"></div><br><br> 但是，如果发生了严重错误，我们必须阻塞该接口，以使测试仪不会进一步单击并且不会陷入死胡同。 <br><br> 为此，我们显示死亡的蓝屏。 <br><br> 我们在顶部看到带有此严重错误的堆栈的文本，在下面看到的是其之前的操作。 我们还会获得错误ID，测试人员只需选择它并将其附加到故障单上即可。 稍后，可以使用此ID在Kibana中轻松找到此错误。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f3/5b8/4b7/7f35b84b746e584111ce64e6416e1f36.png" alt="图片"></div><br> 为此，LoggerContainer具有自己的属性。 <br><br><pre> <code class="javascript hljs">&lt;LoggerContainer active={<span class="hljs-literal"><span class="hljs-literal">true</span></span>|<span class="hljs-literal"><span class="hljs-literal">false</span></span>} limit={<span class="hljs-number"><span class="hljs-number">20</span></span>} bsodActive={<span class="hljs-literal"><span class="hljs-literal">true</span></span>} bsod={BSOD} onError={stack =&gt; { sendToServer(stack); }} &gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LoggerContainer</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  bsodActive-启用/禁用BSOD（禁用BSOD适用于生产代码） <br><br>  bsod是一个组件。 默认情况下，它看起来像上面的屏幕截图。 <br><br> 要在UI LoggerContainer中显示按钮，我们可以在上下文中使用 <br><br><pre> <code class="javascript hljs">context.logger.onError(context.logger.getStackData());</code> </pre> <br><h4>  4. LogRock。 用户互动 </h4><br> 您可以将日志输出到控制台或将其显示给用户，为此，您需要使用stdout方法： <br><br><pre> <code class="javascript hljs">&lt;LoggerContainer active={<span class="hljs-literal"><span class="hljs-literal">true</span></span>|<span class="hljs-literal"><span class="hljs-literal">false</span></span>} limit={<span class="hljs-number"><span class="hljs-number">20</span></span>} bsodActive={<span class="hljs-literal"><span class="hljs-literal">true</span></span>} bsod={BSOD} onError={stack =&gt; { sendToServer(stack); }} stdout={(level, message, important) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>[level](message); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (important) { alert(message); } }} &gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LoggerContainer</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  stdout是负责显示消息的方法。 <br><br> 为了使消息变得重要，只需将第二个参数true传递给记录器就足够了。 因此，该消息可以在弹出窗口中显示给用户，例如，如果数据加载失败，我们可以显示错误消息。 <br><br><pre> <code class="javascript hljs">logger.log(<span class="hljs-string"><span class="hljs-string">'Something was wrong'</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br><h3> 进阶记录 </h3><br> 如果您在一个商店中使用Redux或类似的解决方案，则可以将记录器放入处理您的操作的中间件中，从而所有重要操作都将通过我们的系统。 <br><br> 为了有效地进行日志记录，您可以将数据包装在代理对象中，并使记录器执行与该对象有关的所有操作。 <br><br> 要使用日志记录覆盖第三方方法（库方法，旧版代码方法），可以使用修饰符-“ @”。 <br><br><h3> 小费 </h3><br> 记录包括生产在内的应用程序，因为比真实用户要好，因此没有测试者会发现任何瓶颈。 <br><br> 不要忘记在许可协议中指明日志的收集。 <br><br>  <b>请勿记录密码，银行详细信息和其他个人信息！</b> <br><br> 日志的冗余性也很差，请使签名尽可能清晰。 <br><br><h3> 替代品 </h3><br> 作为替代方法，我强调： <br><br><ul><li>  Rollbar是高度可定制的。 每月只需​​$ 150，即可记录500,000个错误。 如果您是从头开始开发应用程序，则建议使用它。 </li><li>  Sentry易于集成，但可定制性较低。 允许您以每月$ 200的价格记录100万个事件。 </li></ul><br> 两种服务都使您可以做几乎相同的事情并集成到后端中。 <br><br><h3> 接下来是什么 </h3><br> 日志记录不仅是查找错误的信息，还监视用户的操作，数据收集。 日志记录可以很好地补充Google Analytics（分析）和用户体验测试。 <br><br><h3> 结论 </h3><br> 当您发布该应用程序时，他的生活才刚刚开始。 对自己的想法负责，获取反馈，监控日志并加以改进。 编写高质量的软件并繁荣发展:) <br><br>  PS如果您想为Angular，Vue等模块的开发提供帮助 我很高兴在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>提出请求。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN453652/">https://habr.com/ru/post/zh-CN453652/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN453634/index.html">阿尔法银行系统分析学院</a></li>
<li><a href="../zh-CN453642/index.html">智能解析器，用文字书写数字</a></li>
<li><a href="../zh-CN453644/index.html">面试-关于Swift的10个问题。 第三部分</a></li>
<li><a href="../zh-CN453646/index.html">分布式数据库，微服务和ERP中的数据标准化</a></li>
<li><a href="../zh-CN453650/index.html">统一打击战斗机F-35的车载网络基础设施的软件核心</a></li>
<li><a href="../zh-CN453656/index.html">静态网：回到基础？</a></li>
<li><a href="../zh-CN453660/index.html">英特尔推出新的i9-9900KS处理器，每个内核具有5 GHz Turbo频率</a></li>
<li><a href="../zh-CN453662/index.html">火星-北极的冰层更多，但更深</a></li>
<li><a href="../zh-CN453664/index.html">Spring Boot-OAuth2和JWT</a></li>
<li><a href="../zh-CN453666/index.html">我如何乘坐无人出租车</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>