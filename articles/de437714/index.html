<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏽 👨🏻‍🎓 👨🏿‍💼 Wir zeichnen eine Cartoon-Explosion für 180 Zeilen nacktes C ++ 👩🏾‍🚒 🙍🏼 ⛹️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einer Woche habe ich ein weiteres Kapitel aus meinem Computergrafik-Vorlesungskurs veröffentlicht . Heute kehren wir wieder zum Raytracing zurück,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir zeichnen eine Cartoon-Explosion für 180 Zeilen nacktes C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437714/"> Vor einer Woche habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein weiteres Kapitel</a> aus meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Computergrafik-Vorlesungskurs veröffentlicht</a> .  Heute kehren wir wieder zum Raytracing zurück, aber diesmal gehen wir etwas weiter als das Rendern trivialer Kugeln.  Ich brauche keinen Fotorealismus, für Comic-Zwecke wird eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">solche Explosion</a> , so scheint es mir, niedergehen. <br><br>  Wie immer steht uns nur ein Bare-Compiler zur Verfügung, es können keine Bibliotheken von Drittanbietern verwendet werden.  Ich möchte mich nicht mit Fenstermanagern, Maus- / Tastaturverarbeitung und dergleichen beschäftigen.  Das Ergebnis unseres Programms ist ein einfaches Bild, das auf der Festplatte gespeichert wird.  Ich jage überhaupt nicht nach Geschwindigkeit / Optimierung, mein Ziel ist es, die Grundprinzipien zu zeigen. <br><br>  Wie kann man unter solchen Bedingungen insgesamt ein solches Bild in 180 Codezeilen zeichnen? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/052/265/365/052265365c5c2a1da16850f7e0cb6eb1.jpg"><br><a name="habracut"></a><br>  Lassen Sie mich sogar ein animiertes GIF (sechs Meter) einfügen: <br><br><img src="https://github.com/ssloy/tinykaboom/raw/master/kaboom.gif"><br><br>  Und jetzt werden wir die gesamte Aufgabe in mehrere Phasen unterteilen: <br><br><h1>  Stufe eins: Lesen Sie den vorherigen Artikel </h1><br>  Ja, das ist so.  Das allererste, was Sie tun müssen, ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherige Kapitel</a> zu lesen, in dem die Grundlagen des Raytracing behandelt werden.  Es ist im Prinzip sehr kurz, alle Reflexionen-Brechungen können nicht gelesen werden, aber zumindest bis zur diffusen Beleuchtung empfehle ich, es zu lesen.  Der Code ist recht einfach, die Leute führen ihn sogar auf Mikrocontrollern aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc7/080/0d1/cc70800d1c9d4263579068543833351d.gif"><br><br><h1>  Stufe zwei: Zeichne eine Kugel </h1><br>  Zeichnen wir eine Kugel, ohne uns um Materialien oder Beleuchtung zu kümmern.  Der Einfachheit halber wird diese Kugel im Zentrum der Koordinaten leben.  Über dieses Bild möchte ich bekommen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/384/491/07f/38449107fec46a30b60ea125a61180e7.jpg"><br><br>  Sehen Sie sich den Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier an</a> , aber lassen Sie mich Ihnen den wichtigsten direkt im Text des Artikels geben: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _USE_MATH_DEFINES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;limits&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include "geometry.h" const float sphere_radius = 1.5; float signed_distance(const Vec3f &amp;p) { return p.norm() - sphere_radius; } bool sphere_trace(const Vec3f &amp;orig, const Vec3f &amp;dir, Vec3f &amp;pos) { pos = orig; for (size_t i=0; i&lt;128; i++) { float d = signed_distance(pos); if (d &lt; 0) return true; pos = pos + dir*std::max(d*0.1f, .01f); } return false; } int main() { const int width = 640; const int height = 480; const float fov = M_PI/3.; std::vector&lt;Vec3f&gt; framebuffer(width*height); #pragma omp parallel for for (size_t j = 0; j&lt;height; j++) { // actual rendering loop for (size_t i = 0; i&lt;width; i++) { float dir_x = (i + 0.5) - width/2.; float dir_y = -(j + 0.5) + height/2.; // this flips the image at the same time float dir_z = -height/(2.*tan(fov/2.)); Vec3f hit; if (sphere_trace(Vec3f(0, 0, 3), Vec3f(dir_x, dir_y, dir_z).normalize(), hit)) { // the camera is placed to (0,0,3) and it looks along the -z axis framebuffer[i+j*width] = Vec3f(1, 1, 1); } else { framebuffer[i+j*width] = Vec3f(0.2, 0.7, 0.8); // background color } } } std::ofstream ofs("./out.ppm", std::ios::binary); // save the framebuffer to file ofs &lt;&lt; "P6\n" &lt;&lt; width &lt;&lt; " " &lt;&lt; height &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; height*width; ++i) { for (size_t j = 0; j&lt;3; j++) { ofs &lt;&lt; (char)(std::max(0, std::min(255, static_cast&lt;int&gt;(255*framebuffer[i][j])))); } } ofs.close(); return 0; }</span></span></span></span></code> </pre> <br>  Die Vektorklasse befindet sich in der Dateiometry.h, ich werde sie hier nicht beschreiben: Erstens ist dort alles trivial, einfache Manipulation von zwei- und dreidimensionalen Vektoren (Addition, Subtraktion, Zuweisung, Multiplikation mit einem Skalar, Skalarprodukt) und zweitens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">gbg</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hat</a> es bereits im Rahmen einer Vorlesung über Computergrafik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausführlich beschrieben</a> . <br><br>  Ich speichere das Bild im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ppm-Format</a> .  Dies ist der einfachste Weg zum Speichern von Bildern, jedoch nicht immer der bequemste für die weitere Anzeige. <br><br>  In der main () -Funktion habe ich also zwei Zyklen: Der zweite Zyklus speichert das Bild einfach auf der Festplatte, und der erste Zyklus durchläuft alle Pixel des Bildes, sendet einen Strahl von der Kamera durch dieses Pixel aus und prüft, ob dieser Strahl unsere Kugel schneidet. <br><br>  <b>Achtung, die Hauptidee des Artikels:</b> Wenn wir im letzten Artikel den Schnittpunkt eines Strahls und einer Kugel analytisch betrachtet haben, zähle ich ihn jetzt numerisch.  Die Idee ist einfach: Die Kugel hat eine Gleichung der Form x ^ 2 + y ^ 2 + z ^ 2 - r ^ 2 = 0;  aber im allgemeinen ist die Funktion f (x, y, z) = x ^ 2 + y ^ 2 + z ^ 2 - r ^ 2 im gesamten Raum definiert.  Innerhalb der Kugel hat die Funktion f (x, y, z) negative Werte und außerhalb der Kugel ist sie positiv.  Das heißt, die Funktion f (x, y, z) legt den Abstand (mit einem Vorzeichen!) Zu unserer Kugel für den Punkt (x, y, z) fest.  Deshalb gleiten wir einfach entlang des Strahls, bis uns entweder langweilig wird oder die Funktion f (x, y, z) negativ wird.  Die Kugel_trace () -Funktion macht genau das. <br><br><h1>  Stufe drei: Primitive Beleuchtung </h1><br>  Lassen Sie uns die einfachste diffuse Beleuchtung codieren. Ich möchte ein solches Bild am Ausgang erhalten: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b5/a6b/9e6/7b5a6b9e6d05c103b630ffeb6f10018e.jpg"><br><br>  Wie im vorherigen Artikel habe ich zur Vereinfachung des Lesens einen Schritt = ein Commit ausgeführt.  Änderungen sind hier zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sehen</a> . <br><br>  Für diffuses Licht reicht es nicht aus, den Schnittpunkt des Strahls mit der Oberfläche zu berechnen. Wir müssen den Normalenvektor zur Oberfläche an diesem Punkt kennen.  Ich habe diesen Normalenvektor durch einfache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">endliche Unterschiede</a> in unserer Funktion des Abstands zur Oberfläche erhalten: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distance_field_normal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;pos)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> eps = <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d = signed_distance(pos); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> nx = signed_distance(pos + Vec3f(eps, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)) - d; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ny = signed_distance(pos + Vec3f(<span class="hljs-number"><span class="hljs-number">0</span></span>, eps, <span class="hljs-number"><span class="hljs-number">0</span></span>)) - d; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> nz = signed_distance(pos + Vec3f(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, eps)) - d; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec3f(nx, ny, nz).normalize(); }</code> </pre><br>  Im Prinzip kann natürlich, da wir eine Kugel zeichnen, die Normalität viel einfacher erhalten werden, aber ich habe dies mit einer Reserve für die Zukunft getan. <br><br><h1>  Stufe vier: Zeichnen wir ein Muster auf unsere Kugel </h1><br>  Und lassen Sie uns zum Beispiel ein Muster in unserer Region zeichnen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/061/6cd/67a/0616cd67af48498b5ef3876f9b3e9754.jpg"><br><br>  Dazu habe ich im vorherigen Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nur zwei Zeilen</a> geändert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">!</a> <br><br>  Wie habe ich das gemacht?  Natürlich habe ich keine Texturen.  Ich habe gerade die Funktion g (x, y, z) = sin (x) * sin (y) * sin (z) genommen;  es wird wieder im gesamten Raum definiert.  Wenn mein Strahl irgendwann die Kugel kreuzt, bestimmt der Wert der Funktion g (x, y, z) an diesem Punkt die Farbe des Pixels für mich. <br><br>  Achten Sie übrigens auf konzentrische Kreise um die Kugel - dies sind Artefakte meiner numerischen Berechnung des Schnittpunkts. <br><br><h1>  Fünfter Schritt: Verschiebungsabbildung </h1><br>  Warum wollte ich dieses Muster zeichnen?  Und er wird mir helfen, einen solchen Igel zu zeichnen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fae/28b/583/fae28b583626fc4b44706a465dc3f328.jpg"><br><br>  Wo mein Muster schwarz war, möchte ich ein Loch in unsere Kugel schieben, und wo es weiß war, strecken Sie im Gegenteil den Buckel. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ändern</a> Sie dazu einfach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die drei Zeilen</a> in unserem Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signed_distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;p)</span></span></span><span class="hljs-function"> </span></span>{ Vec3f s = Vec3f(p).normalize(sphere_radius); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> displacement = <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>*sx)*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>*sy)*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>*sz)*noise_amplitude; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.norm() - (sphere_radius + displacement); }</code> </pre><br>  Das heißt, ich habe die Berechnung des Abstands zu unserer Oberfläche geändert und ihn als x ^ 2 + y ^ 2 + z ^ 2 - r ^ 2 - sin (x) * sin (y) * sin (z) definiert.  Tatsächlich haben wir eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">implizite Funktion</a> definiert. <br><br><h1>  Schritt 6: Eine weitere implizite Funktion </h1><br>  Und warum bewerte ich das Sinusprodukt nur für Punkte, die auf der Oberfläche unserer Kugel liegen?  Definieren wir unsere implizite Funktion wie folgt neu: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signed_distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> displacement = <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>*px)*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>*py)*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>*pz)*noise_amplitude; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.norm() - (sphere_radius + displacement); }</code> </pre><br>  Der Unterschied zum vorherigen Code ist sehr gering, es ist besser, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den</a> Unterschied zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sehen</a> .  Hier ist das Ergebnis: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f72/da1/e29/f72da1e29ba32fb8cbd7df9acfdd4058.jpg"><br><br>  So können wir getrennte Komponenten in unserem Objekt definieren! <br><br><h1>  Schritt sieben: Pseudozufälliges Rauschen </h1><br>  Das vorherige Bild ähnelt bereits einer Explosion aus der Ferne, aber das Produkt der Sinusse weist ein zu regelmäßiges Muster auf.  Wir würden mehr "zerrissene", mehr "zufällige" Funktionen brauchen ... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Perlins Lärm</a> wird uns helfen.  Hier ist so etwas, das uns viel besser passen würde als das Produkt der Sinusse: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f8/b7a/677/0f8b7a677e99281f724edb3cb94bf9d0.png"><br><br>  Das Erzeugen eines solchen Rauschens ist ein wenig thematisch, aber hier ist die Hauptidee: Sie müssen zufällige Bilder mit unterschiedlichen Auflösungen erzeugen und glätten, um so etwas zu erhalten: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/24b/577/f9e/24b577f9e194d834d2e243f4dc6d2e3a.png"><br><br>  Und dann fasse sie einfach zusammen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd0/e8d/172/bd0e8d172b8179a5f9cd30abdcfa3ae7.jpg"><br><br>  Lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier mehr</a> . <br><br>  Fügen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Code hinzu</a> , der dieses Rauschen erzeugt, und erhalten dieses Bild: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/175/da8/80a/175da880a5e746fd8582906bd6c2829e.jpg"><br><br>  Bitte beachten Sie, dass ich im Rendering-Code überhaupt nichts geändert habe, sondern nur die Funktion, die unsere Kugel „faltig“ macht. <br><br><h1>  Stufe acht, Finale: Farbe hinzufügen </h1><br>  Das einzige, was ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">an diesem Commit geändert habe,</a> ist, dass ich anstelle einer einheitlichen weißen Farbe eine Farbe angewendet habe, die linear von der Menge des angewendeten Rauschens abhängt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">palette_fire</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yellow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.7</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.3</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// note that the color is "hot", ie has components &gt;1 const Vec3f orange(1.0, 0.6, 0.0); const Vec3f red(1.0, 0.0, 0.0); const Vec3f darkgray(0.2, 0.2, 0.2); const Vec3f gray(0.4, 0.4, 0.4); float x = std::max(0.f, std::min(1.f, d)); if (x&lt;.25f) return lerp(gray, darkgray, x*4.f); else if (x&lt;.5f) return lerp(darkgray, red, x*4.f-1.f); else if (x&lt;.75f) return lerp(red, orange, x*4.f-2.f); return lerp(orange, yellow, x*4.f-3.f); }</span></span></code> </pre><br>  Dies ist ein einfacher linearer Verlauf zwischen den fünf Schlüsselfarben.  Nun, hier ist das Bild! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/052/265/365/052265365c5c2a1da16850f7e0cb6eb1.jpg"><br><br><h1>  Fazit </h1><br>  Diese Raytracing-Technik wird Ray Marching genannt.  Die Hausaufgaben sind einfach: Überqueren Sie den vorherigen Ray Tracer mit Blackjack und Reflexionen mit unserer Explosion, damit die Explosion auch alles um sich herum beleuchtet!  Übrigens fehlt dieser Explosion die Transluzenz. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437714/">https://habr.com/ru/post/de437714/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437702/index.html">Google Job Interview Parsing: Synonyme Abfragen</a></li>
<li><a href="../de437704/index.html">Hervorragende Kenntnis des Lehrplans als Indikator für nicht die höchste Intelligenz</a></li>
<li><a href="../de437706/index.html">Jahr mit Tesla</a></li>
<li><a href="../de437710/index.html">Beschränkung der lokalen Benutzerrechte unter Linux auf ein Minimum</a></li>
<li><a href="../de437712/index.html">Raumstation Roskomnadzor</a></li>
<li><a href="../de437716/index.html">Drei relativ ehrliche Möglichkeiten, ein Flutter-Projekt zu erstellen</a></li>
<li><a href="../de437720/index.html">Der Kampf um Qualitätslösungen bei Erlang / Elixir</a></li>
<li><a href="../de437722/index.html">Kosmische Folgen des amerikanischen Shatdown</a></li>
<li><a href="../de437724/index.html">OpenSceneGraph: Prozedurale Animation von Geometrie- und Statusattributen</a></li>
<li><a href="../de437726/index.html">Kotlin mit Kotlinx serialisieren. Serialisierung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>