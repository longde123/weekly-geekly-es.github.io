<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚣🏾 🐊 👨🏿‍🎨 [Javawatch Live]一个请求请求的故事。 SubstrateVM中的os.version 🛁 👩🏿‍⚖️ 🤙🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="自上一个技巧成功以来已经过去了一年：在YouTube上发布视频而不是发布。 在文字版本中， “关于单例的可耻讨论”在YouTube上获得了7,000的观看次数，在Habré上获得了两倍的观看次数。 对于完全顽固的状态写的文章，并讲述古老的纽扣手风琴-这是成功的一点。 

 今天，我整夜都在安装新版本...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>[Javawatch Live]一个请求请求的故事。 SubstrateVM中的os.version</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/420455/"> 自上一个技巧成功以来已经过去了一年：在YouTube上发布视频而不是发布。 在文字版本中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“关于单例的可耻讨论”</a>在YouTube上获得了7,000的观看次数，在Habré上获得了两倍的观看次数。 对于完全顽固的状态写的文章，并讲述古老的纽扣手风琴-这是成功的一点。 <br><br> 今天，我整夜都在安装新版本。 这次的话题是新近出现的：致力于实验技术的历史-SubstrateVM。 但是坚韧程度已经上升到一个新的水平。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/f0nD_8G1uB0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br> 真的很期待您的评论！ 我提醒您，如果您真的想改善本文中的内容，最好将其<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">提交到Github上</a> 。 我想说“喜欢并订阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">新频道</a> ，但是所有发行版本仍会在您的Java集线器中吗？” <br><br> 从技术上讲：视频在结尾处有一层胶合。 我刚刚写了一个未压缩的视频，而我仅有500 GB的m2 ssd迅速溢出。 而且没有其他硬盘驱动器可以承受如此大的数据压力。 因此，我不得不断开半个小时的连接，然后又设法找到另外五十个演出来记录最后几分钟。 这是通过删除<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GoogleChrome编译</a>的文件来实现的。 我在录制时就在FB中写了关于录制软件的文章，这有很多痛苦。 <br><br> 技术上的另一个有趣之处：YouTube由于某种原因阻止了我进行实时流式传输。 同时，帐户上没有任何罢工和污名。 希望这只是一个门框，在90天后一切都会退还。 <br><a name="habracut"></a><br><blockquote> 本文将引用Oracle拥有的代码。 您不能自己使用此代码（除非您阅读了原始许可证，并且在例如GPL的条件下允许使用它）。 这不是在开玩笑。 奥尔索，我警告过。 <br></blockquote><br><h1> 普里卡兹卡（童话故事将会出现） </h1><br> 许多人已经听说过“新的Java将用Java编写”的故事，并想知道这将是怎么回事。 有一份<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">《大都市计划》</a>政策文件和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">John Rose</a>的相应信函，但那里的一切都很模糊。 <br><br> 这听起来像是一种令人毛骨悚然的血腥魔法。 您可以立即尝试进行同样的操作，不仅没有魔法，而且当您用铁锹敲牙时，一切都像铲子的背面一样愚蠢。 当然，有一些细微差别，但这将是在很晚以后的某一天。 <br><br> 我将以一个发生在夏天的启发性故事为例进行演示。 他们如何在学校撰写论文“我如何度过了夏天”。 <br><br> 首先，我要说一点。 当前在Oracle Labs中进行提前编译的项目是GraalVM。 实际上，进行nishtyaki并将Java代码转换为可执行文件（转换为可执行文件）的组件是SubstrateVM或SVM。 请勿将其与数据讽刺专家（支持向量机）使用的缩写混淆。 关于SVM，作为关键部分，我们将进一步讨论。 <br><br><h1> 问题陈述 </h1><br> 因此，“我如何度过夏天”。 我坐在度假中，在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Grail github</a>上花了两个F5，碰到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了一个</a> ： <br><br><img src="https://habrastorage.org/webt/uy/pg/ig/uypgig4krayn8dmvfzif_rd3em0.png"><br><br> 一个人希望<code>os.version</code>提供正确的值。 <br><br> 好吧，我想修复该错误？ 男孩说-男孩做了。 <br><br> 我们将检查客户是否在撒谎。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(System.getProperty(<span class="hljs-string"><span class="hljs-string">"os.version"</span></span>)); } }</code> </pre><br> 首先，实际Java中的排气效果是： <code>4.15.0-32-generic</code> 。 是的，这是新鲜的Ubuntu LTS Bionic。 <br><br> 现在尝试在SVM上执行相同操作： <br><br><pre> <code class="bash hljs">$ ls Main.java $ javac -cp . Main.java $ ls Main.class Main.java $ native-image Main Build on Server(pid: 18438, port: 35415) classlist: 151.77 ms (<span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>): 1,662.32 ms setup: 1,880.78 ms error: Basic header file missing (&lt;zlib.h&gt;). Make sure libc and zlib headers are available on your system. Error: Processing image build request failed</code> </pre><br> 好吧，是的。 这是因为我专门为“干净”测试制作了一个全新的虚拟机。 <br><br><pre> <code class="bash hljs">$ sudo apt-get install zlib1g-dev libc6 libc6-dev $ native-image Main Build on Server(pid: 18438, port: 35415) classlist: 135.17 ms (<span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>): 877.34 ms setup: 1,253.49 ms (typeflow): 4,103.97 ms (objects): 1,441.97 ms (features): 41.74 ms analysis: 5,690.63 ms universe: 252.43 ms (parse): 1,024.49 ms (inline): 819.27 ms (compile): 4,243.15 ms compile: 6,356.02 ms image: 632.29 ms write: 236.99 ms [total]: 14,591.30 ms</code> </pre><br> 绝对的运行时数据可能令人恐惧。 但是，首先，这就是它的原意：非常可怕的优化在这里应用。 其次，这是您想要的脆弱的虚拟机。 <br><br> 最后，关键时刻： <br><br><pre> <code class="hljs cs">$ ./main <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre><br> 看来我们的客人没有说谎，真的行不通。 <br><br><h1> 第一种方法：从主机窃取属性 </h1><br> 然后，我在全局<code>os.version</code>搜索<code>os.version</code> ，发现所有这些属性都在<code>SystemPropertiesSupport</code>类中。 <br><br> 我不会写该文件的完整路径，因为为IntelliJ IDEA和Eclipse生成正确项目的功能直接内置于SVM中。 这非常酷，完全不让人想起大多数OpenJDK必须经历的折磨。 让IDE为我们打开类。 因此： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SystemPropertiesSupport</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String[] HOSTED_PROPERTIES = { <span class="hljs-string"><span class="hljs-string">"java.version"</span></span>, ImageInfo.PROPERTY_IMAGE_KIND_KEY, <span class="hljs-string"><span class="hljs-string">"line.separator"</span></span>, <span class="hljs-string"><span class="hljs-string">"path.separator"</span></span>, <span class="hljs-string"><span class="hljs-string">"file.separator"</span></span>, <span class="hljs-string"><span class="hljs-string">"os.arch"</span></span>, <span class="hljs-string"><span class="hljs-string">"os.name"</span></span>, <span class="hljs-string"><span class="hljs-string">"file.encoding"</span></span>, <span class="hljs-string"><span class="hljs-string">"sun.jnu.encoding"</span></span>, }; <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre><br> 然后，我完全不加思索，只是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">向该</a>集合<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">添加了</a>另一个变量： <br><br><pre> <code class="java hljs"><span class="hljs-string"><span class="hljs-string">"os.arch"</span></span>, <span class="hljs-string"><span class="hljs-string">"os.name"</span></span>, <span class="hljs-string"><span class="hljs-string">"os.version"</span></span></code> </pre><br> 我重建，运行并获得令人垂涎的行<code>4.15.0-32-generic</code> 。 万岁！ <br><br> 但这是问题所在：现在，在运行此代码的<em>每台</em>计算机上，它总是发出<code>4.15.0-32-generic</code> 。 即使在<code>uname -a</code>也会在旧的Ubunt上返回存储桶的先前版本。 <br><br> 很明显，这些变量在编译时已写入源文件。 <br> 实际上，您需要仔细阅读以下注释： <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** System properties that are taken from the VM hosting the image generator. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String[] HOSTED_PROPERTIES</code> </pre><br> 需要使用其他方法。 <br><br><h2> 结论 </h2><br><ul><li> 如果要使“ main Java”中的系统属性出现在SVM中，这非常简单。 我们将所需的属性写在正确的位置，仅此而已。 </li><li> 您可以在IDE中工作，该IDE同时支持Java和Python。 例如，在具有Python插件的IntelliJ IDEA Ultimate中，或在Eclipse中相同。 </li></ul><br><h1> 第二种方法 </h1><br> 如果浏览SystemPropertiesSupport <code>SystemPropertiesSupport</code> ，我们会发现更加合理的东西： <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** System properties that are lazily computed at run time on first access. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;String, Supplier&lt;String&gt;&gt; lazyRuntimeValues;</code> </pre><br> 除其他外，使用这些属性仍然不会阻止构建可执行文件的过程。 显然，如果我们对<code>HOSTED_PROPERTIES</code>进行大量<code>HOSTED_PROPERTIES</code> ，那么一切都会变慢。 <br><br> 通过引用返回以下内容的方法，惰性属性的注册以明显的方式发生： <br><br><pre> <code class="hljs kotlin">lazyRuntimeValues.put(<span class="hljs-string"><span class="hljs-string">"user.name"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::userNameValue); lazyRuntimeValues.put(<span class="hljs-string"><span class="hljs-string">"user.home"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::userHomeValue); lazyRuntimeValues.put(<span class="hljs-string"><span class="hljs-string">"user.dir"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::userDirValue);</code> </pre><br> 而且，所有这些方法引用都是接口，并且对每个受支持的平台都实现了<code>this::userDirValue</code> 。 在这种情况下，这些是<code>PosixSystemPropertiesSupport</code>和<code>WindowsSystemPropertiesSupport</code> 。 <br><br> 如果我们出于好奇而无法使用Windows的实现，我们将看到可悲的事情： <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">userDirValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"C:\\Users\\somebody"</span></span>; }</code> </pre><br> 如您所见，尚不支持Windows ：-)但是，真正的问题是Windows可执行文件的生成尚未完成，因此支持这些方法实际上是完全不必要的工作。 <br><br> 也就是说，您需要实现以下方法： <br><br><pre> <code class="java hljs">lazyRuntimeValues.put(<span class="hljs-string"><span class="hljs-string">"os.version"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::osVersionValue);</code> </pre><br> 然后在两个或三个可用接口中支持它。 <br><br> 但是在那里写什么呢？ <br><br><h2> 结论 </h2><br><ul><li> 如果要添加在运行时计算的新属性，则只需编写一个方法即可。 结果可能取决于当前的操作系统，切换机制已经在起作用并且没有询问。 </li></ul><br><h1> 一点考古 </h1><br> 首先想到的是偷看OpenJDK中的实现并大胆地复制粘贴。 一点考古学和抢劫将永远不会阻止一个勇敢的探险家！ <br><br> 随意在Idea中打开任何Java项目，在其中编写<code>System.getProperty("os.version")</code> ，然后按ctrl +单击转到<code>getProperty()</code>方法的实现。 事实证明，所有这一切都愚蠢地存在于<code>Properties</code> 。 <br><br> 看起来，只需复制粘贴这些<code>Properties</code>被填充的地方，然后大笑起来，就会消失在空白中。 不幸的是，我们遇到一个问题： <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">native</span></span></span><span class="hljs-function"> Properties </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initProperties</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Properties props)</span></span></span></span>;</code> </pre><br> 不，不，不。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d4d/ca9/698/d4dca9698ffccaf0de2944194698e857.gif"><br><br> 但这一切开始得如此顺利。 <br><br><h1> 有男孩吗？ </h1><br> 众所周知，使用C ++是不好的。  SVM中使用C ++吗？ <br><br> 就这样！ 甚至还有一个特殊的软件包： <code>src/com.oracle.svm.native</code> 。 <br><br> 在此包中，horror-horror位于<code>getEnviron.c</code>文件中，如下所示： <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **environ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> **</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getEnviron</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> environ; }</code> </pre><br><h1> 是时候搞砸C ++了 </h1><br> 现在深入研究并打开完整的OpenJDK源代码。 <br><br> 如果某人还没有，则可以<a href="">在网上查找</a>或下载。 我警告您，他们仍然在Mercurial的帮助下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从这里</a>摇摆，仍然需要大约半小时。 <br><br> 我们需要的文件位于<code>src/java.base/share/native/libjava/System.c</code> 。 <br><br> 是否注意到这是文件的路径，而不仅仅是名称？ 没错，您可以推销您新的闪亮时尚主意，该主意是每年200美元购买的。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">尝试CLion</a> ，但是为了避免不可逆转的精神损害，最好只使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Visual Studio Code</a> 。 他已经突出显示了某些内容，但仍然不明白自己所看到的内容（他没有将所有内容划掉红色）。 <br><br> 重播<code>System.c</code> ： <br><br><pre> <code class="hljs lisp">java_props_t *sprops = GetJavaProperties(<span class="hljs-name"><span class="hljs-name">env</span></span>)<span class="hljs-comment"><span class="hljs-comment">; PUTPROP(props, "os.version", sprops-&gt;os_version);</span></span></code> </pre><br> 依次将它们放在<code>src/java.base/unix/native/libjava/java_props_md.c</code> 。 <br> 每个平台都有其自己的此类文件，它们通过<code>#define</code>切换。 <br><br> 从这里开始。 有很多平台。 由于GraalVM并未正式支持AIX，因此可以评分任何像AIX的死灵患者（据我所知，GNU-Linux，macOS和Windows最初计划在其中）。  GNU / Linux和Windows支持使用<code>&lt;sys/utsname.h&gt;</code> ，它具有用于获取操作系统名称和版本的预定义方法。 <br><br> 但是macOS <a href="">的govnokod</a>非常<a href="">糟糕</a> 。 <br><br><ul><li> 名称“ Mac OS X”用硬涂层表示（尽管它早已是macOS）。 </li><li> 这取决于makoshi的版本。 在10.9之前的版本中，SDK不具有<code>operatingSystemVersion</code>函数，您必须手动阅读<code>SystemVersion.plist</code> 。 </li><li> 对于此减法，它使用ObjC扩展名，如下所示： </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// Fallback if running on pre-10.9 Mac OS if (osVersionCStr == NULL) { NSDictionary *version = [NSDictionary dictionaryWithContentsOfFile : @"/System/Library/CoreServices/SystemVersion.plist"]; if (version != NULL) { NSString *nsVerStr = [version objectForKey : @"ProductVersion"]; if (nsVerStr != NULL) { osVersionCStr = strdup([nsVerStr UTF8String]); } } }</span></span></code> </pre><br> 如果最初有一个想法以良好的样式手动重写它，那么它很快就会变成现实。 如果我从ifs弄乱了面条的丛林中某个地方，有人会打碎它，然后将我吊死在中央广场怎么办？ 好吧，nafig。  <strong>有必要复制粘贴。</strong> <br><br><h2> 结论 </h2><br><ul><li> 不需要IDE； </li><li> 与C ++的任何通信都是痛苦的，令人不愉快的，一见钟情。 </li></ul><br><h1> 复制粘贴是常态吗？ </h1><br> 这是进一步折磨所依赖的重要问题。 我确实不想手动重写，但因违反许可而上法庭更为糟糕。 所以我去了github并直接问Codrut Stancu。 这是他的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">回答</a> ： <br><br>  <em>»重复使用OpenJDK代码，例如，从许可的角度来看，复制粘贴是正常的事情。</em>  <em>但是，这有一个很好的理由。</em>  <em>如果可以通过重复使用JDK代码而不复制来实现某个功能，例如用替换对其打补丁，那就更好了。”</em> <br><br> 这听起来像是官方的复制粘贴许可！ <br><br><h1> 我们正常交谈... </h1><br> 我开始移植这段代码，但遇到了懒惰。 要测试不同版本的macOS，您需要至少找到一个具有死灵性10.8 Mountain Lion的软件。 我有两个可用的苹果设备，一个是从朋友那里获得的，我还可以将其部署到一些试用版的VMWare中。 <br><br> 但是懒惰。 这种懒惰救了我。 <br><br> 我去了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">聊天室</a> ，问克里斯·西顿，哪个工具链最适合组装。 支持哪个版本的OS，C ++编译器等等。 <br><br> 作为回应，他从聊天中获得了惊讶的沉默，克里斯回答说他不理解问题的实质。 <br><br> 克里斯花了很长时间才弄清楚我想做什么，并要求他<strong>不再做</strong> 。 <br><blockquote> 确实缺少SVM的想法。  SVM是纯Java，不应从OpenJDK插入代码。 您可以阅读它，并将其转换为Java，但是没有人想要OpenJDK的C ++代码。 那是我们想要的最后一件事。 <br></blockquote><br> 数学库的示例无法说服他。 至少它们是用C编写的，而C ++的包含意味着将全新的语言连接到代码库。 还有就是fufufu。 <br><br> 你需要做什么？ 用<strong>System Java</strong>编写。 <br><br> 并且如果无法避免对C / C ++平台SDK的调用，那么这应该是包装在C API中的某些单个系统调用。 即使Platform SDK具有方便的现成方法来在C ++方面以不同的方式处理数据，都用Java提取数据，然后严格用Java编写业务逻辑。 <br><br> 我叹了口气，开始研究源代码，以了解如何以不同的方式完成此工作。 <br><br><h2> 结论 </h2><br><ul><li> 与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">聊天</a>中的人<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">交谈，以了解</a>任何晦涩的细节。 如果问题不是完全白痴，他们就会回答。 尽管此示例表明Chris准备好讨论白痴问题，即使这并不能节省他个人的时间； </li><li> 项目中根本没有C ++。 没有理由相信有人会让他把他拖到地板下面； </li><li> 相反，您需要使用C作为最后的手段在System Java中进行编写（例如，在调用平台SDK时）。 </li></ul><br><h1> 不需要小提琴手 </h1><br><blockquote> 亲爱的，不需要小提琴手。 他只吃多余的燃料。 <br></blockquote><br> 然后我不知所措，因为看看这里。 如果在Windows上有<code>&lt;sys/utsname.h&gt;</code> ，我们非常希望得到他的回答-这很简单。 <br><br> 但是，如果他不在那，那该怎么办？ <br><br><ul><li> 调用cmd内置命令还是Windows实用程序？ 用俄语发布需要解析的文本。 这是最底层的，可能与真正的OpenJDK在这里所要回答的不一致。 </li><li> 从注册表中拿走吗？ 例如，即使在这里也有细微差别，例如，当从Windows 7切换到10时，在注册表中存储数字数字的方法也发生了变化，在Windows 10中，您需要粘住主要和次要组件的手，或者简单地回答它是一位数字的Windows 10。 尚不清楚哪种方法更正确（不会使用户的资产悔改）。 </li></ul><br> 幸运的是，保罗·威格勒<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">（</a> Paul Woegerer）提出的要求将我的痛苦<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">打断了</a> ，后者解决了所有问题。 <br><br> 有趣的是，起初，所有内容都在向导中修复（ <code>os.version</code>停止在测试中提供<code>null</code> ），然后才注意到pullrequest。 问题在于，该提交未在github上标记为pullrequest-这是一个简单的提交，注释中带有铭文<code>PullRequest: graal/1885</code> 。 事实是，Oracle实验室的帅哥不使用Github，他们只需要它与外部提交者进行交互即可。 我们所有人都不够幸运，无法在Oracle Labs工作，我们需要订阅有关对存储库的新提交的通知，并全部阅读它们。 <br><br> 但是现在您可以放松下来，看看如何<em>正确</em>实现此功能。 <br><br> 让我们看看System Java是什么样的野兽。 <br><br> 正如我之前说的，当他们试图敲掉牙齿时，一切都很简单，就像铲子的背面一样。 同样痛苦。 看一下池中的报价： <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">osVersionValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (osVersionValue != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> osVersionValue; } <span class="hljs-comment"><span class="hljs-comment">/* On OSX Java returns the ProductVersion instead of kernel release info. */</span></span> CoreFoundation.CFDictionaryRef dict = CoreFoundation._CFCopyServerVersionDictionary(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dict.isNull()) { dict = CoreFoundation._CFCopySystemVersionDictionary(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dict.isNull()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> osVersionValue = <span class="hljs-string"><span class="hljs-string">"Unknown"</span></span>; } CoreFoundation.CFStringRef dictKeyRef = DarwinCoreFoundationUtils.toCFStringRef(<span class="hljs-string"><span class="hljs-string">"MacOSXProductVersion"</span></span>); CoreFoundation.CFStringRef dictValue = CoreFoundation.CFDictionaryGetValue(dict, dictKeyRef); CoreFoundation.CFRelease(dictKeyRef); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dictValue.isNull()) { dictKeyRef = DarwinCoreFoundationUtils.toCFStringRef(<span class="hljs-string"><span class="hljs-string">"ProductVersion"</span></span>); dictValue = CoreFoundation.CFDictionaryGetValue(dict, dictKeyRef); CoreFoundation.CFRelease(dictKeyRef); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dictValue.isNull()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> osVersionValue = <span class="hljs-string"><span class="hljs-string">"Unknown"</span></span>; } osVersionValue = DarwinCoreFoundationUtils.fromCFStringRef(dictValue); CoreFoundation.CFRelease(dictValue); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> osVersionValue; }</code> </pre><br> 换句话说，我们用Java逐字写了用C语言写的东西。 <br><br>  <code>DarwinExecutableName</code>一下<code>DarwinExecutableName</code>写法： <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Find out how long the executable path is. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CIntPointer sizePointer = StackValue.get(CIntPointer.class); sizePointer.write(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DarwinDyld._NSGetExecutablePath(WordFactory.nullPointer(), sizePointer) != -<span class="hljs-number"><span class="hljs-number">1</span></span>) { VMError.shouldNotReachHere(<span class="hljs-string"><span class="hljs-string">"DarwinExecutableName.getExecutableName: Executable path length is 0?"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* Allocate a correctly-sized buffer and ask again. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] byteBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[sizePointer.read()]; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (PinnedObject pinnedBuffer = PinnedObject.create(byteBuffer)) { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CCharPointer bufferPointer = pinnedBuffer.addressOfArrayElement(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DarwinDyld._NSGetExecutablePath(bufferPointer, sizePointer) == -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* Failure to find executable path. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String executableString = CTypeConversion.toJavaString(bufferPointer); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String result = realpath(executableString); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }</code> </pre><br> 所有这些<code>CIntPointer</code> ， <code>CCharPointer</code> ， <code>PinnedObject</code> 。 <br><br> 就我的口味而言，这不舒服且丑陋。 您需要手动使用类似于Java类的指针。 您需要及时调用适当的<code>release</code> ，以免内存泄漏。 <br><br> 但是，如果您认为这些是<em>不合理的</em>措施，那么您可以再次查看<a href="">.NET中GC</a>的<a href="">实现，</a>并且如果您不及时停止，就会对C ++导致的结果感到震惊。 我提醒您，这是一个很大的CPP文件，大于一个兆字节。 关于他的工作有<a href="">一些描述</a> ，但是显然不足以使外部贡献者理解。 上面的代码虽然看起来很讨厌，但可以通过Java的静态分析来很好地理解和分析。 <br><br> 至于承诺的实质，我对他有疑问。 至少那里没有实现Windows支持。 当出现Windows的代码源时，我将尝试执行此任务。 <br><br><h2> 结论 </h2><br><ul><li> 需要用System Java编写。 赞美，叫甜面包。 仍然没有选择。 </li><li> 从GitHub上的存储库订阅通知并阅读提交，否则重要的PR将会飞逝； </li><li> 如果可能，请询问负责此领域的人员的主要功能。 有很多实现的方法，但是它们尚未为大众所知。 有机会发明一辆自行车，这比甲骨文实验室的家伙制造的自行车差得多。 </li><li> 处理功能时，请务必在github上通知负责人。 如果他不回答-写封信，所有团队成员的地址都可以轻松地用Google搜索。 </li></ul><br><h1> 结语 </h1><br> 这场战斗结束了，但战争根本没有结束。 <br><br> 战斗机，敏感地等待有关哈布雷的新文章并<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">进入我们的行列</a> ！ <br><br> 我想提醒您，Oracle唯一的GraalVM <strong>官方</strong>推广者Oleg Shelaev将参加<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下一次Joker会议</a> 。 不仅是“唯一的俄语使用者”，而且是“总体上唯一的俄语使用者”。 该报告的标题（ <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“使用GraalVM提前编译Java”</a></em> ）提示SubstrateVM不能没有。 <br><br> 顺便说一句，奥列格（Oleg）最近获得了一种服务武器-在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">谢拉耶夫·奥勒格（Haslaé）</a>的帐户上。 尚无帖子，但您可以使用此用户名进行投射。 <br><br> 您可以在Telegram的聊天室聊天中与Oleg和Oleg交谈： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@graalvm_ru</a> 。 与Github上的ishshuyev不同，您可以在其中进行任何形式的交流，并且不会有人被禁止（ <em>但这并不准确</em> ）。 <br><br> 我还提醒您，每周我们都会与Debriefing播客一起发布Java Digest。 例如，这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最后的摘要</a> 。 有时，有关GraalVM的新闻会不时出现（事实上，我不会因为尊重观众而将整个问题转为GraalVM新闻发布：-） <br><br> 感谢您阅读此书-很快再见！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN420455/">https://habr.com/ru/post/zh-CN420455/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN420441/index.html">Python中最常见的10个安全错误以及如何避免这些错误</a></li>
<li><a href="../zh-CN420443/index.html">网络安全专家创建了一个撇渣器-SkimReaper</a></li>
<li><a href="../zh-CN420447/index.html">计算机历史博物馆-记录IT的地方</a></li>
<li><a href="../zh-CN420451/index.html">云中的服务器：准备启动</a></li>
<li><a href="../zh-CN420453/index.html">Skillbox星期五网络研讨会：开发及其相关内容</a></li>
<li><a href="../zh-CN420457/index.html">Simplify3D 3D打印软件概述</a></li>
<li><a href="../zh-CN420459/index.html">上部工具栏中带有计数器的图标：一项任务的多种方法的示例</a></li>
<li><a href="../zh-CN420461/index.html">坏设计师的十句名言</a></li>
<li><a href="../zh-CN420463/index.html">ICO值得下降，但它们有机会改变</a></li>
<li><a href="../zh-CN420465/index.html">使用njs的Nginx变量：简单，轻松且通过JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>