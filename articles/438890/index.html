<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëéüèø üëû üë©üèæ‚Äç‚úàÔ∏è Postgres en retrospectiva ‚òîÔ∏è üè≥Ô∏è‚Äçüåà üÖøÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Traemos a su atenci√≥n una traducci√≥n del art√≠culo de Joseph Hellerstein "Mirando hacia atr√°s en Postgres" , publicado bajo la afirmaci√≥n de copyright ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Postgres en retrospectiva</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/438890/">  <em>Traemos a su atenci√≥n una traducci√≥n del art√≠culo de <strong>Joseph Hellerstein "Mirando hacia atr√°s en Postgres"</strong> , publicado bajo la <strong>afirmaci√≥n de copyright</strong> internacional Creative Commons versi√≥n 4.0 (CC-BY 4.0).</em>  <em>Los autores se reservan el derecho de distribuir este trabajo en sitios web personales y corporativos con un enlace adecuado a la fuente.</em> <br><br>  <em>Traducci√≥n realizada por Elena Indrupskaya.</em>  <em>Agregar√© por mi cuenta que "un programador que quer√≠a desesperadamente construir un sistema con m√∫ltiples versiones" parece ser Vadim Mikheev, pero todos conocemos a los "voluntarios de Rusia" que reescribieron GiST.</em> <br><br><h1>  Anotaci√≥n </h1><br>  Este es un recuerdo del proyecto Postgres, llevado a cabo en la Universidad de California en Berkeley y dirigido por Mike Stonebraker desde mediados de los a√±os ochenta hasta mediados de los noventa.  Como una de las muchas memorias personales e hist√≥ricas, este art√≠culo fue solicitado para un libro [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bro19</a> ] sobre el Premio Turing de Stonebreaker.  Por lo tanto, el enfoque del art√≠culo est√° en el papel principal de Stonebreaker y sus pensamientos sobre el dise√±o.  Pero Stonebreaker nunca fue un programador y no interfiri√≥ con su equipo de desarrollo.  La base del c√≥digo de Postgres fue el trabajo de un equipo de estudiantes brillantes y ocasionalmente programadores universitarios de tiempo completo que ten√≠an un poco m√°s de experiencia (y solo un salario ligeramente mayor) que los estudiantes.  Tuve la suerte de unirme a este equipo como estudiante en los √∫ltimos a√±os del proyecto.  Recib√≠ material √∫til para este art√≠culo de algunos de los estudiantes mayores involucrados en el proyecto, pero cualquier error u omisi√≥n es m√≠o.  Si observa alguno de ellos, comun√≠quese conmigo e intentar√© solucionarlo. <br><a name="habracut"></a><br><h1>  1. Introducci√≥n </h1><br>  Postgres fue el proyecto m√°s ambicioso de Michael Stonebreaker: su intento serio de crear un sistema de base de datos universal.  Durante una d√©cada, el proyecto ha generado m√°s art√≠culos, doctorados, profesores y empresas que cualquier otra actividad de Stonebreaker.  El proyecto tambi√©n cubri√≥ m√°s del campo t√©cnico que cualquier otro sistema que √©l construy√≥.  A pesar del riesgo inherente de esta magnitud, Postgres tambi√©n se convirti√≥ en el artefacto de software m√°s exitoso que surgi√≥ de los equipos de investigaci√≥n de Stonebreaker, y su principal contribuci√≥n al c√≥digo abierto.  Este es un ejemplo de un "segundo sistema" [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bro75</a> ] que ha tenido √©xito.  En el momento de la redacci√≥n, m√°s de treinta a√±os despu√©s del inicio del proyecto, el sistema de c√≥digo abierto PostgreSQL es el sistema de base de datos de c√≥digo abierto independiente m√°s popular del mundo y el cuarto sistema de base de datos m√°s popular.  Mientras tanto, las compa√±√≠as creadas a partir de Postgres generaron un total de m√°s de $ 2.6 mil millones (en costos de adquisici√≥n).  En cualquier medida, la visi√≥n del Rompepiedras Postgres tuvo una enorme resonancia duradera. <br><br><h2>  1.1.  Antecedentes </h2><br>  Stonebreaker fue un gran √©xito al principio de su carrera con el proyecto de investigaci√≥n Ingres Berkeley [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SHWK76</a> ] y la posterior startup, que fund√≥ con Larry Rowe y Eugene Wong: Relational Technology, Inc.  (RTI) <br><br>  A medida que RTI se desarroll√≥ a principios de la d√©cada de 1980, Stonebreaker comenz√≥ a trabajar en el soporte DBMS para tipos de datos que iban m√°s all√° de las filas y columnas tradicionales del modelo relacional original de Codd (Edgar Frank Codd).  Un ejemplo motivador en ese momento era la necesidad de bases de datos para admitir herramientas de dise√±o asistido por computadora (CAD) para la industria microelectr√≥nica.  En un art√≠culo de 1983 de Stonebreaker y estudiantes, Brad Rubenstein y Antonin Guttman explicaron cu√°nto necesita esta industria para admitir "nuevos tipos de datos como pol√≠gonos, rect√°ngulos, cadenas de texto, etc.", " b√∫squeda espacial efectiva "," restricciones de integridad complejas ", as√≠ como" jerarqu√≠as de dise√±o y representaciones m√∫ltiples "en las mismas estructuras f√≠sicas [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SRG83</a> ].  Con esta motivaci√≥n, el grupo comenz√≥ a trabajar en la indexaci√≥n (incluido el uso de √°rboles R de Guttman para la indexaci√≥n espacial [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gut84</a> ]) y en la adici√≥n de tipos de datos abstractos (ADT) al sistema de base de datos relacional.  En ese momento, los ADT eran una nueva construcci√≥n popular de lenguajes de programaci√≥n, que fue presentada por primera vez por Barbara Liskov, m√°s tarde ganadora del Premio Turing, e investigada en la programaci√≥n de aplicaciones de bases de datos por un nuevo colaborador de Stonebreaker, Larry Rowe.  Un art√≠culo en un registro SIGMOD de 1983 [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OFS83</a> ] Stonebreaker y los estudiantes James Ong y Dennis Fogg describen un estudio de este concepto en la extensi√≥n Ingres llamado ADT-Ingres, que incorpora muchos de los conceptos de presentaci√≥n estudiados m√°s profundamente y con un mejor soporte del sistema en Postgres. <br><br><h1>  2. Postgres: informaci√≥n general </h1><br>  Como su nombre lo indica, Postgres es Post-Ingres: un sistema dise√±ado para tomar lo que Ingres podr√≠a hacer e ir m√°s all√°.  Una caracter√≠stica distintiva de Postgres fue la introducci√≥n de lo que finalmente llam√≥ las propiedades relacionales de objetos de la base de datos: soporte para el concepto de programaci√≥n orientada a objetos en el modelo de datos y el lenguaje de consulta declarativa del sistema de base de datos.  Pero Stonebreaker tambi√©n plane√≥ resolver una serie de otros problemas tecnol√≥gicos independientes del soporte orientado a objetos en Postgres, como las reglas de bases de datos activas, datos versionados, almacenamiento terciario y concurrencia. <br><br>  Se escribieron dos art√≠culos sobre el dise√±o de Postgres: una descripci√≥n del dise√±o inicial en 1986 SIGMOD [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SR86</a> ] y una descripci√≥n intermedia en CACM 1991 [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SK91</a> ].  El proyecto de investigaci√≥n de Postgres gradualmente qued√≥ en nada en 1992 con la fundaci√≥n de Illustra, una startup que involucr√≥ a Stonebreaker, el estudiante graduado principal Wei Hong y luego se convirti√≥ en el programador jefe Jeff Meredith.  En la lista a continuaci√≥n, las oportunidades mencionadas en el art√≠culo de 1986 est√°n marcadas con un asterisco *, y las oportunidades del art√≠culo de 1991, que no estaban en el art√≠culo de 1986, est√°n marcadas con una daga <sup>‚Ä†</sup> .  Las otras tareas enumeradas a continuaci√≥n se tomaron en el sistema y en la literatura de investigaci√≥n, pero no se encuentran en ninguna especificaci√≥n de dise√±o.  Muchos de estos temas fueron abordados en Postgres mucho antes de que otros los estudiaran o reinventaran.  En muchos casos, Postgres se adelant√≥ demasiado a su tiempo, y el inter√©s en los temas surgi√≥ m√°s tarde, desde una perspectiva moderna. <br><br><ol><li>  Soporte ADT en el sistema de base de datos. <br><ul><li>  Objetos complejos (es decir, datos anidados o datos de forma no primera normal (forma no primera normal - NF2)) * </li><li>  Tipos de datos abstractos personalizados y funciones * </li><li>  M√©todos de acceso extensible para nuevos tipos de datos * </li><li>  Procesamiento de consultas optimizado con caracter√≠sticas costosas definidas por el usuario </li></ul></li><li>  Bases de datos activas y sistemas de reglas (disparadores, advertencias) * <br><ul><li>  Reglas implementadas como reescritura de solicitudes <sup>‚Ä†</sup> </li><li>  Reglas implementadas como disparadores de nivel de grabaci√≥n <sup>‚Ä†</sup> </li></ul></li><li>  Almacenamiento y recuperaci√≥n basados ‚Äã‚Äãen registros <br><ul><li>  C√≥digo de recuperaci√≥n de complejidad reducida que trata el registro como datos *, utilizando memoria no vol√°til para el estado de confirmaci√≥n <sup>‚Ä†</sup> </li><li>  Almacenamiento no reescrito y consultas temporales <sup>‚Ä†</sup> </li></ul></li><li>  Soporte para nuevas tecnolog√≠as de almacenamiento profundo, especialmente discos √≥pticos * </li><li>  Soporte para multiprocesadores y procesadores especializados * </li><li>  Soporte para varios modelos de idiomas. <br><ul><li>  Cambios m√≠nimos en el modelo relacional y soporte para consultas declarativas * </li><li>  Acceso a la "v√≠a r√°pida" desde API internas sin pasar por el lenguaje de consulta <sup>‚Ä†</sup> </li><li>  Multiling√ºismo <sup>‚Ä†</sup> </li></ul></li></ol><br>  Discutiremos brevemente la contribuci√≥n de Postgres para cada uno de estos elementos en relaci√≥n con el trabajo posterior en el campo de la inform√°tica. <br><br><h2>  2.1.  Soporte ADT en el sistema de base de datos. </h2><br>  El objetivo claro de Postgres era admitir nuevas propiedades relacionales de objetos: expandir la tecnolog√≠a de base de datos para proporcionar los beneficios tanto del procesamiento de consultas relacionales como de la programaci√≥n orientada a objetos.  Con el tiempo, el concepto de relaci√≥n de objetos que apareci√≥ por primera vez en Postgres se convirti√≥ en una funcionalidad est√°ndar en la mayor√≠a de los sistemas de bases de datos modernos. <br><br><h3>  2.1.1  Objetos complejos </h3><br>  Muy a menudo, los datos se representan como entidades anidadas u "objetos".  Un ejemplo cl√°sico es una orden de compra, que tiene un conjunto integrado de productos, sus cantidades y precios.  La religi√≥n del modelado relacional dictaba que dichos datos deb√≠an reestructurarse y guardarse en un formato sin anidamiento, utilizando varias tablas planas de objetos (pedidos, productos) con tablas planas de relaciones conectadas (product_in_order).  Una raz√≥n t√≠pica de este aplanamiento es que reduce la duplicaci√≥n de datos (porque el producto se describe de forma redundante en muchas √≥rdenes de compra), lo que, a su vez, evita la complejidad o los errores al actualizar todas las copias redundantes.  Pero en algunos casos, desea mantener la subvista, porque es natural para la aplicaci√≥n (por ejemplo, el mecanismo de dise√±o del circuito en CAD), y las actualizaciones son raras.  Este debate sobre el modelado de datos es al menos tan antiguo como el modelo relacional. <br><br>  El enfoque clave de Postgres fue "sentarse en dos sillas" en t√©rminos de modelado de datos: Postgres guard√≥ las tablas como el tipo de datos "m√°s externo", pero permiti√≥ que las columnas tuvieran tipos "complejos", incluidas tuplas o tablas anidadas.  Una de sus implementaciones menos comunes, investigada por primera vez en el prototipo ADT-Ingres, era permitir que una columna de tipo de tabla se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">declarara</a> declarativamente como una definici√≥n de consulta: "Quel como tipo de datos" [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SAHR84</a> ] <em>(Quel - lenguaje de consulta Ingres. - Aprox. Per. .)</em> . <br><br>  El tema de soporte "post-relacional" para consultas declarativas y datos incrustados ha reaparecido a lo largo de los a√±os, a menudo generado por disputas sobre cu√°l es mejor.  Durante la √©poca de Postgres en las d√©cadas de 1980 y 1990, algunos grupos involucrados en bases de datos orientadas a objetos recogieron esta idea y la desarrollaron en el lenguaje OQL est√°ndar, que luego dej√≥ de usarse. <br><br>  A comienzos del milenio, las consultas declarativas sobre objetos anidados se convirtieron en una obsesi√≥n con la investigaci√≥n para el segmento de la comunidad de desarrolladores de bases de datos en forma de bases de datos XML.  El lenguaje XQuery resultante (dirigido por Don Chamberlin, la persona de SQL) es necesario para admitir objetos complejos en el lenguaje Postgel de Postgres.  XQuery es ampliamente utilizado y ampliamente utilizado en la industria, pero nunca ha sido popular entre los usuarios.  Hoy, estos conceptos est√°n siendo reexaminados en proyectos de lenguaje de consulta para el modelo de datos JSON, popular en aplicaciones basadas en navegador.  Al igual que OQL, en grupos que inicialmente rechazaron las consultas declarativas a favor de la programaci√≥n orientada al desarrollador (el movimiento "NoSQL"), estos lenguajes a menudo emergen como una adici√≥n tard√≠a solo por el deseo de agregar consultas nuevamente al sistema.  Al mismo tiempo, a medida que Postgres creci√≥ a lo largo de los a√±os (y pas√≥ del lenguaje de consulta de Postquel a las versiones SQL que cumplen muchos de los objetivos considerados), incluy√≥ soporte para datos incrustados, como XML y JSON, en DBMS de uso general, sin requerir ning√∫n o redise√±o significativo.  La controversia se est√° ejecutando con diversos grados de √©xito, y el enfoque de Postgres para expandir la estructura relacional usando extensiones para datos anidados ha demostrado repetidamente ser un estado final natural para todas las partes despu√©s de que los argumentos remiten. <br><br><h3>  2.1.2.  Tipos de datos abstractos personalizados y funciones </h3><br>  Adem√°s de sugerir tipos anidados, Postgres propuso la idea de introducir ADT opacos y extensibles que se almacenan en la base de datos pero que el n√∫cleo no interpreta.  B√°sicamente, esto siempre ha sido parte del modelo relacional de Codd: los enteros y las cadenas eran tradicionales, pero de hecho el modelo relacional abarca cualquier tipo de datos at√≥micos con predicados.  La tarea consist√≠a en proporcionar tal flexibilidad matem√°tica en el software.  Para utilizar consultas que interpretan estos objetos y los manipulan, un programador de aplicaciones debe poder registrar funciones definidas por el usuario (UDF) para estos tipos en el sistema y llamar a estas funciones en consultas.  Tambi√©n es deseable que las funciones de agregado definido por el usuario (UDA) resuman las colecciones de estos objetos en consultas.  El sistema de base de datos de Postgres ha sido innovador y ha sido totalmente compatible con estas caracter√≠sticas. <br><br>  ¬øPor qu√© poner tal funcionalidad en un DBMS, en lugar de en aplicaciones de alto nivel?  La respuesta t√≠pica a esta pregunta fue una ventaja significativa en el rendimiento del c√≥digo colocado en los datos sobre la "extracci√≥n" de los datos al c√≥digo.  Postgres demostr√≥ que esto es bastante natural dentro de un entorno relacional: solo se requirieron cambios menores en el cat√°logo de metadatos relacionales y se crearon mecanismos de llamada de c√≥digo de terceros, pero la sintaxis de consulta, la sem√°ntica y la arquitectura del sistema funcionaron de manera simple y elegante. <br><br>  Postgres est√° un poco adelantado a su tiempo para explorar esta funcionalidad.  En particular, en ese momento, la comunidad de investigaci√≥n de bases de datos no estaba particularmente preocupada por las implicaciones de seguridad de descargar c√≥digo inseguro al servidor.  Esto comenz√≥ a percibirse como un problema cuando se not√≥ la tecnolog√≠a en la industria.  Stonebreaker llev√≥ a Postgres al mercado en su startup Illustra, que Informix adquiri√≥ en gran medida por su capacidad de soportar paquetes de extensi√≥n DataBlade, incluido UDF.  Informix, con su tecnolog√≠a basada en Postgres y sus s√≥lidas ofertas de bases de datos paralelas, se ha convertido en una amenaza importante para Oracle.  Oracle ha invertido mucho en marketing negativo de los riesgos asociados con la capacidad de Informix para ejecutar c√≥digo C de usuario "inseguro".  Algunos atribuyen la muerte de Informix a esta campa√±a, aunque el fraude financiero de Informix (y el posterior enjuiciamiento federal de su entonces CEO) ciertamente presentaron problemas m√°s serios.  Ahora, d√©cadas despu√©s, todos los principales proveedores de bases de datos admiten funciones personalizadas en uno o m√°s idiomas, utilizando nuevas tecnolog√≠as para protegerse contra fallas del servidor o corrupci√≥n de datos. <br><br>  Mientras tanto, las pilas tecnol√≥gicas de los grandes datos de la d√©cada de 2000, incluido el fen√≥meno MapReduce, que "ech√≥ a perder mucha sangre" por Stonebreaker y David DeWitt [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DS08</a> ], son una re-implementaci√≥n de la idea de Postgres: c√≥digo de usuario publicado como parte de la solicitud.  Parece que MapReduce combina en gran medida las ideas de desarrollo de software de Postgres con ideas de concurrencia de sistemas como Gamma y Teradata, con algunas innovaciones menores en torno a reiniciar el proceso de consulta para cargas de trabajo con escalabilidad extrema.  Las startups basadas en Postgres, Greenplum y Aster, alrededor de 2007, mostraron que la paralelizaci√≥n de Postgres podr√≠a conducir a algo mucho m√°s funcional y pr√°ctico que MapReduce para la mayor√≠a de los clientes, pero en 2008 el mercado a√∫n no estaba listo para esta tecnolog√≠a. .  En este momento, en 2018, casi todas las grandes pilas de datos b√°sicamente manejan la carga de trabajo de SQL paralelo con UDF, que es muy similar al dise√±o que Stonebreaker y el equipo usaron por primera vez en Postgres. <br><br><h3>  2.1.3.  M√©todos de acceso extensible para nuevos tipos de datos </h3><br>  Las bases de datos relacionales se desarrollaron casi al mismo tiempo que los √°rboles B a principios de la d√©cada de 1970, y los √°rboles B ayudaron a darle a Codd un sue√±o de "independencia del almacenamiento de datos f√≠sicos": la indexaci√≥n con √°rboles B proporciona un nivel de indirecci√≥n que Reorganiza de forma adaptativa el almacenamiento f√≠sico sin requerir cambios en la aplicaci√≥n.  La principal limitaci√≥n de los √°rboles B y sus estructuras asociadas fue que solo admiten b√∫squedas y consultas de igualdad en el rango unidimensional.  Pero, ¬øqu√© sucede si tiene consultas de rango bidimensional t√≠picas de aplicaciones de mapeo y CAD?  Este problema se conoci√≥ durante Postgres, y el √°rbol R [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gut84</a> ], desarrollado por Antonin Guttman en el grupo Stonebreaker, fue uno de los nuevos √≠ndices m√°s exitosos dise√±ados para resolver este problema en la pr√°ctica.  Sin embargo, la invenci√≥n de la estructura de √≠ndice no resuelve el problema de soportar rangos multidimensionales en un DBMS para sistemas complejos.  Hay muchas preguntas  ¬øPuede agregar f√°cilmente un m√©todo de acceso, como R-trees, a su DBMS?  ¬øPuede ense√±arle al optimizador a comprender que el m√©todo de acceso especificado ser√° √∫til para ciertas consultas?  ¬øSe puede lograr la recuperaci√≥n correcta y el acceso simult√°neo?  Este fue un punto muy audaz en el plan de acci√≥n de Postgres: un problema de arquitectura de software que afecta a la mayor√≠a del motor de base de datos, desde el optimizador hasta el nivel de almacenamiento, as√≠ como el sistema de registro y recuperaci√≥n.  Los √°rboles R de Postgres se han convertido en una poderosa fuerza impulsora y un excelente ejemplo de la elegante extensibilidad de la capa del m√©todo de acceso y su integraci√≥n en el optimizador de consultas.  Postgres mostr√≥, utilizando un ADT opaco, c√≥mo registrar un m√©todo de acceso descrito de manera abstracta (en este caso, un √°rbol R), y c√≥mo un optimizador de consultas puede reconocer un predicado de selecci√≥n abstracta (en este caso, una elecci√≥n de rango) y compararlo con este m√©todo de acceso descrito de manera abstracta.  Se prest√≥ menos atenci√≥n al control de acceso concurrente en el trabajo inicial: la falta de ordenamiento unidimensional de las llaves hizo que la cerradura utilizada en los √°rboles B en este caso fuera inaplicable. <br><br>  <em>Las caracter√≠sticas prometedoras de los m√©todos de acceso extensible de Postgres inspiraron uno de mis primeros proyectos de investigaci√≥n al final de la escuela de posgrado: √Årboles de b√∫squeda generalizada - GiST [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HNP95</a> ] y el concepto posterior de teor√≠a de indexaci√≥n [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HKM <sup>+</sup> 02</a> ].</em>  <em>Implement√© GiST en Postgres durante un semestre despu√©s de completar mi doctorado, lo que facilit√≥ a√∫n m√°s la adici√≥n de la nueva l√≥gica de indexaci√≥n a Postgres.</em>  <em>La disertaci√≥n de Marcel Kornacker de Berkeley (Marcel Kornacker) resolvi√≥ los complejos problemas de recuperaci√≥n y acceso simult√°neo establecidos por el tipo de "plantilla" extensible de √≠ndice GiST [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">KMH97</a> ].</em> <br><br>  Hoy, PostgreSQL combina favorablemente la arquitectura de software original de los m√©todos de acceso extensible (tiene √≠ndices B-tree, GiST, SP-GiST y Gin) con la extensibilidad y el acceso competitivo intenso de la interfaz del √Årbol de b√∫squeda generalizada (GiST).  Los √≠ndices GiST son compatibles con el popular sistema de geoinformaci√≥n PostGIS basado en PostgreSQL.  Los √≠ndices Gin proporcionan soporte interno de indexaci√≥n de texto en PostgreSQL. <br><br><h3>  2.1.4.  Optimizador de consultas con UDF costosos </h3><br>  En la optimizaci√≥n tradicional de consultas, la tarea consist√≠a en minimizar la cantidad de flujo de tuplas (y, por lo tanto, las operaciones de E / S) creadas al procesar la solicitud.  Esto significaba que las declaraciones que filtran las tuplas (b√∫squeda) son buenas al comienzo del plan de consulta, mientras que las declaraciones que pueden generar nuevas tuplas (uni√≥n) deben ejecutarse m√°s tarde.  Como resultado, los optimizadores de consultas "empujar√°n" a los operadores de b√∫squeda debajo de las conexiones y los organizar√°n al azar, enfoc√°ndose en cambio en la optimizaci√≥n inteligente de las conexiones y los accesos a disco.  Las UDF han cambiado el enfoque: si tiene UDF costosas en sus declaraciones de muestra, el orden de ejecuci√≥n de las UDF puede ser cr√≠tico para optimizar el rendimiento.  Adem√°s, si el UDF en el operador de selecci√≥n realmente toma mucho tiempo, es posible que la selecci√≥n se realice despu√©s de las conexiones (es decir, la selecci√≥n debe ser "pull up" - selecci√≥n "pullup").  Tener en cuenta estos factores ha complicado el espacio de b√∫squeda para el optimizador.  Tom√© este problema como la primera tarea dif√≠cil en la escuela de posgrado, y termin√≥ siendo el tema de mi trabajo de maestr√≠a con Stonebreaker en Berkeley y mi doctorado en Wisconsin bajo la direcci√≥n de Jeff Naughton, pero con la ayuda constante de los consejos de Stonebreaker.  Postgres fue el primer DBMS en almacenar el costo y la selectividad de las funciones definidas por el usuario en un directorio de base de datos.  Abordamos el problema de optimizaci√≥n, habiendo llegado al orden √≥ptimo de las operaciones de muestreo, y luego a la alternancia √≥ptima de las operaciones de muestreo a lo largo de las ramas de cada √°rbol de conexi√≥n considerado en la b√∫squeda del plan.         System R           . <br><br> <em>    ,      ,               . ,     ,     .</em> <br><br>          PostgreSQL       ,            . ,   ,     , ,  2018       . , ,         ,      ,   ,       .    ,  Postgres    . <br><br> <em>  , ,    ,        PostgreSQL       (Neil Conway),                      ¬´ ¬ª .</em> <br><br><h2>  2.2.       </h2><br>  Postgres                   .       :  ,      ¬´  ¬ª,     1990- . <br><br>              .  ‚Äî         Datalog.   ¬´  ¬ª  : , ,                . <br><br> <em>Datalog                ,  -   . Datalog ‚Äî     ¬´ ¬ª     .        ,     ,             .</em> <br><br>   ,     ,     ,             ,       .             . <br><br>             (Eric Hanson),     Ingres,       Postgres.         (Spyros Potamianos)  PRS2: Postgres Rules System 2.           .    ‚Äî     .      ,      Ingres.      ¬´   ¬ª   ¬´       ¬ª. ,   ¬´      ¬ª     ¬´    10%¬ª.     ,     ¬´   ¬ª,           .         (     ),    . <br><br> <em>      PRS2 ,   , .     Postgres       (,  )    Postgres  3.1  1991  (  ):</em> <br><br><pre> <em><font></font>
*        :<font></font>
*     .        <font></font>
*  (. .        <font></font>
* "" )    .   -  <font></font>
*   () .        .<font></font>
*   .    .     <font></font>
*   .  ...<font></font>
* ,  , ? ,    ,  .<font></font>
*         , <font></font>
*  ...</em> </pre><br>       Postgres    ,          ¬´¬ª ‚Äî      .            PostgreSQL,     -           . <br><br>   Postgres          ¬´  ¬ª     IBM Starburst  MCC HiPAC.      SQL        .      .      ,  ,   ,      ,    ¬´  ¬ª:        ,      .  ,   -       ,    ,    ,  ,   .       ,     ,      ,         ,     Postgres. <br><br><h2> 2.3. X      </h2><br>       Postgres  : <br><blockquote>    Postgres,      - .            (write-ahead log ‚Äî WAL),   ,     .  ,   Ingres 1970-     ,         . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SK91</a> ] <br></blockquote>   ,    ,       .               ,    IBM  Tandem    .           :      -  ,   ,      ,    . <br><br> X Postgres             .       ,           ,   , ‚Äî     ¬´  ¬ª  ¬´  ¬ª      .   ,  , ‚Äî         .     ,    ¬´¬ª       .      :                ,      .     Postgres,   ,           ,             ,      [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sto87</a> ].    Postgres   . <br><br>    ¬´ ¬ª           ,      ,        .                    .  ,        ,      ,        ,      Postgres.     Postgres      .         PostgreSQL      . <br><br> <em> , PostgreSQL       :        .   ,  PostgreSQL    ,      Postgres,   ,       Postgres  .    ,      (snapshot isolation) Oracle       -,             .</em> <br><br> <em>  (Mike Olson) ,       ,    B- Postgres    B-   Berkeley DB,       Postgres.         .    Berkeley DB     Sleepycat Corp.,    ()  PostgreSQL       ¬´ ¬ª.  :    ,        (MVCC),       ,   .</em> <br><br> <em>   PostgreSQL     .  Greenplum  PostgreSQL        .      (Matt McCline)‚Äî    (Jim Gray)   Tandem.      .</em> <br><br>         .  ,                   NoSQL (  ,   WAL),        (MMDB ‚Äî main memory databases,        ).              ,            .  ,             . <br><br><h2> 2.4.           </h2><br>  En medio del proyecto Postgres, Stonebreaker se inscribi√≥ como uno de los ejecutivos para una gran subvenci√≥n digital de ciencias de la tierra llamada Proyecto Sequoia.  Parte de la propuesta de subvenci√≥n fue el procesamiento de cantidades sin precedentes de im√°genes satelitales digitales, que requieren hasta 100 terabytes de memoria, es decir, una cantidad de datos mucho mayor de lo que ser√≠a conveniente almacenar en discos magn√©ticos en ese momento.  La base de la soluci√≥n propuesta fue investigar la idea de crear un DBMS (es decir, Postgres), que facilite el acceso al almacenamiento "terciario" semiaut√≥nomo proporcionado por unidades rob√≥ticas con reemplazo autom√°tico de discos para administrar bibliotecas de discos √≥pticos o cintas. <br><br>  Esto condujo a varios estudios diferentes.  Uno de ellos fue el sistema de archivos Inversion, un intento de proporcionar una abstracci√≥n del sistema de archivos UNIX a trav√©s de un DBMS relacional.  En un art√≠culo de revisi√≥n para Sequoia, Stonebreaker lo describi√≥ en su estilo habitual de patrocinar "ejercicio simple" [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sto95</a> ].  De hecho, Mike Olson, un estudiante de Stonebreaker (y el posterior fundador de Cloudera), ha estado ocupado con esto durante varios a√±os, y el resultado final no fue muy sencillo [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ols93</a> ] y no sobrevivi√≥ en la pr√°ctica. <br><br>  <em>Unos a√±os m√°s tarde, Inversion Bill Gates "luch√≥ contra los mismos molinos de viento" en WinFS, un intento de recrear el sistema de archivos m√°s utilizado en el mundo a trav√©s de una base de datos relacional.</em>  <em>WinFS se envi√≥ en versiones de desarrollo de Windows, pero nunca ingres√≥ al mercado.</em>  <em>Gates m√°s tarde lo llam√≥ su mayor decepci√≥n en Microsoft.</em> <br><br>  Otra √°rea principal de investigaci√≥n en este frente fue la inclusi√≥n de un repositorio terciario en la pila de bases de datos relacionales m√°s t√≠picas, que fue el tema de una tesis doctoral de Sunita Sarawagi.  El tema principal fue cambiar la escala en la que piensa administrar el espacio (es decir, los datos almacenados y la jerarqu√≠a de la memoria) y el tiempo (coordinar la programaci√≥n de consultas y la memoria cach√© para minimizar las E / S no deseadas).  Uno de los problemas clave en este trabajo fue almacenar grandes matrices multidimensionales en un almacenamiento terciario y recuperarlas, lo que hace eco del trabajo en el campo de la indexaci√≥n multidimensional.  Las ideas clave incluyeron dividir la matriz en porciones y almacenar juntas las porciones que se seleccionan juntas, as√≠ como replicar las porciones para que la porci√≥n de datos pueda tener varios "vecinos" f√≠sicos.  El segundo problema es pensar en c√≥mo el disco se convierte en un cach√© para el almacenamiento terciario.  Finalmente, la optimizaci√≥n y la programaci√≥n de consultas deben tener en cuenta el largo tiempo de carga de datos del almacenamiento terciario y la importancia de los hits (hits) de la memoria cach√© del disco.  Esto afecta tanto el plan elegido por el optimizador de consultas como el tiempo que lleva completar el plan. <br><br>  Los robots en cintas y discos √≥pticos actualmente no se usan ampliamente.  Pero los problemas de almacenamiento terciario son muy comunes en la nube, que en 2018 tiene una jerarqu√≠a de almacenamiento profundo: desde SSD conectados a servicios de almacenamiento confiables similares a un disco (por ejemplo, AWS EBS), al almacenamiento de archivos (por ejemplo, en AWS S3), al almacenamiento profundo (por ejemplo , Glaciar AWS).  Hoy en d√≠a, estos niveles de almacenamiento a√∫n est√°n relativamente separados, y la base de datos pr√°cticamente no admite el razonamiento sobre el almacenamiento de extremo a extremo que abarca estos niveles.  No me sorprender√≠a si las preguntas investigadas en este frente en Postgres se revisaran pronto. <br><br><h2>  2.5.  Soporte multiprocesador: XPRS </h2><br>  Stonebreaker nunca cre√≥ un gran sistema de base de datos paralela, pero dirigi√≥ muchas discusiones desafiantes en esta √°rea.  Su art√≠culo "Caso para nada compartido" [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sto86</a> ] document√≥ soluciones arquitect√≥nicas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modulares</a> grandes en esta √°rea.  √âl populariz√≥ la terminolog√≠a utilizada en la industria y desconcert√≥ el soporte de arquitecturas sin recursos compartidos, como Gamma y Teradata, que fueron redescubiertos en la d√©cada de 2000 por la comunidad de Big Data. <br><br>  Ir√≥nicamente, la contribuci√≥n m√°s importante de Stonebreaker al campo de las bases de datos paralelas fue la arquitectura de "memoria compartida" llamada XPRS, que significaba "Postgres extendidos en RAID y Sprite".  A principios de la d√©cada de 1990, XPRS era la "liga de la justicia" para los sistemas Berkeley: combina el sistema abreviado Postgres Stonebreaker, John Ousterhout, el sistema operativo Sprite distribuido y la arquitectura RAID de Dave Patterson y Randy Katz )  Al igual que con muchos trabajos interprofesionales, la implementaci√≥n del proyecto XPRS en realidad fue determinada por los estudiantes graduados que trabajaron en √©l.  Result√≥ que la contribuci√≥n principal fue hecha por Wei Hong, quien escribi√≥ su tesis de doctorado sobre optimizaci√≥n de consultas paralelas en XPRS.  Por lo tanto, la principal contribuci√≥n de XPRS a la literatura y la industria fue optimizar las solicitudes concurrentes sin abordar significativamente los problemas asociados con RAID o Sprite. <br><br>  <em>De estos tres proyectos, Postgres y RAID tuvieron un gran impacto en el futuro.</em>  <em>Sprite es mejor recordado por la tesis doctoral de Mendel Rosenblum sobre Log Structured File Systems (LFS), que no tuvo nada que ver con los sistemas operativos distribuidos.</em>  <em>Los tres proyectos conten√≠an nuevas ideas para el almacenamiento en disco, adem√°s de modificar copias individuales en su lugar.</em>  <em>LFS y el administrador del repositorio de Postgres son bastante similares en su nuevo tratamiento de la revista como el repositorio principal y la necesidad de una costosa reorganizaci√≥n en segundo plano.</em>  <em>Una vez, examin√© cuidadosamente al Rompepiedras sobre la rivalidad entre LFS y Postgres o los "hechos fritos" acad√©micos sobre su relaci√≥n, pero nunca aprend√≠ nada interesante de √©l.</em>  <em>Quiz√°s en ese momento en Berkeley alguien estaba "removiendo agua".</em> <br><br>  En principio, la concurrencia "explota" el espacio de los planes del optimizador de consultas, multiplicando las elecciones tradicionales realizadas durante la optimizaci√≥n de consultas (acceso a datos, algoritmos de conexi√≥n, orden de conexi√≥n) por todas las formas posibles de paralelizar cada opci√≥n.  La idea principal del "optimizador Wei Hong" llamado por Stonebreaker era dividir el problema en dos: lanzar el optimizador de consultas tradicional en el esp√≠ritu del Sistema R para un nodo, y luego "paralelizar" el plan resultante, planificar el grado de paralelismo y la ubicaci√≥n de cada operador en funci√≥n de la representaci√≥n datos y configuraci√≥n del sistema.  Este enfoque es heur√≠stico, pero en √©l la concurrencia aumenta el costo de la optimizaci√≥n de consultas tradicionales de forma aditiva, en lugar de multiplicativa. <br><br>  Aunque el optimizador de Wei Hong se desarroll√≥ en el contexto de Postgres, se ha convertido en el enfoque est√°ndar para muchos optimizadores de consultas concurrentes en la industria. <br><br><h2>  2.6.  Soporte para varios modelos de idiomas. </h2><br>  Entre los intereses de Stonebreaker, renovado en repetidas ocasiones desde la √©poca de Ingres, estaba la interfaz de programaci√≥n de aplicaciones (API) del sistema de base de datos.  En sus conferencias en la serie Sistemas de bases de datos, a menudo inclu√≠a el lenguaje GEM Carlo Zaniolo como un tema que es importante de entender para los defensores del sistema de bases de datos.  Este inter√©s en el lenguaje indudablemente lo llev√≥ a asociarse con Larry Rowe en Postgres, lo que a su vez influy√≥ profundamente en el dise√±o del modelo de datos de Postgres y su enfoque de relaci√≥n de objetos.  Su trabajo se centr√≥ principalmente en aplicaciones para trabajar con un gran volumen de datos de la esfera comercial, incluido el procesamiento de informaci√≥n comercial y nuevas aplicaciones como CAD / CAM y GIS. <br><br>  Uno de los problemas que se impuso a Stonebreaker en ese momento fue la idea de "ocultar" los l√≠mites entre las construcciones del lenguaje de programaci√≥n y el repositorio de la base de datos.  Varios proyectos de investigaci√≥n competitivos y compa√±√≠as que investigan bases de datos orientadas a objetos (OODB) se han enfocado en la llamada "p√©rdida de conformidad" entre los lenguajes de programaci√≥n orientados a objetos imperativos como Smalltalk, C ++ y Java, y los relacionales declarativos modelo  La idea de OODB era hacer que los objetos del lenguaje de programaci√≥n, si se desea, se marcaran como "permanentes" y se procesaran autom√°ticamente por el DBMS incorporado.  Postgres admiti√≥ el almacenamiento de objetos anidados y tipos de datos abstractos, pero su interfaz, basada en consultas declarativas en un estilo relacional, asumi√≥ el acceso no natural a la base de datos para el programador (requer√≠a el uso de consultas declarativas), que tambi√©n eran costosas (requer√≠an an√°lisis y optimizaci√≥n).  Para competir con los proveedores de OODB, Postgres proporcion√≥ la llamada interfaz Fast Path: esencialmente la API C / C ++ para el almacenamiento interno de la base de datos.  Esto permiti√≥ a Postgres tener un rendimiento acad√©mico de referencia OODB promedio, pero nunca resolvi√≥ el problema de permitir que los programadores en diferentes idiomas eviten el problema de perder el cumplimiento.  En cambio, Stonebreaker etiquet√≥ a Postgres como una etiqueta "relacional de objetos" y simplemente evit√≥ el uso de bases de datos orientadas a objetos como un mercado de cero mil millones de d√≥lares.  Hoy en d√≠a, casi todos los sistemas de bases de datos relacionales comerciales son sistemas de bases de datos "relacionales con objetos". <br><br>  Esto result√≥ ser una soluci√≥n razonable.  Hoy en d√≠a, ninguno de los productos OODB existe en su forma prevista, y la idea de "objetos persistentes" en los lenguajes de programaci√≥n se ha descartado en gran medida.  Por el contrario, el uso de capas de mapeo relacional de objetos (ORM) est√° muy extendido, impulsado por trabajos iniciales, como Java Hibernate y Ruby on Rails, lo que permite "adaptar" bases de datos declarativas a casi cualquier objeto imperativo de manera relativamente fluida. lenguaje de programaci√≥n orientado como bibliotecas.  Este enfoque a nivel de aplicaci√≥n difiere de las bases de datos relacionales de objetos OODB y Stonebreaker.  Adem√°s, los almacenamientos ligeros de valor-clave tambi√©n se utilizan con √©xito en formas no transaccionales y transaccionales.  Su descubridor fue la estudiante graduada de Stonebreaker Margo Seltzer, quien trabaj√≥ en la base de datos de Berkeley DB como parte de su tesis doctoral al mismo tiempo que el grupo Postgres, que anticip√≥ el crecimiento de repositorios distribuidos de valores clave NoSQL como Dynamo , MongoDB y Cassandra. <br><br><h1>  3. Impacto en el software </h1><br><h2>  3.1.  C√≥digo abierto </h2><br>  Postgres siempre ha sido un proyecto de c√≥digo abierto con lanzamientos consistentes, pero al principio estaba destinado a ser utilizado para la investigaci√≥n en lugar de la producci√≥n. <br><br>  A medida que se acortaba el proyecto de investigaci√≥n de Postgres, dos estudiantes de Stonebreaker, Andrew Yu y Jolly Chen, modificaron el analizador del sistema para reemplazar el lenguaje original de Postquel con una variante SQL extensible.  La primera versi√≥n de Postgres que admite SQL fue Postgres95, y la siguiente se llam√≥ PostgreSQL. <br><br>  Un equipo de desarrollo de c√≥digo abierto se interes√≥ en PostgreSQL y lo "acept√≥" incluso cuando cambiaron los intereses del resto del equipo de Berkeley.  El equipo central de PostgreSQL se ha mantenido relativamente estable con el tiempo, y el proyecto de c√≥digo abierto se ha desarrollado altamente.  Inicialmente, los esfuerzos se centraron en la estabilidad del c√≥digo y la funcionalidad visible para el usuario, pero con el tiempo, la comunidad de software de c√≥digo abierto ha cambiado y mejorado significativamente el n√∫cleo del sistema, desde el optimizador hasta los m√©todos de acceso y el sistema principal de transacciones y almacenamiento.  Desde mediados de la d√©cada de 1990, una fracci√≥n muy peque√±a de los componentes internos de PostgreSQL provino del equipo acad√©mico de Berkeley.  Su √∫ltima contribuci√≥n puede haber sido mi implementaci√≥n de GiST en la segunda mitad de la d√©cada de 1990, pero incluso fue sustancialmente reescrita y aprobada por voluntarios de la comunidad de c√≥digo abierto (en este caso, Rusia).  La parte de la comunidad de c√≥digo abierto que trabaja en PostgreSQL merece los mayores elogios por su proceso simplificado, que durante d√©cadas ha servido para crear un proyecto altamente eficiente y a largo plazo. <br><br>  Aunque mucho ha cambiado durante 25 a√±os, la arquitectura subyacente de PostgreSQL sigue siendo muy similar a las versiones universitarias de Postgres a principios de la d√©cada de 1990, y los desarrolladores familiarizados con el c√≥digo fuente actual de PostgreSQL encontrar√°n f√°cil leer el c√≥digo fuente de Postgres 3.1 (1991).  Todo, desde la estructura del directorio del c√≥digo fuente hasta las estructuras del proceso y las estructuras de datos, sigue siendo sorprendentemente similar.  El c√≥digo del equipo de Postgres en Berkeley ten√≠a una gran columna vertebral. <br><br>  Hoy, PostgreSQL es sin duda el sistema de gesti√≥n de bases de datos de c√≥digo abierto de m√°s alto rendimiento, y admite funcionalidades que a menudo no se encuentran en productos comerciales.  Tambi√©n es (seg√∫n un sitio de calificaci√≥n influyente) el DBMS de c√≥digo abierto independiente m√°s popular del mundo, y su influencia contin√∫a creciendo: en 2017 y 2018, fue la base de datos con la popularidad de m√°s r√°pido crecimiento en el mundo [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DE19c</a> ].  PostgreSQL se usa en una amplia variedad de industrias y tareas, lo cual no es sorprendente, dado su enfoque en amplias oportunidades. <br><br>  <em>Seg√∫n DB-Engines, PostgreSQL hoy es la cuarta base de datos m√°s popular del mundo, despu√©s de Oracle, MySQL y MS SQL Server, los cuales son ofrecidos por compa√±√≠as espec√≠ficas (MySQL fue adquirido por Oracle hace muchos a√±os) [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DE19a</a> ].</em>  <em>Las reglas de clasificaci√≥n se discuten en la descripci√≥n de la metodolog√≠a de clasificaci√≥n DB-Engines [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DE19b</a> ].</em> <br><br>  Heroku es el proveedor de la nube SaaS que ahora forma parte de Salesforce.  Postgres se introdujo en Heroku en 2010 como la base de datos predeterminada para su plataforma.  Heroku eligi√≥ Postgres por su fiabilidad.  Con el soporte de Heroku, las plataformas de desarrollo de aplicaciones m√°s grandes como Ruby on Rails y Python para Django comenzaron a recomendar Postgres como la base de datos predeterminada. <br><br>  Hoy, PostgreSQL admite una infraestructura de extensi√≥n que facilita la adici√≥n de funciones adicionales al sistema a trav√©s de funciones definidas por el usuario y modificaciones relacionadas.  Ahora hay un ecosistema de extensiones PostgreSQL, similar al concepto m√°s completo de los paquetes de extensi√≥n DataBlade, pero con c√≥digo fuente abierto.  Las extensiones m√°s interesantes incluyen, por ejemplo, la biblioteca Apache MADlib para aprendizaje autom√°tico en la interfaz SQL y la biblioteca Citus para la ejecuci√≥n de consultas paralelas. <br><br>  Una de las aplicaciones de c√≥digo abierto m√°s interesantes desarrolladas en Postgres es el sistema de informaci√≥n geogr√°fica PostGIS, que utiliza muchas de las caracter√≠sticas de Postgres que originalmente inspiraron a Stonebreaker para comenzar el proyecto. <br><br><h2>  3.2.  Implementaci√≥n comercial </h2><br>  PostgreSQL ha sido durante mucho tiempo un punto de partida atractivo para crear sistemas de bases de datos comerciales, dado su uso bajo la licencia de software de c√≥digo abierto "todo permitido", c√≥digo confiable, flexibilidad y amplia funcionalidad.  Resumiendo los costos de adquisici√≥n enumerados a continuaci√≥n, vemos que Postgres recibi√≥ m√°s de $ 2.6 mil millones en costos de adquisici√≥n. <br><br>  <em>Tenga en cuenta que esta es una medida en d√≥lares de transacciones financieras reales y es mucho m√°s importante que los valores que a menudo se utilizan en alta tecnolog√≠a.</em>  <em>Las cifras en miles de millones a menudo se usan para describir el valor estimado de bloques de acciones, pero a menudo se exageran 10 veces o m√°s en comparaci√≥n con el valor presente con la esperanza de su importancia futura.</em>  <em>Los d√≥lares de transacci√≥n de adquisici√≥n de la compa√±√≠a miden su valor de mercado real en el momento de la adquisici√≥n.</em>  <em>Es justo decir que Postgres ha creado m√°s de $ 2.6 mil millones de valor comercial real.</em> <br><br>  Muchos de los esfuerzos comerciales asociados con PostgreSQL se han centrado en lo que probablemente sea su principal limitaci√≥n: la capacidad de escalar a una arquitectura paralela sin compartir recursos. <br><br>  <em>Paralelizar PostgreSQL requiere una buena cantidad de trabajo, pero es muy factible por un equipo peque√±o y experimentado.</em>  <em>Hoy en d√≠a, las ramas de la industria de c√≥digo abierto de PostgreSQL como Greenplum y CitusDB brindan esta oportunidad.</em>  <em>Es lamentable que PostgreSQL no se haya paralelo correctamente en c√≥digo abierto mucho antes.</em>  <em>Si PostgreSQL se hubiera expandido en c√≥digo abierto con soporte para una arquitectura sin recursos compartidos a principios de la d√©cada de 2000, es posible que la direcci√≥n de big data de c√≥digo abierto se hubiera desarrollado de una manera completamente diferente y m√°s eficiente.</em> <br><br><ol><li>  Illustra fue la segunda startup m√°s grande de Stonebreaker, fundada en 1992 para comercializar Postgres, cuando RTI lanz√≥ Ingres en el mercado. <br><br>  <em>Illustra fue en realidad el tercer nombre propuesto para la empresa.</em>  <em>Continuando con el tema de la pintura, dado el nombre de Ingres, Illustra originalmente se llamaba Miro.</em>  <em>Debido a problemas con la marca registrada, el nombre se cambi√≥ a Montage, pero tambi√©n encontr√≥ problemas con la marca registrada.</em> <br><br>  El equipo fundador incluy√≥ parte del n√∫cleo del equipo de Postgres, incluido el reciente estudiante graduado Wei Hong y luego el programador jefe Jeff Meredith, as√≠ como los graduados de Ingres Paula Hawthorn y Michael Ubell.  El estudiante graduado de Postgres Mike Olson se uni√≥ poco despu√©s de su fundaci√≥n, y trabaj√© en Illustra para optimizar funciones costosas como parte de mi doctorado.  Illustra    :  SQL92      ,    Postquel,    Postgres               DataBlade ‚Äî       . Illustra   Informix  1997     400 . .  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mon96</a> ],    DataBlade         Informix  Informix Universal Server. <br></li><li> Netezza  ,   1999 ,    PostgreSQL             FPGA. Netezza     ,        2007 .       IBM  1,7 . .  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IBM10</a> ]. <br></li><li> Greenplum         PostgreSQL   .   2003 , Greenplum     PostgreSQL,      API PostgreSQL,  API   .    , Greenplum  PostgreSQL         ,   ,   Orca. Greenplum   EMC  2010   300 . . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mal10</a> ],   2012  EMC  Greenplum     Pivotal.  2015  Pivotal    Greenplum  Orca    .    Greenplum   Postgres API   MADlib     SQL [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HRS+12</a> ]. MADlib     Apache.        ,   Greenplum,  Apache HAWQ,   Pivotal,   ¬´ ¬ª Greenplum (. .         PostgreSQL)    ,     Hadoop. <br></li><li> EnterpriseDB    2004   ,          PostgreSQL   ,             .    EnterpriseDB Advanced Server      Oracle,     Oracle. <br></li><li>  Aster Data    2005    ,      .        PostgreSQL. Aster             ,        SQL  MapReduce. Aster Data    Teradata  2011   263 . . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sho11</a> ].  Teradata    Aster       ,  -  Aster             Teradata. <br></li><li>  ParAccel    2006 ,    PostgreSQL      . ParAccel   Postgres        .  2011  Amazon   ParAccel,   2012   AWS Redshift ‚Äî             ParAccel.  2013  ParAccel    Actian (   Ingres)    ,  ,        Actian.    AWS Redshift     Amazon ‚Äî            Amazon,   ,            ,   Teradata  Oracle Exadata.    Postgres       . <br></li><li>  CitusDB <em>(CitusDB ‚Äî  ;   Citus Data. ‚Äî . .)</em>    2010 ,     PostgreSQL   .      PostgreSQL,  2016  CitusDB    API  PostgreSQL        PostgreSQL.  2016   CitusDB     . <br></li></ol><br><h1> 4.  </h1><br>        Postgres,       . <br><br>   ,   ,   ,  Postgres   ¬´  ¬ª (Second System Effect)    (Fred Brooks) [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bro75</a> ].  ,          ,    -    . Postgres    ,  , ,     .      ,     ,       .     ‚Äî    Postgres     ,      .               :     ,    .  , ¬´ ¬ª  .    ,    ,      .       ¬´-¬ª    ,      ¬´-¬ª    . <br><br>     ,    , ¬´   ¬ª,       ,    .     <em>( 2001           (). ‚Äî . .)</em>          2000-   ¬´    ¬ª.          ,         Postgres. ,            ,       . <br><br> <em>   (Ralph Waldo Emerson), ¬´  ‚Äî   ¬ª.</em> <br><br> ,     ¬´    ¬ª (       ),   ,      ,      , ,               .  ,           .   ,        ,       - .    ,   .          ,     . <br><br>  ,     Postgres, ‚Äî   ,          .        ¬´ ¬ª  PostgreSQL,       ,        .  ,    : <br><blockquote>  ,  ,            ,          1995 .  Postgres,     ,     .       ,     ,            ,       . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sto14</a> ] <br></blockquote>  ,   ,     ,  ,   ¬´ ¬ª   .      ¬´ ¬ª.   , ,  ,         ,       Postgres.     - ,    : ¬´ -      ¬ª.   (  ),         . <br><br><h1> 5.  </h1><br>       Postgres  ,          ,     (Craig Kerstiens)      PostgreSQL. <br><br><h1>  Literatura </h1><br><ul><li><a name="Bro75"></a> [Bro75] Frederick P Brooks. The mythical man-month, 1975. </li><li><a name="Bro19"></a> [Bro19] Michael L. Brodie, editor. Making Databases Work. Morgan &amp; Claypool, 2019. </li><li><a name="DE19a"></a> [DE19a] DB-Engines. DB-Engines ranking, 2019. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">db-engines.com/en/ranking</a> . (Last accessed January 4, 2019). </li><li><a name="DE19b"></a> [DE19b] DB-Engines. Method of calculating the scores of the DB-Engines ranking, 2019. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">db-engines.com/en/ranking_definition</a> (Last accessed January 4, 2019). </li><li><a name="DE19c"></a> [DE19c] DB-Engines. PostgreSQL is the DBMS of the year 2018, January 2019. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">db-engines.com/en/blog_post/79</a> (Last accessed January 4, 2019). </li><li><a name="DS08"></a> [DS08] David DeWitt and Michael Stonebraker. Mapreduce: A major step backwards. The Database Column, 1:23, 2008. </li><li><a name="Gut84"></a> [Gut84] Antonin Guttman. R-trees: A dynamic index structure for spatial searching. In Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data, SIGMOD '84, pages 47‚Äì57, New York, NY, USA, 1984. ACM. </li><li><a name="HKM02"></a> [HKM <sup>+</sup> 02] Joseph M. Hellerstein, Elias Koutsoupias, Daniel P. Miranker, Christos H. Papadimitriou, and Vasilis Samoladas. On a model of indexability and its bounds for range queries. J. ACM, 49(1):35‚Äì55, January 2002. </li><li><a name="HNP95"></a> [HNP95] Joseph M. Hellerstein, Jeffrey F. Naughton, and Avi Pfeffer. Generalized search trees for database systems. In Proceedings of the 21th International Conference on Very Large Data Bases, VLDB '95, pages 562‚Äì573, San Francisco, CA, USA, 1995. Morgan Kaufmann Publishers Inc. </li><li><a name="HRS12"></a> [HRS <sup>+</sup> 12] Joseph M Hellerstein, Christoper Re, Florian Schoppmann, Daisy Zhe Wang, Eugene Fratkin, Aleksander Gorajek, Kee Siong Ng, Caleb Welton, Xixuan Feng, Kun Li, et al. The MADlib analytics library: or MAD skills, the SQL. Proceedings of the VLDB Endowment, 5(12):1700‚Äì1711, 2012. </li><li><a name="IBM10"></a> [IBM10] IBM to acquire Netezza, September 2010. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www-03.ibm.com/press/us/en/pressrelease/32514.wss#release</a> (Last accessed January 22, 2018). </li><li><a name="KMH97"></a> [KMH97] Marcel Kornacker, C. Mohan, and Joseph M. Hellerstein. Concurrency and recovery in generalized search trees. In Proceedings of the 1997 ACM SIGMOD International Conference on Management of Data, SIGMOD '97, pages 62‚Äì72, New York, NY, USA, 1997. ACM. </li><li><a name="Mal10"></a> [Mal10] Om Malik. Big Data = Big Money: EMC Buys Greenplum. In GigaOm, July 2010. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gigaom.com/2010/07/06/emc-buys-greenplum</a> . </li><li><a name="Mon96"></a> [Mon96] John Monroe. Informix acquires illustra for complex data management. In Federal Computer Week, January 1996. </li><li><a name="OFS83"></a> [OFS83] James Ong, Dennis Fogg, and Michael Stonebraker. Implementation of data abstraction in the relational database system ingres. ACM Sigmod Record, 14(1):1‚Äì14, 1983. </li><li><a name="Ols93"></a> [Ols93] Michael A. Olson. The design and implementation of the inversion file system. 1993. </li><li><a name="SAHR84"></a> [SAHR84] Michael Stonebraker, Erika Anderson, Eric Hanson, and Brad Rubenstein. Quel as a data type. In Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data, SIGMOD '84, pages 208‚Äì214, New York, NY, USA, 1984. ACM. </li><li><a name="Sho11"></a> [Sho11] Erick Shonfeld. Big pay day for big data. teradata buys aster data for $263 million. In TechCrunch, May 2011. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">techcrunch.com/2011/03/03/teradata-buys-aster-data-263-million</a> (Last accessed January 22, 2018). </li><li><a name="SHWK76"></a> [SHWK76] Michael Stonebraker, Gerald Held, Eugene Wong, and Peter Kreps. The design and implementation of ingres. ACM Transactions on Database Systems (TODS), 1(3):189‚Äì222, 1976. </li><li><a name="SK91"></a> [SK91] Michael Stonebraker and Greg Kemnitz. The postgres next generation database management system. Commun. ACM, 34(10):78‚Äì92, October 1991. </li><li><a name="SR86"></a> [SR86] Michael Stonebraker and Lawrence A. Rowe. The design of postgres. In Proceedings of the 1986 ACM SIGMOD International Conference on Management of Data, SIGMOD '86, pages 340‚Äì355, New York, NY, USA, 1986. ACM. </li><li><a name="SRG83"></a> [SRG83] M Stonebraker, B Rubenstein, and A Guttman. Application of abstract data types and abstract indices to cad bases. IEEE Trans, on Software Engineering, 1983. </li><li><a name="Sto86"></a> [Sto86] Michael Stonebraker. The case for shared nothing. IEEE Database Eng. Bull., 9(1):4‚Äì9, 1986. </li><li><a name="Sto87"></a> [Sto87] Michael Stonebraker. The design of the postgres storage system. In Proceedings of the 13th International Conference on Very Large Data Bases, VLDB '87, pages 289‚Äì300, San Francisco, CA, USA, 1987. Morgan Kaufmann Publishers Inc. </li><li><a name="Sto95"></a> [Sto95] Michael Stonebraker. An overview of the sequoia 2000 project. Digital Technical Journal, 7(3):39‚Äì49, 1995. </li><li><a name="Sto14"></a> [Sto14] Michael Stonebraker. The land sharks are on the squawk box, 2014. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.acm.org/turing-lecture-stonebraker</a> (Last accessed January 4, 2019). </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438890/">https://habr.com/ru/post/438890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438878/index.html">La aparici√≥n de la pel√≠cula en torrentes despu√©s del estreno aumenta la taquilla en un 3%</a></li>
<li><a href="../438880/index.html">Cu√°ndo usar var, let y const en Javascript [traducci√≥n del art√≠culo de Tyler McGinnis]</a></li>
<li><a href="../438882/index.html">La probabilidad de ganar un partido con una probabilidad conocida de ganar un punto</a></li>
<li><a href="../438884/index.html">Historia real de una agencia de publicidad interior: altibajos e implementaci√≥n de CRM</a></li>
<li><a href="../438886/index.html">Morty, estamos en UltraHD! C√≥mo ver cualquier pel√≠cula en 4K, complet√°ndola a trav√©s de una red neuronal poco conocida</a></li>
<li><a href="../438892/index.html">¬øQu√© es una blockchain corporativa?</a></li>
<li><a href="../438894/index.html">¬øPor qu√© el desarrollo web en Go es mejor que en PHP?</a></li>
<li><a href="../438896/index.html">No llores negocios</a></li>
<li><a href="../438898/index.html">Instalaci√≥n inversa de Chrome y extensi√≥n</a></li>
<li><a href="../438900/index.html">En el camino hacia los principios f√≠sicos de la evoluci√≥n biol√≥gica. Fin + texto completo de la traducci√≥n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>