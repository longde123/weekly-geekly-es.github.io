<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≥ ‚öΩÔ∏è üë• NCBI Genome Workbench: Pesquisa em Perigo üàØÔ∏è üï∂Ô∏è üêÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tecnologias modernas de computador, solu√ß√µes t√©cnicas e de software - tudo isso facilita e acelera a implementa√ß√£o de v√°rias pesquisas cient√≠ficas. Fr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NCBI Genome Workbench: Pesquisa em Perigo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/430476/"><img src="https://habrastorage.org/getpro/habr/post_images/9ce/9dc/792/9ce9dc792e9661eba72b3692521754be.png" align="left">  Tecnologias modernas de computador, solu√ß√µes t√©cnicas e de software - tudo isso facilita e acelera a implementa√ß√£o de v√°rias pesquisas cient√≠ficas.  Freq√ºentemente, a simula√ß√£o por computador √© a √∫nica maneira de testar muitas teorias.  O software cient√≠fico tem suas pr√≥prias caracter√≠sticas.  Por exemplo, esse software geralmente √© submetido a testes muito completos, mas √© pouco documentado.  No entanto, o software √© escrito por pessoas, e as pessoas cometem erros.  Erros em programas cient√≠ficos podem p√¥r em d√∫vida toda a pesquisa.  Este artigo listar√° dezenas de problemas encontrados no c√≥digo do pacote de software NCBI Genome Workbench. <br><a name="habracut"></a><br><h2>  1. Introdu√ß√£o </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O NCBI Genome Workbench</a> oferece aos pesquisadores uma ampla gama de ferramentas para estudar e analisar dados gen√©ticos.  Os usu√°rios podem pesquisar e comparar dados de v√°rias fontes, incluindo os bancos de dados do NCBI (National Center for Biotechnology Information) ou seus pr√≥prios dados pessoais. <br><br>  Como mencionado anteriormente, o software cient√≠fico geralmente √© bem coberto por testes de unidade.  Ao verificar este projeto, 85 diret√≥rios com arquivos de teste foram exclu√≠dos da an√°lise.  S√£o cerca de mil arquivos.  Talvez isso se deva aos requisitos para testar v√°rios algoritmos complexos que s√£o inventados para v√°rios estudos.  Mas a qualidade do restante do c√≥digo (n√£o o teste) n√£o est√° em um n√≠vel t√£o alto quanto gostar√≠amos.  No entanto, como em qualquer projeto em que eles ainda n√£o se encarregaram de introduzir ferramentas est√°ticas de an√°lise de c√≥digo :). <br><br>  Os dados para revis√£o (ou mesmo pesquisa) do c√≥digo foram fornecidos pelo analisador de c√≥digo est√°tico para C / C ++ / C # / Java - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PVS-Studio</a> . <br><br><h2>  Apenas dois n√∫meros que arruinam seu projeto </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dad/9f3/20b/dad9f320b84473428205cc1227a20fe6.png"></div><br><br>  Com base em nosso banco de dados de erros, que atualmente soma mais de 12 mil exemplos selecionados, observamos e descrevemos padr√µes espec√≠ficos para escrever c√≥digo que levam a in√∫meros erros.  Por exemplo, realizamos os seguintes estudos: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O efeito da √∫ltima linha</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A fun√ß√£o mais perigosa do mundo do C / C ++</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Express√µes l√≥gicas em C / C ++.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Qu√£o errados s√£o os profissionais</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O mal vive em fun√ß√µes de compara√ß√£o</a> . </li></ol><br>  Este projeto marcou o in√≠cio da descri√ß√£o do novo padr√£o.  Estamos falando dos n√∫meros <b>1</b> e <b>2</b> nos nomes das vari√°veis, por exemplo, <i>arquivo1</i> e <i>arquivo2</i> , etc.  √â muito f√°cil confundir duas dessas vari√°veis.  Este √© um caso especial de erro de digita√ß√£o no c√≥digo, mas um desses erros resulta no desejo de trabalhar com vari√°veis ‚Äã‚Äãcom o mesmo nome, que diferem apenas pelos n√∫meros 1 e 2 no final do nome. <br><br>  No futuro, direi que todos os estudos listados acima foram confirmados no c√≥digo deste projeto: D. <br><br>  Considere o primeiro exemplo do projeto Genome Workbench: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V501</a> Existem sub-express√µes id√™nticas '(! Loc1.IsInt () &amp;&amp;! Loc1.IsWhole ())' √† esquerda e √† direita da '||'  operador.  nw_aligner.cpp 480 <br><br><pre><code class="cpp hljs">CRef&lt;CSeq_align&gt; CNWAligner::Run(CScope &amp;scope, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSeq_loc &amp;loc1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSeq_loc &amp;loc2, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> trim_end_gaps) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((!loc1.IsInt() &amp;&amp; !loc1.IsWhole()) || (!loc1.IsInt() &amp;&amp; !loc1.IsWhole())) { NCBI_THROW(CException, eUnknown, <span class="hljs-string"><span class="hljs-string">"Only whole and interval locations supported"</span></span>); } .... }</code> </pre> <br>  Vemos duas vari√°veis ‚Äã‚Äãnomeadas <i>loc1</i> e <i>loc2</i> .  E tamb√©m um erro no c√≥digo: a vari√°vel <i>loc2</i> n√£o <i>√©</i> usada, porque em vez disso, <i>loc1</i> √© usada novamente. <br><br>  Outro exemplo: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V560</a> Uma parte da express√£o condicional √© sempre falsa: s1.IsSet ().  valid_biosource.cpp 3073 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s_PCRPrimerSetLess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CPCRPrimerSet&amp; s1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CPCRPrimerSet&amp; s2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!s1.IsSet() &amp;&amp; s1.IsSet()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.IsSet() &amp;&amp; !s2.IsSet()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!s1.IsSet() &amp;&amp; !s2.IsSet()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.Get().size() &lt; s2.Get().size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.Get().size() &gt; s2.Get().size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ..... }</code> </pre> <br>  A primeira linha de c√≥digo misturou as vari√°veis <i>s1</i> e <i>s2</i> .  Com base no nome, esta √© uma fun√ß√£o de compara√ß√£o.  Mas esse erro pode estar em qualquer lugar, porque, ao nomear as vari√°veis <i>N√∫mero 1</i> e <i>N√∫mero 2</i> , o programador quase certamente cometer√° um erro no futuro.  E quanto mais usos desses nomes em uma fun√ß√£o, maior a probabilidade de um erro. <br><br><h2>  Outros erros de digita√ß√£o e copiar e colar </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d5/d9f/f6b/6d5d9ff6bf8083922701b25273fa50b2.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V501</a> Existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">subexpress√µes</a> id√™nticas √† esquerda e √† direita do operador '! =': Bd.bit_.bits [i]! = Bd.bit_.bits [i] bm.h 296 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare_state</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> iterator_base&amp; ib)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;block_type_ == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.ptr != ib_db.bit_.ptr) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.idx != ib_db.bit_.idx) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.cnt != ib_db.bit_.cnt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.pos != ib_db.bit_.pos) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bd.bit_.cnt; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.bits[i] != bd.bit_.bits[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } .... }</code> </pre> <br>  Acredito que, ap√≥s todas as verifica√ß√µes, os tamanhos das matrizes de <i>bits</i> dos <i>objetos bd.bit_</i> e <i>ib_db.bit_</i> s√£o iguais.  Portanto, o autor do c√≥digo escreveu um ciclo para a compara√ß√£o elementar de matrizes de <i>bits</i> , mas cometeu um erro de digita√ß√£o no nome de um dos objetos comparados.  Como resultado, objetos comparados podem ser equivocadamente considerados iguais em algumas situa√ß√µes. <br><br>  Este exemplo √© digno do artigo "O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mal vive em fun√ß√µes de compara√ß√£o</a> ". <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V501</a> Existem sub-express√µes id√™nticas 'CFieldHandler :: QualifierNamesAreEquivalent (campo, kFieldTypeSeqId)' √† esquerda e √† direita da '||'  operador.  field_handler.cpp 152 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CFieldHandlerFactory::s_IsSequenceIDField(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; field) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( CFieldHandler::QualifierNamesAreEquivalent(field, kFieldTypeSeqId) || CFieldHandler::QualifierNamesAreEquivalent(field, kFieldTypeSeqId)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Provavelmente, uma das verifica√ß√µes √© sup√©rflua.  N√£o encontrei nas vari√°veis ‚Äã‚Äãde c√≥digo semelhantes ao <i>kFieldTypeSeqId</i> .  No entanto, uma chamada de fun√ß√£o extra √© poss√≠vel devido ao operador "||", que prejudica o desempenho. <br><br>  Mais alguns do mesmo tipo de lugares com um aviso do analisador, exigindo verifica√ß√£o: <br><br><ul><li>  V501 Existem subexpress√µes id√™nticas 'uf-&gt; GetData (). IsBool ()' √† esquerda e √† direita do operador '&amp;&amp;'.  varia√ß√£o_utils.cpp 1711 </li><li>  V501 Existem subexpress√µes id√™nticas 'uf-&gt; GetData (). IsBool ()' √† esquerda e √† direita do operador '&amp;&amp;'.  varia√ß√£o_utils.cpp 1735 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V766</a> Um item com a mesma chave 'kArgRemote' j√° foi adicionado.  blast_args.cpp 3262 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CBlastAppArgs::x_IssueWarningsForIgnoredOptions(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CArgs&amp; args) { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; can_override; .... can_override.insert(kArgOutputFormat); can_override.insert(kArgNumDescriptions); can_override.insert(kArgNumAlignments); can_override.insert(kArgMaxTargetSequences); can_override.insert(kArgRemote); <span class="hljs-comment"><span class="hljs-comment">// &lt;= can_override.insert(kArgNumThreads); can_override.insert(kArgInputSearchStrategy); can_override.insert(kArgRemote); // &lt;= can_override.insert("remote_verbose"); can_override.insert("verbose"); .... }</span></span></code> </pre> <br>  O analisador detectou a adi√ß√£o de 2 valores id√™nticos ao recipiente <i>definido</i> .  Lembre-se de que esse cont√™iner armazena apenas valores exclusivos, portanto, duplicatas n√£o s√£o adicionadas a ele. <br><br>  C√≥digo como o descrito acima √© geralmente escrito usando o m√©todo copiar e colar.  Pode haver simplesmente um valor extra, ou talvez o autor tenha esquecido de renomear uma das vari√°veis ‚Äã‚Äãao copiar.  Quando voc√™ remove uma chamada extra para <i>inserir, o</i> c√≥digo √© ligeiramente otimizado, o que, no entanto, n√£o √© significativo.  Mais importante, um erro grave pode estar oculto aqui devido a um elemento ausente no conjunto. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V523</a> A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instru√ß√£o</a> 'then' √© equivalente ao fragmento de c√≥digo subsequente.  vcf_reader.cpp 1105 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CVcfReader::xAssignFeatureLocationSet(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.m_SetType == CVcfData::ST_ALL_DEL) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.m_strRef.size() == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//deletion of a single base pFeat-&gt;SetLocation().SetPnt().SetPoint(data.m_iPos-1); pFeat-&gt;SetLocation().SetPnt().SetId(*pId); } else { pFeat-&gt;SetLocation().SetInt().SetFrom(data.m_iPos-1); //-1 for 0-based, //another -1 for inclusive end-point ( ie [], not [) ) pFeat-&gt;SetLocation().SetInt().SetTo( data.m_iPos -1 + data.m_strRef.length() - 1); pFeat-&gt;SetLocation().SetInt().SetId(*pId); } return true; } //default: For MNV's we will use the single starting point //NB: For references of size &gt;=2, this location will not //match the reference allele. Future Variation-ref //normalization code will address these issues, //and obviate the need for this code altogether. if (data.m_strRef.size() == 1) { //deletion of a single base pFeat-&gt;SetLocation().SetPnt().SetPoint(data.m_iPos-1); pFeat-&gt;SetLocation().SetPnt().SetId(*pId); } else { pFeat-&gt;SetLocation().SetInt().SetFrom(data.m_iPos-1); pFeat-&gt;SetLocation().SetInt().SetTo( data.m_iPos -1 + data.m_strRef.length() - 1); pFeat-&gt;SetLocation().SetInt().SetId(*pId); } return true; }</span></span></code> </pre> <br>  A fun√ß√£o cont√©m fragmentos de c√≥digo grandes e completamente id√™nticos.  No entanto, eles cont√™m v√°rios coment√°rios que o acompanham.  O c√≥digo n√£o foi escrito de maneira ideal, confusa e possivelmente cont√©m um erro. <br><br>  A lista inteira de lugares suspeitos com a instru√ß√£o if-else √© assim: <br><br><ul><li>  V523 A instru√ß√£o 'then' √© equivalente √† instru√ß√£o 'else'.  blk.c 2142 </li><li>  V523 A instru√ß√£o 'then' √© equivalente ao fragmento de c√≥digo subsequente.  odbc.c 379 </li><li>  V523 A instru√ß√£o 'then' √© equivalente ao fragmento de c√≥digo subsequente.  odbc.c 1414 </li><li>  V523 A instru√ß√£o 'then' √© equivalente √† instru√ß√£o 'else'.  seqdbvol.cpp 1922 </li><li>  V523 A instru√ß√£o 'then' √© equivalente √† instru√ß√£o 'else'.  seqdb_demo.cpp 466 </li><li>  V523 A instru√ß√£o 'then' √© equivalente ao fragmento de c√≥digo subsequente.  blast_engine.c 1917 </li><li>  V523 A instru√ß√£o 'then' √© equivalente √† instru√ß√£o 'else'.  blast_filter.c 420 </li><li>  V523 A instru√ß√£o 'then' √© equivalente √† instru√ß√£o 'else'.  blast_parameters.c 636 </li><li>  V523 A instru√ß√£o 'then' √© equivalente √† instru√ß√£o 'else'.  unordered_spliter.cpp 684 </li><li>  V523 A instru√ß√£o 'then' √© equivalente √† instru√ß√£o 'else'.  bme.cpp 333 </li><li>  V523 A instru√ß√£o 'then' √© equivalente √† instru√ß√£o 'else'.  gme.cpp 484 </li></ul><br><h2>  / * com seguran√ßa √© melhor ser pedante * / </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/914/df5/670/914df5670813e7eb410e446f60a0ed5e.png"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V597</a> O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o buffer 'passwd_buf'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  challenge.c 366 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Crypt a given password using schema required for NTLMv1 authentication * @param passwd clear text domain password * @param challenge challenge data given by server * @param flags NTLM flags from server side * @param answer buffer where to store crypted password */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tds_answer_challenge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_PW_SZ 14 .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (ntlm_v == 1) { .... </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* with security is best be pedantic */</span></span></span><span class="hljs-meta"> memset(hash, 0, sizeof(hash)); memset(passwd_buf, 0, sizeof(passwd_buf)); memset(ntlm2_challenge, 0, sizeof(ntlm2_challenge)); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { .... } }</span></span></code> </pre> <br>  Como voc√™ provavelmente j√° adivinhou, um coment√°rio engra√ßado sobre a seguran√ßa do c√≥digo foi usado no t√≠tulo da se√ß√£o. <br><br>  Em resumo, a fun√ß√£o <i>memset</i> ser√° removida pelo compilador, porque os buffers liberados n√£o s√£o mais usados.  E dados como <i>hash</i> ou <i>passwd_buf</i> n√£o ser√£o realmente zeros.  Para obter mais informa√ß√µes sobre esse mecanismo n√£o √≥bvio do compilador, consulte o artigo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Limpeza segura de dados particulares</a> ". <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V597</a> O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o objeto 'responder'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  challenge.c 561 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TDSRET </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tds7_send_auth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">/* for security reason clear structure */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;answer, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(TDSANSWER)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tds_flush_packet(tds); }</code> </pre> <br>  Esse n√£o foi o √∫nico exemplo com coment√°rios sobre "seguran√ßa".  A julgar pelos coment√°rios, pode-se supor que a seguran√ßa √© realmente importante para o projeto.  Portanto, estou anexando a lista n√£o pequena inteira de problemas identificados: <br><br><ul><li>  V597 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o objeto 'heap'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  ncbi_heapmgr.c 1300 </li><li>  V597 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o objeto 'contexto'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  challenge.c 167 </li><li>  V597 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o objeto 'ks'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  challenge.c 339 </li><li>  V597 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o objeto 'md5_ctx'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  challenge.c 353 </li><li>  V597 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o buffer 'hash'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  challenge.c 365 </li><li>  V597 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o objeto 'ks'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  challenge.c 406 </li><li>  V597 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o objeto 'ntlm_v2_response'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  login.c 795 </li><li>  V597 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o objeto 'responder'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  login.c 801 </li><li>  V597 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o buffer de 'pacote'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  numeric.c 256 </li><li>  V597 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o buffer de 'pacote'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  numeric.c 110 </li><li>  V597 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o buffer 'pwd'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  getpassarg.c 50 </li><li>  V597 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o objeto 'contexto'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  challenge.c 188 </li><li>  V597 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o buffer 'buf'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  challenge.c 243 </li><li>  V597 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o buffer 'ntlm_v2_hash'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  challenge.c 309 </li><li>  V597 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o objeto 'md5_ctx'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  challenge.c 354 </li><li>  V597 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o buffer 'passwd_buf'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  challenge.c 380 </li><li>  V597 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o objeto 'ks'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  challenge.c 393 </li><li>  V597 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o buffer 'hash'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  challenge.c 394 </li><li>  V597 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o buffer 'ntlm2_challenge'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  challenge.c 395 </li><li>  V597 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o objeto 'ks'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  challenge.c 419 </li><li>  V597 O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o objeto 'ntlm_v2_response'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  challenge.c 556 </li></ul><br><h2>  Ciclos suspeitos </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ac/c77/124/8acc77124e5a13a1d25926c95d9eb2cf.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V534</a> √â prov√°vel que uma vari√°vel incorreta esteja sendo comparada dentro do operador 'for'.  Considere revisar 'i'.  taxFormat.cpp 569 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CTaxFormat::x_LoadTaxTree(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; alignTaxids.size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tax_id = alignTaxids[i]; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; taxInfo.seqInfoList.size(); j++) { SSeqInfo* seqInfo = taxInfo.seqInfoList[j]; seqInfo-&gt;taxid = newTaxid; } .... } .... }</code> </pre> <br>  Eu acho que, na condi√ß√£o do loop interno, a vari√°vel que <i>eu</i> peguei aleatoriamente.  Em vez disso, a vari√°vel <i>j</i> deve ser usada. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V535</a> A vari√°vel 'i' est√° sendo usada para esse loop e para o loop externo.  Verifique as linhas: 302, 309. sls_alp.cpp 309 <br><br><pre> <code class="cpp hljs">alp::~alp() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(d_alp_states) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;=d_nalp;i++) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { if(i&lt;=d_alp_states-&gt;d_dim) { if(d_alp_states-&gt;d_elem[i]) { for(i=0;i&lt;=d_nalp;i++) // &lt;= { .... .... }</span></span></code> </pre> <br>  Dois ciclos id√™nticos aninhados, nos quais o contador global tamb√©m √© redefinido, parecem muito suspeitos.  Os desenvolvedores devem verificar o que acontece aqui. <br><br><h2>  Indexa√ß√£o de matriz anormal </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a8/136/5b2/4a81365b2534c606f6d12df389841299.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V520</a> O operador de v√≠rgula ',' na express√£o do √≠ndice de matriz '[- i2, - k]'.  nw_spliced_aligner16.cpp 564 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CSplicedAligner16::x_DoBackTrace ( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Uint2* backtrace_matrix, CNWAligner::SAlignInOut* data, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i_global_max, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j_global_max) { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(intron_length &lt; m_IntronMinSize || (Key &amp; donor) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { Key = backtrace_matrix[--i2, --k]; ++intron_length; data-&gt;m_transcript.push_back(eTS_Intron); } .... }</code> </pre> <br>  Devo dizer imediatamente que parece n√£o haver erro (por enquanto, lol).  Considere a seguinte linha: <br><br><pre> <code class="cpp hljs">Key = backtrace_matrix[--i2, --k];</code> </pre> <br>  A palavra 'matriz' e indexa√ß√£o dupla podem sugerir que a matriz √© bidimensional, mas n√£o √©.  Este √© um ponteiro regular para uma matriz de n√∫meros inteiros.  Mas o diagn√≥stico do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V520</a> n√£o apareceu apenas.  Os programadores est√£o realmente confusos sobre como indexar matrizes bidimensionais. <br><br>  Nesse caso, o autor simplesmente decidiu salvar em uma linha de c√≥digo, embora pudesse escrever o seguinte: <br><br><pre> <code class="cpp hljs">--i2; Key = backtrace_matrix[--k];</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V661</a> Uma express√£o suspeita 'A [B == C]'.  Provavelmente significava 'A [B] == C'.  ncbi_service_connector.c 180 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EHTTP_HeaderParse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s_ParseHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* header, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>(header, <span class="hljs-string"><span class="hljs-string">"%u.%u.%u.%u%n"</span></span>, &amp;i1, &amp;i2, &amp;i3, &amp;i4, &amp;n) &lt; <span class="hljs-number"><span class="hljs-number">4</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>(header + n, <span class="hljs-string"><span class="hljs-string">"%hu%x%n"</span></span>, &amp;uuu-&gt;port, &amp;tkt, &amp;m) &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> || (header[m += n] &amp;&amp; !(header[m] == <span class="hljs-string"><span class="hljs-string">'$'</span></span>) &amp;&amp; !<span class="hljs-built_in"><span class="hljs-built_in">isspace</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)((header + m) [header[m] == <span class="hljs-string"><span class="hljs-string">'$'</span></span>])))) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span><span class="hljs-comment"><span class="hljs-comment">/*failed - unreadable connection info*/</span></span>; } .... }</code> </pre> <br>  Outro exemplo de c√≥digo no qual passei muito tempo tentando entender o que estava acontecendo: D.  A fun√ß√£o <i>isspace ()</i> verifica o caractere com o √≠ndice <i>m</i> , mas se esse caractere for '$', o caractere com o √≠ndice <i>m + 1 √©</i> passado para a fun√ß√£o.  Al√©m disso, a compara√ß√£o com '$' j√° estava adiantada.  Talvez n√£o haja erro aqui, mas o c√≥digo pode ser definitivamente reescrito com mais clareza. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A</a> satura√ß√£o da matriz V557 √© poss√≠vel.  O √≠ndice de 'linha' est√° apontando al√©m do limite da matriz.  aln_reader.cpp 412 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CAlnReader::x_IsGap(TNumrow row, TSeqPos pos, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; residue) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_MiddleSections.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { x_CalculateMiddleSections(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (row &gt; m_MiddleSections.size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pos &lt; m_MiddleSections[row].first) { .... } .... }</code> </pre> <br>  Aqui h√° um erro grave.  A verifica√ß√£o correta do √≠ndice de <i>linha</i> deve ser assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (row &gt;= m_MiddleSections.size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Caso contr√°rio, √© poss√≠vel acessar dados fora do vetor <i>MiddleSections</i> . <br><br>  Muitos mais desses lugares: <br><br><ul><li>  A satura√ß√£o da matriz V557 √© poss√≠vel.  O √≠ndice 'i' est√° apontando al√©m do limite da matriz.  resource_pool.hpp 388 </li><li>  A satura√ß√£o da matriz V557 √© poss√≠vel.  O √≠ndice de 'linha' est√° apontando al√©m do limite da matriz.  aln_reader.cpp 418 </li><li>  A satura√ß√£o da matriz V557 √© poss√≠vel.  O √≠ndice 'fmt_idx' est√° apontando al√©m do limite da matriz.  seq_writer.cpp 384 </li><li>  A satura√ß√£o da matriz V557 √© poss√≠vel.  O √≠ndice 'fmt_idx' est√° apontando al√©m do limite da matriz.  blastdb_formatter.cpp 183 </li><li>  A satura√ß√£o da matriz V557 √© poss√≠vel.  O √≠ndice 'num' est√° apontando al√©m do limite da matriz.  newcleanupp.cpp 13035 </li></ul><br><h2>  Como ganhar desconfian√ßa nas fun√ß√µes </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/147/029/c18/147029c18e4ccacc04f11f688084034f.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V570</a> A vari√°vel 'm_onClickFunction' √© atribu√≠da a si mesma.  alngraphic.hpp 103 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOnClickFunctionName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> onClickFunction)</span></span></span><span class="hljs-function"> </span></span>{ m_onClickFunction = m_onClickFunction; }</code> </pre> <br>  N√£o h√° nada para comentar.  Voc√™ s√≥ pode simpatizar com a pessoa que clicou em algo, clicou, mas nada mudou. <br><br>  Mais dois casos de atribui√ß√£o de vari√°veis ‚Äã‚Äãpara mim resultar√£o em uma lista: <br><br><ul><li>  V570 A vari√°vel 'iter-&gt; level' √© atribu√≠da a si mesma.  align_format_util.cpp 189 </li><li>  V570 A vari√°vel 'd_elements_values ‚Äã‚Äã[ind]' √© atribu√≠da a si mesma.  sls_alp_data.cpp 1416 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V763 O</a> par√¢metro 'w1' √© sempre reescrito no corpo da fun√ß√£o antes de ser usado.  bmfunc.h 5363 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// Bit COUNT functor template&lt;typename W&gt; struct bit_COUNT { W operator()(W w1, W w2) { w1 = 0; BM_INCWORD_BITCOUNT(w1, w2); return w1; } };</span></span></code> </pre> <br>  Uma fun√ß√£o na qual o argumento √© desgastado imediatamente ap√≥s a entrada na fun√ß√£o pode ser enganosa para os desenvolvedores que a utilizam.  O c√≥digo deve ser verificado duas vezes. <br><br><h2>  Erros de design de classe </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/033/e75/06c/033e7506c36604696731f73024f57c78.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V688</a> O argumento da fun√ß√£o 'm_qsrc' possui o mesmo nome que um dos membros da classe, o que pode resultar em confus√£o.  compart_matching.cpp 873 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CElementaryMatching</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CObject { .... ISequenceSource * m_qsrc; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_CreateIndex</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ISequenceSource *m_qsrc, EIndexMode index_more, ....)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_CreateRemapData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ISequenceSource *m_qsrc, EIndexMode mode)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_LoadRemapData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ISequenceSource *m_qsrc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; sdb)</span></span></span></span>; .... };</code> </pre> <br>  Imediatamente tr√™s fun√ß√µes de classe cont√™m argumentos cujos nomes coincidem com o campo de classe.  Isso pode levar a erros nos corpos das fun√ß√µes: o programador pode pensar que est√° trabalhando com um membro da classe, alterando realmente o valor da vari√°vel local. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V614</a> Vari√°vel n√£o inicializada 'm_BitSet' usada.  SnpBitAttributes.hpp 187 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// SNP bit attribute container. class CSnpBitAttributes { public: .... private: /// Internal storage for bits. Uint8 m_BitSet; }; inline CSnpBitAttributes::CSnpBitAttributes(Uint8 bits) : m_BitSet(bits) { } inline CSnpBitAttributes::CSnpBitAttributes(const vector&lt;char&gt;&amp; octet_string) { auto count = sizeof(m_BitSet); auto byte = octet_string.end(); do m_BitSet = (m_BitSet &lt;&lt; 8) | *--byte; while (--count &gt; 0); }</span></span></code> </pre> <br>  Um dos construtores trabalha <i>desleixadamente</i> com a vari√°vel <i>m_BitSet</i> .  O fato √© que a vari√°vel n√£o foi inicializada.  Seu valor de "lixo" √© usado na primeira itera√ß√£o do loop, ap√≥s o qual a inicializa√ß√£o ocorre.  Este √© um erro muito s√©rio, levando a um comportamento indefinido do programa. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V603</a> O objeto foi criado, mas n√£o est√° sendo usado.  Se voc√™ deseja chamar o construtor, 'this-&gt; SIntervalComparisonResult :: SIntervalComparisonResult (....)' deve ser usado.  compare_feats.hpp 100 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//This struct keeps the result of comparison of two exons struct SIntervalComparisonResult : CObject { public: SIntervalComparisonResult(unsigned pos1, unsigned pos2, FCompareLocs result, int pos_comparison = 0) : m_exon_ordinal1(pos1), m_exon_ordinal2(pos2), m_result(result), m_position_comparison(pos_comparison) {} SIntervalComparisonResult() { SIntervalComparisonResult(0, 0, fCmp_Unknown, 0); } .... };</span></span></code> </pre> <br>  H√° muito tempo, n√£o encontrei esses erros ao verificar projetos.  Mas o problema ainda √© relevante.  O erro √© que chamar o construtor parametrizado dessa maneira cria e remove um objeto tempor√°rio.  E os campos da classe permanecem n√£o inicializados.  Outro construtor deve ser chamado atrav√©s da lista de inicializa√ß√£o (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Delegando o construtor</a> ). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V591</a> A fun√ß√£o n√£o nula deve retornar um valor.  bio_tree.hpp 266 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// Recursive assignment CBioNode&amp; operator=(const CBioNode&amp; tree) { TParent::operator=(tree); TBioTree* pt = (TBioTree*)tree.GetParentTree(); SetParentTree(pt); }</span></span></code> </pre> <br>  O analisador considera que a linha est√° ausente na instru√ß√£o sobrecarregada: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V670</a> O membro da classe n√£o inicializado 'm_OutBlobIdOrData' √© usado para inicializar o membro 'm_StdOut'.  Lembre-se de que os membros s√£o inicializados na ordem de suas declara√ß√µes dentro de uma classe.  remote_app.hpp 215 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NCBI_XCONNECT_EXPORT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CRemoteAppResult</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CRemoteAppResult(CNetCacheAPI::TInstance netcache_api, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_inline_size = kMaxBlobInlineSize) : m_NetCacheAPI(netcache_api), m_RetCode(<span class="hljs-number"><span class="hljs-number">-1</span></span>), m_StdOut(netcache_api, m_OutBlobIdOrData, m_OutBlobSize), m_OutBlobSize(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_StdErr(netcache_api, m_ErrBlobIdOrData, m_ErrBlobSize), m_ErrBlobSize(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_StorageType(eBlobStorage), m_MaxInlineSize(max_inline_size) { } .... };</code> </pre> <br>  3 avisos do analisador s√£o emitidos imediatamente para este fragmento de c√≥digo.  Os campos de classe s√£o inicializados n√£o na ordem em que est√£o listados na lista de inicializa√ß√£o, mas na maneira como s√£o declarados na classe.  A causa cl√°ssica do erro √© que nem todos os programadores se lembram ou conhecem essa regra.  Aqui e na lista de inicializa√ß√£o est√° a ordem errada.  Ficamos com a sensa√ß√£o de que a lista de campos foi inserida em ordem aleat√≥ria. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V746 Corte de</a> objetos.  Uma exce√ß√£o deve ser capturada por refer√™ncia e n√£o por valor.  cobalt.cpp 247 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CMultiAligner::SetQueries(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; CRef&lt;objects::CBioseq&gt; &gt;&amp; queries) { .... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { seq_loc-&gt;SetId(*it-&gt;GetSeqId()); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (objects::CObjMgrException e) { NCBI_THROW(CMultiAlignerException, eInvalidInput, (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)<span class="hljs-string"><span class="hljs-string">"Missing seq-id in bioseq. "</span></span> + e.GetMsg()); } m_tQueries.push_back(seq_loc); .... }</code> </pre> <br>  A captura de exce√ß√µes por valor pode levar √† perda de algumas informa√ß√µes sobre a exce√ß√£o devido √† cria√ß√£o de um novo objeto.  √â muito melhor e mais seguro capturar uma exce√ß√£o por refer√™ncia. <br><br>  Locais similares: <br><br><ul><li>  V746 Corte de objetos.  Uma exce√ß√£o deve ser capturada por refer√™ncia e n√£o por valor.  agp_validate_reader.cpp 562 </li><li>  V746 Corte de objetos.  Uma exce√ß√£o deve ser capturada por refer√™ncia e n√£o por valor.  aln_build_app.cpp 320 </li><li>  V746 Corte de objetos.  Uma exce√ß√£o deve ser capturada por refer√™ncia e n√£o por valor.  aln_test_app.cpp 458 </li><li>  V746 Corte de objetos.  Uma exce√ß√£o deve ser capturada por refer√™ncia e n√£o por valor.  cobalt.cpp 691 </li><li>  V746 Corte de objetos.  Uma exce√ß√£o deve ser capturada por refer√™ncia e n√£o por valor.  cobalt.cpp 719 </li><li>  V746 Corte de objetos.  Uma exce√ß√£o deve ser capturada por refer√™ncia e n√£o por valor.  cobalt.cpp 728 </li><li>  V746 Corte de objetos.  Uma exce√ß√£o deve ser capturada por refer√™ncia e n√£o por valor.  cobalt.cpp 732 </li></ul><br><h2>  Sobre c√≥digo inacess√≠vel e outros problemas de execu√ß√£o de c√≥digo </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d1/8f5/263/1d18f52633776adc7ca32f92446c4b9f.png"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V779</a> C√≥digo inacess√≠vel detectado.  √â poss√≠vel que haja um erro.  merge_tree_core.cpp 627 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CMergeTree::x_FindBefores_Up_Iter(....) { .... FirstFrame-&gt;Curr = StartCurr; FirstFrame-&gt;Returned = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; FirstFrame-&gt;VisitCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; FrameStack.push_back(FirstFrame); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!FrameStack.empty()) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Rel == CEquivRange::eAfter) { Frame-&gt;Returned = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; FrameStack.pop_back(); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Rel == CEquivRange::eBefore) { .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Frame-&gt;VisitCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } } Frame-&gt;Returned = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= FrameStack.pop_back(); continue; } // end stack loop FirstFrame-&gt;ChildFrames.clear(); return FirstFrame-&gt;Returned; }</span></span></code> </pre> <br>  O c√≥digo da instru√ß√£o condicional √© escrito para que absolutamente todas as ramifica√ß√µes do c√≥digo terminem com a instru√ß√£o <i>continue</i> .  Isso levou a v√°rias linhas de c√≥digo inacess√≠vel que se formaram no <i>loop while</i> .  Essas linhas parecem muito suspeitas.  Muito provavelmente, esse problema surgiu ap√≥s a refatora√ß√£o do c√≥digo e agora exige uma revis√£o cuidadosa do c√≥digo. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V519</a> A vari√°vel 'interval_width' recebe valores duas vezes sucessivamente.  Talvez isso seja um erro.  Verifique as linhas: 454, 456. aln_writer.cpp 456 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CAlnWriter::AddGaps(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(exon_chunk-&gt;Which()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CSpliced_exon_chunk::e_Match: interval_width = exon_chunk-&gt;GetMatch(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CSpliced_exon_chunk::e_Mismatch: interval_width = exon_chunk-&gt;GetMismatch(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CSpliced_exon_chunk::e_Diag: interval_width = exon_chunk-&gt;GetDiag(); genomic_string.append(....); product_string.append(....); genomic_pos += interval_width; product_pos += interval_width/res_width; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... } .... }</code> </pre> <br>  A vari√°vel <i>interval_width √©</i> substitu√≠da v√°rias vezes, porque  n√£o h√° instru√ß√µes de <i>interrup√ß√£o</i> nos ramos do <i>caso</i> .  Embora seja um erro cl√°ssico, mas muito ruim. <br><br>  Mais alguns lugares suspeitos: <br><br><ul><li>  V779 C√≥digo inacess√≠vel detectado.  √â poss√≠vel que haja um erro.  dbapi_driver_utils.cpp 351 </li><li>  V779 C√≥digo inacess√≠vel detectado.  √â poss√≠vel que haja um erro.  net.c 780 </li><li>  V779 C√≥digo inacess√≠vel detectado.  √â poss√≠vel que haja um erro.  bcp.c 1495 </li><li>  V779 C√≥digo inacess√≠vel detectado.  √â poss√≠vel que haja um erro.  remote_blast.cpp 1470 </li><li>  V779 C√≥digo inacess√≠vel detectado.  √â poss√≠vel que haja um erro.  remote_blast.cpp 1522 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V571</a> Verifica√ß√£o recorrente.  A condi√ß√£o 'if (m_QueryOpts-&gt; filtering_options)' j√° foi verificada na linha 703. blast_options_local_priv.hpp 713 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CBlastOptionsLocal::SetFilterString(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* f) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_QueryOpts-&gt;filtering_options) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { SBlastFilterOptions* old_opts = m_QueryOpts-&gt;filtering_options; m_QueryOpts-&gt;filtering_options = NULL; SBlastFilterOptionsMerge(&amp;(m_QueryOpts-&gt;filtering_options), old_opts, new_opts); old_opts = SBlastFilterOptionsFree(old_opts); new_opts = SBlastFilterOptionsFree(new_opts); } else { if (m_QueryOpts-&gt;filtering_options) // &lt;= m_QueryOpts-&gt;filtering_options = SBlastFilterOptionsFree(m_QueryOpts-&gt;filtering_options); m_QueryOpts-&gt;filtering_options = new_opts; new_opts = NULL; } .... }</span></span></code> </pre> <br>  Obviamente, o ramo <i>else</i> requer reescrita.  Eu tenho algumas id√©ias que eu queria fazer com o ponteiro <i>m_QueryOpts-&gt; filtering_options</i> , mas o c√≥digo ainda √© de alguma forma confuso.  Apelo aos autores do c√≥digo. <br><br>  Bem, o problema n√£o vem sozinho: <br><br><ul><li>  V571 Verifica√ß√£o recorrente.  A condi√ß√£o 'if (sleeptime)' j√° foi verificada na linha 205. request_control.cpp 208 </li><li>  V571 Verifica√ß√£o recorrente.  A condi√ß√£o 'if (assignValue.empty ())' j√° foi verificada na linha 712. classstr.cpp 718 </li></ul><br><h2>  Erros de leitura de dados </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/761/548/f6b/761548f6b44470fe7b64db8ce0b0eb11.png"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O V739</a> EOF n√£o deve ser comparado com um valor do tipo 'char'.  O 'linestring [0]' deve ser do tipo 'int'.  alnread.c 3509 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EBool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s_AfrpInitLineData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( .... </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* linestring = readfunc (pfile); .... </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">while</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (linestring != </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">NULL</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;&amp; linestring [</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">] != EOF) { s_TrimSpace (&amp;linestring); .... } .... }</span></span></span></span></code> </pre> <br>  Os caracteres que voc√™ planeja comparar com o EOF n√£o devem ser armazenados em vari√°veis ‚Äã‚Äãde <i>caracteres</i> .  Caso contr√°rio, existe o risco de um caractere com o valor 0xFF (255) se transformar em -1 e ser interpretado da mesma maneira que o final de um arquivo (EOF).  Tamb√©m (apenas no caso) vale a pena verificar a implementa√ß√£o da fun√ß√£o <i>readfunc</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V663</a> Loop infinito √© poss√≠vel.  A condi√ß√£o 'cin.eof ()' √© insuficiente para interromper o loop.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere adicionar a chamada de fun√ß√£o 'cin.fail ()' √† express√£o condicional. </font><font style="vertical-align: inherit;">ncbicgi.cpp 1564</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream CNcbiIstream; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CCgiRequest::Serialize(CNcbiOstream&amp; os) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... CNcbiIstream* istrm = GetInputStream(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (istrm) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!istrm-&gt;eof()) { istrm-&gt;read(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf)); os.write(buf, istrm-&gt;gcount()); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O analisador detectou um erro em potencial devido ao qual um loop infinito pode ocorrer. </font><font style="vertical-align: inherit;">Se ocorrer uma falha durante a leitura dos dados, chamar a fun√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eof ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sempre retornar√° </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falso</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Para concluir o loop nesse caso, √© necess√°ria uma verifica√ß√£o adicional do valor retornado pela fun√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fail ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erros diversos </font></font></h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/132/51d/701/13251d701a22cae67c852d1bed7d33a5.png"></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V502</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Talvez o operador '?:' </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Funcione de</font></a><font style="vertical-align: inherit;"> maneira diferente do esperado. </font><font style="vertical-align: inherit;">O operador '?:' Tem uma prioridade mais baixa que o operador '&amp;&amp;'. </font><font style="vertical-align: inherit;">ncbi_connutil.c 1135</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_ClientAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* client_host, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*bool*/</span></span></span></span><span class="hljs-function"><span class="hljs-params"> local_host)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((client_host == c &amp;&amp; x_IsSufficientAddress(client_host)) || !(ip = *c &amp;&amp; !local_host ? SOCK_gethostbyname(c) : SOCK_GetLocalHostAddress(eDefault)) || SOCK_ntoa(ip, addr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(addr)) != <span class="hljs-number"><span class="hljs-number">0</span></span> || !(s = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(client_host) + <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(addr) + <span class="hljs-number"><span class="hljs-number">3</span></span>))) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> client_host<span class="hljs-comment"><span class="hljs-comment">/*least we can do :-/*/</span></span>; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Preste aten√ß√£o √† express√£o: </font></font><br><br><pre> <code class="cpp hljs">!local_host ? SOCK_gethostbyname(c) : SOCK_GetLocalHostAddress(eDefault)</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√£o √© calculado como o programador esperava, porque a express√£o inteira se parece com isso: </font></font><br><br><pre> <code class="cpp hljs">ip = *c &amp;&amp; !local_host ? SOCK_gethostbyname(c) : SOCK_GetLocalHostAddress(...)</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A prioridade do operador </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp;&amp;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© </font><font style="vertical-align: inherit;">maior que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?:</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Por esse motivo, o c√≥digo n√£o √© executado conforme o esperado. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V561</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Provavelmente √© melhor atribuir valor √† vari√°vel 'seq' do que declar√°-lo novamente. </font><font style="vertical-align: inherit;">Declara√ß√£o anterior: validator.cpp, linha 490. validator.cpp 492</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CValidator::IsSeqLocCorrectlyOrdered(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSeq_loc&amp; loc, CScope&amp; scope) { CBioseq_Handle seq; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { CBioseq_Handle seq = scope.GetBioseqHandle(loc); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (CObjMgrException&amp; ) { <span class="hljs-comment"><span class="hljs-comment">// no way to tell return true; } catch (const exception&amp; ) { // no way to tell return true; } if (seq &amp;&amp; seq.GetInst_Topology() == CSeq_inst::eTopology_circular) { // no way to check if topology is circular return true; } return CheckConsecutiveIntervals(loc, scope, x_IsCorrectlyOrdered); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Devido ao programador declarar uma nova vari√°vel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seq</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dentro da se√ß√£o try / catch, a outra vari√°vel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seq</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> permanece n√£o inicializada e √© usada abaixo no c√≥digo. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V562</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √â estranho comparar um valor do tipo bool com um valor de 0: (((status) &amp; 0x7f) == 0)! = 0. ncbi_process.cpp 111</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CProcess::CExitInfo::IsExited(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { EXIT_INFO_CHECK; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state != eExitInfo_Terminated) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(NCBI_OS_UNIX) return WIFEXITED(status) != 0; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> defined(NCBI_OS_MSWIN) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// The process always terminates with exit code return true; #endif }</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nada deu errado, mas o WIFEXITED acabou sendo uma abertura macro desta maneira: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (((status) &amp; <span class="hljs-number"><span class="hljs-number">0x7f</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acontece que a fun√ß√£o retorna o valor oposto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No c√≥digo, havia outra fun√ß√£o desse tipo, que emitia um aviso:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V562 √â estranho comparar um valor do tipo bool com um valor 0. ncbi_process.cpp 126 </font></font></li></ul><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V595</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O ponteiro 'dst_len' foi utilizado antes de ser verificado no nullptr. </font><font style="vertical-align: inherit;">Verifique as linhas: 309, 315. zlib.cpp 309</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CZipCompression::CompressBuffer( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* src_buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> src_len, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* dst_buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> dst_size, <span class="hljs-comment"><span class="hljs-comment">/* out */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>* dst_len) { *dst_len = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Check parameters if (!src_len &amp;&amp; !F_ISSET(fAllowEmptyData)) { src_buf = NULL; } if (!src_buf || !dst_buf || !dst_len) { SetError(Z_STREAM_ERROR, "bad argument"); ERR_COMPRESS(48, FormatErrorMessage("CZipCompression::CompressBuffer")); return false; } .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ponteiro </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dst_len √©</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> desreferenciado no in√≠cio da fun√ß√£o, enquanto mais adiante o c√≥digo √© verificado para que a igualdade seja zero. </font><font style="vertical-align: inherit;">Um erro foi cometido no c√≥digo que leva a um comportamento indefinido se o ponteiro </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dst_len</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nullptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V590</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Considere inspecionar a </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">express√£o</font></a><font style="vertical-align: inherit;"> 'ch! =' \ 0 '&amp;&amp; ch ==' ''. </font><font style="vertical-align: inherit;">A express√£o √© excessiva ou cont√©m uma impress√£o incorreta. </font><font style="vertical-align: inherit;">cleanup_utils.cpp 580</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Asn2gnbkCompressSpaces</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; val)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ch != <span class="hljs-string"><span class="hljs-string">'\0'</span></span> &amp;&amp; ch == <span class="hljs-string"><span class="hljs-string">' '</span></span>) { ptr++; ch = *ptr; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A condi√ß√£o para interromper o loop depende apenas de o caracter </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ch ser um</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> espa√ßo ou n√£o. </font><font style="vertical-align: inherit;">A express√£o pode ser simplificada para o seguinte:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ch == <span class="hljs-string"><span class="hljs-string">' '</span></span>) { .... }</code> </pre> <br><h2>  Conclus√£o </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O uso de programas de computador em pesquisas cient√≠ficas ajuda e ajudar√° a fazer descobertas. </font><font style="vertical-align: inherit;">Vamos esperar que os mais importantes n√£o sejam perdidos devido a erros de digita√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convido os desenvolvedores do projeto NCBI Genome Workbench a entrar em contato conosco e forneceremos um relat√≥rio completo emitido pelo analisador PVS-Studio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espero que esta pequena pesquisa de c√≥digo ajude a corrigir muitos erros e, geralmente, a melhorar a confiabilidade do projeto. </font><font style="vertical-align: inherit;">Tente executar o PVS-Studio no c√≥digo de seus projetos, se voc√™ ainda n√£o o fez. </font><font style="vertical-align: inherit;">Voc√™ pode gostar :).</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ deseja compartilhar este artigo com um p√∫blico que fala ingl√™s, use o link para a tradu√ß√£o: Svyatoslav Razmyslov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NCBI Genome Workbench: pesquisa cient√≠fica sob amea√ßa</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430476/">https://habr.com/ru/post/pt430476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430466/index.html">Mini AI Cup # 3: Escrevendo um Top Bot</a></li>
<li><a href="../pt430468/index.html">Sensibilizar os cidad√£os</a></li>
<li><a href="../pt430470/index.html">Por que manter o contexto na conta do cliente - de maneira honesta e lucrativa</a></li>
<li><a href="../pt430472/index.html">Rede DECT sem costura DIY</a></li>
<li><a href="../pt430474/index.html">CephFS vs GlusterFS</a></li>
<li><a href="../pt430478/index.html">Bots de negocia√ß√£o para o mercado de criptomoedas. Por onde come√ßar?</a></li>
<li><a href="../pt430480/index.html">Como escrevemos o aplicativo no hackathon da NASA Space Apps Challenge</a></li>
<li><a href="../pt430482/index.html">O tema das placas de armadura na cultura do Oriente e do Ocidente</a></li>
<li><a href="../pt430484/index.html">Cen√°rios t√≠picos de implementa√ß√£o do NGFW</a></li>
<li><a href="../pt430486/index.html">Como vivem os freelancers: de um desenvolvedor a um redator t√©cnico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>