<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©â€ğŸ‘©â€ğŸ‘¦ ğŸ‘¨ğŸ½â€ğŸ« ğŸ’‡ğŸ¼ Urutkan berdasarkan distribusi ğŸ¤  ğŸ”› ğŸ¤³</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam jenis distribusi, elemen didistribusikan dan didistribusikan ke dalam kelas sampai array diurutkan. 

 Dalam kasus yang paling umum, ini terjadi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Urutkan berdasarkan distribusi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/472466/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img width="690" height="345" src="https://habrastorage.org/webt/vj/5g/69/vj5g69j-a8ai2v0bhirylzm9hvq.jpeg"></a> <br><br>  Dalam jenis distribusi, elemen didistribusikan dan didistribusikan ke dalam kelas sampai array diurutkan. <a name="habracut"></a><br><br>  Dalam kasus yang paling umum, ini terjadi kira-kira dengan cara yang sama.  Elemen-elemen disebarkan oleh kelas berdasarkan beberapa kriteria.  Jika ini tidak mengarah pada pengurutan array, maka atribut dari kelas disempurnakan dan elemen-elemen tersebut tersebar lagi ke kelas yang disempurnakan.  Dan ini terjadi sampai array dipesan. <br><br>  Dalam menyortir berdasarkan distribusi, hampir selalu tidak ada perbandingan elemen di antara mereka dan pertukaran mereka.  Yang utama adalah apakah elemen itu milik kelas tertentu atau tidak, perbandingannya dengan elemen lain jarang memainkan peran. <br><br>  Biasanya, jenis ini memiliki kompleksitas waktu linier (daripada logaritmik, seperti jenis pertukaran, penggabungan, pilihan, atau sisipan yang efisien).  Algoritme kelas ini hampir selalu membutuhkan banyak memori tambahan, karena elemen yang dikelompokkan berdasarkan kelas harus disimpan di suatu tempat. <br><br>  Jenis distribusi bagus untuk menyortir bilangan bulat dan string.  Menyortir bilangan real dengan mereka biasanya tidak nyaman.  Juga, distribusi menyortir array dengan sempurna yang terdiri dari angka berulang - semakin banyak pengulangan, semakin sedikit kelas yang berbeda yang diperlukan. <br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Perangkat Lunak EDISON - pengembangan web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="Perangkat Lunak EDISON - pengembangan web"></a> <br clear="right">  Artikel ini ditulis dengan dukungan EDISON. <br>  Opini Pelanggan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">10 plus programmer dari EDISON</a> <br>  Ini menarik dan bermanfaat untuk diketahui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Programmer sarapan</a> </blockquote>  Pertimbangkan algoritma yang paling menunjukkan sifat cembung di atas. <br><br><h3>  Sortir ember: Sortir ember </h3><br>  Nama lain adalah penyortiran keranjang, penyortiran blok, penyortiran saku. <br><br>  Kami menyebarkan angka dalam keranjang, lalu di setiap keranjang kami menyebar di keranjang yang lebih kecil, dan seterusnya, sampai pada tingkat tertentu dalam keranjang hanya ada elemen yang sama.  Kemudian dari keranjang seperti itu dari tingkat terendah, mudah untuk mengembalikan array dalam keadaan teratur. <br><br>  Mari kita jelaskan dengan contoh spesifik.  Katakanlah kita memiliki array yang tidak terurut.  Diketahui bahwa array ini berisi angka dari 1 hingga 8. <br><br><img width="608" height="303" src="https://habrastorage.org/webt/1w/dj/qh/1wdjqhl9ggh8ropzijjrvekcuom.gif"><br><br>  Kami membuang angka-angka ini ke dalam 2 kelompok: angka dari 1 hingga 4 jatuh ke dalam satu kelompok, dari 5 hingga 8 menjadi yang kedua.Kemudian kami mendistribusikan angka-angka dalam keranjang pertama menjadi dua keranjang: dalam satu angka 1 dan 2, dan yang lainnya 3 dan 4. Kami juga mendistribusikan keranjang ini ke keranjang kulit pohon, yang sudah berisi angka dengan ukuran yang sama.  Untuk keranjang besar yang berisi angka dari 5 hingga 8, kami menerapkan rekursi serupa. <br><br>  Kemudian, dari keranjang kecil, yang masing-masing berisi angka yang sama, kami mengembalikan elemen ke array utama dalam urutan prioritas. <br><br>  Penyortiran nuklir dalam bentuk ini tidak secara khusus dapat diterapkan dalam praktik, tetapi secara standar menunjukkan bagaimana semua penyortiran menurut distribusi bekerja secara umum. <br><br><h3>  Urutkan Thanos :: Urusan Thanos </h3><br>  Kadang-kadang penulis macam dikirim kepada saya dan ini adalah kasus seperti itu.  Penulis Andrei Danilin menyebutnya "Rusia menyortir menjadi dua," namun saya menyebutnya penyortiran Thanos.  Atau, jika kita secara formal melanjutkan dari metode yang digunakan, kita dapat memanggil penyortiran rata-rata aritmatika. <br><br><img width="608" height="251" src="https://habrastorage.org/webt/e-/le/9u/e-le9uxjeez1ng83tvwbr-eztea.gif"><br><br>  Mean aritmatika elemen dihitung dalam array dan kemudian semua elemen didistribusikan ke dalam 2 kelompok.  Dalam satu kelompok terdapat unsur-unsur yang lebih kecil (atau sama) dengan rata-rata aritmatika, dalam kelompok kedua - unsur-unsur lebih besar dari rata-rata aritmatika.  Kemudian tindakan yang sama diterapkan secara rekursif untuk kedua kelompok - dan seterusnya hingga akhir yang pahit. <br><br>  Dan bagaimana dengan titanium gila?  Jika ini adalah array acak, maka pada umumnya elemen, jika dibandingkan dengan rata-rata aritmatika, memiliki kemungkinan 50/50 bahwa ia akan menuju ke salah satu dari dua grup. <br><br>  Ngomong-ngomong, di internet saya menemukan algoritma komik lain dengan nama yang sama.  Jika array tidak diurutkan, maka klik Infinity Glove dan kirim setengah dari elemen array yang dipilih secara acak ke tidak ada.  Jika para penyintas membentuk susunan tertib, maka misi besar mereka dapat dianggap terpenuhi.  Jika belum, maka Anda dapat membuat beberapa klik lagi. <br><br><img width="726" height="84" src="https://habrastorage.org/webt/on/ej/cz/onejczrz5o9mrtogqgocuteqshm.gif"><br><br>  Tetapi kembali ke penyortiran distribusi kami.  Semuanya hanya dapat dibagi menjadi dua kelompok - <b>penghitungan jenis</b> dan <b>penyortiran bitwise</b> .  Nah, jika Anda mau, Anda juga bisa menyoroti <b>penyortiran penghitungan-bit</b> , mis.  mereka yang dapat dikaitkan dengan keduanya. <br><br>  Ada juga algoritma hibrid (yang menggunakan metode kelas yang berbeda, misalnya, pengurutan Tim adalah persilangan antara pengurutan gabungan dan pengurutan penyisipan, pengurutan introspektif adalah pengurutan cepat yang masuk ke pengelompokan banyak, dll.), Termasuk pengurutan distribusi Namun, hibrida adalah bagian terpisah.  Tentang mereka nanti. <br><br>  Ribuan penyortiran dan aritmatika berarti penyortiran terkait dengan jenis penghitungan. <br><br><h2>  Menghitung Macam </h2><br>  Ide dasarnya adalah bahwa kita menghitung berapa angka di setiap kelas. <br><br><h3>  Sorting sorting :: Counting sort </h3><br>  Kami menghitung berapa kali satu atau nomor lainnya terjadi dalam array.  Mengetahui jumlah ini, kami dengan cepat membentuk array yang sudah dipesan. <br><br><img width="684" height="173" src="https://habrastorage.org/webt/wf/oe/-d/wfoe-dctpt010wmbwqld6j2ab8a.gif"><br><br>  Untuk pengurutan ini, Anda perlu mengetahui minimum dan maksimum dalam array.  Kemudian kunci dihasilkan untuk array bantu, di mana kami memperbaiki apa dan berapa kali bertemu. <br><br>  Kode Python: <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountingSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array, mn, mx)</span></span></span><span class="hljs-function">:</span></span> count = defaultdict(int) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> array: count[i] += <span class="hljs-number"><span class="hljs-number">1</span></span> result = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(mn,mx+<span class="hljs-number"><span class="hljs-number">1</span></span>): result += [j]* count[j] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result</code> </pre> <br><br><h3>  Pigeon Sort :: Pigeonhole sort </h3><br>  Kami pergi melalui array, jika nomor baru ditemukan, maka kami memulai penghitung (sebagai kunci dari daftar tambahan) dari nomor ini.  Jika nomor yang ditemui bukan untuk pertama kalinya, maka kenaikan untuk penghitung ini dipicu. <br><br><img width="684" height="173" src="https://habrastorage.org/webt/wi/rc/ow/wircowxsbt7nauhkqurxoqvbyzo.gif"><br><br>  Perbedaan dari metode sebelumnya adalah bahwa dalam menyortir dengan menghitung, kami segera memulai penghitung untuk semua angka yang mungkin terjadi dalam array (kami dapat membelinya jika diketahui maksimum dan minimum dalam array).  Beberapa angka tidak pernah muncul dan penghitungnya menunjukkan nol.  Dalam penyortiran merpati, kita mulai penghitung hanya untuk angka-angka yang benar-benar terjadi dalam array.  Array digunakan dalam menghitung penyortiran untuk penghitung, dan daftar tertaut ganda digunakan dalam penyortiran merpati, yang memungkinkan menambahkan penghitung baru saat bepergian. <br><br>  Metode ini kadang-kadang secara alternatif disebut <b>Penyortiran Dirichlet</b> , karena algoritma itu sendiri adalah ilustrasi dari berbagai konsekuensi dari prinsip Dirichlet. <br><blockquote>  Jika N objek didistribusikan di wadah M, dan N&gt; M, maka setidaknya satu wadah berisi lebih dari satu elemen. </blockquote><br>  Kode Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PigeOnHoleSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span><span class="hljs-function">:</span></span> mi = min(a) size = max(a) - mi + <span class="hljs-number"><span class="hljs-number">1</span></span> holes = [<span class="hljs-number"><span class="hljs-number">0</span></span>] * size <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a: holes[x - mi] += <span class="hljs-number"><span class="hljs-number">1</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> count <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(size): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> holes[count] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: holes[count] -= <span class="hljs-number"><span class="hljs-number">1</span></span> a[i] = count + mi i += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><br><h2>  Sortasi bit </h2><br>  Kami mendistribusikan angka-angka tergantung pada digit mana yang berada dalam kategori nomor tertentu.  Jika kita melakukan ini beberapa kali untuk digit yang berbeda, maka kita tiba-tiba mendapatkan array yang diurutkan. <br><br><h3>  Pengurutan bitwise orde rendah :: LSD radix sort </h3><br><img align="right" width="380" height="407" src="https://habrastorage.org/webt/xt/ac/qu/xtacqu8pnxiji7ifh82ju8ldiog.gif"><br clear="left">  Kami bergerak dari angka yang lebih rendah ke yang lebih lama dan pada setiap iterasi kami mendistribusikan elemen-elemen dari array tergantung pada digit apa yang ada di digit tersebut. <br><br>  Setelah distribusi berikutnya, kami mengembalikan elemen ke array utama dalam urutan di mana elemen jatuh ke dalam kelas selama redistribusi berikutnya. <br><br>  Untuk penyortiran bitwise, penting agar elemen dianggap memiliki jumlah digit yang sama.  Jika jumlah aktual digit berbeda, maka masalahnya diselesaikan dengan menambahkan nol tambahan sebagai digit lebih tinggi. <br><br><h3>  Pengurutan bitwise orde tinggi :: Urutan MSD radix </h3><br><img align="right" width="380" height="407" src="https://habrastorage.org/webt/3c/ae/ge/3caege4fd6e17l_3p7qscvu6p7e.gif"><br clear="left">  Pertama, kami mendistribusikan di antara peringkat senior, dari mana kami pindah ke yang lebih muda. <br><br>  Opsi ini lebih sulit untuk diimplementasikan, karena transisi ke digit yang lebih rendah dilakukan secara rekursif di dalam kelas, dan bukan di antara semua elemen array. <br><br>  Tetapi kompleksitas ini dihargai oleh fakta bahwa MSD lebih cepat daripada LSD.  Saat melewati dari angka yang lebih rendah ke angka yang lebih tua, Anda harus memproses semua digit dari semua angka untuk mengurutkan dengan benar.  Jika Anda berpindah dari senior ke muda, maka sebenarnya Anda tidak harus memproses semua digit semua angka, negara yang disortir, sebagai aturan, datang lebih awal. <br><br>  Sebagian besar penyortiran bitwise adalah variasi dari MSD yang lebih efisien.  Ini sangat berguna untuk menyortir string, karena ini, pohon suffix biasanya digunakan.  Kami akan menganalisis dalam salah satu artikel berikut. <br><br><h2>  Menghitung penyortiran bitwise </h2><br>  Kadang-kadang penyortiran distribusi secara bersamaan dihitung dan bitwise. <br><br><h3>  Bead Sort :: Manik sort </h3><br><img align="right" width="380" height="433" src="https://habrastorage.org/webt/df/tz/yd/dftzydlspf1ggnxzkzrzsgbvfpw.gif"><br clear="left">  Nama lain dari algoritma: penyortiran sempoa, penyortiran gravitasi. <br><br>  Saya sudah menulis tentang penyortiran ini beberapa kali ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> ), jadi saya akan singkat, hanya intinya. <br><br>  Misalkan setiap angka dalam array adalah satu set bola, jumlah bola adalah nilai angka.  Jika kita mengatur angka satu sama lain sebagai baris horizontal dari bola-bola ini dan kemudian mendorongnya secara vertikal, kita mendapatkan susunan yang teratur. <br><br>  Kuncinya di sini adalah bahwa kami mewakili setiap angka menggunakan bola dalam sistem angka unary.  Dan faktanya, kita cukup menghitung berapa kali semua angka memiliki setiap digit. <br><br>  BeadSort dalam Python dalam satu baris: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/python3 from itertools import zip_longest def beadsort(l): return list(map(sum, zip_longest(*[[1] * e for e in l], fillvalue=0)))</span></span></code> </pre> <br><br>  Setelah beberapa saat, kami akan menganalisis penyortiran penghitungan bitwise yang lebih kompleks, di antaranya penyortiran <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bendera Amerika</a> menempati tempat yang menonjol. <br><br><h2>  Referensi </h2><br><img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ember</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ember</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menghitung</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lubang Pigeon</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dirichlet</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Radix</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pelepasan</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Manik</a> <br><br><h3>  Artikel Seri: </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aplikasi Excel AlgoLab.xlsm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pertukaran macam</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Urutan Penyisipan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sortir berdasarkan pilihan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gabungkan Urusan</a> </li><li>  <b>Urutkan berdasarkan distribusi</b> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menghitung jenis dengan perkiraan distribusi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sortir Bendera Amerika</a> </li><li>  Pohon sufiks dalam penyortiran bitwise </li><li>  Membandingkan Penyortiran berdasarkan Distribusi </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sortasi Hibrid</a> </li></ul><br>  Aplikasi AlgoLab Excel telah diperbarui secara signifikan.  Beberapa algoritma dari artikel hari ini muncul di sana untuk pertama kalinya.  Perbarui siapa yang menggunakan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472466/">https://habr.com/ru/post/id472466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472448/index.html">Tema bagian Frontend di DUMP Kazan: ML untuk pengembang front-end, pixel magic, SvelteJS, tawa, keringat dan air mata</a></li>
<li><a href="../id472452/index.html">Bagaimana cara menambahkan dukungan untuk masa tenggang (Billing Grace Period) di aplikasi iOS?</a></li>
<li><a href="../id472454/index.html">Tinjauan server VPS murah</a></li>
<li><a href="../id472462/index.html">iFest di Nizhny Novgorod: ITU sangat mengesankan</a></li>
<li><a href="../id472464/index.html">5 Cara Membuat Server Python di Raspberry Pi Bagian 2</a></li>
<li><a href="../id472468/index.html">ClusterJ - bekerja dengan MySQL NDB Cluster dari Java</a></li>
<li><a href="../id472470/index.html">Tikus transgenik dan anti-penuaan</a></li>
<li><a href="../id472472/index.html">Pondok di musim dingin: menjadi atau tidak menjadi?</a></li>
<li><a href="../id472474/index.html">Bug kosmetik lucu di Google Chrome</a></li>
<li><a href="../id472482/index.html">Kecelakaan radioaktif: penemuan fase stabil padat plutonium</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>