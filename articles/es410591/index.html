<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí∑ üêö ü§üüèª La historia emocional de los procesadores para las primeras computadoras de los a√±os 70 a principios de los 90 üë©üèø‚Äç‚öïÔ∏è üèóÔ∏è üññüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Me pas√≥ a programar en ensambladores de diferentes procesadores. El √∫ltimo en la lista es Xilinx MicroBlaze. Decid√≠ publicar algunas de mis observacio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La historia emocional de los procesadores para las primeras computadoras de los a√±os 70 a principios de los 90</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/410591/">  Me pas√≥ a programar en ensambladores de diferentes procesadores.  El √∫ltimo en la lista es Xilinx MicroBlaze.  Decid√≠ publicar algunas de mis observaciones sobre las caracter√≠sticas de estas piezas de hierro casi m√°gicas que, como la llave m√°gica de Pinocho, nos abrieron puertas en la tierra m√°gica de la realidad virtual y la creatividad masiva.  Acerca de las caracter√≠sticas de los sistemas modernos x86, x86-64, ARM, ARM-64, etc.  No escribir√©, tal vez en otra ocasi√≥n: el tema es muy amplio y complejo.  Por lo tanto, planeo terminar con Intel 80486 y Motorola 68040. Tambi√©n quer√≠a incluir el IBM / 370 con el que estaba tratando.  Estos sistemas estaban bastante lejos de las masas de usuarios, pero al mismo tiempo tuvieron un gran impacto en la tecnolog√≠a inform√°tica.  Simplemente no ten√≠an suficiente tiempo asignado sobre el tema, no usaban chips de procesador y, por alguna raz√≥n, ellos mismos parec√≠an haber desaparecido por completo.  Realmente espero que mis materiales atraigan la atenci√≥n de los conocedores que pueden agregar algo en lo que no pensaron o no sab√≠an. <br><br>  Como material ilustrativo, adjunto mi peque√±a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">piedra de Rosetta</a> : programas para calcular el n√∫mero œÄ en diferentes procesadores y sistemas que utilizan un algoritmo de obturaci√≥n, afirmando ser la m√°s r√°pida de sus implementaciones. <br><br><a name="habracut"></a><br><h2>  Intel 8080 y 8085 </h2><br>  El primer procesador real en un chip, fabricado en la primera mitad de 1974, todav√≠a se est√° fabricando y est√° encontrando uso.  Clonado muchas veces en todo el mundo, en la URSS ten√≠a la designaci√≥n KR580VM80A.  Los procesadores Intel modernos para PC a√∫n revelan f√°cilmente su afinidad por este producto de reliquia en cierto sentido.  Yo mismo no escrib√≠ c√≥digos para este procesador, pero estando familiarizado con la arquitectura de z80, me aventurar√≠a a traer algunos de mis comentarios. <br><br>  El sistema de instrucciones 8080, al igual que otros procesadores Intel para PC, dif√≠cilmente se puede llamar ideal, pero es universal, bastante flexible y tiene varias caracter√≠sticas muy atractivas.  De sus competidores, Motorola 6800 y MOS Technology 6502, 8080 difer√≠an favorablemente en una gran cantidad de registros, aunque algo torpes, proporcionando al usuario una bater√≠a A de 8 bits, un semi-acumulador de 16 bits y un registro de √≠ndice HL r√°pido a tiempo parcial, puntero de pila SP de 16 bits , as√≠ como dos registros m√°s de 16 bits Sun y DE.  Los registros BC, DE y HL podr√≠an usarse como registros de 6 bytes.  Adem√°s, el 8080 ten√≠a soporte para un conjunto casi completo de indicadores de estado: carry, sign, zero e incluso parity and semi-transfer.  Algunas de las instrucciones del conjunto de instrucciones 8080 han sido campeones de velocidad.  Por ejemplo, el comando XCHG intercambia el contenido de los registros DE y HL de 16 bits en solo 4 ciclos de reloj: ¬°fue excepcionalmente r√°pido!  Varios otros equipos, aunque no establecieron r√©cords tan v√≠vidos, tambi√©n estuvieron entre los mejores durante mucho tiempo: <br><br><ul><li>  XTHL - intercambiando el contenido del registro HL y los datos en la parte superior de la pila, 18 ciclos de reloj - parece ser mucho, incluso en un verdadero 8086 de 16 bits, tal comando toma 22 ciclos de reloj, y para un 6800 o 6502 es incluso dif√≠cil imaginar tal comando; </li><li>  DAD: agregue al semi-acumulador HL el valor de otro registro de 16 bits (BC, DE o incluso SP), 10 ciclos de reloj.  Esta es una adici√≥n real de 16 bits con la configuraci√≥n de la bandera de acarreo.  Si agrega HL consigo mismo, obtendr√° un desplazamiento r√°pido a la izquierda de 16 bits o una multiplicaci√≥n de 2 veces, una operaci√≥n clave tanto para la multiplicaci√≥n completa como para la divisi√≥n; </li><li>  PUSH y POP: coloque en la pila y elimine de la pila el valor de 16 bits, respectivamente, del registro o en el registro.  Realizado en 11 y 10 ciclos.  Estas son las operaciones m√°s r√°pidas de 8080 para trabajar con memoria y en su rendimiento hay un incremento o disminuci√≥n autom√°tica de SP.  PUSH puede usarse, por ejemplo, para llenar r√°pidamente una memoria con un patr√≥n con valores de 3 registros (BC, DE, HL).  No hay comandos para trabajar con cantidades de 8 bits con una pila; </li><li>  LXI: carga de una constante de 16 bits en el registro (HL, DE, BC, SP) durante 10 ciclos de reloj; </li><li>  RNZ, RZ, RNC, RC, RPO, RPE, RP, RM: los retornos condicionales de la subrutina permiten limpiar el c√≥digo, eliminando la necesidad de escribir ramas condicionales adicionales.  Estos equipos fueron abandonados en la arquitectura x86, es posible que en vano, el c√≥digo con √©l resulte mejor. </li></ul><br>  Este procesador se us√≥ en la primera computadora personal Altair 8800, que se hizo muy popular despu√©s de la publicaci√≥n de la revista a principios de 1975. Por cierto, una publicaci√≥n similar en la URSS solo ocurri√≥ en 1980, y su correspondiente relevancia solo en 1986. <br><br><img src="https://img.newatlas.com/altair-8800-clone-0.jpg?auto=format%2Ccompress&amp;fit=max&amp;h=670&amp;q=60&amp;w=1000&amp;s=a0b62f09568803467c43a40736f5f4df" align="left"><br>  <i>Primero casi pc</i> <i><br></i> <br>  El Intel 8080 se convirti√≥ en la base para el desarrollo del primer sistema operativo CP / M profesional en masa, que domin√≥ las microcomputadoras para el trabajo profesional hasta mediados de los a√±os ochenta. <br><br>  Ahora sobre las deficiencias.  8080 requiri√≥ tres voltajes de alimentaci√≥n -5, 5 y 12 voltios.  Trabajar con interrupciones es inc√≥modo y lento.  Y en general, el 8080 no tiene prisa, si lo comparamos con los competidores que pronto aparecieron.  6502 podr√≠a ser hasta 3 veces m√°s r√°pido cuando funciona a la misma frecuencia que 8080. <br><br>  Pero en la arquitectura de 8080, result√≥ ser una visi√≥n correcta del futuro, es decir, ese hecho desconocido en los a√±os 70 de que los procesadores ser√°n m√°s r√°pidos que la memoria.  Los registros 8080 DE y BC son m√°s como un prototipo de cach√©s modernos operados manualmente que los registros de uso general.  El 8080 comenz√≥ con una frecuencia de 2 MHz, y los competidores con solo 1, lo que suaviz√≥ la diferencia en el rendimiento. <br><br>  Es dif√≠cil llamar al 8080 procesador de 8 bits al 100%.  Por supuesto, tiene una ALU de 8 bits, pero hay muchas instrucciones de 16 bits que son m√°s r√°pidas que usar solo an√°logos de 8 bits.  Y para algunos equipos no hay an√°logos de 8 bits en absoluto.  El equipo XCHG en esencia y tiempos es 100% de 16 bits.  Hay registros reales de 16 bits.  Por lo tanto, me atrevo a llamar al 8080 parcialmente de 16 bits.  Ser√≠a interesante calcular el √≠ndice de capacidad del procesador a partir de la totalidad de los signos, pero hasta donde el autor sabe, nadie ha hecho ese trabajo todav√≠a. <br><br>  El autor no sabe la raz√≥n por la cual Intel rechaz√≥ el soporte directo para el desarrollo de PC de 8 bits con sus procesadores.  Intel siempre se ha distinguido por la complejidad y la ambig√ºedad de la pol√≠tica.  Su conexi√≥n con la pol√≠tica, en particular, se ilustra por el hecho de que durante mucho tiempo Intel oper√≥ f√°bricas en Israel y hasta finales de los 90 fue secreto.  Intel pr√°cticamente no intent√≥ mejorar el 8080, la frecuencia del reloj solo se elev√≥ a 3 con un peque√±o MHz.  De hecho, el mercado de 8 bits se transfiri√≥ a Zilog con un procesador 8080 z80 relacionado, que pudo enfrentar con bastante √©xito al principal competidor, el "terminador" 6502. <br><br>  En la URSS y Rusia, el clon dom√©stico 8080 se convirti√≥ en la base de muchas computadoras masivas que siguieron siendo populares hasta principios de los 90.  Esto, por supuesto, es Radio-86RK, Mikrosh, multicolor Orion-128, Vector y Corvette.  Sin embargo, los clones baratos y mejorados basados ‚Äã‚Äãen zX Spectrum z80 derrotaron a las Guerras Clon. <br><br><img src="https://www.old-games.ru/forum/attachments/d64acd00877a00143c992eeffc16e35d-jpg.75531/"><br>  <i>Esta es una PC real.</i> <br><br>  A principios de 1976, Intel present√≥ el procesador 8085, compatible con el 8080, pero muy superior a su predecesor.  Ya hac√≠a innecesaria la fuente de alimentaci√≥n de -5 y 12 voltios y se simplific√≥ el diagrama de conexi√≥n, se mejor√≥ el trabajo con interrupciones, se us√≥ la frecuencia del reloj de 3 a 6 MHz muy s√≥lidos, el sistema de comando se ampli√≥ con varias instrucciones √∫tiles: sustracci√≥n de 16 bits, cambio de 16 bits a la derecha en solo 7 ciclos (esto es muy r√°pido), rotaci√≥n de 16 bits a la izquierda a trav√©s del indicador de transferencia, carga de un registro de 16 bits con un desplazamiento de 8 bits (este comando tambi√©n se puede usar con el puntero de pila SP), escriba el registro HL en la direcci√≥n en el registro DE similar a h  HL fluye a trav√©s de DE.  Todas las instrucciones anteriores, excepto el desplazamiento hacia la derecha, se realizan en 10 ciclos; esto a veces es significativamente m√°s r√°pido que sus contrapartes o emulaci√≥n en z80.  Se agregaron algunas instrucciones m√°s, e incluso dos nuevas banderas.  Entre las nuevas banderas, vale la pena se√±alar la bandera de desbordamiento, aunque trabajar con ella pr√°cticamente no era compatible.  Adem√°s, muchas instrucciones para trabajar con datos de bytes se aceleraron al ritmo.  Esto fue muy significativo, ya que en muchos sistemas con 8080 o z80, se introdujeron ticks de demora que, debido a la presencia de tics adicionales en el 8080, podr√≠an alargar el tiempo de ejecuci√≥n casi dos veces.  Por ejemplo, en una computadora dom√©stica, las instrucciones de vector del tipo de registro-registro se ejecutaron durante 8 ciclos de reloj, y si hubiera 8085 o z80 all√≠, estas mismas instrucciones se ejecutar√≠an en solo 4 ciclos de reloj.  La instrucci√≥n XTHL es incluso dos pasos m√°s r√°pida.  ¬°Con las nuevas instrucciones, puede escribir c√≥digo para copiar el bloque de memoria, que es m√°s r√°pido que los comandos LDI / LDD del procesador Z80!  Sin embargo, algunas instrucciones, por ejemplo, incremento y disminuci√≥n de 16 bits, PUSH y retornos condicionales se hicieron m√°s lentos por reloj. <br><br>  El 8085 tiene soporte incorporado para trabajar con interrupciones, lo que en muchos casos le permite prescindir de un controlador de interrupci√≥n separado en el sistema y un puerto de entrada / salida en serie.  Como ya se se√±al√≥, en 8085 no agregaron soporte completo para la bandera de desbordamiento, por lo que la aritm√©tica de los n√∫meros con un signo permaneci√≥ algo incompleta. <br><br>  Sin embargo, nuevamente puedo repetir la f√≥rmula "por razones desconocidas para el autor" Intel se neg√≥ a promover 8085 como el procesador principal.  Solo en los a√±os 80 aparecieron varios sistemas bastante exitosos basados ‚Äã‚Äãen 8085. El primero en 1981 fue el predecesor y casi rival de la PC IBM: IBM System / 23 Datamaster.  Luego, en 1982, se lanz√≥ una computadora muy r√°pida con excelentes gr√°ficos Zenith Z-100, en la que 8085 funcionaba a 5 MHz.  En 1983, la compa√±√≠a japonesa Kyotronic cre√≥ una rodillera KC-85 muy exitosa, cuyas variantes tambi√©n fueron producidas por otras compa√±√≠as: Tandy produjo el TRS-80 modelo 100, NEC - PC-8201a, Olivetti - M-10.  ¬°En total, se lanzaron m√°s de 10 millones de copias de tales computadoras!  En la URSS / RF a principios de los 90, basado en el clon dom√©stico IM1821VM85A, hubo intentos de mejorar algunos sistemas, por ejemplo, la computadora Vector.  Sorprendentemente, el procesador principal del rover Sojourner, que lleg√≥ a la superficie de Marte en 1997, ¬°era 8085 con una frecuencia de 2 MHz! <br><br>  De hecho, Intel le dio al z80 un color verde.  Unos a√±os m√°s tarde, en la batalla por el mercado de 16 bits, Intel se comport√≥ de manera completamente diferente, iniciando una demanda para prohibir las ventas de procesadores v20 y v30 en los Estados Unidos.  Curiosamente, los procesadores mencionados de la compa√±√≠a japonesa NEC podr√≠an cambiar al modo de compatibilidad binaria completa con el 8080, lo que los convirti√≥ en los procesadores m√°s r√°pidos de la arquitectura 8080. <br><br>  Otro secreto de Intel es la negativa a publicar un sistema de comando extendido, que incluye soporte para nuevas banderas.  Sin embargo, uno de los fabricantes oficiales de estos procesadores ha publicado todo el sistema de equipos.  ¬øCu√°les son las razones de un rechazo tan extra√±o?  Uno solo puede adivinar.  ¬øQuiz√°s Zilog jug√≥ un papel similar al que una vez jug√≥ AMD, y cre√≥ la apariencia de competencia, y 8085 podr√≠a derribar a Zilog?  ¬øQuiz√°s el punto sea el deseo de mantener el sistema de comando m√°s cerca del entonces dise√±ado 8086?  Esto √∫ltimo parece dudoso.  Intel 8086 fue lanzado m√°s de 2 a√±os despu√©s del lanzamiento de 8085 y es dif√≠cil de creer que en 1975 su sistema de comando ya era conocido.  Y en cualquier caso, la compatibilidad con 8080 y 8085 a 8086 solo se puede lograr utilizando un procesador de macro, a veces reemplazando un comando 8080/8085 con varios propios.  Adem√°s, las dos nuevas instrucciones publicadas 8085 en 8086 no son factibles en absoluto.  Es especialmente dif√≠cil explicar por qu√© Intel no public√≥ informaci√≥n sobre nuevos equipos despu√©s del lanzamiento de 8086. Solo podemos suponer que probablemente fue una cuesti√≥n de marketing.  Empeorando artificialmente las especificaciones de 8085, obtuvimos un 8086 m√°s espectacular en este contexto. <br><br><h2>  Motorola 6800 y parientes cercanos </h2><br>  Los procesadores de Motorola siempre se han distinguido por la presencia de varios "aspectos destacados" muy atractivos, mientras que al mismo tiempo la presencia de algunas soluciones arquitect√≥nicas que son absurdas en lo abstracto y en lo pr√°ctico.  El principal "punto culminante" de todos los procesadores en cuesti√≥n es la segunda bater√≠a de registro llena y muy r√°pida. <br><br>  El 6800 fue el primer procesador del mundo que solo necesitaba una fuente de alimentaci√≥n (5 voltios): fue una innovaci√≥n muy √∫til.  Debido a la singularidad del registro de √≠ndice de 16 bits, que es engorroso para una arquitectura de 8 bits, el Ho 6800 result√≥ ser un inconveniente para la programaci√≥n y el uso del producto.  Fue lanzado en 1974, no mucho despu√©s de 8080, pero nunca se convirti√≥ en la base de ning√∫n sistema inform√°tico conocido.  Curiosamente, los desarrolladores de 6502, Chuck Peddle y Bill Mensch, calificaron el 6800 como incorrecto, "demasiado grande".  Sin embargo, √©l y sus variantes fueron ampliamente utilizados como microcontroladores.  Quiz√°s valga la pena se√±alar que Intel ha estado fabricando procesadores desde 1971, lo que coloc√≥ a Motorola en la posici√≥n de un lado atractivo, para lo cual el 6800 fue el primer procesador.  Y si compara el 6800 no con el 8080, sino con su predecesor 8008, entonces el 6800 ser√° mucho m√°s preferible.  Motorola casi alcanza a Intel con 68000/20/30/40.  Tambi√©n puede notar que en los a√±os 70, Motorola era una empresa mucho m√°s grande que Intel. <br><br>  Tambi√©n se produjeron numerosas variantes de 6800: 6801, 6802, 6803, 6805, ... La mayor√≠a de ellas son microcontroladores con memoria incorporada y puertos de entrada / salida.  6803 es un 6801 simplificado y se us√≥ muy tarde (1983) para su computadora de clase Tandy TRS-80 MC-10 y su clon franc√©s Matra Alice, que eran comparables a Commodore VIC-20 (1980) o Sinclair ZX81 (1981).  El sistema de instrucci√≥n 6801/6803 se ha mejorado significativamente, se han agregado instrucciones de 16 bits, multiplicaci√≥n ... ¬°Ha aparecido una instrucci√≥n de rama incondicional inusual (BRN - rama nunca), que nunca se ejecuta!  Algunas instrucciones se han vuelto un poco m√°s r√°pidas. <br><br>  680x admite totalmente el trabajo con enteros con signo, z80 y 6502 lo soportan peor, mientras que 8080 y 8085 casi no tienen tal soporte.  Sin embargo, en el software de 8 bits, rara vez se necesitaba dicho soporte. <br><br>  6809 se lanz√≥ en 1978, cuando la era de 16 bits ya hab√≠a comenzado con 8086, y tiene un sistema de comando muy desarrollado, que incluye la multiplicaci√≥n de bater√≠as de dos bytes para obtener un resultado de 16 bits en 11 ciclos (en comparaci√≥n, 8086 requiere 70 ciclos para una operaci√≥n similar) .  En varios casos, se pueden agrupar dos bater√≠as en una de 16 bits, lo que proporciona instrucciones r√°pidas de 16 bits.  6809 tiene dos registros de √≠ndice y un n√∫mero r√©cord de m√©todos de direccionamiento entre procesadores de 8 bits - 12. Entre los m√©todos de direccionamiento hay exclusivos para chips de 8 bits, como el √≠ndice con incremento o decremento autom√°tico, en relaci√≥n con el contador de instrucciones, √≠ndice con desplazamiento.  El 6809 tiene una oportunidad interesante para usar dos tipos de interrupciones: puede usar interrupciones r√°pidas con el registro autom√°tico parcial guardado e interrupciones con el registro completo guardado - 6809 tiene tres entradas para se√±ales de interrupci√≥n FIRQ (enmascaramiento r√°pido), IRQ (enmascarable), NMI (sin enmascaramiento).  A veces tambi√©n es conveniente usar instrucciones r√°pidas para leer y configurar todas las banderas a la vez. <br><br>  Sin embargo, las operaciones de memoria requieren m√°s de 6502 ciclos de reloj. Los registros de √≠ndice han permanecido torpes dinosaurios de 16 bits en un mundo de 8 bits, algunas operaciones son simplemente impactantes debido a su lentitud, por ejemplo, transferir una bater√≠a de byte a otra toma 6 ciclos, y el intercambio ¬°su contenido es de 8 ciclos (en comparaci√≥n con 8080, donde se realiza un intercambio de 16 bits en 4 ciclos)!  Por alguna raz√≥n, se ofrecen dos punteros de pila de inmediato, tal vez fue la influencia de la arquitectura de interbloqueo VAX-11: en una arquitectura de 8 bits con 64 KB de memoria, parece muy inc√≥modo.  E incluso la presencia de una instrucci√≥n con el interesante nombre SEX no puede resolver todos los problemas de 6809.  En general, 6809 sigue siendo algo m√°s r√°pido que 6502 a la misma frecuencia, pero requiere la misma velocidad de memoria.  Logr√© hacer la divisi√≥n para 6809 con un dividendo de 32 bits y un divisor de 16 bits (32/16 = 32.16) durante un poco m√°s de 520 ciclos, para 6502 no pude lograr menos de 650 ciclos.  La segunda bater√≠a es una gran ventaja, pero otras caracter√≠sticas de 6502, en particular, la transferencia invertida, reducen esta ventaja solo al 25% indicado.  Pero la multiplicaci√≥n por una constante de 16 bits result√≥ ser m√°s lenta que la tabla uno para 6502 con una tabla de 768 bytes.  6809 le permite escribir c√≥digos bastante compactos y r√°pidos utilizando el direccionamiento de la p√°gina instalada (p√°gina directa), pero este direccionamiento hace que los c√≥digos sean bastante confusos.  La esencia de este direccionamiento es establecer el byte alto de la direcci√≥n de datos en un registro especial y especificar solo el byte bajo de la direcci√≥n en los comandos.  El mismo sistema con solo un valor de byte alto fijo se usa en 6502, donde se llama direccionamiento de p√°gina cero.  El direccionamiento de la p√°gina instalada es un an√°logo directo del uso del registro de segmento DS en x86 no solo para segmentos de 64 KB, sino tambi√©n para segmentos de solo 256 bytes.  Otra arquitectura descabellada de 6800 es el uso del orden de bytes de mayor a menor (Big Endian), que ralentiza las operaciones de suma y resta de 16 bits.  El 6809 no es totalmente compatible con los c√≥digos de instrucciones 6800. 6809 fue el √∫ltimo procesador de 8 bits de Motorola; en desarrollos posteriores, se decidi√≥ usar 68008 en su lugar. <br><br>  Se puede suponer que Motorola gast√≥ mucho dinero para promover 6809. Esto sigue siendo cierto ante la menci√≥n de este procesador.  Alrededor de 6809 hay muchas cr√≠ticas favorables, que difieren en algunas nebulosas, generalizaciones y vaguedades.  6809 se posicion√≥ como un superprocesador basado en microprocesador de 8 bits.  Casi los sistemas operativos Unix, OS-9 y UniFlex incluso se hicieron para √©l.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aull√≥ como el procesador principal de Apple Macintosh y, como se desprende de las pel√≠culas sobre Steve Jobs, solo su intervenci√≥n emocional determin√≥ la transici√≥n al 68000 m√°s prometedor. Por supuesto, 6809 es un buen procesador, pero en general es solo un poco mejor que sus competidores aparecieron mucho antes que 6502 (tres a√±os antes) y z80 (dos). Uno solo puede adivinar lo que suceder√≠a si Motorola gastara al menos la mitad del esfuerzo gastado en desarrollar y promover 6809 en desarrollar 6502.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6809 se utiliz√≥ en varios sistemas inform√°ticos bastante conocidos. El m√°s famoso de ellos es la computadora estadounidense Tandy Color o Tandy Coco, as√≠ como su clon brit√°nico o m√°s bien gal√©s Dragon-32/64. Los mercados inform√°ticos de los a√±os 80 se caracterizaron por una gran transparencia y Tandy Coco se distribuy√≥ principalmente solo en los EE. UU., Y Dragons, adem√°s del Reino Unido, gan√≥ cierta popularidad en Espa√±a. En Francia, 6809, por alguna raz√≥n, se convirti√≥ en la base de computadoras masivas de los a√±os 80 de la serie Thomson, que segu√≠an siendo casi desconocidas en cualquier otro lugar, excepto Francia. El 6809 tambi√©n se us√≥ como un segundo procesador en al menos dos sistemas: en la serie Commodore SuperPET 9000 y en el decodificador peque√±o y ahora casi olvidado para la interfaz TUBE de las computadoras BBC Micro.Este procesador tambi√©n se us√≥ en otros sistemas menos conocidos por el autor, en particular, los japoneses. Tambi√©n gan√≥ algo de distribuci√≥n en el mundo de las consolas de juegos. Vale la pena mencionar una de estas consolas, Vectrex, que utiliza una tecnolog√≠a √∫nica: una pantalla vectorial.</font></font><br><br><img src="https://i.imgur.com/DOVW3CM.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Color CoCo 3</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 680x tiene una interesante instrucci√≥n indocumentada con el interesante nombre "Halt and Catch Fire" (HCF), que se utiliza para realizar pruebas a nivel electr√≥nico, por ejemplo, con un osciloscopio. Su uso hace que el procesador se congele, desde el cual solo es posible salir reiniciando (reinicio). Estos procesadores tambi√©n tienen otras instrucciones no documentadas. En 6800 hay, por ejemplo, instrucciones sim√©tricas a la carga directa de la constante de registro, es decir, instrucciones para descargar directamente el registro a la direcci√≥n siguiendo estas instrucciones!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al igual que el 8080, 8085 o z80 6809, es muy dif√≠cil llamar a solo 8 bits. Y 6309 es incluso formalmente dif√≠cil de llamar de 8 bits, fue producido por la compa√±√≠a japonesa Toshiba (no pude encontrar el a√±o exacto de su producci√≥n, pero hay algunos datos que indican 1982) como un procesador que es totalmente compatible con 6809. Sin embargo, este procesador podr√≠a cambiarse en el nuevo modo, que, si bien mantuvo una compatibilidad casi total con 6809, proporcion√≥ grandes oportunidades de casi un orden de magnitud. Estas caracter√≠sticas estaban ocultas en la documentaci√≥n oficial, pero se publicaron en 1988 en la red Usenet. Se agregaron dos bater√≠as m√°s, pero las instrucciones con ellas son significativamente m√°s lentas que con las dos primeras. El tiempo de ejecuci√≥n para la mayor√≠a de las instrucciones se ha reducido considerablemente. Se agregaron varios equipos,entre los cuales la divisi√≥n simb√≥lica de un dividendo de 32 bits por un divisor de 16 bits (32/16 = 16.16) durante 34 ciclos es simplemente fant√°stica para los procesadores de esta clase, y el divisor se toma de la memoria. Tambi√©n hubo una multiplicaci√≥n de 16 bits con un resultado de 32 bits para 28 ciclos de reloj. Tambi√©n se agregaron instrucciones muy √∫tiles para copiar r√°pidamente bloques de memoria con un tiempo de ejecuci√≥n de 6 + 3n, donde n es el n√∫mero de bytes a copiar, puede copiar con direcciones decrecientes o decrecientes. Se pueden usar las mismas instrucciones para llenar r√°pidamente la memoria con un byte dado. Cuando se ejecuta, pueden ocurrir interrupciones. Todav√≠a hay nuevas operaciones bit a bit, registro nulo, etc. Se agregaron interrupciones al ejecutar una instrucci√≥n desconocida y al dividir por 0. En cierto sentido,6309 es el pin√°culo de los avances tecnol√≥gicos entre los procesadores de 8 bits, o m√°s bien los procesadores con un tama√±o de memoria direccionable de 64 KB.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El 6309 es totalmente compatible con los terminales 6809, lo que lo convierte en una actualizaci√≥n popular para el color Tandy o Dragons. </font><font style="vertical-align: inherit;">Hay versiones especiales del sistema operativo que utilizan las nuevas caracter√≠sticas de 6309.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tecnolog√≠a MOS 6502 y WDC 65816 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es un procesador con un destino muy dram√°tico. </font><font style="vertical-align: inherit;">Ning√∫n otro procesador puede compararse con √©l. </font><font style="vertical-align: inherit;">Su aparici√≥n e implementaci√≥n estuvo acompa√±ada de eventos y consecuencias a gran escala. </font><font style="vertical-align: inherit;">Voy a enumerar algunos de ellos:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> el debilitamiento del gigante Motorola, cuyas capacidades durante alg√∫n tiempo excedieron las capacidades de Intel; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> la destrucci√≥n de la tecnolog√≠a MOS; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> el cese del desarrollo de 6502 y su lanzamiento estancado con poca o ninguna modernizaci√≥n. </font></font></li></ul><br>  Todo comenz√≥ con el hecho de que Motorola, por razones completamente desconocidas, se neg√≥ a apoyar la iniciativa de los j√≥venes ingenieros que propusieron mejorar el procesador generalmente mediocre 6800. Tuvieron que abandonar la empresa y continuar su trabajo en la peque√±a pero prometedora empresa MOS Technology, donde pronto prepararon dos procesadores. 6501 y 6502 hechos con tecnolog√≠a NMOS.  El primero era compatible con el 6800, pero por lo dem√°s eran id√©nticos.  El equipo 6501/6502 logr√≥ introducir con √©xito una nueva tecnolog√≠a de fabricaci√≥n de chips, que redujo radicalmente el costo de los nuevos procesadores.  En 1975, MOS Technology podr√≠a ofrecer $ 6502 por $ 25, mientras que el precio inicial para Intel 8080 y Motorola 6800 fue en 1974 $ 360.  En 1975, Motorola e Intel redujeron los precios, pero a√∫n estaban cerca de los $ 100.  Los expertos en tecnolog√≠a MOS afirmaron que su procesador es hasta 4 veces m√°s r√°pido que el 6800. Esto me parece dudoso: el 6502 puede trabajar con la memoria mucho m√°s r√°pido, pero la segunda bater√≠a del 6800 aceler√≥ mucho muchos c√°lculos.  Puedo estimar que 6502 fue en promedio m√°s r√°pido que no m√°s de 2 veces.  Motorola inici√≥ una demanda contra sus antiguos empleados: supuestamente utilizaron muchos de los secretos tecnol√≥gicos de la compa√±√≠a.  Durante el proceso, fue posible establecer que uno de los ingenieros que dej√≥ Motorola emiti√≥ algunos documentos confidenciales en el 6800, actuando en contra de la configuraci√≥n de sus colegas.  A√∫n se desconoce si fue por su propia acci√≥n o por algunas fuerzas gu√≠a detr√°s de √©l.  Por esta y otras razones no del todo claras, Motorola oblig√≥ a MOS Technology, cuyas capacidades financieras eran muy peque√±as, a pagar una cantidad significativa de $ 200,000 y abandonar la producci√≥n de 6501. Intel en una situaci√≥n similar con Zilog actu√≥ de manera bastante diferente.  Aunque debe admitirse que la tecnolog√≠a MOS a veces era demasiado arriesgada cuando intentaba usar el gran dinero gastado por Motorola para promover el 6800 para sus propios fines. <br><br>  M√°s adelante en la historia, aparece la legendaria compa√±√≠a Commodore y su igualmente legendario fundador Jack Tramiel, a la sombra de la cual estaba la figura del jefe financiero de la compa√±√≠a que determina su pol√≠tica: un hombre llamado Irving Gould.  Jack recibi√≥ un pr√©stamo de Irving y con este dinero, usando varios, para decirlo suavemente, t√°cticas sin escr√∫pulos, oblig√≥ a MOS Tecchnology a formar parte del comodoro.  Despu√©s de lo cual, tal vez en contra de los deseos de Tramel, que tuvo que ceder ante Hood, el desarrollo de 6502 pr√°cticamente se detuvo, aunque en 1976 fue posible producir prototipos 6502 con frecuencias operativas de hasta 10 MHz, aunque un mensaje sobre esto apareci√≥ solo despu√©s de muchos a√±os de una persona llamado Bill Mensch (estaba en el equipo que dej√≥ Motorola), quien repetidamente hizo declaraciones fuertes pero en gran parte vac√≠as y jug√≥ un papel bastante ambiguo en el destino de 6502.  El desarrollador jefe 6502 Chuck Peddle fue eliminado para siempre del desarrollo de procesadores.  6502 continu√≥ produci√©ndose no solo en Commodore, sino tambi√©n en la compa√±√≠a creada por Bill Mensch, Western Design Center (WDC).  Es curioso que ninguno de los 6502 equipos anteriores trabaj√≥ con √©l en el futuro. <br><br>  El drama alrededor de 6502 no termin√≥ all√≠.  En 1980, apareci√≥ un breve art√≠culo an√≥nimo en la revista interactiva AIM65 de Rockwell que dec√≠a que todos los 6502 tienen un error peligroso llamado JMP (xxFF).  El tono del art√≠culo sugiere algo completamente fuera de lo com√∫n.  Posteriormente, esta actitud se traslad√≥ a la posici√≥n de Apple sobre este tema y se convirti√≥ en una especie de corriente principal.  Aunque, estrictamente hablando, no hubo "error".  Por supuesto, una de las caracter√≠sticas, bastante apropiada e incluso √∫til entre los microprocesadores, puede parecer un error molesto para un especialista que se acostumbr√≥ a los procesadores c√≥modos de sistemas grandes de esos a√±os.  Pero, de hecho, este comportamiento, que hiri√≥ los sentimientos de alguien, se describi√≥ en la documentaci√≥n oficial de 1976 y en los libros de texto de programaci√≥n que aparecieron antes de la aparici√≥n del art√≠culo mencionado.  El "error" fue eliminado por Bill Mensch, quien supuestamente fabric√≥ 6502 (CMOS 6502) en 1983, es decir, despu√©s del lanzamiento de 65816. Mientras Intel, Motorola y otros fabricaron procesadores de 16 bits de nuevas generaciones, 6502 solo se mejor√≥ microsc√≥picamente y hecho artificialmente parcialmente incompatible con √©l mismo.  Adem√°s de eliminar el "error", se realizaron una serie de cambios que, en particular, llevaron a un cambio durante la ejecuci√≥n de varias instrucciones, que se hicieron m√°s lentas por latido, pero al mismo tiempo en un sentido acad√©mico exagerado, se volvieron m√°s correctos.  Pero debo admitir que varias nuevas instrucciones se esperaban y eran √∫tiles.  Por otro lado, la gran mayor√≠a de las nuevas instrucciones solo ocuparon el espacio de c√≥digo, y no agregaron casi nada a las capacidades de 6502, lo que dej√≥ menos c√≥digos nuevos para posibles actualizaciones adicionales.  El comodoro y el japon√©s Ricoh (fabricante de las consolas de juegos NES m√°s populares) no aceptaron estos cambios.  El autor de este material se encontr√≥ varias veces con el problema de este "error".  Sin saber nada de √©l, escribi√≥ programas para el comodoro.  Luego transfiri√≥ uno de ellos a sistemas donde se usaba un conjunto de comandos 6502.  Surgi√≥ la incompatibilidad, tuve que cambiar los c√≥digos, hacer una compilaci√≥n condicional.  El c√≥digo para 6502 result√≥ ser m√°s voluminoso y lento.  Luego plante√≥ este tema en el foro 6502.org, donde la mayor√≠a de los participantes son del mundo Apple.  Pregunt√© si alguien podr√≠a dar un ejemplo cuando el "error" indicado bloque√≥ el programa.  Solo recib√≠ comentarios emocionales y generales; no se propuso ning√∫n ejemplo concreto. <br><br><img src="https://habrastorage.org/webt/f-/8q/mv/f-8qmv2x4io6ga8qxomqg0dxqnw.png">  Bug !!! <br><br>  65C02 ha sido licenciado para muchas empresas, en particular NCR, GTE, Rockwell, Synertek y Sanyo.  Usado en Apple II, comenzando con los modelos IIe, aunque muchos IIe usaron NMOS 6502. La variante 65C02 6512 tambi√©n se us√≥ en modelos posteriores de BBC Micro.  Atari us√≥ NMOS 6502. Adem√°s de CMOS 6502, Synertek y Rockwell tambi√©n produjeron NMOS 6502. Por cierto, NMOS 6502 tiene su propio conjunto de instrucciones indocumentadas, cuya naturaleza es completamente diferente de los comandos "secretos" 8085. En 6502, estas instrucciones aparecieron como un efecto secundario de la tecnolog√≠a utilizada, por lo tanto la mayor√≠a de ellos son bastante in√∫tiles, pero varios, por ejemplo, cargan o descargan dos registros con un comando a la vez y algunos otros pueden hacer que el c√≥digo sea m√°s r√°pido y compacto. <br><br>  Hubo otros intentos de actualizar el 6502. En el mismo 1979, apareci√≥ un art√≠culo en el que las computadoras Atari se estaban preparando para producir el procesador 6509 (que no debe confundirse con el procesador con el mismo nombre de la compa√±√≠a Commodore que apareci√≥ m√°s adelante), que se esperaba que acelere la ejecuci√≥n de comandos en un 25% y muchos nuevos instrucciones  Pero por razones desconocidas en precisi√≥n, la producci√≥n de este procesador no tuvo lugar.  El comodoro solo realiz√≥ mejoras microsc√≥picas.  All√≠, en particular, cambiaron a la tecnolog√≠a HMOS y a la producci√≥n de n√∫cleos est√°ticos, lo que permiti√≥ ralentizar los procesadores.  Desde el punto de vista de la programaci√≥n, lo m√°s interesante es el procesador 6509, que, aunque de forma muy primitiva, con la ayuda de solo dos instrucciones especialmente asignadas para este prop√≥sito, permite direccionar hasta 1 MB de memoria.  En los s√∫per populares Commodore 64 y 128, hab√≠a procesadores 6510/8510, y en las series 264 menos exitosas: 7501/8501.  Estos procesadores ten√≠an solo 6 y 7 puertos de bits de E / S incorporados, respectivamente, mientras que el 7501/8501 no admit√≠a interrupciones desenmascaradas.  Rockwell produjo la variante 65C02 con su conjunto de instrucciones de operaciones extendidas de 32 bits (similar a las instrucciones de z80 bits), sin embargo, que yo sepa, tales procesadores no se usaron en computadoras y estas instrucciones de bits en s√≠ mismas ten√≠an m√°s probabilidades de usarse solo en sistemas integrados.  Esta extensi√≥n, por cierto, fue producida por Bill Mensch. <br><br>  La √∫ltima escena del drama con la participaci√≥n de 6502 se indic√≥ en la prevenci√≥n de computadoras basadas en 6502 con una frecuencia de 2 MHz para el mercado estadounidense en la primera mitad de los a√±os 80.  Esto afect√≥ al ingl√©s-extranjero BBC Micro, su productora Acorn fabric√≥ una gran cantidad de computadoras para los Estados Unidos, pero result√≥ ser en vano.  Alg√∫n tipo de cerradura funcion√≥ y las computadoras tuvieron que rehacerse urgentemente a los est√°ndares europeos.  Las computadoras semi-americanas, pero formalmente canadienses Commodore CBM II (1982), a pesar de algunos problemas (en particular, de acuerdo con las normas para equipos el√©ctricos), todav√≠a estaban permitidas.  Tal vez debido al hecho de que no ten√≠an modos gr√°ficos e incluso texto en color, incluso el elegante dise√±o de Porsche no pod√≠a compensar esto.  El √∫ltimo en la lista de perdedores fue el Apple III 100% estadounidense (1980): se sabe que Steve Jobs, como la administraci√≥n de Apple en general, hizo mucho para evitar que esta computadora se produzca.  Jobs exig√≠a especificaciones y gesti√≥n claramente imposibles, plazos poco realistas.  ¬øAlguna vez descubriremos sus motivos?  El Apple III Plus, lanzado en 1983, logr√≥ eliminar los defectos del Apple III, pero la administraci√≥n de Apple cerr√≥ el proyecto en silencio en 1984 debido a la falta de voluntad para competir con la computadora Macintosh.  Solo en 1985, cuando comenz√≥ la era de la tecnolog√≠a de 8 bits, apareci√≥ el Commodore 128, que pod√≠a usar 6502 en uno de sus modos con una velocidad de reloj de 2 MHz.  Pero aqu√≠, tambi√©n, result√≥ m√°s como una broma, ya que este modo pr√°cticamente no era compatible y pr√°cticamente no hab√≠a programas para ello.  Solo en la segunda mitad de los a√±os 80 en los Estados Unidos comenz√≥ a producir consolas-aceleradores para Apple II, y desde 1988 el modelo Apple IIc + con un procesador de 4 MHz.  ¬øPor qu√© sucedi√≥ esto?  Quiz√°s porque 6502 a 2 o 3 MHz (y ya se produjeron a principios de los a√±os 80) en una serie de tareas y, en particular, con juegos, podr√≠a competir con √©xito con sistemas basados ‚Äã‚Äãen Intel 8088 o Motorola 68000. En 1991, Commodore Corporation cerr√≥ Un proyecto C65 interesante, aunque tard√≠o, basado en un procesador 4510 con una frecuencia de 3.54 MHz.  4510: este es el 6502 m√°s r√°pido, fabricado solo en 1988, se llev√≥ a cabo finalmente en la optimizaci√≥n de ciclos mencionada anteriormente, lo que dio un aumento del 25% en la velocidad.  Por lo tanto, el procesador en C65 tiene una velocidad cercana a los sistemas con 6502 a 4.5 MHz.  Sorprendentemente, este 6502 m√°s r√°pido con un conjunto ampliado de instrucciones (en algunos detalles esta extensi√≥n result√≥ ser m√°s exitosa que en 65816) nunca se ha utilizado en ning√∫n lugar desde entonces. <br><br>  C128 y Apple III Plus ten√≠an una unidad de administraci√≥n de memoria (MMU), que permit√≠a usar varias pilas y cero p√°ginas, dirigi√©ndose a m√°s de 64 KB de memoria, etc. En C128, la MMU se recort√≥ artificialmente para funcionar con solo 128 KB de memoria.  Para BBC Micro, se produjeron consolas con 6502 a 3 MHz (1984) y 4 MHz (1986). <br><br><img src="http://www.starringthecomputer.com/snapshots/jewel_of_the_nile_cbm_ii.jpg"><br>  <i>Anti-publicidad - m√∫ltiples PET Porsche en el apartamento del villano de la Perla del Nilo (1985) - la era de Apple en Hollywood a√∫n no ha llegado</i> <br><br>  Ahora unas pocas palabras sobre el sistema de instrucci√≥n 6502. La caracter√≠stica principal de este procesador es que se fabric√≥ casi lo m√°s r√°pido posible, pr√°cticamente sin ciclos de reloj adicionales, que son especialmente numerosos en los procesadores 8080/8085 / z80 / 8088/68000.  De hecho, fue la ideolog√≠a de los procesadores de arquitectura 6502 RISC lo que apareci√≥ m√°s tarde y bajo la influencia directa.  La misma ideolog√≠a domina, comenzando con 80486, y entre los procesadores Intel.  Adem√°s, 6502 reaccion√≥ lo m√°s r√°pido posible a las interrupciones, lo que lo hizo muy √∫til en algunos sistemas integrados.  El 6502 tiene una bater√≠a y dos registros de √≠ndice, adem√°s, los primeros 256 bytes de memoria se pueden usar en comandos especiales, ya sea como memoria m√°s r√°pida o como un conjunto de registros de 16 bits (que son casi id√©nticos en su funcionalidad a los registros BC y DE en 8080 / z80) para m√©todos de direccionamiento bastante potentes.  Algunas instrucciones aritm√©ticas (turnos, rotaci√≥n, incremento y decremento) se pueden usar con la memoria directamente, sin usar registros.  No hay instrucciones de 16 bits: es un procesador 100% de 8 bits.  Todas las banderas principales son compatibles, excepto la arquitectura caracter√≠stica de la bandera de paridad Intel.  Hay algunas banderas m√°s inusuales del d√©cimo modo in√∫til.  Los procesadores Intel y Motorola utilizan instrucciones correctivas especiales para trabajar con n√∫meros decimales, y 6502 puede cambiar al modo 10, lo que hace que su ventaja de velocidad con 10 n√∫meros sea a√∫n m√°s significativa que con los binarios.  Es impresionante que para la tabla 6502 se multipliquen los operandos de 8 bits con la obtenci√≥n de un resultado de 16 bits en menos de 30 ciclos de reloj, con el tama√±o de la tabla auxiliar en 2048 bytes.  Lentamente, 6502 produce operaciones de copia masiva de memoria, desde 14 ciclos de reloj por byte. <br><br>  6502 puede funcionar en paralelo con otro dispositivo, por ejemplo, otro 6502. Hasta donde yo s√©, tales sistemas de doble procesador nunca se han producido.  En lugar del segundo procesador, generalmente se usaba un controlador de video, que compart√≠a memoria con 6502. <br><br>  65816 fue lanzado por WDC en 1983. Curiosamente, Bill Mensch recibi√≥ las especificaciones para el nuevo procesador de Apple.  Por supuesto, este fue un gran paso adelante, pero obviamente tard√≠o y con grandes defectos arquitect√≥nicos.  65816 no fue considerado por nadie como un competidor para los principales procesadores Intel o Motorola; ya era un extra√±o secundario, que ya hab√≠a sido programado para establecer una nueva p√©rdida de posici√≥n.  El 65816 ten√≠a dos ventajas importantes: era relativamente barato y casi compatible con el todav√≠a muy popular 6502. En los a√±os siguientes, Bill Mensch ni siquiera intent√≥ mejorar de alguna manera su creaci√≥n, hacer la optimizaci√≥n del bucle, reemplazar la direcci√≥n de la p√°gina cero con la extendida usando el registro Z ( esto se hizo en 4510), para agregar al menos multiplicaci√≥n ... WDC solo aument√≥ las frecuencias m√°ximas de reloj, llegando a mediados de los 90 a 14 MHz (este procesador se us√≥ en el popular acelerador para C64 SuperCPU a una frecuencia de 20 MHz).  Sin embargo, incluso ahora (¬°2019!) WDC ofrece 65816 por alguna raz√≥n solo en los mismos 14 MHz.  65816 puede usar hasta 16 MB de memoria, pero los m√©todos de direccionamiento utilizados para esto parecen lejos de ser √≥ptimos.  Por ejemplo, los registros de √≠ndice solo pueden ser de 8 o 16 bits, la pila solo se puede colocar en los primeros 64 KB de memoria, solo all√≠ puede usar el conveniente direccionamiento corto de la p√°gina instalada (p√°gina directa - generalizaci√≥n de p√°gina cero), trabajar con memoria por encima de 64 KB comparativamente torpe, ... 65816 tiene una ALU de 16 bits, pero un bus de datos de 8 bits, por lo que en operaciones aritm√©ticas es solo un 50% m√°s r√°pido que 6502. Sin embargo, 65816 se lanz√≥ en una cantidad de m√°s de mil millones.  Por supuesto, una serie de instrucciones 65816 complementan claramente las brechas en la arquitectura 6502, por ejemplo, instrucciones para la copia masiva de memoria para 7 ciclos de reloj por byte.  Tambi√©n puede agregar que 65816 usa casi todos los c√≥digos de instrucciones (255 de 256).  El √∫ltimo c√≥digo no utilizado es para instrucciones futuras que nunca aparecieron. <br><br>  Se supon√≠a que Apple IIx, en cuyo desarrollo Steve Wozniak tom√≥ parte activa, deb√≠a usar 65816, pero fue posible establecer la producci√≥n de este procesador solo en 1984 y los primeros lotes de 65816 fueron defectuosos, lo que caus√≥ retrasos excesivos y como resultado cerr√≥ todo el proyecto. <br><br>  Tambi√©n hay una opci√≥n 65816 65802, que utiliza un bus de direcciones de 16 bits y es compatible con los conectores 6502. Hubo actualizaciones para Apple II basadas en este procesador, pero puede obtener un poco de aceleraci√≥n con dicha actualizaci√≥n solo en programas especialmente escritos para √©l. <br><br>  6502 se utiliz√≥ en una gran cantidad de sistemas inform√°ticos, los m√°s populares son Commodore, Atari, Apple, NES de 8 bits.  Curiosamente, el 6502 se us√≥ como controlador de teclado en la computadora Commodore Amiga, y dos 6502 a 10 MHz se usaron en el Apple Macintosh IIfx de alto rendimiento.  Aqu√≠ no podemos dejar de mencionar las consolas de juegos Atari, fabricadas entre 1977 y 1996, ¬°se vendieron aproximadamente 35 millones!  65816 se us√≥ en la computadora Apple IIgs bastante popular, en la consola de juegos Super NES y tambi√©n en la rara computadora inglesa Acorn Communicator. <br><br>  En 1984, apareci√≥ en la revista Byte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un art√≠culo</a> sobre una copia incorrecta de la computadora Apple [hecha en la URSS] con el fondo de im√°genes con pancartas rojas, Lenin y soldados marchando.  Este art√≠culo cit√≥ un precio curioso para esta computadora: $ 17,000 (este es un n√∫mero absurdo, el precio real era de aproximadamente 4,000 rublos) e ir√≥nicamente se√±al√≥ que los fabricantes sovi√©ticos tendr√≠an que reducir dr√°sticamente el precio si quer√≠an vender su producto en Occidente.  √Ågata se utiliz√≥ principalmente en la educaci√≥n escolar.  Los modelos m√°s antiguos de Agate eran casi 100% compatibles con Apple] [y ten√≠an algunas extensiones bastante √∫tiles. <br><br>  Solo puede intentar fantasear sobre lo que suceder√≠a si 6502 pudiera desarrollarse al mismo ritmo que sus competidores.  Me parece que la transferencia gradual de la memoria de p√°gina cero a los registros y la expansi√≥n gradual del sistema de instrucci√≥n con la optimizaci√≥n simult√°nea de ciclos permitir√≠a que el "terminador" 6502 permanezca a la cabeza en t√©rminos de velocidad hasta principios de los 90.  La introducci√≥n del modo 16 y luego de 32 bits permitir√≠a el uso de grandes cantidades de memoria y comandos m√°s r√°pidos.  ¬øPodr√≠an sus competidores tener algo a lo que oponerse? <br><br>  Me gustar√≠a terminar con algunas consideraciones filos√≥ficas generales.  ¬øPor qu√© el 6502 fren√≥ y careci√≥ de un futuro mucho m√°s brillante?  Quiz√°s debido al hecho de que realmente podr√≠a exprimir a las grandes empresas y crear una realidad completamente nueva.  ¬øPero fue el equipo 6502 preparado para eso?  M√°s bien, solo quer√≠an hacer un mejor procesador. <br><br>  Ya mucho m√°s tarde, a principios del siglo XXI, con la ayuda de demandas impuestas por razones exageradas, la compa√±√≠a Lexra, que produjo varios procesadores innovadores durante 5 a√±os, fue derrotada.  Esta triste historia recuerda algo de lo que sucedi√≥ con la tecnolog√≠a MOS. <br><br><h2>  Zilog z80 </h2><br>  Este procesador, junto con 6502, se convirti√≥ en el procesador principal de las primeras computadoras personales.  No hay eventos dram√°ticos en la historia de su aparici√≥n y uso.  Solo hay algo de intriga en el fracaso de Zilog para hacer la pr√≥xima generaci√≥n de procesadores.  Z80 comenz√≥ a producir en 1976 y sus variantes todav√≠a se est√°n produciendo.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una vez, incluso el propio Bill Gates anunci√≥ soporte para sistemas basados ‚Äã‚Äãen z80. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una serie de coincidencias son interesantes. Como en el caso de 6502, el desarrollador principal de Z80, Federico Faggin (Federico Faggin), dej√≥ la gran empresa, de Intel. Despu√©s de trabajar en el z80, Federico casi no trabaj√≥ con el procesador Z8000 de pr√≥xima generaci√≥n y a principios de los a√±os 80 dej√≥ su compa√±√≠a, por lo que nunca tratar√≠a con procesadores en el futuro. Luego cre√≥ varias startups relativamente exitosas, creando sistemas de comunicaciones, paneles t√°ctiles y c√°maras digitales. Puede mencionar que, adem√°s del z80, en Zilog tambi√©n desarroll√≥ el exitoso y a√∫n producido microcontrolador Z8.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El Z80 es un procesador que es m√°s conveniente para su incorporaci√≥n a los sistemas inform√°ticos que el 8080. Requiere solo un voltaje de alimentaci√≥n y tiene soporte incorporado para la regeneraci√≥n de memoria din√°mica. Adem√°s, con total compatibilidad con el 8080, tiene bastantes comandos nuevos, un segundo conjunto de registros principales y varios registros completamente nuevos. Es curioso que Zilog se haya negado a usar la mnemotecnia de ensamblador 8080 y comenz√≥ a usar sus propias mnemotecnias, que son m√°s adecuadas para el sistema de comando extendido z80. Una historia similar sucedi√≥ con el ensamblador Intel x86 en el mundo del software GNU, por alguna raz√≥n tambi√©n usan sus propias convenciones para escribir programas en ensamblador por defecto. El Z80 agreg√≥ soporte para el indicador de desbordamiento, Intel agreg√≥ soporte para dicho indicador solo en 8086. Sin embargo,Esta bandera en z80 se combin√≥ con la bandera de paridad, por lo que al mismo tiempo, como en 8086, no se pueden usar ambas banderas. En z80, como en 6502, solo hay una comprobaci√≥n b√°sica del valor de un indicador, es decir no hay controles de dos o tres indicadores a la vez, lo cual es necesario para las comparaciones de "estrictamente mayor", "menor o igual que", as√≠ como todos los significativos; en tales casos, debe hacer varios controles; en 8086, 6800 o PDP-11, uno es suficiente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entre las nuevas instrucciones z80, las instrucciones para la copia masiva de memoria para 21 ciclos por byte, as√≠ como el interesante comando de b√∫squeda de bytes en memoria, son especialmente impresionantes. </font><font style="vertical-align: inherit;">Sin embargo, lo m√°s interesante es el comando EXX, que intercambia el contenido de 48 bytes de memoria de registro, los registros BC, DE, HL con sus dobles, que se ejecuta en solo 4 ciclos. </font><font style="vertical-align: inherit;">Incluso un ARM de 32 bits necesitar√° al menos 6 ciclos de reloj para la misma operaci√≥n. </font><font style="vertical-align: inherit;">El resto de las instrucciones adicionales no son tan impresionantes, aunque a veces pueden ser √∫tiles. </font><font style="vertical-align: inherit;">Se agreg√≥ m√°s:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resta de 16 bits con un pr√©stamo y adici√≥n de 16 bits con transferencia por 15 ciclos; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unario menos para la bater√≠a por 8 ticks; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> la capacidad de leer de la memoria y escribir en ella utilizando los registros BC, DE, SP, IX, IY y no solo HL; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cambios, rotaciones y entrada-salida para todos los registros de 8 bits; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operaciones de verificaci√≥n, configuraci√≥n y restablecimiento de un bit por su n√∫mero; </font></font></li><li>    (JR); </li><li>  . </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mayor√≠a de los nuevos comandos son bastante lentos, pero usarlos correctamente puede hacer que el c√≥digo sea un poco m√°s r√°pido y significativamente m√°s compacto. Esto es especialmente cierto para el uso de los nuevos registros de 16 bits IX e IY, que pueden usarse para nuevos m√©todos de direccionamiento. ¬°Curiosamente, los registros de √≠ndice IX e IY aparecieron en el Z80 para atraer a 6800 usuarios a la transici√≥n al Z80! Pero me atrevo a expresar mi opini√≥n, las operaciones con los registros del √≠ndice Z80 se realizaron sin √©xito debido a la presencia de un desplazamiento de bytes casi in√∫til en los comandos que utilizan estos registros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muchos equipos 8080 en el z80 obtuvieron un ritmo m√°s r√°pido y esta es una aceleraci√≥n muy notable. Pero el comando ADD, b√°sico para la aritm√©tica de 16 bits, se hizo m√°s lento por ciclo, lo que hace que la aritm√©tica en general, si es m√°s r√°pida, solo sea un poco.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El sistema para trabajar con interrupciones se ha vuelto mucho m√°s interesante que el del 8080. Con el z80, puede usar interrupciones no enmascarables y tres m√©todos (uno de ellos es compatible con el 8080) para trabajar con los enmascarados. El modo m√°s interesante de interrupci√≥n enmascarada 2, que le permite cambiar de manera flexible la direcci√≥n del c√≥digo para manejar la interrupci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z80 tiene muchas instrucciones indocumentadas, muchas de estas instrucciones desaparecieron al cambiar a la tecnolog√≠a CMOS, pero las que sobrevivieron se volvieron pr√°cticamente est√°ndar y fueron documentadas por algunas compa√±√≠as. Las instrucciones particularmente √∫tiles le permiten trabajar con bytes individuales de torpes registros de 16 bits IX e IY. Adem√°s de las instrucciones no documentadas, el Z80 tiene otras propiedades no documentadas, por ejemplo, dos indicadores especiales en el registro de estado.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, el z80 es incluso m√°s que el 8080 tiene derecho a ser llamado ligeramente de 16 bits. El √≠ndice de d√≠gitos hipot√©ticos para z80 es claramente un poco m√°s alto, ¬°pero es parad√≥jico que la ALU de z80 sea en realidad de 4 bits! A nivel electr√≥nico, los z80 y 8080 son chips completamente diferentes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mucho se ha escrito sobre la comparaci√≥n del rendimiento del z80 y el 6502, ya que estos procesadores se usaron ampliamente en las primeras computadoras en masa. Hay varios momentos dif√≠ciles en este tema, sin los cuales es muy dif√≠cil mantener la objetividad. Debido a la presencia de un n√∫mero bastante grande de registros, es natural usar z80 a una frecuencia m√°s alta que la memoria. Por lo tanto, el z80 a 4 MHz puede usar la misma memoria que el 6502 o 6809 a 1.3 MHz. Seg√∫n muchos programadores experimentados que escribieron c√≥digos para ambos procesadores, a la misma frecuencia 6502, en promedio, de 2.4 a 2.6 veces m√°s r√°pido que z80. El autor de este material est√° de acuerdo con esto. Solo necesita agregar que escribir c√≥digos buenos y r√°pidos para el z80 es muy dif√≠cil, necesita optimizar constantemente el uso de registros y usar la pila para trabajar con la memoria tanto como sea posible.Si te esfuerzas, en mi opini√≥n puedes reducir la diferencia entre z80 y 6502 a aproximadamente 2,2 veces. Y si no trata de ignorar los tiempos, puede obtener f√°cilmente la diferencia hasta 4 veces. En algunos casos individuales, el z80 puede mostrar un rendimiento muy r√°pido. En la tarea de llenar la memoria, el z80, usando el comando PUSH, puede incluso ser un poco m√°s r√°pido que 6502, pero esto tiene el costo de prohibir las interrupciones. Al copiar bloques de memoria, el z80 es solo 1.5 veces m√°s lento. Es particularmente impresionante que al dividir un divisible de 32 bits por un divisor de 16, el z80 es solo 1.7 veces m√°s lento. Por cierto, tal super-intercambio fue implementado por un programador ruso. Por lo tanto, obtenemos que el ZX Spectrum con z80 a 3.5 MHz es aproximadamente una vez y media m√°s r√°pido que C64 desde 6502 a 1 MHz. Vale la pena se√±alaresa parte de los ciclos de reloj en la mayor√≠a de los sistemas con z80 o 6502 se elimina del procesador mediante esquemas de soporte de se√±al de video, por ejemplo, debido a esto, para las computadoras populares Amstrad CPC / PCW, la frecuencia real del procesador es de 3.2 MHz, y no el total 4. En los sistemas 6502, generalmente puede apagar la pantalla para el m√°ximo rendimiento del procesador. Si tomamos como base la frecuencia de la memoria, en lugar del procesador, resulta que el z80 es un 25-40% m√°s r√°pido que 6502. El √∫ltimo resultado puede ilustrarse por el hecho de que con una memoria con una frecuencia de 2 MHz, el z80 puede operar a una frecuencia de hasta 6 MHz, y 6502 solo hasta 2 MHz.Si tomamos como base la frecuencia de la memoria, en lugar del procesador, resulta que el z80 es un 25-40% m√°s r√°pido que 6502. El √∫ltimo resultado puede ilustrarse por el hecho de que con una memoria con una frecuencia de 2 MHz, el z80 puede operar a una frecuencia de hasta 6 MHz, y 6502 solo hasta 2 MHz.Si tomamos como base la frecuencia de la memoria, en lugar del procesador, resulta que el z80 es un 25-40% m√°s r√°pido que 6502. El √∫ltimo resultado puede ilustrarse por el hecho de que con una memoria con una frecuencia de 2 MHz, el z80 puede operar a una frecuencia de hasta 6 MHz, y 6502 solo hasta 2 MHz.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z80 se utiliz√≥ en una gran cantidad de sistemas inform√°ticos. Los TRS-80 de Tandy fueron muy populares en EE. UU., ZX Spectrum en Europa y m√°s tarde Amstrad CPC y PCW. Es curioso que las computadoras Amstrad PCW siguieron siendo relevantes hasta mediados de los 90 y se utilizaron de manera masiva y activa para su prop√≥sito previsto hasta finales de los 90. En Jap√≥n y otros pa√≠ses, produjeron computadoras MSX bastante exitosas en todo el mundo. El C128 bastante popular tambi√©n podr√≠a usar el z80, pero aqu√≠ era m√°s probable que los usuarios se avergonzaran: esta √∫ltima versi√≥n de 1985, una computadora z80 de 8 bits, con reloj oficial a 2 MHz, realmente funciona solo a 1.6 MHz. Esto es incluso m√°s lento que los primeros sistemas en los a√±os 8080 de mediados de los 70. La gama de computadoras para usar el sistema operativo CP / M incluye al menos tres docenas de sistemas bastante conocidos.</font></font><br><br><img src="http://www.old-computers.com/museum/photos/Amstrad_9512_Running_s1.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tal PC parec√≠a decente incluso a mediados de los 90, pero su z80 es m√°s lento que el ZX Spectrum.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El sistema inform√°tico basado en z80 m√°s r√°pido conocido por el autor es el BBC Micro con un decodificador TUBE con z80B a 6 MHz, fabricado desde 1984. El procesador en Este sistema funciona a toda velocidad, como dicen, "sin frenos". Se fabricaron consolas similares para Apple] [desde 1979. M√°s tarde, algunas de estas consolas utilizaron el Z80H a 8 MHz e incluso m√°s. Curiosamente, en 1980, Microsoft recibi√≥ el mayor beneficio de la venta de tales consolas. Tambi√©n puede mencionar el Amstrad PCW16, fabricado desde 1994, que utilizaba el CMOS Z80 a una frecuencia de 16 MHz.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Jap√≥n, el R800 compatible con el z80 fue fabricado para los sistemas MSX TurboR (1990). Se ha agregado una multiplicaci√≥n de hardware de 16 bits con un resultado de 32 bits al R800. Aunque cuando se multiplica por una constante de 16 bits, la multiplicaci√≥n de la tabla con una tabla de 768 bytes se obtiene por un reloj m√°s r√°pido. Existe la opini√≥n de que el R800 es un Z800 muy simplificado que funciona a una frecuencia cuatro veces mayor que la frecuencia del bus, que es aproximadamente 7.16 MHz. Por lo tanto, la frecuencia interna del R800 es de aproximadamente 28,64 MHz.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El propio Zilog ha trabajado para mejorar el Z80 de manera muy inconsistente y extremadamente lenta. Los primeros Z80 funcionaron a frecuencias de hasta 2.5 MHz, y el Z80A, que apareci√≥ poco despu√©s, aument√≥ la frecuencia m√°xima a 4 MHz: estos procesadores se convirtieron en la base de las computadoras m√°s populares que usan Z80. Z80B apareci√≥ en 1980, pero se us√≥ relativamente raramente, por ejemplo, en la mencionada consola BBC Micro o en la computadora Sam Coup√© (1989). El Z80H apareci√≥ a mediados de los a√±os 80 y pod√≠a funcionar a frecuencias de hasta 8 MHz, no se usaba en computadoras conocidas. Es interesante que los productos Zilog ten√≠an trampas especiales en el chip para aquellos que intentaron hacer copias de ellos, por ejemplo, la base Z80 ten√≠a 9 trampas y, seg√∫n las revisiones de quienes hicieron esto, ralentizaron el proceso de copia durante casi un a√±o.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La actualizaci√≥n m√°s profunda del z80 se vio obstaculizada por el deseo de Zilog de crear procesadores que compitan con los procesadores de 16 bits de Intel. En 1978, un poco m√°s tarde, 8086 lanz√≥ Z8000, no compatible con z80. Este procesador no pudo resistir a los competidores de Intel, y especialmente de Motorola: el 68000 super√≥ al Z8000 en casi todos los aspectos, aunque el Z8000 se us√≥ en aproximadamente una docena de sistemas econ√≥micos diferentes, generalmente para trabajar con variantes de Unix. Curiosamente, IBM ni siquiera consider√≥ al Z8000 como un posible procesador para la PC de IBM, porque Zilog fue financiado por Exxon, que iba a competir con IBM. Quiz√°s debido al fracaso del Z8000, Zilog se convirti√≥ en una divisi√≥n de Exxon en 1980. Tambi√©n hubo un intento de crear un procesador competitivo de 32 bits. En 1986, apareci√≥ el Z80000, compatible con el Z8000, que </font><b><font style="vertical-align: inherit;">no</font></b><font style="vertical-align: inherit;"> est√° en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ning√∫n otro lado.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y no encontr√© aplicaci√≥n. Algunas circunstancias, en particular, las quejas muy extra√±as del equipo de Zilog sobre el financiamiento excesivo, sugieren que quiz√°s Zilog, por alguna raz√≥n poco clara, haya saboteado su trabajo como parte de Exxon. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uno solo puede preguntarse por qu√© Zilog abandon√≥ su enfoque, que mostr√≥ resultados s√∫per exitosos con el Z80, es decir, hacer que los procesadores sean program√°ticamente compatibles con los procesadores Intel, pero sus mejores y al mismo tiempo son completamente diferentes a nivel de hardware. Posteriormente, este enfoque fue utilizado con √©xito por muchas empresas, en particular, AMD, Cyrix, VIA.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La creaci√≥n de un nuevo procesador basado en el Z80 se retras√≥ hasta 1985, cuando se fabric√≥ el Z800. Sin embargo, los principales esfuerzos de Zilog se dirigieron al Z80000 y muy pocos se lanzaron Z800. En 1986, despu√©s de la falla del z80000, se lanz√≥ el Z280, una versi√≥n ligeramente mejorada del Z800, que, en particular, pod√≠a funcionar a una frecuencia interna varias veces mayor que la frecuencia del bus, tal novedad trajo un gran √©xito a los procesadores Intel 486DX2 y 486DX4. El Z280 tambi√©n ten√≠a otras caracter√≠sticas prometedoras que luego fueron aplicadas con √©xito por otras compa√±√≠as. Pero, tal vez debido al bajo rendimiento: el Z280, a pesar de muchas innovaciones tecnol√≥gicas, podr√≠a usar solo velocidades de reloj relativamente bajas, este procesador tampoco est√° en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ninguna parte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aplicaci√≥n no encontrada. Se cree que el Z280 correspondi√≥ aproximadamente a las capacidades del Intel 80286, pero fue significativamente, al menos un 50% m√°s lento cuando se usa la misma frecuencia de reloj con 80286. Quiz√°s si el Z280 hubiera aparecido 5 a√±os antes, entonces podr√≠a haber tenido mucho √©xito.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El mayor √©xito se logr√≥ gracias a la cooperaci√≥n con la compa√±√≠a japonesa Hitachi, que en 1985 lanz√≥ su super-Z80, HD64180, que es similar en capacidades al Intel 80186, que permiti√≥ el uso de 512 KB de memoria, agreg√≥ una docena de nuevas instrucciones, pero algunas instrucciones casi indocumentadas Z80 No es compatible. HD64180 se ha utilizado en algunos sistemas inform√°ticos. Zilog obtuvo una licencia para el HD64180 y comenz√≥ a fabricarlos con la marca Z64180. Zilog logr√≥ mejorar ligeramente este procesador, en particular, agreg√≥ soporte para trabajar con 1 MB de memoria y lo lanz√≥ a fines de 1986. Este nuevo procesador se llam√≥ Z180 y se convirti√≥ en la base de una familia de procesadores y controladores, con frecuencias de reloj de hasta 33 MHz. Fue utilizado en algunas computadoras MSX2 raras, pero m√°s como un controlador. Curiosoque Z280 y Z180 aparecieron en un a√±o, as√≠ como sus hom√≥logos aproximados 80286 y 80166 cuatro a√±os antes. En 1994, se fabric√≥ un Z380 de 32 bits sobre la base del Z180, que segu√≠a siendo compatible con el z80 y aproximadamente equivalente en sus capacidades al Intel 80386 o Motorola 68020: Zilog mostr√≥ una brecha de casi 10 a√±os con respecto a sus competidores. Ya en el siglo XXI, los controladores de procesador eZ80 muy exitosos con tiempos casi como los de 6502 se est√°n haciendo nuevamente sobre la base de Z180. Se utilizan en diversos equipos, en particular en tarjetas de red, unidades de DVD, calculadoras, ...Ya en el siglo XXI, los controladores de procesador eZ80 muy exitosos con tiempos casi como los de 6502 se est√°n haciendo nuevamente sobre la base de Z180. Se utilizan en diversos equipos, en particular en tarjetas de red, unidades de DVD, calculadoras, ...Ya en el siglo XXI, los controladores de procesador eZ80 muy exitosos con tiempos casi como los de 6502 se est√°n haciendo nuevamente sobre la base de Z180. Se utilizan en diversos equipos, en particular en tarjetas de red, unidades de DVD, calculadoras, ...</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Texas Instruments TMS9900 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para este procesador de c√≥digo muy especial, nunca he podido escribir. </font><font style="vertical-align: inherit;">Y este es el primer procesador de 16 bits disponible para su uso en computadoras personales. </font><font style="vertical-align: inherit;">Se produce desde 1976. </font><font style="vertical-align: inherit;">Utiliza un orden de bytes mucho menos com√∫n de mayor a menor (Big Endian). </font><font style="vertical-align: inherit;">Este pedido todav√≠a se usa solo en los procesadores de las series Motorola 6800 y 68000 y en la arquitectura del gigante IBM / 370. </font><font style="vertical-align: inherit;">Todos los dem√°s procesadores en esta revisi√≥n usan el orden de bytes inverso (Little Endian).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El TMS9900 tiene solo tres registros de 16 bits: un contador de comandos, un registro de estado y un registro base de pseudo-registro. Este procesador utiliza una memoria asignada de 32 bytes como 16 registros de doble byte. Este uso de la memoria recuerda de alguna manera a la p√°gina cero de memoria en la arquitectura 6502. Usando el registro base, el TMS9900 puede cambiar r√°pidamente el contexto. Esto se parece al Z80, que tiene dos contextos de registro. El sistema de banderas se distingue por su originalidad, junto con las banderas t√≠picas de acarreo, cero (igualdad), desbordamiento, paridad, hay dos banderas m√°s √∫nicas de signos de l√≥gica y aritm√©tica menos. Trabajar con la pila y las rutinas se parece a los procesadores RISC del futuro. Simplemente no hay una pila terminada; se puede hacer usando uno de los pseudo-registros.Cuando se llama a la subrutina, se selecciona un nuevo valor para el contador y la base, y los tres registros se almacenan en los pseudoregistros del nuevo contexto. Por lo tanto, una llamada de subrutina es m√°s como una llamada de interrupci√≥n de programa. TMS9900 tiene un controlador de interrupci√≥n incorporado, dise√±ado para trabajar con interrupciones de hardware de hasta 16.</font></font><br><br><img src="https://habrastorage.org/webt/bs/ir/lv/bsirlvxf7fobwzwpdcvxkcnousc.jpeg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La primera computadora dom√©stica de 16 bits, incluso tiene sprites de color.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El sistema de comando se ve muy impresionante. Incluso hay multiplicaci√≥n y divisi√≥n. La instrucci√≥n √∫nica X le permite ejecutar una instrucci√≥n en cualquier direcci√≥n en la memoria y pasar a la siguiente. La ejecuci√≥n del comando es bastante lenta, las instrucciones m√°s r√°pidas se ejecutan en solo 8 ciclos de reloj, los comandos aritm√©ticos en 14, pero la multiplicaci√≥n (16 * 16 = 32) en 52 ciclos de reloj y especialmente la divisi√≥n (32/16 = 16,16) en 124 per√≠odos de reloj probablemente fue un registro m√°s r√°pido entre los procesadores de los 70.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El TMS9900 requiere tres voltajes de suministro de 5, 5 y 12 voltios y cuatro fases de la se√±al de reloj; estos son antirregistros entre los procesadores que conozco. En 1979, este procesador se demostr√≥ a los especialistas de IBM que buscaban un procesador para el prototipo de PC IBM en desarrollo. Las deficiencias obvias del TMS9900 (capacidad de direccionamiento de solo 64 KB de memoria, falta de arquitectura de controladores necesaria, lentitud relativa) causaron la impresi√≥n correspondiente e Intel 8088 fue elegido como el futuro l√≠der entre las PC. Para resolver el problema de la falta de controladores, Texas Instruments tambi√©n produjo la versi√≥n TMS9900 con un bus de 8 bits, TMS -9980, que funcion√≥ un 33% m√°s lento.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El TMS9900 se us√≥ en las computadoras TI99 / 4 y TI99 / 4A, que eran bastante populares en los EE. UU., Que fueron "aplastadas" en la guerra de precios por la computadora Commodore VIC-20 en 1983. Es curioso que, como resultado de esta guerra, Texas Instruments se haya visto obligado a reducir los precios de su computadora a incre√≠ble para 1983 $ 49 (¬°en 1979 el precio era de $ 1150!) y venderlos con una gran p√©rdida para usted. Por ejemplo, podemos citar la computadora relativamente impopular Commodore + 4, que se suspendi√≥ en 1986, pero cuyos precios cayeron a estos $ 49 solo en 1989. T99 / 4A dej√≥ de producir en 1984, cuando, debido a los precios extremadamente bajos, comenz√≥ a ganar popularidad. Esta computadora solo se puede llamar de 16 bits. Porque tiene solo 256 bytes (!) De memoria RAM y toda la memoria ROM dirigida a trav√©s de un bus de 16 bits.El resto de la memoria y los dispositivos de E / S funcionan a trav√©s de un bus lento de 8 bits. Por lo tanto, es posible considerar m√°s correctamente el BK-0010 dom√©stico como la primera computadora dom√©stica de 16 bits. Curiosamente, la TI99 / 4 y la TI99 / 4A usan un procesador a 3 MHz, exactamente igual que el BK-0010.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En las TI-99/4 y TI99 / 4A, se utiliz√≥ un chip TMS9918 bastante exitoso como controlador de video, que se convirti√≥ en la base del est√°ndar MSX muy popular en todo el mundo, as√≠ como en algunas otras computadoras y consolas de juegos. </font><font style="vertical-align: inherit;">En la compa√±√≠a japonesa Yamaha, este chip de video se mejor√≥ significativamente y se us√≥ posteriormente, en particular, para actualizar las TI-99/4 y TI99 / 4A. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La serie TI99 / 4 es un raro ejemplo de computadoras donde el fabricante del procesador y la computadora eran los mismos.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Procesadores DEC PDP-11 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desde el comienzo de los a√±os 70, la era de 10 a√±os de dominio de DEC comenz√≥ en el mundo. Las computadoras DEC eran significativamente m√°s baratas que las fabricadas por IBM y, por lo tanto, atrajeron la atenci√≥n de peque√±as organizaciones para las que los sistemas IBM no estaban disponibles. La era de la programaci√≥n profesional masiva tambi√©n comienza con estas computadoras. La serie de computadoras PDP-11 ha tenido mucho √©xito. Se fabricaron varios modelos PDP-11 desde principios de los 70 hasta principios de los 90. En la URSS, fueron clonados con √©xito y se convirtieron en los primeros sistemas inform√°ticos populares en masa. Entre los clones se encuentran computadoras con los nombres de computadoras SM, Electronics-60/81/85, DVK-1/2/3, BK-0010/0011 (BK0010 es la primera PC que fue posible comprar en la tienda).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, DEC tambi√©n promovi√≥ las computadoras m√°s caras y sofisticadas de la familia VAX-11, la situaci√≥n en torno a la cual estaba algo politizada. Y a partir de la segunda mitad de los a√±os 70, DEC pr√°cticamente detuvo el desarrollo en la l√≠nea PDP-11, en particular, no se introdujo el soporte para 16 n√∫meros para ensamblador. El rendimiento de los sistemas PDP-11 tambi√©n se ha mantenido pr√°cticamente sin cambios desde mediados de los a√±os 70.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDP-11 utiliz√≥ diferentes procesadores compatibles con el sistema de comando principal, por ejemplo, LSI-11, F-11, J-11. A finales de los a√±os 70, DEC hizo un procesador barato para microcomputadoras T-11. Sin embargo, por razones poco claras, a pesar del software aparentemente grande y de alta calidad que podr√≠a transferirse al sistema que lo usa en el futuro, los fabricantes de sistemas inform√°ticos nunca lo notaron. La √∫nica excepci√≥n fue el modelo de consola de juegos Atari. El T-11 encontr√≥ un uso generalizado solo en el mundo de los equipos integrados, aunque en t√©rminos de capacidades fue bastante superior al z80. En la URSS, se produjeron procesadores K1801BM1, K1801BM2, K1801BM3, ... cerca de procesadores DEC, as√≠ como copias exactas de procesadores DEC. Estos √∫ltimos eran mucho m√°s caros y se produc√≠an en peque√±as cantidades.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El sistema de comandos de los procesadores de arquitectura PDP-11 se distingue por una ortogonalidad casi completa, una calidad agradable, pero cuando se lleva al extremo, puede crear comandos rid√≠culos. El sistema de instrucci√≥n del procesador PDP-11 ha influido en muchas arquitecturas, y en particular en el Motorola 68000.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El sistema de comando PDP-11 es estrictamente de 16 bits. Los 8 registros de prop√≥sito general (y el contador de instrucciones en esta arquitectura es un registro R7 normal) son de 16 bits, el registro de estado (contiene indicadores t√≠picos) tambi√©n es de 16 bits, el tama√±o de las instrucciones es de 1 a 3 palabras de 16 bits. Cada operando en un comando puede ser (aunque hay excepciones, por ejemplo, una instrucci√≥n XOR) de cualquier tipo; esto es ortogonalidad. Entre los tipos se encuentran el registro ordinario o la memoria. Los programadores en los a√±os 80 a veces no entend√≠an por qu√© no hab√≠a instrucciones de memoria-memoria en el sistema de instrucciones Intel x86. Esta es la influencia de la escuela PDP-11, donde puede escribir f√°cilmente direcciones completas para cada operando. Esto, por supuesto, es lento y especialmente lento para sistemas con memoria lenta t√≠pica de principios de los 90. Tambi√©n se puede acceder a la memoria a trav√©s de un registro, un registro con un desplazamiento, un registro con auto decremento o incremento.Una caracter√≠stica del sistema de instrucci√≥n PDP-11 es la posibilidad de doble acceso indirecto a la memoria a trav√©s de un registro, por ejemplo,</font></font><br><br><pre><code class="plaintext">MOV @(R0)+,@-(R1)</code> </pre> <br>  significa lo mismo que el operador de lenguaje C / C ++ <br><br><pre> <code class="plaintext">**‚Äìr1 = **r1++;</code> </pre> <br>  , donde r0 y r1 se declaran como <br><br><pre> <code class="plaintext">signed short **r0, **r1;</code> </pre> <br>  Otro ejemplo, un comando <br><br><pre> <code class="plaintext">MOVB @11(R2),@-20(R3)</code> </pre> <br>  corresponde a <br><br><pre> <code class="plaintext">**(r3-20) = **(r2+11);</code> </pre> <br>  donde r2 y r3 se declaran como <br><br><pre> <code class="plaintext">char **r2, **r3;</code> </pre> <br>  En las arquitecturas populares actuales, un equipo no puede prescindir de dicho equipo; probablemente se necesitar√°n al menos 10 equipos.  Tambi√©n puede obtener la direcci√≥n relativa al valor actual del contador de comandos.  Dar√© otro ejemplo con direccionamiento m√°s simple.  El equipo <br><br><pre> <code class="plaintext">ADD #16,11(R4)</code> </pre> <br>  en la arquitectura Intel x86 se puede mapear <br><br><pre> <code class="plaintext">ADD [BX+11],16</code> </pre> <br>  En los ensambladores DEC, es costumbre escribir operandos de izquierda a derecha, a diferencia de Intel, donde escriben de derecha a izquierda.  Hay razones para creer que el ensamblador GNU para x86 se hizo bajo la influencia del ensamblador PDP-11. <br><br>  Los comandos de multiplicaci√≥n y divisi√≥n son solo simb√≥licos y no est√°n disponibles en todos los procesadores.  La aritm√©tica de n√∫meros decimales tambi√©n es opcional: esta es la denominada aritm√©tica comercial de terminolog√≠a DEC.  Como curiosidad de la ortogonalidad completa, dar√© un ejemplo de un comando <br><br><pre> <code class="plaintext">MOV #11,#22</code> </pre> <br>  que despu√©s de la ejecuci√≥n se convierte en <br><br><pre> <code class="plaintext">MOV #11,#11</code> </pre> <br>  - Este es un ejemplo del uso de una constante inmediata como operando.  Otro equipo curioso es el comando MARK √∫nico, cuyo c√≥digo debe insertarse en la pila y nunca puede usarse expl√≠citamente.  Las rutinas de llamadas en la arquitectura PDP-11 tambi√©n son algo peculiares.  El comando correspondiente primero guarda el registro asignado (puede ser cualquiera) en la pila, luego guarda el contador de instrucciones en este registro y solo luego escribe el nuevo valor en el contador de instrucciones.  El comando de retorno del subprograma debe hacer lo contrario y saber qu√© registro se us√≥ al llamar al subprograma.  Se pueden obtener efectos muy extra√±os e impredecibles utilizando el contador de comandos como un registro normal. <br><br>  Es interesante que entre los programadores de PDP-11, se haya desarrollado una cultura de trabajar directamente con c√≥digos de m√°quina.  Los programadores podr√≠an, por ejemplo, trabajar sin un desensamblador al depurar.  ¬°O incluso escriba peque√±os programas directamente en la memoria sin ensamblar! <br><br>  Por supuesto, los horarios del equipo no difieren en las caracter√≠sticas de alta velocidad.  Fue sorprendente una vez descubrir que en la computadora dom√©stica del BK el comando de transferencia de registro a registro toma hasta 12 ciclos (10 ciclos cuando se usa el c√≥digo de ROM), y los comandos con dos operandos con doble direccionamiento indirecto se ejecutan durante m√°s de 100 ciclos.  Z80 realiza una transferencia de registro de 16 bits para 8. Sin embargo, la lentitud del BC no es causada tanto por el procesador, sino por la mala calidad de la memoria dom√©stica, bajo cuyas caracter√≠sticas el BC tuvo que adaptarse.  Si se usara una memoria suficientemente r√°pida, entonces el BC enviaba 16 bits de registro para 8 ciclos de reloj tambi√©n.  Una vez que hubo mucha controversia, ¬øcu√°l es m√°s r√°pido que BC o Spectrum?  Debe decirse de inmediato que Spectrum es una de las computadoras personales de 8 bits en masa m√°s r√°pidas cuando se utilizan los 32 KB superiores de memoria.  Por lo tanto, no es sorprendente que el Spectrum sea m√°s r√°pido que el BC, pero no por mucho.  Y si el BC funcionara con memoria sin frenos, entonces probablemente ser√≠a un poco m√°s r√°pido. <br><br>  La densidad del c√≥digo tambi√©n es m√°s bien un punto d√©bil de la arquitectura PDP-11.  Los c√≥digos de instrucciones deben ser un m√∫ltiplo de la longitud de la palabra de la m√°quina: 2 bytes, lo que es especialmente desagradable cuando se trabaja con argumentos de bytes o comandos simples como establecer o restablecer un indicador. <br><br>  Los intentos de hacer una computadora personal basada en la arquitectura PDP-11 son interesantes.  Una de las primeras PC en el mundo que apareci√≥ solo un poco m√°s tarde que Apple] [y Commodore PET, y un poco antes que el Tandy TRS-80, fue el Terak 8510 / a, que ten√≠a gr√°ficos en blanco y negro y la capacidad de descargar una versi√≥n incompleta de Unix.  Esta PC era bastante cara y, hasta donde yo s√©, solo se usaba en el sistema de educaci√≥n superior de los EE. UU.  Desde 1978, la computadora se produjo en forma de un kit para ensamblar el Heathkit H11.  El propio DEC tambi√©n trat√≥ de hacer su propia PC, pero de manera muy inconsistente.  DEC, por ejemplo, lanz√≥ una PC basada en el z80 y 8088, obviamente jugando en contra de sus principales desarrollos.  El personal basado en la arquitectura PDP-11 DEC PRO-325/350/380 ten√≠a algunas incompatibilidades bastante artificiales con la arquitectura subyacente, lo que dificultaba el uso de parte del software.  La mejor personalizaci√≥n de las tecnolog√≠as de mini computadoras fue en la URSS, donde se hicieron BK, DVK, CC NT ... Por cierto, Electronics-85 es un clon bastante preciso del DEC PRO-350.  Adem√°s, el procesador CP1600, similar a la arquitectura PDP-11, se utiliz√≥ en las consolas de juegos Intellivision, que eran populares a principios de los a√±os 80. <br><br><img src="https://hsto.org/storage2/054/de2/ed6/054de2ed61ad81127c1d7db0f7171100.jpg"><br>  <i>Computadora dom√©stica dom√©stica de 16 bits (1985): casi compatible con PDP-11</i> <br><br>  K1802BM2, que se us√≥ en el DVK, es aproximadamente dos veces m√°s r√°pido que K1801BM1, K1801BM3 es a√∫n m√°s r√°pido y cercano a Intel 8086. <br><br>  En los modelos PDP-11 m√°s antiguos y las computadoras dom√©sticas cercanas a ellos, el procesador puede direccionar hasta 4 MB de memoria, pero no se pueden asignar m√°s de 64 KB a un programa.  En t√©rminos de velocidad, estos procesadores tambi√©n est√°n cerca de 8086 en t√©rminos del n√∫mero de operaciones por megahercio, aunque todav√≠a es m√°s lento que eso. <br><br><h2>  CPU para DEC VAX-11 </h2><br>  Los sistemas VAX-11 fueron muy populares en los a√±os 80, especialmente en la educaci√≥n superior.  Ahora es dif√≠cil entender algunos de los conceptos descritos en los libros de esos a√±os sin conocer la arquitectura de estos sistemas.  Los VAX-11 eran m√°s caros que los PDP-11, pero estaban m√°s orientados hacia la programaci√≥n universal y a√∫n eran significativamente m√°s baratos que los sistemas IBM / 370.  Para la arquitectura VAX, a mediados de los 80 se fabric√≥ un procesador V-11 y, hasta ese momento, se utilizaron ensamblajes de procesador. <br><br>  La arquitectura VAX-11 es de 32 bits, utiliza 16 registros, entre los cuales, como en el PDP-11, hay un contador de comandos.  Se supone que se deben usar dos pilas, una de las cuales se usa para almacenar marcos de subtrama.  Adem√°s, uno de los registros est√° asignado para trabajar con argumentos de funciones llamadas.  Por lo tanto, 3 de 16 registros se asignan para pilas.  El sistema de comandos VAX-11 no puede dejar de sorprender con su magnitud y la presencia de comandos muy raros y a menudo √∫nicos, por ejemplo, para trabajar con campos de bits o varios tipos de colas, para calcular CRC, multiplicando 10 l√≠neas ... Muchos comandos est√°n en versiones de tres direcciones (ARM) y en dos direcciones (como x86), pero hay comandos de cuatro direcciones, por ejemplo, la divisi√≥n extendida de EDIV.  Por supuesto, hay soporte para trabajar con n√∫meros reales. <br><br>  Pero el VAX-11 es un sistema muy lento para su clase y precio.  Incluso el 6502 s√∫per simple a 4 MHz podr√≠a superar al m√°s lento de la familia VAX-11/730, y los sistemas VAX-11 m√°s r√°pidos: gabinetes enormes y "juegos completos de muebles", est√°n al nivel de rendimiento de los primeros PC AT.  Cuando apareci√≥ el 80286, qued√≥ claro que los d√≠as del VAX-11 estaban contados e incluso el frenado con la introducci√≥n de sistemas basados ‚Äã‚Äãen 80286 ya no pod√≠a cambiar fundamentalmente nada.  Los brit√°nicos m√°s directos de Acorn, despu√©s de haber fabricado ARM en 1985 sin ocultar nada, dijeron que ARM es mucho m√°s barato y notablemente m√°s r√°pido.  VAX-11, sin embargo, sigui√≥ siendo relevante hasta principios de los 90, y a√∫n ten√≠a algunas ventajas sobre una PC, en particular, sistemas m√°s r√°pidos para trabajar con discos. <br><br>  VAX-11 es probablemente el √∫ltimo sistema de masa en el que la conveniencia de trabajar en ensamblador se consideraba m√°s importante que la velocidad.  En cierto sentido, este enfoque se ha desplazado a los lenguajes de script modernos y populares. <br><br><img src="https://gordonbell.azurewebsites.net/Digital/timeline/photos/vax11-785.jpg" align="left">  <i>La foto muestra el VAX-11/785 - esto tambi√©n es una computadora (1984) - el m√°s r√°pido entre los VAX-11, en t√©rminos de velocidad del procesador es comparable a IBM PC AT o ARM Evaluation System</i> <br><br>  Sorprendentemente, hay muy poca literatura disponible sobre los sistemas VAX-11.  Como si hubiera alg√∫n tipo de ley extra√±a sobre el olvido.  Varios episodios cercanos a la pol√≠tica y correlacionados con la historia de la URSS est√°n relacionados con la historia de esta arquitectura.  Es posible que el rechazo real del desarrollo de la arquitectura PDP-11 haya sido causado por su bajo costo y el √©xito de su clonaci√≥n en la Uni√≥n Sovi√©tica.  Y la clonaci√≥n de VAX-11 cost√≥ un orden de magnitud de grandes recursos y condujo a un callej√≥n sin salida.  El inter√©s en VAX-11 se cre√≥ usando, por ejemplo, sorteos como el famoso Kremlin Vax el 1 de abril de 1984, en el que el entonces l√≠der de la URSS Konstantin Chernenko ofreci√≥ beber vodka con motivo de conectarse a la red Usenet.  Otra broma fue que algunos chips VAX-11 estaban impresos con un mensaje en ruso roto sobre lo bueno que es el VAX-11.  :) <br><br>  Algunos modelos VAX-11 fueron clonados en la URSS a fines de los a√±os 80, pero se produjeron muy pocos clones de este tipo y casi nunca encontraron uso. <br><br>  Varios sistemas VAX-11 est√°n disponibles para su uso en la red.  Y esto los compara favorablemente con los sistemas IBM / 370 con los que compet√≠an. <br><br><h2>  Intel: 8086 a 80486 </h2><br>  Por supuesto, uno de los mejores procesadores fabricados en los a√±os 70 es el 8086, as√≠ como su 8088 casi anal√≥gico m√°s econ√≥mico. La arquitectura de estos procesadores se distingue gratamente por la ausencia de pr√©stamos mec√°nicos y la adhesi√≥n a teor√≠as abstractas, arquitectura bien pensada y equilibrada, equilibrada y centrada en mayor desarrollo  Entre las deficiencias de la arquitectura x86, se le puede llamar algo engorroso y una tendencia al crecimiento extenso en el n√∫mero de instrucciones. <br><br>  Una de las ingeniosas soluciones de dise√±o de 8086 fue la invenci√≥n de los registros de segmento.  Esto, por as√≠ decirlo, logr√≥ simult√°neamente dos objetivos: portabilidad "gratuita" de programas de hasta 64 KB de tama√±o (esta era una cantidad muy decente de memoria de computadora para un programa hasta mediados de los 80), y capacidad de direccionamiento de hasta 1 MB de espacio de direcciones.  Tambi√©n puede observar que el 8086, como el 8080 o el z80, tambi√©n tiene un espacio de direcciones especial para puertos de E / S de 64 KB de tama√±o (y 8080 y 8085, este volumen es de 256 bytes).  Solo hay cuatro registros de segmento: para c√≥digo, para pila y dos para datos.  Por lo tanto, 64 * 4 = 256 KB de memoria est√°n disponibles para un uso r√°pido, pero esto fue incluso a mediados de los a√±os 80.  De hecho, no hay ning√∫n problema con el tama√±o del c√≥digo, ya que puede usar las llamadas llamadas largas de subprogramas al cargar y guardar la direcci√≥n completa de dos registros.  Solo hay un l√≠mite de 64 KB en el tama√±o de un subprograma; esto es suficiente para muchas aplicaciones modernas.  La imposibilidad de direccionar r√°pidamente las matrices de datos de m√°s de 64 KB crea un cierto problema: cuando se usan dichas matrices, debe cargar el registro de segmento y la direcci√≥n en s√≠ cada vez que se accede, lo que reduce la velocidad de trabajar con matrices tan grandes en varias ocasiones. <br><br>  Los registros de segmento se implementan de tal manera que su presencia es casi imperceptible en los c√≥digos de m√°quina, lo que facilita su rechazo cuando llega el momento. <br><br>  La arquitectura 8086 mantuvo su proximidad a la arquitectura 8080, lo que permiti√≥ un esfuerzo relativamente peque√±o para transferir programas desde 8080 (o incluso z80) a 8086, y especialmente si el c√≥digo fuente de los programas estaba disponible. <br><br>  Los equipos 8086 no difieren en la alta velocidad de ejecuci√≥n, pero son bastante comparables con los competidores, por ejemplo, Motorola 68000, que apareci√≥ un a√±o despu√©s.  Uno de los nuevos productos, que acelera ligeramente el 8086, generalmente sin prisas, fue el turno de los equipos. <br><br>  El 8086 usa ocho registros de 16 bits, algunos de los cuales se pueden usar como registros de dos bytes y otros como √≠ndices.  Por lo tanto, los registros 8086 son algo heterog√©neos, pero est√° bien equilibrado y los registros son muy convenientes de usar.  Esta heterogeneidad, por cierto, le permite tener c√≥digos m√°s densos.  El 8086 usa las mismas banderas que el 8080, m√°s algunas nuevas.  Por ejemplo, apareci√≥ una bandera que es t√≠pica de la arquitectura PDP-11: ejecuci√≥n paso a paso. <br><br>  8086 le permite utilizar modos de direccionamiento muy interesantes, por ejemplo, una direcci√≥n puede estar compuesta por la suma de dos registros y una mezcla constante de 16 bits, en la que se superpone el valor de uno de los registros de segmento.  Solo dos o incluso un t√©rmino pueden quedar fuera de la suma de la direcci√≥n.  Esto en PDP-11 con un comando no funcionar√°.  La mayor√≠a de las instrucciones 8086 no permiten ambos operandos de tipo memoria; uno de los operandos debe ser un registro.  Pero hay comandos de cadena que solo saben c√≥mo trabajar con la memoria utilizando dos direcciones.  Los comandos de cadena le permiten copiar en bloque r√°pidamente (17 medidas por byte o palabra), buscar, llenar, cargar y comparar.  Adem√°s, los comandos de cadena se pueden usar cuando se trabaja con puertos de E / S.  La idea de que 8086 use prefijos de comandos es muy interesante, ya que permite utilizar funcionalidades adicionales muy √∫tiles sin complicaci√≥n significativa de los esquemas de codificaci√≥n de comandos. <br><br>  8086 tiene uno de los mejores entre todos los sistemas inform√°ticos para la organizaci√≥n del trabajo con la pila.  Usando solo dos registros (BP y SP), 8086 le permite resolver todos los problemas al organizar llamadas a rutinas con par√°metros. <br><br>  Entre los equipos hay multiplicaci√≥n y divisi√≥n simb√≥lica y sin signo.  Incluso hay comandos √∫nicos de ajuste decimal para los comandos de multiplicaci√≥n y divisi√≥n.  Es dif√≠cil decir que claramente falta algo en el sistema de comando 8086.  M√°s bien, lo contrario.  Dividir un dividendo de 32 bits en un divisor de 16 bits para obtener un resto privado de 32 bits y un resto de 16 bits puede requerir hasta 300 ciclos de reloj, no particularmente r√°pido, pero varias veces m√°s r√°pido que dicha divisi√≥n en cualquier procesador de 8 bits (excepto 6309) y comparable en velocidad a 68000. La divisi√≥n por x86 tiene una caracter√≠stica inesperada: cambia las banderas de signos de forma impredecible ... <br><br>  Vale la pena agregar que en la arquitectura x86, el equipo XCHG heredado del 8080 se mantuvo, lo que se mejor√≥.  Adem√°s, los procesadores posteriores comenzaron a usar las instrucciones XADD, CMPXCHG y CMPXCHG8B, que tambi√©n pueden realizar un intercambio at√≥mico de argumentos.  Dichas instrucciones son una de las caracter√≠sticas de x86, es dif√≠cil encontrarlas en procesadores de otras arquitecturas. <br><br>  Podemos resumir que el 8086 es un procesador muy exitoso, que combina la conveniencia de la programaci√≥n y el apego a las limitaciones de memoria que son caracter√≠sticas de su tiempo.  El 8086 se utiliz√≥ con relativa poca frecuencia, dando lugar al 8088 m√°s barato como el lugar de honor para ser el primer procesador de la arquitectura de PC principal de nuestro tiempo, la arquitectura de PC de IBM.  El 8088 utiliz√≥ un bus de datos de 8 bits, lo que lo hizo algo m√°s lento, pero permiti√≥ construir sistemas m√°s accesibles para los clientes basados ‚Äã‚Äãen √©l. <br><br>  Curiosamente, Intel se neg√≥ fundamentalmente a realizar mejoras en sus procesadores, prefiriendo desarrollar sus pr√≥ximas generaciones.  Uno de los segundos subcontratistas (NEC) m√°s grandes de Intel, la corporaci√≥n japonesa NEC, que a principios de los a√±os 80 era mucho m√°s grande que Intel, decidi√≥ mejorar los procesadores 8088 y 8086, lanzando procesadores V20 y V30, compatibles con ellos en el z√≥calo y hasta un 30% m√°s r√°pido.  ¬°NEC incluso le ofreci√≥ a Intel convertirse en su subcontratista!  En cambio, Intel lanz√≥ una demanda contra NEC, que, sin embargo, no pudo ganar.  Por alguna raz√≥n, este gran enfrentamiento entre Intel y NEC fue completamente ignorado por Wikipedia. <br><br>  80186 y 80286 aparecieron en 1982. Por lo tanto, se puede suponer que Intel ten√≠a dos equipos de desarrollo casi independientes.  80186 es un 8086 mejorado por varios comandos y tiempos m√°s cortos, adem√°s de varios circuitos integrados t√≠picos de la arquitectura x86: generador de reloj, temporizadores, DMA / DAP, controlador de interrupci√≥n, generador de retardo, etc. Tal procesador parece simplificar enormemente la producci√≥n. computadoras basadas en √©l, pero debido a que el controlador de interrupci√≥n incorporado result√≥ ser incompatible con la PC de IBM por alguna raz√≥n, casi nunca se us√≥ en una PC.  El autor solo conoce el sistema BBC Master 512 basado en la computadora BBC Micro, que no usaba los circuitos integrados, ni siquiera el temporizador, pero hab√≠a varios sistemas m√°s que usaban 80186. La memoria direccionable de 80186 permaneci√≥ de la misma manera que en 8086 con un tama√±o de 1 MB.  La corporaci√≥n japonesa NEC produjo an√°logos de 80186, que eran compatibles con la PC de IBM. <br><br>  80286 tuvo tiempos a√∫n mejores que 80,186, entre los cuales la divisi√≥n fant√°stica (32/16 = 16,16) para 22 medidas es especialmente notable, ¬°desde entonces no se ha aprendido a hacer la divisi√≥n m√°s r√°pido!  80286 admite trabajar con todos los nuevos equipos 80186, adem√°s de muchos equipos para trabajar en un nuevo modo protegido.  80286 fue el primer procesador con soporte incorporado para el modo protegido, que permiti√≥ organizar la protecci√≥n de la memoria, el uso correcto de instrucciones privilegiadas y el acceso a la memoria virtual.  Si bien trabajar en el nuevo modo cre√≥ muchos problemas problem√°ticos (el modo protegido se realiz√≥ sin √©xito) y se us√≥ de manera relativamente rara, fue un gran avance.  En este nuevo modo, los registros de segmento han adquirido una nueva calidad, lo que le permite utilizar hasta 16 MB de memoria direccionable y hasta 1 GB de memoria virtual por tarea.  El gran problema con 80286 fue la incapacidad de cambiar del modo protegido al modo real, en el que la mayor√≠a de los programas funcionaban entonces.  Utilizando la instrucci√≥n LOADALL indocumentada "secreta", fue posible utilizar 16 MB en memoria y en modo real. <br><br>  En 80286, el c√°lculo de direcciones en operandos de instrucciones comenz√≥ a realizarse por esquemas separados y dej√≥ de ralentizar la ejecuci√≥n de comandos.  Esto agreg√≥ caracter√≠sticas interesantes, por ejemplo, con el equipo <br><br><pre> <code class="plaintext">LEA AX,[BX+SI+4000]</code> </pre> <br>  ¬°En solo 3 ciclos, fue posible realizar dos adiciones y transferir el resultado al registro AX! <br><br>  Los registros segmentados en modo protegido se han convertido en parte de un sistema completo de administraci√≥n de memoria (MMU).  En modo real, estos registros solo proporcionan parcialmente la funcionalidad MMU. <br><br>  El n√∫mero de fabricantes y sistemas espec√≠ficos que usan 80286 es enorme, pero, por supuesto, los primeros fueron computadoras PC PC de IBM con indicadores de rendimiento que fueron casi fant√°sticos entre las computadoras personales.  Desde estas computadoras, la memoria comenz√≥ a retrasarse en la velocidad del procesador, hubo estados de retraso, pero luego pareci√≥ algo m√°s temporal. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En 80286, como en 8086/8088, el trabajo con interrupciones no se implement√≥ al 100% correctamente, lo que en casos muy raros podr√≠a tener consecuencias muy desagradables. Por ejemplo, el comando POPF de 80286 siempre permiti√≥ interrupciones durante su ejecuci√≥n, y al ejecutar un comando con dos prefijos (como ejemplo, tome REP ES: MOVSB) en 8086/8088, despu√©s de llamar a la interrupci√≥n, uno de los prefijos se perdi√≥. Un error en POPF fue solo en versiones anteriores de 80286.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El modo protegido 80286 era extremadamente inconveniente, divid√≠a toda la memoria en segmentos de no m√°s de 64 KB y requer√≠a soporte de software complejo para trabajar con memoria virtual. Habiendo aparecido en 1985, 80386 hizo el trabajo en modo protegido bastante c√≥modo, hizo posible usar hasta 4 GB de memoria direccionable y cambiar f√°cilmente entre modos. Adem√°s, para admitir la multitarea, se cre√≥ un modo virtual 8086 para programas para 8086. Para la memoria virtual, se hizo posible utilizar un modo de p√°gina relativamente f√°cil de administrar. 80386, con todas sus innovaciones, retuvo la compatibilidad total con los programas escritos para 80286. Entre las innovaciones de 80386, tambi√©n podemos mencionar la extensi√≥n de registros a 32 bits y la adici√≥n de dos nuevos registros de segmento. Los tiempos han cambiado, pero de manera ambigua. Se ha agregado un cambio r√°pido de bitslo que hizo posible realizar m√∫ltiples turnos con tiempos de uno. Sin embargo, esta innovaci√≥n por alguna raz√≥n ralentiz√≥ en gran medida la ejecuci√≥n de las instrucciones de cambio c√≠clico. La multiplicaci√≥n se ha vuelto un poco m√°s lenta que la de 80286. Por el contrario, trabajar con la memoria se ha vuelto un poco m√°s r√°pido, pero esto no se aplica a los comandos de cadena, que se mantuvieron m√°s r√°pidos que 80286. El autor de este material a menudo ha encontrado la opini√≥n de que en modo real con 16- El c√≥digo de bits 80286 al final sigue siendo un poco m√°s r√°pido que 80386 a la misma frecuencia.El autor de este material m√°s de una vez tuvo que encontrar la opini√≥n de que en modo real con un c√≥digo 80286 de 16 bits, al final, todav√≠a es un poco m√°s r√°pido que 80386 con la misma frecuencia.El autor de este material m√°s de una vez tuvo que encontrar la opini√≥n de que en modo real con un c√≥digo 80286 de 16 bits, al final, todav√≠a es un poco m√°s r√°pido que 80386 con la misma frecuencia.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En 80386 se agregaron nuevos comandos, la mayor√≠a de los cuales solo daban nuevas formas de trabajar con datos, en realidad duplicando los disponibles para algunos casos con optimizaci√≥n. </font><font style="vertical-align: inherit;">Por ejemplo, se agregaron los siguientes comandos:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para verificar, establecer y restablecer el bit por n√∫mero, similar a los que se hicieron para z80; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escaneo de bits BSF y BSR; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> copiar valores con extensi√≥n con signo o cero, MOVSX y MOVZX; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> establecer valores seg√∫n los valores de los indicadores de las operaciones SETxx; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> turnos dobles SHLD, SHRD. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de la llegada de 80386, los procesadores x86 solo pod√≠an usar saltos condicionales cortos de un byte, esto a menudo era muy insuficiente. Con 80386, se hizo posible usar compensaciones de dos (o cuatro en el modo de direcci√≥n de 32 bits) bytes, y a pesar de que el c√≥digo de las nuevas transiciones se volvi√≥ dos (o tres) veces m√°s largo, su tiempo de ejecuci√≥n permaneci√≥ igual que los anteriores, transiciones cortas </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El soporte de depuraci√≥n se mejor√≥ radicalmente al introducir 4 puntos de interrupci√≥n de hardware, us√°ndolos, fue posible detener programas incluso en direcciones en la memoria que no se pueden cambiar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El modo protegido principal se ha vuelto mucho m√°s f√°cil de administrar que en 80286, que hizo que varios comandos heredados fueran rudimentos innecesarios. En el modo protegido principal, el llamado modo plano utiliza segmentos de hasta 4 GB de tama√±o, lo que convierte todos los registros de segmento en una formalidad sutil. Y el modo irreal semi-documentado incluso hizo posible utilizar toda la memoria como en el modo plano, pero desde el modo real, que es f√°cil de instalar y administrar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con 80386, Intel se neg√≥ a compartir sus tecnolog√≠as, convirti√©ndose de hecho en un fabricante monopol√≠stico de procesadores para la arquitectura de PC de IBM, y con el debilitamiento de Motorola, para otras arquitecturas de computadoras personales. </font><font style="vertical-align: inherit;">Los sistemas basados ‚Äã‚Äãen 80386 eran muy caros hasta principios de los 90, cuando finalmente estuvieron disponibles para los consumidores masivos en frecuencias de 25 a 40 MHz. </font><font style="vertical-align: inherit;">C 80386 IBM comenz√≥ a perder su posici√≥n como fabricante l√≠der de computadoras compatibles con PC de IBM. </font><font style="vertical-align: inherit;">Esto se manifest√≥, en particular, en el hecho de que la computadora Compaq fue la primera PC basada en 80386 en 1986.</font></font><br><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es dif√≠cil no contener la admiraci√≥n por los vol√∫menes de trabajo realizados por los creadores de 80386 y sus resultados. </font><font style="vertical-align: inherit;">Incluso me atrevo a sugerir que el 80386 contiene m√°s logros que todos los logros tecnol√≥gicos de la humanidad antes de 1970, y tal vez incluso antes de 1980.</font></font><br><br></p><p>      80386.   .     ,               .       80386 ,    .     IBTS  XBTS.   80386DX/SX,   AMD,   Intel (     ),      ,       EAX,            POPAD  PUSHAD  ,     BX.       .      ,        .    . <br><br>  ARM      .   ,  ARM   .  Intel  80486.             Intel           ‚Äì   . <br><br>  80486                ARM  .     -   .  ,           ,   8088!      ,  8 ,  -.    , , CMPXCHG ‚Äì       IBTS  XBTS (,             80386).     ‚Äì  ,             32-  BSWAP.           ‚Äì     .      . <br><br>     80486   .  ,      80486,  VX FT,    Apricot ‚Äì    1989   18  40  ,     ‚Äì  60 !           Intel       ARM  Acorn. IBM      80486  1990,    PS/2 90  $17000. <br><br>     Intel  ,   .      ,     8086. ,        ,        AAD  AAM      ,   (      Pentium  15 !).      AND/OR/XOR    , , AND BX,7      (83 E3 07).  ,    ,       ,        80386. ,      8086  80286     ,       .      ADD/ADC/SBB/SUB,      . ,  ,   ,    (?)      .           ‚Äì       .  , ,   SAL/SHL ( D0 E0, D0 F0  D1 E0, D1 F0)   . ,    ,     . ,     .   ,  Intel     ,     ?  SALC      1995  20 !    ICEBP    10   1985  1995.       LOADALL  LOADALLD ‚Äì      ,                80286  80386 .        UD1 (0F B9),      .    . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En la URSS, se domin√≥ la producci√≥n de clones de los procesadores 8088 y 8086, y no fue posible reproducir completamente 80286. </font></font><br><br></p><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Motorola: 68,000 a 68040 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Motorola es la √∫nica compa√±√≠a que durante alg√∫n tiempo pudo competir exitosamente con Intel en la producci√≥n de procesadores para computadoras personales. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68000 fue lanzado en 1979 y a primera vista parec√≠a mucho m√°s impresionante que 8086. Ten√≠a 16 registros de 32 bits (m√°s precisamente, incluso 17), un contador de comandos separado y un registro de estado. Podr√≠a direccionar 16 MB de memoria directamente, lo que no cre√≥ ninguna restricci√≥n, por ejemplo, para matrices grandes. Sin embargo, un an√°lisis cuidadoso de las caracter√≠sticas del 68000 muestra que no todo es tan bueno como parece. En esos a√±os, tener una memoria de m√°s de 1 MB es un lujo inalcanzable incluso para organizaciones medianas. La densidad de c√≥digos en 68000 es peor que en 8086, lo que significa que los c√≥digos con la misma funcionalidad ocupan 68000 m√°s espacio. Esto √∫ltimo tambi√©n se debe al hecho de que los c√≥digos 68k deben tener un m√∫ltiplo de 2 bytes de longitud, y x86 debe tener 1. Pero la informaci√≥n sobre la densidad del c√≥digo es controvertida, ya que hay evidencia de que en algunos casos 68000 puede ser mejor que 8086 De los 16 registros, 8 son direccionables,de alguna manera, estos son an√°logos un poco m√°s avanzados de registros de segmento x86. ALU y el bus de datos son de 16 bits, por lo que las operaciones con datos de 32 bits son m√°s lentas de lo que cabr√≠a esperar. El tiempo de ejecuci√≥n de las operaciones de registro a registro es de 4 ciclos, y el de 8086 es de solo 2. Las computadoras basadas en 68000 hasta mediados de los 80 resultaron ser mucho m√°s caras que las computadoras basadas en Intel 8088, pero 68000 no pod√≠a funcionar con memoria virtual y no ten√≠a hardware soporte para trabajar con n√∫meros reales, lo que lo hizo inadecuado para su uso en los sistemas m√°s avanzados.que basado en Intel 8088, pero 68000 no pod√≠a funcionar con memoria virtual y no ten√≠a soporte de hardware para trabajar con n√∫meros reales, lo que lo hac√≠a inadecuado para su uso en los sistemas m√°s avanzados.que basado en Intel 8088, pero 68000 no pod√≠a funcionar con memoria virtual y no ten√≠a soporte de hardware para trabajar con n√∫meros reales, lo que lo hac√≠a inadecuado para su uso en los sistemas m√°s avanzados.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como siempre, con los productos de Motorola, la arquitectura 68000 muestra cierta torpeza y rarezas descabelladas. Por ejemplo, dos pilas o dos banderas de transporte (una para funciones y otra para operaciones). Esta rareza con las banderas no termina ah√≠. Por alguna raz√≥n, muchos equipos, incluso MOVE, est√°n llenos de banderas para llevar y banderas de desbordamiento. Otra cosa extra√±a es que el comando para guardar el estado de los indicadores aritm√©ticos, que funcion√≥ bien en 68000, se ha privilegiado en todos los procesadores a partir de 68010. Algunas operaciones son molestas con su no optimizaci√≥n, por ejemplo, la operaci√≥n de escribir cero en la memoria CLR es m√°s lenta que escribir el 0 constante en la memoria con el comando MOVE o un desplazamiento a la izquierda es m√°s lento que agregar el operando a s√≠ mismo. Hay algunos comandos pr√°cticamente innecesarios, por ejemplo, hay cambios aritm√©ticos y l√≥gicos a la izquierda.Incluso los registros de direcciones con ventajas aparentemente superiores a los registros de segmentos 8086 tienen una serie de inconvenientes molestos. Por ejemplo, en ellos se requer√≠a cargar hasta 4 bytes en lugar de dos en 8086 y uno de estos cuatro era superfluo. El sistema de comando 68000 revela muchas similitudes con el sistema de comando PDP-11 desarrollado en los a√±os 60.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los c√≥digos para Motorola se ven de alguna manera m√°s voluminosos y torpes en comparaci√≥n con x86 o ARM. Por otro lado, 68,000 es a√∫n m√°s r√°pido que 8086, seg√∫n mis estimaciones, en aproximadamente un 20-30%. Sin embargo, los c√≥digos 680x0 tambi√©n tienen su propia belleza y elegancia especiales, menos mec√°nica, caracter√≠stica de x86. Adem√°s, como lo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demostr√≥ la</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comunicaci√≥n con los expertos de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">eab.abime.net</font></a><font style="vertical-align: inherit;"> , la densidad de c√≥digo de 68k a menudo es mejor que x86.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En general, el 68000 es un buen procesador, con un gran sistema de instrucciones. Fue utilizado en muchas computadoras personales legendarias: en las primeras computadoras Apple Macintosh, que se produjeron antes de principios de los 90, en las primeras computadoras multimedia Commodore Amiga, en las computadoras Atari ST relativamente econ√≥micas y de alta calidad. El 68,000 tambi√©n se us√≥ en computadoras relativamente econ√≥micas que funcionan con variantes de Unix, en particular en el popular Tandy 16B. Curiosamente, IBM simult√°neamente con el desarrollo de PC lider√≥ el desarrollo de la computadora System 9000 basada en 68000, que se lanz√≥ menos de un a√±o despu√©s de la PC.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El 68010 apareci√≥ obviamente tarde, solo en 1982, al mismo tiempo que Intel lanz√≥ el 80286, que puso a las computadoras personales en el nivel de las minicomputadoras. 68010 es compatible con el conector 68000, pero el sistema de sus comandos es ligeramente diferente, por lo que reemplazar el 68000 con 68010 no se ha vuelto popular. La incompatibilidad fue causada por una raz√≥n descabellada para alinear 68,000 m√°s con la teor√≠a ideal de organizar el soporte de virtualizaci√≥n. 68010 es solo un poco, no m√°s del 10% m√°s r√°pido que 68000. Es obvio que 68010 perdi√≥ mucho frente a 80286 y fue a√∫n m√°s d√©bil que el 800186 que apareci√≥ en el mismo a√±o. Al igual que 80186, 68010 casi nunca encontr√≥ su uso en computadoras personales.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68008 tambi√©n se lanz√≥ en 1982, probablemente con la esperanza de repetir el √©xito de 8088. Esto es 68000, pero con un bus de datos de 8 bits, que permiti√≥ su uso en sistemas m√°s baratos. Pero el 68008, como el 68000, no tiene una l√≠nea de comando, lo que lo hace aproximadamente un 50% m√°s lento que el 68000. Por lo tanto, el 68008 puede ser incluso un poco m√°s lento que el 8088, que, debido a la l√≠nea de comando, es solo un 20% m√°s lento de 8086.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basado en esto, Sir Clive Sinclair hizo el Spectrum QL, una computadora muy interesante que, debido a su precio m√°s bajo, podr√≠a competir con Atari ST y computadoras similares. Pero Clive simult√°neamente y obviamente prematuramente comenz√≥ a invertir una gran cantidad de energ√≠a en el desarrollo de veh√≠culos el√©ctricos, dejando QL (salto cu√°ntico - salto cu√°ntico) como una tarea secundaria, que, con algunas soluciones de dise√±o fallidas, llev√≥ a la computadora de Clive y a toda la compa√±√≠a a cerrar prematuramente (la compa√±√≠a se convirti√≥ en parte Amstrad, que se neg√≥ a producir QL). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ser√≠a interesante calcular el √≠ndice de bits para 68000, me parece que es claramente superior a 16, aunque lo m√°s probable es que no sea superior a 24.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de haber aparecido en 1984, 68020 volvi√≥ nuevamente a Motorola a las primeras posiciones. Este procesador ha implementado muchos productos nuevos muy interesantes y prometedores. ¬°El efecto m√°s fuerte es ciertamente producido por la canalizaci√≥n de instrucciones, que a veces le permite ejecutar hasta tres instrucciones a la vez! El bus de direcciones de 32 bits parec√≠a un poco prematuro en esos a√±os y, por lo tanto, se produjo una versi√≥n m√°s barata del procesador 68020EC con un bus de 24 bits. Pero el bus de datos de 32 bits parec√≠a bastante apropiado y permiti√≥ acelerar significativamente el trabajo. La novedad tambi√©n analiz√≥ el cach√© incorporado, aunque peque√±o, de 256 bytes, en volumen, lo que permiti√≥ mejorar significativamente el rendimiento, ya que la memoria din√°mica principal ya no pod√≠a seguir el ritmo del procesador. Se agregaron operaciones bastante r√°pidas para la divisi√≥n (64/32 = 32.32) y la multiplicaci√≥n (32 * 32 = 64), para aproximadamente 80 y hasta 45 medidas, respectivamente.Los tiempos de las instrucciones generalmente mejoraron significativamente, por ejemplo, la divisi√≥n (32/16 = 16.16) comenz√≥ a realizarse en aproximadamente 45 ciclos (m√°s de 140 ciclos en 68000). ¬°Algunas instrucciones, en los casos m√°s favorables, se pueden ejecutar sin necesidad de ciclos! Se agregaron nuevos modos de direcci√≥n, en particular con el escalado: en x86, este modo apareci√≥ solo el a√±o pr√≥ximo en 80386. Otros nuevos modos de direcci√≥n permiten el uso de direccionamiento indirecto doble, usando varios desplazamientos, PDP-11 se super√≥ significativamente aqu√≠.con escala: en x86, este modo apareci√≥ solo el a√±o pr√≥ximo en 80386. Otros modos de direccionamiento nuevos permiten el uso de direccionamiento indirecto doble, utilizando varios desplazamientos al mismo tiempo: PDP-11 fue superado significativamente aqu√≠.con escala: en x86, este modo apareci√≥ solo el a√±o pr√≥ximo en 80386. Otros modos de direccionamiento nuevos permiten el uso de direccionamiento indirecto doble, utilizando varios desplazamientos al mismo tiempo: PDP-11 fue superado significativamente aqu√≠.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero algunas instrucciones nuevas, por ejemplo, operaciones pesadas con campos de bits o nuevas operaciones con 10 n√∫meros que se volvieron innecesarias con la divisi√≥n y multiplicaci√≥n r√°pidas, se parec√≠an m√°s a una quinta rueda en un carro que a algo esencialmente √∫til. Los modos de direcci√≥n con doble direccionamiento indirecto te√≥ricamente parecen interesantes, pero pr√°cticamente no se necesitan y se ejecutan muy lentamente. A diferencia de 80286, 68020 toma tiempo para calcular la direcci√≥n del operando, la llamada direcci√≥n efectiva. La divisi√≥n en 68020 result√≥ ser casi el doble de lenta que la divisi√≥n milagrosa en 80286. La multiplicaci√≥n y algunas operaciones tambi√©n son m√°s lentas. El 68020 no tiene un sistema integrado de administraci√≥n de memoria (MMU) y, m√°s bien, la capacidad ex√≥tica de conectar hasta ocho coprocesadores no pudo solucionarlo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El 68020 se us√≥ ampliamente en las computadoras masivas Apple Macintosh II, Macintosh LC y Commodore Amiga 1200. Tambi√©n se us√≥ en varios sistemas Unix.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La llegada del 80386 con sus buses y registros MMU integrados y de fabricaci√≥n muy s√≥lida y 32 bits puso a Motorola nuevamente en la posici√≥n n√∫mero 2. 68030, que apareci√≥ en 1987, por √∫ltima vez, pudo recuperar el liderazgo de Motorola por un corto tiempo. El 68030 tiene un sistema integrado de administraci√≥n de memoria y un cach√© duplicado, dividido en un cach√© para instrucciones y datos. Era un producto nuevo muy prometedor. Adem√°s, el 68030 podr√≠a usar una interfaz de acceso a memoria m√°s r√°pida, que puede acelerar las operaciones de memoria en casi un tercio. Pero, a pesar de todas las innovaciones, el 68030 result√≥ ser un poco m√°s lento que el 80386 a las mismas frecuencias. Sin embargo, 68030 estaba disponible en frecuencias de hasta 50 MHz y 80386 solo hasta 40 MHz, lo que hizo que los principales sistemas basados ‚Äã‚Äãen 68030 fueran un poco m√°s r√°pidos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68030 se us√≥ en computadoras de la serie Apple Macintosh II, Commodore Amiga 3000, Atari TT, Atari Falcon y algunas otras.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con el 68040, Motorola una vez m√°s intent√≥ superar a Intel. Este procesador apareci√≥ un a√±o despu√©s despu√©s de 80486, pero en t√©rminos de la combinaci√≥n de cualidades √∫tiles, no pudo superarlo. De hecho, Motorola, al tener un sistema de comando m√°s sobrecargado, no pudo soportarlo y, en cierto sentido, perdi√≥ el rumbo. En 68040 solo pudieron colocar un coprocesador muy truncado para trabajar con n√∫meros reales y el chip en s√≠ se calent√≥ significativamente m√°s de 80486. Seg√∫n los resultados en lowendmac.com/benchmarks 68040, es solo 2.1 veces m√°s r√°pido que 68030, lo que significa que 68040 es un poco m√°s lento que 80486 en ese sentido. misma frecuencia 68040 pr√°cticamente no encontr√≥ aplicaci√≥n en computadoras populares. Solo su opci√≥n m√°s barata, 68LC040, que no tiene un coprocesador integrado, encontr√≥ un uso notable. Sin embargo¬°Las primeras versiones de este chip ten√≠an un serio defecto de hardware, que ni siquiera permit√≠a el uso de la emulaci√≥n de software de un coprocesador!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motorola siempre ha tenido problemas con los coprocesadores matem√°ticos. </font><font style="vertical-align: inherit;">Motorola, como ya se mencion√≥, no ha lanzado dicho coprocesador para 68000/68010, mientras que Intel lanz√≥ su exitoso 8087 desde 1980. Para los procesadores 68020/68030, se produjeron dos coprocesadores 68881 y su versi√≥n mejorada compatible con pin 68882 a la vez. Pero para obtener una ganancia de rendimiento significativa, el c√≥digo para 68882 debe compilarse de manera diferente que para 68881. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es apropiado decir que Intel x86 todav√≠a tiene problemas con el coprocesador matem√°tico: la precisi√≥n de los c√°lculos de algunas funciones, por ejemplo, el seno de algunos argumentos, es muy peque√±o, </font><font style="vertical-align: inherit;">a veces no m√°s de 4 caracteres. </font><font style="vertical-align: inherit;">Por lo tanto, los compiladores modernos a menudo calculan tales funciones sin recurrir a los servicios de un coprocesador.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> National Semiconductor 32016 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es el primer procesador real de 32 bits propuesto para su uso en computadoras en 1982. Este procesador se plane√≥ originalmente como un VAX-11 en un chip, pero debido a la incapacidad de negociar con DEC, National Semiconductor (NS) tuvo que hacer que el procesador solo separe partes similares. en la arquitectura VAX-11. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El uso de memoria virtual paginada comienza con este procesador: hoy es la tecnolog√≠a dominante. Pero la compatibilidad con la memoria virtual no est√° integrada en el procesador, sino que requiere un coprocesador. Tambi√©n se requiere un coprocesador separado para trabajar con n√∫meros reales.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El sistema de instrucci√≥n NS32016 es enorme y similar al sistema de instrucci√≥n VAX-11, en particular, con una pila separada para marcos de subprograma. El bus de direcciones es de 24 bits, lo que le permite utilizar hasta 16 MB de memoria. Una caracter√≠stica de 32016 es el trabajo con banderas de signos. Adem√°s de las banderas de transporte est√°ndar (que tambi√©n se pueden usar como un signo para una transici√≥n condicional), desbordamiento, signo, igualdad (o cero), tambi√©n est√° la bandera L (menos), lo que significa que menos es como un transporte para las comparaciones. La situaci√≥n de transferencia es similar a la de los procesadores Motorola 680x0. El indicador de desbordamiento se llama por alguna raz√≥n F. Hay indicadores de modo paso a paso, modo privilegiado y (¬°unicidad!) Indicador para seleccionar la pila actual. Al realizar instrucciones aritm√©ticas, los indicadores del signo, cero, minoritario (L) no se establecen, solo se establecen mediante comandos de comparaci√≥n.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede usar ocho registros de prop√≥sito general de 32 bits. Adem√°s, tambi√©n hay un contador de comandos, dos punteros de pila, un puntero de pila de cuadros de subprograma, un puntero base de programa (esto es algo √∫nico), un puntero base de m√≥dulo (tambi√©n algo muy raro), un puntero a la tabla de vectores de interrupci√≥n, registro de configuraci√≥n y registro condici√≥n En t√©rminos de velocidad, el NS32016 fue comparable a 68,000.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32016, que yo sepa, se us√≥ solo con computadoras personales BBC Micro como segundo procesador. </font><font style="vertical-align: inherit;">Era un prefijo muy costoso y prestigioso para 1984. </font><font style="vertical-align: inherit;">Fue posible pedir un procesador con frecuencias de 6, 8 y 10 MHz. </font><font style="vertical-align: inherit;">Hubo algunos problemas t√©cnicos con este √∫ltimo y fue muy costoso. </font><font style="vertical-align: inherit;">Hab√≠a muy poco software para 32016, solo hecho por Acorn, un sistema operativo Unix tipo Panos y Acorn BASIC. </font><font style="vertical-align: inherit;">BBC Micro no us√≥ el chip MMU, aunque pod√≠a conectarse, no hab√≠a programas para usarlo. </font><font style="vertical-align: inherit;">El coprocesador aritm√©tico ni siquiera estaba previsto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se sabe que este procesador muy complejo tiene graves errores de hardware que se han solucionado durante a√±os.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Brazo de bellota </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La ideolog√≠a de 6502, a saber, hacerla m√°s simple, m√°s barata y mejor, continu√≥ en el desarrollo casi fant√°stico de Acorn, el procesador ARM-1, lanzado en 1985, al mismo tiempo que el milagro tecnol√≥gico de Intel, el procesador 80386. ARM consist√≠a en un orden de magnitud menor el n√∫mero de transistores y, por lo tanto, consumi√≥ significativamente menos energ√≠a y, en promedio, fue mucho m√°s r√°pido. Por supuesto, ARM no ten√≠a ninguna MMU o incluso operaciones de divisi√≥n y multiplicaci√≥n, por lo que en algunos c√°lculos basados ‚Äã‚Äãen la divisi√≥n 80386 podr√≠a ser m√°s r√°pido. Sin embargo, las ventajas de ARM fueron tan grandes que hoy es la arquitectura de procesador m√°s masiva. Se han lanzado m√°s de 100 mil millones de procesadores de este tipo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El desarrollo de ARM en 1983 comenz√≥ despu√©s de que Acorn realiz√≥ una investigaci√≥n con el procesador 32016, que mostr√≥ que, en muchos c√°lculos, 6502 podr√≠a ser la mitad de la frecuencia de operaci√≥n m√°s r√°pido que esto, al parecer, un procesador mucho m√°s potente. Entonces 80286 ya estaba disponible, lo que mostr√≥ un muy buen rendimiento, pero Intel, tal vez percibiendo el potencial bastante peque√±o de la peque√±a empresa Acorn, se neg√≥ a proporcionar su procesador para las pruebas. Al mismo tiempo, la tecnolog√≠a 80286 no se cerr√≥ como 80386 y se transfiri√≥ a muchas empresas, por lo que la historia a√∫n est√° esperando que se revelen los detalles de esta falla algo inusual. Quiz√°s si Intel permitiera usar su procesador, entonces Acorn lo usar√≠a y no comenzar√≠a a desarrollar ARM.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARM fue desarrollado por solo unas pocas personas y prob√≥ el sistema de comando usando BBC Micro BASIC. El desarrollo en s√≠ tuvo lugar en el edificio de la antigua sala de servicios p√∫blicos, que a menudo se llama granero o granero. El debut del procesador result√≥ bastante infructuoso. En 1986, se lanz√≥ un decodificador BBC Micro con el nombre de sistema de evaluaci√≥n ARM, que conten√≠a adem√°s del procesador 4 MB de memoria (esto es mucho para esos a√±os), lo que hizo que este decodificador fuera un producto muy costoso (su precio era de m√°s de ¬£ 4,000, es decir, aproximadamente $ 6,000). Por supuesto, si lo compara con computadoras de esa √©poca con capacidades comparables en velocidad, entonces el prefijo result√≥ ser un orden de magnitud o incluso casi dos m√°s barato. Pero hab√≠a muy pocos programas para el nuevo sistema. Y es un poco extra√±oComo era bastante posible portar Unix a este sistema, entonces estaban disponibles numerosas variantes de Unix que no requer√≠an MMU, hab√≠a variantes de Unix para PDP-11, 68000, 80186 e incluso 8088. Es curioso que en los a√±os 90 Acorn Archimedes fuera portado Linux Quiz√°s la demora con la introducci√≥n de Unix verdadero para ARM fue causada por la renuencia de Acorn a transferir la tecnolog√≠a ARM a otras empresas.</font></font><br><br><img src="http://www.computinghistory.org.uk/userdata/images/large/70/88/product-77088.jpg"><br> <i>    ARM</i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La pol√≠tica de marketing algo fallida de Acorn llev√≥ a la compa√±√≠a a una situaci√≥n financiera muy dif√≠cil para 1985. Acorn, adem√°s de ARM, tambi√©n trat√≥ de llevar a cabo un costoso desarrollo de computadoras para los negocios, que fracas√≥, en particular, debido a las deficiencias del procesador 32016 elegido para ellos. Acorn Communicator tampoco tuvo mucho √©xito. El desarrollo de una computadora Master 512 relativamente exitosa, pero no totalmente compatible con IBM PC fue muy costosa. Adem√°s, se gastaron muchos recursos financieros en un intento fallido de ingresar al mercado de EE. UU., A la compa√±√≠a italiana Olivetti, con sus computadoras bastante exitosas basadas en Intel 8086 y 80286, se le permiti√≥ ingresar en el marco de un hipot√©tico gran juego para hacerse cargo de Acorn. Por cierto, despu√©s de la adquisici√≥n de Bellota,El papel de Olivetti en el mercado estadounidense se desvaneci√≥ r√°pidamente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya como parte de Olivetti Acorn ha desarrollado un chip ARM2 mejorado con comandos de multiplicaci√≥n integrados, sobre la base de la cual se fabric√≥ la computadora personal de Arqu√≠medes, que entonces era incre√≠ble a su velocidad, cuyos primeros modelos estuvieron disponibles en 1987. Sin embargo, el control Olivetti se orient√≥ a trabajar con computadoras compatibles con PC de IBM y No quer√≠a usar sus recursos para vender productos Acorn.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARM proporciona 16 registros de 32 bits para su uso (en realidad, hay m√°s de ellos si tenemos en cuenta los registros para las necesidades del sistema). Uno de los registros, R15, como la arquitectura PDP-11, es un contador de comandos. Casi todas las operaciones se realizan en 1 ciclo. Se necesitan m√°s medidas, en particular, para transiciones, multiplicaciones y accesos a la memoria. En comparaci√≥n, con los principales procesadores de esos a√±os, ARM se distingui√≥ por la ausencia de una estructura tan t√≠pica como la pila. La pila se implementa, si es necesario, a trav√©s de uno de los registros. Cuando se llaman subrutinas, la pila no se usa; en cambio, la direcci√≥n de retorno se almacena en un registro asignado para ella. Tal esquema obviamente no funciona para llamadas anidadas, para las cuales debe organizar una pila. Una caracter√≠stica √∫nica de ARM es la combinaci√≥n de un contador de comandos, que es de 26 bits, es decir, permite direccionar hasta 64 MB con un registro de estado.Se asignan ocho bits para las banderas en este registro combinado, se obtienen dos bits adicionales m√°s en este registro debido al hecho de que los dos bits inferiores de la direcci√≥n no se utilizan, ya que los c√≥digos deben estar alineados en el borde de una palabra de 4 bytes. El procesador puede acceder a bytes y palabras de 4 bytes, no puede acceder directamente a datos de 16 bits. Las instrucciones de datos ARM son de 3 direcciones. Una caracter√≠stica de la arquitectura RISC es el uso de comandos de tipo de memoria de registro solo para cargar y descargar datos. ARM tiene un desplazador de bits r√°pido incorporado (Desplazador de barril), que le permite cambiar el valor de uno de los registros en el comando cualquier cantidad de veces sin el costo de los ciclos de reloj. Por ejemplo, multiplicando el valor del registro R0 por 65 con la colocaci√≥n del resultado en el registro R1 se puede escribir con un comando de adici√≥n de ciclo √∫nicomultiplicando el valor del registro R0 por 65 con la colocaci√≥n del resultado en el registro R1 se puede escribir con un comando de adici√≥n de ciclo √∫nico</font></font><br><br><pre> <code class="plaintext">ADD R1, R0, R0 shl 6</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y multiplicando por 63 con el comando</font></font><br><br><pre> <code class="plaintext">RSB R1, R0, R0 shl 6</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El sistema de comando tiene una resta de retroceso, lo que permite, en particular, tener un menos unario como un caso especial de este comando y acelerar el procedimiento de divisi√≥n. ARM tiene otra caracter√≠stica √∫nica: todas sus instrucciones son condicionales. Hay 16 casos (combinaciones de banderas) que se adjuntan a cada instrucci√≥n. La instrucci√≥n se ejecuta solo si el conjunto actual de banderas coincide con el conjunto en esta instrucci√≥n. En procesadores de otras arquitecturas, dicha ejecuci√≥n tiene lugar, por regla general, solo para transiciones condicionales. Esta caracter√≠stica de ARM permite en muchos casos evitar una operaci√≥n de transici√≥n lenta. Esto √∫ltimo tambi√©n contribuye al hecho de que al realizar operaciones aritm√©ticas, puede negarse a establecer los indicadores de estado. Con ARM, como el procesador 6809, puede usar interrupciones r√°pidas y regulares. Tambi√©nEn los modos de interrupci√≥n, los registros con n√∫meros altos se reemplazan por registros del sistema, lo que hace que los manejadores de interrupciones sean m√°s compactos y r√°pidos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El sistema de instrucci√≥n ARM contiene significativamente menos instrucciones b√°sicas que el sistema de instrucci√≥n del procesador x86. Pero las instrucciones en s√≠ en ARM son muy flexibles y poderosas. Varias instrucciones ARM muy convenientes y potentes no tienen an√°logos para 80386, por ejemplo, RSB (sustracci√≥n inversa), BIC (Y con inversi√≥n, PDP-11 tiene dicho comando), MLA de 4 direcciones (multiplicaci√≥n con suma), LDM y STM ( cargar o descargar m√∫ltiples registros de la memoria, similar al comando MOVEM para procesadores 68k). Casi todas las instrucciones ARM son de 3 direcciones, y casi todas las instrucciones 80386 no tienen m√°s de 2 operandos. El sistema de instrucci√≥n ARM es m√°s ortogonal: todos los registros son intercambiables, solo los registros R14 y R15 hacen alguna excepci√≥n. La mayor√≠a de los comandos ARM pueden requerir 3-4 comandos 80386 para su emulaci√≥n, y la mayor√≠a de los comandos 80386 se pueden emular con 2-3 comandos ARM. Interesanteque el emulador IBM PC XT en el hardware de computadora Acorn Archimedes con un procesador de 8 MHz es a√∫n m√°s r√°pido que una computadora PC XT real. En una computadora Commodore Amiga con un procesador 68000 a 7 MHz, el emulador solo puede funcionar a una velocidad de no m√°s del 10-15% de una PC XT real. Tambi√©n es muy interesante que las primeras computadoras NeXT con 68030 de 25 MHz mostraron el rendimiento de los c√°lculos de enteros al mismo nivel de ARM de 8 MHz. Apple iba a hacer la computadora sucesora de Apple en el proyecto M√∂bius] [, pero cuando result√≥ que el prototipo de esta computadora en modo de emulaci√≥n super√≥ no solo a Apple] [sino tambi√©n a Macintosh basado en procesadores 68k, ¬°el proyecto se cerr√≥!En una computadora Commodore Amiga con un procesador 68000 a 7 MHz, el emulador solo puede funcionar a una velocidad de no m√°s del 10-15% de una PC XT real. Tambi√©n es muy interesante que las primeras computadoras NeXT con 68030 de 25 MHz mostraron el rendimiento de los c√°lculos de enteros al mismo nivel de ARM de 8 MHz. Apple iba a hacer la computadora sucesora de Apple en el proyecto M√∂bius] [, pero cuando result√≥ que el prototipo de esta computadora en modo de emulaci√≥n super√≥ no solo a Apple] [sino tambi√©n a Macintosh basado en procesadores 68k, ¬°el proyecto se cerr√≥!En una computadora Commodore Amiga con un procesador 68000 a 7 MHz, el emulador solo puede funcionar a una velocidad de no m√°s del 10-15% de una PC XT real. Tambi√©n es muy interesante que las primeras computadoras NeXT con 68030 de 25 MHz mostraron el rendimiento de los c√°lculos de enteros al mismo nivel de ARM de 8 MHz. Apple iba a hacer la computadora sucesora de Apple en el proyecto M√∂bius] [, pero cuando result√≥ que el prototipo de esta computadora en modo de emulaci√≥n super√≥ no solo a Apple] [sino tambi√©n a Macintosh basado en procesadores 68k, ¬°el proyecto se cerr√≥!que el prototipo de esta computadora en modo de emulaci√≥n no solo supera a Apple] [, sino tambi√©n a Macintosh basado en procesadores 68k, ¬°el proyecto se cerr√≥!que el prototipo de esta computadora en modo de emulaci√≥n no solo supera a Apple] [, sino tambi√©n a Macintosh basado en procesadores 68k, ¬°el proyecto se cerr√≥!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entre las desventajas de ARM, se puede se√±alar el problema de cargar una constante en un registro. Solo puede cargar 8 bits a la vez, aunque la constante puede invertirse y desplazarse. Por lo tanto, cargar una constante de 32 bits completa puede tomar hasta 4 comandos. Por supuesto, puede cargar la constante desde la memoria con un comando, pero surge el problema de especificar la direcci√≥n de esta cantidad, ya que el desplazamiento solo puede ser de 12 bits. Otra desventaja de ARM es la densidad relativamente baja de c√≥digos, que hace que los programas sean algo m√°s grandes y, lo que es m√°s importante, reduce la eficiencia de la memoria cach√© del procesador. Sin embargo, esto fue probablemente una consecuencia de los compiladores de baja calidad para esta plataforma. Durante mucho tiempo, un inconveniente significativo de ARM fue la falta de soporte integrado para la administraci√≥n de memoria (MMU); Apple, por ejemplo, este soporte fue requerido a principios de los 90.Los coprocesadores para trabajar con n√∫meros reales para la arquitectura ARM tambi√©n comenzaron a usarse con un retraso significativo. ARM no ten√≠a las herramientas de depuraci√≥n avanzadas que ten√≠a x86. Todav√≠a hay algo extra√±o en el lenguaje ensamblador est√°ndar para ARM: es costumbre escribir operaciones de desplazamiento de bits separadas por comas. Por lo tanto, en lugar de una forma simple</font></font><pre> <code class="plaintext">R1 shl 7</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - desplazar el contenido del registro R1 7 bits hacia la izquierda - necesita escribir </font></font><pre> <code class="plaintext">R1, shl 7</code> </pre>  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desde 1989, ARM3 con un cach√© incorporado estuvo disponible. </font><font style="vertical-align: inherit;">En 1990, el equipo de desarrollo de ARM se separ√≥ de Acorn y cre√≥ ARM Holding con Apple y VLSI. </font><font style="vertical-align: inherit;">Una de las razones de la separaci√≥n fue el costo demasiado alto de desarrollar el ARM, seg√∫n la gerencia de Acorn-Olivetti. </font><font style="vertical-align: inherit;">Posteriormente, Acorn ces√≥ su existencia independiente, y ARM Holding se convirti√≥ en una gran empresa. </font><font style="vertical-align: inherit;">La separaci√≥n de Acorn y ARM Holding tambi√©n se inici√≥ por el deseo de Apple de tener un procesador ARM en su computadora Newton y no depender de otro fabricante de computadoras.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°ARM mostr√≥ rendimiento en datos enteros, excediendo 80486 a la misma frecuencia en un 10-20%! </font><font style="vertical-align: inherit;">Intel fue capaz de lograr los beneficios de usar la tecnolog√≠a de multiplicaci√≥n de reloj y luego arreglarlo firmemente con un procesador Pentium. </font><font style="vertical-align: inherit;">DEC StrongARM pudo recuperar el liderazgo por un corto tiempo en 1996, despu√©s de lo cual Intel adquiri√≥ esta tecnolog√≠a, que desde entonces ha sido un importante fabricante de procesadores de arquitectura ARM. </font><font style="vertical-align: inherit;">Por lo tanto, hay dos centros para el desarrollo de esta arquitectura. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El desarrollo adicional de la tecnolog√≠a ARM tambi√©n es muy curioso, pero esa es otra historia. </font><font style="vertical-align: inherit;">Aunque se puede mencionar que fue gracias a una participaci√≥n en ARM Holding que Apple en los a√±os 90 pudo evitar la bancarrota.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algunas conclusiones, supuestos y preguntas. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es dif√≠cil deshacerse de la sensaci√≥n de que los procesadores de 8 bits resultaron ser una necesidad indeseable para los personajes principales que actuaron en los a√±os 70 y 80 en el escenario de la historia de la computadora. El 8-batidor 6502 m√°s exitoso fue congelado. Intel y Motorola ralentizaron su propio desarrollo de peque√±os procesadores y restringieron a otros desarrolladores. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estoy casi seguro de que Amiga o Atari ST funcionar√≠an mejor y m√°s r√°pido en un procesador de 4 MHz con una direcci√≥n de 20 o 24 bits compatible con 6502 que con 68000. Bill Mensch declar√≥ recientemente que 6502 a 10 GHz no es dif√≠cil de hacer hoy. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la serie Amstrad PCW, cuyo √©xito podr√≠a ser compartido por el Commodore CBM II, comenz√≥ a usar z80 optimizado a frecuencias m√°s altas, entonces es muy posible que esta serie sea relevante hace 10 a√±os.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo ser√≠a el mundo si ARM se hiciera en 1982, lo cual era completamente posible? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo ser√≠an las computadoras dom√©sticas si copiaran y desarrollaran no las tecnolog√≠as m√°s caras sino las m√°s prometedoras?</font></font><p></p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es410591/">https://habr.com/ru/post/es410591/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es410581/index.html">El abuso de alcohol es la forma m√°s r√°pida de demencia.</a></li>
<li><a href="../es410583/index.html">Samsung Gear VR: impresiones despu√©s de un mes de uso</a></li>
<li><a href="../es410585/index.html">C√≥mo convertirte en un mago (parte 1)</a></li>
<li><a href="../es410587/index.html">Apple tiene la intenci√≥n de comprar cobalto exclusivamente de compa√±√≠as mineras</a></li>
<li><a href="../es410589/index.html">Ecosistemas marinos capaces de adaptarse al calentamiento global</a></li>
<li><a href="../es410593/index.html">Telegram lleva a cabo otra ronda de ICO</a></li>
<li><a href="../es410597/index.html">Otro dispositivo inteligente para el hogar</a></li>
<li><a href="../es410599/index.html">Una ola de robos de equipos de granjas mineras se extendi√≥ por Islandia</a></li>
<li><a href="../es410601/index.html">¬øQu√© es la rob√≥tica educativa hoy?</a></li>
<li><a href="../es410603/index.html">Manifiesto de propiedad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>