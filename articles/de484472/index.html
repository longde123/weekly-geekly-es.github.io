<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóëÔ∏è üóëÔ∏è ü§∞üèª Verwenden von asyncio zum Erstellen asynchroner Ger√§tetreiber unter MicroPython v.1.12 üöµüèæ ‚ú® üî∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als ich die M√∂glichkeiten von MicroPython f√ºr seine Zwecke studierte, stie√ü ich auf eine der Implementierungen der Asyncio- Bibliothek und nach einer ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden von asyncio zum Erstellen asynchroner Ger√§tetreiber unter MicroPython v.1.12</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484472/"> <i>Als ich die M√∂glichkeiten von <b>MicroPython</b> f√ºr seine Zwecke studierte, stie√ü ich auf eine der Implementierungen der <b>Asyncio-</b> Bibliothek und nach einer kurzen Korrespondenz mit <b>Piter Hinch</b> , dem Autor der Bibliothek, erkannte ich, dass ich die Prinzipien, Grundkonzepte und typischen Fehler bei der Verwendung asynchroner Programmiermethoden besser verstehen musste.</i>  <i>Au√üerdem ist der Abschnitt f√ºr Anf√§nger nur f√ºr mich.</i> <br><br>  Dieses Handbuch richtet sich an Benutzer mit unterschiedlichen Erfahrungen mit <i><b>Asyncio</b></i> , einschlie√ülich eines speziellen Abschnitts f√ºr Anf√§nger. <br><a name="habracut"></a><br>  <b>Inhalt</b> <br>  <b>0. Einleitung</b> <br>  0.1 .___ <i><b>uasyncio</b></i> auf einem leeren Ger√§t (Hardware) installieren <br>  <b>1. Planung f√ºr die gemeinsame Programmausf√ºhrung</b> <br>  1.1 .___ Module <br>  <b>2. <i>Uasyncio-</i> Bibliothek</b> <br>  2.1 .___ Programmstruktur: Ereignisverarbeitungszyklus <br>  2.2 .___ Koroutinen <br>  2.2.1 .______ Einreihen von <i>Coroutinen zur Teilnahme an der Planung</i> <br>  2.2.2 .______ <i>Funktionsr√ºckruf</i> starten <i>( <i>Callback</i> )</i> <br>  2.2.3 .______ <i>Anmerkungen: Koroutinen als verwandte Methoden.</i>  <i>Die R√ºckgabewerte.</i> <br>  2.3 .___ Versp√§tungen <br>  <b>3. Synchronisation und ihre Klassen</b> <br>  3.1 .___ Sperre <i><b>Sperre</b></i> <br>  3.1.1 .______ <i>Sperren und Zeit√ºberschreitungen</i> <br>  3.2 .___ <i><b>Ereignis</b></i> <br>  3.2.1 .______ Ereigniswert <br>  3.3 .___ Barriere <i><b>Barriere</b></i> <br>  3.4 .___ <i><b>Semaphor</b></i> <br>  3.4.1 .______ <i>Limited Semaphore</i> <br>  3.5 .___ Warteschlange <i><b>Warteschlange</b></i> <br>  3.6 .___ Andere Synchronisationsklassen <br>  <b>4. Klassenentwicklung f√ºr <i>Asyncio</i></b> <br>  4.1 .___ Klassen mit wait <br>  4.1.1 .______ <i>Verwendung in Kontextmanagern</i> <br>  4.1.2 .______ <i>In der Coroutine</i> warten <br>  4.2 .___ Asynchrone Iteratoren <br>  4.3 .___ Asynchrone Kontextmanager <br>  <b>5. Ausnahmen zu Zeit√ºberschreitungen und aufgrund von Aufgabenstornierungen</b> <br>  5.1 .___ Ausnahmen <br>  5.2 .___ Ausnahmen aufgrund von Timeouts und aufgrund von Abbr√ºchen von Aufgaben <br>  5.2.1 .______ <i>Aufgaben</i> abbrechen <br>  5.2.2 .______ <i>Koroutinen mit Timeouts</i> <br>  <b>6. Interaktion mit Hardwareger√§ten</b> <br>  6.1 .___ Synchronisierungsprobleme <br>  6.2 .___ Abfragen von Ger√§ten mit Coroutinen <br>  6.3 .___ Verwenden der Streaming-Engine <br>  6.3.1 .______ <i>UART-</i> Treiberbeispiel <br>  6.4 .___ Treiberentwicklung f√ºr ein Streaming-Ger√§t <br>  6.5 .___ Vollst√§ndiges Beispiel: <i>aremote.py</i> Treiber f√ºr IR-Fernbedienungsempf√§nger. <br>  6.6 .___ Treiber f√ºr Temperatur- und Feuchtigkeitssensor HTU21D. <br>  <b>7. Tipps und Tricks</b> <br>  7.1 .___ Programm friert ein <br>  7.2 .___ <b><i>uasyncio</i></b> speichert den Zustand <br>  7.3 .___ Speicherbereinigung <br>  7.4 .___ Testen <br>  7.5 .___ H√§ufiger Fehler.  Es kann schwer zu finden sein. <br>  7.6 .___ Programmieren mit Sockets ( <i>Sockets</i> ) <br>  7.6.1 .______ <i>WLAN-Probleme</i> <br>  7.7 .___ Argumente des Event-Loop-Konstruktors <br>  <b>8. Hinweise f√ºr Anf√§nger</b> <br>  8.1 .___ Problem 1: Ereignisschleifen <br>  8.2 .___ Problem 2: Sperrmethoden <br>  8.3 .___ Der <b><i>Uasyncio-</i></b> Ansatz <br>  8.4 .___ Planung in <b><i>uasyncio</i></b> <br>  8.5 .___ Warum kollaboratives, nicht threadbasiertes Scheduling ( <i>_thread</i> )? <br>  8.6 .___ Interaktion <br>  8.7 .___ <i>Polling</i> <br><br>  <b>0. Einleitung</b> <br><br>  Der gr√∂√üte Teil dieses Dokuments setzt eine gewisse Vertrautheit mit der asynchronen Programmierung voraus.  F√ºr Anf√§nger finden Sie eine Einf√ºhrung in Abschnitt 7. <br><br>  Die <i><b>uasyncio-</b></i> Bibliothek f√ºr <b>MicroPython</b> enth√§lt eine Teilmenge der <b><i>asyncio-</i></b> <b>Python-</b> Bibliothek und ist f√ºr die Verwendung auf Mikrocontrollern vorgesehen.  Daher nimmt es nur wenig RAM ein und ist so konfiguriert, dass Kontexte ohne RAM-Zuweisung schnell umgeschaltet werden. <br><br>  In diesem Dokument wird die Verwendung von <i><b>uasyncio beschrieben,</b></i> wobei der Schwerpunkt auf der Erstellung von Treibern f√ºr Hardwareger√§te liegt. <br><br>  Ziel ist es, die Treiber so zu gestalten, dass die Anwendung weiterhin funktioniert, w√§hrend der Treiber auf eine Antwort vom Ger√§t wartet.  Gleichzeitig reagiert die Anwendung empfindlich auf andere Ereignisse und Benutzerinteraktionen. <br><br>  Ein weiteres wichtiges Einsatzgebiet von <b><i>asyncio</i></b> ist die Netzwerkprogrammierung: Im Internet finden Sie gen√ºgend Informationen zu diesem Thema. <br><br>  Beachten Sie, dass <b>MicroPython</b> auf <b>Python 3.4</b> mit den minimalen <b>Python 3.5-</b> Add-Ons basiert.  Funktionen von <b><i>Asyncio-</i></b> Versionen, die √§lter als 3.4 sind, werden nicht unterst√ºtzt, es sei denn, dies wird im <b><i>Folgenden beschrieben</i></b> .  In diesem Dokument werden die Funktionen definiert, die in dieser Untergruppe unterst√ºtzt werden. <br><br>  In diesem Handbuch wird ein Programmierstil vorgestellt, der mit <b>CPython V3.5</b> und h√∂her kompatibel ist. <br><br>  <b>0.1 Installieren Sie <b><i>uasyncio</i></b> auf einem leeren Ger√§t (Hardware)</b> <br><br>  Es wird empfohlen, die Firmware <b>MicroPython V1.11</b> oder h√∂her zu verwenden.  Auf vielen Plattformen ist keine Installation erforderlich, da <b><i>uasyncio¬Æ</i></b> bereits in der Assembly kompiliert ist.  Um dies zu √ºberpr√ºfen, geben Sie einfach REPL ein <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio</code> </pre> <br>  Die folgenden Anweisungen decken F√§lle ab, in denen die Module nicht vorinstalliert sind.  Die <b><i>Warteschlangen</i></b> und <b><i>Synchronisationsmodule</i></b> sind optional, werden jedoch ben√∂tigt, um die hier angegebenen Beispiele auszuf√ºhren. <br><br>  <b>Ger√§t mit Internetverbindung</b> <br><br>  Auf einem mit dem Internet verbundenen Ger√§t, auf dem Firmware V1.11 oder h√∂her ausgef√ºhrt wird, k√∂nnen Sie mit der integrierten <i>Upip-</i> Version installieren.  Stellen Sie sicher, dass das Ger√§t mit Ihrem Netzwerk verbunden ist: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> upip upip.install ( <span class="hljs-string"><span class="hljs-string">'micropython-uasyncio'</span></span> ) upip.install ( <span class="hljs-string"><span class="hljs-string">'micropython-uasyncio.synchro'</span></span> ) upip.install ( <span class="hljs-string"><span class="hljs-string">'micropython-uasyncio.queues'</span></span> )</code> </pre><br>  Die Fehlermeldungen von <i>upip sind</i> nicht sehr n√ºtzlich.  Wenn Sie einen unverst√§ndlichen Fehler erhalten, √ºberpr√ºfen Sie die Internetverbindung erneut. <br><br>  <b>Hardware ohne Internetverbindung ( <i>Micropip</i> )</b> <br><br>  Wenn Ihr Ger√§t nicht √ºber eine Internetverbindung verf√ºgt (z. B. <b>Pyboard V1.x</b> ), <b>starten Sie</b> am einfachsten die Installation von <i>micropip.py</i> auf dem Computer in das Verzeichnis Ihrer Wahl und kopieren Sie die resultierende Verzeichnisstruktur auf das Zielger√§t.  Das Dienstprogramm <i>micropip.py</i> l√§uft unter <b>Python 3.2</b> oder h√∂her und unter Linux, Windows und OSX.  Weitere Informationen finden Sie <a href="https://github.com/peterhinch/micropython-samples/tree/master/micropip" rel="nofollow">hier</a> . <br><br>  Typischer Anruf: <br><br><pre> <code class="python hljs">$ micropip.py install -p ~/rats micropython-uasyncio $ micropip.py install -p ~/rats micropython-uasyncio.synchro $ micropip.py install -p ~/rats micropython-uasyncio.queues</code> </pre><br>  <b>Ein Ger√§t ohne Internetverbindung (Kopierquelle)</b> <br><br>  Wenn Sie <i>micropip.py</i> nicht verwenden, m√ºssen die Dateien von der Quelle kopiert werden.  In den folgenden Anweisungen wird beschrieben, wie die Mindestanzahl von Dateien auf das Zielger√§t <b><i>kopiert wird. Au√üerdem wird</i></b> der Fall beschrieben, in dem <b><i>uasyncio</i></b> in Form eines Bytecodes in eine kompilierte Assembly komprimiert werden muss, um den belegten Speicherplatz zu verringern.  F√ºr die neueste Version, die mit der offiziellen Firmware kompatibel ist, m√ºssen die Dateien von der offiziellen <a href="http://github.com/micropython/micropython-lib" rel="nofollow">Micropython-Lib-</a> Website kopiert werden. <br><br>  Klonen Sie die Bibliothek mit dem Befehl auf den Computer <br><br><pre> <code class="python hljs">$ git clone https://github.com/micropython/micropython-lib.git</code> </pre><br>  Erstellen Sie auf dem <b><i>Zielger√§t das</i></b> Verzeichnis <b><i>uasyncio</i></b> (optional im Verzeichnis lib) und kopieren Sie die folgenden Dateien hinein: <br><br>  <b>‚Ä¢ uasyncio / uasyncio / __ init__.py</b> <b><br></b>  <b>‚Ä¢ uasyncio.core / uasyncio / core.py</b> <b><br></b>  <b>‚Ä¢ uasyncio.synchro / uasyncio / synchro.py</b> <b><br></b>  <b>‚Ä¢ uasyncio.queues / uasyncio / queues.py</b> <b><br></b> <br><br>  Diese <b><i>uasyncio-</i></b> Module k√∂nnen zu Bytecode komprimiert werden, indem das Verzeichnis <b><i>uasyncio</i></b> und sein Inhalt in den Port des Verzeichnisses <i>modules gestellt</i> und der Inhalt neu kompiliert wird. <br><br>  <b>1. Gemeinsame Planung</b> <br><br>  Die Technik der gemeinsamen Ausf√ºhrung mehrerer Tasks ist in eingebetteten Systemen weit verbreitet und bietet weniger Overhead als die <b>Thread-</b> Planung ( <b>_thread</b> ), wodurch viele Fallstricke vermieden werden, die mit wirklich asynchronen Threads verbunden sind. <br><br>  <b>1.1 Module</b> <br><br>  Im Folgenden finden Sie eine Liste der Module, die auf dem Zielger√§t ausgef√ºhrt werden k√∂nnen. <br><br>  <b><u>Bibliotheken</u></b> <br><br>  1. <b><i>asyn.py</i></b> Stellt <i><b>Sperre, Ereignis, Barriere, Semaphor, BoundedSemaphor, Bedingung und Sammelsynchronisationsprimitive bereit</b></i> .  Bietet Unterst√ºtzung f√ºr das Abbrechen von Aufgaben √ºber die Klassen <i><b>NamedTask</b></i> und <i><b>Cancellable</b></i> . <br><br>  2. <b><i>aswitch.py</i></b> Repr√§sentiert Klassen zum <b><i>Koppeln von</i></b> Schaltern und Tasten sowie ein Programmobjekt mit der M√∂glichkeit einer wiederholten Verz√∂gerung.  Tasten sind eine Verallgemeinerung von Schaltern, die eher einen logischen als einen physischen Zustand bereitstellen, sowie von Ereignissen, die durch zweimaliges und langes Dr√ºcken ausgel√∂st werden. <br><br>  <b>Demo-Programme</b> <br><br>  Die ersten beiden sind am n√ºtzlichsten, da sie beim Zugriff auf die <b>Pyboard-Hardware</b> sichtbare Ergebnisse <b>liefern</b> . <br><br><ol><li>  <b><i>aledflash.py Blinkt</i></b> vier <b>Pyboard-</b> Anzeigen 10 Sekunden <b>lang</b> asynchron.  Die einfachste Demonstration von <b>Uasyncio</b> .  Importieren Sie es zum Ausf√ºhren. </li><li>  <b><i>apoll.py Ger√§tetreiber</i></b> f√ºr den <b>Pyboard-</b> Beschleunigungssensor.  Veranschaulicht die Verwendung von Coroutinen zum Abfragen eines Ger√§ts.  Funktioniert f√ºr 20 s.  Importieren Sie es zum Ausf√ºhren.  Ben√∂tigt <b>Pyboard V1.x.</b> </li><li>  <b><i>astests.py</i></b> Test- / Demoprogramme f√ºr das <b><i>Aswitch-</i></b> Modul. </li><li>  <b><i>asyn_demos.py</i></b> Einfache Demos zum Abbrechen von Aufgaben. </li><li>  <b><i>roundrobin.py</i></b> Demonstration der <b><i>Kreisplanung</i></b> .  Auch der Ma√üstab f√ºr die Leistungsplanung. </li><li>  <b><i>awaitable.py</i></b> Demonstration einer Klasse mit einer Wartezeit.  Eine M√∂glichkeit, einen Ger√§tetreiber zu implementieren, der eine Schnittstelle abfragt. </li><li>  <b><i>chain.py</i></b> Kopiert aus der <b>Python-</b> Dokumentation.  Demonstration der Coroutine-Kette. </li><li>  <b><i>aqtest.py</i></b> Demonstration der <b><i>Queue-</i></b> Klasse der <i><b>uasyncio-</b></i> Bibliothek. </li><li>  <b><i>aremote.py</i></b> Beispielger√§tetreiber f√ºr das NEC-IR-Protokoll. </li><li>  <b><i>auart.py</i></b> Demonstration von Streaming Input-Output √ºber <b>Pyboard UART</b> . </li><li>  <b><i>auart_hd.py</i></b> Verwenden von <b>Pyboard UART</b> zur Kommunikation mit einem Ger√§t unter Verwendung des Halbduplex-Protokolls.  Geeignet f√ºr Ger√§te, die beispielsweise den Befehlssatz AT-Modem verwenden. </li><li>  <b><i>iorw.py</i></b> Demonstration eines Lese- / <b><i>Schreibger√§ts</i></b> mit Streaming-E / <b><i>A.</i></b> </li></ol><br>  <b>Testprogramme</b> <br><br><ol><li>  <b><i>asyntest.py Pr√ºft</i></b> auf Synchronisationsklassen in <b><i>asyn.py.</i></b> </li><li>  <b><i>cantest.py Abbruchtests</i></b> . </li></ol><br>  <b>Dienstprogramm</b> <br><br>  1. <b><i>check_async_code.py</i></b> Das Dienstprogramm wurde in <b>Python3 geschrieben</b> , um bestimmte Codierungsfehler zu erkennen, die m√∂glicherweise schwer zu finden sind.  Siehe Abschnitt 7.5. <br><br>  <b>Kontrolle</b> <br><br>  Das <a href="" rel="nofollow"><i>Benchmark-</i></a> Verzeichnis enth√§lt Skripte zur √úberpr√ºfung und Charakterisierung des <i><b>uasyncio-Schedulers</b></i> . <br><br><cut></cut><br>  <b>2. <i>Uasyncio-</i> Bibliothek</b> <br><br>  Das <i>asyncio-</i> Konzept basiert auf der Organisation der Planung f√ºr die gemeinsame Ausf√ºhrung mehrerer Aufgaben, die in diesem Dokument als <b>Coroutinen bezeichnet werden</b> . <br><br>  <b>2.1 Programmstruktur: Ereignisschleife</b> <br><br>  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> : count + = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> ( count ) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep ( <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-comment"><span class="hljs-comment">#  1 loop = asyncio.get_event_loop () loop.create_task ( bar ()) #     loop.run_forever ()</span></span></code> </pre><br>  Die Programmausf√ºhrung wird fortgesetzt, bis <i>loop.run_forever aufgerufen wird</i> .  Zu diesem Zeitpunkt wird die Ausf√ºhrung vom Scheduler gesteuert.  Die Zeile nach <i>loop.run_forever</i> wird niemals ausgef√ºhrt.  Der Scheduler f√ºhrt den <i>Barcode aus</i> , da er im <i>Scheduler loop.create_task</i> in die <i>Warteschlange gestellt wurde</i> .  In diesem einfachen Beispiel gibt es nur einen Koroutinenstab.  Wenn es andere g√§be, w√ºrde der Scheduler sie in Zeitr√§umen ausf√ºhren, in denen die <i>Leiste</i> angehalten wurde. <br><br>  Die meisten eingebetteten Anwendungen verf√ºgen √ºber eine kontinuierliche Ereignisschleife.  Eine Ereignisschleife kann auch so gestartet werden, dass sie mit der Ereignisschleifenmethode <i>run_until_complete abgeschlossen</i> werden kann.  Es wird haupts√§chlich zum Testen verwendet.  Beispiele finden Sie im <a href="https://github.com/peterhinch/micropython-async/blob/master/astests.py" rel="nofollow"><b><i>astests.py-</i></b></a> Modul. <br><br>  Eine Ereignisschleifeninstanz ist ein einzelnes Objekt, das durch den ersten Aufruf von <i>asyncio.get_event_loop ()</i> mit zwei optionalen Ganzzahlargumenten erstellt wird, die die Anzahl der Coroutinen in den beiden Warteschlangen angeben - Start und Warten.  In der Regel haben beide Argumente den gleichen Wert, der mindestens der Anzahl der gleichzeitig ausgef√ºhrten Coroutinen in der Anwendung entspricht.  In der Regel ist der Standardwert 16 ausreichend.Wenn nicht-Standardwerte verwendet werden, lesen Sie Argumente des Konstruktors f√ºr Ereignisschleifen (Abschnitt 7.7.). <br><br>  Wenn die Coroutine die Ereignisschleifenmethode aufrufen <i>muss (</i> normalerweise <i>create_task</i> ), wird sie durch Aufrufen von <i>asyncio.get_event_loop ()</i> (ohne Argumente) zur√ºckgegeben. <br><br>  <b>2.2 Koroutinen</b> <br><br>  Eine Coroutine wird wie folgt erstellt: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( delay_secs )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep ( delay_secs ) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> ( <span class="hljs-string"><span class="hljs-string">'Hello'</span></span> )</code> </pre><br>  Mit einer Coroutine k√∂nnen andere Coroutinen mit der Anweisung <i>await</i> gestartet werden.  Eine Coroutine muss mindestens eine <i>wait-</i> Anweisung enthalten.  Dies bewirkt, dass die Coroutine vor dem Abschluss ausgef√ºhrt wird, bevor die Ausf√ºhrung mit der n√§chsten Anweisung fortgesetzt wird.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep ( delay_secs ) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep ( <span class="hljs-number"><span class="hljs-number">0</span></span> )</code> </pre><br>  In der ersten Zeile wird der Code f√ºr eine Verz√∂gerungszeit angehalten, w√§hrend andere Coroutinen diese Zeit f√ºr ihre Ausf√ºhrung verwenden.  Eine Verz√∂gerung von 0 bewirkt, dass alle anstehenden Coroutinen in einer zyklischen Reihenfolge ausgef√ºhrt werden, bis die n√§chste Zeile ausgef√ºhrt wird.  Siehe das Beispiel von <i><b>roundrobin.py</b></i> . <br><br>  <b>2.2.1.</b>  <b>Warteschlange f√ºr die Planung einer Coroutine</b> <br><br><ul><li>  <i>EventLoop.create_task</i> Argument: Auszuf√ºhrende Coroutine.  Der Scheduler stellt die Coroutine in eine Warteschlange, damit sie so schnell wie m√∂glich startet.  Der Aufruf von create_task wird sofort zur√ºckgegeben.  Die Koroutine im Argument wird in der Syntax des Funktionsaufrufs mit den erforderlichen Argumenten angegeben. </li><li>  <i>EventLoop.run_until_complete</i> Argument: Auszuf√ºhrende Coroutine.  Der Scheduler stellt die Coroutine in eine Warteschlange, damit sie so schnell wie m√∂glich startet.  Die Koroutine im Argument wird in der Syntax des Funktionsaufrufs mit den erforderlichen Argumenten angegeben.  Der Aufruf <i>un_until_complete gibt</i> zur√ºck, wenn die Coroutine abgeschlossen ist: Diese Methode bietet eine M√∂glichkeit, den Scheduler zu beenden. </li><li>  <i>wait</i> Argument: Eine auszuf√ºhrende Coroutine, die mithilfe der Funktionsaufrufsyntax angegeben wird.  Startet so schnell wie m√∂glich eine Coroutine.  Die anstehende Coroutine wird blockiert, bis eine der erwarteten Coroutinen abgeschlossen ist. </li></ul><br>  Das obige ist mit <b>CPython</b> kompatibel.  Weitere <b><i>Uasyncio-</i></b> Methoden <b><i>werden</i></b> im Anhang (Abschnitt 2.2.3.) Erl√§utert. <br><br>  <b>2.2.2 R√ºckruffunktion starten</b> <br><br>  R√ºckrufe sollten <b>Python-</b> Funktionen sein, die so konzipiert sind, dass sie in kurzer Zeit ausgef√ºhrt werden.  Dies liegt an der Tatsache, dass Coroutinen nicht f√ºr die gesamte Dauer der Ausf√ºhrung einer solchen Funktion arbeiten k√∂nnen. <br><br>  Die folgenden <b><i>EventLoop-</i></b> Klassenmethoden verwenden R√ºckrufe: <br><br><ol><li>  <i>call_soon</i> - ruf so schnell wie m√∂glich an.  Argumente: <i>R√ºckruf</i> R√ºckruf, um auszuf√ºhren, <i>*</i> Argumente, auf die Positionsargumente m√∂glicherweise ein Komma folgt. </li><li>  <i>call_later</i> - ruft nach einer Verz√∂gerung in Sekunden an.  Argumente: <i>Verz√∂gerung, R√ºckruf, * Argumente</i> </li><li>  <i>call_later_ms</i> - ruft nach einer Verz√∂gerung in ms auf.  Argumente: <i>Verz√∂gerung, R√ºckruf, * Argumente</i> . </li></ol><br><pre> <code class="python hljs">loop = asyncio.get_event_loop () loop.call_soon ( foo , <span class="hljs-number"><span class="hljs-number">5</span></span> ) <span class="hljs-comment"><span class="hljs-comment">#    'foo'      5. loop.call_later ( 2 , foo , 5 ) #   2 . loop.call_later_ms ( 50 , foo , 5 ) #   50 . loop.run_forever ()</span></span></code> </pre><br>  <b>2.2.3 Hinweise</b> <br><br>  Eine Coroutine kann eine <i>return-</i> Anweisung mit beliebigen R√ºckgabewerten enthalten.  So erhalten Sie diesen Wert: <br><br><pre> <code class="python hljs">result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> my_coro ()</code> </pre><br>  Eine Coroutine kann durch Methoden begrenzt werden und muss mindestens eine <i>wait-</i> Anweisung enthalten. <br><br>  <b>2.3 Versp√§tungen</b> <br><br>  Es gibt zwei M√∂glichkeiten, Verz√∂gerungen in Coroutinen zu organisieren.  F√ºr l√§ngere Verz√∂gerungen und in F√§llen, in denen die Dauer nicht genau sein muss, k√∂nnen Sie Folgendes verwenden: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( delay_secs , delay_ms )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep ( delay_secs ) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> ( <span class="hljs-string"><span class="hljs-string">'Hello'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep_ms ( delay_ms )</code> </pre><br>  W√§hrend solcher Verz√∂gerungen f√ºhrt der Scheduler andere Coroutinen aus.  Dies kann zu zeitlicher Unsicherheit f√ºhren, da die aufrufende Coroutine nur gestartet wird, wenn die gerade laufende ausgef√ºhrt wird.  Die Verz√∂gerungszeit h√§ngt vom Anwendungsentwickler ab, liegt jedoch wahrscheinlich in der Gr√∂√üenordnung von zehn oder hundert ms.  Dies wird im Abschnitt Interaktion mit Hardwareger√§ten (Abschnitt 6) n√§her erl√§utert. <br><br>  Mit den <i>utime-</i> Funktionen <i>sleep_ms</i> und <i>sleep_us</i> k√∂nnen sehr genaue Verz√∂gerungen durchgef√ºhrt werden.  Sie eignen sich am besten f√ºr kurze Verz√∂gerungen, da der Scheduler w√§hrend der Verz√∂gerung keine anderen Coroutinen ausf√ºhren kann. <br><br>  <b>3.Sync</b> <br><br>  Oft muss die Synchronisation zwischen den Koroutinen sichergestellt werden.  Ein h√§ufiges Beispiel ist die Vermeidung der sogenannten "Race Conditions", wenn mehrere Coroutinen gleichzeitig Zugriff auf dieselbe Ressource ben√∂tigen.  Ein Beispiel ist in <b><i>astests.py enthalten</i></b> und wird in der <a href="" rel="nofollow">Dokumentation</a> erl√§utert.  Eine weitere Gefahr sind ‚ÄûTodesumarmungen‚Äú, wenn jede Koroutine darauf wartet, dass die andere abgeschlossen ist. <br><br>  In einfachen Anwendungen kann die Synchronisierung mithilfe globaler Flags oder verwandter Variablen erfolgen.  Ein eleganterer Ansatz ist die Verwendung von Synchronisationsklassen.  Das Modul <b><i>asyn.py</i></b> bietet Mikroimplementierungen der Klassen <i><b>Event, Barrier, Semaphore</b></i> und <i><b>Conditios</b></i> , die nur f√ºr die Verwendung mit <b><i>asyncio vorgesehen sind</i></b> .  Sie sind nicht <b><i>threadorientiert</i></b> und sollten nicht mit dem <b><i>_thread-</i></b> Modul oder dem Interrupt-Handler verwendet werden, sofern nicht anders angegeben.  Die <i><b>Lock-</b></i> Klasse ist ebenfalls implementiert, was eine Alternative zur offiziellen Implementierung darstellt. <br><br>  Ein weiteres Synchronisationsproblem tritt bei Coroutine-Produzenten und Coroutine-Konsumenten auf.  Ein Coroutine-Produzent generiert Daten, die ein Coroutine-Konsument verwendet.  Zu diesem <b><i>Zweck</i></b> stellt <b><i>asyncio</i></b> die <i><b>Queue-</b></i> Klasse bereit.  Der Coroutine-Produzent stellt die Daten in die Warteschlange, w√§hrend der Coroutine-Consumer auf die Fertigstellung wartet (wobei andere Operationen p√ºnktlich geplant sind).  Die <i><b>Queue-</b></i> Klasse bietet Garantien zum Entfernen von Elementen in der Reihenfolge, in der sie empfangen wurden.  Alternativ k√∂nnen Sie die <i><b>Barrier-</b></i> Klasse verwenden, wenn die Producer-Coroutine warten muss, bis die Consumer-Coroutine bereit ist, auf die Daten zuzugreifen. <br><br>  Eine kurze √úbersicht √ºber die Klassen finden Sie weiter unten.  Weitere Details finden Sie in der <a href="" rel="nofollow">vollst√§ndigen Dokumentation</a> . <br><br>  <b>3.1 <a href="" rel="nofollow"><i>Sperre</i></a></b> <br><br>  <i><b>Lock</b></i> garantiert einen eindeutigen Zugriff auf eine gemeinsam genutzte Ressource.  Im folgenden Codebeispiel wird eine Instanz der <i>Sperrklasse</i> <b><i>Lock erstellt</i></b> , die an alle Clients √ºbergeben wird, die auf die freigegebene Ressource zugreifen m√∂chten.  Jede Coroutine versucht, die Sperre zu erfassen und h√§lt die Ausf√ºhrung an, bis sie erfolgreich ist: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> uasyncio.synchro <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Lock <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, lock)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> lock.acquire() print(<span class="hljs-string"><span class="hljs-string">"Acquired lock in task"</span></span>, i) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) lock.release() <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">killer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">10</span></span>) loop = asyncio.get_event_loop() lock = Lock() <span class="hljs-comment"><span class="hljs-comment"># The global Lock instance loop.create_task(task(1, lock)) loop.create_task(task(2, lock)) loop.create_task(task(3, lock)) loop.run_until_complete(killer()) #  10s</span></span></code> </pre><br>  <b>3.1.1.Lock und Timeouts</b> <br><br>  Zum Zeitpunkt des Schreibens (5. Januar 2018) ist die Entwicklung der Klasse <i><b>uasycio</b></i> <i>Lock</i> noch nicht offiziell abgeschlossen.  Wenn die Coroutine eine <u>Zeit√ºberschreitung aufweist (Abschnitt 5.2.2.)</u> , Ist die Zeit√ºberschreitung unwirksam, wenn auf eine Sperre gewartet wird, wenn diese ausgel√∂st wird.  Es wird kein <i>TimeoutError</i> empfangen, bis es eine Sperre erh√§lt.  Gleiches gilt f√ºr das Abbrechen einer Aufgabe. <br><br>  Das <b><i>asyn.py-</i></b> Modul bietet die <a href="" rel="nofollow"><b><i>Lock-</i></b></a> Klasse, die in diesen Situationen funktioniert.  Diese Implementierung der Klasse ist weniger effizient als die offizielle Klasse, unterst√ºtzt jedoch zus√§tzliche Schnittstellen gem√§√ü der <b>CPython-</b> Version, einschlie√ülich der Verwendung des Kontextmanagers. <br><br>  <b>3.2 Ereignis</b> <br><br>  <b><i>Das Ereignis gibt</i></b> einer oder mehreren Koroutinen die M√∂glichkeit, eine Pause einzulegen, w√§hrend eine andere ein Signal f√ºr ihre Fortsetzung gibt.  Eine Instanz von <b>Event</b> wird f√ºr alle Coroutinen verf√ºgbar, die es verwenden: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyn event = asyn.Event ()</code> </pre><br>  Eine Coroutine wartet auf ein Ereignis, indem sie ein <i>Warteereignis</i> deklariert. <i>Danach wird</i> die Ausf√ºhrung unterbrochen, bis andere Coroutinen <i>event.set ()</i> deklarieren.  <a href="" rel="nofollow">Vollst√§ndige Informationen</a> . <br><br>  Ein Problem kann auftreten, wenn <i>event.set ()</i> in einem Schleifenkonstrukt ausgegeben wird.  Der Code muss warten, bis alle ausstehenden Objekte Zugriff auf das Ereignis haben, bevor er erneut festgelegt wird.  Wenn ein <b>Coro</b> ein Ereignis erwartet, kann dies erreicht werden, indem ein <b>Coro-</b> Ereignis empfangen wird, das das Ereignis <b>l√∂scht</b> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eventwait</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( event )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> event event.clear()</code> </pre><br>  Die Coroutine, die das Ereignis ausl√∂st, √ºberpr√ºft, ob es gewartet wurde: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( event )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> : <span class="hljs-comment"><span class="hljs-comment">#   - while event.is_set (): await asyncio.sleep ( 1 ) # ,  coro   event.set ()</span></span></code> </pre><br>  Wenn mehrere <b>Coros</b> auf die Synchronisation eines Ereignisses warten, kann das Problem mit dem Best√§tigungsereignis behoben werden.  Jeder <b>Coro</b> ben√∂tigt ein eigenes Event. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eventwait</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(  , ack_event )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> event ack_event.set ()</code> </pre><br>  Ein Beispiel hierf√ºr finden Sie in der Funktion <i><b>event_test</b></i> in der <i>Datei</i> <i><b>asyntest.py</b></i> .  Dies ist in den meisten F√§llen umst√§ndlich. Selbst bei einem wartenden <b>Coro</b> bietet die unten dargestellte <b>Barrier-</b> Klasse einen einfacheren Ansatz. <br>  Ein Ereignis kann auch ein Kommunikationsmittel zwischen dem Interrupt-Handler und <b>coro darstellen</b> .  Der Handler wartet die Hardware und setzt das Ereignis, das von <b>coro</b> bereits im normalen Modus gepr√ºft wird. <br><br>  <b>3.2.1 Ereigniswerte</b> <br><br>  Die <i>event.set ()</i> -Methode kann einen optionalen Datenwert eines beliebigen Typs annehmen.  <b>Coro</b> wartet auf ein Ereignis und kann es mit <i>event.value () abrufen</i> .  Beachten Sie, dass <i>event.clear ()</i> auf <i>None gesetzt wird</i> .  Eine typische Verwendung f√ºr die <i>Coro-</i> Einstellung des Ereignisses ist die Ausgabe von <i>event.set (utime.ticks_ms ())</i> .  Jeder <b>Coro, der</b> auf ein Ereignis wartet, kann die aufgetretene Verz√∂gerung ermitteln, um dies beispielsweise zu kompensieren. <br><br>  <b>3.3 <a href="" rel="nofollow"><i>Barriere</i></a></b> <br><br>  F√ºr die <b><i>Barrier-</i></b> Klasse gibt es zwei Verwendungszwecke. <br><br>  Erstens kann eine Coroutine ausgesetzt werden, bis eine oder mehrere andere Coroutinen abgeschlossen sind. <br><br>  Zweitens k√∂nnen sich mehrere Koroutinen an einem bestimmten Punkt treffen.  Beispielsweise k√∂nnen ein Produzent und ein Konsument an dem Punkt synchronisieren, an dem der Produzent √ºber Daten verf√ºgt, und der Konsument ist bereit, diese zu verwenden.  Zum Zeitpunkt der Ausf√ºhrung kann die <b>Barriere</b> einen zus√§tzlichen R√ºckruf ausgeben, bevor die Barriere entfernt wird, und alle anstehenden Ereignisse k√∂nnen fortgesetzt werden. <br><br>  Der R√ºckruf kann eine Funktion oder eine Coroutine sein.  In den meisten Anwendungen wird die Funktion h√∂chstwahrscheinlich verwendet: Es kann garantiert werden, dass sie vor Abschluss ausgef√ºhrt wird, bevor die Barriere entfernt wird. <br><br>  Ein Beispiel ist die Funktion <i><b>barrier_test</b></i> in <i><b>asyntest.py</b></i> .  Im Code-Snippet dieses Programms: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyn <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(text)</span></span></span><span class="hljs-function">:</span></span> print(text) barrier = asyn.Barrier(<span class="hljs-number"><span class="hljs-number">3</span></span>, callback, (<span class="hljs-string"><span class="hljs-string">'Synch'</span></span>,)) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>): print(<span class="hljs-string"><span class="hljs-string">'{} '</span></span>.format(i), end=<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> barrier</code> </pre> <br>  Mehrere Instanzen der <i>Berichtskoroutine</i> drucken ihr Ergebnis und halten an, bis auch andere Instanzen abgeschlossen sind, und warten, bis die <b>Barriere</b> fortgesetzt wird.  An dieser Stelle wird ein R√ºckruf durchgef√ºhrt.  Nach Fertigstellung wird die urspr√ºngliche Coroutine fortgesetzt. <br><br>  <b>3.4 Semaphor</b> <br><br>  Das Semaphor begrenzt die Anzahl der Coroutinen, die auf die Ressource zugreifen k√∂nnen.  Es kann verwendet werden, um die Anzahl der Instanzen einer bestimmten Coroutine zu begrenzen, die gleichzeitig ausgef√ºhrt werden k√∂nnen.  Dies geschieht mit einem Zugriffsz√§hler, der vom Konstruktor initialisiert und jedes Mal reduziert wird, wenn die Coroutine ein Semaphor empf√§ngt. <br><br>  Der einfachste Weg, es in einem Kontextmanager zu verwenden: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyn sema = asyn.Semaphore(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sema)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> sema: <span class="hljs-comment"><span class="hljs-comment">#   </span></span></code> </pre><br>  Ein Beispiel ist die Funktion <i><b>semaphore_test</b></i> in <i><b>asyntest.py</b></i> . <br><br>  <b>3.4.1 ( <a href="" rel="nofollow"><i>Eingeschr√§nktes</i></a> ) Semaphor</b> <br><br>  Es funktioniert √§hnlich wie die <i><b>Semaphore-</b></i> Klasse, au√üer dass ein <i>ValueError gesetzt wird</i> , wenn die <i>release-</i> Methode bewirkt, dass der Zugriffsz√§hler seinen Anfangswert √ºberschreitet. <br><br>  <b>3.5 Warteschlange</b> <br><br>  Die <i><b>Queue-</b></i> Klasse wird vom offiziellen <i><b>uasycio verwaltet</b></i> und das Beispielprogramm <i><b>aqtest.py</b></i> demonstriert seine Verwendung.  Die Warteschlange wird wie folgt erstellt: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> uasyncio.queues <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Queue q = Queue ()</code> </pre><br>  Eine typische Hersteller-Coroutine kann wie folgt arbeiten: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">producer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(q)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> slow_process() <span class="hljs-comment"><span class="hljs-comment">#       await q.put(result) #  ,       </span></span></code> </pre><br>  und die Consumer Coroutine kann wie folgt arbeiten: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consumer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(q)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span>(q.get()) <span class="hljs-comment"><span class="hljs-comment"># ,  q  print('Result was {}'.format(result))</span></span></code> </pre><br>  Die <i><b>Queue-</b></i> Klasse bietet erhebliche zus√§tzliche Funktionen, wenn die Gr√∂√üe der Warteschlangen begrenzt und der Status abgefragt werden kann.  Das Verhalten mit einer leeren Warteschlange (wenn die Gr√∂√üe begrenzt ist) und das Verhalten mit einer vollen Warteschlange k√∂nnen gesteuert werden.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Dokumentation dazu befindet sich im Code. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.6 Andere Synchronisationsklassen</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Bibliothek </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyn.py</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bietet eine Mikroimplementierung einiger anderer Funktionen von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit der </font></font><a href="" rel="nofollow"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Condition-</font></font></i></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><font style="vertical-align: inherit;">kann eine Coroutine andere Coroutines benachrichtigen, die auf eine gesperrte Ressource warten. Nach Erhalt der Benachrichtigung erhalten sie Zugriff auf die Ressource und werden freigeschaltet. Eine Benachrichtigungskoroutine kann die Anzahl der zu benachrichtigenden Koroutinen begrenzen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit der </font></font><a href="" rel="nofollow"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gather-</font></font></i></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><font style="vertical-align: inherit;">k√∂nnen Sie eine Liste von Coroutinen ausf√ºhren. Nach Abschluss des letzteren wird eine Liste der Ergebnisse zur√ºckgegeben. Diese "Mikro" -Implementierung verwendet eine andere Syntax. Zeit√ºberschreitungen k√∂nnen auf jede der Coroutinen angewendet werden.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 Entwickeln von Klassen f√ºr </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asyncio</font></font></i></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Im Rahmen der Entwicklung von Ger√§tetreibern soll sichergestellt werden, dass diese nicht blockieren. Ein Coroutine-Treiber muss sicherstellen, dass andere Coroutinen ausgef√ºhrt werden, w√§hrend der Treiber darauf wartet, dass das Ger√§t Hardwarevorg√§nge ausf√ºhrt. Beispielsweise sollte eine Task, die auf Daten wartet, die in UART eingehen, oder ein Benutzer, der eine Taste dr√ºckt, erm√∂glichen, dass andere Ereignisse geplant werden, bis das Ereignis eintritt. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1 Klassen mit Warten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf</font></font></i></b> <font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;"> Warten Eine </font></b><b><i><font style="vertical-align: inherit;">Coroutine</font></i></b></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann die Ausf√ºhrung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anhalten,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> w√§hrend sie auf ein </font><i><font style="vertical-align: inherit;">wartendes</font></i><font style="vertical-align: inherit;"> Objekt wartet </font><font style="vertical-align: inherit;">. Unter </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> benutzerdefinierte Klasse </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">awaitable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> durch die Implementierung einer speziellen Methode erstellt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__await__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">was der Generator zur√ºckgibt. </font><font style="vertical-align: inherit;">Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erwartete</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><i><font style="vertical-align: inherit;">wird</font></i><font style="vertical-align: inherit;"> wie folgt verwendet:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__await__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>): print(<span class="hljs-string"><span class="hljs-string">'__await__ called'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">#     return 42 __iter__ = __await__ # .   async def bar(): foo = Foo() # Foo - awaitable  print('waiting for foo') res = await foo #   print('done', res) loop = asyncio.get_event_loop() loop.run_until_complete(bar())</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Derzeit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht unterst√ºtzen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__await__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="http://github.com/micropython/micropython/issues/2678" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausgabe # 2678</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und f√ºr die L√∂sung verwendet werden soll </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__iter__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die Zeichenfolge </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__iter__ = __await__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bietet Portabilit√§t zwischen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Code - </font><font style="vertical-align: inherit;">Beispiele finden Sie in </font><font style="vertical-align: inherit;">den Klassen </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ereignis, Barrier, Cancellable, Zustand</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyn.py</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1.1 Verwendung in Kontextmanagern</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erwartete Objekte k√∂nnen in synchronen oder asynchronen Kontextmanagern verwendet werden, wobei die erforderlichen speziellen Methoden bereitgestellt werden. </font><font style="vertical-align: inherit;">Syntax:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> awaitable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> a: <span class="hljs-comment"><span class="hljs-comment">#  'as'   #    async with awaitable as a: #    (.) #  -</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dies zu erreichen, muss sich der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__await__-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generator </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selbst zur√ºckgeben</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dies wird an jede Variable in der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klausel √ºbergeben und erm√∂glicht auch die Verwendung spezieller Methoden. Siehe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyn.Condition</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyntest.condition_test, in</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> denen die von der </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Condition-</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><font style="vertical-align: inherit;">verwendeten Funktionen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">warten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und in einem synchronen Kontext-Manager verwendet werden k√∂nnen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1.2 Await Koroutine in</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sprache </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erfordert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__await__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Generatorfunktion war. In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython sind die</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generatoren und Coroutinen identisch, daher besteht die L√∂sung darin, die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausbeute aus coro (args) zu verwenden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Zweck dieses Handbuchs besteht darin, Code anzubieten, der auf </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPython 3.5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder h√∂her </font><font style="vertical-align: inherit;">portierbar ist </font><font style="vertical-align: inherit;">. In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPython haben</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generatoren und Coroutinen unterschiedliche Bedeutungen. In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPython verf√ºgt eine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coroutine √ºber eine </font><font style="vertical-align: inherit;">spezielle Methode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__await__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die der Generator abruft. Dies ist portabel:</font></font><br><br><pre> <code class="python hljs">up = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-comment"><span class="hljs-comment">#   MicroPython? try: import uasyncio as asyncio up = True #    sys.implementation.name except ImportError: import asyncio async def times_two(n): # Coro   await asyncio.sleep(1) return 2 * n class Foo(): def __await__(self): res = 1 for n in range(5): print('__await__ called') if up: # MicroPython res = yield from times_two(res) else: # CPython res = yield from times_two(res).__await__() return res __iter__ = __await__ async def bar(): foo = Foo() # foo is awaitable print('waiting for foo') res = await foo #   print('done', res) loop = asyncio.get_event_loop() loop.run_until_complete(bar())</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__await__, yield from asyncio.sleep (1)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erlaubt ist </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ich verstehe immer noch nicht, wie dies erreicht wird. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2 Asynchrone Iteratoren</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Asynchrone Iteratoren bieten die M√∂glichkeit, eine endliche oder unendliche Folge von Werten zur√ºckzugeben. Sie k√∂nnen zum Abrufen von sequentiellen Datenelementen verwendet werden, wenn diese von einem schreibgesch√ºtzten Ger√§t stammen. </font><font style="vertical-align: inherit;">Ein asynchroner Iterator ruft bei seiner </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√§chsten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode asynchronen Code auf </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Klasse muss die folgenden Anforderungen erf√ºllen:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__aiter__-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode, </font><font style="vertical-align: inherit;">die in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async def</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definiert ist </font><font style="vertical-align: inherit;">und einen asynchronen Iterator </font><i><font style="vertical-align: inherit;">zur√ºckgibt</font></i><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__anext__-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><font style="vertical-align: inherit;">, die selbst eine Coroutine ist, </font><i><font style="vertical-align: inherit;">dh</font></i><font style="vertical-align: inherit;"> √ºber </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async def</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definiert ist </font><font style="vertical-align: inherit;">und mindestens eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wait-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anweisung enth√§lt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um die Iteration zu stoppen, muss eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StopAsyncIteration-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ausnahme </font><i><font style="vertical-align: inherit;">ausgel√∂st werden</font></i><font style="vertical-align: inherit;"> .</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serielle Werte werden mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wie </font><i><font style="vertical-align: inherit;">folgt</font></i><font style="vertical-align: inherit;"> abgerufen </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncIterable</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.data = (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) self.index = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__aiter__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__anext__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.fetch_data() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> StopAsyncIteration <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-comment"><span class="hljs-comment">#     if self.index &gt;= len(self.data): return None x = self.data[self.index] self.index += 1 return x async def run(): ai = AsyncIterable() async for x in ai: print(x)</span></span></code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3 Asynchrone Kontextmanager</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klassen k√∂nnen so entworfen werden, dass sie asynchrone Kontextmanager unterst√ºtzen, bei denen es sich um Co-Programme handelt. Ein Beispiel ist ein Klasse - </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschluss</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wie </font><font style="vertical-align: inherit;">oben beschrieben. Es verf√ºgt √ºber die Coroutine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__aenter__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die f√ºr den asynchronen Betrieb logisch erforderlich ist. Um das asynchrone Protokoll des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kontextmanagers zu unterst√ºtzen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , muss die Methode </font><i><font style="vertical-align: inherit;">__aexit__</font></i><font style="vertical-align: inherit;"> ebenfalls eine Coroutine </font><font style="vertical-align: inherit;">sein. </font><i><font style="vertical-align: inherit;">Dies</font></i><font style="vertical-align: inherit;"> wird durch Einschlie√üen von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await asyncio.sleep (0) erreicht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Auf solche Klassen kann innerhalb einer Coroutine mit der folgenden Syntax zugegriffen werden:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( lock )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> lock: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> ( ¬´ bar ¬ª )</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bei normalen Kontextmanagern wird die Exit-Methode garantiert aufgerufen, wenn der Kontextmanager seine Arbeit wie gewohnt und √ºber eine Ausnahme abgeschlossen hat. Um dieses Ziel zu erreichen, werden spezielle Methoden </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__aenter__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__aexit__ verwendet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die als Coroutinen definiert werden m√ºssen, die auf eine andere Coroutine oder ein </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anderes wartbares</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekt </font><i><font style="vertical-align: inherit;">warten</font></i><font style="vertical-align: inherit;"> . Dieses Beispiel stammt aus der </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lock-</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__aenter__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.acquire() <span class="hljs-comment"><span class="hljs-comment"># a coro    async def return self async def __aexit__(self, *args): self.release() #   await asyncio.sleep_ms(0)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async with</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine Klausel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as variable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enth√§lt </font><font style="vertical-align: inherit;">, erh√§lt die Variable den von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__aenter__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur√ºckgegebenen </font><i><font style="vertical-align: inherit;">Wert</font></i><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um ein korrektes Verhalten zu gew√§hrleisten, muss die Firmware V1.9.10 oder h√∂her sein. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Ausnahmen von Zeit√ºberschreitungen und aufgrund des </font></font></b> <font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">Abbruchs </font></b><b><font style="vertical-align: inherit;">von Aufgaben</font></b></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diese Themen stehen in Zusammenhang: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> umfasst das Abbrechen von Aufgaben und das Anwenden einer Zeit√ºberschreitung auf eine Aufgabe, wobei eine Ausnahme f√ºr die Aufgabe auf besondere Weise </font><b><font style="vertical-align: inherit;">ausgel√∂st wird</font></b><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1 Ausnahmen</font></font></b> <br><br>      (exeption),        ,   ,   .  ,      .   ,   ,    ,   . ,    , ,   <i>loop.create_task()</i>     . <br><br>  <i>throw</i>  <i>close</i>     , .   <b>uasyncio</b> ,    , , ,         . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das obige Beispiel veranschaulicht diese Situation. Wenn es erlaubt ist, bis zum Ende zu arbeiten, funktioniert es wie erwartet.</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">3</span></span>) print(<span class="hljs-string"><span class="hljs-string">'About to throw exception.'</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> foo() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ZeroDivisionError: print(<span class="hljs-string"><span class="hljs-string">'foo  -   0'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># ! raise #     . except KeyboardInterrupt: print('foo was interrupted by ctrl-c') #   ! raise async def shutdown(): print('Shutdown is running.') #     await asyncio.sleep(1) print('done') loop = asyncio.get_event_loop() try: loop.run_until_complete(bar()) except ZeroDivisionError: loop.run_until_complete(shutdown()) except KeyboardInterrupt: print('Keyboard interrupt at loop level.') loop.run_until_complete(shutdown())</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ausgeben einer Tastaturunterbrechung f√ºhrt jedoch dazu, dass die Ausnahme in die Ereignisschleife eintritt. Dies liegt daran, dass die Ausf√ºhrung von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio.sleep</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> an die Ereignisschleife √ºbergeben wird. Daher m√ºssen Anwendungen, die als Reaktion auf eine Tastaturunterbrechung einen eindeutigen Code ben√∂tigen, eine Ausnahme auf der Ebene der Ereignisschleife abfangen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2 Stornierung und Timeouts</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie oben erw√§hnt, sind </font><font style="vertical-align: inherit;">diese Funktionen arbeiten, eine Ausnahme f√ºr eine bestimmte Aufgabe zu </font><font style="vertical-align: inherit;">verursachen, eine spezielle Methode mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koroutine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pend_throw</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wie es funktioniert, h√§ngt von der Version ab. In der offiziellen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Version 2.0 von uasyncio wird eine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ausnahme erst bei der n√§chsten geplanten Aufgabe verarbeitet. Dies f√ºhrt zu einer Verz√∂gerung, wenn die Aufgabe </font><i><font style="vertical-align: inherit;">Schlaf</font></i><font style="vertical-align: inherit;"> erwartet</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eingabe-Ausgabe </font><font style="vertical-align: inherit;">Zeit√ºberschreitungen k√∂nnen √ºber den nominalen Zeitraum hinausgehen. </font><font style="vertical-align: inherit;">Die Aufgabe zum R√ºckg√§ngigmachen anderer Aufgaben kann nicht bestimmen, wann das R√ºckg√§ngigmachen abgeschlossen ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Derzeit gibt es eine Problemumgehung und zwei L√∂sungen.</font></font><br><br><ul><li><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Umgehung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : In der </font><b><font style="vertical-align: inherit;">asyn-</font></b><font style="vertical-align: inherit;"> Bibliothek k√∂nnen Sie darauf </font><font style="vertical-align: inherit;">warten, dass Aufgaben oder Aufgabengruppen abgebrochen werden. </font><font style="vertical-align: inherit;">Siehe Abbrechen eines Jobs (Abschnitt 5.2.1.).</font></font></li><li> <a href="http://github.com/pfalcon/pycopy-lib" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Paul Sokolovsky-Bibliothek</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stellt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio v2.4 zur Verf√ºgung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , erfordert jedoch die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pycopy-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Firmware </font><font style="vertical-align: inherit;">.</font></font></li><li> <a href="" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fast_io</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliothek</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> l√∂st dieses Problem in</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dem Python</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (weniger elegante Art</font><font style="vertical-align: inherit;">Weise) und offizielle Firmware l√§uft.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die hier verwendete </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausnahmehierarchie</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lautet </font><i><font style="vertical-align: inherit;">Exception-CanceledError-TimeoutError</font></i><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2.1 Abbrechen eines Jobs </font></font></b> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bietet eine </font><b><font style="vertical-align: inherit;">Abbruchfunktion </font></b></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Coro)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dies funktioniert, indem eine Ausnahme </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ausgel√∂st wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die Coroutine </font><i><font style="vertical-align: inherit;">pend_throw</font></i><font style="vertical-align: inherit;"> zu verwenden </font><font style="vertical-align: inherit;">. Es funktioniert auch mit verschachtelten Coroutinen. Verwendung ist wie folgt:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-comment"><span class="hljs-comment">#  -  10 secs await asyncio.sleep(10) async def bar(loop): foo_instance = foo() #   coro loop.create_task(foo_instance) # code omitted asyncio.cancel(foo_instance)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn dieses Beispiel unter </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio v2.0 ausgef√ºhrt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird und der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Balken </font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cancel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur√ºckgibt </font><i><font style="vertical-align: inherit;">,</font></i><font style="vertical-align: inherit;"> wird er erst beim n√§chsten geplanten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wirksam, </font><font style="vertical-align: inherit;">und es kann zu einer </font><font style="vertical-align: inherit;">Verz√∂gerung von bis zu 10 Sekunden kommen, </font><font style="vertical-align: inherit;">wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> annulliert wird </font><font style="vertical-align: inherit;">. Eine weitere Verz√∂gerungsquelle tritt auf, wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf E / A wartet. Wo immer die Verz√∂gerung auftritt, kann der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Balken</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht feststellen, ob </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> annulliert wurde. Es ist in einigen Anwendungsf√§llen von Bedeutung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei Verwendung der </font><b><font style="vertical-align: inherit;">Bibliotheken </font></b></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paul Sokolovsky</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast_io ist es</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausreichend, sleep (0) zu verwenden:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-comment"><span class="hljs-comment">#  -  10 secs await asyncio.sleep(10) async def bar(loop): foo_instance = foo() #   coro loop.create_task(foo_instance) #    asyncio.cancel(foo_instance) await asyncio.sleep(0) #   </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies funktioniert auch in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio v2.0,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (und alle ausstehenden Coroutine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) niemals den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlaf wiedergegeben haben</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und nicht auf I / O gewartet haben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Verhalten, das die Unachtsamkeit √ºberraschen kann, tritt auf, wenn erwartet wird, dass eine von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">create_task ausgef√ºhrte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coroutine </font><font style="vertical-align: inherit;">im Standby-Modus </font><font style="vertical-align: inherit;">abgebrochen wird </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Betrachten Sie dieses Snippet:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-comment"><span class="hljs-comment">#  -  10 secs await asyncio.sleep(10) async def foo_runner(foo_instance): await foo_instance print('   ') async def bar(loop): foo_instance = foo() loop.create_task(foo_runner(foo_instance)) #    asyncio.cancel(foo_instance)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abgebrochen wird, wird es aus der Scheduler-Warteschlange entfernt. </font><font style="vertical-align: inherit;">Da es keine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">return-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anweisung gibt, wird die aufrufende Prozedur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foo_runner</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nie </font><i><font style="vertical-align: inherit;">fortgesetzt</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es wird empfohlen, dass Sie die Ausnahme immer im √§u√üersten Bereich der r√ºckg√§ngig zu machenden Funktion abfangen:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> my_coro <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> asyncio.CancelledError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall muss </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">my_coro</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Ausnahme nicht abfangen, da sie an den aufrufenden Kanal weitergegeben und dort erfasst wird.</font></font><br><br>  Hinweis<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist verboten, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Close-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Throw-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methoden von Coroutinen zu verwenden, wenn Coroutinen au√üerhalb des Schedulers verwendet werden. Dies untergr√§bt den Scheduler und zwingt die Coroutine, Code auszuf√ºhren, auch wenn er nicht geplant ist. Dies kann unerw√ºnschte Folgen haben. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2.2 Coroutinen mit Timeouts</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Timeouts werden mit den </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methoden </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.wait_for ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.wait_for_ms () implementiert</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sie nehmen Coroutine und Latenz in Sekunden bzw. ms als Argumente. Wenn das Timeout abl√§uft, </font><font style="vertical-align: inherit;">wird mit </font><i><font style="vertical-align: inherit;">pend_throw</font></i><font style="vertical-align: inherit;"> ein </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TimeoutError</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in die Coroutine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geworfen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Ausnahme muss entweder vom Benutzer oder vom Anrufer abgefangen werden. </font><font style="vertical-align: inherit;">Dies ist aus dem oben beschriebenen Grund erforderlich: Wenn das Timeout abl√§uft, wird es abgebrochen. </font><font style="vertical-align: inherit;">Wenn der Fehler nicht abgefangen und zur√ºckgegeben wird, kann der Aufrufer nur die Ausnahme selbst abfangen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wo die Ausnahme von der Coroutine abgefangen wurde, hatte ich unklare Fehler, wenn die Ausnahme nicht im √§u√üeren Bereich abgefangen wurde, wie unten gezeigt:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forever</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: print(<span class="hljs-string"><span class="hljs-string">'Starting'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep_ms(<span class="hljs-number"><span class="hljs-number">300</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Got here'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> asyncio.TimeoutError: print(<span class="hljs-string"><span class="hljs-string">'Got timeout'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># And return async def foo(): await asyncio.wait_for(forever(), 5) await asyncio.sleep(2) loop = asyncio.get_event_loop() loop.run_until_complete(foo())</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alternativ k√∂nnen Sie die aufrufende Funktion abfangen: </font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forever</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">'Starting'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep_ms(<span class="hljs-number"><span class="hljs-number">300</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Got here'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.wait_for(forever(), <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> asyncio.TimeoutError: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> print(<span class="hljs-string"><span class="hljs-string">'Timeout elapsed.'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) loop = asyncio.get_event_loop() loop.run_until_complete(foo())</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis f√ºr </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uasyncio v2.0</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies gilt nicht f√ºr die </font><b><font style="vertical-align: inherit;">Bibliotheken </font></b></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paul Sokolovsky</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast_io</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Coroutine startet </font><font style="vertical-align: inherit;">und mit einer langen Verz√∂gerung t </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf asynchronen Schlaf (t) wartet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wird die Coroutine nicht neu </font><i><font style="vertical-align: inherit;">gestartet</font></i><font style="vertical-align: inherit;"> , bis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abl√§uft </font><font style="vertical-align: inherit;">. Wenn die Zeit√ºberschreitung vor dem Ende des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruhezustands</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abgelaufen ist </font><font style="vertical-align: inherit;">, tritt ein </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TimeoutError auf,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wenn die Coroutine neu geladen wird - d. H. wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abl√§uft </font><font style="vertical-align: inherit;">. In Echtzeit und aus Sicht des Anrufers wird seine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TimeoutError-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Antwort </font><font style="vertical-align: inherit;">verz√∂gert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn dies f√ºr die Anwendung wichtig ist, erstellen Sie eine lange Verz√∂gerung, w√§hrend Sie auf eine kurze Verz√∂gerung in der Schleife warten. Coroutine</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyn.sleep</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unterst√ºtzt dies. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6 Interaktion mit Ger√§ten</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Grundlage f√ºr die Interaktion zwischen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und externen asynchronen Ereignissen ist die Abfrage. Hardware, die eine schnelle Reaktion erfordert, verwendet m√∂glicherweise einen Interrupt. Die Interaktion zwischen der Interruptroutine (ISR) und der Benutzer-Coroutine basiert jedoch auf Umfragen. Beispielsweise kann ein ISR ein </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ereignis</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufrufen </font><font style="vertical-align: inherit;">oder ein globales Flag setzen, w√§hrend eine Coroutine, die auf ein Ergebnis wartet, jedes Mal ein Objekt abfragt, wenn eine Anforderung geplant ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Abfrage kann auf zwei Arten erfolgen, explizit oder implizit. Letzteres erfolgt √ºber </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stream I / O</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Mechanismus, der f√ºr das Streaming von Ger√§ten wie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UART</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sockets entwickelt wurde</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In der einfachsten expliziten Abfrage kann der folgende Code bestehen:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poll_my_device</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> my_flag <span class="hljs-comment"><span class="hljs-comment">#   ISR while True: if my_flag: my_flag = False # service the device await asyncio.sleep(0)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstelle eines globalen Flags k√∂nnen Sie eine Instanzvariable der </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Event-</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><font style="vertical-align: inherit;">oder eine Instanz einer Klasse verwenden, die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wait verwendet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Eine explizite Umfrage wird unten diskutiert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implizites Polling besteht darin, einen Treiber zu entwickeln, der als Streaming-E / A-Ger√§t fungiert, z. B. als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UART-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font><i><font style="vertical-align: inherit;">Streaming-E / A- </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Socket</font></font></i> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der Ger√§te mit dem </font><b><font style="vertical-align: inherit;">Python-</font></b><font style="vertical-align: inherit;"> System </font><i><font style="vertical-align: inherit;">select.poll abfragt</font></i><font style="vertical-align: inherit;"> : Da das Polling in C ausgef√ºhrt wird, ist es schneller und effizienter als explizite Umfrage. Die Verwendung von Stream-E / A wird in Abschnitt 6.3 erl√§utert.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i> <b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgrund seiner Effektivit√§t bietet implizites Polling den schnellsten E / A-Ger√§tetreibern einen Vorteil: Streaming-Treiber k√∂nnen f√ºr viele Ger√§te erstellt werden, die normalerweise nicht als Streaming-Ger√§te betrachtet werden. Dies wird in Abschnitt 6.4 n√§her erl√§utert. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.1 Synchronisierungsprobleme</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sowohl explizite als auch implizite Umfragen basieren derzeit auf einer zyklischen Planung. Angenommen, E / A funktioniert gleichzeitig mit N benutzerdefinierten Coroutinen, von denen jede ohne Verz√∂gerung ausgef√ºhrt wird. Wenn die E / A bedient wird, wird sie abgefragt, sobald alle Benutzervorg√§nge geplant sind. Die gesch√§tzte Verz√∂gerung sollte bei der Planung ber√ºcksichtigt werden. E / A-Kan√§le m√ºssen m√∂glicherweise gepuffert werden, wobei ISR-Wartungsger√§te in Echtzeit Puffer und Coroutinen verwenden, um die Puffer zu einem langsameren Zeitpunkt zu f√ºllen oder freizugeben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Man muss auch die M√∂glichkeit eines √úberschreitens in Betracht ziehen: Dies ist der Fall, wenn etwas, das von der Coroutine abgefragt wird, mehr als einmal vorkommt, bevor es tats√§chlich von der Coroutine geplant wird.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiteres Zeitproblem ist die Latenzgenauigkeit. Wenn die Coroutine Probleme hat</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep_ms ( t ) <span class="hljs-comment"><span class="hljs-comment">#  </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Scheduler garantiert, dass die Ausf√ºhrung f√ºr mindestens t ms unterbrochen wird. Die tats√§chliche Verz√∂gerung kann gr√∂√üer als t sein, was von der aktuellen Systemlast abh√§ngt. Wenn zu diesem Zeitpunkt andere Coroutinen auf die Beendigung von Verz√∂gerungen ungleich Null warten, wird die Ausf√ºhrung der n√§chsten Zeile sofort eingeplant. Wenn jedoch auch andere Coroutinen auf die Ausf√ºhrung warten (entweder weil sie eine Verz√∂gerung von Null ausgegeben haben oder weil ihre Zeit ebenfalls abgelaufen ist), ist m√∂glicherweise eine fr√ºhere Ausf√ºhrung geplant. Dies f√ºhrt eine Synchronisationsunsicherheit in die Funktionen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sleep ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sleep_ms () ein</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Der Worst-Case-Wert f√ºr diesen √úberlauf kann berechnet werden, indem die Laufzeitwerte aller dieser Coroutinen summiert werden, um die Worst-Case-√úbertragungszeit an den Scheduler zu bestimmen.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die fast_io-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Version von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bietet in diesem Kontext eine M√∂glichkeit, um sicherzustellen, dass Streaming-E / A bei jeder Iteration des Schedulers abgefragt werden. Es wird gehofft, dass das offizielle </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die entsprechenden √Ñnderungen </font><b><font style="vertical-align: inherit;">rechtzeitig</font></b><font style="vertical-align: inherit;"> akzeptiert. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.2 Abfragen von Ger√§ten mit Coroutinen</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist ein einfacher Ansatz, der am besten f√ºr Ger√§te geeignet ist, die mit einer relativ geringen Geschwindigkeit abgefragt werden k√∂nnen. Dies ist haupts√§chlich auf die Tatsache zur√ºckzuf√ºhren, dass das Abrufen mit einem kurzen (oder Null-) Abfrageintervall dazu f√ºhren kann, dass die Coroutine mehr Prozessorzeit verbraucht, als f√ºr das Fallen in das Intervall w√ºnschenswert ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apoll.py-</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beispiel </font><i><b><font style="vertical-align: inherit;">veranschaulicht</font></b></i><font style="vertical-align: inherit;"> diesen Ansatz durch Abfragen des </font><b><font style="vertical-align: inherit;">Pyboard-</font></b><font style="vertical-align: inherit;"> Beschleunigungsmessers</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einem Intervall von 100 ms. Es f√ºhrt eine einfache Filterung durch, um Rauschen zu ignorieren, und druckt alle zwei Sekunden eine Meldung, wenn keine Bewegung auftritt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Beispiel </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aswitch.py</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enth√§lt Treiber f√ºr Schalter und </font><i><b><font style="vertical-align: inherit;">Tastenger√§te</font></b></i><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Beispieltreiber f√ºr ein Ger√§t, das lesen und schreiben kann, ist unten dargestellt. Zum leichteren Testen </font><font style="vertical-align: inherit;">emuliert </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyboard</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UART 4 ‚Äã‚Äãein bedingtes Ger√§t. Der Treiber implementiert die </font><b><i><font style="vertical-align: inherit;">RecordOrientedUart-</font></i></b><font style="vertical-align: inherit;"> Klasse</font></font><b><i><font style="vertical-align: inherit;"></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wobei Daten in Datens√§tzen variabler L√§nge geliefert werden, die aus Byte-Instanzen bestehen. Das Objekt f√ºgt vor dem Senden ein Trennzeichen hinzu und puffert die eingehenden Daten, bis ein hinzugef√ºgtes Trennzeichen empfangen wird. Dies ist nur eine Demo und eine ineffiziente Art, UART im Vergleich zu Streaming Input / Output zu verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die asynchrone √úbertragung zu demonstrieren, wird davon ausgegangen, dass das emulierte Ger√§t √ºber ein Mittel verf√ºgt, mit dem √ºberpr√ºft werden kann, ob die √úbertragung abgeschlossen ist und die Anwendung eine Wartezeit erfordert. In diesem Beispiel ist keine der Annahmen wahr, aber der Code </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t√§uscht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sie vor, indem er </font><i><font style="vertical-align: inherit;">auf asyncio.sleep (0.1) wartet</font></i><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergessen Sie zu Beginn nicht, die Ausg√§nge des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyboard</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> X1 und X2 (UART Txd und Rxd) anzuschlie√üen.</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyb <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UART <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RecordOrientedUart</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> DELIMITER = <span class="hljs-string"><span class="hljs-string">b'\0'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.uart = UART(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9600</span></span>) self.data = <span class="hljs-string"><span class="hljs-string">b''</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__iter__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Not __await__ issue #2678 data = b'' while not data.endswith(self.DELIMITER): yield from asyncio.sleep(0) # ,  : while not self.uart.any(): yield from asyncio.sleep(0) # timing may mean this is never called data = b''.join((data, self.uart.read(self.uart.any()))) self.data = data async def send_record(self, data): data = b''.join((data, self.DELIMITER)) self.uart.write(data) await self._send_complete() #          #        await asyncio.sleep(0) async def _send_complete(self): await asyncio.sleep(0.1) def read_record(self): # Synchronous: await the object before calling return self.data[0:-1] # Discard delimiter async def run(): foo = RecordOrientedUart() rx_data = b'' await foo.send_record(b'A line of text.') for _ in range(20): await foo #  coros       foo rx_data = foo.read_record() print('Got: {}'.format(rx_data)) await foo.send_record(rx_data) rx_data = b'' loop = asyncio.get_event_loop() loop.run_until_complete(run())</span></span></code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3 Verwenden des Streaming-Mechanismus ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stream</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Beispiel zeigt die gleichzeitige E / A auf einem einzelnen UART </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyboard-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mikroprozessor </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbinden Sie zum Starten die Ausg√§nge des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyboard</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> X1 und X2 (UART Txd und Rxd)</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyb <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UART uart = UART(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9600</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sender</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> swriter = asyncio.StreamWriter(uart, {}) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> swriter.awrite(<span class="hljs-string"><span class="hljs-string">'Hello uart\n'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receiver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> sreader = asyncio.StreamReader(uart) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: res = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> sreader.readline() print(<span class="hljs-string"><span class="hljs-string">'Received'</span></span>, res) loop = asyncio.get_event_loop() loop.create_task(sender()) loop.create_task(receiver()) loop.run_forever()</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der unterst√ºtzende Code befindet sich in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__init__.py</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliothek. </font><font style="vertical-align: inherit;">Der Mechanismus funktioniert, weil der Ger√§tetreiber (in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C geschrieben</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) die folgenden Methoden implementiert: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ioctl, read, readline</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">write</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In Abschnitt 6.4: Schreiben eines Streaming-Ger√§tetreibers erfahren Sie, wie solche Treiber in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python geschrieben werden k√∂nnen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br> UART      .   -       ,    .   ,      ;   ,     . ,  UART     ,        ,       .   ,     UART,     .        ,     . <br><br> <b>6.3.1   UART</b> <br><br>  <i><b>auart_hd.py</b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">veranschaulicht ein Kommunikationsverfahren mit einem Halbduplex-Ger√§t, beispielsweise einem Ger√§t, das auf den AT-Modem-Befehlssatz reagiert. Halbduplex bedeutet, dass das Ger√§t niemals unerw√ºnschte Daten sendet: Die √úbertragung erfolgt immer auf einen empfangenen Befehl des Masters hin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ger√§t wird durch Ausf√ºhren eines Tests auf einem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyboard</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit zwei </font><b><font style="vertical-align: inherit;">Kabelverbindungen</font></b><font style="vertical-align: inherit;"> emuliert </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das (sehr vereinfachte) emulierte Ger√§t reagiert auf jeden Befehl, indem es vier Datenzeilen mit einer Pause dazwischen sendet, um eine langsame Verarbeitung zu simulieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Assistent sendet einen Befehl, wei√ü jedoch nicht im Voraus, wie viele Datenzeilen zur√ºckgegeben werden. Es startet einen Neustart-Timer, der jedes Mal neu startet, wenn eine Leitung empfangen wird. Nach Ablauf des Timers wird davon ausgegangen, dass das Ger√§t die √úbertragung abgeschlossen hat und eine Liste der empfangenen Leitungen zur√ºckgegeben wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird auch ein Ger√§teausfall beschrieben, bei dem eine √úbertragung √ºbersprungen wird, bevor auf eine Antwort gewartet wird. Nach dem Timeout wird eine leere Liste zur√ºckgegeben. Weitere Details finden Sie in den Codekommentaren. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.4 Entwicklung von Streaming (Treiber - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stream</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) -Einheit</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Strom Ein- / Ausgabemechanismus ( </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stream - </font><font style="vertical-align: inherit;">E / A</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) zur Steuerung des Betriebes von Streaming - </font><font style="vertical-align: inherit;">E / A - </font><font style="vertical-align: inherit;">Ger√§ten wie UART und Buchsen ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Steckdose</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Der Mechanismus kann von Treibern jedes regelm√§√üig abgefragten Ger√§ts verwendet werden, indem er an den Scheduler delegiert wird, der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">select</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet, </font><i><font style="vertical-align: inherit;">um</font></i><font style="vertical-align: inherit;"> die Bereitschaft aller Ger√§te in der Warteschlange abzufragen. Dies ist effizienter als die Ausf√ºhrung mehrerer Coroutine-Operationen, von denen jede das Ger√§t </font><font style="vertical-align: inherit;">abfragt </font><font style="vertical-align: inherit;">, zum Teil, weil </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">select</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C geschrieben ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und auch, weil die Coroutine, die die Abfrage durchf√ºhrt, verz√∂gert wird, bis das abgefragte Objekt einen Bereitschaftszustand zur√ºckgibt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Ger√§tetreiber, der den Streaming-Ein- / Ausgabemechanismus </font><i><font style="vertical-align: inherit;">bedienen kann,</font></i><font style="vertical-align: inherit;"> sollte vorzugsweise die Methoden </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamReader, StreamWriter unterst√ºtzen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ein lesbares Ger√§t muss mindestens eine der folgenden Methoden bereitstellen. Bitte beachten Sie, dass dies synchrone Methoden sind. Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ioctl-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><font style="vertical-align: inherit;">(siehe unten) stellt sicher, dass sie nur aufgerufen werden, wenn Daten verf√ºgbar sind. Methoden sollten so schnell wie m√∂glich zur√ºckgegeben werden, wobei so viele Daten wie m√∂glich verwendet werden. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">readline ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gibt so viele Zeichen wie m√∂glich bis zu einem beliebigen Zeilenvorschub zur√ºck. Erforderlich bei Verwendung von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamReader.readline () </font></font></i> <br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">read (n) </font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">Gibt</font></i><font style="vertical-align: inherit;"> so viele Zeichen wie m√∂glich zur√ºck, jedoch nicht mehr als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Erforderlich, wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamReader.read ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamReader.readexactly () verwendet wird</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erstellte Treiber sollte die folgende synchrone Methode mit sofortiger R√ºckgabe bereitstellen: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schreiben Sie</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit den Argumenten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buf, off, sz</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Wo: <br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein Puffer zum Schreiben. </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">off</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Offset zum Puffer des ersten zu schreibenden Zeichens. </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sz</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Die angeforderte Anzahl der zu schreibenden Zeichen. </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der R√ºckgabewert</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die Anzahl der tats√§chlich geschriebenen Zeichen (m√∂glicherweise 1, wenn das Ger√§t langsam ist). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ioctl-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><font style="vertical-align: inherit;">stellt sicher, dass sie nur aufgerufen wird, wenn das Ger√§t bereit ist, Daten zu empfangen.</font></font><br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Ger√§te m√ºssen eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ioctl-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode bereitstellen, mit der Ger√§te </font><i><font style="vertical-align: inherit;">abgefragt</font></i><font style="vertical-align: inherit;"> werden </font><font style="vertical-align: inherit;">, um ihren Verf√ºgbarkeitsstatus zu ermitteln. </font><font style="vertical-align: inherit;">Ein typisches Beispiel f√ºr einen Lese- / Schreibtreiber:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io MP_STREAM_POLL_RD = const(<span class="hljs-number"><span class="hljs-number">1</span></span>) MP_STREAM_POLL_WR = const(<span class="hljs-number"><span class="hljs-number">4</span></span>) MP_STREAM_POLL = const(<span class="hljs-number"><span class="hljs-number">3</span></span>) MP_STREAM_ERROR = const(<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyIO</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(io.IOBase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    def ioctl(self, req, arg): # see ports/stm32/uart.c ret = MP_STREAM_ERROR if req == MP_STREAM_POLL: ret = 0 if arg &amp; MP_STREAM_POLL_RD: if hardware_has_at_least_one_char_to_read: ret |= MP_STREAM_POLL_RD if arg &amp; MP_STREAM_POLL_WR: if hardware_can_accept_at_least_one_write_character: ret |= MP_STREAM_POLL_WR return ret</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Folgenden wird die </font><font style="vertical-align: inherit;">Wartezeit </font><font style="vertical-align: inherit;">der </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MillisecTimer-</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse beschrieben </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> utime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io MP_STREAM_POLL_RD = const(<span class="hljs-number"><span class="hljs-number">1</span></span>) MP_STREAM_POLL = const(<span class="hljs-number"><span class="hljs-number">3</span></span>) MP_STREAM_ERROR = const(<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MillisecTimer</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(io.IOBase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.end = <span class="hljs-number"><span class="hljs-number">0</span></span> self.sreader = asyncio.StreamReader(self) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__iter__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.sreader.readline() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, ms)</span></span></span><span class="hljs-function">:</span></span> self.end = utime.ticks_add(utime.ticks_ms(), ms) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">b'\n'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ioctl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, req, arg)</span></span></span><span class="hljs-function">:</span></span> ret = MP_STREAM_ERROR <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> req == MP_STREAM_POLL: ret = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> arg &amp; MP_STREAM_POLL_RD: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> utime.ticks_diff(utime.ticks_ms(), self.end) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>: ret |= MP_STREAM_POLL_RD <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> welches wie folgt verwendet werden kann: </font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timer_test</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( n )</span></span></span><span class="hljs-function">:</span></span> timer = ms_timer.MillisecTimer () <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> timer ( <span class="hljs-number"><span class="hljs-number">30</span></span> ) <span class="hljs-comment"><span class="hljs-comment">#  30 </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gegen√ºber dem offiziellen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio bietet eine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> solche Implementierung keine Vorteile gegen√ºber dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyncio.sleep_ms ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die Verwendung von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast_io</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bietet im normalen Verwendungsmuster wesentlich genauere Verz√∂gerungen, wenn Coroutinen eine Verz√∂gerung von Null erwarten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen die E / A-Planung verwenden, um ein Ereignis einem R√ºckruf zuzuordnen. Dies ist effizienter als der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abrufzyklus</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , da der </font><i><font style="vertical-align: inherit;">Abruf</font></i><font style="vertical-align: inherit;"> erst geplant wird, wenn </font><i><font style="vertical-align: inherit;">ioctl</font></i><font style="vertical-align: inherit;"> bereit ist. Als n√§chstes wird ein R√ºckruf ausgef√ºhrt, wenn der R√ºckruf den Zustand √§ndert.</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io MP_STREAM_POLL_RD = const(<span class="hljs-number"><span class="hljs-number">1</span></span>) MP_STREAM_POLL = const(<span class="hljs-number"><span class="hljs-number">3</span></span>) MP_STREAM_ERROR = const(<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PinCall</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(io.IOBase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, pin, *, cb_rise=None, cbr_args=</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span><span class="hljs-function"><span class="hljs-params">, cb_fall=None, cbf_args=</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> self.pin = pin self.cb_rise = cb_rise self.cbr_args = cbr_args self.cb_fall = cb_fall self.cbf_args = cbf_args self.pinval = pin.value() self.sreader = asyncio.StreamReader(self) loop = asyncio.get_event_loop() loop.create_task(self.run()) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.sreader.read(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, _)</span></span></span><span class="hljs-function">:</span></span> v = self.pinval <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self.cb_rise <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: self.cb_rise(*self.cbr_args) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">b'\n'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self.cb_fall <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: self.cb_fall(*self.cbf_args) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">b'\n'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ioctl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, req, arg)</span></span></span><span class="hljs-function">:</span></span> ret = MP_STREAM_ERROR <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> req == MP_STREAM_POLL: ret = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> arg &amp; MP_STREAM_POLL_RD: v = self.pin.value() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v != self.pinval: self.pinval = v ret = MP_STREAM_POLL_RD <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und wieder - auf der offiziellen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uasyncio kann die</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verz√∂gerung hoch sein. Je nach Anwendungsdesign ist die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast_io-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Version </font><font style="vertical-align: inherit;">m√∂glicherweise effizienter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iorw.py-Demo</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zeigt ein vollst√§ndiges Beispiel. Bitte beachten Sie, dass zum Zeitpunkt des Schreibens des Artikels im offiziellen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ein Fehler vorliegt, aufgrund dessen dies </font></font><a href="http://github.com/micropython/pull/3836" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht funktioniert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es gibt zwei L√∂sungen. Die Problemumgehung besteht darin, zwei separate Treiber zu schreiben, einen nur zum Lesen und einen nur zum Schreiben. Die zweite </font></font><a href="" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√∂glichkeit</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die Verwendung von </font><a href="" rel="nofollow"><b><font style="vertical-align: inherit;">fast_io</font></b></a><font style="vertical-align: inherit;"> , um dieses Problem zu l√∂sen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im offiziellen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uasyncio ist die</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eingabe / Ausgabe ziemlich </font></font><a href="http://github.com/micropython/micropython/issues/2664" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> geplant </font><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.5 Vollst√§ndiges Beispiel: aremote.py</font></font></b> <br><br> <a href="" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Treiber ist</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zum Empfangen / Dekodieren von Signalen von einer Infrarot-Fernbedienung ausgelegt. Der</font></font><a href="http://github.com/peterhinch/micropython-async/blob/master/nec_ir/aremote.py" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aremote.py-</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Treiber</font><a href="http://github.com/peterhinch/micropython-async/blob/master/nec_ir/aremote.py" rel="nofollow"><b><font style="vertical-align: inherit;"> selbst</font></b></a><font style="vertical-align: inherit;"> . Die folgenden Hinweise sind f√ºr die Verwendung von</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Asyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von</font><b><font style="vertical-align: inherit;"> Bedeutung</font></b><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Unterbrechung des Kontakts zeichnet den Zeitpunkt des Zustandswechsels (in Mikrosekunden) auf und setzt das Ereignis, wobei der Zeitpunkt des ersten Zustandswechsels √ºbersprungen wird. Die Coroutine wartet auf ein Ereignis, meldet die Dauer des Datenpakets und decodiert dann die gespeicherten Daten, bevor sie den vom Benutzer angegebenen R√ºckruf aufruft.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch</font><font style="vertical-align: inherit;">die</font><b><font style="vertical-align: inherit;"> √úbergabe der</font></b><font style="vertical-align: inherit;"> Zeit an eine</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ereignisinstanz</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann die Coroutine</font><font style="vertical-align: inherit;">beim Festlegen der Verz√∂gerungszeit</font><font style="vertical-align: inherit;">jede</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Asynchronit√§tsverz√∂gerung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausgleichen</font><font style="vertical-align: inherit;">.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6.6 Umgebungssensor HTU21D</font></font></b> <br><br> <a href="http://github.com/peterhinch/micropython-async/blob/master/nec_ir/aremote.py" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HTU21D-Chiptreiber bietet genaue Temperatur- und Feuchtigkeitsmessungen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Chip ben√∂tigt ca. 120 ms, um beide Datenelemente zu empfangen. Der Treiber arbeitet asynchron und initiiert den Empfang und die Verwendung von</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wait asyncio.sleep (t),</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bevor Daten gelesen werden. Er aktualisiert die Temperatur- und Feuchtigkeitsvariablen, auf die jederzeit zugegriffen werden kann. Dadurch k√∂nnen andere Coroutinen gestartet werden, w√§hrend der Chiptreiber ausgef√ºhrt wird.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Tipps und Tricks </font></font></b> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1 Das Programm friert ein Das Einfrieren erfolgt</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> normalerweise, weil die Aufgabe ohne</font><b><font style="vertical-align: inherit;"> Erlaubnis</font></b><font style="vertical-align: inherit;"> blockiert wird. Dies f√ºhrt zum Einfrieren des gesamten Systems. Bei der Entwicklung ist es n√ºtzlich, eine Coroutine zu haben, die die eingebaute LED regelm√§√üig einschaltet. Dadurch wird best√§tigt, dass der Scheduler noch ausgef√ºhrt wird.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2 uasyncio speichert Status</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie Programme mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in REPL </font><b><font style="vertical-align: inherit;">starten</font></b><font style="vertical-align: inherit;"> , f√ºhren Sie zwischen den Starts einen Soft-Reset (Strg-D) durch. Aufgrund der Tatsache, dass </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> den Status zwischen den Starts beibeh√§lt, kann es beim n√§chsten Start zu unvorhersehbarem Verhalten kommen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.3 </font></font></b> <font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">Speicherbereinigung</font></i></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie k√∂nnen eine Coroutine ausf√ºhren, indem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie zuerst import gc angeben</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="python hljs">gc.collect () gc.treshold ( gc.mem_free () // <span class="hljs-number"><span class="hljs-number">4</span></span> + gc.mem_alloc ())</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Zweck hierf√ºr wird </font></font><a href="http://docs.micropython.org/en/latest/reference/constrained.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Abschnitt Heap </font><font style="vertical-align: inherit;">erl√§utert </font><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.4 Testen</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es wird empfohlen, sicherzustellen, dass der Ger√§tetreiber die Kontrolle beh√§lt, wenn dies erforderlich ist. F√ºhren Sie dazu eine oder mehrere Kopien von fiktiven Coroutinen aus, die den Nachrichtendruckzyklus starten, und √ºberpr√ºfen Sie, ob der Treiber in den folgenden Zeitr√§umen im Standby-Modus ausgef√ºhrt wird:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: print(<span class="hljs-string"><span class="hljs-string">'Roundrobin '</span></span>, n) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als ein Beispiel die Art der Gefahr , </font><font style="vertical-align: inherit;">die im obigen Beispiel auftreten kann </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecordOrientedUart </font></font></i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__await__</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wurde Methode urspr√ºnglich geschrieben als:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__await__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> data = <span class="hljs-string"><span class="hljs-string">b''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> data.endswith(self.DELIMITER): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.uart.any(): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>) data = <span class="hljs-string"><span class="hljs-string">b''</span></span>.join((data, self.uart.read(self.uart.any()))) self.data = data</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infolgedessen wird die Ausf√ºhrung so lange gestreckt, bis der gesamte Datensatz empfangen wurde. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au√üerdem</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gibt </font><i><font style="vertical-align: inherit;">uart.any ()</font></i><font style="vertical-align: inherit;"> immer eine von Null verschiedene Anzahl empfangener Zeichen zur√ºck. Zum Zeitpunkt des Anrufs sind m√∂glicherweise bereits alle Zeichen eingegangen. Diese Situation kann mit einer externen Schleife gel√∂st werden:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__await__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> data = <span class="hljs-string"><span class="hljs-string">b''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> data.endswith(self.DELIMITER): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment"># ,  : while not self.uart.any(): yield from asyncio.sleep(0) #        data = b''.join((data, self.uart.read(self.uart.any()))) self.data = data</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es kann erw√§hnenswert sein, dass dieser Fehler nicht offensichtlich gewesen w√§re, wenn die Daten mit einer geringeren Geschwindigkeit an den UART gesendet worden w√§ren, anstatt einen R√ºckkopplungstest zu verwenden. Willkommen zu den Freuden der Echtzeitprogrammierung. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.5 H√§ufiger Fehler</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn eine Funktion oder Methode von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async def</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definiert </font><font style="vertical-align: inherit;">und anschlie√üend wie ein regul√§rer (synchroner) Aufruf aufgerufen wird, zeigt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keine Fehlermeldung an. Dies ist beabsichtigt. Normalerweise f√ºhrt dies dazu, dass das Programm im Hintergrund nicht richtig funktioniert:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># code loop.create_task(foo) #  1 1: foo     foo() #  2: .</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe einen </font></font><a href="http://github.com/micropython-lib/pull/292" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorschlag</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der vorschl√§gt, die Situation in Option 1 mit </font></font><a href="" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast_io zu beheben</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Modul </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">check_async_code.py</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> versucht, F√§lle von zweifelhafter Verwendung von Coroutinen zu erkennen. Es ist in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python3 geschrieben</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und f√ºr die Arbeit auf einem PC ausgelegt. Wird in Skripten verwendet, die gem√§√ü den in diesem Handbuch beschriebenen Richtlinien mit Coroutinen geschrieben wurden, die mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async def</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deklariert wurden </font><font style="vertical-align: inherit;">. Das Modul hat ein Argument, den Pfad zu der Quelldatei </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (oder --help).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitte beachten Sie, dass es etwas unh√∂flich ist und in einer syntaktisch korrekten Datei verwendet werden soll, die nicht standardm√§√üig gestartet wird. </font><font style="vertical-align: inherit;">Verwenden Sie ein Tool wie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pylint</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur allgemeinen Syntaxpr√ºfung (bei </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pylint</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tritt dieser Fehler derzeit nicht auf). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Skript erzeugt falsche Positive. </font><font style="vertical-align: inherit;">Koroutinen sind laut Plan Objekte der ersten Ebene, sie k√∂nnen auf Funktionen √ºbertragen und in Datenstrukturen abgelegt werden. </font><font style="vertical-align: inherit;">Abh√§ngig von der Logik des Programms k√∂nnen Sie die Funktion oder das Ergebnis ihrer Ausf√ºhrung speichern. </font><font style="vertical-align: inherit;">Das Skript kann die Absicht nicht bestimmen. </font><font style="vertical-align: inherit;">Es zielt darauf ab, F√§lle zu ignorieren, die korrekt erscheinen, wenn andere zu ber√ºcksichtigende F√§lle identifiziert werden. </font><font style="vertical-align: inherit;">Angenommen, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foo,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der die Coroutine als </font><i><font style="vertical-align: inherit;">asynchron def</font></i><font style="vertical-align: inherit;"> deklariert ist</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><br><pre> <code class="python hljs">loop.run_until_complete(foo()) <span class="hljs-comment"><span class="hljs-comment">#   bar(foo) #     ,      bar(foo()) z = (foo,) z = (foo(),) foo() #  :   .</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich finde es n√ºtzlich, aber Verbesserungen sind immer willkommen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.6 Programmieren mit Steckdosen ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Steckdosen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es gibt zwei grundlegende Ans√§tze zur Programmierung Steckdosen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Standardm√§√üig werden Sockets gesperrt, bis der angegebene Lese- oder Schreibvorgang abgeschlossen ist. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unterst√ºtzt das Sperren von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sockets</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit </font><i><font style="vertical-align: inherit;">select.poll</font></i><font style="vertical-align: inherit;"> , um zu verhindern, dass der Scheduler sie blockiert. In den meisten F√§llen ist dieser Mechanismus am einfachsten zu bedienen. Ein Beispiel f√ºr Client- und Server-Code finden Sie im Verzeichnis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">client_server</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Benutzer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet die Anwendung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">select.poll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><i><font style="vertical-align: inherit;">indem er</font></i><font style="vertical-align: inherit;"> den Server-Socket explizit abfragt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Client-Sockets verwenden es implizit in dem Sinne, dass die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Streaming-Engine </font><font style="vertical-align: inherit;">es direkt verwendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitte beachten Sie, dass </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">socket.getaddrinfo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> derzeit gesperrt ist. Die Zeit im Beispielcode ist minimal, aber wenn eine DNS-Suche erforderlich ist, kann der Sperrzeitraum erheblich sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein zweiter Ansatz zur Socket-Programmierung ist die Verwendung nicht blockierender Sockets. Dies erh√∂ht die Komplexit√§t, ist jedoch in einigen Anwendungen erforderlich, insbesondere wenn die Verbindung √ºber WLAN erfolgt (siehe unten). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Zeitpunkt dieser Ver√∂ffentlichung (M√§rz 2019) befand sich die TLS-Unterst√ºtzung f√ºr nicht blockierende Sockets in der Entwicklung. Ihr genauer Status ist mir unbekannt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verwendung von nicht blockierenden Steckdosen erfordert viel Liebe zum Detail. Wenn aufgrund der Serverlatenz nicht blockierende Lesevorg√§nge auftreten, kann nicht garantiert werden, dass alle (oder einige) der angeforderten Daten zur√ºckgegeben werden. Ebenso k√∂nnen Eintr√§ge nicht vollst√§ndig sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher m√ºssen asynchrone Lese- und Schreibmethoden iterativ eine nicht blockierende Operation ausf√ºhren, bis die erforderlichen Daten gelesen oder geschrieben wurden. In der Praxis kann eine Zeit√ºberschreitung erforderlich sein, um Serverausf√§lle zu beheben. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine weitere Komplikation ist, dass der ESP32-Port Probleme hatte, die f√ºr einen fehlerfreien Betrieb ziemlich unangenehme Einbr√ºche erforderten. Ich habe nicht getestet, ob dies noch der Fall ist. </font><a href="" rel="nofollow"><i><b><font style="vertical-align: inherit;">Sock_nonblock.py-</font></b></i></a></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modul</font></font><a href="" rel="nofollow"><i><b><font style="vertical-align: inherit;"></font></b></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">veranschaulicht die erforderlichen Methoden. Dies ist keine funktionierende Demo und die Entscheidungen sind wahrscheinlich anwendungsabh√§ngig. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.6.1 Probleme mit WiFi</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Streaming-Mechanismus </font><b><font style="vertical-align: inherit;">ist</font></b><font style="vertical-align: inherit;"> nicht die beste Option zum Erkennen von WiFi-Ausf√§llen. Ich fand es notwendig, nicht blockierende Sockets zu verwenden, um einen ausfallsicheren Betrieb zu gew√§hrleisten und den Client bei Fehlern erneut zu verbinden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem </font></font><a href="" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokument</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden die Probleme beschrieben, auf die ich in WiFi-Anwendungen gesto√üen bin, die Sockets f√ºr l√§ngere Zeit offen halten, und die L√∂sung skizziert. </font></font><br><br> <a href="http://guthub.com/peterhinch/micropython-mqtt" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pltcm</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bietet einen robusten asynchronen MQTT-Client, der die Nachrichtenintegrit√§t bei WLAN-Ausf√§llen gew√§hrleistet. Eine einfache asynchrone serielle Vollduplex-Verbindung zwischen einem drahtlosen Client und einem verdrahteten Server mit garantierter Nachrichten√ºbermittlung wird beschrieben. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.7 Argumente des Konstruktors f√ºr Ereignisschleifen</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein kleiner Fehler kann auftreten, wenn Sie eine Ereignisschleife mit Werten erstellen m√ºssen, die von den Standardwerten abweichen. Eine solche Schleife muss deklariert werden, bevor ein anderer Code mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyncio ausgef√ºhrt wird,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> da diese Werte in diesem Code m√∂glicherweise erforderlich sind. Andernfalls wird der Code mit den Standardwerten initialisiert:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> some_module bar = some_module.Bar() <span class="hljs-comment"><span class="hljs-comment">#   get_event_loop() #     loop = asyncio.get_event_loop(runq_len=40, waitq_len=40)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da beim Importieren eines Moduls Code ausgef√ºhrt werden kann, ist es am sichersten, eine Ereignisschleife unmittelbar nach dem Import von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu instanziieren </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio loop = asyncio.get_event_loop(runq_len=<span class="hljs-number"><span class="hljs-number">40</span></span>, waitq_len=<span class="hljs-number"><span class="hljs-number">40</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> some_module bar = some_module.Bar() <span class="hljs-comment"><span class="hljs-comment"># get_event_loop()   </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Schreiben von Modulen zur Verwendung durch andere Programme ziehe ich es vor, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code </font><font style="vertical-align: inherit;">beim Import </font><b><font style="vertical-align: inherit;">nicht</font></b><font style="vertical-align: inherit;"> auszuf√ºhren </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Schreiben Sie Funktionen und Methoden, um auf eine Ereignisschleife als Argument zu warten. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dann sicher, dass nur Anwendungen der obersten Ebene </font><i><font style="vertical-align: inherit;">get_event_loop aufrufen</font></i><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> my_module <span class="hljs-comment"><span class="hljs-comment">#      loop = asyncio.get_event_loop(runq_len=40, waitq_len=40) bar = my_module.Bar(loop)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Problem wird </font></font><a href="http://github.com/micropython/micropython-lib/issues/295" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diskutiert </font><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 Notizen f√ºr Anf√§nger</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diese Notizen richten sich an Anf√§nger in asynchronem Code. Sie beginnen mit einer Beschreibung der Probleme, die Planer zu l√∂sen versuchen, und geben einen √úberblick √ºber </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L√∂sungsansatz von </font><b><font style="vertical-align: inherit;">uasyncio</font></b><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Abschnitt 8.5 werden die relativen Vorteile der Module </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und _ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">thread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sowie </font><font style="vertical-align: inherit;">die </font><b><font style="vertical-align: inherit;">Gr√ºnde erl√§utert</font></b><font style="vertical-align: inherit;"> , warum Sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coroutinen </font><b><font style="vertical-align: inherit;">mit</font></b><font style="vertical-align: inherit;"> proaktiver Zeitplanung (_thread) </font><font style="vertical-align: inherit;">m√∂glicherweise bevorzugen </font><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.1 Problem 1: Ereignisschleifen</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine typische Firmware-Anwendung arbeitet ununterbrochen und sollte gleichzeitig auf externe Ereignisse reagieren, zu denen eine Spannungs√§nderung am ADC, das Auftreten eines Hardware-Interrupts oder ein im UART empfangenes Symbol oder auf Daten, die auf dem Sockel verf√ºgbar sind, geh√∂ren k√∂nnen. Diese Ereignisse treten asynchron auf, und der Code sollte in der Lage sein, unabh√§ngig von der Reihenfolge, in der sie auftreten, zu reagieren. Dar√ºber hinaus k√∂nnen zeitabh√§ngige Aufgaben erforderlich sein, z. B. das Blinken von LEDs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die naheliegende M√∂glichkeit hierf√ºr ist die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasycio-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ereignisschleife </font><font style="vertical-align: inherit;">. Dieses Beispiel ist kein praktischer Code, sondern dient zur Veranschaulichung der allgemeinen Form der Ereignisschleife.</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">event_loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> led_1_time = <span class="hljs-number"><span class="hljs-number">0</span></span> led_1_period = <span class="hljs-number"><span class="hljs-number">20</span></span> led_2_time = <span class="hljs-number"><span class="hljs-number">0</span></span> led_2_period = <span class="hljs-number"><span class="hljs-number">30</span></span> switch_state = switch.state() <span class="hljs-comment"><span class="hljs-comment">#    while True: time_now = utime.time() if time_now &gt;= led_1_time: #  LED #1 led1.toggle() led_1_time = time_now + led_1_period if time_now &gt;= led_2_time: #  LED #2 led2.toggle() led_2_time = time_now + led_2_period #    LEDs if switch.value() != switch_state: switch_state = switch.value() #  - if uart.any(): #    UART</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine solche Schleife funktioniert f√ºr einfache Beispiele, aber mit zunehmender Anzahl von Ereignissen wird der Code schnell umst√§ndlich. Sie verletzen auch die Prinzipien der objektorientierten Programmierung, indem sie den gr√∂√üten Teil der Programmlogik an einem Ort kombinieren, anstatt Code mit einem gesteuerten Objekt zu verkn√ºpfen. Wir wollen eine Klasse f√ºr eine blinkende LED entwickeln, die in ein Modul eingef√ºgt und importiert werden kann. Der OOP-Ansatz f√ºr das Blinken von LEDs k√∂nnte folgenderma√üen aussehen:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pyb <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LED_flashable</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, led_no)</span></span></span><span class="hljs-function">:</span></span> self.led = pyb.LED(led_no) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, period)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: self.led.toggle() <span class="hljs-comment"><span class="hljs-comment"># -     period, #         </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem Scheduler in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k√∂nnen Sie solche Klassen erstellen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.2 Problem 2: Blockierungsmethoden</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Angenommen, Sie m√ºssen eine bestimmte Anzahl von Bytes aus einem Socket lesen. Wenn Sie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">socket.read (n)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> standardm√§√üig mit einem blockierenden Socket </font><font style="vertical-align: inherit;">aufrufen </font><font style="vertical-align: inherit;">, wird es "blockieren" ( </font><i><font style="vertical-align: inherit;">dh</font></i><font style="vertical-align: inherit;"> es kann nicht beendet werden), bis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bytes </font><font style="vertical-align: inherit;">empfangen werden </font><font style="vertical-align: inherit;">. W√§hrend dieser Zeit reagiert die Anwendung nicht auf andere Ereignisse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem nicht blockierenden </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Socket </font><b><font style="vertical-align: inherit;">k√∂nnen</font></b><font style="vertical-align: inherit;"> Sie eine asynchrone </font><b><font style="vertical-align: inherit;">Lesemethode</font></b><font style="vertical-align: inherit;"> schreiben. Eine Aufgabe, f√ºr die Daten erforderlich sind, wird (notwendigerweise) blockiert, bis sie empfangen werden. In diesem Zeitraum werden jedoch andere Aufgaben ausgef√ºhrt, sodass die Anwendung weiterhin reagiert.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.3. Uasyncio-Ans√§tze</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die n√§chste Klasse verf√ºgt √ºber eine LED, die ein- und ausgeschaltet werden kann. Sie kann auch bei jeder Geschwindigkeit blinken. Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LED_async-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Instanz </font><font style="vertical-align: inherit;">verwendet die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausf√ºhrungsmethode</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die f√ºr den kontinuierlichen Betrieb verwendet werden kann. Das Verhalten von LEDs kann mit den Methoden </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on (), off ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flash (secs)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gesteuert werden </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pyb <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LED_async</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, led_no)</span></span></span><span class="hljs-function">:</span></span> self.led = pyb.LED(led_no) self.rate = <span class="hljs-number"><span class="hljs-number">0</span></span> loop = asyncio.get_event_loop() loop.create_task(self.run()) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.rate &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep_ms(<span class="hljs-number"><span class="hljs-number">200</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: self.led.toggle() <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep_ms(int(<span class="hljs-number"><span class="hljs-number">500</span></span> / self.rate)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, rate)</span></span></span><span class="hljs-function">:</span></span> self.rate = rate <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.led.on() self.rate = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">off</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.led.off() self.rate = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist zu beachten, dass </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on (), off ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flash ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> normale synchrone Methoden sind. Sie √§ndern das Verhalten der LED, kehren aber sofort zur√ºck. Das Blinken erfolgt "im Hintergrund". Dies wird im n√§chsten Abschnitt ausf√ºhrlich erl√§utert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Klasse entspricht dem OOP-Prinzip, bei dem die dem Ger√§t zugeordnete Logik in der Klasse gespeichert wird. Gleichzeitig stellt die Verwendung von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sicher, dass die Anwendung auf andere Ereignisse reagieren kann, w√§hrend die LED blinkt. Das folgende Programm blinkt mit vier </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyboard-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LEDs </font><font style="vertical-align: inherit;">mit unterschiedlichen Frequenzen und reagiert auch auf die USR-Taste, die es vervollst√§ndigt.</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pyb <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uasyncio <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> led_async <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> LED_async <span class="hljs-comment"><span class="hljs-comment"># ,   async def killer(): # ,      sw = pyb.Switch() while not sw.value(): await asyncio.sleep_ms(100) leds = [LED_async(n) for n in range(1, 4)] for n, led in enumerate(leds): led.flash(0.7 + n/4) loop = asyncio.get_event_loop() loop.run_until_complete(killer())</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Gegensatz zum ersten Beispiel einer Ereignisschleife befindet sich die dem Schalter zugeordnete Logik in einer Funktion, die von der Funktionalit√§t der LED getrennt ist. </font><font style="vertical-align: inherit;">Achten Sie auf den Code, der zum Starten des Schedulers verwendet wird:</font></font><br><br><pre> <code class="python hljs">loop = asyncio.get_event_loop() loop.run_until_complete(killer()) <span class="hljs-comment"><span class="hljs-comment">#    #       killer (), #   .</span></span></code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.4 Planung in uasyncio </font></font></b> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python 3.5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unterst√ºtzen das Konzept einer asynchronen Funktion, die auch als Coroutine oder Task bezeichnet wird. </font><font style="vertical-align: inherit;">Eine Coroutine muss mindestens eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wait-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anweisung enthalten </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>): print(<span class="hljs-string"><span class="hljs-string">'Hello world.'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Funktion druckt zehnmal im Sekundentakt eine Nachricht. W√§hrend die Funktion in Erwartung einer Verz√∂gerung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">angehalten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird </font><font style="vertical-align: inherit;">, f√ºhrt der </font><i><font style="vertical-align: inherit;">Asyncio-Scheduler</font></i><font style="vertical-align: inherit;"> andere Aufgaben aus, wodurch die Illusion entsteht, sie gleichzeitig auszuf√ºhren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Coroutine-Probleme </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf asyncio.sleep_ms ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font><i><font style="vertical-align: inherit;">asyncio.sleep () </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">warten, wird die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aktuelle Task angehalten und in eine Warteschlange gestellt, die nach Zeit geordnet ist, und die Ausf√ºhrung wird mit der Task am Anfang der Warteschlange fortgesetzt. Die Warteschlange ist so konzipiert, dass selbst wenn der angegebene Ruhemodus Null ist, andere relevante Aufgaben ausgef√ºhrt werden, bis der Strom wieder aufgenommen wird. Dies ist eine ‚Äûehrliche Kreislaufplanung‚Äú. Es ist g√§ngige Praxis, </font><i><font style="vertical-align: inherit;">asyncio.sleep (0) -Schleifen abzuwarten</font></i><font style="vertical-align: inherit;"> .</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit die Task die Ausf√ºhrung nicht verz√∂gert. </font><font style="vertical-align: inherit;">Die folgende Schleife wartet darauf, dass eine andere Task die globale </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flag-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variable setzt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Leider monopolisiert es den Prozessor und verhindert den Start anderer Coroutinen:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bad_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> flag <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> flag: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-comment"><span class="hljs-comment">#  flag = False #    </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem hierbei ist </font><font style="vertical-align: inherit;">, dass keine andere Task gestartet </font><font style="vertical-align: inherit;">wird, bis die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flagis-False-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schleife </font><i><font style="vertical-align: inherit;">die</font></i><font style="vertical-align: inherit;"> Steuerung an den Scheduler </font><i><font style="vertical-align: inherit;">√ºbergibt</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Der richtige Ansatz:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">good_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> flag <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> flag: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">#  flag = False #    </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus dem gleichen Grund ist es √ºblich, Verz√∂gerungen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">festzulegen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , z. B. </font><i><font style="vertical-align: inherit;">utime.sleep (1),</font></i><font style="vertical-align: inherit;"> da andere Tasks f√ºr 1 s blockiert werden. Es ist richtiger, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wait asyncio.sleep (1) zu verwenden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass Verz√∂gerungen, die von den Methoden </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uasyncio </font></font></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sleep</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sleep_ms</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> generiert werden, </font><font style="vertical-align: inherit;">die angegebene Zeit √ºberschreiten k√∂nnen. Dies liegt an der Tatsache, dass andere Aufgaben w√§hrend der Verz√∂gerung ausgef√ºhrt werden. Nach Ablauf der Verz√∂gerungszeit wird die Ausf√ºhrung erst fortgesetzt, wenn die ausgef√ºhrten Aufgaben </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">warten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder beendet sind. Eine wohlerzogene Coroutine wird immer das </font><i><font style="vertical-align: inherit;">Warten</font></i><font style="vertical-align: inherit;"> erkl√§ren</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in regelm√§√üigen Abst√§nden. Wenn eine genaue Verz√∂gerung erforderlich ist, insbesondere wenn eine weniger als einige ms betr√§gt, muss m√∂glicherweise </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utime.sleep_us (us) verwendet werden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.5 Warum kollaboratives, nicht threadbasiertes Scheduling ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_thread</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die anf√§ngliche Reaktion von Anf√§ngern auf die Idee, Koroutinen mitzuplanen, ist oft entt√§uschend. Sicherlich ist Streaming-Planung besser? Warum sollte ich die Kontrolle explizit aufgeben, wenn die virtuelle Python-Maschine dies f√ºr mich tun kann? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei eingebetteten Systemen bietet das Kollaborationsmodell zwei Vorteile.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das erste ist geringes Gewicht. Es ist m√∂glich, dass eine gro√üe Anzahl von Coroutinen vorhanden ist, da suspendierte Coroutinen im Gegensatz zu geplanten Threads weniger Platz beanspruchen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens werden auf diese Weise einige der subtilen Probleme im Zusammenhang mit der Streaming-Planung vermieden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Praxis ist das kollaborative Multitasking weit verbreitet, insbesondere in Benutzeroberfl√§chenanwendungen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zur Verteidigung des Streaming-Planungsmodells zeige ich einen Vorteil: Wenn jemand schreibt</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range ( <span class="hljs-number"><span class="hljs-number">1000000</span></span> ): <span class="hljs-comment"><span class="hljs-comment">#  - </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere Aufgaben werden nicht blockiert. Das Kollaborationsmodell geht davon aus, dass die Schleife der Steuerung jeder Aufgabe explizit eine bestimmte Anzahl von Iterationen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zuweisen soll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , z. B. Code in eine Coroutine </font><i><font style="vertical-align: inherit;">einf√ºgen</font></i><font style="vertical-align: inherit;"> und in regelm√§√üigen Abst√§nden den </font><i><font style="vertical-align: inherit;">Befehl wait asyncio.sleep (0)</font></i><font style="vertical-align: inherit;"> ausgeben </font><i><font style="vertical-align: inherit;">soll</font></i><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leider verblasst dieser Vorteil im Vergleich zu den Nachteilen. Einige davon sind in der Dokumentation zum Schreiben von </font></font><a href="http://docs.micropython.org/en/latest/reference/isr_rules.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interrupt-Handlern beschrieben.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In einem Streaming-Planungsmodell kann jeder Thread jeden anderen Thread unterbrechen und die Daten √§ndern, die in anderen Threads verwendet werden k√∂nnen. In der Regel ist es viel einfacher, eine Sperre zu finden und zu beheben, die aufgrund eines Fehlers auftritt, der kein Ergebnis liefert, als manchmal sehr subtile und selten auftretende Fehler zu erkennen, die in Code auftreten k√∂nnen, der im Rahmen eines Modells mit Streaming-Planung geschrieben wurde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfach ausgedr√ºckt, wenn Sie eine </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroPython-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coroutine schreiben </font><font style="vertical-align: inherit;">, k√∂nnen Sie sicher sein, dass die Variablen nicht pl√∂tzlich von einer anderen Coroutine ge√§ndert werden: Ihre Coroutine hat die volle Kontrolle, bis sie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wieder asyncio.sleep (0) erwartet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Denken Sie daran, dass Interrupt-Handler pr√§ventiv sind. Dies gilt sowohl f√ºr Hardware- als auch f√ºr Software-Interrupts, die an einer beliebigen Stelle in Ihrem Code auftreten k√∂nnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine eloquente Diskussion zu Fragen der Streaming-Planung finden Sie </font></font><a href="http://glyph.twistedmatrix.com/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.6 Interaktion</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In nicht trivialen Anwendungen m√ºssen Coroutinen interagieren. Es k√∂nnen herk√∂mmliche </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methoden verwendet werden </font><font style="vertical-align: inherit;">. Dazu geh√∂ren die Verwendung globaler Variablen oder die Deklaration von Coroutinen als Objektmethoden: Sie k√∂nnen Instanzvariablen gemeinsam nutzen. Alternativ kann ein ver√§nderbares Objekt als Argument an eine Coroutine √ºbergeben werden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr das Streaming-Planungsmodell m√ºssen Spezialisten sicherstellen, dass Klassen eine sichere Verbindung bereitstellen. </font><font style="vertical-align: inherit;">In einem Kollaborationsmodell ist dies selten erforderlich. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.7. </font><font style="vertical-align: inherit;">Poll ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Polling</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einige Hardware - </font><font style="vertical-align: inherit;">Ger√§t wie ein Beschleunigungsmesser </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pyboard</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , unterst√ºtzen keine Unterbrechungen und daher abgefragt werden soll ( das </font><font style="vertical-align: inherit;">hei√üt periodisch √ºberpr√ºft). </font><font style="vertical-align: inherit;">Polling kann auch in Verbindung mit Interrupt-Handlern verwendet werden: Der Interrupt-Handler verwaltet die Ausr√ºstung und setzt ein Flag. </font><font style="vertical-align: inherit;">Die Coroutine fragt das Flag ab - wenn es gesetzt ist, werden Daten verarbeitet und das Flag zur√ºckgesetzt. </font><font style="vertical-align: inherit;">Der beste Ansatz ist die Verwendung der </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Event-</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><font style="vertical-align: inherit;">.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484472/">https://habr.com/ru/post/de484472/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484462/index.html">Scraping Github: Suche nach "Geheimnissen", die es zu entwickeln gilt</a></li>
<li><a href="../de484464/index.html">Japanische Motorradauktionen, wie das alles passiert</a></li>
<li><a href="../de484466/index.html">Gemeinsame JavaScript-Versprechen, √ºber die jeder Bescheid wissen sollte</a></li>
<li><a href="../de484468/index.html">Rote Unternehmenskultur ist das Hauptproblem des russischen Gesch√§fts (Teil 2)</a></li>
<li><a href="../de484470/index.html">Erweiterbare Erweiterungen in JavaScript</a></li>
<li><a href="../de484480/index.html">Die Kapitalisierung der 5 gr√∂√üten US-Technologieunternehmen √ºberstieg 5 Billionen US-Dollar</a></li>
<li><a href="../de484482/index.html">Ein kleines Bildungsprogramm zur Wasseraufbereitung</a></li>
<li><a href="../de484484/index.html">Ubuntu ist nicht das beste Desktop-Linux</a></li>
<li><a href="../de484486/index.html">Ein Computer, der sich weigert zu sterben</a></li>
<li><a href="../de484488/index.html">Wie verwirrend ist ein Quantensystem? Die Antwort ist m√∂glicherweise nicht berechenbar.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>