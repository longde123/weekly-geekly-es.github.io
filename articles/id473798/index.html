<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßùüèª ‚öïÔ∏è üö® Pemrograman berorientasi protokol. Bagian 1 ü§∂üèø üç≠ üíÖüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mari kita lihat lebih dekat topik pemrograman berorientasi protokol. Untuk kenyamanan, materi itu dibagi menjadi tiga bagian. 


 Bahan ini adalah ter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemrograman berorientasi protokol. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473798/"><p>  Mari kita lihat lebih dekat topik pemrograman berorientasi protokol.  Untuk kenyamanan, materi itu dibagi menjadi tiga bagian. </p><br><p>  Bahan ini adalah terjemahan komentar dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">presentasi WWDC 2016</a> .  Bertentangan dengan kepercayaan umum bahwa hal-hal "di bawah tenda" harus tetap ada, kadang-kadang sangat berguna untuk mencari tahu apa yang terjadi di sana.  Ini akan membantu untuk menggunakan item dengan benar dan untuk tujuan yang dimaksud. </p><a name="habracut"></a><br><p>  Bagian ini akan membahas masalah-masalah utama dalam pemrograman berorientasi objek dan bagaimana POP memecahkannya.  Semuanya akan dipertimbangkan dalam realitas bahasa Swift, detailnya akan dianggap "kompartemen mesin" dari protokol. </p><br><h2 id="problemy-oop-i-zachem-nam-nuzhno-pop">  Masalah OOP dan mengapa kita membutuhkan POP </h2><br><p>  Diketahui bahwa dalam OOP ada sejumlah kelemahan yang bisa ‚Äúmembebani‚Äù pelaksanaan program.  Pertimbangkan yang paling eksplisit dan umum: </p><br><ol><li>  Alokasi: Stack or Heap? </li><li>  Penghitungan referensi: lebih atau kurang? </li><li>  Metode pengiriman: statis atau dinamis? </li></ol><br><h3 id="11-allocation---stack">  1.1 Alokasi - Stack </h3><br><p> Stack adalah struktur data yang cukup sederhana dan primitif.  Kita bisa meletakkan di atas tumpukan (push), kita dapat mengambil dari atas tumpukan (pop).  Kesederhanaannya adalah bahwa hanya itu yang bisa kita lakukan dengannya. </p><br><p>  Untuk mempermudah, mari kita asumsikan bahwa setiap tumpukan memiliki variabel (penunjuk tumpukan).  Ini digunakan untuk melacak bagian atas tumpukan dan menyimpan integer (Integer).  Maka kecepatan operasi dengan stack sama dengan kecepatan menulis ulang Integer ke dalam variabel ini. </p><br><p>  Tekan - taruh di atas tumpukan, tambah penunjuk tumpukan; </p><br><p>  pop - kurangi stack pointer. </p><br><h3 id="tipy-znacheniy">  Jenis nilai </h3><br><p>  Mari kita pertimbangkan prinsip-prinsip operasi tumpukan di Swift menggunakan struktur (struct). </p><br><p>  Dalam Swift, tipe nilai adalah struktur (struct) dan enumerasi (enum), dan tipe referensi adalah kelas (kelas) dan fungsi / penutupan (func).  Tipe nilai disimpan di Stack, tipe referensi disimpan di Heap. </p><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {...} } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point1 = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">// (1) let point2 = point1 // (2) point2.x = 5 // (3) //  point1 //  point2 // (4)</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/tq/vj/8y/tqvj8yfygyvbneaqfwwuiig8on0.png"></p><br><ol><li>  Kami menempatkan struktur pertama di Stack </li><li>  Salin isi dari struktur pertama </li><li>  Ubah memori struktur kedua (yang pertama tetap utuh) </li><li>  Akhir penggunaan.  Memori bebas </li></ol><br><h3 id="12-allocation---heap">  1.2 Alokasi - Heap </h3><br><p>  Heap adalah struktur data seperti pohon.  Topik implementasi tumpukan tidak akan terpengaruh di sini, tetapi kami akan mencoba membandingkannya dengan tumpukan. </p><br><p>  Mengapa, jika mungkin, apakah layak menggunakan Stack daripada Heap?  Inilah alasannya: </p><br><ul><li>  penghitungan referensi </li><li>  administrasi memori bebas dan pencariannya untuk alokasi </li><li>  menulis ulang memori untuk deallokasi </li></ul><br><p>  Semua ini hanyalah sebagian kecil dari apa yang membuat Heap bekerja dan jelas menimbangnya dibandingkan dengan Stack. </p><br><p>  Misalnya, ketika kita membutuhkan memori bebas di Stack, kita cukup mengambil nilai stack-pointer dan meningkatkannya (karena semua yang di atas stack-pointer di Stack adalah memori bebas) - O (1) adalah operasi yang konstan dalam waktu. </p><br><p>  Ketika kita membutuhkan memori bebas pada Heap, kita mulai mencarinya menggunakan algoritma pencarian yang sesuai dalam struktur pohon data - dalam kasus terbaik, kita memiliki operasi O (logn), yang tidak konstan dalam waktu dan tergantung pada implementasi spesifik. <br>  Faktanya, Heap jauh lebih rumit: pekerjaannya disediakan oleh sejumlah mekanisme lain yang hidup di dalam usus sistem operasi. </p><br><p>  Perlu juga dicatat bahwa penggunaan Heap dalam mode multithreading memperburuk situasi secara signifikan, karena itu perlu untuk memastikan sinkronisasi sumber daya bersama (memori) untuk utas yang berbeda.  Ini dicapai dengan menggunakan kunci (semaphores, spinlocks, dll.). </p><br><h3 id="ssylochnye-tipy">  Jenis Referensi </h3><br><p>  Mari kita lihat bagaimana Heap bekerja di Swift menggunakan kelas. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {...} } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point1 = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">// (1) let point2 = point1 // (2) point2.x = 5 // (3) //  point1 //  point2 // (4)</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/o4/ct/y3/o4cty3n_4gizx4o0-amtg2f5tqm.png"></p><br><p>  1. Tempatkan tubuh kelas di Heap.  Tempatkan pointer ke tubuh ini di tumpukan. </p><br><ol><li>  Salin pointer yang merujuk ke tubuh kelas </li><li>  Kami mengubah tubuh kelas </li><li>  Akhir penggunaan.  Memori bebas </li></ol><br><h3 id="13-allocation---nebolshoy-i-realnyy-primer">  1.3 Alokasi - Contoh Kecil dan "Nyata" </h3><br><p>  Dalam beberapa situasi, memilih Stack tidak hanya menyederhanakan penanganan memori, tetapi juga meningkatkan kualitas kode.  Pertimbangkan sebuah contoh: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> red, green, blue } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Orientation</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">left</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">right</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tail</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">none</span></span>, tail, bubble } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cache: [<span class="hljs-type"><span class="hljs-type">String</span></span>: <span class="hljs-type"><span class="hljs-type">UIImage</span></span>] = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeBalloon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> color: Color, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation: Orientation, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tail: Tail)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIImage</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = <span class="hljs-string"><span class="hljs-string">"\(color):\(orientation):\(tail)"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> image = cache[key] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> image } ... }</code> </pre> <br><p>  Jika kamus cache memiliki nilai dengan kunci tombol, maka fungsi hanya akan mengembalikan UIImached cache. </p><br><h3 id="problemy-etogo-koda">  Masalah kode ini adalah: </h3><br><p>  Bukan praktik yang baik adalah dengan menggunakan String sebagai kunci dalam cache, karena String pada akhirnya "bisa berubah menjadi apa pun." </p><br><p>  String adalah struktur copy-on-write, untuk mengimplementasikan dinamismenya, String menyimpan semua Character-nya di Heap.  Jadi, String adalah struktur, dan disimpan di Stack, tetapi ia menyimpan semua isinya pada Heap. </p><br><p>  Ini diperlukan untuk memberikan kemampuan mengubah garis (hapus bagian dari garis, tambahkan baris baru ke baris ini).  Jika semua karakter string disimpan di Stack, maka manipulasi seperti itu tidak mungkin dilakukan.  Misalnya, dalam C, string bersifat statis, yang berarti bahwa ukuran string tidak dapat ditingkatkan dalam runtime karena semua konten disimpan di Stack.  Untuk parsing garis copy-on-write dan lebih detail di Swift, silakan klik di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><h3 id="reshenie">  Solusi: </h3><br><ol><li><p>  Gunakan struktur yang cukup jelas di sini sebagai ganti string: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Attributes</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hashable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> color: <span class="hljs-type"><span class="hljs-type">Color</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> orientation: <span class="hljs-type"><span class="hljs-type">Orientation</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tail: <span class="hljs-type"><span class="hljs-type">Tail</span></span> }</code> </pre> <br></li><li><p>  Ubah kamus ke: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cache: [<span class="hljs-type"><span class="hljs-type">Attributes</span></span>: <span class="hljs-type"><span class="hljs-type">UIImage</span></span>] = []</code> </pre> <br></li><li><p>  Singkirkan String </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = <span class="hljs-type"><span class="hljs-type">Attributes</span></span>(color: color, orientation: orientation, tail: tail)</code> </pre> <br></li></ol><br><p>  Dalam struktur Atribut, semua properti disimpan di Stack, karena enum disimpan di Stack.  Ini berarti bahwa tidak ada penggunaan Heap secara implisit di sini, dan sekarang kunci untuk kamus cache didefinisikan dengan sangat tepat, yang meningkatkan keamanan dan kejelasan kode ini.  Kami juga menyingkirkan penggunaan Heap secara implisit. </p><br><p>  <strong>Putusan:</strong> Stack jauh lebih mudah dan lebih cepat daripada Heap - pilihan untuk sebagian besar situasi sudah jelas. </p><br><h3 id="2-podschet-ssylok">  2. Penghitungan Referensi </h3><br><p>  Untuk apa? </p><br><p>  Swift harus tahu kapan dimungkinkan untuk membebaskan sepotong memori di Heap, ditempati, misalnya, dengan instance dari kelas atau fungsi.  Ini diimplementasikan melalui mekanisme penghitungan tautan - setiap instance (kelas atau fungsi) yang dihosting di Heap memiliki variabel yang menyimpan jumlah tautan ke sana.  Ketika tidak ada tautan ke sebuah instance, Swift memutuskan untuk membebaskan sebagian memori yang dialokasikan untuk itu. </p><br><p>  Perlu dicatat bahwa untuk implementasi "berkualitas tinggi" dari mekanisme ini dibutuhkan lebih banyak sumber daya daripada untuk meningkatkan dan mengurangi Stack-pointer.  Hal ini disebabkan oleh fakta bahwa nilai jumlah tautan dapat meningkat dari utas yang berbeda (karena Anda bisa merujuk ke kelas atau fungsi dari utas yang berbeda).  Juga, jangan lupa tentang perlunya memastikan sinkronisasi sumber daya bersama (jumlah variabel tautan) untuk utas berbeda (spinlocks, semaphores, dll.). </p><br><p>  Stack: menemukan memori bebas dan membebaskan memori bekas - operasi stack-pointer </p><br><p>  Heap: mencari memori bebas dan membebaskan memori yang digunakan - algoritma pencarian pohon dan penghitungan referensi. </p><br><p>  Dalam struktur Atribut, semua properti disimpan di Stack, karena enum disimpan di Stack.  Ini berarti bahwa tidak ada penggunaan Heap secara implisit di sini, dan sekarang kunci untuk kamus cache didefinisikan dengan sangat tepat, yang meningkatkan keamanan dan kejelasan kode ini.  Kami juga menyingkirkan penggunaan Heap secara implisit. </p><br><h3 id="psevdokod">  Kode palsu </h3><br><p>  Pertimbangkan sepotong kodesemu kecil untuk menunjukkan cara penghitungan tautan bekerja: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> refCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {...} <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(...) { ... <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.refCount = <span class="hljs-number"><span class="hljs-number">1</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point1 = <span class="hljs-type"><span class="hljs-type">Point</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point2 = point1 retain(point2) <span class="hljs-comment"><span class="hljs-comment">// retain() -  refCount  1    point2.x = 5 //  `point1` release(point1) // release() -  refCount  1 //  `point2` release(point2)</span></span></code> </pre> <br><h3 id="struct">  Struct </h3><br><p>  Ketika bekerja dengan struktur, mekanisme seperti penghitungan referensi sama sekali tidak diperlukan: </p><br><ol><li>  struct tidak disimpan di Heap </li><li>  struct - disalin atas penugasan, karena itu, tidak ada referensi </li></ol><br><h3 id="kopirovanie-ssylok">  Salin tautan </h3><br><p>  Sekali lagi, struct dan tipe nilai lainnya di Swift disalin setelah penugasan.  Jika struktur menyimpan tautan itu sendiri, mereka juga akan disalin: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Label</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> font: <span class="hljs-type"><span class="hljs-type">UIFont</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() { ... text.refCount = <span class="hljs-number"><span class="hljs-number">1</span></span> font.refCount = <span class="hljs-number"><span class="hljs-number">1</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> label = <span class="hljs-type"><span class="hljs-type">Label</span></span>(text: <span class="hljs-string"><span class="hljs-string">"Hi"</span></span>, font: font) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> label2 = label retain(label2.text._storage) <span class="hljs-comment"><span class="hljs-comment">//    `String`       Heap retain(label2.font) //  label release(label.text._storage) release(label.font) //  label2 release(label2.text._storage) release(label2.font)</span></span></code> </pre> <br><p>  label dan label2 berbagi contoh umum yang dihosting di Heap: </p><br><ul><li>  konten teks </li><li>  dan font </li></ul><br><p>  Jadi, jika struct menyimpan tautan dalam dirinya sendiri, maka ketika menyalin struktur ini, jumlah tautan berlipat ganda, yang, jika tidak perlu, secara negatif mempengaruhi "kemudahan" program. </p><br><h3 id="i-snova-realnyy-primer">  Dan lagi contoh "nyata": </h3><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Attachment</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fileUrl: <span class="hljs-type"><span class="hljs-type">URL</span></span> <span class="hljs-comment"><span class="hljs-comment">//   HEAP  let uuid: String //    HEAP  let mimeType: String //    HEAP  init?(fileUrl: URL, uuid: String, mimeType: String) { guard mimeType.isMimeType else { return nil } self.fileUrl = fileUrl self.uuid = uuid self.mimeType = mimeType } }</span></span></code> </pre> <br><p>  Masalah dari struktur ini adalah bahwa ia memiliki: </p><br><ol><li>  3 Alokasi tumpukan </li><li>  Karena String dapat berupa string apa pun, keamanan dan kejelasan kode dipengaruhi. </li></ol><br><p>  Pada saat yang sama, uuid dan mimeType adalah hal-hal yang didefinisikan secara ketat: </p><br><p>  uuid adalah string format xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx <br>  mimeType adalah tipe / ekstensi format string. </p><br><h3 id="reshenie-1">  Solusi </h3><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> uuid: <span class="hljs-type"><span class="hljs-type">UUID</span></span> <span class="hljs-comment"><span class="hljs-comment">// UUID  ,    Foundation</span></span></code> </pre> <br><p>  Dalam hal mimeType, enum berfungsi dengan baik: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MimeType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(rawValue: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> rawValue { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"image/jpeg"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = .jpeg <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"image/png"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = .png <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"image/gif"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = .gif <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> jpeg, png, gif }</code> </pre> <br><p>  Atau lebih baik dan lebih mudah: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MimeType</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> jpeg = <span class="hljs-string"><span class="hljs-string">"image/jpeg"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> png = <span class="hljs-string"><span class="hljs-string">"image/png"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> gif = <span class="hljs-string"><span class="hljs-string">"image/gif"</span></span> }</code> </pre> <br><p>  Dan jangan lupa ganti: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mimeType: <span class="hljs-type"><span class="hljs-type">MimeType</span></span></code> </pre> <br><h3 id="31-method-dispatch">  3.1 Metode Pengiriman </h3><br><ul><li>  ini adalah algoritma yang mencari kode metode yang dipanggil </li></ul><br><p>  Sebelum berbicara tentang implementasi mekanisme ini, ada baiknya menentukan apa ‚Äúpesan‚Äù dan ‚Äúmetode‚Äù dalam konteks ini: </p><br><ul><li>  pesan adalah nama yang kami kirim ke objek.  Argumen masih bisa dikirim bersama namanya. </li></ul><br><pre> <code class="swift hljs">circle.draw(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: origin)</code> </pre> <br><p>  Pesannya adalah draw - nama metode.  Objek penerima adalah lingkaran.  Asal juga argumen yang disahkan. </p><br><ul><li>  Metode adalah kode yang akan dikembalikan dalam menanggapi pesan. </li></ul><br><p>  Kemudian Metode Pengiriman adalah algoritma yang memutuskan metode mana yang harus diberikan kepada pesan tertentu. </p><br><h2 id="bolee-konkretno-o-method-dispatch-v-swift">  Lebih khusus tentang Metode Pengiriman di Swift </h2><br><p>  Karena kita dapat mewarisi dari kelas induk dan mengganti metode-metodenya, Swift harus tahu persis implementasi mana dari metode ini yang perlu dipanggil dalam situasi tertentu. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">me</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"parent"</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Child</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">me</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"child"</span></span>) } }</code> </pre> <br><p>  Buat beberapa contoh dan panggil metode saya: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parent = <span class="hljs-type"><span class="hljs-type">Parent</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> child = <span class="hljs-type"><span class="hljs-type">Child</span></span>() parent.me() <span class="hljs-comment"><span class="hljs-comment">// "parent" child.me() // "child"</span></span></code> </pre> <br><p>  Contoh yang cukup jelas dan sederhana.  Dan bagaimana jika: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> array: [<span class="hljs-type"><span class="hljs-type">Parent</span></span>] = [<span class="hljs-type"><span class="hljs-type">Child</span></span>(), <span class="hljs-type"><span class="hljs-type">Child</span></span>(), <span class="hljs-type"><span class="hljs-type">Parent</span></span>(), <span class="hljs-type"><span class="hljs-type">Child</span></span>()] array.forEach { $<span class="hljs-number"><span class="hljs-number">0</span></span>.me() <span class="hljs-comment"><span class="hljs-comment">// "child" "child" "parent" "child" }</span></span></code> </pre> <br><p>  Ini tidak begitu jelas dan membutuhkan sumber daya dan mekanisme tertentu untuk menentukan implementasi metode me yang benar.  Sumber daya adalah prosesor dan RAM.  Mekanisme adalah Metode Pengiriman. </p><br><p>  Dengan kata lain, Metode Pengiriman adalah bagaimana program menentukan implementasi metode mana yang akan dipanggil. </p><br><p>  Ketika suatu metode dipanggil dalam kode, implementasinya harus diketahui.  Jika dia diketahui <br>  Pada saat kompilasi, maka ini adalah Pengiriman Statis.  Jika implementasi ditentukan segera sebelum panggilan (di runtime, pada saat eksekusi kode), maka ini adalah Pengiriman Dinamis. </p><br><h3 id="32-method-dispatch---static-dispatch">  3.2 Metode Pengiriman - Pengiriman Statis </h3><br><p>  Paling optimal, karena: </p><br><ol><li>  Kompiler tahu blok kode mana (implementasi metode) yang akan dipanggil.  Berkat ini, ia dapat mengoptimalkan kode ini sebanyak mungkin dan menggunakan mekanisme seperti inlining. </li><li>  Juga, pada saat eksekusi kode, program hanya akan mengeksekusi blok kode ini yang diketahui oleh kompiler.  Tidak ada sumber daya dan waktu yang akan dihabiskan untuk menentukan implementasi metode yang benar, yang akan mempercepat pelaksanaan program. </li></ol><br><h3 id="33-method-dispatch---dynamic-dispatch">  3.3 Metode Pengiriman - Pengiriman Dinamis </h3><br><p>  Bukan yang paling optimal, karena: </p><br><ol><li>  Implementasi metode yang benar akan ditentukan pada saat pelaksanaan program, yang membutuhkan sumber daya dan waktu </li><li>  Tidak ada optimisasi kompiler yang keluar dari pertanyaan </li></ol><br><h3 id="34-method-dispatch---inlining">  3.4 Metode Pengiriman - Inlining </h3><br><p>  Mekanisme seperti inlining disebutkan, tetapi apakah itu?  Pertimbangkan sebuah contoh: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Point.draw implementation } } func drawAPoint(_ param: Point) { param.draw() } let point = Point(x: 0, y: 0) drawAPoint(point)</span></span></code> </pre> <br><ul><li>  Metode point.draw () dan fungsi drawAPoint akan diproses melalui Pengiriman Statis, karena tidak ada kesulitan dalam menentukan implementasi yang benar untuk kompiler (karena tidak ada warisan dan redefinisi tidak mungkin) </li><li>  karena kompiler tahu apa yang akan dilakukan, ia dapat mengoptimalkan ini.  Pertama mengoptimalkan drawAPoint, cukup mengganti pemanggilan fungsi dengan kodenya: </li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) point.draw()</code> </pre> <br><ul><li>  kemudian mengoptimalkan point.draw, karena penerapan metode ini juga dikenal: </li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Point.draw implementation</span></span></code> </pre> <br><p>  Kami membuat titik, mengeksekusi kode metode draw - kompiler hanya mengganti kode yang diperlukan untuk fungsi-fungsi ini alih-alih memanggilnya.  Dalam Pengiriman dinamis, ini akan sedikit lebih rumit. </p><br><h3 id="35-method-dispatch---inheritance-based-polymorphism">  3.5 Metode Pengiriman - Polimorfisme Berbasis Warisan </h3><br><p>  Mengapa saya perlu Pengiriman Dinamis?  Tanpa itu, tidak mungkin untuk mendefinisikan metode yang ditimpa oleh kelas anak.  Polimorfisme tidak akan mungkin terjadi.  Pertimbangkan sebuah contoh: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Line</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1, y1, x2, y2: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> drawables: [<span class="hljs-type"><span class="hljs-type">Drawable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> drawables { d.draw() }</code> </pre> <br><ul><li>  Array drawables dapat berisi Point dan Line </li><li>  secara intuitif, Pengiriman Statis tidak dimungkinkan di sini.  d dalam for loop bisa Line, atau mungkin Point.  Kompiler tidak dapat menentukan ini, dan masing-masing jenis memiliki implementasi undiannya sendiri </li></ul><br><p>  Lalu bagaimana cara Pengiriman Dinamis?  Setiap objek memiliki bidang tipe.  Jadi Point (...). Tipe akan sama dengan Point, dan Line (...). Tipe akan sama dengan Line.  Juga di suatu tempat di (statis) memori program adalah tabel (tabel virtual), di mana untuk setiap jenis ada daftar dengan implementasi metodenya. </p><br><p>  Di Objective-C, bidang tipe dikenal sebagai bidang isa.  Ini hadir pada setiap objek Objective-C (NSObject). </p><br><p>  Metode kelas disimpan dalam tabel virtual dan tidak memiliki gagasan tentang diri.  Untuk menggunakan diri di dalam metode ini, perlu dilewatkan di sana (diri). </p><br><p>  Dengan demikian, kompiler akan mengubah kode ini menjadi: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">self</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Point)</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Line</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">self</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Line)</span></span></span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> drawables: [<span class="hljs-type"><span class="hljs-type">Drawable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> drawables { vtable[d.type].draw(d) }</code> </pre> <br><p>  Pada saat eksekusi kode, Anda perlu melihat tabel virtual, temukan kelas d di sana, ambil metode draw dari daftar yang dihasilkan dan berikan objek tipe d sebagai self.  Ini adalah pekerjaan yang layak untuk doa metode sederhana, tetapi perlu untuk memastikan bahwa polimorfisme berfungsi.  Mekanisme serupa digunakan dalam bahasa OOP. </p><br><h2 id="method-dispatch---itog">  Metode Pengiriman - Ringkasan </h2><br><ul><li>  metode kelas diproses secara default melalui Dynamic Dispatch.  Tetapi tidak semua metode kelas perlu ditangani melalui Dynamic Dispatch.  Jika metode ini tidak diganti, maka Anda dapat menuju dengan kata kunci terakhir, dan kemudian kompiler akan tahu bahwa metode ini tidak dapat diganti dan akan memprosesnya melalui Pengiriman Statis </li><li>  metode non-kelas tidak dapat diganti (karena struct dan enum tidak mendukung warisan) dan diproses melalui Pengiriman Statis </li></ul><br><h2 id="problemy-oop---itog">  Masalah OOP - Ringkasan </h2><br><p>  Hal ini diperlukan untuk memperhatikan hal-hal sepele seperti: </p><br><ol><li>  Saat membuat sebuah instance: di mana ia akan ditempatkan? </li><li>  Ketika bekerja dengan contoh ini: bagaimana cara penghitungan tautan berfungsi? </li><li>  Saat memanggil metode: bagaimana prosesnya? </li></ol><br><p>  Jika kita membayar dinamisme tanpa menyadarinya dan tanpa membutuhkannya, maka ini akan berdampak negatif pada program yang sedang dilaksanakan. </p><br><p>  Polimorfisme adalah hal yang sangat penting dan berguna.  Saat ini, yang diketahui hanyalah polimorfisme di Swift yang terkait langsung dengan kelas dan tipe referensi.  Kami, pada gilirannya, mengatakan bahwa kelas lambat dan berat, dan strukturnya sederhana dan mudah.  Apakah polimorfisme diwujudkan melalui struktur yang mungkin?  Pemrograman berorientasi protokol dapat memberikan jawaban untuk pertanyaan ini. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473798/">https://habr.com/ru/post/id473798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473786/index.html">Pendaftaran untuk hackathon di Riga berakhir. Hadiah - pelatihan jangka pendek di PhysTech</a></li>
<li><a href="../id473788/index.html">Microprotein menemukan aspek yang tidak diketahui dari biologi modern</a></li>
<li><a href="../id473790/index.html">Splines dalam grafik 3d, opsi paling otomatis</a></li>
<li><a href="../id473794/index.html">Mobile Phishing - Ancaman Tak Berujung</a></li>
<li><a href="../id473796/index.html">Extender HDMI Optik. 300 meter</a></li>
<li><a href="../id473800/index.html">Radar bio, drone kardus dan sosis terbang - Nikita Kalinovsky tentang teknologi pencarian yang baik dan buruk</a></li>
<li><a href="../id473802/index.html">Alain Bombar - Jatuh demi Kemenangan</a></li>
<li><a href="../id473804/index.html">Berapa gaji SMP QA?</a></li>
<li><a href="../id473806/index.html">Ini adalah jenis internet yang kita inginkan: bagaimana media sosial berubah menjadi senjata yang mematikan</a></li>
<li><a href="../id473812/index.html">Intisari acara untuk profesional SDM di bidang TI pada November 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>