<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦈 ⬛️ 🤜🏿 Escribir un clon del motor Doom: leer información del mapa 🔎 🗻 🤲🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 El objetivo de este proyecto es crear un clon del motor DOOM utilizando recursos lanzados con Ultimate DOOM ( versión de Steam ). 

 Se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribir un clon del motor Doom: leer información del mapa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471552/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/423/35b/c2f42335b751d3bd9acec03251204977.png" alt="imagen"></div><br><h2>  Introduccion </h2><br>  El objetivo de este proyecto es crear un clon del motor DOOM utilizando recursos lanzados con Ultimate DOOM ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">versión de Steam</a> ). <br><br>  Se presentará en forma de tutorial: no quiero lograr el máximo rendimiento en el código, solo creo una versión funcional y más tarde comenzaré a mejorarlo y optimizarlo. <br><br>  No tengo experiencia en la creación de juegos o motores de juegos, y poca experiencia en la redacción de artículos, por lo que puede sugerir sus propios cambios o incluso reescribir completamente el código. <br><br>  Aquí hay una lista de recursos y enlaces. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Libro Game Engine Black Book: DOOM Fabien Sanglar</a> .  Uno de los mejores libros sobre DOOM internos. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Doom wiki</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Código fuente DOOM</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Código fuente Chocolate Doom</a> <br><a name="habracut"></a><br><h3>  Requisitos </h3><br><ul><li>  Visual Studio: cualquier IDE servirá;  Trabajaré en Visual Studio 2017. </li><li>  SDL2: bibliotecas. </li><li>  DOOM: una copia de la versión Steam de Ultimate DOOM, solo necesitamos un archivo WAD de él. </li></ul><br><h3>  Opcional </h3><br><ul><li>  Slade3: una buena herramienta para probar nuestro trabajo. </li></ul><br><h3>  Pensamientos </h3><br>  No sé, puedo completar este proyecto, pero haré lo mejor que pueda para esto. <br><br>  Windows será mi plataforma de destino, pero como uso SDL, solo hará que el motor funcione bajo cualquier otra plataforma. <br><br>  Mientras tanto, instale Visual Studio! <br><br>  El proyecto fue renombrado de Handmade DOOM para Do It Yourself Doom with SLD (DIY Doom) para que no se confunda con otros proyectos llamados "Handmade".  Hay algunas capturas de pantalla en el tutorial donde todavía se llama Handmade DOOM. <br><br><h2>  Archivos WAD </h2><br>  Antes de embarcarse en la codificación, establezcamos objetivos y pensemos en lo que queremos lograr. <br><br>  Primero, verifiquemos si podemos leer los archivos de recursos DOOM.  Todos los recursos de DOOM están en el archivo WAD. <br><br><h2>  ¿Qué es un archivo WAD? </h2><br>  "¿Dónde están todos mis datos"?  ("¿Dónde están todos mis datos?") ¡Están en WAD!  WAD es un archivo de todos los recursos de DOOM (y juegos basados ​​en DOOM) ubicados en un solo archivo. <br><br>  Los desarrolladores de Doom crearon este formato para simplificar la creación de modificaciones del juego. <br><br><h2>  WAD File Anatomy </h2><br>  El archivo WAD consta de tres partes principales: el encabezado (encabezado), "piezas" (grumos) y directorios (directorios). <br><br><ol><li>  Encabezado: contiene información básica sobre el archivo WAD y el desplazamiento del directorio. </li><li>  Bultos: aquí se almacenan recursos del juego, datos de mapas, sprites, música, etc. </li><li>  Directorios: la estructura organizativa para buscar datos en la sección global. </li></ol><br><br><pre> <code class="hljs erlang-repl"> &lt;---- <span class="hljs-number"><span class="hljs-number">32</span></span> bits ----&gt; /------------------\ ---&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>x00 | ASCII WAD Type | <span class="hljs-number"><span class="hljs-number">0</span></span>X03 | |------------------| Header -| <span class="hljs-number"><span class="hljs-number">0</span></span>x04 | # of directories | <span class="hljs-number"><span class="hljs-number">0</span></span>x07 | |------------------| ---&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>x08 | directory offset | <span class="hljs-number"><span class="hljs-number">0</span></span>x0B -- ---&gt; |------------------| &lt;-- | | <span class="hljs-number"><span class="hljs-number">0</span></span>x0C | Lump Data | | | | |------------------| | | Lumps - | | . | | | | | . | | | | | . | | | ---&gt; | . | | | ---&gt; |------------------| &lt;--|--- | | Lump offset | | | |------------------| | Directory -| | directory offset | --- List | |------------------| | | Lump Name | | |------------------| | | . | | | . | | | . | ---&gt; \------------------/</code> </pre><br><h3>  Formato de encabezado </h3><br><div class="scrollable-table"><table><thead><tr><th>  Tamaño del campo </th><th>  Tipo de datos </th><th>  Contenido </th></tr></thead><tbody><tr><td>  0x00-0x03 </td><td>  4 caracteres ASCII </td><td>  Cadena ASCII (con los valores "IWAD" o "PWAD"). </td></tr><tr><td>  0x04-0x07 </td><td>  unsigned int </td><td>  Número de elemento del directorio. </td></tr><tr><td>  0x08-0x0b </td><td>  unsigned int </td><td>  Valor de desplazamiento del directorio en el archivo WAD. </td></tr></tbody></table></div><br><h3>  Formato de directorio </h3><br><div class="scrollable-table"><table><thead><tr><th>  Tamaño del campo </th><th>  Tipo de datos </th><th>  Contenido </th></tr></thead><tbody><tr><td>  0x00-0x03 </td><td>  unsigned int </td><td>  El valor de desplazamiento al comienzo de los datos globales en el archivo WAD. </td></tr><tr><td>  0x04-0x07 </td><td>  unsigned int </td><td>  El tamaño de la "pieza" (bulto) en bytes. </td></tr><tr><td>  0x08-0x0f </td><td>  8 caracteres ASCII </td><td>  ASCII que contiene el nombre "pieza". </td></tr></tbody></table></div><br><h2>  Objetivos </h2><br><ol><li>  Crea un proyecto. </li><li>  Abre el archivo WAD. </li><li>  Lee el titular. </li><li>  Lea todos los directorios y muéstrelos. </li></ol><br><h2>  Arquitectura </h2><br>  No complicamos nada todavía.  Cree una clase que simplemente se abra y cargue WAD, y llámelo WADLoader.  Luego escribimos una clase que es responsable de leer los datos dependiendo de su formato, y lo llamamos WADReader.  También necesitamos una función <code>main</code> simple que llame a estas clases. <br><br>  Nota: esta arquitectura puede no ser óptima, y ​​si es necesario la cambiaremos. <br><br><h2>  Llegando al código </h2><br>  Comencemos creando un proyecto C ++ vacío.  En Visual Studio, haga clic en Archivo-&gt; Nuevo -&gt; Proyecto.  Llamémoslo DIYDoom. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdc/753/755/bdc7537557888a7ece9738204ecb457d.png"></div><br>  Agreguemos dos nuevas clases: WADLoader y WADReader.  Comencemos con la implementación de WADLoader. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WADLoader</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: WADLoader(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sWADFilePath); <span class="hljs-comment"><span class="hljs-comment">// We always want to make sure a WAD file is passed bool LoadWAD(); // Will call other helper functions to open and load the WAD file ~WADLoader(); // Clean up! protected: bool OpenAndLoad(); // Open the file and load it to memory bool ReadDirectories(); // A function what will iterate though the directory section std::string m_sWADFilePath; // Sore the file name passed to the constructor std::ifstream m_WADFile; // The file stream that will pint to the WAD file. uint8_t *m_WADData; // let's load the file and keep it in memory! It is just a few MBs! std::vector&lt;Directory&gt; m_WADDirectories; //let's store all the directories in this vector. };</span></span></code> </pre> <br>  Implementar el constructor será simple: inicialice el puntero de datos y almacene una copia de la ruta transferida al archivo WAD. <br><br><pre> <code class="cpp hljs">WADLoader::WADLoader(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sWADFilePath) : m_WADData(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>), m_sWADFilePath(sWADFilePath) { }</code> </pre> <br>  Ahora pasemos a la implementación de la función auxiliar de cargar <code>OpenAndLoad</code> : solo intentamos abrir el archivo como binario y, en caso de falla, mostrar un error. <br><br><pre> <code class="cpp hljs">m_WADFile.open(m_sWADFilePath, ifstream::binary); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_WADFile.is_open()) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: Failed to open WAD file"</span></span> &lt;&lt; m_sWADFilePath &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Si todo va bien, y podemos encontrar y abrir el archivo, entonces necesitamos saber el tamaño del archivo para asignar memoria para copiar el archivo. <br><br><pre> <code class="cpp hljs">m_WADFile.seekg(<span class="hljs-number"><span class="hljs-number">0</span></span>, m_WADFile.end); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = m_WADFile.tellg();</code> </pre> <br>  Ahora sabemos cuánto espacio ocupa un WAD completo, y asignaremos la cantidad de memoria necesaria. <br><br><pre> <code class="cpp hljs">m_WADData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>[length];</code> </pre> <br>  Copie el contenido del archivo a esta memoria. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// remember to know the file size we had to move the file pointer all the way to the end! We need to move it back to the beginning. m_WADFile.seekg(ifstream::beg); m_WADFile.read((char *)m_WADData, length); // read the file and place it in m_WADData m_WADFile.close();</span></span></code> </pre> <br>  Es posible que haya notado que usé el tipo <code>m_WADData</code> como tipo de datos para <code>unint8_t</code> .  Esto significa que necesito una matriz exacta de 1 byte (1 byte * longitud).  El uso de unint8_t garantiza que el tamaño sea igual a un byte (8 bits, que se pueden entender a partir del nombre del tipo).  Si quisiéramos asignar 2 bytes (16 bits), usaríamos unint16_t, del cual hablaremos más adelante.  Al usar estos tipos de código, el código se vuelve independiente de la plataforma.  Explicaré: si usamos "int", entonces el tamaño exacto de int en la memoria dependerá del sistema.  Si compilamos "int" en una configuración de 32 bits, obtenemos un tamaño de memoria de 4 bytes (32 bits), y cuando compilamos el mismo código en una configuración de 64 bits, obtenemos un tamaño de memoria de 8 bytes (64 bits).  ¡Aún peor, compilar el código en una plataforma de 16 bits (puede que seas un fanático de DOS) nos dará 2 bytes (16 bits)! <br><br>  Revisemos el código brevemente y asegurémonos de que todo funcione.  Pero primero necesitamos implementar LoadWAD.  Mientras que LoadWAD llamará "OpenAndLoad" <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::LoadWAD() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!OpenAndLoad()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Y agreguemos al código de función principal que crea una instancia de la clase e intenta cargar WAD <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">WADLoader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wadloader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"D:\\SDKs\\Assets\\Doom\\DOOM.WAD"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; wadloader.LoadWAD(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  <strong>Deberá ingresar la ruta correcta a su archivo WAD.</strong>  ¡Vamos a correrlo! <br><br>  ¡Ay!  ¡Tenemos una ventana de consola que solo se abre por unos segundos!  Nada particularmente útil ... ¿funciona el programa?  La idea!  ¡Echemos un vistazo a la memoria y veamos qué contiene!  ¡Quizás allí encontraremos algo especial!  Primero, coloque un punto de interrupción haciendo doble clic a la izquierda del número de línea.  Deberías ver algo como esto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/c5c/760/44bc5c7609610c9f8f1efd2c2e2046ef.png"></div><br>  Puse un punto de interrupción inmediatamente después de leer todos los datos del archivo para mirar la matriz de memoria y ver lo que estaba cargado.  ¡Ahora ejecute el código nuevamente!  En la ventana automática, veo los primeros bytes.  ¡Los primeros 4 bytes dicen "IWAD"!  Genial, funciona!  ¡Nunca pensé que llegaría este día!  Entonces, está bien, debes calmarte, ¡todavía hay mucho trabajo por delante! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/1a3/ddb/4c41a3ddb26bfa88f350435ca4792c31.png" alt="Depurar"></div><br><h2>  Leer encabezado </h2><br>  El tamaño total del encabezado es de 12 bytes (de 0x00 a 0x0b), estos 12 bytes se dividen en 3 grupos.  Los primeros 4 bytes son un tipo de WAD, generalmente "IWAD" o "PWAD".  IWAD debería ser el WAD oficial lanzado por ID Software, "PWAD" debería usarse para modificaciones.  En otras palabras, esta es solo una forma de determinar si el archivo WAD es un lanzamiento oficial o si lo publican los modders.  Tenga en cuenta que la cadena no tiene terminación NULL, ¡así que tenga cuidado!  Los siguientes 4 bytes son int sin signo, que contiene el número total de directorios al final del archivo.  Los siguientes 4 bytes indican el desplazamiento del primer directorio. <br><br>  Agreguemos una estructura que almacenará información.  Agregaré un nuevo archivo de encabezado y lo nombraré "DataTypes.h".  En él describiremos todas las estructuras que necesitamos. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Header</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> WADType[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// I added an extra character to add the NULL uint32_t DirectoryCount; //uint32_t is 4 bytes (32 bits) uint32_t DirectoryOffset; // The offset where the first directory is located. };</span></span></code> </pre> <br>  Ahora necesitamos implementar la clase WADReader, que leerá datos de la matriz de bytes WAD cargada.  ¡Ay!  Aquí hay un truco: los archivos WAD están en formato big-endian, es decir, tendremos que cambiar los bytes para hacerlos little endian (hoy, la mayoría de los sistemas usan little endian).  Para hacer esto, agregaremos dos funciones, una para procesar 2 bytes (16 bits), la otra para procesar 4 bytes (32 bits);  Si necesitamos leer solo 1 byte, entonces no es necesario hacer nada. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> WADReader::bytesToShort(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (pWADData[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | pWADData[offset]; } <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> WADReader::bytesToInteger(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (pWADData[offset + <span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>) | (pWADData[offset + <span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (pWADData[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | pWADData[offset]; }</code> </pre> <br>  Ahora estamos listos para leer el encabezado: cuente los primeros cuatro bytes como char y luego agregue NULL para simplificar nuestro trabajo.  En el caso de la cantidad de directorios y su desplazamiento, simplemente puede usar funciones auxiliares para convertirlos al formato correcto. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WADReader::ReadHeaderData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, Header &amp;header) { <span class="hljs-comment"><span class="hljs-comment">//0x00 to 0x03 header.WADType[0] = pWADData[offset]; header.WADType[1] = pWADData[offset + 1]; header.WADType[2] = pWADData[offset + 2]; header.WADType[3] = pWADData[offset + 3]; header.WADType[4] = '\0'; //0x04 to 0x07 header.DirectoryCount = bytesToInteger(pWADData, offset + 4); //0x08 to 0x0b header.DirectoryOffset = bytesToInteger(pWADData, offset + 8); }</span></span></code> </pre> <br>  Vamos a poner todo junto, llamar a estas funciones e imprimir los resultados. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::ReadDirectories() { WADReader reader; Header header; reader.ReadHeaderData(m_WADData, <span class="hljs-number"><span class="hljs-number">0</span></span>, header); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; header.WADType &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; header.DirectoryCount &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; header.DirectoryOffset &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  ¡Ejecute el programa y vea si todo funciona! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfa/693/d03/dfa693d039ab66df047768c209561ac2.png"></div><br>  Genial  La línea IWAD es claramente visible, pero ¿son correctos los otros dos números?  ¡Intentemos leer directorios usando estos desplazamientos y veamos si funciona! <br><br>  Necesitamos agregar una nueva estructura para manejar el directorio correspondiente a las opciones anteriores. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Directory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> LumpOffset; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> LumpSize; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> LumpName[<span class="hljs-number"><span class="hljs-number">9</span></span>]; };</code> </pre> <br>  Ahora agreguemos la función ReadDirectories: ¡cuente el desplazamiento y déles salida! <br><br>  En cada iteración, multiplicamos i * 16 para ir al incremento de desplazamiento del siguiente directorio. <br><br><pre> <code class="cpp hljs">Directory directory; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; header.DirectoryCount; ++i) { reader.ReadDirectoryData(m_WADData, header.DirectoryOffset + i * <span class="hljs-number"><span class="hljs-number">16</span></span>, directory); m_WADDirectories.push_back(directory); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; directory.LumpOffset &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; directory.LumpSize &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; directory.LumpName &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br>  Ejecute el código y vea qué sucede.  Wow!  Una gran lista de directorios. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fb/7b5/af6/8fb7b5af6df0d44303c11d5bd005e93d.png" alt="Correr 2"></div><br>  A juzgar por el nombre de la masa, podemos suponer que logramos leer los datos correctamente, pero tal vez hay una mejor manera de verificar esto.  Echaremos un vistazo a las entradas del Directorio WAD usando Slade3. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/6b7/21c/d1c6b721c04575fe71785efe1f2bdbd3.png"></div><br>  Parece que el nombre y el tamaño del bulto corresponden a los datos obtenidos con nuestro código.  ¡Hoy hicimos un gran trabajo! <br><br><h2>  Otras notas </h2><br><ul><li>  En algún momento, pensé que sería bueno usar vector para almacenar directorios.  ¿Por qué no usar Map?  Esto será más rápido que obtener datos mediante la búsqueda lineal de vectores.  Esta es una mala idea  Cuando se usa el mapa, no se rastreará el orden de las entradas del directorio, pero necesitamos esta información para obtener los datos correctos. <br><br>  Y otro concepto erróneo: Map en C ++ se implementa como árboles rojo-negros con tiempo de búsqueda O (log N), y las iteraciones sobre el mapa siempre dan un orden creciente de claves.  Si necesita una estructura de datos que proporcione el tiempo promedio O (1) y el peor tiempo O (N), entonces debe usar un mapa desordenado. </li><li>  <s>Cargar todos los archivos WAD en la memoria no es un método de implementación óptimo.</s>  <s>Sería más lógico simplemente leer los directorios en el encabezado de la memoria y luego regresar al archivo WAD y cargar recursos desde el disco.</s>  <s>Esperemos que algún día aprendamos más sobre el almacenamiento en caché.</s> <br><br>  <strong>DOOMReboot</strong> : <em>completamente en desacuerdo.</em>  <em>15 MB de RAM en estos días es una bagatela completa, y leer de memoria será mucho más rápido que el voluminoso fseek, que deberá usarse después de descargar todo lo necesario para el nivel.</em>  <em>Esto aumentará el tiempo de descarga en no menos de uno o dos segundos (me lleva menos de 20 ms descargar todo el tiempo).</em>  <em>fseek usa el sistema operativo.</em>  <em>Qué archivo es más probable en la memoria caché de RAM, pero puede que no.</em>  <em>Pero incluso si él está allí, es una gran pérdida de recursos y estas operaciones confundirán muchas lecturas de WAD en términos de caché de CPU.</em>  <em>Lo mejor es que puede crear métodos de arranque híbridos y almacenar datos WAD para un nivel que se ajuste al caché L3 de los procesadores modernos, donde los ahorros serán increíbles.</em> </li></ul><br><h2>  Código fuente </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Código fuente</a> <br><br><h2>  Datos básicos de la tarjeta </h2><br>  Después de haber aprendido a leer el archivo WAD, intentemos usar los datos leídos.  Será genial aprender a leer los datos de la misión (mundo / nivel) y aplicarlos.  Los "fragmentos" de estas misiones (Mission Lumps) deberían ser algo complejo y complicado.  Por lo tanto, necesitaremos movernos y desarrollar el conocimiento gradualmente.  Como primer pequeño paso, creemos algo así como una característica de Automap: un plano bidimensional de un mapa con una vista superior.  Primero, veamos qué hay dentro del bulto de la misión. <br><br><h2>  Anatomía de la tarjeta </h2><br>  Comencemos de nuevo: la descripción de los niveles de DOOM es muy similar al dibujo 2D, en el que las paredes están marcadas con líneas.  Sin embargo, para obtener coordenadas 3D, cada pared toma la altura del piso y el techo (XY es el plano a lo largo del cual nos movemos horizontalmente, y Z es la altura que nos permite movernos hacia arriba y hacia abajo, por ejemplo, al levantarnos en un elevador o saltar desde una plataforma. Los componentes de coordenadas se utilizan para representar la misión como un mundo 3D, sin embargo, para garantizar un buen rendimiento, el motor tiene ciertas limitaciones: no hay habitaciones ubicadas una encima de la otra en los niveles y el jugador no puede mirar hacia arriba y hacia abajo. Otra característica interesante: proyectiles y  Las rocas, por ejemplo, los cohetes, ascienden verticalmente para alcanzar un objetivo ubicado en una plataforma más alta. <br><br>  Estas características curiosas han provocado un sinfín de preguntas acerca de si el DOOM es un motor 2D o 3D.  Poco a poco, se alcanzó un compromiso diplomático, que salvó muchas vidas: las partes acordaron la designación "2.5D" aceptable para ambos. <br><br>  Para simplificar la tarea y volver al tema, intentemos leer estos datos 2D y ver si pueden usarse de alguna manera.  Más adelante intentaremos renderizarlos en 3D, pero por ahora necesitamos entender cómo funcionan juntas las partes individuales del motor. <br><br>  Después de realizar una investigación, descubrí que cada misión se compone de un conjunto de "piezas".  Estos "Bultos" siempre se representan en el archivo WAD de un juego DOOM en el mismo orden. <br><br><ol><li>  <strong>Vértices: los</strong> puntos finales de las paredes en 2D.  Dos VERTEX conectados forman un LINEDEF.  Tres VERTEX conectados forman dos paredes / LINEDEF, y así sucesivamente.  Se pueden percibir simplemente como los puntos de conexión de dos o más paredes.  (Sí, la mayoría de la gente prefiere el plural "Vértices", pero a John Carmack no le gustó. Según <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">merriam-webster</a> , se aplican ambas opciones. </li><li>  <strong>LINEDEFS:</strong> líneas que forman juntas entre vértices y paredes que forman.  No todas las líneas (paredes) se comportan igual, hay banderas que especifican el comportamiento de dichas líneas. </li><li>  <strong>DEDOS LADOS:</strong> en la vida real, las paredes tienen dos lados: miramos uno, el segundo está del otro lado.  Los dos lados pueden tener diferentes texturas, y SIDEDEFS es el bulto que contiene la información de textura para la pared (LINEDEF). </li><li>  <strong>SECTORES: los</strong> sectores son "salas" obtenidas por la unión LINEDEF.  Cada sector contiene información como alturas de piso y techo, texturas, valores de iluminación, acciones especiales, como mover pisos / plataformas / elevadores.  Algunos de estos parámetros también afectan la forma en que se representan las paredes, por ejemplo, el nivel de iluminación y el cálculo de las coordenadas del mapeo de texturas. </li><li>  <strong>SECTORES:</strong> (subsectores) forman áreas convexas dentro de un sector que se utilizan para renderizar junto con el bypass BSP, y también ayudan a determinar dónde se encuentra un jugador en un nivel particular.  Son bastante útiles y a menudo se usan para determinar la posición vertical de un jugador.  Cada SSECTOR consta de partes conectadas de un sector, por ejemplo, de paredes que forman un ángulo.  Tales partes de las paredes, o "segmentos", se almacenan en su propio bulto llamado ... </li><li>  <strong>SEGS:</strong> piezas de pared / LINEDEF;  en otras palabras, estos son los "segmentos" del muro / LINEDEF.  El mundo se representa sin pasar por el árbol BSP para determinar qué paredes dibujar primero (las primeras son las más cercanas).  Aunque el sistema funciona muy bien, a menudo hace que los linedefs se dividan en dos o más SEG.  Estos SEG se utilizan para representar muros en lugar de LINEDEF.  La geometría de cada SSECTOR está determinada por los segmentos contenidos en él. </li><li>  <strong>NODOS:</strong> Un nodo BSP es un nodo de una estructura de árbol binario que almacena datos del subsector.  Se utiliza para determinar rápidamente qué SSECTOR (y SEG) están delante del jugador.  La eliminación de los SEG ubicados detrás del jugador y, por lo tanto, invisibles, permite que el motor se concentre en los SEG potencialmente visibles, lo que reduce significativamente el tiempo de renderizado. </li><li>  <strong>COSAS: El</strong> bulto llamado COSAS es una lista de actores de escenarios y misiones (enemigos, armas, etc.).  Cada elemento de este bulto contiene información sobre una instancia del actor / conjunto, por ejemplo, el tipo de objeto, el punto de creación, la dirección, etc. </li><li>  <strong>RECHAZAR:</strong> este bulto contiene datos sobre qué sectores son visibles desde otros sectores.  Se utiliza para determinar cuándo un monstruo se entera de la presencia de un jugador.  También se utiliza para determinar el rango de distribución de sonidos creados por el jugador, por ejemplo, disparos.  Cuando ese sonido puede transmitirse al sector del monstruo, puede averiguar sobre el jugador.  La tabla RECHAZAR también se puede utilizar para acelerar el reconocimiento de colisiones de proyectiles de armas. </li><li>  <strong>BLOCKMAP:</strong> información de reconocimiento de colisión del jugador y movimiento de THING.  Consiste en una cuadrícula que cubre la geometría de toda la misión.  Cada celda de la cuadrícula contiene una lista de LINEDEF que están dentro o que se cruzan con ella.  Se utiliza para acelerar significativamente el reconocimiento de colisiones: se requieren comprobaciones de colisión para solo unos pocos LINEDEF por jugador / COSA, lo que ahorra significativamente la potencia informática. </li></ol><br>  Al generar nuestro mapa 2D, nos centraremos en VERTEXOS y LINEDEFS.  Si podemos dibujar los vértices y conectarlos con las líneas dadas por linedef, entonces necesitamos generar un modelo 2D del mapa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f4/dd4/a3b/3f4dd4a3b79fab0d47e7f1212a73df83.png" alt="Mapa de demostración"></div><br>  La tarjeta de demostración que se muestra arriba tiene las siguientes características: <br><br><ul><li>  4 picos <ul><li>  vértice 1 en (10.10) </li><li>  top 2 en (10,100) </li><li>  top 3 en (100, 10) </li><li>  pico 4 in (100,100) </li></ul></li><li>  4 lineas <ul><li>  línea de arriba 1 a 2 </li><li>  línea de arriba 1 a 3 </li><li>  línea de arriba 2 a 4 </li><li>  línea de arriba 3 a 4 </li></ul></li></ul><br><h3>  Formato de vértice </h3><br>  Como es de esperar, los datos de vértice son muy simples: solo x e y (punto) de algunas coordenadas. <br><br><div class="scrollable-table"><table><thead><tr><th>  Tamaño del campo </th><th>  Tipo de datos </th><th>  Contenido </th></tr></thead><tbody><tr><td>  0x00-0x01 </td><td>  Corto firmado </td><td>  Posición X </td></tr><tr><td>  0x02-0x03 </td><td>  Corto firmado </td><td>  Posición Y </td></tr></tbody></table></div><br><h3>  Formato Linedef </h3><br>  Linedef contiene más información; describe la línea que conecta los dos vértices y las propiedades de esta línea (que luego se convertirá en un muro). <br><br><div class="scrollable-table"><table><thead><tr><th>  Tamaño del campo </th><th>  Tipo de datos </th><th>  Contenido </th></tr></thead><tbody><tr><td>  0x00-0x01 </td><td>  Corto sin signo </td><td>  Pico de inicio </td></tr><tr><td>  0x02-0x03 </td><td>  Corto sin signo </td><td>  Pico máximo </td></tr><tr><td>  0x04-0x05 </td><td>  Corto sin signo </td><td>  Banderas (ver más abajo para más detalles) </td></tr><tr><td>  0x06-0x07 </td><td>  Corto sin signo </td><td>  Tipo de línea / acción </td></tr><tr><td>  0x08-0x09 </td><td>  Corto sin signo </td><td>  Etiqueta sectorial </td></tr><tr><td>  0x10-0x11 </td><td>  Corto sin signo </td><td>  Front sidedef (0xFFFF - sin lado) </td></tr><tr><td>  0x12-0x13 </td><td>  Corto sin signo </td><td>  Dedo lateral trasero (0xFFFF - sin lado) </td></tr></tbody></table></div><br><h3>  Linedef Flag Values </h3><br>  No todas las líneas (paredes) están dibujadas.  Algunos de ellos tienen un comportamiento especial. <br><br><div class="scrollable-table"><table><thead><tr><th>  Poco </th><th>  Descripción </th></tr></thead><tbody><tr><td>  0 0 </td><td>  Bloquea el camino para jugadores y monstruos. </td></tr><tr><td>  1 </td><td>  Bloque monstruos </td></tr><tr><td>  2 </td><td>  Doble cara </td></tr><tr><td>  3 </td><td>  La textura superior está desactivada (hablaremos de esto más adelante) </td></tr><tr><td>  4 4 </td><td>  La textura inferior está desactivada (hablaremos de esto más adelante) </td></tr><tr><td>  5 5 </td><td>  Secreto (se muestra en el mapa como un muro unilateral) </td></tr><tr><td>  6 6 </td><td>  Obstruye el sonido </td></tr><tr><td>  7 7 </td><td>  Nunca se muestra en la tarjeta automática </td></tr><tr><td>  8 </td><td>  Siempre se muestra en autocard </td></tr></tbody></table></div><br><h2>  Objetivos </h2><br><ol><li>  Crea una clase de Mapa. </li><li>  Leer datos de vértices. </li><li>  Leer datos linedef. </li></ol><br><h2>  Arquitectura </h2><br>  Primero, creemos una clase y llamémosla mapa.  En él almacenaremos todos los datos asociados con la tarjeta. <br><br>  Por ahora, planeo almacenar solo vértices y linedefs como un vector, para poder aplicarlos más tarde. <br><br>  Además, complementemos WADLoader y WADReader para que podamos leer estas dos nuevas piezas de información. <br><br><h2>  Codificación </h2><br>  El código será similar al código de lectura de WAD, solo agregaremos unas pocas estructuras más y luego los llenaremos con datos de WAD.  Comencemos agregando una nueva clase y pasando el nombre del mapa. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Map(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sName); ~Map(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Incase someone need to know the map name void AddVertex(Vertex &amp;v); // Wrapper class to append to the vertexes vector void AddLinedef(Linedef &amp;l); // Wrapper class to append to the linedef vector protected: std::string m_sName; std::vector&lt;Vertex&gt; m_Vertexes; std::vector&lt;Linedef&gt; m_Linedef; };</span></span></code> </pre> <br>  Ahora agregue estructuras para leer estos nuevos campos.  Como ya lo hemos hecho varias veces, solo agréguelas todas a la vez. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vertex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> XPosition; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> YPosition; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Linedef</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> StartVertex; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> EndVertex; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Flags; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> LineType; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> SectorTag; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> FrontSidedef; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> BackSidedef; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A continuación, necesitamos una función para leerlos desde WADReader, estará cerca de lo que hicimos antes. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WADReader::ReadVertexData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, Vertex &amp;vertex) { vertex.XPosition = Read2Bytes(pWADData, offset); vertex.YPosition = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WADReader::ReadLinedefData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, Linedef &amp;linedef) { linedef.StartVertex = Read2Bytes(pWADData, offset); linedef.EndVertex = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">2</span></span>); linedef.Flags = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">4</span></span>); linedef.LineType = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">6</span></span>); linedef.SectorTag = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">8</span></span>); linedef.FrontSidedef = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">10</span></span>); linedef.BackSidedef = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">12</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creo que no hay nada nuevo para ti aquí. </font><font style="vertical-align: inherit;">Y ahora necesitamos llamar a estas funciones desde la clase WADLoader. </font><font style="vertical-align: inherit;">Permítanme exponer los hechos: la secuencia de grumos es importante aquí, encontraremos el nombre del mapa en el directorio de grumos, seguido de todos los grumos asociados con los mapas en el orden dado. </font><font style="vertical-align: inherit;">Para simplificar nuestra tarea y no rastrear los índices de bultos por separado, agregaremos una enumeración que nos permite deshacernos de los números mágicos.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EMAPLUMPSINDEX { eTHINGS = <span class="hljs-number"><span class="hljs-number">1</span></span>, eLINEDEFS, eSIDEDDEFS, eVERTEXES, eSEAGS, eSSECTORS, eNODES, eSECTORS, eREJECT, eBLOCKMAP, eCOUNT };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">También agregaré una función para buscar un mapa por su nombre en la lista de directorios. </font><font style="vertical-align: inherit;">Más adelante, es probable que aumentemos el rendimiento de este paso mediante el uso de la estructura de datos del mapa, porque aquí hay un número significativo de registros, y tendremos que revisarlos con bastante frecuencia, especialmente al comienzo de cargar recursos como texturas, sprites, sonidos, etc.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> WADLoader::FindMapIndex(Map &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_WADDirectories.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_WADDirectories[i].LumpName == <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.GetName()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Guau, ya casi hemos terminado! </font><font style="vertical-align: inherit;">Ahora, ¡solo contemos los VERTEXOS! </font><font style="vertical-align: inherit;">Repito, ya hemos hecho esto antes, ahora debes entender esto.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::ReadMapVertex(Map &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iMapIndex = FindMapIndex(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iMapIndex == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } iMapIndex += EMAPLUMPSINDEX::eVERTEXES; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(m_WADDirectories[iMapIndex].LumpName, <span class="hljs-string"><span class="hljs-string">"VERTEXES"</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVertexSizeInBytes = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Vertex); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVertexesCount = m_WADDirectories[iMapIndex].LumpSize / iVertexSizeInBytes; Vertex vertex; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; iVertexesCount; ++i) { m_Reader.ReadVertexData(m_WADData, m_WADDirectories[iMapIndex].LumpOffset + i * iVertexSizeInBytes, vertex); <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.AddVertex(vertex); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; vertex.XPosition &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; vertex.YPosition &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hmm, parece que estamos copiando constantemente el mismo código; </font><font style="vertical-align: inherit;">Puede que tenga que optimizarlo en el futuro, pero por ahora implementará ReadMapLinedef usted mismo (o mire el código fuente desde el enlace). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toques finales: necesitamos llamar a esta función y pasarle el objeto del mapa.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::LoadMapData(Map &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ReadMapVertex(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: Failed to load map vertex data MAP: "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.GetName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ReadMapLinedef(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: Failed to load map linedef data MAP: "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.GetName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora cambiemos la función principal y veamos si todo funciona. </font><font style="vertical-align: inherit;">Quiero cargar el mapa "E1M1", que transferiré al objeto del mapa.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">Map </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"E1M1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; wadloader.LoadMapData(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora vamos a ejecutarlo todo. </font><font style="vertical-align: inherit;">Wow, un montón de números interesantes, pero ¿son ciertos? </font><font style="vertical-align: inherit;">¡Vamos a echarle un vistazo! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veamos si slade puede ayudarnos con esto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos encontrar el mapa en el menú de slade y ver los detalles de los bultos. </font><font style="vertical-align: inherit;">Comparemos los números.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48b/3ec/439/48b3ec43988e25260d45a4abd1999c91.png" alt="Vértice"></div><br>  Genial <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¿Qué hay de Linedef? </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96f/93d/ecd/96f93decd409dad0b8b6836726345a08.png" alt="Linedef"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> También agregué esta enumeración, que intentaremos usar al representar el mapa. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ELINEDEFFLAGS { eBLOCKING = <span class="hljs-number"><span class="hljs-number">0</span></span>, eBLOCKMONSTERS = <span class="hljs-number"><span class="hljs-number">1</span></span>, eTWOSIDED = <span class="hljs-number"><span class="hljs-number">2</span></span>, eDONTPEGTOP = <span class="hljs-number"><span class="hljs-number">4</span></span>, eDONTPEGBOTTOM = <span class="hljs-number"><span class="hljs-number">8</span></span>, eSECRET = <span class="hljs-number"><span class="hljs-number">16</span></span>, eSOUNDBLOCK = <span class="hljs-number"><span class="hljs-number">32</span></span>, eDONTDRAW = <span class="hljs-number"><span class="hljs-number">64</span></span>, eDRAW = <span class="hljs-number"><span class="hljs-number">128</span></span> };</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Otras notas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el proceso de escribir el código, leí por error más bytes de los necesarios y recibí valores incorrectos. </font><font style="vertical-align: inherit;">Para la depuración, comencé a mirar el desplazamiento WAD en la memoria para ver si estaba en el desplazamiento correcto. </font><font style="vertical-align: inherit;">Esto se puede hacer usando la ventana de memoria de Visual Studio, que es una herramienta muy útil para rastrear bytes o memoria (también puede establecer puntos de interrupción en esta ventana). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si no ve la ventana de memoria, vaya a Depurar&gt; Memoria&gt; Memoria.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/cba/0d3/27dcba0d33094493822f4444a4c0d8c8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora vemos los valores en memoria en hexadecimal. </font><font style="vertical-align: inherit;">Estos valores se pueden comparar con la visualización hexadecimal en slade haciendo clic derecho en cualquier bulto y mostrándolo como hexadecimal.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cc/159/757/1cc15975726f8a1204bf674aa0824fc6.png" alt="Slade"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compárelos con la dirección del WAD cargado en la memoria. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/970/2af/c96/9702afc96be99794e7d9f01e4d6d89bb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y lo último para hoy: vimos todos estos valores de vértice, pero ¿hay una manera fácil de visualizarlos sin escribir código? </font><font style="vertical-align: inherit;">No quiero perder tiempo en esto, solo para descubrir que nos estamos moviendo en la dirección equivocada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seguramente alguien ya creó un trazador. </font><font style="vertical-align: inherit;">Busqué en Google "dibujar puntos en un gráfico" y el primer resultado fue el sitio web de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plot Points: Desmos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En él, puede pegar números del portapapeles y él los dibujará. </font><font style="vertical-align: inherit;">Deben estar en el formato "(x, y)". </font><font style="vertical-align: inherit;">Para obtenerlo, simplemente cambie la función de salida a la pantalla.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"("</span></span> &lt;&lt; vertex.XPosition &lt;&lt; <span class="hljs-string"><span class="hljs-string">","</span></span> &lt;&lt; vertex.YPosition &lt;&lt; <span class="hljs-string"><span class="hljs-string">")"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wow! </font><font style="vertical-align: inherit;">¡Ya parece un E1M1! </font><font style="vertical-align: inherit;">¡Hemos logrado algo!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/ce6/36b/499ce636b2dbd6bd3e158bff07304b37.png" alt="Puntos de trazado E1M1"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si eres perezoso para hacer esto, aquí hay un enlace a un gráfico punteado: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plot Vertex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero demos un paso más: después de un poco de trabajo, podemos conectar estos puntos en función de linedefs.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/423/35b/c2f42335b751d3bd9acec03251204977.png" alt="E1M1 Plot Vertex"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí está el enlace: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E1M1 Plot Vertex</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Código fuente </font></font></h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código fuente</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Referencias </font></font></h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom Wiki </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZDoom Wiki</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/471552/">https://habr.com/ru/post/471552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471538/index.html">Desde la idea de una aplicación móvil hasta el MVP en el que los inversores invertirán</a></li>
<li><a href="../471542/index.html">Reconocimiento de texto OCR</a></li>
<li><a href="../471544/index.html">Sobre el amor, o por qué el centurión cosaco cambió su uniforme por una túnica uzbeka</a></li>
<li><a href="../471548/index.html">Los 5 mejores libros para leer de un artista</a></li>
<li><a href="../471550/index.html">¿Dónde obtener audio para el desarrollo de juegos y otros proyectos comerciales? Bibliotecas con los sonidos de la naturaleza.</a></li>
<li><a href="../471554/index.html">¿Cómo reducir los riesgos de reclamos fiscales por la venta de aplicaciones y contenido?</a></li>
<li><a href="../471556/index.html">Fujitsu World Tour 2019. ¿Cómo fue nuestra conferencia más grande?</a></li>
<li><a href="../471558/index.html">Mamá, estoy en televisión: ¿cómo fue el final del concurso Digital Breakthrough?</a></li>
<li><a href="../471562/index.html">Superinfección 2: rubicón de problemas, el fiasco de la tecnología y una nueva esperanza</a></li>
<li><a href="../471564/index.html">Friends RaspberryPi con TP-Link TL-WN727N</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>