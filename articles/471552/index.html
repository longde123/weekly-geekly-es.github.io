<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶à ‚¨õÔ∏è ü§úüèø Escribir un clon del motor Doom: leer informaci√≥n del mapa üîé üóª ü§≤üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 El objetivo de este proyecto es crear un clon del motor DOOM utilizando recursos lanzados con Ultimate DOOM ( versi√≥n de Steam ). 

 Se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribir un clon del motor Doom: leer informaci√≥n del mapa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471552/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/423/35b/c2f42335b751d3bd9acec03251204977.png" alt="imagen"></div><br><h2>  Introduccion </h2><br>  El objetivo de este proyecto es crear un clon del motor DOOM utilizando recursos lanzados con Ultimate DOOM ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">versi√≥n de Steam</a> ). <br><br>  Se presentar√° en forma de tutorial: no quiero lograr el m√°ximo rendimiento en el c√≥digo, solo creo una versi√≥n funcional y m√°s tarde comenzar√© a mejorarlo y optimizarlo. <br><br>  No tengo experiencia en la creaci√≥n de juegos o motores de juegos, y poca experiencia en la redacci√≥n de art√≠culos, por lo que puede sugerir sus propios cambios o incluso reescribir completamente el c√≥digo. <br><br>  Aqu√≠ hay una lista de recursos y enlaces. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Libro Game Engine Black Book: DOOM Fabien Sanglar</a> .  Uno de los mejores libros sobre DOOM internos. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Doom wiki</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥digo fuente DOOM</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥digo fuente Chocolate Doom</a> <br><a name="habracut"></a><br><h3>  Requisitos </h3><br><ul><li>  Visual Studio: cualquier IDE servir√°;  Trabajar√© en Visual Studio 2017. </li><li>  SDL2: bibliotecas. </li><li>  DOOM: una copia de la versi√≥n Steam de Ultimate DOOM, solo necesitamos un archivo WAD de √©l. </li></ul><br><h3>  Opcional </h3><br><ul><li>  Slade3: una buena herramienta para probar nuestro trabajo. </li></ul><br><h3>  Pensamientos </h3><br>  No s√©, puedo completar este proyecto, pero har√© lo mejor que pueda para esto. <br><br>  Windows ser√° mi plataforma de destino, pero como uso SDL, solo har√° que el motor funcione bajo cualquier otra plataforma. <br><br>  Mientras tanto, instale Visual Studio! <br><br>  El proyecto fue renombrado de Handmade DOOM para Do It Yourself Doom with SLD (DIY Doom) para que no se confunda con otros proyectos llamados "Handmade".  Hay algunas capturas de pantalla en el tutorial donde todav√≠a se llama Handmade DOOM. <br><br><h2>  Archivos WAD </h2><br>  Antes de embarcarse en la codificaci√≥n, establezcamos objetivos y pensemos en lo que queremos lograr. <br><br>  Primero, verifiquemos si podemos leer los archivos de recursos DOOM.  Todos los recursos de DOOM est√°n en el archivo WAD. <br><br><h2>  ¬øQu√© es un archivo WAD? </h2><br>  "¬øD√≥nde est√°n todos mis datos"?  ("¬øD√≥nde est√°n todos mis datos?") ¬°Est√°n en WAD!  WAD es un archivo de todos los recursos de DOOM (y juegos basados ‚Äã‚Äãen DOOM) ubicados en un solo archivo. <br><br>  Los desarrolladores de Doom crearon este formato para simplificar la creaci√≥n de modificaciones del juego. <br><br><h2>  WAD File Anatomy </h2><br>  El archivo WAD consta de tres partes principales: el encabezado (encabezado), "piezas" (grumos) y directorios (directorios). <br><br><ol><li>  Encabezado: contiene informaci√≥n b√°sica sobre el archivo WAD y el desplazamiento del directorio. </li><li>  Bultos: aqu√≠ se almacenan recursos del juego, datos de mapas, sprites, m√∫sica, etc. </li><li>  Directorios: la estructura organizativa para buscar datos en la secci√≥n global. </li></ol><br><br><pre> <code class="hljs erlang-repl"> &lt;---- <span class="hljs-number"><span class="hljs-number">32</span></span> bits ----&gt; /------------------\ ---&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>x00 | ASCII WAD Type | <span class="hljs-number"><span class="hljs-number">0</span></span>X03 | |------------------| Header -| <span class="hljs-number"><span class="hljs-number">0</span></span>x04 | # of directories | <span class="hljs-number"><span class="hljs-number">0</span></span>x07 | |------------------| ---&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>x08 | directory offset | <span class="hljs-number"><span class="hljs-number">0</span></span>x0B -- ---&gt; |------------------| &lt;-- | | <span class="hljs-number"><span class="hljs-number">0</span></span>x0C | Lump Data | | | | |------------------| | | Lumps - | | . | | | | | . | | | | | . | | | ---&gt; | . | | | ---&gt; |------------------| &lt;--|--- | | Lump offset | | | |------------------| | Directory -| | directory offset | --- List | |------------------| | | Lump Name | | |------------------| | | . | | | . | | | . | ---&gt; \------------------/</code> </pre><br><h3>  Formato de encabezado </h3><br><div class="scrollable-table"><table><thead><tr><th>  Tama√±o del campo </th><th>  Tipo de datos </th><th>  Contenido </th></tr></thead><tbody><tr><td>  0x00-0x03 </td><td>  4 caracteres ASCII </td><td>  Cadena ASCII (con los valores "IWAD" o "PWAD"). </td></tr><tr><td>  0x04-0x07 </td><td>  unsigned int </td><td>  N√∫mero de elemento del directorio. </td></tr><tr><td>  0x08-0x0b </td><td>  unsigned int </td><td>  Valor de desplazamiento del directorio en el archivo WAD. </td></tr></tbody></table></div><br><h3>  Formato de directorio </h3><br><div class="scrollable-table"><table><thead><tr><th>  Tama√±o del campo </th><th>  Tipo de datos </th><th>  Contenido </th></tr></thead><tbody><tr><td>  0x00-0x03 </td><td>  unsigned int </td><td>  El valor de desplazamiento al comienzo de los datos globales en el archivo WAD. </td></tr><tr><td>  0x04-0x07 </td><td>  unsigned int </td><td>  El tama√±o de la "pieza" (bulto) en bytes. </td></tr><tr><td>  0x08-0x0f </td><td>  8 caracteres ASCII </td><td>  ASCII que contiene el nombre "pieza". </td></tr></tbody></table></div><br><h2>  Objetivos </h2><br><ol><li>  Crea un proyecto. </li><li>  Abre el archivo WAD. </li><li>  Lee el titular. </li><li>  Lea todos los directorios y mu√©strelos. </li></ol><br><h2>  Arquitectura </h2><br>  No complicamos nada todav√≠a.  Cree una clase que simplemente se abra y cargue WAD, y ll√°melo WADLoader.  Luego escribimos una clase que es responsable de leer los datos dependiendo de su formato, y lo llamamos WADReader.  Tambi√©n necesitamos una funci√≥n <code>main</code> simple que llame a estas clases. <br><br>  Nota: esta arquitectura puede no ser √≥ptima, y ‚Äã‚Äãsi es necesario la cambiaremos. <br><br><h2>  Llegando al c√≥digo </h2><br>  Comencemos creando un proyecto C ++ vac√≠o.  En Visual Studio, haga clic en Archivo-&gt; Nuevo -&gt; Proyecto.  Llam√©moslo DIYDoom. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdc/753/755/bdc7537557888a7ece9738204ecb457d.png"></div><br>  Agreguemos dos nuevas clases: WADLoader y WADReader.  Comencemos con la implementaci√≥n de WADLoader. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WADLoader</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: WADLoader(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sWADFilePath); <span class="hljs-comment"><span class="hljs-comment">// We always want to make sure a WAD file is passed bool LoadWAD(); // Will call other helper functions to open and load the WAD file ~WADLoader(); // Clean up! protected: bool OpenAndLoad(); // Open the file and load it to memory bool ReadDirectories(); // A function what will iterate though the directory section std::string m_sWADFilePath; // Sore the file name passed to the constructor std::ifstream m_WADFile; // The file stream that will pint to the WAD file. uint8_t *m_WADData; // let's load the file and keep it in memory! It is just a few MBs! std::vector&lt;Directory&gt; m_WADDirectories; //let's store all the directories in this vector. };</span></span></code> </pre> <br>  Implementar el constructor ser√° simple: inicialice el puntero de datos y almacene una copia de la ruta transferida al archivo WAD. <br><br><pre> <code class="cpp hljs">WADLoader::WADLoader(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sWADFilePath) : m_WADData(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>), m_sWADFilePath(sWADFilePath) { }</code> </pre> <br>  Ahora pasemos a la implementaci√≥n de la funci√≥n auxiliar de cargar <code>OpenAndLoad</code> : solo intentamos abrir el archivo como binario y, en caso de falla, mostrar un error. <br><br><pre> <code class="cpp hljs">m_WADFile.open(m_sWADFilePath, ifstream::binary); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_WADFile.is_open()) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: Failed to open WAD file"</span></span> &lt;&lt; m_sWADFilePath &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Si todo va bien, y podemos encontrar y abrir el archivo, entonces necesitamos saber el tama√±o del archivo para asignar memoria para copiar el archivo. <br><br><pre> <code class="cpp hljs">m_WADFile.seekg(<span class="hljs-number"><span class="hljs-number">0</span></span>, m_WADFile.end); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = m_WADFile.tellg();</code> </pre> <br>  Ahora sabemos cu√°nto espacio ocupa un WAD completo, y asignaremos la cantidad de memoria necesaria. <br><br><pre> <code class="cpp hljs">m_WADData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>[length];</code> </pre> <br>  Copie el contenido del archivo a esta memoria. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// remember to know the file size we had to move the file pointer all the way to the end! We need to move it back to the beginning. m_WADFile.seekg(ifstream::beg); m_WADFile.read((char *)m_WADData, length); // read the file and place it in m_WADData m_WADFile.close();</span></span></code> </pre> <br>  Es posible que haya notado que us√© el tipo <code>m_WADData</code> como tipo de datos para <code>unint8_t</code> .  Esto significa que necesito una matriz exacta de 1 byte (1 byte * longitud).  El uso de unint8_t garantiza que el tama√±o sea igual a un byte (8 bits, que se pueden entender a partir del nombre del tipo).  Si quisi√©ramos asignar 2 bytes (16 bits), usar√≠amos unint16_t, del cual hablaremos m√°s adelante.  Al usar estos tipos de c√≥digo, el c√≥digo se vuelve independiente de la plataforma.  Explicar√©: si usamos "int", entonces el tama√±o exacto de int en la memoria depender√° del sistema.  Si compilamos "int" en una configuraci√≥n de 32 bits, obtenemos un tama√±o de memoria de 4 bytes (32 bits), y cuando compilamos el mismo c√≥digo en una configuraci√≥n de 64 bits, obtenemos un tama√±o de memoria de 8 bytes (64 bits).  ¬°A√∫n peor, compilar el c√≥digo en una plataforma de 16 bits (puede que seas un fan√°tico de DOS) nos dar√° 2 bytes (16 bits)! <br><br>  Revisemos el c√≥digo brevemente y asegur√©monos de que todo funcione.  Pero primero necesitamos implementar LoadWAD.  Mientras que LoadWAD llamar√° "OpenAndLoad" <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::LoadWAD() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!OpenAndLoad()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Y agreguemos al c√≥digo de funci√≥n principal que crea una instancia de la clase e intenta cargar WAD <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">WADLoader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wadloader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"D:\\SDKs\\Assets\\Doom\\DOOM.WAD"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; wadloader.LoadWAD(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  <strong>Deber√° ingresar la ruta correcta a su archivo WAD.</strong>  ¬°Vamos a correrlo! <br><br>  ¬°Ay!  ¬°Tenemos una ventana de consola que solo se abre por unos segundos!  Nada particularmente √∫til ... ¬øfunciona el programa?  La idea!  ¬°Echemos un vistazo a la memoria y veamos qu√© contiene!  ¬°Quiz√°s all√≠ encontraremos algo especial!  Primero, coloque un punto de interrupci√≥n haciendo doble clic a la izquierda del n√∫mero de l√≠nea.  Deber√≠as ver algo como esto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/c5c/760/44bc5c7609610c9f8f1efd2c2e2046ef.png"></div><br>  Puse un punto de interrupci√≥n inmediatamente despu√©s de leer todos los datos del archivo para mirar la matriz de memoria y ver lo que estaba cargado.  ¬°Ahora ejecute el c√≥digo nuevamente!  En la ventana autom√°tica, veo los primeros bytes.  ¬°Los primeros 4 bytes dicen "IWAD"!  Genial, funciona!  ¬°Nunca pens√© que llegar√≠a este d√≠a!  Entonces, est√° bien, debes calmarte, ¬°todav√≠a hay mucho trabajo por delante! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/1a3/ddb/4c41a3ddb26bfa88f350435ca4792c31.png" alt="Depurar"></div><br><h2>  Leer encabezado </h2><br>  El tama√±o total del encabezado es de 12 bytes (de 0x00 a 0x0b), estos 12 bytes se dividen en 3 grupos.  Los primeros 4 bytes son un tipo de WAD, generalmente "IWAD" o "PWAD".  IWAD deber√≠a ser el WAD oficial lanzado por ID Software, "PWAD" deber√≠a usarse para modificaciones.  En otras palabras, esta es solo una forma de determinar si el archivo WAD es un lanzamiento oficial o si lo publican los modders.  Tenga en cuenta que la cadena no tiene terminaci√≥n NULL, ¬°as√≠ que tenga cuidado!  Los siguientes 4 bytes son int sin signo, que contiene el n√∫mero total de directorios al final del archivo.  Los siguientes 4 bytes indican el desplazamiento del primer directorio. <br><br>  Agreguemos una estructura que almacenar√° informaci√≥n.  Agregar√© un nuevo archivo de encabezado y lo nombrar√© "DataTypes.h".  En √©l describiremos todas las estructuras que necesitamos. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Header</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> WADType[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// I added an extra character to add the NULL uint32_t DirectoryCount; //uint32_t is 4 bytes (32 bits) uint32_t DirectoryOffset; // The offset where the first directory is located. };</span></span></code> </pre> <br>  Ahora necesitamos implementar la clase WADReader, que leer√° datos de la matriz de bytes WAD cargada.  ¬°Ay!  Aqu√≠ hay un truco: los archivos WAD est√°n en formato big-endian, es decir, tendremos que cambiar los bytes para hacerlos little endian (hoy, la mayor√≠a de los sistemas usan little endian).  Para hacer esto, agregaremos dos funciones, una para procesar 2 bytes (16 bits), la otra para procesar 4 bytes (32 bits);  Si necesitamos leer solo 1 byte, entonces no es necesario hacer nada. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> WADReader::bytesToShort(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (pWADData[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | pWADData[offset]; } <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> WADReader::bytesToInteger(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (pWADData[offset + <span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>) | (pWADData[offset + <span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (pWADData[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | pWADData[offset]; }</code> </pre> <br>  Ahora estamos listos para leer el encabezado: cuente los primeros cuatro bytes como char y luego agregue NULL para simplificar nuestro trabajo.  En el caso de la cantidad de directorios y su desplazamiento, simplemente puede usar funciones auxiliares para convertirlos al formato correcto. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WADReader::ReadHeaderData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, Header &amp;header) { <span class="hljs-comment"><span class="hljs-comment">//0x00 to 0x03 header.WADType[0] = pWADData[offset]; header.WADType[1] = pWADData[offset + 1]; header.WADType[2] = pWADData[offset + 2]; header.WADType[3] = pWADData[offset + 3]; header.WADType[4] = '\0'; //0x04 to 0x07 header.DirectoryCount = bytesToInteger(pWADData, offset + 4); //0x08 to 0x0b header.DirectoryOffset = bytesToInteger(pWADData, offset + 8); }</span></span></code> </pre> <br>  Vamos a poner todo junto, llamar a estas funciones e imprimir los resultados. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::ReadDirectories() { WADReader reader; Header header; reader.ReadHeaderData(m_WADData, <span class="hljs-number"><span class="hljs-number">0</span></span>, header); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; header.WADType &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; header.DirectoryCount &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; header.DirectoryOffset &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  ¬°Ejecute el programa y vea si todo funciona! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfa/693/d03/dfa693d039ab66df047768c209561ac2.png"></div><br>  Genial  La l√≠nea IWAD es claramente visible, pero ¬øson correctos los otros dos n√∫meros?  ¬°Intentemos leer directorios usando estos desplazamientos y veamos si funciona! <br><br>  Necesitamos agregar una nueva estructura para manejar el directorio correspondiente a las opciones anteriores. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Directory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> LumpOffset; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> LumpSize; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> LumpName[<span class="hljs-number"><span class="hljs-number">9</span></span>]; };</code> </pre> <br>  Ahora agreguemos la funci√≥n ReadDirectories: ¬°cuente el desplazamiento y d√©les salida! <br><br>  En cada iteraci√≥n, multiplicamos i * 16 para ir al incremento de desplazamiento del siguiente directorio. <br><br><pre> <code class="cpp hljs">Directory directory; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; header.DirectoryCount; ++i) { reader.ReadDirectoryData(m_WADData, header.DirectoryOffset + i * <span class="hljs-number"><span class="hljs-number">16</span></span>, directory); m_WADDirectories.push_back(directory); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; directory.LumpOffset &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; directory.LumpSize &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; directory.LumpName &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br>  Ejecute el c√≥digo y vea qu√© sucede.  Wow!  Una gran lista de directorios. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fb/7b5/af6/8fb7b5af6df0d44303c11d5bd005e93d.png" alt="Correr 2"></div><br>  A juzgar por el nombre de la masa, podemos suponer que logramos leer los datos correctamente, pero tal vez hay una mejor manera de verificar esto.  Echaremos un vistazo a las entradas del Directorio WAD usando Slade3. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/6b7/21c/d1c6b721c04575fe71785efe1f2bdbd3.png"></div><br>  Parece que el nombre y el tama√±o del bulto corresponden a los datos obtenidos con nuestro c√≥digo.  ¬°Hoy hicimos un gran trabajo! <br><br><h2>  Otras notas </h2><br><ul><li>  En alg√∫n momento, pens√© que ser√≠a bueno usar vector para almacenar directorios.  ¬øPor qu√© no usar Map?  Esto ser√° m√°s r√°pido que obtener datos mediante la b√∫squeda lineal de vectores.  Esta es una mala idea  Cuando se usa el mapa, no se rastrear√° el orden de las entradas del directorio, pero necesitamos esta informaci√≥n para obtener los datos correctos. <br><br>  Y otro concepto err√≥neo: Map en C ++ se implementa como √°rboles rojo-negros con tiempo de b√∫squeda O (log N), y las iteraciones sobre el mapa siempre dan un orden creciente de claves.  Si necesita una estructura de datos que proporcione el tiempo promedio O (1) y el peor tiempo O (N), entonces debe usar un mapa desordenado. </li><li>  <s>Cargar todos los archivos WAD en la memoria no es un m√©todo de implementaci√≥n √≥ptimo.</s>  <s>Ser√≠a m√°s l√≥gico simplemente leer los directorios en el encabezado de la memoria y luego regresar al archivo WAD y cargar recursos desde el disco.</s>  <s>Esperemos que alg√∫n d√≠a aprendamos m√°s sobre el almacenamiento en cach√©.</s> <br><br>  <strong>DOOMReboot</strong> : <em>completamente en desacuerdo.</em>  <em>15 MB de RAM en estos d√≠as es una bagatela completa, y leer de memoria ser√° mucho m√°s r√°pido que el voluminoso fseek, que deber√° usarse despu√©s de descargar todo lo necesario para el nivel.</em>  <em>Esto aumentar√° el tiempo de descarga en no menos de uno o dos segundos (me lleva menos de 20 ms descargar todo el tiempo).</em>  <em>fseek usa el sistema operativo.</em>  <em>Qu√© archivo es m√°s probable en la memoria cach√© de RAM, pero puede que no.</em>  <em>Pero incluso si √©l est√° all√≠, es una gran p√©rdida de recursos y estas operaciones confundir√°n muchas lecturas de WAD en t√©rminos de cach√© de CPU.</em>  <em>Lo mejor es que puede crear m√©todos de arranque h√≠bridos y almacenar datos WAD para un nivel que se ajuste al cach√© L3 de los procesadores modernos, donde los ahorros ser√°n incre√≠bles.</em> </li></ul><br><h2>  C√≥digo fuente </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥digo fuente</a> <br><br><h2>  Datos b√°sicos de la tarjeta </h2><br>  Despu√©s de haber aprendido a leer el archivo WAD, intentemos usar los datos le√≠dos.  Ser√° genial aprender a leer los datos de la misi√≥n (mundo / nivel) y aplicarlos.  Los "fragmentos" de estas misiones (Mission Lumps) deber√≠an ser algo complejo y complicado.  Por lo tanto, necesitaremos movernos y desarrollar el conocimiento gradualmente.  Como primer peque√±o paso, creemos algo as√≠ como una caracter√≠stica de Automap: un plano bidimensional de un mapa con una vista superior.  Primero, veamos qu√© hay dentro del bulto de la misi√≥n. <br><br><h2>  Anatom√≠a de la tarjeta </h2><br>  Comencemos de nuevo: la descripci√≥n de los niveles de DOOM es muy similar al dibujo 2D, en el que las paredes est√°n marcadas con l√≠neas.  Sin embargo, para obtener coordenadas 3D, cada pared toma la altura del piso y el techo (XY es el plano a lo largo del cual nos movemos horizontalmente, y Z es la altura que nos permite movernos hacia arriba y hacia abajo, por ejemplo, al levantarnos en un elevador o saltar desde una plataforma. Los componentes de coordenadas se utilizan para representar la misi√≥n como un mundo 3D, sin embargo, para garantizar un buen rendimiento, el motor tiene ciertas limitaciones: no hay habitaciones ubicadas una encima de la otra en los niveles y el jugador no puede mirar hacia arriba y hacia abajo. Otra caracter√≠stica interesante: proyectiles y  Las rocas, por ejemplo, los cohetes, ascienden verticalmente para alcanzar un objetivo ubicado en una plataforma m√°s alta. <br><br>  Estas caracter√≠sticas curiosas han provocado un sinf√≠n de preguntas acerca de si el DOOM es un motor 2D o 3D.  Poco a poco, se alcanz√≥ un compromiso diplom√°tico, que salv√≥ muchas vidas: las partes acordaron la designaci√≥n "2.5D" aceptable para ambos. <br><br>  Para simplificar la tarea y volver al tema, intentemos leer estos datos 2D y ver si pueden usarse de alguna manera.  M√°s adelante intentaremos renderizarlos en 3D, pero por ahora necesitamos entender c√≥mo funcionan juntas las partes individuales del motor. <br><br>  Despu√©s de realizar una investigaci√≥n, descubr√≠ que cada misi√≥n se compone de un conjunto de "piezas".  Estos "Bultos" siempre se representan en el archivo WAD de un juego DOOM en el mismo orden. <br><br><ol><li>  <strong>V√©rtices: los</strong> puntos finales de las paredes en 2D.  Dos VERTEX conectados forman un LINEDEF.  Tres VERTEX conectados forman dos paredes / LINEDEF, y as√≠ sucesivamente.  Se pueden percibir simplemente como los puntos de conexi√≥n de dos o m√°s paredes.  (S√≠, la mayor√≠a de la gente prefiere el plural "V√©rtices", pero a John Carmack no le gust√≥. Seg√∫n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">merriam-webster</a> , se aplican ambas opciones. </li><li>  <strong>LINEDEFS:</strong> l√≠neas que forman juntas entre v√©rtices y paredes que forman.  No todas las l√≠neas (paredes) se comportan igual, hay banderas que especifican el comportamiento de dichas l√≠neas. </li><li>  <strong>DEDOS LADOS:</strong> en la vida real, las paredes tienen dos lados: miramos uno, el segundo est√° del otro lado.  Los dos lados pueden tener diferentes texturas, y SIDEDEFS es el bulto que contiene la informaci√≥n de textura para la pared (LINEDEF). </li><li>  <strong>SECTORES: los</strong> sectores son "salas" obtenidas por la uni√≥n LINEDEF.  Cada sector contiene informaci√≥n como alturas de piso y techo, texturas, valores de iluminaci√≥n, acciones especiales, como mover pisos / plataformas / elevadores.  Algunos de estos par√°metros tambi√©n afectan la forma en que se representan las paredes, por ejemplo, el nivel de iluminaci√≥n y el c√°lculo de las coordenadas del mapeo de texturas. </li><li>  <strong>SECTORES:</strong> (subsectores) forman √°reas convexas dentro de un sector que se utilizan para renderizar junto con el bypass BSP, y tambi√©n ayudan a determinar d√≥nde se encuentra un jugador en un nivel particular.  Son bastante √∫tiles y a menudo se usan para determinar la posici√≥n vertical de un jugador.  Cada SSECTOR consta de partes conectadas de un sector, por ejemplo, de paredes que forman un √°ngulo.  Tales partes de las paredes, o "segmentos", se almacenan en su propio bulto llamado ... </li><li>  <strong>SEGS:</strong> piezas de pared / LINEDEF;  en otras palabras, estos son los "segmentos" del muro / LINEDEF.  El mundo se representa sin pasar por el √°rbol BSP para determinar qu√© paredes dibujar primero (las primeras son las m√°s cercanas).  Aunque el sistema funciona muy bien, a menudo hace que los linedefs se dividan en dos o m√°s SEG.  Estos SEG se utilizan para representar muros en lugar de LINEDEF.  La geometr√≠a de cada SSECTOR est√° determinada por los segmentos contenidos en √©l. </li><li>  <strong>NODOS:</strong> Un nodo BSP es un nodo de una estructura de √°rbol binario que almacena datos del subsector.  Se utiliza para determinar r√°pidamente qu√© SSECTOR (y SEG) est√°n delante del jugador.  La eliminaci√≥n de los SEG ubicados detr√°s del jugador y, por lo tanto, invisibles, permite que el motor se concentre en los SEG potencialmente visibles, lo que reduce significativamente el tiempo de renderizado. </li><li>  <strong>COSAS: El</strong> bulto llamado COSAS es una lista de actores de escenarios y misiones (enemigos, armas, etc.).  Cada elemento de este bulto contiene informaci√≥n sobre una instancia del actor / conjunto, por ejemplo, el tipo de objeto, el punto de creaci√≥n, la direcci√≥n, etc. </li><li>  <strong>RECHAZAR:</strong> este bulto contiene datos sobre qu√© sectores son visibles desde otros sectores.  Se utiliza para determinar cu√°ndo un monstruo se entera de la presencia de un jugador.  Tambi√©n se utiliza para determinar el rango de distribuci√≥n de sonidos creados por el jugador, por ejemplo, disparos.  Cuando ese sonido puede transmitirse al sector del monstruo, puede averiguar sobre el jugador.  La tabla RECHAZAR tambi√©n se puede utilizar para acelerar el reconocimiento de colisiones de proyectiles de armas. </li><li>  <strong>BLOCKMAP:</strong> informaci√≥n de reconocimiento de colisi√≥n del jugador y movimiento de THING.  Consiste en una cuadr√≠cula que cubre la geometr√≠a de toda la misi√≥n.  Cada celda de la cuadr√≠cula contiene una lista de LINEDEF que est√°n dentro o que se cruzan con ella.  Se utiliza para acelerar significativamente el reconocimiento de colisiones: se requieren comprobaciones de colisi√≥n para solo unos pocos LINEDEF por jugador / COSA, lo que ahorra significativamente la potencia inform√°tica. </li></ol><br>  Al generar nuestro mapa 2D, nos centraremos en VERTEXOS y LINEDEFS.  Si podemos dibujar los v√©rtices y conectarlos con las l√≠neas dadas por linedef, entonces necesitamos generar un modelo 2D del mapa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f4/dd4/a3b/3f4dd4a3b79fab0d47e7f1212a73df83.png" alt="Mapa de demostraci√≥n"></div><br>  La tarjeta de demostraci√≥n que se muestra arriba tiene las siguientes caracter√≠sticas: <br><br><ul><li>  4 picos <ul><li>  v√©rtice 1 en (10.10) </li><li>  top 2 en (10,100) </li><li>  top 3 en (100, 10) </li><li>  pico 4 in (100,100) </li></ul></li><li>  4 lineas <ul><li>  l√≠nea de arriba 1 a 2 </li><li>  l√≠nea de arriba 1 a 3 </li><li>  l√≠nea de arriba 2 a 4 </li><li>  l√≠nea de arriba 3 a 4 </li></ul></li></ul><br><h3>  Formato de v√©rtice </h3><br>  Como es de esperar, los datos de v√©rtice son muy simples: solo x e y (punto) de algunas coordenadas. <br><br><div class="scrollable-table"><table><thead><tr><th>  Tama√±o del campo </th><th>  Tipo de datos </th><th>  Contenido </th></tr></thead><tbody><tr><td>  0x00-0x01 </td><td>  Corto firmado </td><td>  Posici√≥n X </td></tr><tr><td>  0x02-0x03 </td><td>  Corto firmado </td><td>  Posici√≥n Y </td></tr></tbody></table></div><br><h3>  Formato Linedef </h3><br>  Linedef contiene m√°s informaci√≥n; describe la l√≠nea que conecta los dos v√©rtices y las propiedades de esta l√≠nea (que luego se convertir√° en un muro). <br><br><div class="scrollable-table"><table><thead><tr><th>  Tama√±o del campo </th><th>  Tipo de datos </th><th>  Contenido </th></tr></thead><tbody><tr><td>  0x00-0x01 </td><td>  Corto sin signo </td><td>  Pico de inicio </td></tr><tr><td>  0x02-0x03 </td><td>  Corto sin signo </td><td>  Pico m√°ximo </td></tr><tr><td>  0x04-0x05 </td><td>  Corto sin signo </td><td>  Banderas (ver m√°s abajo para m√°s detalles) </td></tr><tr><td>  0x06-0x07 </td><td>  Corto sin signo </td><td>  Tipo de l√≠nea / acci√≥n </td></tr><tr><td>  0x08-0x09 </td><td>  Corto sin signo </td><td>  Etiqueta sectorial </td></tr><tr><td>  0x10-0x11 </td><td>  Corto sin signo </td><td>  Front sidedef (0xFFFF - sin lado) </td></tr><tr><td>  0x12-0x13 </td><td>  Corto sin signo </td><td>  Dedo lateral trasero (0xFFFF - sin lado) </td></tr></tbody></table></div><br><h3>  Linedef Flag Values </h3><br>  No todas las l√≠neas (paredes) est√°n dibujadas.  Algunos de ellos tienen un comportamiento especial. <br><br><div class="scrollable-table"><table><thead><tr><th>  Poco </th><th>  Descripci√≥n </th></tr></thead><tbody><tr><td>  0 0 </td><td>  Bloquea el camino para jugadores y monstruos. </td></tr><tr><td>  1 </td><td>  Bloque monstruos </td></tr><tr><td>  2 </td><td>  Doble cara </td></tr><tr><td>  3 </td><td>  La textura superior est√° desactivada (hablaremos de esto m√°s adelante) </td></tr><tr><td>  4 4 </td><td>  La textura inferior est√° desactivada (hablaremos de esto m√°s adelante) </td></tr><tr><td>  5 5 </td><td>  Secreto (se muestra en el mapa como un muro unilateral) </td></tr><tr><td>  6 6 </td><td>  Obstruye el sonido </td></tr><tr><td>  7 7 </td><td>  Nunca se muestra en la tarjeta autom√°tica </td></tr><tr><td>  8 </td><td>  Siempre se muestra en autocard </td></tr></tbody></table></div><br><h2>  Objetivos </h2><br><ol><li>  Crea una clase de Mapa. </li><li>  Leer datos de v√©rtices. </li><li>  Leer datos linedef. </li></ol><br><h2>  Arquitectura </h2><br>  Primero, creemos una clase y llam√©mosla mapa.  En √©l almacenaremos todos los datos asociados con la tarjeta. <br><br>  Por ahora, planeo almacenar solo v√©rtices y linedefs como un vector, para poder aplicarlos m√°s tarde. <br><br>  Adem√°s, complementemos WADLoader y WADReader para que podamos leer estas dos nuevas piezas de informaci√≥n. <br><br><h2>  Codificaci√≥n </h2><br>  El c√≥digo ser√° similar al c√≥digo de lectura de WAD, solo agregaremos unas pocas estructuras m√°s y luego los llenaremos con datos de WAD.  Comencemos agregando una nueva clase y pasando el nombre del mapa. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Map(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sName); ~Map(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Incase someone need to know the map name void AddVertex(Vertex &amp;v); // Wrapper class to append to the vertexes vector void AddLinedef(Linedef &amp;l); // Wrapper class to append to the linedef vector protected: std::string m_sName; std::vector&lt;Vertex&gt; m_Vertexes; std::vector&lt;Linedef&gt; m_Linedef; };</span></span></code> </pre> <br>  Ahora agregue estructuras para leer estos nuevos campos.  Como ya lo hemos hecho varias veces, solo agr√©guelas todas a la vez. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vertex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> XPosition; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> YPosition; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Linedef</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> StartVertex; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> EndVertex; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Flags; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> LineType; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> SectorTag; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> FrontSidedef; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> BackSidedef; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A continuaci√≥n, necesitamos una funci√≥n para leerlos desde WADReader, estar√° cerca de lo que hicimos antes. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WADReader::ReadVertexData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, Vertex &amp;vertex) { vertex.XPosition = Read2Bytes(pWADData, offset); vertex.YPosition = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WADReader::ReadLinedefData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pWADData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, Linedef &amp;linedef) { linedef.StartVertex = Read2Bytes(pWADData, offset); linedef.EndVertex = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">2</span></span>); linedef.Flags = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">4</span></span>); linedef.LineType = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">6</span></span>); linedef.SectorTag = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">8</span></span>); linedef.FrontSidedef = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">10</span></span>); linedef.BackSidedef = Read2Bytes(pWADData, offset + <span class="hljs-number"><span class="hljs-number">12</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creo que no hay nada nuevo para ti aqu√≠. </font><font style="vertical-align: inherit;">Y ahora necesitamos llamar a estas funciones desde la clase WADLoader. </font><font style="vertical-align: inherit;">Perm√≠tanme exponer los hechos: la secuencia de grumos es importante aqu√≠, encontraremos el nombre del mapa en el directorio de grumos, seguido de todos los grumos asociados con los mapas en el orden dado. </font><font style="vertical-align: inherit;">Para simplificar nuestra tarea y no rastrear los √≠ndices de bultos por separado, agregaremos una enumeraci√≥n que nos permite deshacernos de los n√∫meros m√°gicos.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EMAPLUMPSINDEX { eTHINGS = <span class="hljs-number"><span class="hljs-number">1</span></span>, eLINEDEFS, eSIDEDDEFS, eVERTEXES, eSEAGS, eSSECTORS, eNODES, eSECTORS, eREJECT, eBLOCKMAP, eCOUNT };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n agregar√© una funci√≥n para buscar un mapa por su nombre en la lista de directorios. </font><font style="vertical-align: inherit;">M√°s adelante, es probable que aumentemos el rendimiento de este paso mediante el uso de la estructura de datos del mapa, porque aqu√≠ hay un n√∫mero significativo de registros, y tendremos que revisarlos con bastante frecuencia, especialmente al comienzo de cargar recursos como texturas, sprites, sonidos, etc.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> WADLoader::FindMapIndex(Map &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_WADDirectories.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_WADDirectories[i].LumpName == <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.GetName()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Guau, ya casi hemos terminado! </font><font style="vertical-align: inherit;">Ahora, ¬°solo contemos los VERTEXOS! </font><font style="vertical-align: inherit;">Repito, ya hemos hecho esto antes, ahora debes entender esto.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::ReadMapVertex(Map &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iMapIndex = FindMapIndex(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iMapIndex == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } iMapIndex += EMAPLUMPSINDEX::eVERTEXES; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(m_WADDirectories[iMapIndex].LumpName, <span class="hljs-string"><span class="hljs-string">"VERTEXES"</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVertexSizeInBytes = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Vertex); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVertexesCount = m_WADDirectories[iMapIndex].LumpSize / iVertexSizeInBytes; Vertex vertex; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; iVertexesCount; ++i) { m_Reader.ReadVertexData(m_WADData, m_WADDirectories[iMapIndex].LumpOffset + i * iVertexSizeInBytes, vertex); <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.AddVertex(vertex); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; vertex.XPosition &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; vertex.YPosition &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hmm, parece que estamos copiando constantemente el mismo c√≥digo; </font><font style="vertical-align: inherit;">Puede que tenga que optimizarlo en el futuro, pero por ahora implementar√° ReadMapLinedef usted mismo (o mire el c√≥digo fuente desde el enlace). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toques finales: necesitamos llamar a esta funci√≥n y pasarle el objeto del mapa.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WADLoader::LoadMapData(Map &amp;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ReadMapVertex(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: Failed to load map vertex data MAP: "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.GetName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ReadMapLinedef(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: Failed to load map linedef data MAP: "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.GetName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora cambiemos la funci√≥n principal y veamos si todo funciona. </font><font style="vertical-align: inherit;">Quiero cargar el mapa "E1M1", que transferir√© al objeto del mapa.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">Map </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"E1M1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; wadloader.LoadMapData(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora vamos a ejecutarlo todo. </font><font style="vertical-align: inherit;">Wow, un mont√≥n de n√∫meros interesantes, pero ¬øson ciertos? </font><font style="vertical-align: inherit;">¬°Vamos a echarle un vistazo! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veamos si slade puede ayudarnos con esto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos encontrar el mapa en el men√∫ de slade y ver los detalles de los bultos. </font><font style="vertical-align: inherit;">Comparemos los n√∫meros.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48b/3ec/439/48b3ec43988e25260d45a4abd1999c91.png" alt="V√©rtice"></div><br>  Genial <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øQu√© hay de Linedef? </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96f/93d/ecd/96f93decd409dad0b8b6836726345a08.png" alt="Linedef"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambi√©n agregu√© esta enumeraci√≥n, que intentaremos usar al representar el mapa. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ELINEDEFFLAGS { eBLOCKING = <span class="hljs-number"><span class="hljs-number">0</span></span>, eBLOCKMONSTERS = <span class="hljs-number"><span class="hljs-number">1</span></span>, eTWOSIDED = <span class="hljs-number"><span class="hljs-number">2</span></span>, eDONTPEGTOP = <span class="hljs-number"><span class="hljs-number">4</span></span>, eDONTPEGBOTTOM = <span class="hljs-number"><span class="hljs-number">8</span></span>, eSECRET = <span class="hljs-number"><span class="hljs-number">16</span></span>, eSOUNDBLOCK = <span class="hljs-number"><span class="hljs-number">32</span></span>, eDONTDRAW = <span class="hljs-number"><span class="hljs-number">64</span></span>, eDRAW = <span class="hljs-number"><span class="hljs-number">128</span></span> };</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Otras notas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el proceso de escribir el c√≥digo, le√≠ por error m√°s bytes de los necesarios y recib√≠ valores incorrectos. </font><font style="vertical-align: inherit;">Para la depuraci√≥n, comenc√© a mirar el desplazamiento WAD en la memoria para ver si estaba en el desplazamiento correcto. </font><font style="vertical-align: inherit;">Esto se puede hacer usando la ventana de memoria de Visual Studio, que es una herramienta muy √∫til para rastrear bytes o memoria (tambi√©n puede establecer puntos de interrupci√≥n en esta ventana). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si no ve la ventana de memoria, vaya a Depurar&gt; Memoria&gt; Memoria.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/cba/0d3/27dcba0d33094493822f4444a4c0d8c8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora vemos los valores en memoria en hexadecimal. </font><font style="vertical-align: inherit;">Estos valores se pueden comparar con la visualizaci√≥n hexadecimal en slade haciendo clic derecho en cualquier bulto y mostr√°ndolo como hexadecimal.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cc/159/757/1cc15975726f8a1204bf674aa0824fc6.png" alt="Slade"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comp√°relos con la direcci√≥n del WAD cargado en la memoria. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/970/2af/c96/9702afc96be99794e7d9f01e4d6d89bb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y lo √∫ltimo para hoy: vimos todos estos valores de v√©rtice, pero ¬øhay una manera f√°cil de visualizarlos sin escribir c√≥digo? </font><font style="vertical-align: inherit;">No quiero perder tiempo en esto, solo para descubrir que nos estamos moviendo en la direcci√≥n equivocada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seguramente alguien ya cre√≥ un trazador. </font><font style="vertical-align: inherit;">Busqu√© en Google "dibujar puntos en un gr√°fico" y el primer resultado fue el sitio web de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plot Points: Desmos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En √©l, puede pegar n√∫meros del portapapeles y √©l los dibujar√°. </font><font style="vertical-align: inherit;">Deben estar en el formato "(x, y)". </font><font style="vertical-align: inherit;">Para obtenerlo, simplemente cambie la funci√≥n de salida a la pantalla.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"("</span></span> &lt;&lt; vertex.XPosition &lt;&lt; <span class="hljs-string"><span class="hljs-string">","</span></span> &lt;&lt; vertex.YPosition &lt;&lt; <span class="hljs-string"><span class="hljs-string">")"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wow! </font><font style="vertical-align: inherit;">¬°Ya parece un E1M1! </font><font style="vertical-align: inherit;">¬°Hemos logrado algo!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/ce6/36b/499ce636b2dbd6bd3e158bff07304b37.png" alt="Puntos de trazado E1M1"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si eres perezoso para hacer esto, aqu√≠ hay un enlace a un gr√°fico punteado: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plot Vertex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero demos un paso m√°s: despu√©s de un poco de trabajo, podemos conectar estos puntos en funci√≥n de linedefs.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/423/35b/c2f42335b751d3bd9acec03251204977.png" alt="E1M1 Plot Vertex"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ est√° el enlace: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E1M1 Plot Vertex</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo fuente </font></font></h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥digo fuente</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Referencias </font></font></h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom Wiki </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZDoom Wiki</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/471552/">https://habr.com/ru/post/471552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471538/index.html">Desde la idea de una aplicaci√≥n m√≥vil hasta el MVP en el que los inversores invertir√°n</a></li>
<li><a href="../471542/index.html">Reconocimiento de texto OCR</a></li>
<li><a href="../471544/index.html">Sobre el amor, o por qu√© el centuri√≥n cosaco cambi√≥ su uniforme por una t√∫nica uzbeka</a></li>
<li><a href="../471548/index.html">Los 5 mejores libros para leer de un artista</a></li>
<li><a href="../471550/index.html">¬øD√≥nde obtener audio para el desarrollo de juegos y otros proyectos comerciales? Bibliotecas con los sonidos de la naturaleza.</a></li>
<li><a href="../471554/index.html">¬øC√≥mo reducir los riesgos de reclamos fiscales por la venta de aplicaciones y contenido?</a></li>
<li><a href="../471556/index.html">Fujitsu World Tour 2019. ¬øC√≥mo fue nuestra conferencia m√°s grande?</a></li>
<li><a href="../471558/index.html">Mam√°, estoy en televisi√≥n: ¬øc√≥mo fue el final del concurso Digital Breakthrough?</a></li>
<li><a href="../471562/index.html">Superinfecci√≥n 2: rubic√≥n de problemas, el fiasco de la tecnolog√≠a y una nueva esperanza</a></li>
<li><a href="../471564/index.html">Friends RaspberryPi con TP-Link TL-WN727N</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>