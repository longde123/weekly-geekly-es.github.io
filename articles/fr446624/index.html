<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî¥ „äóÔ∏è ‚òéÔ∏è Index dans PostgreSQL - 6 (SP-GiST) ‚ú¥Ô∏è üë©üèª‚Äç‚öïÔ∏è üçº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avons d√©j√† discut√© du moteur d'indexation PostgreSQL, de l'interface des m√©thodes d'acc√®s et de trois m√©thodes: l' index de hachage , l' arboresc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Index dans PostgreSQL - 6 (SP-GiST)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/446624/">  Nous avons d√©j√† discut√© du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moteur d'indexation</a> PostgreSQL, de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'interface des m√©thodes d'acc√®s</a> et de trois m√©thodes: l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">index de hachage</a> , l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arborescence B</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GiST</a> .  Dans cet article, nous d√©crirons SP-GiST. <br><br><h1>  SP-GiST </h1><br>  Tout d'abord, quelques mots sur ce nom.  La partie "GiST" fait allusion √† une certaine similitude avec la m√©thode d'acc√®s du m√™me nom.  La similitude existe: les deux sont des arbres de recherche g√©n√©ralis√©s qui fournissent un cadre pour la construction de diverses m√©thodes d'acc√®s. <br><br>  "SP" signifie partitionnement d'espace.  L'espace ici est souvent juste ce que nous appelons un espace, par exemple un plan √† deux dimensions.  Mais nous verrons que tout espace de recherche est destin√©, c'est-√†-dire en fait n'importe quel domaine de valeur. <br><br>  SP-GiST convient aux structures o√π l'espace peut √™tre r√©cursivement divis√© en zones <em>sans intersection</em> .  Cette classe comprend les arbres quadruples, les arbres k-dimensionnels (arbres kD) et les arbres radix. <br><a name="habracut"></a><br><h2>  La structure </h2><br>  Ainsi, l'id√©e de la m√©thode d'acc√®s SP-GiST est de diviser le domaine de valeur en <em>sous-</em> domaines <em>non chevauchants,</em> chacun pouvant √† son tour √©galement √™tre divis√©.  Le partitionnement comme celui-ci induit <em>des</em> arbres <em>non √©quilibr√©s</em> (contrairement aux arbres B et au GiST standard). <br><br>  Le fait de ne pas se croiser simplifie la prise de d√©cision lors de l'insertion et de la recherche.  En revanche, en r√®gle g√©n√©rale, les arbres induits sont de faible ramification.  Par exemple, un n≈ìud d'un arbre quadruple a g√©n√©ralement quatre n≈ìuds enfants (contrairement aux arbres B, o√π les n≈ìuds s'√©l√®vent √† des centaines) et une plus grande profondeur.  De tels arbres conviennent bien au travail en RAM, mais l'index est stock√© sur un disque et, par cons√©quent, pour r√©duire le nombre d'op√©rations d'E / S, les n≈ìuds doivent √™tre regroup√©s dans des pages, et il n'est pas facile de le faire efficacement.  En outre, le temps qu'il faut pour trouver diff√©rentes valeurs dans l'index peut varier en raison des diff√©rences de profondeur de branche. <br><br>  Cette m√©thode d'acc√®s, de la m√™me mani√®re que GiST, prend en charge les t√¢ches de bas niveau (acc√®s et verrous simultan√©s, journalisation et algorithme de recherche pur) et fournit une interface simplifi√©e sp√©cialis√©e pour permettre l'ajout de la prise en charge de nouveaux types de donn√©es et de nouveaux algorithmes de partitionnement. <br><br>  Un n≈ìud interne de l'arborescence SP-GiST stocke les r√©f√©rences aux n≈ìuds enfants;  une <em>√©tiquette</em> peut √™tre d√©finie pour chaque r√©f√©rence.  De plus, un n≈ìud interne peut stocker une valeur appel√©e <em>pr√©fixe</em> .  En fait, cette valeur n'est pas obligatoire un pr√©fixe;  il peut √™tre consid√©r√© comme un pr√©dicat arbitraire respect√© pour tous les n≈ìuds enfants. <br><br>  Les n≈ìuds feuilles de SP-GiST contiennent une valeur de type index√© et une r√©f√©rence √† une ligne de table (TID).  Les donn√©es index√©es elles-m√™mes (cl√© de recherche) peuvent √™tre utilis√©es comme valeur, mais ne sont pas obligatoires: une valeur raccourcie peut √™tre stock√©e. <br><br>  De plus, les n≈ìuds feuilles peuvent √™tre regroup√©s dans des listes.  Ainsi, un n≈ìud interne peut r√©f√©rencer non seulement une valeur, mais une liste enti√®re. <br><br>  Notez que les pr√©fixes, les √©tiquettes et les valeurs dans les n≈ìuds terminaux ont leurs propres types de donn√©es, ind√©pendants les uns des autres. <br><br>  De la m√™me mani√®re que dans GiST, la fonction principale √† d√©finir pour la recherche est <em>la fonction de coh√©rence</em> .  Cette fonction est appel√©e pour un n≈ìud d'arbre et renvoie un ensemble de n≈ìuds enfants dont les valeurs "sont coh√©rentes" avec le pr√©dicat de recherche (comme d'habitude, sous la forme " <em>expression d'op√©rateur de champ index√©</em> ").  Pour un n≈ìud feuille, la fonction de coh√©rence d√©termine si la valeur index√©e dans ce n≈ìud correspond au pr√©dicat de recherche. <br><br>  La recherche commence par le n≈ìud racine.  La fonction de coh√©rence permet de savoir quels n≈ìuds enfants il est logique de visiter.  L'algorithme se r√©p√®te pour chacun des n≈ìuds trouv√©s.  La recherche est la profondeur d'abord. <br><br>  Au niveau physique, les n≈ìuds d'index sont regroup√©s dans des pages pour rendre le travail avec les n≈ìuds efficace du point de vue des op√©rations d'E / S.  Notez qu'une page peut contenir des n≈ìuds internes ou terminaux, mais pas les deux. <br><br><h2>  Exemple: quadtree </h2><br>  Un quadtree est utilis√© pour indexer des points dans un plan.  Une id√©e est de diviser r√©cursivement les zones en quatre parties (quadrants) par rapport au <em>point central</em> .  La profondeur des branches dans un tel arbre peut varier et d√©pend de la densit√© des points dans les quadrants appropri√©s. <br><br>  Voil√† √† quoi cela ressemble en chiffres, par exemple de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">base de donn√©es de d√©monstration</a> augment√©e par les a√©roports du site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">openflights.org</a> .  Soit dit en passant, nous avons r√©cemment publi√© une nouvelle version de la base de donn√©es dans laquelle, parmi les autres, nous avons remplac√© la longitude et la latitude par un champ de type "point". <br><br><img src="https://habrastorage.org/web/8ab/6f6/4e7/8ab6f64e7bb5484bbfc798327798ce69.png"><br>  <em>Tout d'abord, nous avons divis√© l'avion en quatre quadrants ...</em> <br><br><img src="https://habrastorage.org/web/6b5/ce5/3e1/6b5ce53e1b57499cad2a61a86a451835.png"><br>  <em>Ensuite, nous avons divis√© chacun des quadrants ...</em> <br><br><img src="https://habrastorage.org/web/ba5/e5d/10a/ba5e5d10a47844a2bc95e5505641e798.png"><br>  <em>Et ainsi de suite jusqu'√† ce que nous obtenions le partitionnement final.</em> <br><br>  Fournissons plus de d√©tails sur un exemple simple que nous avons d√©j√† consid√©r√© dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article li√© √† GiST</a> .  Voyez √† quoi le partitionnement peut ressembler dans ce cas: <br><br><img src="https://habrastorage.org/web/a98/6f1/065/a986f106505b4b0fa0b03005a2c657f3.png"><br><br>  Les quadrants sont num√©rot√©s comme indiqu√© sur la premi√®re figure.  Par souci de clart√©, pla√ßons les n≈ìuds enfants de gauche √† droite exactement dans la m√™me s√©quence.  Une structure d'index possible dans ce cas est illustr√©e dans la figure ci-dessous.  Chaque n≈ìud interne fait r√©f√©rence √† un maximum de quatre n≈ìuds enfants.  Chaque r√©f√©rence peut √™tre √©tiquet√©e avec le num√©ro du quadrant, comme sur la figure.  Mais il n'y a pas d'√©tiquette dans l'impl√©mentation car il est plus pratique de stocker un tableau fixe de quatre r√©f√©rences dont certaines peuvent √™tre vides. <br><br><img src="https://habrastorage.org/web/24c/3cf/97f/24c3cf97f59b4f99acb2aa992d1825d6.png"><br><br>  Les points qui se trouvent sur les limites se rapportent au quadrant avec le plus petit nombre. <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> points(p <span class="hljs-type"><span class="hljs-type">point</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> points(p) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(1,1)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(3,2)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(6,3)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(5,5)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(7,8)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(8,6)'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> points_quad_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(p);</code> </pre> <br>  Dans ce cas, la classe d'op√©rateur "quad_point_ops" est utilis√©e par d√©faut, qui contient les op√©rateurs suivants: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'quad_point_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'spgist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------+-------------- &lt;&lt;(point,point) | 1 strictly left &gt;&gt;(point,point) | 5 strictly right ~=(point,point) | 6 coincides &lt;^(point,point) | 10 strictly below &gt;^(point,point) | 11 strictly above &lt;@(point,box) | 8 contained in rectangle (6 rows)</code> </pre><br>  Par exemple, regardons comment la requ√™te <code>select * from points where p &gt;^ point '(2,7)'</code> sera ex√©cut√© (trouver tous les points qui se trouvent au-dessus de celui donn√©). <br><br><img src="https://habrastorage.org/web/5f3/194/855/5f3194855fe74166b56c1703f4bb9b07.png"><br><br>  Nous commen√ßons par le n≈ìud racine et utilisons la fonction de coh√©rence pour s√©lectionner les n≈ìuds enfants √† descendre.  Pour l'op√©rateur <code>&gt;^</code> , cette fonction compare le point (2,7) avec le point central du n≈ìud (4,4) et s√©lectionne les quadrants pouvant contenir les points recherch√©s, dans ce cas, les premier et quatri√®me quadrants. <br><br>  Dans le n≈ìud correspondant au premier quadrant, nous d√©terminons √† nouveau les n≈ìuds enfants √† l'aide de la fonction de coh√©rence.  Le point central est (6,6), et nous devons √† nouveau regarder √† travers les premier et quatri√®me quadrants. <br><br><img src="https://habrastorage.org/web/8ac/99b/d9e/8ac99bd9e7b94f8d9683307b98ad1875.png"><br><br>  La liste des n≈ìuds feuilles (8.6) et (7.8) correspond au premier quadrant, dont seul le point (7.8) remplit la condition de requ√™te.  La r√©f√©rence au quatri√®me quadrant est vide. <br><br>  Dans le n≈ìud interne (4.4), la r√©f√©rence au quatri√®me quadrant est √©galement vide, ce qui termine la recherche. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p &gt;^ <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(2,7)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------ Index Only Scan using points_quad_idx on points Index Cond: (p &gt;^ '(2,7)'::point) (2 rows)</code> </pre><br><h3>  Internes </h3><br>  Nous pouvons explorer la structure interne des index SP-GiST en utilisant l'extension " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gevel</a> ", qui a √©t√© mentionn√©e pr√©c√©demment.  La mauvaise nouvelle est qu'en raison d'un bogue, cette extension ne fonctionne pas correctement avec les versions modernes de PostgreSQL.  La bonne nouvelle est que nous pr√©voyons d'√©tendre "pageinspect" avec la fonctionnalit√© de "gevel" ( <a href="">discussion</a> ).  Et le bug a d√©j√† √©t√© corrig√© dans "pageinspect". <br><blockquote>  Encore une fois, la mauvaise nouvelle est que le patch est rest√© sans aucun progr√®s. <br></blockquote><br>  Par exemple, prenons la base de donn√©es de d√©monstration √©tendue, qui a √©t√© utilis√©e pour dessiner des images avec la carte du monde. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> airports_coordinates_quad_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> airports_ml <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(coordinates);</code> </pre><br>  Tout d'abord, nous pouvons obtenir des statistiques pour l'indice: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_stats(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_quad_idx'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> spgist_stats ---------------------------------- totalPages: 33 + deletedPages: 0 + innerPages: 3 + leafPages: 30 + emptyPages: 2 + usedSpace: 201.53 kbytes+ usedInnerSpace: 2.17 kbytes + usedLeafSpace: 199.36 kbytes+ freeSpace: 61.44 kbytes + fillRatio: 76.64% + leafTuples: 5993 + innerTuples: 37 + innerAllTheSame: 0 + leafPlaceholders: 725 + innerPlaceholders: 0 + leafRedirects: 0 + innerRedirects: 0 (1 row)</code> </pre><br>  Et deuxi√®mement, nous pouvons sortir l'arbre d'index lui-m√™me: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> tid, n, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, tid_ptr, prefix, leaf_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_print(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_quad_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t( tid tid, allthesame <span class="hljs-type"><span class="hljs-type">bool</span></span>, n <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, tid_ptr tid, prefix <span class="hljs-type"><span class="hljs-type">point</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- prefix type node_label int, -- label type (unused here) leaf_value point -- list value type ) order by tid, n;</span></span></code> </pre><pre> <code class="plaintext hljs"> tid | n | level | tid_ptr | prefix | leaf_value ---------+---+-------+---------+------------------+------------------ (1,1) | 0 | 1 | (5,3) | (-10.220,53.588) | (1,1) | 1 | 1 | (5,2) | (-10.220,53.588) | (1,1) | 2 | 1 | (5,1) | (-10.220,53.588) | (1,1) | 3 | 1 | (5,14) | (-10.220,53.588) | (3,68) | | 3 | | | (86.107,55.270) (3,70) | | 3 | | | (129.771,62.093) (3,85) | | 4 | | | (57.684,-20.430) (3,122) | | 4 | | | (107.438,51.808) (3,154) | | 3 | | | (-51.678,64.191) (5,1) | 0 | 2 | (24,27) | (-88.680,48.638) | (5,1) | 1 | 2 | (5,7) | (-88.680,48.638) | ...</code> </pre><br>  Mais gardez √† l'esprit que "spgist_print" ne produit pas toutes les valeurs de feuille, mais seulement la premi√®re de la liste, et montre donc la structure de l'index plut√¥t que son contenu complet. <br><br><h2>  Exemple: arbres k-dimensionnels </h2><br>  Pour les m√™mes points dans le plan, nous pouvons √©galement sugg√©rer une autre fa√ßon de partitionner l'espace. <br><br>  Dessinons <em>une ligne horizontale</em> passant par le premier point index√©.  Il divise l'avion en deux parties: sup√©rieure et inf√©rieure.  Le deuxi√®me point √† indexer appartient √† l'une de ces parties.  √Ä travers ce point, dessinons <em>une ligne verticale</em> , qui divise cette partie en deux: droite et gauche.  Nous dessinons √† nouveau une ligne horizontale passant par le point suivant et une ligne verticale passant par le point suivant, et ainsi de suite. <br><br>  Tous les n≈ìuds internes de l'arborescence ainsi construits n'auront que deux n≈ìuds enfants.  Chacune des deux r√©f√©rences peut conduire soit au n≈ìud interne qui est le suivant dans la hi√©rarchie, soit √† la liste des n≈ìuds feuilles. <br><br>  Cette m√©thode peut √™tre facilement g√©n√©ralis√©e pour les espaces k-dimensionnels, et par cons√©quent, les arbres sont √©galement appel√©s k-dimensionnels (arbres kD) dans la litt√©rature. <br><br>  Expliquer la m√©thode par l'exemple des a√©roports: <br><br><img src="https://habrastorage.org/web/a97/130/4d6/a971304d68c8442b86a10c0e52c3e78c.png"><br>  <em>Nous avons d'abord divis√© l'avion en parties sup√©rieure et inf√©rieure ...</em> <br><br><img src="https://habrastorage.org/web/035/660/8fe/0356608fea41422eb7fab9cbb2b67669.png"><br>  <em>Ensuite, nous avons divis√© chaque partie en parties gauche et droite ...</em> <br><br><img src="https://habrastorage.org/web/bb1/26e/8db/bb126e8db6714d7bb5122f9213e5f658.png"><br>  <em>Et ainsi de suite jusqu'√† ce que nous obtenions le partitionnement final.</em> <br><br>  Pour utiliser un partitionnement comme celui-ci, nous devons sp√©cifier explicitement la classe d'op√©rateur <strong>"kd_point_ops"</strong> lors de la cr√©ation d'un index. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> points_kd_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(p kd_point_ops);</code> </pre><br>  Cette classe comprend exactement les m√™mes op√©rateurs que la classe "par d√©faut" "quad_point_ops". <br><br><h3>  Internes </h3><br>  Lors de la recherche dans l'arborescence, nous devons tenir compte du fait que le pr√©fixe dans ce cas n'est qu'une coordonn√©e plut√¥t qu'un point: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> tid, n, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, tid_ptr, prefix, leaf_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_print(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_kd_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t( tid tid, allthesame <span class="hljs-type"><span class="hljs-type">bool</span></span>, n <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, tid_ptr tid, prefix <span class="hljs-type"><span class="hljs-type">float</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- prefix type node_label int, -- label type (unused here) leaf_value point -- list node type ) order by tid, n;</span></span></code> </pre><pre> <code class="plaintext hljs"> tid | n | level | tid_ptr | prefix | leaf_value ---------+---+-------+---------+------------+------------------ (1,1) | 0 | 1 | (5,1) | 53.740 | (1,1) | 1 | 1 | (5,4) | 53.740 | (3,113) | | 6 | | | (-7.277,62.064) (3,114) | | 6 | | | (-85.033,73.006) (5,1) | 0 | 2 | (5,12) | -65.449 | (5,1) | 1 | 2 | (5,2) | -65.449 | (5,2) | 0 | 3 | (5,6) | 35.624 | (5,2) | 1 | 3 | (5,3) | 35.624 | ...</code> </pre><br><h2>  Exemple: arbre radix </h2><br>  Nous pouvons √©galement utiliser SP-GiST pour impl√©menter un arbre radix pour les cha√Ænes.  L'id√©e d'un arbre Radix est qu'une cha√Æne √† indexer n'est pas enti√®rement stock√©e dans un n≈ìud feuille, mais est obtenue en concat√©nant les valeurs stock√©es dans les n≈ìuds au-dessus de celui-ci jusqu'√† la racine. <br><br>  Supposons que nous devons indexer les URL des sites: "postgrespro.ru", "postgrespro.com", "postgresql.org" et "planet.postgresql.org". <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> sites(url <span class="hljs-type"><span class="hljs-type">text</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'postgrespro.ru'</span></span>),(<span class="hljs-string"><span class="hljs-string">'postgrespro.com'</span></span>),(<span class="hljs-string"><span class="hljs-string">'postgresql.org'</span></span>),(<span class="hljs-string"><span class="hljs-string">'planet.postgresql.org'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(url);</code> </pre><br>  L'arbre se pr√©sente comme suit: <br><br><img src="https://habrastorage.org/web/6dd/626/8d2/6dd6268d2c304e98a78609a6bad997e1.png"><br><br>  Les n≈ìuds internes des pr√©fixes de stockage d'arborescence communs √† tous les n≈ìuds enfants.  Par exemple, dans les n≈ìuds enfants de "stgres", les valeurs commencent par "p" + "o" + "stgres". <br><br>  Contrairement √† Quadtrees, chaque pointeur vers un n≈ìud enfant est en outre √©tiquet√© avec un caract√®re (plus exactement, avec deux octets, mais ce n'est pas si important). <br><br>  La classe d'op√©rateur "Text_ops" prend en charge les op√©rateurs de type arbre B: "√©gal", "sup√©rieur" et "inf√©rieur": <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'text_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'spgist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------+-------------- ~&lt;~(text,text) | 1 ~&lt;=~(text,text) | 2 =(text,text) | 3 ~&gt;=~(text,text) | 4 ~&gt;~(text,text) | 5 &lt;(text,text) | 11 &lt;=(text,text) | 12 &gt;=(text,text) | 14 &gt;(text,text) | 15 (9 rows)</code> </pre><br>  La distinction des op√©rateurs avec des tildes est qu'ils manipulent des <em>octets</em> plut√¥t que des <em>caract√®res</em> . <br><br>  Parfois, une repr√©sentation sous la forme d'un arbre radix peut s'av√©rer beaucoup plus compacte que l'arbre B car les valeurs ne sont pas enti√®rement stock√©es, mais reconstruites au fur et √† mesure des besoins en descendant dans l'arbre. <br><br>  Consid√©rez une requ√™te: <code>select * from sites where url like 'postgresp%ru'</code> .  Elle peut √™tre r√©alis√©e √† l'aide de l'index: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> url <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'postgresp%ru'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------ Index Only Scan using sites_url_idx on sites Index Cond: ((url ~&gt;=~ 'postgresp'::text) AND (url ~&lt;~ 'postgresq'::text)) Filter: (url ~~ 'postgresp%ru'::text) (3 rows)</code> </pre><br>  En fait, l'index est utilis√© pour rechercher des valeurs sup√©rieures ou √©gales √† "postgresp", mais inf√©rieures √† "postgresq" (Index Cond), puis les valeurs correspondantes sont choisies dans le r√©sultat (Filter). <br><br>  Premi√®rement, la fonction de coh√©rence doit d√©cider vers quels n≈ìuds enfants de la racine "p" nous devons descendre.  Deux options sont disponibles: "p" + "l" (pas besoin de descendre, ce qui est clair m√™me sans plonger plus profond√©ment) et "p" + "o" + "stgres" (continuer la descente). <br><br>  Pour le n≈ìud "stgres", un appel √† la fonction de coh√©rence est √† nouveau n√©cessaire pour v√©rifier "postgres" + "p" + "ro".  (continuer la descente) et "postgres" + "q" (pas besoin de descendre). <br><br>  Pour "ro".  n≈ìud et tous ses n≈ìuds feuilles enfants, la fonction de coh√©rence r√©pondra "oui", donc la m√©thode d'index retournera deux valeurs: "postgrespro.com" et "postgrespro.ru".  Une valeur correspondante en sera s√©lectionn√©e au stade du filtrage. <br><br><img src="https://habrastorage.org/web/cec/aec/23c/cecaec23c932448098cdd360e60d3c5c.png"><br><br><h3>  Internes </h3><br>  Lors de la recherche dans l'arborescence, nous devons prendre en compte les types de donn√©es: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_print(<span class="hljs-string"><span class="hljs-string">'sites_url_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t( tid tid, allthesame <span class="hljs-type"><span class="hljs-type">bool</span></span>, n <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, tid_ptr tid, prefix <span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- prefix type node_label smallint, -- label type leaf_value text -- leaf node type ) order by tid, n;</span></span></code> </pre><br><h2>  Propri√©t√©s </h2><br>  Examinons les propri√©t√©s de la m√©thode d'acc√®s SP-GiST (des requ√™tes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ont √©t√© fournies pr√©c√©demment</a> ): <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- spgist | can_order | f spgist | can_unique | f spgist | can_multi_col | f spgist | can_exclude | t</code> </pre><br>  Les index SP-GiST ne peuvent pas √™tre utilis√©s pour le tri et pour la prise en charge de la contrainte unique.  De plus, des index comme celui-ci ne peuvent pas √™tre cr√©√©s sur plusieurs colonnes (contrairement √† GiST).  Mais il est autoris√© d'utiliser de tels index pour prendre en charge les contraintes d'exclusion. <br><br>  Les propri√©t√©s de couche d'index suivantes sont disponibles: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | t bitmap_scan | t backward_scan | f</code> </pre><br>  La diff√©rence avec GiST ici est que le clustering est impossible. <br><br>  Et finalement, les propri√©t√©s de couche de colonne sont les suivantes: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | t search_array | f search_nulls | t</code> </pre><br>  Le tri n'est pas pris en charge, ce qui est pr√©visible.  Les op√©rateurs de distance pour la recherche des voisins les plus proches ne sont pas disponibles pour l'instant dans SP-GiST.  Tr√®s probablement, cette fonctionnalit√© sera prise en charge √† l'avenir. <br><blockquote>  Il est pris en charge dans le prochain PostgreSQL 12, le correctif de Nikita Glukhov. <br></blockquote><br>  SP-GiST peut √™tre utilis√© pour l'analyse d'index uniquement, au moins pour les classes d'op√©rateurs d√©crites.  Comme nous l'avons vu, dans certains cas, les valeurs index√©es sont explicitement stock√©es dans les n≈ìuds feuilles, tandis que dans les autres, les valeurs sont reconstruites partie par partie pendant la descente de l'arbre. <br><br><h3>  Nulls </h3><br>  Pour ne pas compliquer l'image, nous n'avons pas mentionn√© de NULL jusqu'√† pr√©sent.  Il ressort clairement des propri√©t√©s d'index que les valeurs NULL sont prises en charge.  Vraiment: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> url <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------- Index Only Scan using sites_url_idx on sites Index Cond: (url IS NULL) (2 rows)</code> </pre><br>  Cependant, NULL est quelque chose d'√©tranger pour SP-GiST.  Tous les op√©rateurs de la classe d'op√©rateur "spgist" doivent √™tre stricts: un op√©rateur doit retourner NULL chaque fois que l'un de ses param√®tres est NULL.  La m√©thode elle-m√™me garantit ceci: les valeurs NULL ne sont tout simplement pas transmises aux op√©rateurs. <br><br>  Mais pour utiliser la m√©thode d'acc√®s pour l'analyse d'index uniquement, les valeurs NULL doivent de toute fa√ßon √™tre stock√©es dans l'index.  Et ils sont stock√©s, mais dans un arbre s√©par√© avec sa propre racine. <br><br><h2>  Autres types de donn√©es </h2><br>  En plus des arbres de points et de radix pour les cha√Ænes, d'autres m√©thodes bas√©es sur SP-GiST sont √©galement impl√©ment√©es PostgreSQL: <br><br><ul><li>  La classe d'op√©rateur Box_ops fournit un quadtree pour les rectangles. <br>  Chaque <em>rectangle</em> est repr√©sent√© par <em>un point dans un espace √† quatre dimensions</em> , donc le nombre de quadrants est √©gal √† 16. Un indice comme celui-ci peut battre GiST en performance quand il y a beaucoup d'intersections des rectangles: dans GiST, il est impossible de tracer des fronti√®res afin de s√©parer les objets qui se croisent les uns des autres, alors qu'il n'y a pas de tels probl√®mes avec les points (m√™me en quatre dimensions). <br></li><li>  La classe d'op√©rateur "Range_ops" fournit un quadtree pour les intervalles. <br>  <em>Un intervalle</em> est repr√©sent√© par <em>un point √† deux dimensions</em> : la limite inf√©rieure devient l'abscisse et la limite sup√©rieure devient l'ordonn√©e. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Continuez √† lire</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr446624/">https://habr.com/ru/post/fr446624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr446612/index.html">Au moment o√π nous avons commenc√© √† croire en l'innovation</a></li>
<li><a href="../fr446614/index.html">Syst√®mes de fichiers virtuels Linux: pourquoi sont-ils n√©cessaires et comment fonctionnent-ils? Partie 1</a></li>
<li><a href="../fr446616/index.html">Comment nous avons fait du cloud FaaS √† l'int√©rieur de Kubernetes et gagn√© au Tinkoff Hackathon</a></li>
<li><a href="../fr446620/index.html">DataGrip 2019.1: prise en charge de nouvelles bases de donn√©es, scripts d'initialisation, nouvelles inspections et plus</a></li>
<li><a href="../fr446622/index.html">Nouvelles √† 11</a></li>
<li><a href="../fr446626/index.html">Kaspersky Mobile Talks # 1. Multi-modularit√©</a></li>
<li><a href="../fr446628/index.html">Donnez plus de HighLoad ++: √† partir de lundi √† Saint-P√©tersbourg</a></li>
<li><a href="../fr446630/index.html">Comment choisir une imprimante 3D ou pourquoi vous avez besoin d'une table chauffante et d'une cam√©ra ferm√©e</a></li>
<li><a href="../fr446632/index.html">De la loi au d√©veloppement du Big Data</a></li>
<li><a href="../fr446634/index.html">SDN Digest - Six √©mulateurs Open Source</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>