<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïµüèæ ‚ôìÔ∏è ü§∞üèª ChaiScript - langage de script pour C ++ üàπ ‚ö∞Ô∏è üë©üèæ‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lorsqu'il est n√©cessaire d'incorporer un langage de script dans un projet C ++, la premi√®re chose dont la plupart des gens se souviennent est Lua. Dan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ChaiScript - langage de script pour C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483540/">  Lorsqu'il est n√©cessaire d'incorporer un langage de script dans un projet C ++, la premi√®re chose dont la plupart des gens se souviennent est Lua.  Dans cet article √ßa ne sera pas, je vais en parler d'un autre, non moins pratique et facile √† apprendre, le langage appel√© ChaiScript. <br><br><img src="https://habrastorage.org/webt/zh/vl/py/zhvlpyg_87wuf7gg0alk-s7qeyo.png" alt="image"><br><a name="habracut"></a><br><h4>  Br√®ve introduction </h4><br>  Je suis moi-m√™me tomb√© sur ChaiScript par hasard en regardant l' <a href="https://youtu.be/uzF4u9KgUWI">une des conf√©rences de</a> Jason Turner, l'un des cr√©ateurs du langage.  Cela m'a int√©ress√©, et √† ce moment o√π il a fallu choisir un langage de script dans le projet, j'ai d√©cid√© - pourquoi ne pas essayer ChaiScript?  Le r√©sultat m'a agr√©ablement surpris (mon exp√©rience personnelle sera √©crite plus pr√®s de la fin de l'article), cependant, aussi √©trange que cela puisse para√Ætre, il n'y avait pas un seul article sur le hub qui mentionnait cette langue au moins d'une mani√®re ou d'une autre, et j'ai d√©cid√© que ce serait bien d'√©crire sur lui.  Bien s√ªr, la langue a une <a href="">documentation</a> et un <a href="http://chaiscript.com/">site officiel</a> , mais tout le monde ne la lira pas √† partir des observations, et le format de l'article est plus proche de beaucoup (y compris moi). <br><br>  Tout d'abord, nous parlerons de la syntaxe du langage et de toutes ses fonctionnalit√©s, puis de la fa√ßon de l'impl√©menter dans votre projet C ++, et √† la fin je parlerai un peu de mon exp√©rience.  Si une partie de vous n'est pas int√©ress√©e, ou si vous souhaitez lire l'article dans un ordre diff√©rent, vous pouvez utiliser la table des mati√®res: <br><br><ul><li>  <a href="https://habr.com/ru/post/483540/">Syntaxe ChaiScript</a> </li><li>  <a href="https://habr.com/ru/post/483540/">Impl√©mentation en C ++</a> </li><li>  <a href="https://habr.com/ru/post/483540/">Exp√©rience personnelle</a> </li></ul><br><a name="syntax"></a><br><h2>  Syntaxe du langage </h2><br>  ChaiScript est tr√®s similaire √† C ++ et JS dans sa syntaxe.  Tout d'abord, comme la grande majorit√© des langages de script, il est typ√© dynamiquement, mais contrairement √† JavaScript, il a un typage strict (non <code>1 + "2"</code> ).  Il y a aussi un garbage collector int√©gr√©, le langage est enti√®rement interpr√©table, vous permettant d'ex√©cuter du code ligne par ligne, sans compilation en bytecode.  Il prend en charge les exceptions (en plus, joint, vous permettant de les intercepter √† la fois dans le script et en C ++), les fonctions lambda, la surcharge de l'op√©rateur.  Il n'est pas sensible aux espaces, vous permettant d'√©crire sur une seule ligne √† travers un point-virgule ou en style python, en s√©parant les expressions par une nouvelle ligne. <br><br><h4>  Types primitifs </h4><br>  ChaiScript par d√©faut stocke les variables enti√®res comme int, r√©elles comme double et les cha√Ænes avec std :: string.  Cela se fait principalement afin d'assurer la compatibilit√© avec le code appelant.  Le langage a m√™me des suffixes pour les nombres, afin que nous puissions indiquer explicitement de quel type est notre variable: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*   chaiscript    js    ,  var / auto `;`      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myInt = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">// int var myLongLong = 1ll // long long int var myFloating = 3.3 // double var myBoolean = false // bool var myString = "hello world!\n" // std::string</span></span></code> </pre><br>  Changer le type de variables ne fonctionne tout simplement pas, vous devrez probablement d√©finir votre propre op√©rateur `=` pour ces types, sinon vous courez le risque de lever une exception (nous en parlerons plus tard) ou de devenir victime d'arrondi, comme ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> integer = <span class="hljs-number"><span class="hljs-number">3</span></span> integer = <span class="hljs-number"><span class="hljs-number">5.433</span></span> print(integer) <span class="hljs-comment"><span class="hljs-comment">//  5    double    int! integer = true //   -   `=`  (int, bool)</span></span></code> </pre><br>  Cependant, vous pouvez d√©clarer une variable sans lui affecter de valeur, auquel cas elle contiendra une sorte d'ind√©fini jusqu'√† ce qu'une valeur lui soit affect√©e. <br><br><h4>  Conteneurs en ligne </h4><br>  La langue a deux conteneurs - Vector et Map.  Ils fonctionnent de mani√®re tr√®s similaire √† leurs homologues en C ++ (std :: vector et std :: map, respectivement), mais ils ne n√©cessitent pas de type, car ils peuvent en stocker n'importe quel.  L'indexation peut √™tre effectu√©e comme d'habitude avec des entiers, mais Map n√©cessite une cl√© avec une cha√Æne.  Apparemment inspir√© par python, les auteurs ont √©galement ajout√© la possibilit√© de d√©clarer rapidement des conteneurs en code en utilisant la syntaxe suivante: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = [ <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>u, <span class="hljs-number"><span class="hljs-number">4</span></span>ll, <span class="hljs-string"><span class="hljs-string">"16"</span></span>, <span class="hljs-string"><span class="hljs-string">`+`</span></span> ] <span class="hljs-comment"><span class="hljs-comment">//      var m = [ "key1" : 1, "key2": "Bob" ]; //    - var M = Map() //    var V = Vector() //    //        C++ : v.push_back(123) //    ,     v.push_back_ref(m); // m -   //      m["key"] = 3 //       (reference assignment): m["key"] := m //      </span></span></code> </pre><br>  Ces deux classes r√©p√®tent presque compl√®tement leurs homologues en C ++, √† l'exception des it√©rateurs, car √† leur place, il existe des classes sp√©ciales Range et Const_Range.  Soit dit en passant, tous les conteneurs sont pass√©s par r√©f√©rence m√™me si vous utilisez l'affectation via =, ce qui est tr√®s √©trange pour moi, car pour tous les autres types, la copie par valeur se produit. <br><br><h4>  Constructions conditionnelles </h4><br>  Presque toutes les constructions de conditions et de cycles peuvent √™tre d√©crites dans un seul exemple de code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-comment"><span class="hljs-comment">//  if-else if (a &gt; b) { print("a &gt; b") } else if (a == b){ print("a == b") } else { print("a &lt; b") } // switch -    if- //      //  break    ,    C++ var str = "hello" switch(str) { case("hi") { print("hi!"); break; } case("hello") { print("hello!" break; } case("bye") { print("bye-bye!") break; } default { print("what have you said?") } } var x = true //     ,       while (x) { print("x was true") x = false; } //    C.        ,    ,    ,    for (var i = 0; i &lt; 10; ++i) //   -,    { print(i); //  0 ... 9  10  } // ranged-for loop for(element : [1, 2, 3, 4, 5]) { puts(element) //   12345 } //  :   C++17 if-init statements: if(var x = get_value(); x &lt; 10) { print(x) // x     if }</span></span></code> </pre><br>  Je pense que les gens familiers avec C ++ n‚Äôont rien trouv√© de nouveau.  Cela n'est pas surprenant, car ChaiScript est positionn√© comme un langage facile √† apprendre pour les "apprenants", et emprunte donc tous les mod√®les classiques bien connus.  Les auteurs ont d√©cid√© de mettre en √©vidence m√™me deux mots cl√©s pour d√©clarer des variables - <code>var</code> et <code>auto</code> , au cas o√π vous aimeriez vraiment les avantages avec auto. <br><br><h4>  Contexte d'ex√©cution </h4><br>  ChaiScript a un contexte local et global.  Le code est ex√©cut√© de haut en bas ligne par ligne, mais il peut √™tre retir√© dans les fonctions et appel√© plus tard (mais pas plus t√¥t!).  Les variables d√©clar√©es √† l'int√©rieur des fonctions ou des conditions / boucles ne sont pas visibles par d√©faut de l'ext√©rieur, mais vous pouvez changer ce comportement en utilisant l'identifiant <code>global</code> au lieu de <code>var</code> .  Les variables globales diff√®rent des variables ordinaires en ce que, d'une part, elles sont visibles en dehors du contexte local, et d'autre part, elles peuvent √™tre re-d√©clar√©es (si la valeur n'est pas d√©finie lors de la re-d√©claration, alors elle reste la m√™me) <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     chaiscript def foo(x) { global G = 2 print(x) } foo(0) //  foo(x), G = 2 print(G) //  2 global G = 3 //  G = 3,   global -  !</span></span></code> </pre><br>  Soit dit en passant, si vous avez une variable et que vous devez v√©rifier si une valeur lui est affect√©e, utilisez la <code>is_var_undef</code> int√©gr√©e <code>is_var_undef</code> , qui renvoie true si la variable n'est pas d√©finie. <br><br><h4>  Interpolation de cha√Ænes </h4><br>  Les objets de base ou les objets utilisateur qui ont une m√©thode <code>to_string()</code> peuvent √™tre plac√©s dans une cha√Æne en utilisant la syntaxe <code>${object}</code> .  Cela √©vite les concat√©nations de cha√Ænes inutiles et semble g√©n√©ralement beaucoup plus ordonn√©: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-comment"><span class="hljs-comment">//  sum of 3 + 4 = 7 print("sum of ${x} + ${y} = ${x + y}")</span></span></code> </pre><br>  Vector, Map, MapPair et toutes les primitives prennent √©galement en charge cette fonctionnalit√©.  Le vecteur est affich√© au format <code>[o1, o2, ...]</code> , Map as <code>[&lt;key1, val1&gt;, &lt;key2, val2&gt;, ...]</code> et MapPair: <code>&lt;key, val&gt;</code> . <br><br><h4>  Fonctions et leurs nuances </h4><br>  Les fonctions ChaiScript sont des objets comme tout le reste.  Ils peuvent √™tre captur√©s, affect√©s √† des variables, rendus imbriqu√©s dans d'autres fonctions et pass√©s en argument.  Pour eux, vous pouvez √©galement sp√©cifier le type de valeurs d'entr√©e (ce qui manquait aux langues typ√©es dynamiquement!). Pour cela, vous devez sp√©cifier le type avant de d√©clarer le param√®tre de fonction.  Si, une fois appel√©, le param√®tre peut √™tre converti en celui sp√©cifi√©, la conversion se produira selon les r√®gles C ++, sinon une exception sera lev√©e: <br><br><pre> <code class="javascript hljs">def adder(int x, int y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y } def adder(bool x, bool y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x || y } adder(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ,  3 adder(1.22, -3.7) // ,  1 + (-3) = 2 adder(true, true) // ,  true adder(true, 3) // ,    adder(bool, int)</span></span></code> </pre><br>  Des fonctions dans la langue peuvent √©galement √™tre d√©finies comme conditions d'appel (garde d'appel).  S'il n'est pas respect√©, une exception est lev√©e, sinon un appel est effectu√©.  Je note √©galement que si la fonction n'a pas de d√©claration de retour √† la fin, la derni√®re expression sera retourn√©e.  Tr√®s pratique pour les petites routines: <br><br><pre> <code class="javascript hljs">def div(x, y) : y != <span class="hljs-number"><span class="hljs-number">0</span></span> { x / y } <span class="hljs-comment"><span class="hljs-comment">//  `y`    -    `x`  `y` print(div(2, 0.5)) //  4.0 print(div(2, 0)) // , `y`  0!</span></span></code> </pre><br><h4>  Classes et Dynamic_Object </h4><br>  ChaiScript a les rudiments de la POO, ce qui est un avantage certain si vous devez manipuler des objets complexes.  Le langage a un type sp√©cial - Dynamic_Object.  En fait, toutes les instances de classes et d'espaces de noms sont exactement Dynamic_Object avec des propri√©t√©s pr√©d√©finies.  Un objet dynamique vous permet d'y ajouter des champs lors de l'ex√©cution du script, puis d'y acc√©der: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = Dynamic_Object(); obj.x = <span class="hljs-number"><span class="hljs-number">3</span></span>; obj.f = fun(arg) { print(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x + arg); } <span class="hljs-comment"><span class="hljs-comment">//  obj   f (     `x` obj.f(-3); //  0</span></span></code> </pre><br>  Les classes sont d√©finies tout simplement.  Ils peuvent √™tre d√©finis sur des champs, des m√©thodes, des constructeurs.  Du <code>set_explicit(object, value)</code> int√©ressant <code>set_explicit(object, value)</code> gr√¢ce √† la fonction sp√©ciale <code>set_explicit(object, value)</code> vous pouvez ¬´corriger¬ª les champs de l'objet en interdisant l'ajout de nouvelles m√©thodes ou attributs apr√®s la d√©claration de la classe (cela se fait g√©n√©ralement dans le constructeur): <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id; <span class="hljs-comment"><span class="hljs-comment">//  id def Widget() { this.id= 0 } //    def Widget(id) { this.id = id } //   1  def get_id() { id } //   } var w = Widget(10) print(w.get_id()) //  10 (w.id) print(w.get_id) //   10,        set_explicit(w, true) //    wx = 3 //      Widget   x</span></span></code> </pre><br>  Un point important - en fait, les m√©thodes de classe ne sont que des fonctions dont le premier argument est un objet d'une classe avec un type explicitement sp√©cifi√©.  Par cons√©quent, le code suivant √©quivaut √† ajouter une m√©thode √† une classe existante: <br><br><pre> <code class="javascript hljs">def set_id(Widget w, id) { w.id = id } w.set_id(<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-comment"><span class="hljs-comment">// w.id = 9 set_id(w, 9) //  , w.id = 9</span></span></code> </pre><br>  Toute personne familiaris√©e avec C # peut remplacer ce qui ressemble douloureusement √† une m√©thode d'extension et sera proche de la v√©rit√©.  Ainsi, dans le langage, vous pouvez ajouter de nouvelles fonctionnalit√©s m√™me pour les classes int√©gr√©es, par exemple, pour une cha√Æne ou un entier.  Les auteurs proposent √©galement un moyen d√©licat de surcharger les op√©rateurs: pour ce faire, vous devez entourer le symbole de l'op√©rateur d'un tilde (`) comme dans l'exemple ci-dessous: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   +     Widget def `+`(Widget w1, Widget w2) { print("merging two widgets!") } var widget1 = Widget() var widget2 = Widget() widget1 + widget2 //      //        : var plus = `+` print(plus(1, 7)) //  8</span></span></code> </pre><br><h4>  Espaces de noms </h4><br>  En parlant de l'espace de noms dans ChaiScript, il faut garder √† l'esprit que ce sont essentiellement des classes qui sont toujours dans un contexte global.  Vous pouvez les cr√©er √† l'aide de la fonction <code>namespace(name)</code> , puis ajouter les fonctions et classes n√©cessaires.  Par d√©faut, il n'y a pas de biblioth√®ques dans la langue, mais vous pouvez les installer √† l'aide d'extensions, dont nous parlerons un peu plus tard.  En g√©n√©ral, l'initialisation de l'espace de noms peut ressembler √† ceci: <br><br><pre> <code class="javascript hljs">namespace(<span class="hljs-string"><span class="hljs-string">"math"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//    math //   math.square = fun(x) { x * x } math.hypot_squared= fun(x, y) { math.square(x) + math.square(y) } print(math.square(4)) //  16 print(math.hypot_squared(3, 4)) //  25</span></span></code> </pre><br><h4>  Expressions lambda et autres fonctionnalit√©s </h4><br>  Les expressions lambda dans ChaiScript sont similaires √† ce que nous savons du C ++.  Le mot-cl√© <b>fun</b> est utilis√© pour eux, et ils n√©cessitent √©galement de sp√©cifier explicitement les variables captur√©es, mais ils le font toujours par r√©f√©rence.  Le langage poss√®de √©galement une fonction de liaison qui vous permet de lier des valeurs aux param√®tres de fonction: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func_object = fun(x) { x * x } func_object(<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  81 var name = "John" var greet = fun[name]() { "Hello, " + name } print(greet()) //  Hello, John name = "Bob" print(greet()) //  Hello, Bob var message = bind(fun(msg, name) { msg + " from " + name }, _, "ChaiScript"); print(message("Hello")) //  Hello from ChaiScript</span></span></code> </pre><br><h4>  Exceptions </h4><br>  Des exceptions peuvent se produire lors de l'ex√©cution du script.  Ils peuvent √™tre intercept√©s √† la fois dans ChaiScript lui-m√™me (dont nous parlerons ici) et en C ++.  La syntaxe est absolument identique aux plus, vous pouvez m√™me jeter un nombre ou une cha√Æne: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(x + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// x   } catch (e) { print("Error during evaluation")) } //   C++   ChaiScript //   Vector -   std::vector,    std::exception      try { var vec = [1, 2] var val = vec[3] //     } catch (e) { print("index out of range: " + e.what()); // e.what    ChaiScript } //  atch   guard     ,    `:` try { throw(5.2) } catch(e) : is_type(e, "int") { print("Int: ${e}"); //   `e`  int } catch(e) : is_type(e, "double") { print("Double: ${e}"); //  `e`  double }</span></span></code> </pre><br>  Dans le bon sens, vous devez d√©finir votre classe d'exceptions et la lever.  Nous parlerons de la fa√ßon de l'intercepter en C ++ dans la deuxi√®me section.  Pour les exceptions d'interpr√©teur, ChaiScript l√®ve ses exceptions, telles que eval_error, bad_boxed_cast, etc. <br><br><h4>  Constantes d'interpr√©teur </h4><br>  √Ä ma grande surprise, le langage s'est av√©r√© √™tre une sorte de macros de compilation - il n'y en a que 4 et elles servent toutes √† identifier le contexte et sont principalement utilis√©es pour la gestion des erreurs: <br><div class="scrollable-table"><table><tbody><tr><td>  __LINE__ </td><td>  ligne actuelle, si le code n'est pas ex√©cut√© √† partir d'un fichier, alors '1' </td></tr><tr><td>  __FILE__ </td><td>  fichier actuel, si le code n'est pas appel√© √† partir d'un fichier, alors "__EVAL__" </td></tr><tr><td>  __CLASS__ </td><td>  classe actuelle ou "NOT_IN_CLASS" </td></tr><tr><td>  __FUNC__ </td><td>  fonction actuelle ou "NOT_IN_FUNCTION" </td></tr></tbody></table></div><br><h4>  Erreur de r√©cup√©ration </h4><br>  Si la fonction que vous appelez n'a pas √©t√© d√©clar√©e, une exception est lev√©e.  Si cela ne vous convient pas, vous pouvez d√©finir une fonction sp√©ciale - <code>method_missing(object, func_name, params)</code> , qui sera appel√©e avec les arguments correspondants en cas d'erreur: <br><br><pre> <code class="javascript hljs">def method_missing(Widget w, string name, Vector v) { print(<span class="hljs-string"><span class="hljs-string">"widget method ${name} with params {v} was not found"</span></span>) } w = Widget() w.invoke_error(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  widget method invoke_error with params [1, 2, 3] was not found</span></span></code> </pre><br><h4>  Fonctions int√©gr√©es </h4><br>  ChaiScript d√©finit de nombreuses fonctions int√©gr√©es, et dans l'article, j'aimerais parler de fonctions particuli√®rement utiles.  Parmi eux: <code>eval(str)</code> , <code>eval_file(filename)</code> , <code>to_json(object)</code> , <code>from_json(str)</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">"x * y"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// res = 15,  eval     //     : //  eval_file eval_file("source.chai") //   use,  ,         use("source.chai") // to_json    Map    var w = Widget(0) var j = to_json(w) // j = "{ "id" : 0 }" // from_json    Map ( ,   ) var m = from_json(" { "x": 0, "y": 3, "z": 2 }") print(m) //  Map  [&lt;x, 0&gt;, &lt;y, 3&gt;, &lt;z, 2&gt;]</span></span></code> </pre><br><a name="cppchai"></a><br><h2>  Impl√©mentation en C ++ </h2><br><h4>  L'installation </h4><br>  ChaiScript est une biblioth√®que en-t√™te uniquement bas√©e sur un mod√®le C ++.  Par cons√©quent, pour l'installation, il vous suffit de cr√©er un <a href="https://github.com/ChaiScript/ChaiScript">r√©f√©rentiel de</a> clone ou de simplement mettre tous les fichiers de <a href="https://github.com/ChaiScript/ChaiScript/tree/develop/include/chaiscript">ce dossier</a> dans votre projet.  √âtant donn√© que, selon l'IDE, tout cela se fait diff√©remment et a √©t√© d√©crit en d√©tail sur les forums depuis longtemps, nous supposerons que vous avez r√©ussi √† connecter la biblioth√®que, et le code avec include: <code>#include &lt;chaiscript/chaiscript.hpp&gt;</code> compil√©. <br><br><h4>  Invocation de code C ++ et chargement de script </h4><br>  Le plus petit exemple de code utilisant ChaiScript est le suivant.  Nous d√©finissons une fonction simple en C ++ qui prend std :: string et renvoie la cha√Æne modifi√©e, puis nous y ajoutons un lien dans l'objet ChaiScript pour l'appeler.  La compilation peut prendre un temps consid√©rable, mais cela est principalement d√ª au fait qu'il n'est pas facile d'instancier un grand nombre de mod√®les pour le compilateur: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;chaiscript/chaiscript.hpp&gt; std::string greet_name(const std::string&amp; name) { return "hello, " + name; } int main() { chaiscript::ChaiScript chai; //  chaiscript chai.add(chaiscript::fun(&amp;greet_name), "greet"); //    greet //  eval      chai.eval(R"( print(greet("John")); )"); }</span></span></span></span></code> </pre> <br>  J'esp√®re que vous avez r√©ussi et que vous avez vu le r√©sultat de la fonction.  Je veux noter une nuance tout de suite - si vous d√©clarez un objet ChaiScript statique, vous obtenez une erreur d'ex√©cution d√©sagr√©able.  Cela est d√ª au fait que le langage prend en charge le multithreading par d√©faut et stocke les variables de flux locales accessibles dans son destructeur.  Cependant, ils sont d√©truits avant l'appel du destructeur de l'instance statique et, par cons√©quent, nous avons une violation d'acc√®s ou une erreur de segmentation.  En fonction du <a href="https://github.com/ChaiScript/ChaiScript/issues/338">probl√®me sur github</a> , la solution la plus simple serait de simplement mettre <b><code>#define CHAISCRIPT_NO_THREADS</code></b> dans les param√®tres du compilateur ou avant d'inclure le fichier de biblioth√®que, d√©sactivant ainsi le multithreading.  Si je comprends bien, il n'a pas √©t√© possible de corriger cette erreur. <br><br>  Nous allons maintenant analyser en d√©tail comment se d√©roule l'interaction entre C ++ et ChaiScript.  La biblioth√®que d√©finit une fonction de mod√®le sp√©ciale <code>fun</code> , qui peut prendre un pointeur vers une fonction, un foncteur ou un pointeur vers une variable de classe, puis renvoyer un objet sp√©cial qui stocke l'√©tat.  Par exemple, d√©finissons la classe Widget dans le code C ++ et essayons de l'associer √† ChaiScript de diff√©rentes mani√®res: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) : Id(id) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Id; } }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Widget&amp; w)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"widget #"</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(w.GetId()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget  C++  chai.add(chaiscript::fun([&amp;w] { return w; }), "get_widget"); //         chai.add(chaiscript::fun(ToString), "to_string"); //   chai.add(chaiscript::fun(&amp;Widget::GetId), "get_id"); //   //    ,   Widget    GetId,    to_string,    chai.eval(R"( var w = get_widget() print(w.get_id) //  2 print(w) //  widget #2 )"); }</span></span></code> </pre><br>  Comme vous pouvez le voir, ChaiScript fonctionne de mani√®re absolument calme avec des classes C ++ inconnues et peut appeler leurs m√©thodes.  Si vous faites une erreur quelque part dans le code, le script l√®vera tr√®s probablement une exception √† l' <code>error in function dispatch</code> type <code>error in function dispatch</code> , qui n'est pas critique du tout.  Cependant, non seulement les fonctions peuvent √™tre import√©es, voyons comment ajouter une variable √† un script √† l'aide de la biblioth√®que.  Pour ce faire, s√©lectionnez un peu plus la t√¢che - import std :: vector &lt;Widget&gt;.  La fonction <code>chaiscript::var</code> et la m√©thode <code>add_global</code> nous y aideront.  Nous ajouterons √©galement le champ public <code>Data</code> √† notre widget pour voir comment importer le champ de classe: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Data = <span class="hljs-number"><span class="hljs-number">0</span></span>; Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : Id(id) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Id; } }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Widget&amp; w)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"widget #"</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(w.GetId()) + <span class="hljs-string"><span class="hljs-string">" with data: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(w.Data); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Widget&gt; W; <span class="hljs-comment"><span class="hljs-comment">//    Widget W.emplace_back(1); W.emplace_back(2); W.emplace_back(3); chai.add(chaiscript::fund(ToString), "to_string"); chai.add(chaiscript::fun(&amp;Widget::Data), "data"); //     //     ChaiScript chai.add_global(chaiscript::var(std::ref(W)), "widgets"); //     std::ref chai.add(chaiscript::fun(&amp;std::vector&lt;Widget&gt;::size), "size"); //   // .        using IndexFuncType = Widget&amp; (std::vector&lt;Widget&gt;::*)(const size_t); chai.add(chaiscript::fun(IndexFuncType(&amp;std::vector&lt;Widget&gt;::operator[])), "[]"); chai.eval(R"( for(var i = 0; i &lt; vec.size; ++i) { vec[i].data = i * 2; print(vec[i]) } )"); }</span></span></code> </pre><br>  Le code ci-dessus affiche: <b><code>widget #1 with data: 0</code> , <code>widget #2 with data: 2</code> , <code>widget #3 with data: 4</code></b> .  Nous avons ajout√© un pointeur sur le champ de classe dans ChaiScript, et puisque le champ s'est av√©r√© √™tre un type primitif, nous changeons sa valeur.  De plus, plusieurs m√©thodes ont √©t√© ajout√©es pour fonctionner avec <code>std::vector</code> , y compris l' <code>operator[]</code> .  Ceux qui connaissent STL savent que <code>std::vector</code> deux m√©thodes d'indexation - l'une renvoie un lien constant, l'autre un simple lien.  C'est pourquoi pour les fonctions surcharg√©es, vous devez indiquer explicitement leur type - sinon une ambigu√Øt√© survient et le compilateur l√®vera une erreur. <br><br>  La biblioth√®que fournit plusieurs autres m√©thodes pour ajouter des objets, mais ils sont tous presque identiques, donc je ne vois pas l'int√©r√™t de les examiner en d√©tail.  √Ä titre indicatif, voici le code ci-dessous: <br><br><pre> <code class="cpp hljs">chai.add(chaiscript::var(x), <span class="hljs-string"><span class="hljs-string">"x"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// x   ChaiScript chai.add(chaiscript::var(std::ref(x), "x"); //  ,    C++  ChaiScript auto shared_x = std::make_shared&lt;int&gt;(5); chai.add(chaiscript::var(shared_x), "x"); // shared_ptr      C++  ChaiScript chai.add(chaiscript::const_var(x), "x"); //   ChaiScript    chai.add_global_const(chaiscript::const_var(x), "x"); // global const . ,  x   chai.add_global(chaiscript::var(x), "x"); // global , .  x   chai.set_global(chaiscript::var(x), "x"); //   global ,    const</span></span></code> </pre><br><h4>  Utilisation de conteneurs STL </h4><br>  Si vous souhaitez transmettre des conteneurs STL contenant <b>des</b> types <b>primitifs</b> √† ChaiScript, vous pouvez ajouter une instanciation de conteneur de mod√®le √† votre script afin de ne pas importer de m√©thodes pour chaque type. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyVector = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;&gt;; MyVector V; V.emplace_back(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"John"</span></span>); V.emplace_back(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    - vector  pair chai.add(chaiscript::bootstrap::standard_library::vector_type&lt;MyVector&gt;("MyVec")); chai.add(chaiscript::bootstrap::standard_library::pair_type&lt;MyVector::value_type&gt;("MyVecData")); chai.add(chaiscript::var(std::ref(V)), "vec"); chai.eval(R"( for(var i = 0; i &lt; vec.size; ++i) { print(to_string(vec[i].first) + " " + vec[i].second) } )");</span></span></code> </pre> <br>       ChaiScript,     .  ,        STL-,       .   c <code>std::vector&lt;Widget&gt;</code> ,  , ,   ChaiScript        <code>vector_type</code> ,    Widget  . <br><br><h4> ++   ChaiScript </h4><br>            ChaiScript,      .  ,   .      Widget      WindowWidget,         ,       : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) : Id(id) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Id; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WindowWidget</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Widget { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; Size; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: WindowWidget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height) : Widget(id), Size(width, height) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWidth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size.first; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size.second; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-comment"><span class="hljs-comment">//   Widget    chai.add(chaiscript::user_type&lt;Widget&gt;(), "Widget"); chai.add(chaiscript::constructor&lt;Widget(int)&gt;(), "Widget"); //   WindowWidget    chai.add(chaiscript::user_type&lt;WindowWidget&gt;(), "WindowWidget"); chai.add(chaiscript::constructor&lt;WindowWidget(int, int, int)&gt;(), "WindowWidget"); // ,  Widget -    WindowWidget chai.add(chaiscript::base_class&lt;Widget, WindowWidget&gt;()); //   Widget  WindowWidget chai.add(chaiscript::fun(&amp;Widget::GetId), "get_id"); chai.add(chaiscript::fun(&amp;WindowWidget::GetWidth), "width"); chai.add(chaiscript::fun(&amp;WindowWidget::GetHeight), "height"); //  WindowWidget     chai.eval(R"( var window = WindowWidget(1, 800, 600) print("${window.width} * ${window.height}") print("widget.id is ${window.get_id}") )"); }</span></span></code> </pre><br>    ChaiScript  ,    C++  ,     .   -          (,      ),      ,          <code>std::vector&lt;Widget&gt;</code> . <br><br><h4>        </h4><br>              .     ChaiScript    ,   ,        : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; w.Data = <span class="hljs-number"><span class="hljs-number">4444</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget w chai.add(chaiscript::fun(&amp;Widget::GetId, &amp;w), "widget_id"); chai.add(chaiscript::fun(&amp;Widget::Data, &amp;w), "widget_data"); chai.eval(R"( print(widget_id) print(widget_data) )");</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, lors de l'exportation de plusieurs classes de ¬´biblioth√®que¬ª de C ++ vers ChaiScript (par exemple, vec3, complexe, matrice), la possibilit√© de conversion implicite d'un type √† un autre est souvent requise. Dans ChaiScript, ce probl√®me est r√©solu en ajoutant </font></font><code>type_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un script √† l'objet. Par exemple, consid√©rez la classe Complex et l'impl√©mentation de la conversion int et double en elle pendant l'ajout:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Complex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Re, Im; Complex(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> re, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> im = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) : Re(re), Im(im) { } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-comment"><span class="hljs-comment">//  Complex,   re, im,    `=` chai.add(chaiscript::user_type&lt;Complex&gt;(), "Complex"); chai.add(chaiscript::bootstrap::standard_library::assignable_type&lt;Complex&gt;("Complex")); chai.add(chaiscript::constructor&lt;Complex(float, float)&gt;(), "Complex"); chai.add(chaiscript::fun(&amp;Complex::Re), "re"); chai.add(chaiscript::fun(&amp;Complex::Im), "im"); //     double  int  Complex chai.add(chaiscript::type_conversion&lt;int, Complex&gt;()); chai.add(chaiscript::type_conversion&lt;double, Complex&gt;()); //     `+`    chai.eval(R"( def `+`(Complex c, x) { var res = Complex(0, 0) res.re = c.re + x.re res.im = c.im + x.im return res } var c = Complex(1, 2) c = c + 3 print("${c.re} + ${c.im}i") )"); // : `4 + 2i` }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, il n'est pas n√©cessaire d'√©crire une fonction de conversion en C ++ lui-m√™me, puis de l'exporter vers ChaiScript. </font><font style="vertical-align: inherit;">Vous pouvez ajouter des transformations et d√©j√† d√©crire la nouvelle fonctionnalit√© dans le code de script lui-m√™me. </font><font style="vertical-align: inherit;">Si la conversion pour les deux types n'est pas triviale, vous pouvez passer le lambda comme argument √† une fonction </font></font><code>type_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il sera appel√© lors du casting. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un principe similaire est utilis√© pour convertir Vector ou Map ChaiScript en votre type personnalis√©. </font><font style="vertical-align: inherit;">Pour cela, </font></font><code>vector_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et sont </font><font style="vertical-align: inherit;">d√©finis dans la biblioth√®que </font></font><code>map_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©compression des valeurs de retour ChaiScript </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©thodes </font></font><code>eval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>eval_file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retourne la valeur de la derni√®re expression ex√©cut√©e en tant qu'objet </font></font><code>Boxed_Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour le d√©compresser et utiliser le r√©sultat dans le code C ++, vous pouvez soit sp√©cifier explicitement le type de la valeur de retour, soit utiliser une fonction </font></font><code>boxed_cast&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si la conversion entre types existe, elle sera ex√©cut√©e, sinon une exception sera lev√©e </font></font><code>bad_boxed_cast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       double d = chai.eval&lt;double&gt;("5.3 + 2.1"); //     Boxed_Value,     auto v = chai.eval("5.3 + 2.1"); double d = chai.boxed_cast&lt;double&gt;(v);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que tous les objets √† l'int√©rieur de ChaiScript sont stock√©s √† l'aide de shared_ptr, vous pouvez obtenir l'objet en tant que pointeur pour un travail ult√©rieur avec lui. </font><font style="vertical-align: inherit;">Pour ce faire, sp√©cifiez explicitement le type shared_ptr lors de la conversion de la valeur de retour:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = chai.eval&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;&gt;(<span class="hljs-string"><span class="hljs-string">"var x = 3.2"</span></span>);</code> </pre><br> ,        shared_ptr,     access violation  ,           . <br><br>     ,     ChaiScript     ,    ChaiScript.  ,      Complex           : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> printComplex = chai.eval&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(Complex)&gt;&gt;(<span class="hljs-string"><span class="hljs-string">R"( fun(Complex c) { print("${c.re} + ${c.im}i"); } )"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ,   ,      C++ printComplex(Complex(2, 3)); //  chaiscript,  `2 + 3i`</span></span></code> </pre><br><h4>    ChaiScript </h4><br>        ,    .  <code>eval_error</code>    , <code>bad_boxed_cast</code> ,        <code>std::exception</code>   .        ,        ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Data; MyException(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data) : <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(<span class="hljs-string"><span class="hljs-string">"MyException"</span></span>), Data(data) { } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-comment"><span class="hljs-comment">//      chaiscript chai.add(chaiscript::user_type&lt;MyException&gt;(), "MyException"); chai.add(chaiscript::constructor&lt;MyException(int)&gt;(), "MyException"); try { //          chai.eval("throw(MyException(11111))", chaiscript::exception_specification&lt;MyException, std::exception&gt;()); } catch (MyException&amp; e) { std::cerr &lt;&lt; e.Data; //   `11111` } catch (chaiscript::exception::eval_error&amp; e) { std::cerr &lt;&lt; e.pretty_print(); } catch(std::exception&amp; e) { std::cerr &lt;&lt; e.what(); } }</span></span></code> </pre><br>    ,       C++.   <code>pretty_print</code> ,  <code>eval_error</code>     ,    ,  ,  ,              . <br><br><h4>  ChaiScript </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malheureusement, par d√©faut, ChaiScript ne fournit pas de fonctionnalit√©s suppl√©mentaires en termes de biblioth√®ques. </font><font style="vertical-align: inherit;">Par exemple, il manque des fonctions math√©matiques, des tables de hachage et la plupart des algorithmes. </font><font style="vertical-align: inherit;">Vous pouvez t√©l√©charger certains d'entre eux sous forme de biblioth√®ques de modules √† partir du r√©f√©rentiel officiel </font></font><a href="https://github.com/ChaiScript/ChaiScript_Extras"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChaiScript Extras</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , puis les importer dans votre script. </font><font style="vertical-align: inherit;">Par exemple, prenez la biblioth√®que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">math√©matique</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et la fonction acos (x):</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chaiscript/chaiscript.hpp&gt; #include &lt;chaiscript/extras/math.hpp&gt; int main() { chaiscript::ChaiScript chai; //   auto mathlib = chaiscript::extras::math::bootstrap(); chai.add(mathlib); std::cout &lt;&lt; chai.eval&lt;double&gt;("acos(0.5)"); // ~1.047 }</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez √©galement √©crire votre biblioth√®que pour la langue, puis l'importer. </font><font style="vertical-align: inherit;">Cela se fait tout simplement, je vous conseille donc de vous familiariser avec les math√©matiques open source ou toute autre source dans le r√©f√©rentiel. </font><font style="vertical-align: inherit;">En principe, dans le cadre de l'int√©gration avec C ++, nous avons examin√© presque tout, donc je pense que la section peut √™tre compl√©t√©e √† ce sujet.</font></font><br><a name="myexp"></a><br><h2>  Exp√©rience personnelle </h2><br>      3D-  OpenGL    ,          ,         .      <a href="https://github.com/MomoDeve/MSL"></a> , ,  , ¬´    ¬ª,      . <br><br>      ,  ChaiScript      ,         Lua.      ,        ,       :  ,         C++  C,      -  C-style . ,        ,     . <br><br>        ,         .            ImGui,     chaiscript.               ,   : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      3D-: // rotation CHAI_IMPORT(&amp;GLInstance::RotateX, rotate_x); CHAI_IMPORT(&amp;GLInstance::RotateY, rotate_y); CHAI_IMPORT(&amp;GLInstance::RotateZ, rotate_z); // scale CHAI_IMPORT((GLInstance&amp;(GLInstance::*)(float))&amp;GLInstance::Scale, scale); CHAI_IMPORT((GLInstance&amp;(GLInstance::*)(float, float, float))&amp;GLInstance::Scale, scale); // translation CHAI_IMPORT(&amp;GLInstance::Translate, translate); CHAI_IMPORT(&amp;GLInstance::TranslateX, translate_x); CHAI_IMPORT(&amp;GLInstance::TranslateY, translate_y); CHAI_IMPORT(&amp;GLInstance::TranslateZ, translate_z); // hide / show CHAI_IMPORT(&amp;GLInstance::Hide, hide); CHAI_IMPORT(&amp;GLInstance::Show, show); // getters CHAI_IMPORT(&amp;GLInstance::GetTranslation, translation); CHAI_IMPORT(&amp;GLInstance::GetRotation, rotation); CHAI_IMPORT(&amp;GLInstance::GetScale, scale);</span></span></code> </pre><br>       ,      -,     .        : <br><br><img src="https://habrastorage.org/webt/rl/bo/td/rlbotdpcfl4pdpbplwxfrvsk73i.png" alt="image"><br> <i>  chaiscript  ImGui:      </i> <br><br>     ,            . , Lua      ,       ,          (JIT     ),     ChaiScript    .      ,    ,      . <br><br>         .           C++ (  Lua   ),         ChaiScript    .         .    . <br><br><h4>   </h4><br><ul><li>   ChaiScript: <a href="http://chaiscript.com/">chaiscript.com</a> </li><li>      : <a href="">ChaiScript cheatsheet</a> </li><li>  : <a href="https://codedocs.xyz/ChaiScript/ChaiScript/">codedocs.xyz/ChaiScript/ChaiScript</a> </li><li>     ChaiScript: <a href="https://github.com/MomoDeve/MomoEngine">github.com/MomoDeve/MomoEngine</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr483540/">https://habr.com/ru/post/fr483540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr483528/index.html">L'API REST doit √™tre bas√©e sur l'hypertexte</a></li>
<li><a href="../fr483530/index.html">Comment nous avons fait un jeu de soci√©t√©. Pourquoi et pourquoi?</a></li>
<li><a href="../fr483532/index.html">Conf√©rence DefCon 27: Dans les coulisses de la cr√©ation de badges √©lectroniques Partie 1</a></li>
<li><a href="../fr483536/index.html">L'histoire du microprocesseur et de l'ordinateur personnel: 1974 - 1980</a></li>
<li><a href="../fr483538/index.html">Connexion d'un √©cran 10 "ER-TFT101-1 au STM32F429 via FMC</a></li>
<li><a href="../fr483542/index.html">Telecom digest - documents sur le travail des fournisseurs</a></li>
<li><a href="../fr483544/index.html">De nouvelles donn√©es r√©futent l'hypoth√®se cl√© de l'√©nergie sombre</a></li>
<li><a href="../fr483550/index.html">D√©veloppement de services et IaaS: une compilation du cloud, du stockage de donn√©es et de 1cloud Evolution</a></li>
<li><a href="../fr483552/index.html">MVVM et s√©lection d'√©l√©ments dans l'adaptateur</a></li>
<li><a href="../fr483554/index.html">Nouvelle plateforme technologique des ann√©es 20. Pourquoi je ne suis pas d'accord avec Zuckerberg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>