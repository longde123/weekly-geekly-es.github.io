<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßë‚Äçü§ù‚Äçüßë üë®üèº‚Äçü§ù‚Äçüë®üèª üë®üèº Berkat WebAssembly, Anda dapat menulis Frontend on Go üíÉüèΩ üëäüèø üè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel asli 

 Pada bulan Februari 2017, seorang anggota tim Brad Fitzpatrick go mengusulkan pembuatan dukungan WebAssembly dalam bahasa tersebut. Em...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Berkat WebAssembly, Anda dapat menulis Frontend on Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417563/">  Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">asli</a> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ww/az/mf/wwazmfemkd6qhegdxrzeabctnxk.jpeg"></div><br>  Pada bulan Februari 2017, seorang anggota tim Brad Fitzpatrick go <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengusulkan</a> pembuatan dukungan WebAssembly dalam bahasa tersebut.  Empat bulan kemudian, pada November 2017, penulis GopherJS Richard Muziol mulai menerapkan gagasan itu.  Dan akhirnya, implementasi penuh ditemukan di master.  Pengembang akan menerima wasme sekitar Agustus 2018, dengan versi <a href="">go 1.11</a> .  Akibatnya, pustaka standar mengatasi hampir semua kesulitan teknis dengan mengimpor dan mengekspor fungsi yang Anda kenal jika Anda sudah mencoba mengkompilasi C dalam wasm.  Kedengarannya menjanjikan.  Mari kita lihat apa yang bisa dilakukan dengan versi pertama. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de1/415/41d/de141541d13f83b05f9e3412d1961868.png"></div><br><br>  Semua contoh dalam artikel ini dapat diluncurkan dari wadah buruh pelabuhan yang ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di repositori penulis</a> : <br><br><pre><code class="bash hljs">Ôªødocker container run -dP nlepage/golang_wasm:examples <span class="hljs-comment"><span class="hljs-comment"># Find out which host port is used docker container ls</span></span></code> </pre> <br>  Lalu pergi ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">localhost</a> : 32XXX /, dan pergi dari satu tautan ke tautan lainnya. <br><br><h3>  Hai Wasm! </h3><br>  Penciptaan dasar "hello world" dan konsepnya sudah cukup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terdokumentasi dengan baik</a> (bahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam bahasa Rusia</a> ), jadi mari kita beralih ke hal-hal yang lebih halus. <br><br>  Yang paling penting adalah versi Go yang baru dikompilasi yang mendukung wasm.  Saya tidak akan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menjelaskan langkah demi langkah instalasi</a> , hanya tahu bahwa apa yang dibutuhkan sudah di master. <br><br>  Jika Anda tidak ingin khawatir tentang hal ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dockerfile c go</a> tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori golub-wasm di github</a> , atau Anda dapat mengambil gambar dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nlepage / golang_wasm</a> lebih cepat. <br><br>  Sekarang Anda dapat menulis <code>helloworld.go</code> tradisional dan kompilasi dengan perintah berikut: <br><br><pre> <code class="bash hljs">ÔªøGOOS=js GOARCH=wasm go build -o test.wasm helioworld.go</code> </pre><br>  Variabel lingkungan GOOS dan GOARCH telah disetel di gambar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nlepage / golang_wasm</a> , sehingga Anda dapat menggunakan file <code>Dockerfile</code> seperti ini untuk dikompilasi: <br><br><pre> <code class="hljs go">FROM nlepage/golang_wasm COPY helloworld.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> /<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>/src/hello/ RUN <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> build -o test.wasm hello</code> </pre><br>  Langkah terakhir adalah menggunakan file <code>wasm_exec.html</code> dan <code>wasm_exec.js</code> tersedia di repositori go di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code> misc/wasm</code></a> atau di docker image <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nlepage / golang_wasm</a> di <code>/usr/local/go/misc/wasm/</code> untuk menjalankan <code>test.wasm</code> di browser (wasm_exec.js mengharapkan file binary <code>test.wasm</code> , jadi kami menggunakan nama ini). <br>  Anda hanya perlu memberikan 3 file statis menggunakan nginx, misalnya, lalu wasm_exec.html akan menampilkan tombol ‚Äúrun‚Äù (ini akan menyala hanya jika <code>test.wasm</code> dimuat dengan benar). <br><br>  Patut dicatat bahwa <code>test.wasm</code> harus disajikan dengan <code>application/wasm</code> jenis MIME, jika tidak browser akan menolak untuk mengeksekusinya.  (mis. nginx membutuhkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">file mime.types yang diperbarui</a> ). <br><br>  Anda dapat menggunakan gambar nginx dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nlepage / golang_wasm</a> , yang sudah menyertakan tipe MIME tetap, <code>wasm_exec.html</code> dan <code>wasm_exec.js</code> dalam kode&gt; / usr / share / nginx / html / direktori. <br><br>  Sekarang klik tombol "run", lalu buka konsol browser Anda dan Anda akan melihat ucapan console.log ("Hello Wasm!"). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb1/3fe/587/cb13fe587331b2426368ea541f22c61b.png"></div><br>  Contoh lengkap tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h3>  Panggil JS dari Go </h3><br>  Sekarang kita telah berhasil meluncurkan biner WebAssembly pertama yang dikompilasi dari Go, mari kita lihat lebih dekat fitur yang disediakan. <br><br>  Paket syscall / js baru telah ditambahkan ke perpustakaan standar. Pertimbangkan file utama, <code><a href="">js.go</a></code> <br>  Tipe <code>js.Value</code> baru <code>js.Value</code> yang mewakili nilai JavaScript. <br><br>  Ini menawarkan API sederhana untuk mengelola variabel JavaScript: <br><br><ul><li>  <code>js.Value.Get()</code> dan <code>js.Value.Set()</code> mengembalikan dan mengatur nilai bidang objek. </li><li>  <code>js.Value.Index()</code> dan <code>js.Value.SetIndex()</code> mengakses objek dengan membaca dan menulis indeks. </li><li>  <code>js.Value.Call()</code> memanggil metode objek sebagai fungsi. </li><li>  <code>js.Value.Invoke()</code> menyebut objek itu sendiri sebagai fungsi. </li><li>  <code>js.Value.New()</code> memanggil operator baru dan menggunakan pengetahuannya sendiri sebagai konstruktor. </li><li>  Beberapa metode lagi untuk mendapatkan nilai JavaScript dalam tipe Go yang sesuai, misalnya <code>js.Value.Int()</code> atau <code>js.Value.Bool()</code> . </li></ul><br>  Dan metode menarik tambahan: <br><br><ul><li>  <code>js.Undefined()</code> akan memberikan js.Value <code>undefined</code> sesuai. </li><li>  <code>js.Null()</code> akan memberikan <code>js.Value</code> <code>null</code> sesuai. </li><li>  <code>js.Global()</code> akan mengembalikan <code>js.Value</code> memberikan akses ke lingkup global. </li><li>  <code>js.ValueOf()</code> menerima tipe Go primitif dan mengembalikan <code>js.Value</code> benar </li></ul><br>  Alih-alih menampilkan pesan di os.StdOut, mari kita tampilkan di jendela notifikasi menggunakan <code>window.alert()</code> . <br><br>  Karena kita berada di browser, ruang lingkup global adalah sebuah jendela, jadi pertama-tama Anda perlu mendapatkan lansiran () dari ruang lingkup global: <br><br><pre> <code class="go hljs">alert := js.Global().Get(<span class="hljs-string"><span class="hljs-string">"alert"</span></span>)</code> </pre><br>  Sekarang kita memiliki variabel <code>alert</code> , dalam bentuk <code>js.Value</code> , yang merupakan referensi ke <code>window.alert</code> JS, dan Anda dapat menggunakan fungsi untuk memanggil melalui <code>js.Value.Invoke()</code> : <br><br><pre> <code class="go hljs">alert.Invoke(<span class="hljs-string"><span class="hljs-string">"Hello wasm!"</span></span>)</code> </pre><br>  Seperti yang Anda lihat, tidak perlu memanggil js.ValueOf () sebelum meneruskan argumen ke Invoke, dibutuhkan <code>interface{}</code> sewenang-wenang dan meneruskan nilai melalui ValueOf itu sendiri. <br><br>  Sekarang program baru kita akan terlihat seperti ini: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"syscall/js"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { alert := js.Global().Get(<span class="hljs-string"><span class="hljs-string">"alert"</span></span>) alert.Invoke(<span class="hljs-string"><span class="hljs-string">"Hello Wasm!"</span></span>) }</code> </pre><br>  Seperti pada contoh pertama, Anda hanya perlu membuat file bernama <code>test.wasm</code> , dan biarkan <code>wasm_exec.html</code> dan <code>wasm_exec.js</code> seperti semula. <br>  Sekarang, ketika kita mengklik tombol "Jalankan", jendela peringatan muncul dengan pesan kami. <br><br>  Contoh yang berfungsi ada di folder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>examples/js-call</code></a> . <br><br><h3>  Panggil Pergi dari JS. </h3><br>  Memanggil JS dari Go cukup sederhana, mari kita lihat lebih dekat pada paket <code>syscall/js</code> , file kedua yang akan dilihat adalah <a href=""><code>callback.go</code></a> . <br><br><ul><li>  <code>js.Callback</code> tipe pembungkus untuk fungsi Go, untuk digunakan dalam JS. </li><li>  <code>js.NewCallback()</code> fungsi yang mengambil fungsi (menerima sepotong <code>js.Value</code> dan mengembalikan apa-apa), dan mengembalikan <code>js.Callback</code> . </li><li>  Beberapa mekanisme untuk mengelola panggilan balik aktif dan <code>js.Callback.Release()</code> , yang harus dipanggil untuk menghancurkan panggilan balik itu. </li><li>  <code>js.NewEventCallback()</code> mirip dengan <code>js.NewCallback()</code> , tetapi fungsi yang dibungkus hanya menerima 1 argumen - sebuah peristiwa. </li></ul><br>  Mari kita coba melakukan sesuatu yang sederhana: jalankan Go <code>fmt.Println()</code> dari sisi JS. <br><br>  Kami akan membuat beberapa perubahan pada <code>wasm_exec.html</code> untuk bisa mendapatkan panggilan balik dari Go untuk memanggilnya. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.clear(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> go.run(inst); inst = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> WebAssembly.instantiate(mod, go.ImportObject); <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre><br>  Ini meluncurkan binary wasme dan menunggu untuk menyelesaikannya, kemudian menginisialisasi ulang untuk menjalankan berikutnya. <br><br>  Mari kita tambahkan fungsi baru yang akan menerima dan menyimpan panggilan balik Go dan mengubah status <code>Promise</code> setelah selesai: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> printMessage <span class="hljs-comment"><span class="hljs-comment">// Our reference to the Go callback let printMessageReceived // Our promise let resolvePrintMessageReceived // Our promise resolver function setPrintMessage(callback) { printMessage = callback resolvePrintMessageReceived() }</span></span></code> </pre><br>  Sekarang mari kita adaptasikan fungsi <code>run()</code> untuk menggunakan callback: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.clear() <span class="hljs-comment"><span class="hljs-comment">// Create the Promise and store its resolve function printMessageReceived = new Promise(resolve =&gt; { resolvePrintMessageReceived = resolve }) const run = go.run(inst) // Start the wasm binary await printMessageReceived // Wait for the callback reception printMessage('Hello Wasm!') // Invoke the callback await run // Wait for the binary to terminate inst = await WebAssembly.instantiate(mod, go.importObject) // reset instance }</span></span></code> </pre><br>  Dan ini ada di pihak JS! <br><br>  Sekarang, di bagian Go, Anda perlu membuat panggilan balik, mengirimkannya ke sisi JS dan menunggu fungsi yang diperlukan. <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> done = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{})</code> </pre><br>  Maka mereka harus menulis fungsi <code>printMessage()</code> : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args []js.Value)</span></span></span></span> { message := args[<span class="hljs-number"><span class="hljs-number">0</span></span>].Strlng() fmt.Println(message) done &lt;- <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}{} <span class="hljs-comment"><span class="hljs-comment">// Notify printMessage has been called }</span></span></code> </pre><br>  Argumen dilewatkan melalui slice <code>[]js.Value</code> , jadi Anda perlu memanggil <code>js.Value.String()</code> pada elemen slice pertama untuk mendapatkan pesan di baris Go. <br>  Sekarang kita dapat membungkus fungsi ini dalam panggilan balik: <br><br><pre> <code class="go hljs">callback := js.NewCallback(printMessage) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> callback.Release() <span class="hljs-comment"><span class="hljs-comment">// to defer the callback releasing is a good practice</span></span></code> </pre><br>  Kemudian panggil fungsi JS <code>setPrintMessage()</code> , sama seperti memanggil <code>window.alert()</code> : <br><br><pre> <code class="go hljs">setPrintMessage := js.Global.Get(<span class="hljs-string"><span class="hljs-string">"setPrintMessage"</span></span>) setPrintMessage.Invoke(callback)</code> </pre><br>  Hal terakhir yang harus dilakukan adalah menunggu panggilan balik dipanggil di utama: <br><br><pre> <code class="go hljs">&lt;-done</code> </pre><br>  Bagian terakhir ini penting karena callback dijalankan dalam goroutine khusus, dan goroutine utama harus menunggu panggilan balik dipanggil, jika biner wasm akan dihentikan sebelum waktunya. <br><br>  Program Go yang dihasilkan akan terlihat seperti ini: <br><br><pre> <code class="go hljs">Ôªø<span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"syscall/js"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> done = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { callback := js.NewCallback(prtntMessage) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> callback.Release() setPrintMessage := js.Global().Get(<span class="hljs-string"><span class="hljs-string">"setPrintMessage"</span></span>) setPrIntMessage.Invoke(callback) &lt;-done } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args []js.Value)</span></span></span></span> { message := args[<span class="hljs-number"><span class="hljs-number">0</span></span>].Strlng() fmt.PrintIn(message) done &lt;- <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}{} }</code> </pre><br>  Seperti pada contoh sebelumnya, buat file bernama <code>test.wasm</code> .  Kita juga perlu mengganti <code>wasm_exec.html</code> dengan versi kita, dan <code>wasm_exec.js</code> dapat menggunakan kembali <code>wasm_exec.js</code> . <br><br>  Sekarang, ketika Anda menekan tombol "run", seperti dalam contoh pertama kami, pesan dicetak di konsol browser, tetapi kali ini jauh lebih baik!  (Dan lebih keras.) <br><br>  Contoh yang berfungsi dalam tawaran file buruh pelabuhan tersedia di folder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>examples/go-call</code></a> . <br><br><h3>  Kerja panjang </h3><br>  Memanggil Go dari JS sedikit lebih rumit daripada memanggil JS dari Go, terutama di sisi JS. <br><br>  Hal ini terutama disebabkan oleh fakta bahwa Anda perlu menunggu sampai hasil panggilan balik Go diteruskan ke sisi JS. <br><br>  Mari kita coba sesuatu yang lain: mengapa tidak mengatur binary wasm, yang tidak akan berakhir tepat setelah panggilan balik, tetapi akan terus bekerja dan menerima panggilan lain. <br>  Kali ini, mari kita mulai dari sisi Go, dan seperti pada contoh kita sebelumnya, kita perlu membuat panggilan balik dan mengirimkannya ke sisi JS. <br><br>  Tambahkan penghitung panggilan untuk melacak berapa kali fungsi telah dipanggil. <br><br>  Fungsi <code>printMessage()</code> baru kami <code>printMessage()</code> akan mencetak pesan yang diterima dan nilai penghitung: <br><br><pre> <code class="go hljs">Ôªø<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> no <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args []js.Value)</span></span></span></span> { message := args[<span class="hljs-number"><span class="hljs-number">0</span></span>].String() no++ fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Message no %d: %s\n"</span></span>, no, message) }</code> </pre><br>  Membuat panggilan balik dan mengirimnya ke sisi JS sama seperti pada contoh sebelumnya: <br><br><pre> <code class="go hljs">Ôªøcallback := js.NewCallback(printMessage) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> callback.Release() setPrintMessage := js.Global().Get(<span class="hljs-string"><span class="hljs-string">"setPrintMessage"</span></span>) setPrIntMessage.Invoke(callback)</code> </pre><br>  Tapi kali ini kami belum memiliki saluran untuk memberi tahu kami tentang penghentian goroutine utama.  Salah satu caranya adalah dengan mengunci goroutin utama secara permanen dengan <code>select{}</code> kosong <code>select{}</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span>{}</code> </pre><br>  Ini tidak memuaskan, binary wasm kami hanya akan menggantung di memori sampai tab browser ditutup. <br><br>  Anda dapat mendengarkan acara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>beforeunload</code></a> pada halaman, Anda akan membutuhkan panggilan balik kedua untuk menerima acara dan memberitahukan goroutine utama melalui saluran: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> beforeUnloadCh = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{})</code> </pre><br>  Kali ini, fungsi <code>beforeUnload()</code> baru hanya akan menerima acara tersebut, sebagai argumen tunggal <code>js.Value</code> : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeUnload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event js.Value)</span></span></span></span> { beforeUnloadCh &lt;- <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}{} }</code> </pre><br>  Kemudian bungkus dengan callback menggunakan <code>js.NewEventCallback()</code> dan daftarkan di sisi JS: <br><br><pre> <code class="go hljs">beforeUnloadCb := js.NewEventCallback(<span class="hljs-number"><span class="hljs-number">0</span></span>, beforeUnload) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> beforeUnloadCb.Release() addEventLtstener := js.Global().Get(<span class="hljs-string"><span class="hljs-string">"addEventListener"</span></span>) addEventListener.Invoke(<span class="hljs-string"><span class="hljs-string">"beforeunload"</span></span>, beforeUnloadCb)</code> </pre><br>  Akhirnya, ganti <code>select</code> pemblokiran kosong dengan membaca dari saluran <code>beforeUnloadCh</code> : <br><br><pre> <code class="go hljs">&lt;-beforeUnloadCh fmt.Prtntln(<span class="hljs-string"><span class="hljs-string">"Bye Wasm!"</span></span>)</code> </pre><br>  Program akhir terlihat seperti ini: <br><br><pre> <code class="go hljs">Ôªø<span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"syscall/js"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( no <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beforeUnloadCh = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}) ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { callback := js.NewCallback(printMessage) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> callback.Release() setPrintMessage := js.Global().Get(<span class="hljs-string"><span class="hljs-string">"setPrintMessage"</span></span>) setPrIntMessage.Invoke(callback) beforeUnloadCb := js.NewEventCallback(<span class="hljs-number"><span class="hljs-number">0</span></span>, beforeUnload) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> beforeUnloadCb.Release() addEventLtstener := js.Global().Get(<span class="hljs-string"><span class="hljs-string">"addEventListener"</span></span>) addEventListener.Invoke(<span class="hljs-string"><span class="hljs-string">"beforeunload"</span></span>, beforeUnloadCb) &lt;-beforeUnloadCh fmt.Prtntln(<span class="hljs-string"><span class="hljs-string">"Bye Wasm!"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args []js.Value)</span></span></span></span> { message := args[<span class="hljs-number"><span class="hljs-number">0</span></span>].String() no++ fmt.Prtntf(<span class="hljs-string"><span class="hljs-string">"Message no %d: %s\n"</span></span>, no, message) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeUnload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event js.Value)</span></span></span></span> { beforeUnloadCh &lt;- <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}{} }</code> </pre><br>  Sebelumnya, di sisi JS, unduhan biner wasme tampak seperti ini: <br><br><pre> <code class="javascript hljs">Ôªø<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> go = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Go() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mod, inst WebAssembly .instantiateStreaming(fetch(<span class="hljs-string"><span class="hljs-string">"test.wasm"</span></span>), go.importObject) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { mod = result.module inst = result.Instance <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"runButton"</span></span>).disabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span> })</code> </pre><br>  Mari kita adaptasi untuk menjalankan biner segera setelah memuat: <br><br><pre> <code class="javascript hljs">Ôªø(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> go = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Go() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { instance } = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> WebAssembly.instantiateStreaming( fetch(<span class="hljs-string"><span class="hljs-string">"test.wasm"</span></span>), go.importObject ) go.run(instance) })()</code> </pre><br>  Dan ganti tombol "Jalankan" dengan bidang pesan dan tombol untuk memanggil <code>printMessage()</code> : <br><br><pre> <code class="xml hljs">Ôªø<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"messageInput"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Hello Wasm!"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"printMessage(document.querySelector('#messagelnput').value);"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"prtntMessageButton"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">disabled</span></span></span><span class="hljs-tag">&gt;</span></span> Print message <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Akhirnya, fungsi <code>setPrintMessage()</code> , yang menerima dan menyimpan panggilan balik, harus lebih sederhana: <br><br><pre> <code class="javascript hljs">Ôªø<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> printMessage; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPrintMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ printMessage = callback; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'#printMessageButton'</span></span>).disabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Sekarang, ketika kita mengklik tombol "Cetak pesan", Anda akan melihat pesan pilihan kami dan penghitung panggilan dicetak di konsol browser. <br>  Jika kita mencentang kotak Preserve log dari konsol browser dan menyegarkan halaman, kita akan melihat pesan "Bye Wasm!". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c3/676/63d/6c367663d28d90535ccaafd1c10b5f50.png"></div><br><br>  Sumber tersedia di folder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>examples/long-running</code></a> di github. <br><br><h3>  Lalu? </h3><br>  Seperti yang Anda lihat, API <code>syscall/js</code> dipelajari melakukan tugasnya dan memungkinkan Anda menulis hal-hal kompleks dengan sedikit kode.  Anda dapat menulis kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penulis</a> jika Anda tahu metode yang lebih sederhana. <br>  Saat ini tidak mungkin untuk mengembalikan nilai ke JS langsung dari panggilan balik Go. <br>  Ingatlah bahwa semua panggilan balik dilakukan di goroutin yang sama, jadi jika Anda melakukan beberapa operasi pemblokiran dalam panggilan balik tersebut, jangan lupa untuk membuat goroutin baru, jika tidak, Anda akan memblokir eksekusi semua panggilan balik lainnya. <br>  Semua fitur bahasa dasar sudah tersedia, termasuk konkurensi.  Untuk saat ini, semua goroutin akan bekerja dalam satu utas, tetapi ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akan berubah di masa mendatang</a> . <br>  Dalam contoh kami, kami hanya menggunakan paket fmt dari perpustakaan standar, tetapi semuanya tersedia yang tidak mencoba untuk melarikan diri dari kotak pasir. <br><br>  Sistem file tampaknya didukung melalui Node.js. <br><br>  Akhirnya, bagaimana dengan kinerja?  Akan menarik untuk menjalankan beberapa tes untuk melihat bagaimana Go wasm membandingkan dengan kode JS murni yang setara.  Seseorang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hajimehoshi</a> membuat pengukuran tentang bagaimana lingkungan yang berbeda bekerja dengan bilangan bulat, tetapi tekniknya tidak terlalu jelas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae0/e5b/ab5/ae0e5bab565640331a956284e94f4859.jpg"></div><br><br>  Jangan lupa bahwa Go 1.11 belum dirilis secara resmi.  Menurut saya itu sangat bagus untuk teknologi eksperimental.  Mereka yang tertarik dengan tes kinerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat menyiksa browser mereka</a> . <br>  Ceruk utama, seperti yang dicatat penulis, adalah transfer dari server ke klien dari kode go yang ada.  Tetapi dengan standar baru, Anda dapat membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi sepenuhnya offline</a> , dan kode wasm disimpan dalam bentuk yang dikompilasi.  Anda dapat mentransfer banyak utilitas ke web, setuju, dengan nyaman? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417563/">https://habr.com/ru/post/id417563/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417553/index.html">Buka webinar "CSS preprocessors"</a></li>
<li><a href="../id417555/index.html">Seminar Kultus Kargo Diumumkan di Moskow: Pemogokan Pemasaran Kembali</a></li>
<li><a href="../id417557/index.html">Ikhtisar Mesin Laser CNC LaserSolid</a></li>
<li><a href="../id417559/index.html">Bagaimana China membuat Apple menyimpan kunci enkripsi pengguna iCloud di server negara Cina</a></li>
<li><a href="../id417561/index.html">Call of the Date, atau How adalah Mail kedua.Ru Mail hackathon</a></li>
<li><a href="../id417565/index.html">Google akan meletakkan kabel pribadi melintasi Atlantik</a></li>
<li><a href="../id417569/index.html">Unit menguji skrip basis data</a></li>
<li><a href="../id417571/index.html">Bandit multi-bersenjata dalam rekomendasi</a></li>
<li><a href="../id417573/index.html">Pengembang AI yang terkenal di dunia sepakat untuk tidak membuat senjata pintar</a></li>
<li><a href="../id417577/index.html">Mesin CNC patut diperhatikan dari 3Dtool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>