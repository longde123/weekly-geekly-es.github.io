<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴🏿 🦆 🐆 Testen von Node.js-Projekten. Teil 2. Bewertung der Testleistung, kontinuierliche Integration und Analyse der Codequalität 🥉 🅰️ 😽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="→ Testen von Node.js-Projekten. Teil 1. Testanatomie und Testtypen 

 Im zweiten Teil der Übersetzung von Material zum Testen von Node.js-Projekten we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testen von Node.js-Projekten. Teil 2. Bewertung der Testleistung, kontinuierliche Integration und Analyse der Codequalität</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/435464/">  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testen von Node.js-Projekten.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1. Testanatomie und Testtypen</a> <br><br>  Im zweiten Teil der Übersetzung von Material zum Testen von Node.js-Projekten werden wir heute über die Bewertung der Wirksamkeit von Tests und die Analyse der Qualität des Codes sprechen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/f16/1a0/3e2/f161a03e2b08ae35b31f718a083a39a0.jpg" alt="Bild"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Abschnitt 3. Bewertung der Wirksamkeit von Tests</font> </h2><br><h3>  <font color="#3AC1EF">▍19.</font>  <font color="#3AC1EF">Erreichen Sie mit Tests eine ausreichend hohe Codeabdeckung, um Vertrauen in den korrekten Betrieb zu gewinnen.</font>  <font color="#3AC1EF">Normalerweise liefert eine Abdeckung von ungefähr 80% gute Ergebnisse.</font> </h3><br><h4>  Empfehlungen </h4><br>  Der Zweck des Testens besteht darin, sicherzustellen, dass der Programmierer weiterhin produktiv an dem Projekt arbeiten kann, um sicherzustellen, dass das, was bereits getan wurde, korrekt ist.  Je größer das Volumen des getesteten Codes ist, desto stärker ist natürlich das Vertrauen, dass alles so funktioniert, wie es sollte.  Der Indikator für die Codeabdeckung durch Tests gibt an, wie viele Zeilen (Zweige, Befehle) durch Tests überprüft wurden.  Was soll dieser Indikator sein?  Es ist klar, dass 10-30% zu wenig sind, um sicher zu sein, dass das Projekt fehlerfrei funktioniert.  Andererseits kann sich der Wunsch nach einer 100% igen Abdeckung des Codes mit Tests als zu teuer herausstellen und den Entwickler von den wichtigsten Programmfragmenten ablenken, sodass er im Code nach Stellen suchen muss, die die vorhandenen Tests nicht erreichen.  Wenn Sie eine umfassendere Antwort auf die Frage geben, wie der Code mit Tests abgedeckt werden soll, können wir sagen, dass der Indikator, nach dem wir streben sollten, von der zu entwickelnden Anwendung abhängt.  Wenn Sie beispielsweise Software für den Airbus A380 der nächsten Generation schreiben, ist 100% ein Indikator, der nicht einmal diskutiert wird.  Wenn Sie jedoch eine Website erstellen, auf der Karikaturgalerien angezeigt werden, sind wahrscheinlich 50% bereits viel.  Obwohl Testexperten sagen, dass der Grad der Codeabdeckung mit Tests, die Sie anstreben sollten, vom Projekt abhängt, erwähnen viele von ihnen die 80% -Zahl, die wahrscheinlich für die meisten Anwendungen geeignet ist.  Zum Beispiel sprechen wir hier von etwas im Bereich von 80-90%, und laut dem Autor dieses Materials macht ihn eine 100% ige Abdeckung des Codes mit Tests misstrauisch, da dies darauf hindeuten kann, dass der Programmierer Tests nur schreibt, um sie zu erhalten schöne Nummer im Bericht. <br><br>  Um die Indikatoren für Codeabdeckungstests verwenden zu können, müssen Sie Ihr System für die kontinuierliche Integration (CI, Continuous Integration) ordnungsgemäß konfigurieren.  Auf diese Weise kann die Montage des Projekts gestoppt werden, wenn der entsprechende Indikator einen bestimmten Schwellenwert nicht erreicht.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> erfahren Sie, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie Sie</a> Jest so konfigurieren, dass Informationen zur Testabdeckung erfasst werden.  Darüber hinaus können Sie Abdeckungsschwellenwerte nicht für den gesamten Code konfigurieren, sondern sich auf einzelne Komponenten konzentrieren.  Erwägen Sie außerdem, eine Abnahme der Testabdeckung festzustellen.  Dies geschieht beispielsweise, wenn Sie einem Projekt neuen Code hinzufügen.  Die Steuerung dieses Indikators ermutigt Entwickler, das Volumen des getesteten Codes zu erhöhen oder zumindest dieses Volumen auf dem vorhandenen Niveau zu halten.  In Anbetracht des oben Gesagten ist die Abdeckung von Code mit Tests nur ein quantifizierter Indikator, der nicht ausreicht, um die Zuverlässigkeit von Tests vollständig zu bewerten.  Wie weiter unten gezeigt wird, bedeuten die hohen Werte noch nicht, dass der Code „mit Tests abgedeckt“ wirklich überprüft wird. <br><br><h4>  Folgen der Abweichung von den Empfehlungen </h4><br>  Das Vertrauen des Programmierers in die hohe Qualität des Codes und die damit verbundenen Indikatoren im Zusammenhang mit dem Testen gehen Hand in Hand.  Ein Programmierer kann nicht anders, als Angst vor Fehlern zu haben, wenn er nicht weiß, dass der größte Teil des Codes für sein Projekt durch Tests abgedeckt ist.  Diese Bedenken können Ihr Projekt verlangsamen. <br><br><h4>  Beispiel </h4><br>  So sieht ein typischer Testbericht aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96b/951/4fc/96b9514fc0e5d96553a4fc8551793d27.png"></div><br>  <i><font color="#999999">Von Istanbul erstellter Testbericht</font></i> <br><br><h4>  Richtiger Ansatz </h4><br>  Hier ist ein Beispiel für die Einstellung der gewünschten Testabdeckung des Komponentencodes und der allgemeinen Ebene dieses Indikators in Jest. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e23/feb/473/e23feb47399296324bb96b2109d4b360.jpg"></div><br>  <i><font color="#999999">Festlegen der gewünschten Codeabdeckung mit Tests für das gesamte Projekt und für eine bestimmte Komponente</font></i> <br><br><h3>  <font color="#3AC1EF">▍20.</font>  <font color="#3AC1EF">Untersuchen Sie Berichte zur Codeabdeckung mit Tests, um ungeschützte Teile des Codes und andere Anomalien zu identifizieren</font> </h3><br><h4>  Empfehlungen </h4><br>  Einige Probleme neigen dazu, durch eine Vielzahl von Fehlererkennungssystemen zu rutschen.  Solche Dinge können mit herkömmlichen Werkzeugen schwer zu erkennen sein.  Möglicherweise trifft dies nicht auf echte Fehler zu.  Es handelt sich vielmehr um unerwartetes Anwendungsverhalten, das verheerende Folgen haben kann.  Beispielsweise kommt es häufig vor, dass einige Codefragmente entweder nie verwendet oder selten aufgerufen werden.  Sie denken beispielsweise, dass die Mechanismen der <code>PricingCalculator</code> Klasse immer zum <code>PricingCalculator</code> des Preises eines Produkts verwendet werden. Tatsächlich stellt sich jedoch heraus, dass diese Klasse überhaupt nicht verwendet wird und dass in der Datenbank und im Online-Shop, in dem das System verwendet wird, Aufzeichnungen von 10.000 Produkten vorhanden sind. Viele Verkäufe ... Berichte über die Codeabdeckung mit Tests helfen dem Entwickler zu verstehen, ob die Anwendung so funktioniert, wie sie funktionieren sollte.  Darüber hinaus können Sie anhand der Berichte herausfinden, welcher Projektcode nicht getestet wurde.  Wenn Sie sich auf einen allgemeinen Indikator konzentrieren, der angibt, dass Tests 80% des Codes abdecken, können Sie nicht herausfinden, ob kritische Teile der Anwendung getestet werden.  Um einen solchen Bericht zu erstellen, reicht es aus, das Tool, mit dem Sie die Tests ausführen, ordnungsgemäß zu konfigurieren.  Solche Berichte sehen normalerweise ziemlich hübsch aus, und ihre Analyse, die nicht viel Zeit in Anspruch nimmt, ermöglicht es Ihnen, alle möglichen Überraschungen zu erkennen. <br><br><h4>  Folgen der Abweichung von den Empfehlungen </h4><br>  Wenn Sie nicht wissen, welche Teile Ihres Codes noch nicht getestet wurden, wissen Sie nicht, wo Sie Probleme erwarten können. <br><br><h4>  Falscher Ansatz </h4><br>  Schauen Sie sich den nächsten Bericht an und überlegen Sie, was darin ungewöhnlich aussieht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ce/883/889/1ce88388923499c997c6fdc4606d3c10.png"></div><br>  <i><font color="#999999">Bericht über ungewöhnliches Systemverhalten</font></i> <br><br>  Der Bericht basiert auf einem realen Anwendungsnutzungsszenario und ermöglicht es Ihnen, ungewöhnliches Programmverhalten zu sehen, das mit Benutzern verbunden ist, die sich am System anmelden.  Eine unerwartet große Anzahl erfolgloser Versuche, in das System einzudringen, fällt nämlich im Vergleich zu erfolgreichen auf.  Nach der Analyse des Projekts stellte sich heraus, dass der Grund dafür ein Fehler im Frontend war, aufgrund dessen der Schnittstellenteil des Projekts ständig entsprechende Anforderungen an die Server-API zur Eingabe des Systems sendete. <br><br><h3>  <font color="#3AC1EF">▍21.</font>  <font color="#3AC1EF">Messen Sie die logische Codeabdeckung mit Tests mithilfe von Mutationstests</font> </h3><br><h4>  Empfehlungen </h4><br>  Herkömmliche Benchmarking-Metriken sind möglicherweise unzuverlässig.  Der Bericht kann also eine Zahl von 100% enthalten, aber gleichzeitig geben absolut alle Funktionen des Projekts falsche Werte zurück.  Wie kann man das erklären?  Tatsache ist, dass der Indikator für die Codeabdeckung durch Tests nur angibt, welche Codezeilen unter der Kontrolle des Testsystems ausgeführt wurden, aber nicht davon abhängt, ob etwas wirklich verifiziert wurde, dh ob die Aussagen des Tests waren zielte darauf ab, die Richtigkeit der Ergebnisse des Codes zu überprüfen.  Dies ähnelt einer Person, die nach einer Geschäftsreise ins Ausland Briefmarken in ihrem Pass zeigt.  Briefmarken beweisen, dass er irgendwohin gegangen ist, aber sie sagen nichts darüber aus, ob er das getan hat, was er auf Geschäftsreise gemacht hat. <br><br>  Hier können uns Mutationstests helfen, mit denen wir herausfinden können, wie viel Code tatsächlich getestet und nicht nur vom Testsystem besucht wurde.  Für Mutationstests können Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stryker</a> JS-Bibliothek verwenden.  Hier sind die Prinzipien, nach denen es funktioniert: <br><br><ol><li>  Sie ändert den Code absichtlich und erzeugt Fehler darin.  Beispielsweise wird der Code <code>newOrder.price===0</code> zu <code>newOrder.price!=0</code> .  Diese "Fehler" nennt man Mutationen. </li><li>  Sie führt Tests durch.  Wenn sich herausstellt, dass sie bestanden wurden, haben wir Probleme, weil die Tests ihre Aufgabe, Fehler zu erkennen, nicht erfüllen und die „Mutanten“, wie sie sagen, „überleben“.  Wenn die Tests Fehler im Code anzeigen, ist alles in Ordnung - die "Mutanten" "sterben". </li></ol><br>  Wenn sich herausstellt, dass alle "Mutanten" "getötet" wurden (oder zumindest die meisten von ihnen nicht überlebten), gibt dies ein höheres Maß an Vertrauen in die hohe Qualität des Codes und die Tests, die ihn testen, als herkömmliche Metriken zum Abdecken des Codes mit Tests.  Gleichzeitig ist die Zeit, die zum Konfigurieren und Durchführen von Mutationstests erforderlich ist, mit der Zeit vergleichbar, die bei Verwendung herkömmlicher Tests benötigt wird. <br><br><h4>  Folgen der Abweichung von den Empfehlungen </h4><br>  Wenn der traditionelle Indikator für die Codeabdeckung durch Tests anzeigt, dass 85% des Codes durch Tests abgedeckt sind, bedeutet dies nicht, dass die Tests Fehler in diesem Code erkennen können. <br><br><h4>  Falscher Ansatz </h4><br>  Hier ist ein Beispiel für eine 100% ige Abdeckung des Codes mit Tests, bei denen der Code nicht vollständig getestet wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addNewOrder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newOrder</span></span></span><span class="hljs-function">) </span></span>{   logger.log(<span class="hljs-string"><span class="hljs-string">`Adding new order </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${newOrder}</span></span></span><span class="hljs-string">`</span></span>);   DB.save(newOrder);   Mailer.sendMail(newOrder.assignee, <span class="hljs-string"><span class="hljs-string">`A new order was places </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${newOrder}</span></span></span><span class="hljs-string">`</span></span>);   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">approved</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}; } it(<span class="hljs-string"><span class="hljs-string">"Test addNewOrder, don't use such test names"</span></span>, () =&gt; {   addNewOrder({<span class="hljs-attr"><span class="hljs-attr">asignee</span></span>: <span class="hljs-string"><span class="hljs-string">"John@mailer.com"</span></span>,<span class="hljs-attr"><span class="hljs-attr">price</span></span>: <span class="hljs-number"><span class="hljs-number">120</span></span>}); });<span class="hljs-comment"><span class="hljs-comment">//    100%, ,   ,    </span></span></code> </pre> <br><h4>  Richtiger Ansatz </h4><br>  Hier ist der Mutationstestbericht, der von der Stryker-Bibliothek erstellt wurde.  Hier können Sie herausfinden, wie viel Code nicht getestet wurde (dies wird durch die Anzahl der "überlebenden" "Mutanten" angezeigt). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/037/f6c/9c0/037f6c9c038e09d219c1d06a1b255e4c.jpg"></div><br>  <i><font color="#999999">Stryker-Bericht</font></i> <br><br>  Die Ergebnisse dieses Berichts lassen mit mehr Sicherheit als übliche Indikatoren für die Codeabdeckung bei Tests zu, dass die Tests wie erwartet funktionieren. <br><br><ul><li>  Eine Mutation ist ein Code, der von der Stryker-Bibliothek absichtlich geändert wurde, um die Wirksamkeit eines Tests zu testen. </li><li>  Die Anzahl der "getöteten" "Mutanten" (getötet) zeigt die Anzahl der absichtlich erzeugten Codedefekte ("Mutanten"), die während des Tests identifiziert wurden. </li><li>  Die Anzahl der "überlebenden" "Mutanten" (überlebt) ermöglicht es Ihnen herauszufinden, wie viele Codefehler-Tests nicht gefunden wurden. </li></ul><br><h2>  <font color="#3AC1EF">Abschnitt 4. Kontinuierliche Integration, andere Codequalitätsindikatoren</font> </h2><br><h3>  <font color="#3AC1EF">▍ 22.</font>  <font color="#3AC1EF">Nutzen Sie die Funktionen von linter und unterbrechen Sie den Erstellungsprozess des Projekts, wenn Probleme erkannt werden, die gemeldet werden</font> </h3><br><h4>  Empfehlungen </h4><br>  Linters sind heute leistungsstarke Tools, mit denen schwerwiegende Codeprobleme erkannt werden können.  Es wird empfohlen, zusätzlich zu einigen grundlegenden Flusenregeln (wie den durch die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plugins eslint-plugin-standard</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eslint-config-airbnb implementierten</a> ) spezielle Regeln zu verwenden.  Dies sind beispielsweise die Regeln, die mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eslint-plugin-chai-expected-Plugins</a> implementiert wurden, um die Richtigkeit des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testcodes</a> zu überprüfen. Dies sind die Regeln des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eslint-plugin-versprechen-Plugins</a> , die die Arbeit mit Versprechungen steuern. Dies sind die Regeln der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eslint-plugin-Sicherheit</a> , die den Code auf Verfügbarkeit prüfen es enthält gefährliche reguläre Ausdrücke.  Hier können Sie auch das Plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eslint-plugin-you-dont-need-lodash-underscore erwähnen</a> , mit dem Sie im Code die Verwendung von Methoden aus externen Bibliotheken finden können, die Analoga in reinem JavaScript enthalten. <br><br><h4>  Folgen der Abweichung von den Empfehlungen </h4><br>  Es ist ein regnerischer Tag gekommen, das Projekt führt zu kontinuierlichen Produktionsfehlern und es gibt keine Informationen zu Fehlerstapeln in den Protokollen.  Was ist passiert?  Wie sich herausstellte, ist das, was der Code als Ausnahme auslöst, nicht wirklich ein Fehlerobjekt.  Infolgedessen werden Informationen über den Stapel nicht in die Protokolle aufgenommen.  Tatsächlich kann der Programmierer in einer solchen Situation entweder gegen die Wand töten oder, viel besser, 5 Minuten damit verbringen, den Linter einzurichten, wodurch das Problem leicht erkannt und das Projekt vor ähnlichen Problemen geschützt wird, die in Zukunft auftreten können. <br><br><h4>  Falscher Ansatz </h4><br>  Hier ist der Code, der versehentlich ein gewöhnliches Objekt als Ausnahme auslöst, während Sie hier ein Objekt vom Typ <code>Error</code> benötigen.  Andernfalls werden die Daten zum Stapel nicht in das Protokoll aufgenommen.  ESLint findet heraus, was Produktionsprobleme verursachen kann, und hilft, diese Probleme zu vermeiden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6a/d40/bc0/d6ad40bc0f5e0c09840e3b52e2b878a6.jpg"></div><br>  <i><font color="#999999">ESLint hilft Ihnen, einen Fehler in Ihrem Code zu finden</font></i> <br><br><h3>  <font color="#3AC1EF">▍23.</font>  <font color="#3AC1EF">Schnelleres Feedback mit Entwicklern, die die lokale kontinuierliche Integration verwenden</font> </h3><br><h4>  Empfehlungen </h4><br>  Verwenden Sie ein zentrales System der kontinuierlichen Integration, mit dessen Hilfe Sie die Qualität des Codes kontrollieren, testen, den Linter verwenden und auf Schwachstellen prüfen können?  Stellen Sie in diesem Fall sicher, dass Entwickler dieses System lokal ausführen können.  Auf diese Weise können sie ihren Code sofort überprüfen, was das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Feedback</a> beschleunigt und die Projektentwicklungszeit verkürzt.  Warum ist das so?  Ein effektiver Entwicklungs- und Testprozess umfasst viele zyklisch wiederholte Vorgänge.  Der Code wird getestet, der Entwickler erhält einen Bericht, und bei Bedarf wird der Code überarbeitet. Danach wird alles wiederholt.  Je schneller die Rückkopplungsschleife funktioniert, desto schneller erhalten die Entwickler Berichte über Codetests, desto mehr Iterationen zur Verbesserung dieses Codes können sie durchführen.  Wenn das Abrufen eines Testberichts viel Zeit in Anspruch nimmt, kann dies zu einer schlechten Codequalität führen.  Angenommen, jemand hat an einem Modul gearbeitet, dann mit der Arbeit an einem anderen Modul begonnen und dann einen Bericht über das Modul erhalten, der angibt, dass das Modul verbessert werden muss.  Da sich der Entwickler jedoch bereits mit völlig anderen Themen beschäftigt, wird er dem Problemmodul nicht genügend Aufmerksamkeit schenken. <br><br>  Bei einigen CI-Lösungsanbietern (dies gilt beispielsweise für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CircleCI</a> ) können Sie die CI-Pipeline lokal ausführen.  Einige kostenpflichtige Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wallaby.js</a> (der Autor stellt fest, dass er nicht mit diesem Projekt verbunden ist) können schnell wertvolle Informationen über die Qualität des Codes erhalten.  Darüber hinaus kann der Entwickler einfach das entsprechende npm-Skript zu <code>package.json</code> , das Codequalitätsprüfungen durchführt (Tests, Analysen mit einem Linter, Suche nach Schwachstellen) und sogar das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gleichzeitige</a> Paket verwendet, um die Überprüfungen zu beschleunigen.  Um den Code jetzt umfassend zu überprüfen, reicht es aus, einen einzelnen Befehl wie die <code>npm run quality</code> und sofort einen Bericht zu erhalten.  Wenn die Codetests ergeben, dass Probleme vorliegen, können Sie Commits mithilfe von Git-Hooks abbrechen (die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Husky-</a> Bibliothek kann zur Lösung dieses Problems hilfreich sein). <br><br><h4>  Folgen der Abweichung von den Empfehlungen </h4><br>  Wenn ein Entwickler einen Tag nach dem Schreiben dieses Codes einen Bericht über die Qualität des Codes erhält, wird ein solcher Bericht wahrscheinlich zu einem formalen Dokument, und Codetests werden von der Arbeit getrennt und nicht zu ihrem natürlichen Bestandteil. <br><br><h4>  Richtiger Ansatz </h4><br>  Hier ist ein npm-Skript, das die Qualität des Codes überprüft.  Das Durchführen von Überprüfungen wird parallelisiert.  Das Skript wird ausgeführt, wenn versucht wird, neuen Code an das Repository zu senden.  Darüber hinaus kann der Entwickler es von sich aus starten. <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"inspect:sanity-testing"</span></span>: <span class="hljs-string"><span class="hljs-string">"mocha **/**--test.js --grep \"sanity\""</span></span>,   <span class="hljs-string"><span class="hljs-string">"inspect:lint"</span></span>: <span class="hljs-string"><span class="hljs-string">"eslint ."</span></span>,   <span class="hljs-string"><span class="hljs-string">"inspect:vulnerabilities"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm audit"</span></span>,   <span class="hljs-string"><span class="hljs-string">"inspect:license"</span></span>: <span class="hljs-string"><span class="hljs-string">"license-checker --failOn GPLv2"</span></span>,   <span class="hljs-string"><span class="hljs-string">"inspect:complexity"</span></span>: <span class="hljs-string"><span class="hljs-string">"plato ."</span></span>,     <span class="hljs-string"><span class="hljs-string">"inspect:all"</span></span>: <span class="hljs-string"><span class="hljs-string">"concurrently -c \"bgBlue.bold,bgMagenta.bold,yellow\" \"npm:inspect:quick-testing\" \"npm:inspect:lint\" \"npm:inspect:vulnerabilities\" \"npm:inspect:license\""</span></span> }, <span class="hljs-string"><span class="hljs-string">"husky"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"hooks"</span></span>: {     <span class="hljs-string"><span class="hljs-string">"precommit"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run inspect:all"</span></span>,     <span class="hljs-string"><span class="hljs-string">"prepush"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run inspect:all"</span></span>   } }</code> </pre> <br><h3>  <font color="#3AC1EF">▍24.</font>  <font color="#3AC1EF">Führen Sie End-to-End-Tests an einem realistischen Spiegel der Produktionsumgebung durch</font> </h3><br><h4>  Empfehlungen </h4><br>  In dem riesigen Kubernetes-Ökosystem besteht immer noch Konsens darüber, Tools zu verwenden, die für die Bereitstellung lokaler Umgebungen geeignet sind, obwohl solche Tools häufig vorkommen.  Ein möglicher Ansatz besteht darin, ein „minimiertes“ Kubernet mit Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Minikube</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MicroK8s auszuführen</a> , mit denen Sie leichtgewichtige Umgebungen erstellen können, die echten Umgebungen ähneln.  Ein anderer Ansatz besteht darin, Projekte in einer entfernten „echten“ Kubernetes-Umgebung zu testen.  Einige CI-Anbieter (wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codefresh</a> ) ermöglichen die Interaktion mit integrierten Umgebungen von Kubernetes, was die Arbeit von CI-Pipelines beim Testen realer Projekte vereinfacht.  In anderen Fällen können Sie mit Remote-Kubernetes-Umgebungen arbeiten. <br><br><h4>  Folgen der Abweichung von den Empfehlungen </h4><br>  Der Einsatz verschiedener Technologien in Produktion und Test erfordert die Unterstützung von zwei Entwicklungsmodellen und führt zur Trennung von Teams aus Programmierern und DevOps-Spezialisten. <br><br><h4>  Richtiger Ansatz </h4><br>  Hier ist ein Beispiel für eine CI-Kette, die, wie sie sagen, im laufenden Betrieb einen Kubernetes-Cluster erstellt (dies wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier übernommen</a> ). <br><br><pre> <code class="javascript hljs">deploy: stage: deploy image: registry.gitlab.com/gitlab-examples/kubernetes-deploy script: - ./configureCluster.sh $KUBE_CA_PEM_FILE $KUBE_URL $KUBE_TOKEN - kubectl create ns $NAMESPACE - kubectl create secret -n $NAMESPACE docker-registry gitlab-registry --docker-server=<span class="hljs-string"><span class="hljs-string">"$CI_REGISTRY"</span></span> --docker-username=<span class="hljs-string"><span class="hljs-string">"$CI_REGISTRY_USER"</span></span> --docker-password=<span class="hljs-string"><span class="hljs-string">"$CI_REGISTRY_PASSWORD"</span></span> --docker-email=<span class="hljs-string"><span class="hljs-string">"$GITLAB_USER_EMAIL"</span></span> - mkdir .generated - echo <span class="hljs-string"><span class="hljs-string">"$CI_BUILD_REF_NAME-$CI_BUILD_REF"</span></span> - sed -e <span class="hljs-string"><span class="hljs-string">"s/TAG/$CI_BUILD_REF_NAME-$CI_BUILD_REF/g"</span></span> templates/deals.yaml | tee <span class="hljs-string"><span class="hljs-string">".generated/deals.yaml"</span></span> - kubectl apply --namespace $NAMESPACE -f .generated/deals.yaml - kubectl apply --namespace $NAMESPACE -f templates/my-sock-shop.yaml environment: name: test-<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>-ci</code> </pre> <br><h3>  <font color="#3AC1EF">▍25.</font>  <font color="#3AC1EF">Bemühen Sie sich, die Testausführung zu parallelisieren</font> </h3><br><h4>  Empfehlungen </h4><br>  Wenn das Testsystem gut organisiert ist, wird es 24 Stunden am Tag zu Ihrem treuen Freund, der bereit ist, Probleme mit dem Code zu melden.  Dazu müssen Tests sehr schnell durchgeführt werden.  In der Praxis stellt sich heraus, dass das Ausführen von 500 Unit-Tests im Single-Threaded-Modus, bei denen der Prozessor intensiv genutzt wird, zu lange dauert.  Und solche Tests müssen ziemlich oft durchgeführt werden.  Glücklicherweise können moderne Tools zum Ausführen von Tests ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jest</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AVA</a> , eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterung für Mocha</a> ) und CI-Plattformen Tests mit mehreren Prozessen parallel ausführen, was die Geschwindigkeit des Empfangs von Testberichten erheblich verbessern kann.  Einige CI-Plattformen wissen sogar, wie Tests zwischen Containern parallelisiert werden, was die Rückkopplungsschleife weiter verbessert.  Um die Ausführung lokaler oder entfernter Tests erfolgreich zu parallelisieren, sollten die Tests nicht voneinander abhängig sein.  Standalone-Tests können problemlos in verschiedenen Prozessen ausgeführt werden. <br><br><h4>  Folgen der Abweichung von den Empfehlungen </h4><br>  Das Abrufen von Testergebnissen eine Stunde nach dem Senden des Codes an das Repository während der Arbeit an neuen Projektfunktionen ist eine hervorragende Möglichkeit, den Nutzen von Testergebnissen zu verringern. <br><br><h4>  Richtiger Ansatz </h4><br>  Dank der parallelen Ausführung von Tests umgehen die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mokka-Parallel-Test-</a> Bibliothek und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jest-</a> Framework Mokka leicht ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dies ist die</a> Quelle dieser Informationen). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c5f/aa2/e8e/c5faa2e8ee900ae5d3447d510bc1bf8f.png"></div><br>  <i><font color="#999999">Tools zum Testen der Leistungstests</font></i> <br><br><h3>  <font color="#3AC1EF">▍26.</font>  <font color="#3AC1EF">Schützen Sie sich vor rechtlichen Problemen, indem Sie die Lizenzüberprüfung und die Plagiatscodeüberprüfung verwenden</font> </h3><br><h4>  Empfehlungen </h4><br>  Vielleicht sind Sie jetzt nicht besonders besorgt über Probleme mit dem Gesetz und Plagiate.  Überprüfen Sie Ihr Projekt jedoch auf ähnliche Probleme.  Es stehen viele Tools zur Verfügung, um solche Inspektionen zu organisieren.  Dies sind beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lizenzprüfer</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plagiatsprüfer</a> (dies ist ein kommerzielles Paket, es besteht jedoch die Möglichkeit seiner kostenlosen Verwendung).  Es ist einfach, solche Überprüfungen in die CI-Pipeline zu integrieren und das Projekt beispielsweise auf das Vorhandensein von Abhängigkeiten mit begrenzten Lizenzen oder auf das Vorhandensein von Code zu überprüfen, der von StackOverflow kopiert wurde und möglicherweise die Urheberrechte anderer verletzt. <br><br><h4>  Folgen der Abweichung von den Empfehlungen </h4><br>  Der Entwickler kann das Paket ganz versehentlich mit einer Lizenz verwenden, die für sein Projekt nicht geeignet ist, oder den Handelscode kopieren, was zu rechtlichen Problemen führen kann. <br><br><h4>  Richtiger Ansatz </h4><br>  Installieren Sie das Lizenzprüfungspaket lokal oder in einer CI-Umgebung: <br><br><pre> <code class="javascript hljs">npm install -g license-checker</code> </pre> <br>  Wir werden die Lizenzen damit überprüfen. Wenn er etwas findet, das nicht zu uns passt, erkennen wir die Prüfung als nicht erfolgreich an.  Wenn das CI-System beim Überprüfen der Lizenzen feststellt, dass ein Fehler aufgetreten ist, stoppt es die Projektzusammenstellung. <br><br><pre> <code class="javascript hljs">license-checker --summary --failOn BSD</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/791/cde/326/791cde326f7185df4c78479ef4ab5757.png"></div><br>  <i><font color="#999999">Lizenzprüfung</font></i> <br><br><h3>  <font color="#3AC1EF">▍27.</font>  <font color="#3AC1EF">Überprüfen Sie das Projekt ständig auf anfällige Abhängigkeiten</font> </h3><br><h4>  Empfehlungen </h4><br>  Selbst hoch angesehene und zuverlässige Pakete wie Express weisen Schwachstellen auf.  Um solche Schwachstellen zu identifizieren, können Sie spezielle Tools verwenden - wie das Standardtool zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prüfen von npm-Paketen</a> oder das kommerzielle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">snyk-</a> Projekt mit einer kostenlosen Version.  Diese Überprüfungen können zusammen mit anderen Teil der CI-Pipeline sein. <br><br><h4>  Folgen der Abweichung von den Empfehlungen </h4><br>  Um Ihr Projekt vor Schwachstellen seiner Abhängigkeiten zu schützen, ohne spezielle Tools zu verwenden, müssen Sie Veröffentlichungen über solche Schwachstellen ständig überwachen.  Dies ist eine sehr zeitaufwändige Aufgabe. <br><br><h4>  Richtiger Ansatz </h4><br>  Hier sind die Ergebnisse der Projektüberprüfung mit NPM Audit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d5/da1/3a9/9d5da13a900a066fbc6c15aba2cc0a0d.png"></div><br>  <i><font color="#999999">Paketbericht zur Überprüfung der Sicherheitsanfälligkeit</font></i> <br><br><h3>  <font color="#3AC1EF">▍28.</font>  <font color="#3AC1EF">Automatisieren Sie Abhängigkeitsaktualisierungen</font> </h3><br><h4>  Empfehlungen </h4><br>  Der Weg zur Hölle ist mit guten Absichten gepflastert.  Diese Idee ist vollständig auf die <code>package-lock.json</code> anwendbar, deren Verwendung standardmäßig Paketaktualisierungen blockiert.  Dies geschieht auch in Fällen, in denen Projekte durch die Befehle <code>npm install</code> und <code>npm update</code> in einen fehlerfreien Zustand versetzt werden.  Dies führt entweder bestenfalls zur Verwendung veralteter Pakete oder im schlimmsten Fall zum Auftreten von anfälligem Code im Projekt.  Die Entwicklungsteams verlassen sich daher entweder auf die manuelle Aktualisierung von Informationen über geeignete Versionen von Paketen oder auf Dienstprogramme wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ncu</a> , die wiederum manuell gestartet werden.  Das Aktualisieren von Abhängigkeiten wird am besten automatisiert, wobei der Schwerpunkt auf der Verwendung der zuverlässigsten Versionen der im Projekt verwendeten Pakete liegt.  Dies ist nicht die einzig richtige Lösung. Bei der Automatisierung von Paketaktualisierungen gibt es jedoch einige bemerkenswerte Ansätze.  Die erste besteht darin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> Pakete wie das Überprüfen von Paketen mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">npm-veralteten</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">npm-check-Updates</a> (ncu) in die CI-Pipeline einzufügen.  Dies hilft dabei, veraltete Pakete zu identifizieren und Entwickler zu ermutigen, sie zu aktualisieren.  Der zweite Ansatz besteht darin, kommerzielle Tools zu verwenden, die den Code überprüfen und automatisch Pull-Anforderungen stellen, um Abhängigkeiten zu aktualisieren.  Im Bereich der automatischen Abhängigkeitsaktualisierung stehen wir vor einer weiteren interessanten Frage bezüglich der Aktualisierungsrichtlinie.  Wenn das Update mit jedem neuen Patch aktualisiert wird, wird das System möglicherweise zu stark belastet.  Wenn Sie unmittelbar nach der Veröffentlichung der nächsten Hauptversion des Pakets aktualisieren, kann dies zur Verwendung instabiler Lösungen im Projekt führen (Schwachstellen in vielen Paketen werden bereits in den ersten Tagen nach der Veröffentlichung gefunden, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lesen Sie</a> den Vorfall mit eslint-scope).  Eine gute Paketaktualisierungsrichtlinie kann eine gewisse „Übergangszeit“ vorsehen, wenn die lokale Version nicht unmittelbar nach der Veröffentlichung der nächsten neuen Version, jedoch mit einer gewissen Verzögerung, als veraltet angesehen wird. ,      1.3.1,             1.3.2,      1.3.8. <br><br><h4>     </h4><br>       ,    ,        ,     . <br><br><h4>   </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ncu</a>     ,   ,   ,       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6e/b2a/dcf/e6eb2adcf8720657a4e5c09c34691704.png"></div><br> <i><font color="#999999">   ncu</font></i> <br><br><h3> <font color="#3AC1EF">▍29.        ,     Node.js</font> </h3><br><h4>  Empfehlungen </h4><br>       ,     Node.js-,     ,   Node.js  . <br><br><ol><li>   .     —   , , ,    Jenkins      . </li><li>  ,  Docker. </li><li>       . ,    ,      .    (,    ),       , ,  ,     . </li><li>   ,    ,      ,    .  —   ,    ,   ,      . </li><li>     ,     . ,          feature,    —   master, ,                 (   ). </li><li>        .        ,    . </li><li>     . </li><li>         (,     Docker)  . </li><li>     , ,  ,  . ,        <code>node_modules</code> . </li></ol><br><h4>     </h4><br>      ,     ,     . <br><br><h3> <font color="#3AC1EF">▍30.    </font> </h3><br><h4>  Empfehlungen </h4><br>      ,      .     ,      , ,    Node.js    ,            .  CI-,    ,    « ». ,      ,    ,   . , ,      mySQL,   — Postgres.   ,        Node.js,  — 8, 9  10.          ,     .     CI-. <br><br><h4>     </h4><br>         ,     ,    ,      . ,  ,     . <br><br><h4>   </h4><br>    CI- Travis        Node.js. <br><br><pre> <code class="javascript hljs">language: node_js node_js: - <span class="hljs-string"><span class="hljs-string">"7"</span></span> - <span class="hljs-string"><span class="hljs-string">"6"</span></span> - <span class="hljs-string"><span class="hljs-string">"5"</span></span> - <span class="hljs-string"><span class="hljs-string">"4"</span></span> install: - npm install script: - npm run test</code> </pre> <br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>      ,    ,       . ,   ,     . <br><br>  <b>Liebe Leser!</b>      ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435464/">https://habr.com/ru/post/de435464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435452/index.html">End-to-End-Tests von Microservices mit Catcher</a></li>
<li><a href="../de435454/index.html">AOP vs Funktionen</a></li>
<li><a href="../de435456/index.html">Ist es schädlich, nachts ein Smartphone neben sich zu lassen?</a></li>
<li><a href="../de435460/index.html">Coworkidea Coworking Fototour (Barcelona)</a></li>
<li><a href="../de435462/index.html">Testen von Node.js-Projekten. Teil 1. Testanatomie und Testtypen</a></li>
<li><a href="../de435466/index.html">React Tutorial Teil 6: Einige Funktionen des Kurses, JSX und JavaScript</a></li>
<li><a href="../de435468/index.html">React Tutorial Teil 7: Inline-Stile</a></li>
<li><a href="../de435470/index.html">React Tutorial, Teil 8: Fortsetzung der Arbeit an einer TODO-Anwendung, Einführung in die Komponenteneigenschaften</a></li>
<li><a href="../de435476/index.html">Mkcert: gültige HTTPS-Zertifikate für localhost</a></li>
<li><a href="../de435480/index.html">Microsoft und Kroger werden Amazon einen Kampf auf dem Gebiet geben ... den Handel mit Lebensmitteln</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>