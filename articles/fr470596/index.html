<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßúüèº üç† üë¥üèΩ Caract√©ristiques de Q et KDB + sur l'exemple d'un service en temps r√©el üëÜüèø üö´ üë£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qu'est-ce que KDB +, le langage de programmation Q, quelles sont leurs forces et leurs faiblesses, peut √™tre trouv√© dans mon article pr√©c√©dent et bri√®...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Caract√©ristiques de Q et KDB + sur l'exemple d'un service en temps r√©el</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dbtc/blog/470596/">  Qu'est-ce que KDB +, le langage de programmation Q, quelles sont leurs forces et leurs faiblesses, peut √™tre trouv√© dans mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> pr√©c√©dent et bri√®vement dans l'introduction.  Dans l'article, nous impl√©mentons un service sur Q qui traitera le flux de donn√©es entrant et calculera par minute diverses fonctions d'agr√©gation en mode ¬´temps r√©el¬ª (c'est-√†-dire qu'il parviendra √† tout compter jusqu'√† la prochaine donn√©e).  La principale caract√©ristique de Q est qu'il s'agit d'un langage vectoriel qui vous permet de fonctionner non pas avec des objets uniques, mais avec leurs tableaux, tableaux de tableaux et autres objets complexes.  Des langages tels que Q et ses K, J, APL sont r√©put√©s pour leur bri√®vet√©.  Souvent, un programme qui s'√©tend sur plusieurs √©crans de code dans un langage familier tel que Java peut y √™tre √©crit sur plusieurs lignes.  C'est exactement ce que je veux d√©montrer dans cet article. <br><br><img src="https://habrastorage.org/webt/wb/ej/zy/wbejzyzkg_-aypnh92it6kecrtq.jpeg"><br><a name="habracut"></a><br><h3>  Pr√©sentation </h3><br>  KDB + est une base de donn√©es de colonnes centr√©e sur de tr√®s gros volumes de donn√©es, tri√©es d'une certaine mani√®re (principalement par le temps).  Il est utilis√©, tout d'abord, dans les organisations financi√®res - banques, fonds d'investissement, compagnies d'assurance.  Le langage Q est un langage interne de KDB + qui vous permet de travailler efficacement avec ces donn√©es.  L'id√©ologie de Q est la bri√®vet√© et l'efficacit√©, tandis que la clart√© est sacrifi√©e.  Cela se justifie par le fait que dans tous les cas, le langage vectoriel sera difficile √† percevoir, et la bri√®vet√© et la richesse de l'enregistrement vous permettent de voir une partie beaucoup plus grande du programme sur un seul √©cran, ce qui facilite finalement sa compr√©hension. <br><br>  Dans cet article, nous mettons en ≈ìuvre un programme Q √† part enti√®re et vous voudrez peut-√™tre l'essayer.  Pour ce faire, vous aurez besoin du v√©ritable Q. Vous pouvez t√©l√©charger la version gratuite 32 bits sur le site Web de la soci√©t√© kx - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.kx.com</a> .  Au m√™me endroit, si vous √™tes int√©ress√©, vous trouverez des informations de r√©f√©rence sur Q, le livre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Q For Mortals</a> et divers articles sur ce sujet. <br><br>
<h3>  √ânonc√© du probl√®me </h3><br>  Il existe une source qui envoie une table de donn√©es toutes les 25 millisecondes.  √âtant donn√© que KDB + est principalement utilis√© dans la finance, nous supposons qu'il s'agit d'une table de transactions dans laquelle se trouvent les colonnes suivantes: heure (heure en millisecondes), sym (nom de la soci√©t√© en bourse - <b>IBM</b> , <b>AAPL</b> , ...), prix (prix par lequel les actions ont √©t√© achet√©es), taille (taille de la transaction).  Un intervalle de 25 millisecondes est choisi arbitrairement, il n'est ni trop petit ni trop grand.  Sa pr√©sence signifie que les donn√©es arrivant au service sont d√©j√† tamponn√©es.  Il serait facile d'impl√©menter la mise en m√©moire tampon c√¥t√© service, y compris la mise en m√©moire tampon dynamique, en fonction de la charge actuelle, mais pour plus de simplicit√©, nous nous attardons sur un intervalle fixe. <br><br>  Le service doit consid√©rer par minute pour chaque caract√®re entrant de la colonne sym un ensemble de fonctions d'agr√©gation - prix max, prix moyen, taille de la somme, etc.  informations utiles.  Pour simplifier, nous supposons que toutes les fonctions peuvent √™tre calcul√©es de mani√®re incr√©mentielle, c'est-√†-dire  pour obtenir une nouvelle valeur, il suffit de conna√Ætre deux nombres - l'ancien et la valeur entrante.  Par exemple, les fonctions max, average, sum ont cette propri√©t√©, mais pas la fonction m√©diane. <br><br>  Nous supposons √©galement que le flux de donn√©es entrant est ordonn√© par le temps.  Cela nous donnera l'occasion de travailler uniquement avec la derni√®re minute.  En pratique, il suffit de pouvoir travailler avec les minutes actuelles et pr√©c√©dentes au cas o√π des mises √† jour seraient en retard.  Par souci de simplicit√©, nous ne consid√©rerons pas ce cas. <br><br><h3>  Fonctions d'agr√©gation </h3><br>  Voici les fonctions d'agr√©gation requises.  Je les ai pris le plus possible pour augmenter la charge sur le service: <br><br><ul><li>  haut - prix maximum - prix maximum par minute. </li><li>  low - min price - le prix minimum par minute. </li><li>  firstPrice - premier prix - le premier prix par minute. </li><li>  lastPrice - dernier prix - le dernier prix par minute. </li><li>  firstSize - first size - la taille de la premi√®re offre en une minute. </li><li>  lastSize - last size - la derni√®re taille de transaction en une minute. </li><li>  numTrades - count i - le nombre de transactions par minute. </li><li>  volume - somme taille - somme des tailles de transaction par minute. </li><li>  pvolume - somme prix - la somme des prix par minute, n√©cessaire pour le prix moyen. </li><li>  chiffre d'affaires - prix total * taille - volume total de transactions par minute. </li><li>  avgPrice - pvolume% numTrades - prix moyen par minute. </li><li>  avgSize - volume% numTrades - taille moyenne des transactions par minute. </li><li>  vwap - chiffre d'affaires% volume - le prix moyen par minute pond√©r√© par la taille de la transaction. </li><li>  cumVolume - somme du volume - taille cumul√©e des transactions pendant tout le temps. </li></ul><br>  Discutez imm√©diatement d'un point non √©vident - comment initialiser ces colonnes pour la premi√®re fois et pour chaque minute suivante.  Certaines colonnes du type firstPrice doivent √™tre initialis√©es avec null √† chaque fois, leur valeur n'est pas d√©finie.  Les autres types de volume doivent toujours √™tre d√©finis sur 0. Il y a encore des colonnes qui n√©cessitent une approche combin√©e - par exemple, cumVolume doit √™tre copi√© √† partir de la minute pr√©c√©dente, et pour le premier ensemble sur 0. Nous d√©finirons tous ces param√®tres √† l'aide du dictionnaire de types de donn√©es (analogue de l'enregistrement): <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// list ! list ‚Äì  , 0n ‚Äì float null, 0N ‚Äì long null, `sym ‚Äì  , `sym1`sym2 ‚Äì   initWith:`sym`time`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover`avgPrice`avgSize`vwap`cumVolume!(`;00:00;0n;0n;0n;0n;0N;0N;0;0;0.0;0.0;0n;0n;0n;0); aggCols:reverse key[initWith] except `sym`time; //    , reverse  </span></span></code> </pre> <br>  J'ai ajout√© sym et time au dictionnaire pour plus de commodit√©, maintenant initWith est une ligne finie de la table agr√©g√©e finale, o√π il reste √† d√©finir les sym et time corrects.  Vous pouvez l'utiliser pour ajouter de nouvelles lignes √† la table. <br><br>  aggCols dont nous avons besoin lors de la cr√©ation d'une fonction d'agr√©gation.  La liste doit √™tre invers√©e en raison des particularit√©s de l'ordre dans lequel les expressions sont calcul√©es en Q (de droite √† gauche).  Le but est de fournir un calcul dans la direction de high √† cumVolume, car certaines colonnes d√©pendent des pr√©c√©dentes. <br><br>  Colonnes √† copier √† une nouvelle minute de la pr√©c√©dente, colonne sym ajout√©e pour plus de commodit√©: <br><br><pre> <code class="cpp hljs">rollColumns:`sym`cumVolume;</code> </pre><br>  Maintenant, nous divisons les colonnes en groupes selon la fa√ßon dont elles doivent √™tre mises √† jour.  On peut distinguer trois types: <br><br><ol><li>  Batteries (volume, chiffre d'affaires, ..) - nous devons ajouter la valeur d'entr√©e √† la pr√©c√©dente. </li><li>  Avec un point sp√©cial (haut, bas, ..) - la premi√®re valeur en une minute est prise √† partir des donn√©es d'entr√©e, les autres sont compt√©es √† l'aide de la fonction. </li><li>  Le reste.  Toujours compt√© √† l'aide d'une fonction. </li></ol><br>  D√©finissez des variables pour ces classes: <br><br><pre> <code class="cpp hljs">accumulatorCols:`numTrades`volume`pvolume`turnover; specialCols:`high`low`firstPrice`firstSize;</code> </pre><br><h3>  Ordre de calcul </h3><br>  Nous mettrons √† jour le tableau agr√©g√© en deux √©tapes.  Pour plus d'efficacit√©, nous allons d'abord r√©duire la table entrante afin qu'il ne reste qu'une ligne pour chaque caract√®re et chaque minute.  Le fait que toutes nos fonctions soient incr√©mentales et associatives nous garantit que le r√©sultat de cette √©tape suppl√©mentaire ne changera pas.  Vous pouvez serrer la table en utilisant la s√©lection: <br><br><pre> <code class="cpp hljs">select high:max price, low:min price ‚Ä¶ by sym,time.minute from table</code> </pre><br>  Cette m√©thode a un inconv√©nient - l'ensemble des colonnes calcul√©es est pr√©d√©fini.  Heureusement, dans Q, la s√©lection est √©galement impl√©ment√©e comme une fonction o√π vous pouvez remplacer des arguments cr√©√©s dynamiquement: <br><br><pre> <code class="cpp hljs">?[table;whereClause;byClause;selectClause]</code> </pre><br>  Je ne d√©crirai pas en d√©tail le format des arguments, dans notre cas, seules les expressions by et select sont non triviales et doivent √™tre des dictionnaires des colonnes du formulaire! Expressions.  Ainsi, la fonction de restriction peut √™tre d√©finie comme suit: <br><br><pre> <code class="cpp hljs">selExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover!<span class="hljs-function"><span class="hljs-function">parse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"max price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"min price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"first price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"last price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"first size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"last size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"count i"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum price*size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// each   map  Q    preprocess:?[;();`sym`time!`sym`time.minute;selExpression];</span></span></code> </pre><br>  Pour plus de clart√©, j'ai utilis√© la fonction d'analyse, qui transforme une cha√Æne avec une expression Q en une valeur qui peut √™tre transmise √† la fonction eval et qui est requise dans la fonction select.  Notez √©galement que le pr√©traitement est d√©fini comme une projection (c'est-√†-dire une fonction avec des arguments partiellement d√©finis) de la fonction de s√©lection, un argument (table) est manquant.  Si nous appliquons un pr√©traitement √† une table, nous obtenons une table r√©duite. <br><br>  La deuxi√®me √©tape consiste √† mettre √† jour la table agr√©g√©e.  Tout d'abord, nous √©crivons l'algorithme en pseudocode: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each sym in inputTable idx: row index in agg table <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sym+currentTime; aggTable[idx;`high]: aggTable[idx;`high] | inputTable[sym;`high]; aggTable[idx;`volume]: aggTable[idx;`volume] + inputTable[sym;`volume]; ‚Ä¶</code> </pre><br>  Dans Q, au lieu de boucles, il est habituel d'utiliser des fonctions de cartographie / r√©duction.  Mais comme Q est un langage vectoriel et que toutes les op√©rations peuvent √™tre appliqu√©es en toute s√©curit√© √† tous les symboles √† la fois, alors en premi√®re approximation, nous pouvons nous passer d'un cycle, en effectuant des op√©rations avec tous les symboles √† la fois: <br><br><pre> <code class="cpp hljs">idx:calcIdx inputTable; row:aggTable idx; aggTable[idx;`high]: row[`high] | inputTable`high; aggTable[idx;`volume]: row[`volume] + inputTable`volume; ‚Ä¶</code> </pre><br>  Mais nous pouvons aller plus loin, dans Q il y a un op√©rateur unique et extr√™mement puissant - l'op√©rateur d'affectation g√©n√©ralis√©.  Il vous permet de modifier l'ensemble de valeurs dans une structure de donn√©es complexe √† l'aide d'une liste d'index, de fonctions et d'arguments.  Dans notre cas, cela ressemble √† ceci: <br><br><pre> <code class="cpp hljs">idx:calcIdx inputTable; rows:aggTable idx; <span class="hljs-comment"><span class="hljs-comment">// .[target;(idx0;idx1;..);function;argument] ~ target[idx 0;idx 1;‚Ä¶]: function[target[idx 0;idx 1;‚Ä¶];argument],     ‚Äì   .[aggTable;(idx;aggCols);:;flip (row[`high] | inputTable`high;row[`volume] + inputTable`volume;‚Ä¶)];</span></span></code> </pre><br>  Malheureusement, pour affecter √† une table, vous avez besoin d'une liste de lignes, pas de colonnes, et vous devez transposer la matrice (liste de colonnes en une liste de lignes) √† l'aide de la fonction flip.  Pour une grande table, cela n'est pas n√©cessaire, donc nous appliquons √† la place l'affectation g√©n√©ralis√©e √† chaque colonne s√©par√©ment, en utilisant la fonction de carte (qui ressemble √† une apostrophe): <br><br><pre> <code class="sql hljs">.[aggTable;;:;]'[(idx;)each aggCols; (row[`high] | inputTable`high;row[`volume] + inputTable`volume;‚Ä¶)];</code> </pre><br>  Nous utilisons √† nouveau la fonction de projection.  Notez √©galement que dans Q, la cr√©ation d'une liste est √©galement une fonction et nous pouvons l'appeler en utilisant la fonction each (map) pour obtenir une liste de listes. <br><br>  Pour que l'ensemble des colonnes calcul√©es ne soit pas fixe, cr√©ez dynamiquement l'expression ci-dessus.  Tout d'abord, nous d√©finissons les fonctions de calcul de chaque colonne, en utilisant les variables ligne et inp pour r√©f√©rencer les donn√©es agr√©g√©es et d'entr√©e: <br><br><pre> <code class="cpp hljs">aggExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`avgPrice`avgSize`vwap`cumVolume! (<span class="hljs-string"><span class="hljs-string">"row[`high]|inp`high"</span></span>;<span class="hljs-string"><span class="hljs-string">"row[`low]&amp;inp`low"</span></span>;<span class="hljs-string"><span class="hljs-string">"row`firstPrice"</span></span>;<span class="hljs-string"><span class="hljs-string">"inp`lastPrice"</span></span>;<span class="hljs-string"><span class="hljs-string">"row`firstSize"</span></span>;<span class="hljs-string"><span class="hljs-string">"inp`lastSize"</span></span>;<span class="hljs-string"><span class="hljs-string">"pvolume%numTrades"</span></span>;<span class="hljs-string"><span class="hljs-string">"volume%numTrades"</span></span>;<span class="hljs-string"><span class="hljs-string">"turnover%volume"</span></span>;<span class="hljs-string"><span class="hljs-string">"row[`cumVolume]+inp`volume"</span></span>);</code> </pre><br>  Certaines colonnes sont sp√©ciales, leur premi√®re valeur ne doit pas √™tre calcul√©e par une fonction.  Nous pouvons d√©terminer qu'il est le premier de la ligne de colonne [`numTrades] - s'il a 0, alors la valeur est la premi√®re.  Q a une fonction de s√©lection -? [Liste bool√©enne; liste1; liste2] - qui s√©lectionne une valeur dans la liste 1 ou 2 selon la condition du premier argument: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// high -&gt; ?[isFirst;inp`high;row[`high]|inp`high] // @ -         @[`aggExpression;specialCols;{[x;y]"?[isFirst;inp`",y,";",x,"]"};string specialCols];</span></span></code> </pre><br>  Ici, j'ai appel√© une affectation g√©n√©rique avec ma fonction (expression entre accolades).  La valeur actuelle (le premier argument) et un argument suppl√©mentaire, que je passe dans le 4√®me param√®tre, lui sont pass√©s. <br><br>  S√©par√©ment, nous ajoutons des haut-parleurs √† batterie, car pour eux la fonction est la m√™me: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// volume -&gt; row[`volume]+inp`volume aggExpression[accumulatorCols]:{"row[`",x,"]+inp`",x } each string accumulatorCols;</span></span></code> </pre><br>  Il s'agit d'une affectation habituelle selon les normes de Q, je n'attribue qu'une liste de valeurs √† la fois.  Enfin, cr√©ez la fonction principale: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ":",/:aggExprs ~ map[{":",x};aggExpr] =&gt; ":row[`high]|inp`high"    ,          // string[cols],'exprs ~ map[,;string[cols];exprs] =&gt; "high:row[`high]|inp`high"   . ,'   map[concat] // ";" sv exprs ‚Äì String from Vector (sv),     ‚Äú;‚Äù  updateAgg:value "{[aggTable;idx;inp] row:aggTable idx; isFirst:0=row`numTrades; .[aggTable;;:;]'[(idx;)each aggCols;(",(";"sv string[aggCols],'":",/:aggExpression aggCols),")]}";</span></span></code> </pre><br>  Avec cette expression, je cr√©e dynamiquement une fonction √† partir d'une cha√Æne qui contient l'expression que j'ai cit√©e ci-dessus.  Le r√©sultat ressemblera √† ceci: <br><br><pre> <code class="sql hljs">{[aggTable;idx;inp] rows:aggTable idx; isFirst:0=row`numTrades; .[aggTable;;:;]'[(idx;)each aggCols ;(cumVolume:row[`cumVolume]+inp`cumVolume;‚Ä¶ ; high:?[isFirst;inp`high;row[`high]|inp`high])]}</code> </pre><br>  L'ordre de calcul des colonnes est invers√©, car dans Q l'ordre de calcul est de droite √† gauche. <br><br>  Maintenant, nous avons deux fonctions principales n√©cessaires pour les calculs, il reste √† ajouter un peu d'infrastructure et le service est pr√™t. <br><br><h3>  √âtapes finales </h3><br>  Nous avons des fonctions de pr√©traitement et de mise √† jour qui font tout le travail.  Mais il reste n√©cessaire d'assurer la transition correcte en quelques minutes et de calculer les indices d'agr√©gation.  Nous d√©finissons d'abord la fonction init: <br><br><pre> <code class="cpp hljs">init:{ tradeAgg:: <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-meta"><span class="hljs-meta">#enlist[initWith]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    , enlist    ,  0#   0    currTime::00:00; //   0, :: ,      currSyms::`u#`symbol$(); // `u# -    ,     offset::0; //   tradeAgg,     rollCache:: `sym xkey update `u#sym from rollColumns#tradeAgg; //     roll ,    sym }</span></span></span></span></code> </pre><br>  Nous d√©finissons √©galement la fonction roll, qui changera la minute courante: <br><br><pre> <code class="cpp hljs">roll:{[tm] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>[currTime&gt;tm; :init[]]; <span class="hljs-comment"><span class="hljs-comment">//    ,    init rollCache,::offset _ rollColumns#tradeAgg; //   ‚Äì  roll   aggTable, ,   rollCache offset::count tradeAgg; currSyms::`u#`$(); }</span></span></code> </pre><br>  Nous avons besoin d'une fonction pour ajouter de nouveaux personnages: <br><br><pre> <code class="java hljs">addSyms:{[syms] currSyms,::syms; <span class="hljs-comment"><span class="hljs-comment">//     //    sym, time  rollColumns   . //  ^      roll ,     . value flip table     . `tradeAgg upsert @[count[syms]#enlist initWith;`sym`time,cols rc;:;(syms;currTime), (initWith cols rc)^value flip rc:rollCache ([] sym: syms)]; }</span></span></code> </pre><br>  Et enfin, la fonction upd (le nom traditionnel de cette fonction pour les services Q), qui est appel√©e par le client, pour ajouter des donn√©es: <br><br><pre> <code class="cpp hljs">upd:{[tblName;data] <span class="hljs-comment"><span class="hljs-comment">// tblName   ,       tm:exec distinct time from data:() xkey preprocess data; // preprocess &amp; calc time updMinute[data] each tm; //      }; updMinute:{[data;tm] if[tm&lt;&gt;currTime; roll tm; currTime::tm]; //  ,   data:select from data where time=tm; //  if[count msyms:syms where not (syms:data`sym)in currSyms; addSyms msyms]; //   updateAgg[`tradeAgg;offset+currSyms?syms;data]; //   .  ?        . };</span></span></code> </pre><br>  C‚Äôest tout.  Voici le code complet de notre service, comme promis, en quelques lignes: <br><br><pre> <code class="cpp hljs">initWith:`sym`time`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover`avgPrice`avgSize`vwap`cumVolume!(`;<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>N;<span class="hljs-number"><span class="hljs-number">0</span></span>N;<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-number"><span class="hljs-number">0.0</span></span>;<span class="hljs-number"><span class="hljs-number">0.0</span></span>;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>); aggCols:reverse key[initWith] except `sym`time; rollColumns:`sym`cumVolume; accumulatorCols:`numTrades`volume`pvolume`turnover; specialCols:`high`low`firstPrice`firstSize; selExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover!<span class="hljs-function"><span class="hljs-function">parse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"max price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"min price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"first price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"last price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"first size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"last size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"count i"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum price*size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; preprocess:?[;();`sym`time!`sym`time.minute;selExpression]; aggExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`avgPrice`avgSize`vwap`cumVolume!(<span class="hljs-string"><span class="hljs-string">"row[`high]|inp`high"</span></span>;<span class="hljs-string"><span class="hljs-string">"row[`low]&amp;inp`low"</span></span>;<span class="hljs-string"><span class="hljs-string">"row`firstPrice"</span></span>;<span class="hljs-string"><span class="hljs-string">"inp`lastPrice"</span></span>;<span class="hljs-string"><span class="hljs-string">"row`firstSize"</span></span>;<span class="hljs-string"><span class="hljs-string">"inp`lastSize"</span></span>;<span class="hljs-string"><span class="hljs-string">"pvolume%numTrades"</span></span>;<span class="hljs-string"><span class="hljs-string">"volume%numTrades"</span></span>;<span class="hljs-string"><span class="hljs-string">"turnover%volume"</span></span>;<span class="hljs-string"><span class="hljs-string">"row[`cumVolume]+inp`volume"</span></span>); @[`aggExpression;specialCols;{<span class="hljs-string"><span class="hljs-string">"?[isFirst;inp`"</span></span>,y,<span class="hljs-string"><span class="hljs-string">";"</span></span>,x,<span class="hljs-string"><span class="hljs-string">"]"</span></span>};<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> specialCols]; aggExpression[accumulatorCols]:{<span class="hljs-string"><span class="hljs-string">"row[`"</span></span>,x,<span class="hljs-string"><span class="hljs-string">"]+inp`"</span></span>,x } each <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> accumulatorCols; updateAgg:value <span class="hljs-string"><span class="hljs-string">"{[aggTable;idx;inp] row:aggTable idx; isFirst:0=row`numTrades; .[aggTable;;:;]'[(idx;)each aggCols;("</span></span>,(<span class="hljs-string"><span class="hljs-string">";"</span></span>sv <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[aggCols],<span class="hljs-string"><span class="hljs-string">'":",/:aggExpression aggCols),")]}"; / '</span></span> init:{ tradeAgg::<span class="hljs-number"><span class="hljs-number">0</span></span>#enlist[initWith]; currTime::<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>; currSyms::`u#`symbol$(); offset::<span class="hljs-number"><span class="hljs-number">0</span></span>; rollCache:: `sym xkey update `u#sym from rollColumns#tradeAgg; }; roll:{[tm] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>[currTime&gt;tm; :init[]]; rollCache,::offset _ rollColumns#tradeAgg; offset::count tradeAgg; currSyms::`u#`$(); }; addSyms:{[syms] currSyms,::syms; `tradeAgg upsert @[count[syms]#enlist initWith;`sym`time,cols rc;:;(syms;currTime),(initWith cols rc)^value flip rc:rollCache ([] sym: syms)]; }; upd:{[tblName;data] updMinute[data] each exec distinct time from data:() xkey preprocess data}; updMinute:{[data;tm] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>[tm&lt;&gt;currTime; roll tm; currTime::tm]; data:select from data where time=tm; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>[count msyms:syms where <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> (syms:data`sym)in currSyms; addSyms msyms]; updateAgg[`tradeAgg;offset+currSyms?syms;data]; };</code> </pre><br><h3>  Test </h3><br>  V√©rifiez les performances du service.  Pour ce faire, ex√©cutez-le dans un processus distinct (placez le code dans le fichier service.q) et appelez la fonction init: <br><br><pre> <code class="plaintext hljs">q service.q ‚Äìp 5566 q)init[]</code> </pre><br>  Dans une autre console, d√©marrez le deuxi√®me processus Q et connectez-vous au premier: <br><br><pre> <code class="cpp hljs">h:hopen `:host:<span class="hljs-number"><span class="hljs-number">5566</span></span> h:hopen <span class="hljs-number"><span class="hljs-number">5566</span></span> <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre><br>  Tout d'abord, cr√©ez une liste de caract√®res - 10 000 pi√®ces et ajoutez une fonction pour cr√©er une table al√©atoire.  Dans la deuxi√®me console: <br><br><pre> <code class="cpp hljs">syms:`IBM`AAPL`GOOG,<span class="hljs-number"><span class="hljs-number">-9997</span></span>?`<span class="hljs-number"><span class="hljs-number">8</span></span> rnd:{[n;t] ([] sym:n?syms; time:t+asc n#til <span class="hljs-number"><span class="hljs-number">25</span></span>; price:n?<span class="hljs-number"><span class="hljs-number">10f</span></span>; size:n?<span class="hljs-number"><span class="hljs-number">10</span></span>)}</code> </pre><br>  J'ai ajout√© trois vrais personnages √† la liste des personnages pour le rendre plus pratique √† rechercher dans le tableau.  La fonction rnd cr√©e une table al√©atoire avec n lignes, o√π le temps varie de t √† t + 25 millisecondes. <br><br>  Vous pouvez maintenant essayer d'envoyer des donn√©es au service (ajoutez les dix premi√®res heures): <br><br><pre> <code class="cpp hljs">{h (`upd;`trade;rnd[<span class="hljs-number"><span class="hljs-number">10000</span></span>;x])} each `time$<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span> + til <span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  Vous pouvez v√©rifier dans le service que la table a √©t√© mise √† jour: <br><br><pre> <code class="cpp hljs">\c <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> select from tradeAgg where sym=`AAPL <span class="hljs-number"><span class="hljs-number">-20</span></span>#select from tradeAgg where sym=`AAPL</code> </pre><br>  R√©sultat: <br><br><pre> <code class="1c hljs">sym<span class="hljs-string"><span class="hljs-string">|time|high|low|firstPrice|lastPrice|firstSize|lastSize|numTrades|volume|pvolume|turnover|avgPrice|avgSize|vwap|cumVolume --|--|--|--|--|-------------------------------- AAPL|09:27|9.258904|9.258904|9.258904|9.258904|8|8|1|8|9.258904|74.07123|9.258904|8|9.258904|2888 AAPL|09:28|9.068162|9.068162|9.068162|9.068162|7|7|1|7|9.068162|63.47713|9.068162|7|9.068162|2895 AAPL|09:31|4.680449|0.2011121|1.620827|0.2011121|1|5|4|14|9.569556|36.84342|2.392389|3.5|2.631673|2909 AAPL|09:33|2.812535|2.812535|2.812535|2.812535|6|6|1|6|2.812535|16.87521|2.812535|6|2.812535|2915 AAPL|09:34|5.099025|5.099025|5.099025|5.099025|4|4|1|4|5.099025|20.3961|5.099025|4|5.099025|2919</span></span></code> </pre> <br>  Nous allons maintenant effectuer des tests de charge pour d√©terminer la quantit√© de donn√©es que le service peut traiter par minute.  Permettez-moi de vous rappeler que nous avons d√©fini l'intervalle de mise √† jour √† 25 millisecondes.  Par cons√©quent, un service devrait (en moyenne) tenir dans au moins 20 millisecondes par mise √† jour pour donner aux utilisateurs le temps de demander des donn√©es.  Saisissez les informations suivantes dans le deuxi√®me processus: <br><br><pre> <code class="cpp hljs">tm:<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.000</span></span> stressTest:{[n] <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[tm],<span class="hljs-string"><span class="hljs-string">" "</span></span>; times,::h ({st:.zT; upd[`trade;x]; .zT-st};rnd[n;tm]); tm+:<span class="hljs-number"><span class="hljs-number">25</span></span>} start:{[n] times::(); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>[<span class="hljs-number"><span class="hljs-number">4800</span></span>;stressTest[n]]; <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-string"><span class="hljs-string">" "</span></span>; `min`avg`med`max!(min times;avg times;med times;max times)}</code> </pre><br>  4800 est deux minutes.  Vous pouvez essayer de commencer en premier pour 1000 lignes toutes les 25 millisecondes: <br><br><pre> <code class="cpp hljs">start <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre><br>  Dans mon cas, le r√©sultat est d'environ deux millisecondes par mise √† jour.  Je vais donc imm√©diatement augmenter le nombre de lignes √† 10 000: <br><br><pre> <code class="cpp hljs">start <span class="hljs-number"><span class="hljs-number">10000</span></span></code> </pre><br>  R√©sultat: <br><br><pre> <code class="cpp hljs">min| <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.004</span></span> avg| <span class="hljs-number"><span class="hljs-number">9.191458</span></span> med| <span class="hljs-number"><span class="hljs-number">9f</span></span> max| <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.030</span></span></code> </pre><br>  Encore une fois, rien de sp√©cial, mais c'est 24 millions de lignes par minute, 400 000 par seconde.  Pendant plus de 25 millisecondes, la mise √† jour n'a ralenti que 5 fois, apparemment lors du changement de minute.  Augmentation √† 100 000: <br><br><pre> <code class="cpp hljs">start <span class="hljs-number"><span class="hljs-number">100000</span></span></code> </pre><br>  R√©sultat: <br><br><pre> <code class="cpp hljs">min| <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.013</span></span> avg| <span class="hljs-number"><span class="hljs-number">25.11083</span></span> med| <span class="hljs-number"><span class="hljs-number">24f</span></span> max| <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.108</span></span> q)sum times <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">02</span></span>:<span class="hljs-number"><span class="hljs-number">00.532</span></span></code> </pre><br>  Comme vous pouvez le voir, le service fait √† peine face, mais il parvient n√©anmoins √† rester √† flot.  Cette quantit√© de donn√©es (240 millions de lignes par minute) est extr√™mement importante, dans de tels cas, il est habituel d'ex√©cuter plusieurs clones (voire des dizaines de clones) du service, chacun ne traitant qu'une partie des caract√®res.  N√©anmoins, le r√©sultat est impressionnant pour le langage interpr√©t√©, qui se concentre principalement sur le stockage de donn√©es. <br><br>  La question peut se poser, pourquoi le temps augmente de fa√ßon non lin√©aire avec la taille de chaque mise √† jour.  La raison en est que la fonction de compression est en fait une fonction C qui fonctionne beaucoup plus efficacement que updateAgg.  √Ä partir d'une certaine taille de mise √† jour (environ 10 000), updateAgg atteint son plafond, puis son temps d'ex√©cution ne d√©pend pas de la taille de la mise √† jour.  C'est gr√¢ce √† l'√©tape pr√©liminaire Q que le service est capable de dig√©rer de tels volumes de donn√©es.  Cela souligne combien il est important lorsque vous travaillez avec des m√©gadonn√©es de choisir le bon algorithme.  Un autre point est le stockage correct des donn√©es en m√©moire.  Si les donn√©es n'√©taient pas stock√©es dans des colonnes ou n'√©taient pas tri√©es dans le temps, nous nous familiariserions avec une chose telle que le cache TLB manqu√© - l'absence d'une adresse de page de m√©moire dans le cache d'adresse du processeur.  La recherche de l'adresse prend environ 30 fois plus de temps en cas d'√©chec et dans le cas de donn√©es dispers√©es peut ralentir le service plusieurs fois. <br><br><h3>  Conclusion </h3><br>  Dans cet article, j'ai montr√© que les bases de donn√©es KDB + et Q conviennent non seulement pour stocker des donn√©es volumineuses et un acc√®s facile √† celles-ci via select, mais √©galement pour cr√©er des services de traitement des donn√©es qui peuvent dig√©rer des centaines de millions de lignes / gigaoctets de donn√©es m√™me en un seul processus Q .  Le langage Q lui-m√™me permet de mettre en ≈ìuvre extr√™mement bri√®vement et efficacement des algorithmes li√©s au traitement des donn√©es en raison de sa nature vectorielle, de l'interpr√©teur int√©gr√© du dialecte SQL et d'un ensemble tr√®s r√©ussi de fonctions de biblioth√®que. <br><br>  Je remarquerai que ce qui pr√©c√®de n'est qu'une partie des capacit√©s de Q, il a d'autres caract√©ristiques uniques.  Par exemple, un protocole IPC extr√™mement simple qui efface la fronti√®re entre les processus Q individuels et vous permet de combiner des centaines de ces processus en un seul r√©seau, qui peut √™tre situ√© sur des dizaines de serveurs dans diff√©rentes parties du monde. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr470596/">https://habr.com/ru/post/fr470596/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr470576/index.html">Les banques d'Am√©rique vont supprimer 200 000 emplois au cours des prochaines ann√©es</a></li>
<li><a href="../fr470578/index.html">Comment nous avons ¬´humanis√©¬ª la comptabilit√© dans une banque mobile</a></li>
<li><a href="../fr470584/index.html">V√©rifiez l'interface utilisateur Telerik pour UWP pour vous familiariser avec PVS-Studio</a></li>
<li><a href="../fr470592/index.html">Revue Plesk - Panneaux de contr√¥le d'h√©bergement et de site</a></li>
<li><a href="../fr470594/index.html">Reportage du spectacle de lumi√®re ¬´Circle of Light¬ª 2019 √† Moscou</a></li>
<li><a href="../fr470598/index.html">Le livre "Java moderne. Expressions Lambda, flux et programmation fonctionnelle ¬ª</a></li>
<li><a href="../fr470600/index.html">√Ä propos des consoles noVNC s√©curis√©es, de la mise √† l'√©chelle automatique dans Kubernetes, de Haproxy dans Ostrovka et du travail des administrateurs avec les programmeurs</a></li>
<li><a href="../fr470602/index.html">√Ä quoi ressemblerait le m√©tro de Moscou dans un monde en trois dimensions</a></li>
<li><a href="../fr470604/index.html">Vitesse de chargement des sites dans le commerce √©lectronique: analyse des 48 meilleurs magasins en ligne en Russie</a></li>
<li><a href="../fr470608/index.html">Optimisation de l'interface utilisateur Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>