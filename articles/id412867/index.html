<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤭 🥧 🚯 Cara mengompilasi file DOS COM oleh kompiler GCC 🎪 💚 🍇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel diterbitkan 9 Desember 2014 
 Pembaruan untuk 2018: RenéRebe membuat video yang menarik berdasarkan artikel ini ( bagian 2 ) 

 Akhir pekan la...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara mengompilasi file DOS COM oleh kompiler GCC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412867/"> <font color="gray">Artikel diterbitkan 9 Desember 2014</font> <br>  <i>Pembaruan untuk 2018: RenéRebe membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video yang menarik</a> berdasarkan artikel ini ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 2</a> )</i> <br><br>  Akhir pekan lalu saya berpartisipasi dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ludum Dare # 31</a> .  Tetapi bahkan sebelum konferensi diumumkan, karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hobi terakhir</a> saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> saya ingin membuat game jadul di bawah DOS.  Platform target adalah DOSBox.  Ini adalah cara paling praktis untuk menjalankan aplikasi DOS, terlepas dari kenyataan bahwa semua prosesor x86 modern sepenuhnya kompatibel dengan yang lama, hingga 8086 16-bit. <br><br>  Saya berhasil membuat dan menunjukkan game <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DOS Defender</a> di konferensi.  Program ini bekerja dalam mode nyata dari 80386 32-bit. Semua sumber daya dibangun ke dalam file COM yang dapat dieksekusi, tidak ada dependensi eksternal, sehingga seluruh game dikemas dalam biner 10 kilobyte. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/skeeto/dosdefender-ld31</a> </li><li>  <a href="">DOSDEF.COM</a> (10 KB, v1.1.0, berfungsi di DOSBox) </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ay/na/qs/aynaqsaenvt32x5oa8y7z4fmnfy.gif"></div><a name="habracut"></a><br>  Anda membutuhkan joystick atau gamepad untuk bermain.  Saya menyertakan dukungan mouse dalam rilis untuk Ludum Dare demi presentasi, tetapi kemudian menghapusnya karena itu tidak berfungsi dengan baik. <br><br>  Bagian yang paling menarik secara teknis adalah <b><i>tidak ada</i> alat pengembangan DOS yang diperlukan untuk membuat gim</b> !  Saya hanya menggunakan kompiler Linux C biasa (gcc).  Pada kenyataannya, Anda bahkan tidak dapat membuat Defender DOS untuk DOS.  Saya melihat DOS hanya sebagai platform tertanam, yang merupakan satu-satunya bentuk di mana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DOS masih ada sampai sekarang</a> .  Bersama dengan DOSBox dan DOSEMU, ini adalah seperangkat alat yang cukup nyaman. <br><br>  Jika Anda hanya tertarik pada bagian praktis dari pengembangan, buka bagian "Cheat on GCC", di mana kami akan menulis program DOS COM "Hello, World" dengan GCC Linux. <br><br><h1>  Menemukan alat yang tepat </h1><br>  Ketika saya memulai proyek ini, saya tidak memikirkan GCC.  Pada kenyataannya, saya pergi dengan cara ini ketika saya menemukan paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bcc</a> (Bruce's C Compiler) untuk Debian, yang mengumpulkan binari 16-bit untuk 8086. Itu diadakan untuk mengkompilasi boot loader x86 dan hal-hal lain, tetapi bcc juga dapat digunakan untuk mengkompilasi file DOS COM.  Itu membuat saya tertarik. <br><br>  Untuk referensi: Intel 8086 mikroprosesor 16-bit dirilis pada tahun 1978.  Itu tidak memiliki fitur aneh prosesor modern: tidak ada perlindungan memori, tidak ada instruksi floating point, dan hanya 1 MB RAM addressable.  Semua desktop dan laptop x86 modern masih dapat berpura-pura menjadi prosesor 16-bit 8086 ini empat puluh tahun yang lalu, dengan pengalamatan terbatas yang sama dan semua itu.  Ini adalah kompatibilitas yang terbelakang.  Fungsi seperti ini disebut <i>mode nyata</i> .  Ini adalah mode di mana semua komputer x86 boot.  OS modern segera beralih ke <i>mode terlindungi</i> dengan pengalamatan virtual dan multitasking yang aman.  DOS tidak melakukan itu. <br><br>  Sayangnya, bcc bukan kompiler ANSI C. Ini mendukung subset K&amp;R C, serta kode assembler x86 bawaan.  Tidak seperti kompiler 8086 C lainnya, ia tidak memiliki konsep pointer “jauh” atau “panjang”, sehingga kode assembler internal diperlukan untuk mengakses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">segmen memori lain</a> (VGA, jam, dll.).  Catatan: sisa-sisa "long pointer" 8086 ini masih tersimpan di Win32 API: <code>LPSTR</code> , <code>LPWORD</code> , <code>LPDWORD</code> , dll. Assembler built-in itu bahkan tidak sebanding dengan GCC assembler built-in.  Dalam assembler, Anda perlu memuat variabel secara manual dari tumpukan, dan karena bcc mendukung dua konvensi pemanggilan yang berbeda, variabel dalam kode harus dikodekan secara keras sesuai dengan satu atau beberapa konvensi lainnya. <br><br>  Mengingat keterbatasan ini, saya memutuskan untuk mencari alternatif. <br><br><h1>  DJGPP </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DJGPP</a> - GCC port di bawah DOS.  Sebuah proyek yang sangat mengesankan yang mentransfer hampir seluruh POSIX di bawah DOS.  Banyak program port-DOS yang dibuat di DJGPP.  Tapi dia hanya membuat program 32-bit untuk mode terproteksi.  Jika dalam mode terproteksi Anda perlu bekerja dengan perangkat keras (misalnya, VGA), program membuat permintaan ke layanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antarmuka mode terproteksi DOS</a> (DPMI).  Jika saya menggunakan DJGPP, saya tidak dapat membatasi diri saya pada satu biner mandiri, karena saya harus memiliki server DPMI.  Kinerja juga menderita dari permintaan untuk DPMI. <br><br>  Mendapatkan alat yang diperlukan untuk DJGPP itu sulit, untuk sedikitnya.  Untungnya, saya menemukan proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">build-djgpp yang</a> berguna yang menjalankan semuanya, setidaknya di Linux. <br><br>  Entah ada kesalahan serius, atau binari DJGPP resmi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terinfeksi virus lagi</a> , tetapi ketika saya memulai program saya di DOSBox, kesalahan "Bukan COFF: periksa virus" terus muncul.  Untuk memverifikasi lebih lanjut bahwa virus tidak ada di komputer saya sendiri, saya mengatur lingkungan DJGPP pada Raspberry Pi saya, yang bertindak sebagai ruang bersih.  Perangkat berbasis ARM ini tidak dapat terinfeksi virus x86.  Dan masih ada masalah yang sama muncul, dan semua hash biner adalah sama antara mesin, jadi itu bukan salahku. <br><br>  Jadi mengingat ini dan masalah DPMI, saya mulai mencari lebih jauh. <br><br><h1>  Menipu gcc </h1><br>  Apa yang akhirnya saya setujui adalah trik rumit “menipu” GCC untuk membuat file DOS COM dalam mode nyata.  Triknya berfungsi hingga 80386 (yang biasanya Anda butuhkan).  Prosesor 80386 diluncurkan pada tahun 1985 dan menjadi mikroprosesor x86 32-bit pertama.  GCC masih mematuhi set instruksi ini, bahkan pada lingkungan x86-64.  Sayangnya, GCC tidak dapat menghasilkan kode 16-bit dengan cara apa pun, jadi saya harus mengabaikan tujuan awal pembuatan game untuk 8086.  Namun, ini tidak masalah, karena platform target DOSBox pada dasarnya adalah sebuah emulator 80386. <br><br>  Secara teori, triknya juga harus bekerja di kompiler MinGW, tetapi ada kesalahan lama yang mencegahnya bekerja dengan benar ("tidak dapat melakukan operasi PE pada file keluaran non PE").  Namun, Anda dapat mengatasinya, dan saya melakukannya sendiri: Anda harus menghapus arahan <code>OUTPUT_FORMAT</code> dan menambahkan langkah <code>objcopy</code> tambahan ( <code>objcopy -O binary</code> ). <br><br><h3>  Halo Dunia di DOS </h3><br>  Untuk demonstrasi, kami akan membuat program DOS COM "Hello, World" menggunakan GCC di Linux. <br><br>  Ada kendala utama dan signifikan dalam metode ini: <b>tidak akan ada perpustakaan standar</b> .  Ini seperti menulis sistem operasi dari awal, dengan pengecualian beberapa layanan yang disediakan DOS.  Itu berarti tidak ada <code>printf()</code> atau sejenisnya.  Sebagai gantinya, kami meminta DOS untuk mencetak string ke konsol.  Membuat permintaan DOS membutuhkan interupsi, yang berarti kode assembler inline! <br><br>  DOS memiliki sembilan interupsi: 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x2F.  Hal terpenting yang menarik minat kami adalah 0x21, fungsi 0x09 (cetak satu baris).  Antara DOS dan BIOS, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ribuan fungsi yang dinamai pola ini</a> .  Saya tidak akan mencoba menjelaskan assembler x86, tetapi singkatnya nomor fungsi macet di register <code>ah</code> - dan kebakaran interupsi 0x21.  Fungsi 0x09 juga mengambil argumen - pointer ke garis untuk dicetak, yang dilewatkan dalam register <code>dx</code> dan <code>ds</code> . <br><br>  Berikut adalah fungsi <code>print()</code> dari assembler inline GCC.  Baris yang diteruskan ke fungsi ini harus diakhiri dengan $ karakter.  Mengapa  Karena DOS. <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mov $0x09, %%ah\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"int $0x21\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* no output */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"d"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">) : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ah"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; }</code> </pre> <br>  Kode dinyatakan tidak <code>volatile</code> karena memiliki efek samping (cetak garis).  Untuk GCC, kode assembler buram, dan pengoptimal bergantung pada batasan output / input / clobber (tiga baris terakhir).  Untuk program DOS semacam itu, assembler bawaan apa pun akan memiliki efek samping.  Ini karena ini ditulis bukan untuk optimasi, tetapi untuk akses ke sumber daya perangkat keras dan DOS - hal-hal yang tidak dapat diakses oleh C. sederhana <br><br>  Anda juga harus menjaga pernyataan panggilan, karena GCC tidak tahu bahwa memori yang ditunjukkan oleh <code>string</code> pernah dibaca.  Kemungkinan array yang mendukung string juga harus dinyatakan <code>volatile</code> .  Semua ini menandakan hal yang tak terhindarkan: tindakan apa pun dalam lingkungan seperti itu berubah menjadi perjuangan tanpa akhir dengan pengoptimal.  Tidak semua pertempuran ini bisa dimenangkan. <br><br>  Sekarang ke fungsi utama.  Namanya pada prinsipnya tidak penting, tetapi saya menghindari menyebutnya <code>main()</code> , karena MinGW memiliki ide lucu tentang bagaimana memproses karakter tersebut secara khusus, bahkan jika mereka memintanya untuk tidak melakukannya. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dosmain</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { print(<span class="hljs-string"><span class="hljs-string">"Hello, World!\n$"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  File COM terbatas pada ukuran 65279 byte.  Ini karena segmen memori x86 adalah 64 KB, dan DOS hanya mengunduh file COM ke alamat segmen 0x0100 dan mengeksekusi.  Tidak ada judul, hanya biner bersih.  Karena program COM, pada prinsipnya, tidak dapat memiliki ukuran yang signifikan, maka tidak ada tata letak nyata (berdiri bebas) yang harus terjadi, semuanya dikompilasi sebagai unit terjemahan tunggal.  Ini akan menjadi satu panggilan GCC dengan banyak parameter. <br><br><h3>  Opsi penyusun </h3><br>  Berikut adalah opsi kompiler utama. <br><br> <code>-std=gnu99 -Os -nostdlib -m32 -march=i386 -ffreestanding</code> <br> <br>  Karena pustaka standar tidak digunakan, satu-satunya perbedaan antara gnu99 dan c99 adalah trigraph yang terputus (sebagaimana mestinya), dan assembler built-in dapat ditulis sebagai <code>asm</code> bukan <code>__asm__</code> .  Ini bukan tempat sampah Newton.  Proyek ini akan sangat erat kaitannya dengan GCC sehingga saya masih tidak peduli dengan ekstensi GCC. <br><br>  Opsi <code>-Os</code> mengurangi hasil kompilasi sebanyak mungkin.  Jadi program akan bekerja lebih cepat.  Ini penting dengan memperhatikan DOSBox, karena emulator default berjalan lambat seperti mesin 80-an.  Saya ingin menyesuaikan dengan batasan ini.  Jika optimizer menyebabkan masalah, maka <code>-O0</code> sementara <code>-O0</code> untuk menentukan apakah kesalahan Anda atau optimizer ada di sini. <br><br>  Seperti yang Anda lihat, pengoptimal tidak mengerti bahwa program akan bekerja dalam mode nyata dengan batasan pengalamatan yang sesuai.  <b>Ini melakukan segala macam optimasi tidak valid yang merusak program Anda yang benar-benar valid.</b>  Ini bukan bug GCC, karena kami sendiri melakukan hal-hal gila di sini.  Saya harus mengulang kode beberapa kali untuk mencegah optimizer merusak program.  Misalnya, kami harus menghindari mengembalikan struktur kompleks dari fungsi karena kadang-kadang dipenuhi dengan sampah.  Bahaya sebenarnya adalah bahwa versi GCC di masa depan akan menjadi lebih pintar dan akan merusak lebih banyak kode.  Ini teman Anda yang <code>volatile</code> . <br><br>  Parameter berikutnya adalah <code>-nostdlib</code> , karena kita tidak akan dapat menautkan ke pustaka yang valid, bahkan secara statis. <br><br>  Parameter <code>-m32-march=i386</code> compiler untuk mengeluarkan kode 80386. Jika saya menulis bootloader untuk komputer modern, maka penglihatan pada 80686 juga akan normal, tetapi DOSBox adalah 80386. <br><br>  Argumen <code>-ffreestanding</code> mensyaratkan GCC untuk tidak mengeluarkan kode yang mengakses fungsi pembantu perpustakaan standar bawaan.  Terkadang, alih-alih kode yang benar-benar berfungsi, ini menghasilkan kode untuk menjalankan fungsi bawaan, terutama dengan operator matematika.  Saya memiliki salah satu masalah utama dengan bcc, di mana perilaku ini tidak dapat dinonaktifkan.  Opsi ini paling sering digunakan saat menulis boot loader dan kernel OS.  Dan sekarang file dos dos .com. <br><br><h3>  Opsi Tautan </h3><br>  <code>-Wl</code> digunakan untuk meneruskan argumen ke linker ( <code>ld</code> ).  Kami membutuhkan ini karena kami melakukan segalanya dalam satu panggilan ke GCC. <br><br><pre> <code class="hljs powershell"><span class="hljs-literal"><span class="hljs-literal">-Wl</span></span>,-<span class="hljs-literal"><span class="hljs-literal">-nmagic</span></span>,-<span class="hljs-literal"><span class="hljs-literal">-script</span></span>=com.ld</code> </pre> <br>  <code>--nmagic</code> menonaktifkan perataan halaman bagian.  Pertama, kita tidak membutuhkannya.  Kedua, itu membuang-buang ruang yang berharga.  Dalam pengujian saya, ini sepertinya bukan ukuran yang diperlukan, tetapi untuk berjaga-jaga, saya meninggalkan opsi ini. <br><br>  Parameter <code>--script</code> menunjukkan bahwa kami ingin menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skrip linker</a> khusus.  Ini memungkinkan Anda untuk secara akurat menempatkan bagian ( <code>text</code> , <code>data</code> , <code>bss</code> , <code>rodata</code> ) dari program kami.  Ini skrip <code>com.ld</code> <br><br><pre> <code class="hljs haskell"><span class="hljs-type"><span class="hljs-type">OUTPUT_FORMAT</span></span>(binary) <span class="hljs-type"><span class="hljs-type">SECTIONS</span></span> { . = <span class="hljs-number"><span class="hljs-number">0x0100</span></span>; .text : { *(.text); } .<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> : { *(.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">); *(.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bss</span></span></span><span class="hljs-class">); *(.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rodata</span></span></span><span class="hljs-class">); } _heap = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ALIGN</span></span></span><span class="hljs-class">(4); }</span></span></code> </pre> <br>  <code>OUTPUT_FORMAT(binary)</code> memberi tahu Anda untuk tidak meletakkan ini dalam file ELF (atau PE, dll.).  Linker hanya perlu mereset kode bersih.  File COM hanyalah kode bersih, yaitu, kami memberikan perintah kepada linker untuk membuat file COM! <br><br>  Saya mengatakan bahwa file COM diunggah ke <code>0x0100</code> .  Baris keempat menggeser biner di sana.  Byte pertama dari file COM masih byte pertama dari kode, tetapi akan diluncurkan dari memori ini diimbangi. <br><br>  Kemudian semua bagian mengikuti: <code>text</code> (program), <code>data</code> (data statis), <code>bss</code> (data dengan inisialisasi nol), <code>rodata</code> (string).  Akhirnya, saya menandai akhir biner dengan simbol <code>_heap</code> .  Ini akan berguna nanti ketika menulis <code>sbrk()</code> ketika kita selesai dengan "Halo, Dunia".  Saya mengindikasikan untuk menyelaraskan <code>_heap</code> dengan 4 byte. <br><br>  Hampir selesai. <br><br><h3>  Peluncuran program </h3><br>  Tautan biasanya mengetahui titik masuk kami ( <code>main</code> ) dan mengaturnya untuk kami.  Tapi karena kami meminta masalah "biner", kami harus mencari tahu sendiri.  Jika fungsi <code>print()</code> adalah yang pertama dijalankan, maka program akan memulainya, yang mana salah.  Program ini membutuhkan tajuk kecil untuk memulai. <br><br>  Ada opsi <code>STARTUP</code> dalam skrip tautan untuk hal-hal seperti itu, tetapi untuk kesederhanaan kami akan menerapkannya langsung dalam program.  Biasanya hal-hal seperti itu disebut <code>crt0.o</code> atau <code>Boot.o</code> , jika Anda tersandung di suatu tempat.  Kode kita <i>harus</i> dimulai dengan assembler bawaan ini, sebelum ada inklusi dan sejenisnya.  DOS akan melakukan sebagian besar instalasi untuk kita, kita hanya perlu pergi ke titik masuk. <br><br><pre> <code class="hljs perl">asm (<span class="hljs-string"><span class="hljs-string">".code16gcc\n"</span></span> <span class="hljs-string"><span class="hljs-string">"call dosmain\n"</span></span> <span class="hljs-string"><span class="hljs-string">"mov $0x4C, %ah\n"</span></span> <span class="hljs-string"><span class="hljs-string">"int $0x21\n"</span></span>);</code> </pre> <br>  <code>.code16gcc</code> memberi tahu assembler bahwa kita akan bekerja dalam mode nyata, sehingga itu akan membuat konfigurasi yang benar.  Meskipun namanya, itu <i>tidak</i> akan menghasilkan kode 16-bit!  Pertama, fungsi <code>dosmain</code> , yang kami tulis sebelumnya, disebut.  Dia kemudian memberi tahu DOS menggunakan fungsi 0x4C ("selesai dengan kode kembali") bahwa kita selesai dengan melewatkan kode keluar ke register <code>al</code> -byte 1-byte (sudah ditetapkan oleh <code>dosmain</code> ).  Assembler bawaan ini <code>volatile</code> karena tidak memiliki input dan output. <br><br><h3>  Semuanya bersama </h3><br>  Inilah keseluruhan program dalam C. <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> (<span class="hljs-string"><span class="hljs-string">".code16gcc\n"</span></span> <span class="hljs-string"><span class="hljs-string">"call dosmain\n"</span></span> <span class="hljs-string"><span class="hljs-string">"mov $0x4C,%ah\n"</span></span> <span class="hljs-string"><span class="hljs-string">"int $0x21\n"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mov $0x09, %%ah\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"int $0x21\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* no output */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"d"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">) : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ah"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dosmain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ print(<span class="hljs-string"><span class="hljs-string">"Hello, World!\n$"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Saya tidak akan mengulangi <code>com.ld</code>  Inilah tantangan GCC. <br><br><pre> <code class="hljs powershell">gcc <span class="hljs-literal"><span class="hljs-literal">-std</span></span>=gnu99 <span class="hljs-literal"><span class="hljs-literal">-Os</span></span> <span class="hljs-literal"><span class="hljs-literal">-nostdlib</span></span> <span class="hljs-literal"><span class="hljs-literal">-m32</span></span> <span class="hljs-literal"><span class="hljs-literal">-march</span></span>=i386 <span class="hljs-literal"><span class="hljs-literal">-ffreestanding</span></span> \ <span class="hljs-literal"><span class="hljs-literal">-o</span></span> hello.com <span class="hljs-literal"><span class="hljs-literal">-Wl</span></span>,-<span class="hljs-literal"><span class="hljs-literal">-nmagic</span></span>,-<span class="hljs-literal"><span class="hljs-literal">-script</span></span>=com.ld hello.c</code> </pre> <br>  Dan pengujiannya di DOSBox: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c5/478/358/4c5478358be0cdd9cc05eafd66bd44d2.png"><br><br>  Kemudian jika Anda ingin grafik yang indah, satu-satunya pertanyaan adalah untuk memanggil interupsi dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menulis ke memori VGA</a> .  Jika Anda ingin suara, gunakan interupsi Speaker PC.  Saya belum menemukan cara untuk memanggil Sound Blaster.  Sejak saat itu, DOS Defender tumbuh. <br><br><h1>  Alokasi memori </h1><br>  Untuk membahas topik lain, ingat <code>_heap</code> ?  Kita dapat menggunakannya untuk mengimplementasikan <code>sbrk()</code> dan mengalokasikan memori secara dinamis di bagian utama program.  Ini adalah mode nyata dan tidak ada memori virtual, jadi kami dapat menulis ke memori apa pun yang dapat diakses kapan saja.  Beberapa area dicadangkan (misalnya, memori bawah dan atas) untuk peralatan.  Jadi tidak perlu menggunakan sbrk (), tetapi menarik untuk dicoba. <br><br>  Seperti biasa pada x86, program dan partisi Anda berada di memori yang lebih rendah (0x0100 dalam kasus ini), dan tumpukan berada di memori atas (dalam kasus kami, di wilayah 0xffff).  Pada sistem mirip Unix, memori yang dikembalikan oleh <code>malloc()</code> berasal dari dua tempat: <code>sbrk()</code> dan <code>mmap()</code> .  Apa yang <code>sbrk()</code> lakukan adalah mengalokasikan memori tepat di atas segmen program / data, menambahnya "naik" ke arah tumpukan.  Setiap panggilan ke <code>sbrk()</code> akan menambah ruang ini (atau membiarkannya tetap sama).  Memori ini akan dikelola oleh <code>malloc()</code> dan sejenisnya. <br><br>  Inilah cara menerapkan <code>sbrk()</code> dalam program COM.  Harap perhatikan bahwa Anda perlu mendefinisikan <code>size_t</code> Anda sendiri, karena kami tidak memiliki perpustakaan standar. <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> _heap; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *hbreak = &amp;_heap; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sbrk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr = hbreak; hbreak += size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; }</code> </pre> <br>  Ini hanya mengatur pointer ke <code>_heap</code> dan menambahkannya sesuai kebutuhan.  <code>sbrk()</code> sedikit lebih <code>sbrk()</code> juga akan berhati-hati dengan perataan. <br><br>  Suatu hal yang menarik terjadi pada saat pembuatan Defender DOS.  Saya (salah) menganggap bahwa memori dari <code>sbrk()</code> reset.  Jadi itu setelah pertandingan pertama.  Namun, DOS tidak mengatur ulang memori ini antar program.  Ketika saya memulai permainan lagi, <i>itu melanjutkan persis di mana saya berhenti</i> , karena struktur data yang sama dengan konten yang sama dimuat ke tempatnya.  Kebetulan keren sekali!  Ini adalah bagian dari apa yang membuat platform tertanam ini menyenangkan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id412867/">https://habr.com/ru/post/id412867/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id412855/index.html">Kerentanan CSRF masih relevan</a></li>
<li><a href="../id412859/index.html">Otentikasi dua faktor di Windows dan enkripsi data tanpa otoritas dan domain sertifikat</a></li>
<li><a href="../id412861/index.html">Membuat peta jalur pengguna untuk boneka</a></li>
<li><a href="../id412863/index.html">Dialogflower - Google Dialogflow untuk Yandex Alice</a></li>
<li><a href="../id412865/index.html">Cara memotret kamera Motion Eye di Sony Xperia XZ2</a></li>
<li><a href="../id412869/index.html">Wawancara dengan seorang ahli di bidang teknik jaringan dan kedokteran regeneratif, Profesor Tal Tal Dvir</a></li>
<li><a href="../id412871/index.html">Eclair - perpustakaan logging deklaratif Spring Java</a></li>
<li><a href="../id412873/index.html">Hard drive dimanjakan oleh suara dari speaker laptop biasa</a></li>
<li><a href="../id412877/index.html">Ruthenium (Ru) - elemen keempat dengan sifat feromagnetik pada suhu kamar</a></li>
<li><a href="../id412879/index.html">Edisi # 24: Pelatihan TI - masalah saat ini dan tantangan dari perusahaan terkemuka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>