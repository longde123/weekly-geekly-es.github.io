<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚🏻 👒 🔓 Erstellen einer modernen Webanwendung von Grund auf neu 🙊 👫 👩🏻‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sie haben sich also für ein neues Projekt entschieden. Und dieses Projekt ist eine Webanwendung. Wie lange dauert die Erstellung eines Basisprototyps?...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen einer modernen Webanwendung von Grund auf neu</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444446/"> Sie haben sich also für ein neues Projekt entschieden.  Und dieses Projekt ist eine Webanwendung.  Wie lange dauert die Erstellung eines Basisprototyps?  Wie schwer ist es  Was sollte eine moderne Website von Anfang an können? <br><br>  In diesem Artikel werden wir versuchen, das Boilerplate einer einfachen Webanwendung mit der folgenden Architektur zu skizzieren: <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ul/ne/9v/ulne9vljujdrtxnf-qeqrrux7da.png"></a> </div><br>  Was wir behandeln werden: <br><br><ul><li>  Einrichten der Entwicklungsumgebung in Docker-Compose. </li><li>  Backend-Erstellung auf Flask. </li><li>  Erstellen eines Frontends in Express. </li><li>  Erstellen Sie JS mit Webpack. </li><li>  Reagieren, Redux und serverseitiges Rendern. </li><li>  Aufgabenwarteschlangen mit RQ. </li></ul><a name="habracut"></a><br><h2>  Einführung </h2><br>  Vor der Entwicklung müssen Sie natürlich erst entscheiden, was wir entwickeln!  Als Modellanwendung für diesen Artikel habe ich beschlossen, eine primitive Wiki-Engine zu erstellen.  Wir werden Karten in Markdown ausstellen lassen;  Sie können angesehen werden und (irgendwann in der Zukunft) Änderungen anbieten.  All dies werden wir als einseitige Anwendung mit serverseitigem Rendering arrangieren (was für die Indizierung unserer zukünftigen Terabyte an Inhalten unbedingt erforderlich ist). <br><br>  Schauen wir uns die Komponenten, die wir dafür benötigen, etwas genauer an: <br><br><ul><li>  <b>Kunde</b>  Erstellen wir eine einseitige Anwendung (d. H. Mit Seitenübergängen unter Verwendung von AJAX) für das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">React</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Redux-</a> Bundle, das in der Front-End-Welt sehr verbreitet ist. </li><li>  <b>Frontend</b> .  Erstellen wir einen einfachen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Express-</a> Server, der unsere React-Anwendung rendert (alle erforderlichen Daten im Backend asynchron anfordert) und an den Benutzer ausgibt. </li><li>  <b>Backend</b> .  Unser Backend ist eine kleine Flask-Anwendung.  Wir werden Daten (unsere Karten) im beliebten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MongoDB-</a> Dokumenten-Repository speichern und für die Task-Warteschlange und möglicherweise in Zukunft für das Caching <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Redis verwenden</a> . </li><li>  <b>ARBEITNEHMER</b> .  Ein separater Container für schwere Aufgaben wird von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RQ-</a> Bibliothek gestartet. </li></ul><br><h2>  Infrastruktur: git </h2><br>  Wahrscheinlich konnten wir nicht darüber sprechen, aber wir werden natürlich die Entwicklung im Git-Repository durchführen. <br><br><pre><code class="bash hljs">git init git remote add origin git@github.com:Saluev/habr-app-demo.git git commit --allow-empty -m <span class="hljs-string"><span class="hljs-string">"Initial commit"</span></span> git push</code> </pre> <br>  (Hier sollten Sie sofort <code>.gitignore</code> .) <br><br>  Der endgültige Entwurf kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf Github</a> eingesehen werden.  Jeder Abschnitt des Artikels entspricht einem Commit (ich habe viel zurückgewiesen, um dies zu erreichen!). <br><br><h2>  Infrastruktur: Docker-Compose </h2><br>  Beginnen wir mit der Einrichtung der Umgebung.  Angesichts der Fülle an Komponenten wäre es eine sehr logische Entwicklungslösung, Docker-Compose zu verwenden. <br><br>  Fügen Sie die Datei <code>docker-compose.yml</code> folgenden Inhalt zum Repository hinzu: <br><br><pre> <code class="plaintext hljs">version: '3' services: mongo: image: "mongo:latest" redis: image: "redis:alpine" backend: build: context: . dockerfile: ./docker/backend/Dockerfile environment: - APP_ENV=dev depends_on: - mongo - redis ports: - "40001:40001" volumes: - .:/code frontend: build: context: . dockerfile: ./docker/frontend/Dockerfile environment: - APP_ENV=dev - APP_BACKEND_URL=backend:40001 - APP_FRONTEND_PORT=40002 depends_on: - backend ports: - "40002:40002" volumes: - ./frontend:/app/src worker: build: context: . dockerfile: ./docker/worker/Dockerfile environment: - APP_ENV=dev depends_on: - mongo - redis volumes: - .:/code</code> </pre><br>  Werfen wir einen kurzen Blick darauf, was hier passiert. <br><br><ul><li>  Ein MongoDB-Container und ein Redis-Container werden erstellt. </li><li>  Ein Container für unser Backend wird erstellt (den wir unten beschreiben).  Die Umgebungsvariable APP_ENV = dev wird an sie übergeben (wir werden sie untersuchen, um zu verstehen, welche Flask-Einstellungen geladen werden sollen), und ihr Port 40001 wird außerhalb geöffnet (über sie geht unser Browser-Client zur API). </li><li>  Ein Container unseres Frontends wird erstellt.  Es werden auch verschiedene Umgebungsvariablen eingefügt, die später für uns nützlich sein werden, und Port 40002 wird geöffnet. Dies ist der Hauptport unserer Webanwendung: Im Browser gehen wir zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http: // localhost: 40002</a> . </li><li>  Der Container unseres Arbeiters wird erstellt.  Er benötigt keine externen Ports und nur in MongoDB und Redis ist Zugriff erforderlich. </li></ul><br>  Jetzt erstellen wir Docker-Dateien.  Im Moment kommt eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzungen</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">exzellenter</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> über Docker nach Habré - Sie können sicher dorthin gehen, um alle Details zu erfahren. <br><br>  Beginnen wir mit dem Backend. <br><br><pre> <code class="plaintext hljs"># docker/backend/Dockerfile FROM python:stretch COPY requirements.txt /tmp/ RUN pip install -r /tmp/requirements.txt ADD . /code WORKDIR /code CMD gunicorn -w 1 -b 0.0.0.0:40001 --worker-class gevent backend.server:app</code> </pre><br>  Es versteht sich, dass wir die Gunicorn Flask-Anwendung durchlaufen und uns unter der Namens- <code>app</code> im Modul <code>backend.server</code> verstecken. <br><br>  Nicht weniger wichtig <code>docker/backend/.dockerignore</code> : <br><br><pre> <code class="plaintext hljs">.git .idea .logs .pytest_cache frontend tests venv *.pyc *.pyo</code> </pre><br>  Der Arbeiter ist im Allgemeinen dem Backend ähnlich, nur haben wir anstelle von Gunicorn den üblichen Start eines Pit-Moduls: <br><br><pre> <code class="plaintext hljs"># docker/worker/Dockerfile FROM python:stretch COPY requirements.txt /tmp/ RUN pip install -r /tmp/requirements.txt ADD . /code WORKDIR /code CMD python -m worker</code> </pre><br>  Wir werden die ganze Arbeit in <code>worker/__main__.py</code> . <br><br>  <code>.dockerignore</code> Worker ist dem <code>.dockerignore</code> Backend völlig ähnlich. <br><br>  Endlich das Frontend.  Es gibt einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">separaten Artikel</a> über ihn über Habré, aber nach der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausführlichen Diskussion über StackOverflow</a> und den Kommentaren im Geiste von "Jungs, ist es schon 2018, gibt es noch keine normale Lösung?"  dort ist nicht alles so einfach.  Ich habe mich für diese Version der Docker-Datei entschieden. <br><br><pre> <code class="plaintext hljs"># docker/frontend/Dockerfile FROM node:carbon WORKDIR /app #  package.json  package-lock.json   npm install,   . COPY frontend/package*.json ./ RUN npm install #       , #     PATH. ENV PATH /app/node_modules/.bin:$PATH #      . ADD frontend /app/src WORKDIR /app/src RUN npm run build CMD npm run start</code> </pre><br>  Vorteile: <br><br><ul><li>  Alles wird wie erwartet zwischengespeichert (auf der untersten Ebene - Abhängigkeiten, auf der obersten Ebene - dem Build unserer Anwendung). </li><li>  <code>docker-compose exec frontend npm install --save newDependency</code> funktioniert wie es sollte und ändert <code>package.json</code> in unserem Repository (was nicht der Fall wäre, wenn wir COPY verwenden würden, wie viele Leute vorschlagen).  Es wäre ohnehin nicht wünschenswert, <code>npm install --save newDependency</code> außerhalb des Containers <code>npm install --save newDependency</code> , da einige Abhängigkeiten des neuen Pakets möglicherweise bereits vorhanden sind und auf einer anderen Plattform erstellt werden (z. B. unter der im Docker und nicht unter unserem funktionierenden Macbook) ), und dennoch möchten wir im Allgemeinen nicht die Anwesenheit von Node auf der Entwicklungsmaschine benötigen.  Ein Docker, der sie alle regiert! </li></ul><br>  Na ja und natürlich <code>docker/frontend/.dockerignore</code> : <br><br><pre> <code class="plaintext hljs">.git .idea .logs .pytest_cache backend worker tools node_modules npm-debug tests venv</code> </pre><br>  Unser Containerrahmen ist also fertig und Sie können ihn mit Inhalt füllen! <br><br><h2>  Backend: Flask Framework </h2><br>  Fügen Sie <code>flask</code> , <code>flask-cors</code> , <code>gevent</code> und <code>gunicorn</code> zu <code>gevent</code> <code>gunicorn</code> und erstellen Sie eine einfache Flask-Anwendung in <code>backend/server.py</code> . <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># backend/server.py import os.path import flask import flask_cors class HabrAppDemo(flask.Flask): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) # CORS        #    ,      # (  Access-Control-Origin  ). #   - . flask_cors.CORS(self) app = HabrAppDemo("habr-app-demo") env = os.environ.get("APP_ENV", "dev") print(f"Starting application in {env} mode") app.config.from_object(f"backend.{env}_settings")</span></span></code> </pre><br>  Wir haben Flask <code>backend.{env}_settings</code> , die Einstellungen aus der <code>backend.{env}_settings</code> Datei <code>backend.{env}_settings</code> , was bedeutet, dass wir auch eine (mindestens leere) Datei <code>backend/dev_settings.py</code> damit alles abheben kann. <br><br>  Jetzt können wir unser Backend offiziell ERHÖHEN! <br><br><pre> <code class="plaintext hljs">habr-app-demo$ docker-compose up backend ... backend_1 | [2019-02-23 10:09:03 +0000] [6] [INFO] Starting gunicorn 19.9.0 backend_1 | [2019-02-23 10:09:03 +0000] [6] [INFO] Listening at: http://0.0.0.0:40001 (6) backend_1 | [2019-02-23 10:09:03 +0000] [6] [INFO] Using worker: gevent backend_1 | [2019-02-23 10:09:03 +0000] [9] [INFO] Booting worker with pid: 9</code> </pre><br>  Wir gehen weiter. <br><br><h2>  Frontend: Express Framework </h2><br>  Beginnen wir mit der Erstellung eines Pakets.  Nachdem wir den Frontend-Ordner erstellt und <code>npm init</code> darin ausgeführt haben, erhalten wir nach einigen ungekünstelten Fragen das fertige package.json im Geiste <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"habr-app-demo"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0.1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"This is an app demo for Habr article."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"index.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"repository"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"git"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"git+https://github.com/Saluev/habr-app-demo.git"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"Tigran Saluev &lt;tigran@saluev.com&gt;"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"MIT"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"bugs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://github.com/Saluev/habr-app-demo/issues"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"homepage"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://github.com/Saluev/habr-app-demo#readme"</span></span> }</code> </pre><br>  In Zukunft brauchen wir Node.js auf dem Entwicklercomputer überhaupt nicht mehr (obwohl wir <code>npm init</code> über Docker ausweichen und starten könnten, aber na ja). <br><br>  In <code>Dockerfile</code> wir <code>npm run build</code> und <code>npm run start</code> - Sie müssen <code>package.json</code> die entsprechenden Befehle <code>package.json</code> : <br><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/frontend/package.json +++ b/frontend/package.json @@ -4,6 +4,8 @@ "description": "This is an app demo for Habr article.", "main": "index.js", "scripts": { + "build": "echo 'build'", + "start": "node index.js", "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" }, "repository": {</span></span></code> </pre><br>  Der Befehl <code>build</code> führt noch nichts aus, ist aber für uns weiterhin nützlich. <br><br>  Fügen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Express-</a> Abhängigkeiten hinzu und erstellen Sie eine einfache Anwendung in <code>index.js</code> : <br><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/frontend/package.json +++ b/frontend/package.json @@ -17,5 +17,8 @@ "bugs": { "url": "https://github.com/Saluev/habr-app-demo/issues" }, - "homepage": "https://github.com/Saluev/habr-app-demo#readme" + "homepage": "https://github.com/Saluev/habr-app-demo#readme", + "dependencies": { + "express": "^4.16.3" + } }</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/index.js const express = require("express"); app = express(); app.listen(process.env.APP_FRONTEND_PORT); app.get("*", (req, res) =&gt; { res.send("Hello, world!") });</span></span></code> </pre><br>  Jetzt erhöht <code>docker-compose up frontend</code> unser Frontend!  Außerdem sollte auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http: // localhost: 40002</a> der Klassiker „Hallo Welt“ bereits zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geltung</a> kommen. <br><br><h2>  Frontend: Mit Webpack und React-Anwendung erstellen </h2><br>  Es ist Zeit, in unserer Anwendung mehr als nur einfachen Text darzustellen.  In diesem Abschnitt fügen wir die einfachste React-Komponente der <code>App</code> und konfigurieren die Assembly. <br><br>  Bei der Programmierung in React ist es sehr praktisch, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSX</a> zu verwenden, einen JavaScript-Dialekt, der durch syntaktische Konstruktionen des Formulars erweitert wird <br><br><pre> <code class="javascript hljs">render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MyButton</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">color</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"blue"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{this.props.caption}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MyButton</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; }</code> </pre><br>  JavaScript-Engines verstehen dies jedoch nicht. Daher wird normalerweise die Erstellungsphase zum Frontend hinzugefügt.  Spezielle JavaScript-Compiler (yeah-yeah) verwandeln syntaktischen Zucker in <s>hässliches</s> klassisches JavaScript, verarbeiten Importe, minimieren und so weiter. <br><br><img src="https://habrastorage.org/webt/f1/rl/0j/f1rl0jer0cxs_ll69yagvwm_0gc.jpeg"><br><br>  <i>2014 Jahr.</i>  <i>apt-cache search java</i> <br><br>  Die einfachste React-Komponente sieht also sehr einfach aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/components/app.js import React, {Component} from 'react' class App extends Component { render() { return &lt;h1&gt;Hello, world!&lt;/h1&gt; } } export default App</span></span></code> </pre><br>  Er wird unseren Gruß einfach mit einer überzeugenderen Stecknadel anzeigen. <br><br>  Fügen Sie die Datei <code>frontend/src/template.js</code> die das minimale HTML-Framework unserer zukünftigen Anwendung enthält: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/template.js export default function template(title) { let page = ` &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;${title}&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script src="/dist/client.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `; return page; }</span></span></code> </pre><br>  Fügen Sie einen Client-Einstiegspunkt hinzu: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/client.js import React from 'react' import {render} from 'react-dom' import App from './components/app' render( &lt;App/&gt;, document.querySelector('#app') );</span></span></code> </pre><br>  Um all diese Schönheit aufzubauen, brauchen wir: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">webpack</a> ist ein modischer Jugendbauer für JS (obwohl ich drei Stunden lang keine Artikel im Frontend gelesen habe, bin ich mir also nicht sicher über die Mode); <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">babel</a> ist ein Compiler für alle Arten von Lotionen wie JSX und gleichzeitig ein Polyfill-Anbieter für alle IE-Fälle. <br><br>  Wenn die vorherige Iteration des Frontends noch ausgeführt wird, müssen Sie nur noch etwas tun <br><br><pre> <code class="bash hljs">docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> frontend npm install --save \ react \ react-dom docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> frontend npm install --save-dev \ webpack \ webpack-cli \ babel-loader \ @babel/core \ @babel/polyfill \ @babel/preset-env \ @babel/preset-react</code> </pre><br>  um neue Abhängigkeiten zu installieren.  Konfigurieren Sie nun das Webpack: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/webpack.config.js const path = require("path"); //  . clientConfig = { mode: "development", entry: { client: ["./src/client.js", "@babel/polyfill"] }, output: { path: path.resolve(__dirname, "../dist"), filename: "[name].js" }, module: { rules: [ { test: /\.js$/, exclude: /node_modules/, loader: "babel-loader" } ] } }; //  .     : // 1. target: "node" -      import path. // 2.   ..,    ../dist --   //    ,   ! serverConfig = { mode: "development", target: "node", entry: { server: ["./index.js", "@babel/polyfill"] }, output: { path: path.resolve(__dirname, ".."), filename: "[name].js" }, module: { rules: [ { test: /\.js$/, exclude: /node_modules/, loader: "babel-loader" } ] } }; module.exports = [clientConfig, serverConfig];</span></span></code> </pre><br>  Damit Babel funktioniert, müssen Sie <code>frontend/.babelrc</code> konfigurieren: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"presets"</span></span>: [<span class="hljs-string"><span class="hljs-string">"@babel/env"</span></span>, <span class="hljs-string"><span class="hljs-string">"@babel/react"</span></span>] }</code> </pre><br>  Machen Sie unseren Befehl <code>npm run build</code> aussagekräftig: <br><br><pre> <code class="json hljs">// frontend/package.json ... <span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"build"</span></span>: <span class="hljs-string"><span class="hljs-string">"webpack"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node /app/server.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> }, ...</code> </pre><br>  Jetzt durchläuft unser Client zusammen mit einem Bündel von Polyfills und all seinen Abhängigkeiten babel, kompiliert und faltet sich zu einer monolithisch minimierten Datei <code>../dist/client.js</code> .  Fügen Sie die Möglichkeit hinzu, es als statische Datei in unsere Express-Anwendung hochzuladen, und in der Standardroute geben wir unser HTML zurück: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/index.js // ,    , //  - . import express from 'express' import template from './src/template' let app = express(); app.use('/dist', express.static('../dist')); app.get("*", (req, res) =&gt; { res.send(template("Habr demo app")); }); app.listen(process.env.APP_FRONTEND_PORT);</span></span></code> </pre><br>  Erfolg!  Wenn wir jetzt <code>docker-compose up --build frontend</code> , sehen wir "Hallo Welt!"  In einem neuen, glänzenden Wrapper und wenn Sie die Erweiterung React Developer Tools ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chrome</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Firefox</a> ) installiert haben, gibt es in den Entwicklertools auch einen React-Komponentenbaum: <br><br><img src="https://habrastorage.org/webt/q1/it/gu/q1itgukw2k0ko60pghlwwkfqfn0.png"><br><br><h2>  Backend: Daten in MongoDB </h2><br>  Bevor Sie fortfahren und unserer Anwendung Leben einhauchen, müssen Sie sie zuerst in das Backend einatmen.  Es scheint, dass wir die in Markdown markierten Karten aufbewahren wollten - es ist Zeit, dies zu tun. <br><br>  Während <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es in Python ORMs für MongoDB gibt, halte</a> ich die Verwendung von ORMs für bösartig und überlasse Ihnen das Studium der geeigneten Lösungen.  Stattdessen erstellen wir eine einfache Klasse für die Karte und das zugehörige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DAO</a> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># backend/storage/card.py import abc from typing import Iterable class Card(object): def __init__(self, id: str = None, slug: str = None, name: str = None, markdown: str = None, html: str = None): self.id = id self.slug = slug #    self.name = name self.markdown = markdown self.html = html class CardDAO(object, metaclass=abc.ABCMeta): @abc.abstractmethod def create(self, card: Card) -&gt; Card: pass @abc.abstractmethod def update(self, card: Card) -&gt; Card: pass @abc.abstractmethod def get_all(self) -&gt; Iterable[Card]: pass @abc.abstractmethod def get_by_id(self, card_id: str) -&gt; Card: pass @abc.abstractmethod def get_by_slug(self, slug: str) -&gt; Card: pass class CardNotFound(Exception): pass</span></span></code> </pre><br>  (Wenn Sie in Python immer noch keine Typanmerkungen verwenden, lesen Sie unbedingt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> !) <br><br>  Erstellen wir nun eine Implementierung der <code>CardDAO</code> Schnittstelle, die ein <code>Database</code> aus <code>pymongo</code> (ja, Zeit, um <code>pymongo</code> zur <code>requirements.txt</code> hinzuzufügen): <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># backend/storage/card_impl.py from typing import Iterable import bson import bson.errors from pymongo.collection import Collection from pymongo.database import Database from backend.storage.card import Card, CardDAO, CardNotFound class MongoCardDAO(CardDAO): def __init__(self, mongo_database: Database): self.mongo_database = mongo_database # , slug   . self.collection.create_index("slug", unique=True) @property def collection(self) -&gt; Collection: return self.mongo_database["cards"] @classmethod def to_bson(cls, card: Card): # MongoDB     BSON.  #       BSON- #  ,      . result = { k: v for k, v in card.__dict__.items() if v is not None } if "id" in result: result["_id"] = bson.ObjectId(result.pop("id")) return result @classmethod def from_bson(cls, document) -&gt; Card: #   ,     #     ,     #  .    id    # ,   -   . document["id"] = str(document.pop("_id")) return Card(**document) def create(self, card: Card) -&gt; Card: card.id = str(self.collection.insert_one(self.to_bson(card)).inserted_id) return card def update(self, card: Card) -&gt; Card: card_id = bson.ObjectId(card.id) self.collection.update_one({"_id": card_id}, {"$set": self.to_bson(card)}) return card def get_all(self) -&gt; Iterable[Card]: for document in self.collection.find(): yield self.from_bson(document) def get_by_id(self, card_id: str) -&gt; Card: return self._get_by_query({"_id": bson.ObjectId(card_id)}) def get_by_slug(self, slug: str) -&gt; Card: return self._get_by_query({"slug": slug}) def _get_by_query(self, query) -&gt; Card: document = self.collection.find_one(query) if document is None: raise CardNotFound() return self.from_bson(document)</span></span></code> </pre><br>  Zeit, die Monga-Konfiguration in den Backend-Einstellungen zu registrieren.  Wir haben unseren Container einfach mit <code>MONGO_HOST = "mongo"</code> benannt, also <code>MONGO_HOST = "mongo"</code> : <br><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/backend/dev_settings.py +++ b/backend/dev_settings.py @@ -0,0 +1,3 @@ +MONGO_HOST = "mongo" +MONGO_PORT = 27017 +MONGO_DATABASE = "core"</span></span></code> </pre><br>  Jetzt müssen wir <code>MongoCardDAO</code> erstellen und der Flask-Anwendung Zugriff darauf gewähren.  Obwohl wir jetzt eine sehr einfache Hierarchie von Objekten haben (Einstellungen → Pymongo-Client → Pymongo-Datenbank → <code>MongoCardDAO</code> ), erstellen wir sofort eine zentralisierte King-Komponente, die die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abhängigkeitsinjektion</a> <code>MongoCardDAO</code> (dies wird sich wieder als nützlich erweisen, wenn wir den Worker und die Tools <code>MongoCardDAO</code> ). <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># backend/wiring.py import os from pymongo import MongoClient from pymongo.database import Database import backend.dev_settings from backend.storage.card import CardDAO from backend.storage.card_impl import MongoCardDAO class Wiring(object): def __init__(self, env=None): if env is None: env = os.environ.get("APP_ENV", "dev") self.settings = { "dev": backend.dev_settings, # (    # ,   !) }[env] #        . #        DI,  . self.mongo_client: MongoClient = MongoClient( host=self.settings.MONGO_HOST, port=self.settings.MONGO_PORT) self.mongo_database: Database = self.mongo_client[self.settings.MONGO_DATABASE] self.card_dao: CardDAO = MongoCardDAO(self.mongo_database)</span></span></code> </pre><br><br>  Zeit, der Flask-Anwendung eine neue Route hinzuzufügen und die Ansicht zu genießen! <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># backend/server.py import os.path import flask import flask_cors from backend.storage.card import CardNotFound from backend.wiring import Wiring env = os.environ.get("APP_ENV", "dev") print(f"Starting application in {env} mode") class HabrAppDemo(flask.Flask): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) flask_cors.CORS(self) self.wiring = Wiring(env) self.route("/api/v1/card/&lt;card_id_or_slug&gt;")(self.card) def card(self, card_id_or_slug): try: card = self.wiring.card_dao.get_by_slug(card_id_or_slug) except CardNotFound: try: card = self.wiring.card_dao.get_by_id(card_id_or_slug) except (CardNotFound, ValueError): return flask.abort(404) return flask.jsonify({ k: v for k, v in card.__dict__.items() if v is not None }) app = HabrAppDemo("habr-app-demo") app.config.from_object(f"backend.{env}_settings")</span></span></code> </pre><br>  Starten Sie mit dem <code>docker-compose up --build backend</code> : <br><br><img src="https://habrastorage.org/webt/ts/_a/1l/ts_a1ljldp9jztjvlupm4z6f29i.png"><br><br>  Ups ... oh genau.  Wir müssen Inhalte hinzufügen!  Wir öffnen den Tools-Ordner und fügen ein Skript hinzu, das eine Testkarte hinzufügt: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># tools/add_test_content.py from backend.storage.card import Card from backend.wiring import Wiring wiring = Wiring() wiring.card_dao.create(Card( slug="helloworld", name="Hello, world!", markdown=""" This is a hello-world page. """))</span></span></code> </pre><br>  Der <code>docker-compose exec backend python -m tools.add_test_content</code> füllt unsere Monga mit Inhalten aus dem <code>docker-compose exec backend python -m tools.add_test_content</code> Container. <br><br><img src="https://habrastorage.org/webt/em/n2/la/emn2laspljezpnoc66oeccj42l4.png"><br><br>  Erfolg!  Jetzt ist es an der Zeit, dies am Frontend zu unterstützen. <br><br><h2>  Frontend: Redux </h2><br>  Jetzt wollen wir die Route <code>/card/:id_or_slug</code> , über die unsere React-Anwendung geöffnet wird, die Kartendaten aus der API laden und uns irgendwie anzeigen.  Und hier beginnt vielleicht der schwierigste Teil, weil wir möchten, dass der Server uns sofort HTML mit dem Inhalt der Karte gibt, der für die Indizierung geeignet ist. Gleichzeitig empfängt die Anwendung beim Navigieren zwischen den Karten alle Daten in Form von JSON von der API und die Seite wird nicht überladen.  Und das alles - ohne Copy-Paste! <br><br>  Beginnen wir mit dem Hinzufügen von Redux.  Redux ist eine JavaScript-Bibliothek zum Speichern des Status.  Die Idee ist, dass anstelle der Tausenden impliziter Zustände, die Ihre Komponenten während Benutzeraktionen und anderen interessanten Ereignissen ändern, sie einen zentralen Status haben und Änderungen über einen zentralisierten Aktionsmechanismus vornehmen.  Wenn wir also früher für die Navigation zuerst das GIF zum Laden aktiviert haben, dann eine Anfrage über AJAX gestellt und schließlich im Erfolgsrückruf die erforderlichen Teile der Seite aktualisiert haben, werden wir im Redux-Paradigma aufgefordert, die Aktion "Inhalt in ein GIF mit Animation ändern" zu senden ändert den globalen Status, sodass eine Ihrer Komponenten den vorherigen Inhalt löscht und die Animation einfügt, dann eine Anfrage stellt und eine weitere Aktion in ihrem erfolgreichen Rückruf sendet: "Ändern Sie den Inhalt in geladen".  Im Allgemeinen werden wir es jetzt selbst sehen. <br><br>  Beginnen wir mit der Installation neuer Abhängigkeiten in unserem Container. <br><br><pre> <code class="bash hljs">docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> frontend npm install --save \ redux \ react-redux \ redux-thunk \ redux-devtools-extension</code> </pre><br>  Das erste ist in der Tat Redux, das zweite ist eine spezielle Bibliothek zum Überqueren von React und Redux (geschrieben von Paarungsexperten), das dritte ist eine sehr notwendige Sache, deren Notwendigkeit in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der README-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datei</a> gut begründet ist, und schließlich ist das vierte die Bibliothek, die für die Arbeit von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Redux DevTools</a> erforderlich ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterung</a> . <br><br>  Beginnen wir mit dem Redux-Code der Boilerplate: Erstellen eines Reduzierers, der nichts tut, und Initialisieren des Status. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/reducers.js export default function root(state = {}, action) { return state; }</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/configureStore.js import {createStore, applyMiddleware} from "redux"; import thunkMiddleware from "redux-thunk"; import {composeWithDevTools} from "redux-devtools-extension"; import rootReducer from "./reducers"; export default function configureStore(initialState) { return createStore( rootReducer, initialState, composeWithDevTools(applyMiddleware(thunkMiddleware)), ); }</span></span></code> </pre><br>  Unser Kunde ändert sich ein wenig und bereitet sich mental auf die Arbeit mit Redux vor: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/client.js import React from 'react' import {render} from 'react-dom' import {Provider} from 'react-redux' import App from './components/app' import configureStore from './redux/configureStore' //      ... const store = configureStore(); render( // ...      , //     &lt;Provider store={store}&gt; &lt;App/&gt; &lt;/Provider&gt;, document.querySelector('#app') );</span></span></code> </pre><br>  Jetzt können wir Docker-Compose Up - Build Frontend ausführen, um sicherzustellen, dass nichts kaputt ist, und unser primitiver Status wurde in Redux DevTools angezeigt: <br><br><img src="https://habrastorage.org/webt/x0/hr/_e/x0hr_empfso4poji4s8egshlcye.png"><br><br><h2>  Frontend: Kartenseite </h2><br>  Bevor Sie Seiten mit SSRs erstellen können, müssen Sie Seiten ohne SSRs erstellen!  Lassen Sie uns endlich unsere geniale API für den Zugriff auf Karten verwenden und die Kartenseite im Frontend erstellen. <br><br>  Zeit, die Intelligenz zu nutzen und unsere Staatsstruktur neu zu gestalten.  Es <a href="">gibt viele</a> Materialien zu diesem Thema, daher empfehle ich, die Intelligenz nicht zu missbrauchen und mich auf das Einfache zu konzentrieren.  Zum Beispiel: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"page"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"card"</span></span>, //     //       type=card: <span class="hljs-string"><span class="hljs-string">"cardSlug"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, //     <span class="hljs-attr"><span class="hljs-attr">"isFetching"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, //      API <span class="hljs-attr"><span class="hljs-attr">"cardData"</span></span>: {...}, //   (  ) // ... }, // ... }</code> </pre><br>  Lassen Sie uns die "Karten" -Komponente erhalten, die den Inhalt von cardData als Requisiten verwendet (es ist eigentlich der Inhalt unserer Karte in Mongo): <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/components/card.js import React, {Component} from 'react'; class Card extends Component { componentDidMount() { document.title = this.props.name } render() { const {name, html} = this.props; return ( &lt;div&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;!---,  HTML  React  - !--&gt; &lt;div dangerouslySetInnerHTML={{__html: html}}/&gt; &lt;/div&gt; ); } } export default Card;</span></span></code> </pre><br>  Lassen Sie uns nun eine Komponente für die gesamte Seite mit der Karte erhalten.  Er ist dafür verantwortlich, die erforderlichen Daten von der API abzurufen und auf die Karte zu übertragen.  Und wir werden Daten auf React-Redux-Weise abrufen. <br><br>  Erstellen Sie zunächst die Datei <code>frontend/src/redux/actions.js</code> und erstellen Sie eine Aktion, die den Inhalt der Karte aus der API extrahiert, falls noch nicht geschehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchCardIfNeeded</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, getState</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = getState().page; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state.cardData === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> || state.cardData.slug !== state.cardSlug) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dispatch(fetchCard()); } }; }</code> </pre><br>  Die <code>fetchCard</code> Aktion, die den Abruf tatsächlich macht, ist etwas komplizierter: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchCard</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, getState</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,    . //     , , //    . dispatch(startFetchingCard()); //    API. let url = apiPath() + "/card/" + getState().page.cardSlug; // , ,   ,  //    . , ,  //    . return fetch(url) .then(response =&gt; response.json()) .then(json =&gt; dispatch(finishFetchingCard(json))); }; // ,  redux-thunk   //     . } function startFetchingCard() { return { type: START_FETCHING_CARD }; } function finishFetchingCard(json) { return { type: FINISH_FETCHING_CARD, cardData: json }; } function apiPath() { //    .    server-side // rendering,   API     -  //         localhost, //   backend. return "http://localhost:40001/api/v1"; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oh, wir haben eine Aktion, die ETWAS TUT! </font><font style="vertical-align: inherit;">Dies muss im Reduzierer unterstützt werden:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/reducers.js import { START_FETCHING_CARD, FINISH_FETCHING_CARD } from "./actions"; export default function root(state = {}, action) { switch (action.type) { case START_FETCHING_CARD: return { ...state, page: { ...state.page, isFetching: true } }; case FINISH_FETCHING_CARD: return { ...state, page: { ...state.page, isFetching: false, cardData: action.cardData } } } return state; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Beachten Sie die trendige Syntax zum Klonen eines Objekts mit sich ändernden einzelnen Feldern.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem die gesamte Logik in Redux-Aktionen ausgeführt </font></font><code>CardPage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird, sieht </font><font style="vertical-align: inherit;">die Komponente selbst </font><font style="vertical-align: inherit;">relativ einfach aus:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/components/cardPage.js import React, {Component} from 'react'; import {connect} from 'react-redux' import {fetchCardIfNeeded} from '../redux/actions' import Card from './card' class CardPage extends Component { componentWillMount() { //   ,  React  //   .      //   ,    " // "   ,    //  - .    -   //       HTML  // renderToString,      SSR. this.props.dispatch(fetchCardIfNeeded()) } render() { const {isFetching, cardData} = this.props; return ( &lt;div&gt; {isFetching &amp;&amp; &lt;h2&gt;Loading...&lt;/h2&gt;} {cardData &amp;&amp; &lt;Card {...cardData}/&gt;} &lt;/div&gt; ); } } //       ,   //  .        //  react-redux.   page    //  dispatch,   . function mapStateToProps(state) { const {page} = state; return page; } export default connect(mapStateToProps)(CardPage);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fügen Sie unserer Root-App-Komponente eine einfache page.type-Verarbeitung hinzu: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/components/app.js import React, {Component} from 'react' import {connect} from "react-redux"; import CardPage from "./cardPage" class App extends Component { render() { const {pageType} = this.props; return ( &lt;div&gt; {pageType === "card" &amp;&amp; &lt;CardPage/&gt;} &lt;/div&gt; ); } } function mapStateToProps(state) { const {page} = state; const {type} = page; return { pageType: type }; } export default connect(mapStateToProps)(App);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und jetzt bleibt der letzte Moment - Sie müssen irgendwie initialisieren </font></font><code>page.type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>page.cardSlug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abhängig von der URL der Seite. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt zwar noch viele Abschnitte in diesem Artikel, aber wir können derzeit keine qualitativ hochwertige Lösung finden. </font><font style="vertical-align: inherit;">Lass es uns erstmal dumm machen. </font><font style="vertical-align: inherit;">Das ist einfach völlig dumm. </font><font style="vertical-align: inherit;">Zum Beispiel eine regelmäßige bei der Initialisierung der Anwendung!</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/client.js import React from 'react' import {render} from 'react-dom' import {Provider} from 'react-redux' import App from './components/app' import configureStore from './redux/configureStore' let initialState = { page: { type: "home" } }; const m = /^\/card\/([^\/]+)$/.exec(location.pathname); if (m !== null) { initialState = { page: { type: "card", cardSlug: m[1] }, } } const store = configureStore(initialState); render( &lt;Provider store={store}&gt; &lt;App/&gt; &lt;/Provider&gt;, document.querySelector('#app') );</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir das Frontend mit Hilfe </font></font><code>docker-compose up --build frontend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unserer Karte neu erstellen </font></font><code>helloworld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... </font></font><br><br><img src="https://habrastorage.org/webt/vj/qi/iu/vjqiiu9iu3c0ieigltqbu35smfw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warten Sie also eine Sekunde ... und wo ist unser Inhalt? </font><font style="vertical-align: inherit;">Oh, wir haben vergessen, Markdown zu analysieren!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbeiter: RQ </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Parsen von Markdown und das Generieren von HTML für eine Karte mit potenziell unbegrenzter Größe ist eine typische „schwere“ Aufgabe, die nicht direkt im Backend gelöst wird, während Änderungen gespeichert werden, sondern normalerweise auf separaten Arbeitsmaschinen in die Warteschlange gestellt und ausgeführt wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt viele Open Source-Implementierungen von Task-Warteschlangen. </font><font style="vertical-align: inherit;">Wir werden Redis und eine einfache Bibliothek </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RQ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Redis Queue) nehmen, die Aufgabenparameter im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pickle-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Format überträgt </font><font style="vertical-align: inherit;">und uns Laichprozesse für deren Verarbeitung organisiert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit, Radieschen hinzuzufügen, abhängig von Einstellungen und Verkabelung!</font></font><br><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/requirements.txt +++ b/requirements.txt @@ -3,3 +3,5 @@ flask-cors gevent gunicorn pymongo +redis +rq --- a/backend/dev_settings.py +++ b/backend/dev_settings.py @@ -1,3 +1,7 @@ MONGO_HOST = "mongo" MONGO_PORT = 27017 MONGO_DATABASE = "core" +REDIS_HOST = "redis" +REDIS_PORT = 6379 +REDIS_DB = 0 +TASK_QUEUE_NAME = "tasks" --- a/backend/wiring.py +++ b/backend/wiring.py @@ -2,6 +2,8 @@ import os from pymongo import MongoClient from pymongo.database import Database +import redis +import rq import backend.dev_settings from backend.storage.card import CardDAO @@ -21,3 +23,11 @@ class Wiring(object): port=self.settings.MONGO_PORT) self.mongo_database: Database = self.mongo_client[self.settings.MONGO_DATABASE] self.card_dao: CardDAO = MongoCardDAO(self.mongo_database) + + self.redis: redis.Redis = redis.StrictRedis( + host=self.settings.REDIS_HOST, + port=self.settings.REDIS_PORT, + db=self.settings.REDIS_DB) + self.task_queue: rq.Queue = rq.Queue( + name=self.settings.TASK_QUEUE_NAME, + connection=self.redis)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein bisschen Code für den Arbeiter. </font></font><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># worker/__main__.py import argparse import uuid import rq import backend.wiring parser = argparse.ArgumentParser(description="Run worker.") #   ,      #  .  ,       rq. parser.add_argument( "--burst", action="store_const", const=True, default=False, help="enable burst mode") args = parser.parse_args() #       Redis. wiring = backend.wiring.Wiring() with rq.Connection(wiring.redis): w = rq.Worker( queues=[wiring.settings.TASK_QUEUE_NAME], #         # ,    . name=uuid.uuid4().hex) w.work(burst=args.burst)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbinden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für das Parsen selbst die </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Mistune-</font></a><font style="vertical-align: inherit;"> Bibliothek </font><font style="vertical-align: inherit;">und schreiben Sie eine einfache Funktion:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># backend/tasks/parse.py import mistune from backend.storage.card import CardDAO def parse_card_markup(card_dao: CardDAO, card_id: str): card = card_dao.get_by_id(card_id) card.html = _parse_markdown(card.markdown) card_dao.update(card) _parse_markdown = mistune.Markdown(escape=True, hard_wrap=False)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logischerweise: Wir müssen </font></font><code>CardDAO</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Quellcode der Karte erhalten und das Ergebnis speichern. </font><font style="vertical-align: inherit;">Ein Objekt, das eine Verbindung zu einem externen Speicher enthält, kann jedoch nicht über pickle serialisiert werden. Dies bedeutet, dass diese Aufgabe nicht sofort übernommen und für RQ in die Warteschlange gestellt werden kann. </font><font style="vertical-align: inherit;">Auf eine gute Weise müssen wir </font></font><code>Wiring</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen Arbeiter auf die Seite stellen und ihn in alle möglichen Richtungen werfen ... Lass es uns tun:</font></font><br><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/worker/__main__.py +++ b/worker/__main__.py @@ -2,6 +2,7 @@ import argparse import uuid import rq +from rq.job import Job import backend.wiring @@ -16,8 +17,23 @@ args = parser.parse_args() wiring = backend.wiring.Wiring() + +class JobWithWiring(Job): + + @property + def kwargs(self): + result = dict(super().kwargs) + result["wiring"] = backend.wiring.Wiring() + return result + + @kwargs.setter + def kwargs(self, value): + super().kwargs = value + + with rq.Connection(wiring.redis): w = rq.Worker( queues=[wiring.settings.TASK_QUEUE_NAME], - name=uuid.uuid4().hex) + name=uuid.uuid4().hex, + job_class=JobWithWiring) w.work(burst=args.burst)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben unsere Klasse von Jobs deklariert und die Verkabelung als zusätzliches Argument für alle Probleme verwendet. </font><font style="vertical-align: inherit;">(Beachten Sie, dass jedes Mal eine NEUE Verkabelung erstellt wird, da einige Clients nicht vor dem Fork erstellt werden können, der in RQ vor der Verarbeitung der Aufgabe auftritt.) Damit alle unsere Aufgaben nicht von der Verkabelung abhängen, dh von ALLEN unseren Objekten, lassen Sie uns Machen wir einen Dekorateur, der nur das Nötigste aus der Verkabelung herausholt:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># backend/tasks/task.py import functools from typing import Callable from backend.wiring import Wiring def task(func: Callable): #    : varnames = func.__code__.co_varnames @functools.wraps(func) def result(*args, **kwargs): #  .  .pop(),     # ,        . wiring: Wiring = kwargs.pop("wiring") wired_objects_by_name = wiring.__dict__ for arg_name in varnames: if arg_name in wired_objects_by_name: kwargs[arg_name] = wired_objects_by_name[arg_name] #          #   ,  -   . return func(*args, **kwargs) return result</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fügen Sie unserer Aufgabe einen Dekorateur hinzu und genießen Sie das Leben: </font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mistune <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> backend.storage.card <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CardDAO <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> backend.tasks.task <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> task @task <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_card_markup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(card_dao: CardDAO, card_id: str)</span></span></span><span class="hljs-function">:</span></span> card = card_dao.get_by_id(card_id) card.html = _parse_markdown(card.markdown) card_dao.update(card) _parse_markdown = mistune.Markdown(escape=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hard_wrap=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Leben genießen? </font><font style="vertical-align: inherit;">Ugh, ich wollte sagen, wir starten den Arbeiter:</font></font><br><br><pre> <code class="plaintext hljs">$ docker-compose up worker ... Creating habr-app-demo_worker_1 ... done Attaching to habr-app-demo_worker_1 worker_1 | 17:21:03 RQ worker 'rq:worker:49a25686acc34cdfa322feb88a780f00' started, version 0.13.0 worker_1 | 17:21:03 *** Listening on tasks... worker_1 | 17:21:03 Cleaning registries for queue: tasks</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">III ... er macht nichts! </font><font style="vertical-align: inherit;">Natürlich, weil wir keine einzige Aufgabe gestellt haben! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schreiben wir unser Tool, das eine Testkarte erstellt, so um, dass es: a) nicht herunterfällt, wenn die Karte bereits erstellt wurde (wie in unserem Fall); </font><font style="vertical-align: inherit;">b) Aufgabe beim Parsen von Marqdown.</font></font><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># tools/add_test_content.py from backend.storage.card import Card, CardNotFound from backend.tasks.parse import parse_card_markup from backend.wiring import Wiring wiring = Wiring() try: card = wiring.card_dao.get_by_slug("helloworld") except CardNotFound: card = wiring.card_dao.create(Card( slug="helloworld", name="Hello, world!", markdown=""" This is a hello-world page. """)) # ,   card_dao.get_or_create,  #      ! wiring.task_queue.enqueue_call( parse_card_markup, kwargs={"card_id": card.id})</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tools können jetzt nicht nur im Backend, sondern auch auf dem Worker ausgeführt werden. </font><font style="vertical-align: inherit;">Im Prinzip ist uns das jetzt egal. </font><font style="vertical-align: inherit;">Wir starten es </font></font><code>docker-compose exec worker python -m tools.add_test_content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und in einem benachbarten Tab des Terminals sehen wir ein Wunder - der Arbeiter hat ETWAS getan!</font></font><br><br><pre> <code class="plaintext hljs">worker_1 | 17:34:26 tasks: backend.tasks.parse.parse_card_markup(card_id='5c715dd1e201ce000c6a89fa') (613b53b1-726b-47a4-9c7b-97cad26da1a5) worker_1 | 17:34:27 tasks: Job OK (613b53b1-726b-47a4-9c7b-97cad26da1a5) worker_1 | 17:34:27 Result is kept for 500 seconds</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem wir den Container mit dem Backend neu erstellt haben, können wir endlich den Inhalt unserer Karte im Browser sehen: </font></font><br><br><img src="https://habrastorage.org/webt/ii/5f/zb/ii5fzb_nh2p4-hbv7obhjmxr5kk.png"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Frontend-Navigation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir zu SSR übergehen, müssen wir all unsere Reaktionsreaktionen ein wenig aussagekräftig machen und unsere Einzelseitenanwendung wirklich zu einer einzigen Seite machen. </font><font style="vertical-align: inherit;">Lassen Sie uns unser Tool aktualisieren, um zwei (NICHT EINE, ZWEI! MAMMA, ICH JETZT BIG DATE DEVELOPER!) Karten zu erstellen, die miteinander verknüpft sind, und dann werden wir uns mit der Navigation zwischen ihnen befassen.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Versteckter Text</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># tools/add_test_content.py def create_or_update(card): try: card.id = wiring.card_dao.get_by_slug(card.slug).id card = wiring.card_dao.update(card) except CardNotFound: card = wiring.card_dao.create(card) wiring.task_queue.enqueue_call( parse_card_markup, kwargs={"card_id": card.id}) create_or_update(Card( slug="helloworld", name="Hello, world!", markdown=""" This is a hello-world page. It can't really compete with the [demo page](demo). """)) create_or_update(Card( slug="demo", name="Demo Card!", markdown=""" Hi there, habrovchanin. You've probably got here from the awkward ["Hello, world" card](helloworld). Well, **good news**! Finally you are looking at a **really cool card**! """ ))</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir den Links folgen und überlegen, wie unsere wunderbare Anwendung jedes Mal neu gestartet wird. </font><font style="vertical-align: inherit;">Hör auf! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setzen Sie Ihren Handler zunächst auf Klicks auf die Links. </font><font style="vertical-align: inherit;">Da HTML mit Links aus dem Backend stammt und die Anwendung mit React ausgeführt wird, benötigen wir einen kleinen reaktionsspezifischen Fokus.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/components/card.js class Card extends Component { componentDidMount() { document.title = this.props.name } navigate(event) { //       .  //      ,    . if (event.target.tagName === 'A' &amp;&amp; event.target.hostname === window.location.hostname) { //     event.preventDefault(); //      this.props.dispatch(navigate(event.target)); } } render() { const {name, html} = this.props; return ( &lt;div&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;div dangerouslySetInnerHTML={{__html: html}} onClick={event =&gt; this.navigate(event)} /&gt; &lt;/div&gt; ); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die gesamte Logik beim Laden der Karten in unserer Komponente </font></font><code>CardPage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Aktion selbst (erstaunlich!), Muss keine Aktion ausgeführt werden:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">link</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: NAVIGATE, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: link.pathname } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fügen Sie für diesen Fall einen albernen Reduzierer hinzu: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/reducers.js import { START_FETCHING_CARD, FINISH_FETCHING_CARD, NAVIGATE } from "./actions"; function navigate(state, path) { //     react-router,    ! // (       SSR.) let m = /^\/card\/([^/]+)$/.exec(path); if (m !== null) { return { ...state, page: { type: "card", cardSlug: m[1], isFetching: true } }; } return state } export default function root(state = {}, action) { switch (action.type) { case START_FETCHING_CARD: return { ...state, page: { ...state.page, isFetching: true } }; case FINISH_FETCHING_CARD: return { ...state, page: { ...state.page, isFetching: false, cardData: action.cardData } }; case NAVIGATE: return navigate(state, action.path) } return state; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da sich jetzt der Status unserer Anwendung ändern kann, müssen </font></font><code>CardPage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir eine Methode hinzufügen, die </font></font><code>componentDidUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit der bereits hinzugefügten identisch ist </font></font><code>componentWillMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nach dem Aktualisieren der Eigenschaften </font></font><code>CardPage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(z. B. Eigenschaften </font></font><code>cardSlug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">während der Navigation) wird nun auch der Inhalt der Karte aus dem Backend angefordert (dies </font></font><code>componentWillMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geschah erst, als die Komponente initialisiert wurde). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Okay, </font></font><code>docker-compose up --build frontend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und wir haben eine funktionierende Navigation! </font></font><br><br><img src="https://habrastorage.org/webt/4l/ov/b_/4lovb_vai0fxv0tjx6zfcmwb8y8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein aufmerksamer Leser wird feststellen, dass sich die URL der Seite beim Navigieren zwischen Karten nicht ändert - selbst im Screenshot sehen wir Hallo, die Weltkarte an der Adresse der Demokarte. </font><font style="vertical-align: inherit;">Dementsprechend fiel auch die Vorwärts-Rückwärts-Navigation ab. </font><font style="vertical-align: inherit;">Fügen wir sofort etwas schwarze Magie mit Geschichte hinzu, um das Problem zu beheben! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Einfachste, was Sie tun können, ist, der Aktion etwas hinzuzufügen.</font></font><code>navigate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Herausforderung </font></font><code>history.pushState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">link</span></span></span><span class="hljs-function">) </span></span>{ history.pushState(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, link.href); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: NAVIGATE, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: link.pathname } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie nun auf die Links klicken, ändert sich die URL in der Adressleiste des Browsers wirklich. </font><font style="vertical-align: inherit;">Der Zurück-Knopf </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird jedoch brechen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit es funktioniert, müssen wir das Ereignis des </font></font><code>popstate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekts </font><font style="vertical-align: inherit;">abhören </font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn wir in diesem Fall sowohl vorwärts als auch rückwärts navigieren möchten (dh durch </font></font><code>dispatch(navigate(...))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), müssen wir der Funktion </font></font><code>navigate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein spezielles "Nicht </font></font><code>pushState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font><font style="vertical-align: inherit;">-Flag hinzufügen </font><font style="vertical-align: inherit;">(sonst wird alles noch mehr kaputt gehen!). </font><font style="vertical-align: inherit;">Um zwischen „unseren“ Zuständen zu unterscheiden, sollten wir außerdem die Möglichkeit nutzen </font></font><code>pushState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Metadaten zu speichern. </font><font style="vertical-align: inherit;">Es gibt viel Magie und Debugging, also lasst uns gleich zum Code kommen! </font><font style="vertical-align: inherit;">So sieht die App aus:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/components/app.js class App extends Component { componentDidMount() { //     --   //      "". history.replaceState({ pathname: location.pathname, href: location.href }, ""); //     . window.addEventListener("popstate", event =&gt; this.navigate(event)); } navigate(event) { //    "" ,   //        ,    //   (or is it a good thing?..) if (event.state &amp;&amp; event.state.pathname) { event.preventDefault(); event.stopPropagation(); //      "  pushState". this.props.dispatch(navigate(event.state, true)); } } render() { // ... } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und hier ist die Navigationsaktion: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/actions.js export function navigate(link, dontPushState) { if (!dontPushState) { history.pushState({ pathname: link.pathname, href: link.href }, "", link.href); } return { type: NAVIGATE, path: link.pathname } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt wird die Geschichte funktionieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun, die letzte Berührung: Da wir jetzt eine Aktion haben </font></font><code>navigate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, warum geben wir nicht den zusätzlichen Code im Client auf, der den Anfangszustand berechnet? </font><font style="vertical-align: inherit;">Wir können einfach die Navigation zum aktuellen Standort anrufen:</font></font><br><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/frontend/src/client.js +++ b/frontend/src/client.js @@ -3,23 +3,16 @@ import {render} from 'react-dom' import {Provider} from 'react-redux' import App from './components/app' import configureStore from './redux/configureStore' +import {navigate} from "./redux/actions"; let initialState = { page: { type: "home" } }; -const m = /^\/card\/([^\/]+)$/.exec(location.pathname); -if (m !== null) { - initialState = { - page: { - type: "card", - cardSlug: m[1] - }, - } -} const store = configureStore(initialState); +store.dispatch(navigate(location));</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kopieren-Einfügen zerstört! </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Frontend: Serverseitiges Rendern </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist Zeit für unsere wichtigsten (meiner Meinung nach) Chips - SEO-Freundlichkeit. Damit Suchmaschinen unseren Inhalt indizieren können, der vollständig dynamisch in React-Komponenten erstellt wird, müssen wir in der Lage sein, ihnen das Ergebnis des Renderns von React zu geben und zu lernen, wie dieses Ergebnis wieder interaktiv gemacht werden kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das allgemeine Schema ist einfach. Erstens: Wir müssen den von unserer React-Komponente generierten HTML-Code in unsere HTML-Vorlage einfügen </font></font><code>App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dieser HTML-Code wird von Suchmaschinen (und Browsern mit deaktiviertem JS, hehe) angezeigt. Zweitens: Sie müssen der Vorlage ein Tag hinzufügen, das </font></font><code>&lt;script&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">irgendwo (z. B. ein Objekt </font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) einen Statusspeicherauszug </font><font style="vertical-align: inherit;">speichert, </font><font style="vertical-align: inherit;">aus dem dieser HTML-Code gerendert wurde. Dann können wir unsere Anwendung auf der Client-Seite sofort mit diesem Status initialisieren und zeigen, was benötigt wird (wir können sogar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hydrat verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf den generierten HTML-Code, um den DOM-Baum der Anwendung nicht neu zu erstellen). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit dem Schreiben einer Funktion, die gerenderten HTML-Code und den Endzustand zurückgibt.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/server.js import "@babel/polyfill" import React from 'react' import {renderToString} from 'react-dom/server' import {Provider} from 'react-redux' import App from './components/app' import {navigate} from "./redux/actions"; import configureStore from "./redux/configureStore"; export default function render(initialState, url) { //  store,    . const store = configureStore(initialState); store.dispatch(navigate(url)); let app = ( &lt;Provider store={store}&gt; &lt;App/&gt; &lt;/Provider&gt; ); // ,        ! // ,         ? let content = renderToString(app); let preloadedState = store.getState(); return {content, preloadedState}; };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fügen Sie unserer Vorlage, über die wir oben gesprochen haben, neue Argumente und Logik hinzu: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/template.js function template(title, initialState, content) { let page = ` &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;${title}&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;${content}&lt;/div&gt; &lt;script&gt; window.__STATE__ = ${JSON.stringify(initialState)} &lt;/script&gt; &lt;script src="/dist/client.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `; return page; } module.exports = template;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unser Express-Server wird etwas komplizierter: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/index.js app.get("*", (req, res) =&gt; { const initialState = { page: { type: "home" } }; const {content, preloadedState} = render(initialState, {pathname: req.url}); res.send(template("Habr demo app", preloadedState, content)); });</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aber der Kunde ist einfacher: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/client.js import React from 'react' import {hydrate} from 'react-dom' import {Provider} from 'react-redux' import App from './components/app' import configureStore from './redux/configureStore' import {navigate} from "./redux/actions"; //         ! const store = configureStore(window.__STATE__); // render   hydrate. hydrate    // DOM tree,       . hydrate( &lt;Provider store={store}&gt; &lt;App/&gt; &lt;/Provider&gt;, document.querySelector('#app') );</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Nächstes müssen Sie plattformübergreifende Fehler wie "Verlauf ist nicht definiert" bereinigen. </font><font style="vertical-align: inherit;">Fügen Sie dazu irgendwo in eine einfache (bisher) Funktion hinzu </font></font><code>utility.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/utility.js export function isServerSide() { //   ,      process, //     -   . return process.env.APP_ENV !== undefined; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann wird es eine bestimmte Anzahl von Routineänderungen geben, die ich hier nicht einbringen werde (aber sie finden Sie im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entsprechenden Commit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Dadurch kann unsere React-Anwendung sowohl im Browser als auch auf dem Server rendern.</font></font><br><br>  Es funktioniert!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber es gibt, wie sie sagen, eine Einschränkung ... </font></font><br><br><img src="https://habrastorage.org/webt/gd/ac/ut/gdacut18knqjvzftjhkkuhnzxgk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LADEN? Alles, was Google in meinem supercoolen Modedienst sieht, ist LADEN ?! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun, es scheint, dass all unser Asynchronismus gegen uns gespielt hat. Jetzt müssen wir dem Server eine Möglichkeit geben, zu verstehen, dass die Antwort vom Backend mit dem Inhalt der Karte warten muss, bevor die React-Anwendung in eine Zeichenfolge gerendert und an den Client gesendet wird. Und es ist wünschenswert, dass diese Methode ziemlich allgemein ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es kann viele Lösungen geben. Ein Ansatz besteht darin, in einer separaten Datei zu beschreiben, für welche Pfade welche Daten gesichert werden sollen, und dies vor dem Rendern der Anwendung ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Diese Lösung hat viele Vorteile. Es ist einfach, es ist explizit und es funktioniert.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Experiment (der ursprüngliche Inhalt sollte zumindest irgendwo im Artikel enthalten sein!) Schlage ich ein anderes Schema vor. </font><font style="vertical-align: inherit;">Lassen Sie uns jedes Mal, wenn wir etwas Asynchrones ausführen, auf das wir warten müssen, irgendwo in unserem Status das entsprechende Versprechen hinzufügen (z. B. das, das Fetch zurückgibt). </font><font style="vertical-align: inherit;">So haben wir einen Ort, an dem Sie immer überprüfen können, ob alles heruntergeladen wurde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie zwei neue Aktionen hinzu.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/actions.js function addPromise(promise) { return { type: ADD_PROMISE, promise: promise }; } function removePromise(promise) { return { type: REMOVE_PROMISE, promise: promise, }; }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste wird aufgerufen, wenn der Abruf gestartet wird, der zweite - am Ende </font></font><code>.then()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie nun ihre Verarbeitung zum Reduzierer hinzu:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/reducers.js export default function root(state = {}, action) { switch (action.type) { case ADD_PROMISE: return { ...state, promises: [...state.promises, action.promise] }; case REMOVE_PROMISE: return { ...state, promises: state.promises.filter(p =&gt; p !== action.promise) }; ...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt werden wir die Aktion verbessern </font></font><code>fetchCard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/actions.js function fetchCard() { return (dispatch, getState) =&gt; { dispatch(startFetchingCard()); let url = apiPath() + "/card/" + getState().page.cardSlug; let promise = fetch(url) .then(response =&gt; response.json()) .then(json =&gt; { dispatch(finishFetchingCard(json)); // " ,  " dispatch(removePromise(promise)); }); // "  ,  " return dispatch(addPromise(promise)); }; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es bleibt, dem </font></font><code>initialState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">leeren Array Versprechen </font><font style="vertical-align: inherit;">hinzuzufügen </font><font style="vertical-align: inherit;">und den Server auf sie alle warten zu lassen! </font><font style="vertical-align: inherit;">Die Renderfunktion wird asynchron und hat folgende Form:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/server.js function hasPromises(state) { return state.promises.length &gt; 0 } export default async function render(initialState, url) { const store = configureStore(initialState); store.dispatch(navigate(url)); let app = ( &lt;Provider store={store}&gt; &lt;App/&gt; &lt;/Provider&gt; ); //  renderToString     // (  ). CardPage     . renderToString(app); // ,   !    - //    (  // , ),     //    . let preloadedState = store.getState(); while (hasPromises(preloadedState)) { await preloadedState.promises[0]; preloadedState = store.getState() } //  renderToString.    HTML. let content = renderToString(app); return {content, preloadedState}; };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgrund der erfassten </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronität ist der Request-Handler auch etwas komplizierter:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/index.js app.get("*", (req, res) =&gt; { const initialState = { page: { type: "home" }, promises: [] }; render(initialState, {pathname: req.url}).then(result =&gt; { const {content, preloadedState} = result; const response = template("Habr demo app", preloadedState, content); res.send(response); }, (reason) =&gt; { console.log(reason); res.status(500).send("Server side rendering failed!"); }); });</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et voilà! </font></font><br><br><img src="https://habrastorage.org/webt/vt/ed/uj/vteduj-6tnshnodaw0setd3b0wu.png"><br><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie sehen, ist das Erstellen einer High-Tech-Anwendung nicht so einfach. </font><font style="vertical-align: inherit;">Aber nicht so schwer! </font><font style="vertical-align: inherit;">Die endgültige Anwendung befindet sich im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository von Github,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und theoretisch benötigen Sie nur Docker, um sie auszuführen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Artikel gefragt ist, wird dieses Repository nicht einmal verlassen! </font><font style="vertical-align: inherit;">Wir werden es mit etwas anderem Wissen betrachten können, das notwendig ist:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Protokollierung, Überwachung, Lasttest. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Testen, CI, CD. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coolere Funktionen wie Autorisierung oder Volltextsuche. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einrichtung und Entwicklung der Produktionsumgebung. </font></font></li></ul><br>  Vielen Dank für Ihre Aufmerksamkeit! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444446/">https://habr.com/ru/post/de444446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444434/index.html">Es ist Zeit für Java 12! Überprüfung der heißen JEPs</a></li>
<li><a href="../de444436/index.html">Was ist ein Mirai-Botnetz und wie kann ich meine Geräte schützen?</a></li>
<li><a href="../de444438/index.html">Eine kurze Geschichte von Open Source - wie freie Software mit proprietären kämpfte</a></li>
<li><a href="../de444442/index.html">Jetson Nano: Nvidia Machine Board Single Board</a></li>
<li><a href="../de444444/index.html">Die besten Fehler unserer Konferenzen (Joker, JPoint, DotNext, Mobius, TechTrain usw.)</a></li>
<li><a href="../de444448/index.html">Mirai Clone fügt Dutzende neuer Exploits für gezielte IoT-Geräte für Unternehmen hinzu</a></li>
<li><a href="../de444456/index.html">Atari 65XE - USB-Tastatur</a></li>
<li><a href="../de444460/index.html">Vom Parser des Python-Theaterplakats bis zum Telegrammbot. Teil 1</a></li>
<li><a href="../de444462/index.html">Testen des Samsung Galaxy S10 - Wann holen Smartphones Kameras ein?</a></li>
<li><a href="../de444464/index.html">Eine andere Möglichkeit, Ihr Bein mit std :: thread zu schießen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>