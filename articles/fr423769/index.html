<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👩🏻 🙏 🥚 Connexion d'OpenSSL à Mono ☝🏾 🤡 👨🏽‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans un article précédent, le processus d'intégration des certificats GOST de CryptoPro avec mono a été décrit. De même, nous nous attardons sur la co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Connexion d'OpenSSL à Mono</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423769/"><p>  Dans un article précédent, le processus d'intégration des certificats GOST de CryptoPro avec mono a été décrit.  De même, nous nous attardons sur la connexion des certificats RSA. </p><br><p>  Nous avons continué à porter l'un de nos systèmes serveurs écrits en C # vers Linux, et la file d'attente a atteint la partie liée à RSA.  Si la dernière fois les difficultés de connexion s'expliquaient facilement par l'interaction de deux systèmes qui n'étaient pas initialement connectés l'un à l'autre, alors lors de la connexion de certificats RSA «ordinaires» à partir de mono, personne ne s'attendait à une capture. </p><br><a name="habracut"></a><br><p>  L'installation du certificat et de la clé n'a pas posé de problème et le système l'a même vu dans le stockage standard.  Cependant, il n'était plus possible de signer, de crypter ou d'extraire des données à partir d'une signature précédemment générée - mono est tombé de manière stable avec une erreur.  Je devais, comme dans le cas de CryptoPro, me connecter directement à la bibliothèque de cryptage.  Pour les certificats RSA sous Linux, le principal candidat pour une telle connexion est OpenSSL. </p><br><h2>  Installation de certificat </h2><br><p>  Heureusement, Centos 7 dispose d'une version intégrée d'OpenSSL - 1.0.2k.  Afin de ne pas introduire de difficultés supplémentaires dans le système, nous avons décidé de nous connecter à cette version.  OpenSSL vous permet de créer des magasins de certificats de fichiers spéciaux, cependant: </p><br><ol><li>  un tel magasin contient des certificats et des listes de révocation de certificats, et non des clés privées, dans ce cas, ils devront être stockés séparément; </li><li>  le stockage de certificats et de clés privées dans Windows sur un disque sous une forme non sécurisée est «extrêmement précaire» (les responsables de la sécurité numérique le décrivent généralement de manière plus efficace et moins censurée), pour être honnête, ce n'est pas très sûr sous Linux, mais, en fait, c'est courant la pratique; </li><li>  la coordination de l'emplacement de ces référentiels sous Windows et Linux est assez problématique; </li><li>  en cas de mise en œuvre manuelle du stockage, un utilitaire sera nécessaire pour gérer l'ensemble des certificats; </li><li>  mono utilise lui-même le stockage sur disque avec une structure OpenSSL, et stocke également les clés privées sous une forme ouverte à proximité; </li></ol><br>  Pour ces raisons, nous utiliserons les magasins de certificats standard .Net et mono pour connecter OpenSSL.  Pour ce faire, sous Linux, le certificat et la clé privée doivent d'abord être placés dans le référentiel mono. <br><br><div class="spoiler">  <b class="spoiler_title">Installation de certificat</b> <div class="spoiler_text"> Pour cela, nous utiliserons l'utilitaire standard certmgr.  Tout d'abord, installez la clé privée de pfx: <br><br> <code>certmgr -importKey -c -p {password} My {pfx file}</code> <br> <br>  Ensuite, nous mettons le certificat de ce pfx, la clé privée s'y connectera automatiquement: <br><br> <code>certmgr -add -c My {cer file}</code> <br> <br>  Si vous souhaitez installer la clé dans le stockage de la machine, vous devez ajouter l'option -m. <br><br>  Après quoi le certificat peut être vu dans le référentiel: <br><br> <code>certmgr -list -c -v My</code> <br> <br>  Faites attention à l'émission.  Il convient de noter que le certificat est visible par le système et est lié à la clé privée téléchargée précédemment.  Après cela, vous pouvez procéder à la connexion dans le code. <br></div></div><br><h2>  Connexion en code </h2><br><p>  Tout comme la dernière fois, le système, malgré son portage sur Linux, aurait dû continuer à fonctionner dans l'environnement Windows.  Par conséquent, extérieurement, le travail avec la cryptographie devrait être effectué à l'aide de méthodes générales de la forme «octet [] SignData (octet [] _arData, X509Certificate2 _pCert)», qui devraient fonctionner de la même manière sous Linux et Windows. </p><br><p>  Idéalement, il devrait y avoir des méthodes qui fonctionnent comme sous Windows - quel que soit le type de certificat (sous Linux via OpenSSL ou CryptoPro selon le certificat, et sous Windows via crypt32). </p><br><p>  L'analyse des bibliothèques OpenSSL a montré que sous Windows, la bibliothèque principale est «libeay32.dll» et sous Linux «libcrypto.so.10».  Ainsi que la dernière fois, nous formons deux classes WOpenSSLAPI et LOpenSSLAPI, contenant une liste de méthodes de bibliothèque de bibliothèque: <br><br></p><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(CTRYPTLIB, CharSet = CharSet.Auto, SetLastError = true, CallingConvention = CallingConvention.Cdecl)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OPENSSL_init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>;</code> </pre><br><p>  Faites attention à la convention d'appel, contrairement à CryptoPro - ici, elle doit être explicitement spécifiée.  La syntaxe de connexion de chacune des méthodes devra cette fois être générée indépendamment sur la base des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichiers</a> source * .h OpenSSL. </p><br><p>  Les règles de base pour générer la syntaxe d'appel en C # à partir des données des fichiers .h sont les suivantes: </p><br><ol><li>  tout lien vers des structures, chaînes, etc. - IntPtr, y compris les liens au sein des structures elles-mêmes; </li><li>  liens vers des liens - réf IntPtr, si cette option ne fonctionne pas, alors juste IntPtr.  Dans ce cas, le lien lui-même devra être mis et supprimé manuellement; </li><li>  tableaux - octet []; </li><li>  long en C (OpenSSL) est un int en C # (une petite erreur, à première vue, peut se transformer en heures de recherche de la source d'erreurs imprévisibles); </li></ol><br><p>  Dans la déclaration, par habitude, vous pouvez spécifier SetLastError = true, mais la bibliothèque l'ignorera - les erreurs ne seront pas disponibles via Marshal.GetLastWin32Error ().  OpenSSL a ses propres méthodes pour accéder aux erreurs. </p><br><p>  Et puis nous formons la classe statique déjà familière "UOpenSSLAPI" qui, selon le système, appellera la méthode de l'une des deux classes: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> fpOSSection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  OpenSSL&lt;/summary&gt;**/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OPENSSL_init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (pOSSection) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fIsLinux) LOpenSSLAPI.OPENSSL_init(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> WOpenSSLAPI.OPENSSL_init(); } } <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;    OpenSSL&lt;/summary&gt;**/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> pOSSection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fpOSSection; } } <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt;**/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> fIsLinux { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iPlatform = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) Environment.OSVersion.Platform; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (iPlatform == <span class="hljs-number"><span class="hljs-number">4</span></span>) || (iPlatform == <span class="hljs-number"><span class="hljs-number">6</span></span>) || (iPlatform == <span class="hljs-number"><span class="hljs-number">128</span></span>); } }</code> </pre><br><p>  Aussitôt, on note la présence d'une section critique.  OpenSSL fournit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">théoriquement du</a> travail dans un environnement multi-thread.  Mais, tout d'abord, immédiatement dans la description, il est dit que cela n'est pas garanti: </p><br><blockquote>  Mais vous ne pouvez toujours pas utiliser simultanément la plupart des objets dans plusieurs threads. </blockquote><br><p>  Et deuxièmement, la méthode de connexion n'est pas la plus triviale.  La machine virtuelle à deux cœurs habituelle (un serveur avec un processeur Intel Xeon E5649 en mode Hyper-Threading) lors de l'utilisation d'une telle section critique donne environ 100 cycles complets (voir l'algorithme de test de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> précédent) ou 600 signatures par seconde, ce qui est fondamentalement suffisant pour la plupart des tâches ( sous de lourdes charges, le microservice ou l'architecture nodale du système sera quand même utilisé). </p><br><h2>  Initialisation et déchargement d'OpenSSL </h2><br><p>  Contrairement à CryptoPro, OpenSSL nécessite certaines actions avant de commencer à l'utiliser et après avoir fini de travailler avec la bibliothèque: <br><br></p><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; OpenSSL&lt;/summary&gt;**/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitOpenSSL</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { UOpenSSLAPI.OPENSSL_init(); UOpenSSLAPI.ERR_load_crypto_strings(); UOpenSSLAPI.ERR_load_RSA_strings(); UOpenSSLAPI.OPENSSL_add_all_algorithms_conf(); UOpenSSLAPI.OpenSSL_add_all_ciphers(); UOpenSSLAPI.OpenSSL_add_all_digests(); } <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; OpenSSL&lt;/summary&gt;**/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CleanupOpenSSL</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { UOpenSSLAPI.EVP_cleanup(); UOpenSSLAPI.CRYPTO_cleanup_all_ex_data(); UOpenSSLAPI.ERR_free_strings(); }</code> </pre><br><br><h2>  Informations sur l'erreur </h2><br><p>  OpenSSL stocke les informations d'erreur dans les structures internes pour lesquelles il existe des méthodes spéciales dans la bibliothèque.  Malheureusement, certaines des méthodes simples, telles que ERR_error_string, sont instables, vous devez donc utiliser des méthodes plus complexes: </p><br><div class="spoiler">  <b class="spoiler_title">Obtention d'informations sur les erreurs</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;    OpenSSL&lt;/summary&gt; * &lt;param name="_iErr"&gt; &lt;/param&gt; * &lt;param name="_iPart"&gt;&lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetErrStrPart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ulong</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _iErr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _iPart</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)    IntPtr hErrStr = IntPtr.Zero; switch (_iPart) { case 0: hErrStr = UOpenSSLAPI.ERR_lib_error_string(_iErr); break; case 1: hErrStr = UOpenSSLAPI.ERR_func_error_string(_iErr); break; case 2: hErrStr = UOpenSSLAPI.ERR_reason_error_string(_iErr); break; } // 1)   return PtrToFirstStr(hErrStr); } /**&lt;summary&gt;    OpenSSL&lt;/summary&gt; * &lt;param name="_iErr"&gt; &lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/ public static string GetErrStr(ulong _iErr ) { return UCConsts.S_GEN_LIB_ERR_MAKRO.Frm(_iErr, GetErrStrPart(_iErr, 0), GetErrStrPart(_iErr, 1), GetErrStrPart(_iErr, 2)); } /**&lt;summary&gt;    OpenSSL&lt;/summary&gt; * &lt;returns&gt; &lt;/returns&gt; * **/ public static string GetErrStrOS() { return GetErrStr(UOpenSSLAPI.ERR_get_error()); }</span></span></code> </pre></div></div><br><p>  Une erreur dans OpenSSL contient des informations sur la bibliothèque dans laquelle elle s'est produite, la méthode et la raison.  Par conséquent, après avoir reçu le code d'erreur lui-même, il est nécessaire d'extraire ces trois parties séparément et de les rassembler dans une ligne de texte.  La longueur de chaque ligne, selon la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> OpenSSL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">,</a> ne dépasse pas 120 caractères, et comme nous utilisons du code managé, nous devons soigneusement extraire la ligne du lien: </p><br><div class="spoiler">  <b class="spoiler_title">Obtention d'une chaîne par IntPtr</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;    PChar     _iLen&lt;/summary&gt; * &lt;param name="_hPtr"&gt;    &lt;/param&gt; * &lt;param name="_iLen"&gt;  &lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PtrToFirstStr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hPtr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _iLen = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">256</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_hPtr == IntPtr.Zero) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] arStr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[_iLen]; Marshal.Copy(_hPtr, arStr, <span class="hljs-number"><span class="hljs-number">0</span></span>, arStr.Length); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] arRes = Encoding.ASCII.GetString(arStr).Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> }, StringSplitOptions.RemoveEmptyEntries); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arRes.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arRes[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>; } }</code> </pre></div></div><br><p>  Les erreurs lors de la vérification des certificats ne font pas partie de la liste générale et doivent être extraites par une méthode distincte, selon le contexte de vérification: </p><br><div class="spoiler">  <b class="spoiler_title">Recevoir une erreur de vérification de certificat</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;   &lt;/summary&gt; * &lt;param name="_hStoreCtx"&gt; &lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCertVerifyErr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hStoreCtx</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iErr = UOpenSSLAPI.X509_STORE_CTX_get_error(_hStoreCtx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PtrToFirstStr(UOpenSSLAPI.X509_verify_cert_error_string(iErr)); }</code> </pre></div></div><br><h2>  Recherche de certificat </h2><br><p>  Comme toujours, la cryptographie commence par une recherche de certificat.  Nous utilisons un stockage à temps plein, nous allons donc rechercher en utilisant des méthodes régulières: </p><br><div class="spoiler">  <b class="spoiler_title">Recherche de certificat</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  (   )&lt;/summary&gt; * &lt;param name="_pFindType"&gt; &lt;/param&gt; * &lt;param name="_pFindValue"&gt; &lt;/param&gt; * &lt;param name="_pLocation"&gt; &lt;/param&gt; * &lt;param name="_pName"&gt; &lt;/param&gt; * &lt;param name="_pCert"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_fVerify"&gt; &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindCertificateOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _pFindValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError, StoreLocation _pLocation = StoreLocation.CurrentUser, StoreName _pName = StoreName.My, X509FindType _pFindType = X509FindType.FindByThumbprint, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _fVerify = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (UOpenSSLAPI.pOSSection) { <span class="hljs-comment"><span class="hljs-comment">// 0)    _pCert = null; X509Store pStore = new X509Store(_pName, _pLocation); X509Certificate2Collection pCerts = null; try { // 1)   pStore.Open(OpenFlags.ReadOnly); // 2)    ( , .. Verify  Linux  false) pCerts = pStore.Certificates.Find(_pFindType, _pFindValue, false); if (pCerts.Count == 0) return UConsts.E_NO_CERTIFICATE; // 3)     if (!_fVerify) { _pCert = ISDP_X509Cert.Create(pCerts[0], TCryptoPath.cpOpenSSL); return UConsts.S_OK; } // 4)       foreach (X509Certificate2 pCert in pCerts) { ISDP_X509Cert pISDPCert = ISDP_X509Cert.Create(pCert, TCryptoPath.cpOpenSSL); if (pISDPCert.ISDPVerify()) { _pCert = pISDPCert; return UConsts.S_OK; } } return UConsts.E_NO_CERTIFICATE; } finally { if(pCerts != null) pCerts.Clear(); pStore.Close(); } } }</span></span></code> </pre></div></div><br><p>  Faites attention à la section critique.  Mono avec certificats fonctionne également via OpenSSL, mais pas via UOpenSSLAPI.  Si vous ne le faites pas ici, vous pouvez obtenir des fuites de mémoire et des erreurs flottantes incompréhensibles sous charge. </p><br><p>  La principale caractéristique est la création d'un certificat.  Contrairement à la version pour CryptoPro, dans ce cas, nous obtenons le certificat lui-même (X509Certificate2) à partir du magasin, et le lien dans Handle est déjà dirigé vers la structure OpenSSL X509_st.  Il semblerait que cela soit nécessaire, mais il n'y a pas de pointeur vers EVP_PKEY (lien vers la structure de clé privée dans OpenSSL) dans le certificat. <br></p><p>  Il s'est avéré que la clé privée elle-même est stockée en clair dans le champ interne du certificat - impl / fallback / _cert / _rsa / rsa.  Il s'agit de la classe RSAManaged, et un rapide coup d'œil à son code (par exemple, la méthode <a href="">DecryptValue</a> ) montre à quel point le mono est mauvais avec la cryptographie.  Au lieu d'utiliser honnêtement les techniques de cryptographie OpenSSL, ils semblent avoir implémenté plusieurs algorithmes manuellement.  Cette hypothèse est supportée par un résultat de recherche vide pour leur projet de méthodes OpenSSL telles que CMS_final, CMS_sign ou CMS_ContentInfo_new.  Et sans eux, il est difficile d'imaginer la formation d'une structure de signature CMS standard.  Dans le même temps, le travail avec les certificats est partiellement effectué via OpenSSL. </p><br><p>  Cela signifie que la clé privée devra être déchargée de mono et chargée dans EVP_PKEY via pem.  Pour cette raison, nous avons à nouveau besoin de l'héritier de classe de X509Certificate, qui stockera tous les liens supplémentaires. </p><br><p>  Voici quelques tentatives, comme dans le cas de CryptoPro pour créer un nouveau certificat à partir de Handle - ne mènent pas non plus au succès (les plantages mono avec une erreur), et la création sur la base du certificat reçu entraîne des fuites de mémoire.  Par conséquent, la seule option consiste à créer un certificat basé sur un tableau d'octets contenant pem.  Le certificat PEM peut être obtenu comme suit: </p><br><div class="spoiler">  <b class="spoiler_title">Obtention d'un certificat PEM</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;param name="_arData"&gt;  &lt;/param&gt; * &lt;param name="_fBase64"&gt; Base64&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToCerFile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _fBase64 = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span></span><span class="hljs-function">)</span></span> { _arData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] arData = _pCert.Export(X509ContentType.Cert); <span class="hljs-comment"><span class="hljs-comment">// 0) DER if (!_fBase64) { _arData = arData; return UConsts.S_OK; } // 1) Base64 using (TextWriter pWriter = new StringWriter()) { pWriter.WriteLine(UCConsts.S_PEM_BEGIN_CERT); pWriter.WriteLine(Convert.ToBase64String(arData, Base64FormattingOptions.InsertLineBreaks)); pWriter.WriteLine(UCConsts.S_PEM_END_CERT); // 1.2)   _arData = Encoding.UTF8.GetBytes(pWriter.ToString()); } return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_TO_PEM_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } }</span></span></code> </pre></div></div><br><p>  Le certificat est obtenu sans clé privée et nous le connectons nous-mêmes, formant un champ séparé pour un lien vers ENV_PKEY: </p><br><div class="spoiler">  <b class="spoiler_title">Génération d'ENV_PKEY basée sur la clé privée PEM</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; OpenSSL    (EVP_PKEY)    &lt;/summary&gt; * &lt;remarks&gt;      PEM&lt;/remarks&gt; * &lt;param name="_arData"&gt;   &lt;/param&gt; * &lt;returns&gt;   (EVP_PKEY)&lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetENV_PKEYOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arData</span></span></span><span class="hljs-function">)</span></span> { IntPtr hBIOPem = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   BIO hBIOPem = UOpenSSLAPI.BIO_new_mem_buf( _arData, _arData.Length); if (hBIOPem == IntPtr.Zero) return IntPtr.Zero; IntPtr hKey = IntPtr.Zero; // 1)     UOpenSSLAPI.PEM_read_bio_PrivateKey(hBIOPem, ref hKey, IntPtr.Zero, 0); return hKey; } finally { if(hBIOPem != IntPtr.Zero) UOpenSSLAPI.BIO_free(hBIOPem); } }</span></span></code> </pre></div></div><br><p>  En téléchargeant la clé privée dans PEM, la tâche est beaucoup plus compliquée que le certificat PEM, mais elle est déjà décrite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Notez que le déchargement de la clé privée est une activité «extrêmement dangereuse», et cela doit être évité de toutes les manières.  Et comme un tel déchargement est nécessaire pour travailler avec OpenSSL, dans Windows, il est préférable d'utiliser les méthodes crypt32.dll ou les classes .Net normales lors de l'utilisation de cette bibliothèque.  Sous Linux, pour l'instant, vous devez travailler comme ça. </p><br><p>  Il convient également de rappeler que les liens générés indiquent une zone de mémoire non gérée et doivent être libérés.  Parce que  dans .Net 4.5 X509Certificate2 n'est pas jetable, vous devez le faire dans le destructeur </p><br><h2>  Signature </h2><br><p>  Pour signer OpenSSL, vous pouvez utiliser la méthode CMS_sign simplifiée, cependant, elle s'appuie sur un fichier de configuration pour choisir un algorithme, qui sera le même pour tous les certificats.  Par conséquent, il est préférable de s'appuyer sur le <a href="">code de</a> cette méthode pour implémenter une génération de signature similaire: </p><br><div class="spoiler">  <b class="spoiler_title">Signature des données</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt; * &lt;param name="_arData"&gt;  &lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_arRes"&gt; &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SignDataOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arData, X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arRes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _arRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iFlags = UCConsts.CMS_DETACHED; IntPtr hData = IntPtr.Zero; IntPtr hBIORes = IntPtr.Zero; IntPtr hCMS = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   ISDP_X509Cert pCert = ISDP_X509Cert.Convert(_pCert, TCryptoPath.cpOpenSSL); // 1)  BIO   int iRes = GetBIOByBytesOS(_arData, out hData, ref _sError); if (iRes != UConsts.S_OK) return iRes; // 2)   BIO hBIORes = UOpenSSLAPI.BIO_new(UOpenSSLAPI.BIO_s_mem()); // 3)    hCMS = UOpenSSLAPI.CMS_ContentInfo_new(); if (hCMS == IntPtr.Zero) return RetErrOS(ref _sError, UCConsts.S_OS_CMS_CR_ERR); if (!UOpenSSLAPI.CMS_SignedData_init(hCMS)) return RetErrOS(ref _sError, UCConsts.S_OS_CMS_INIT_ERR); // 4)   if(UOpenSSLAPI.CMS_add1_signer(hCMS, pCert.hRealHandle, pCert.hOSKey, pCert.hOSDigestAlg, iFlags) == IntPtr.Zero) return RetErrOS(ref _sError, UCConsts.S_OS_CMS_SET_SIGNER_ERR); // 5)   -   if (!UOpenSSLAPI.CMS_set_detached(hCMS, 1)) return RetErrOS(ref _sError, UCConsts.S_OS_CMS_SET_DET_ERR); // 6)    if (!UOpenSSLAPI.CMS_final(hCMS, hData, IntPtr.Zero, iFlags)) return RetErrOS(ref _sError, UCConsts.S_OS_CMS_FINAL_ERR); // 7)    BIO if (!UOpenSSLAPI.i2d_CMS_bio_stream(hBIORes, hCMS, IntPtr.Zero, iFlags)) return RetErrOS(ref _sError, UCConsts.S_OS_CMS_EXP_TO_BIO_ERR); // 8)     BIO return ReadFromBIO_OS(hBIORes, out _arRes, ref _sError); } catch (Exception E) { _sError = UCConsts.S_SIGN_OS_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hBIORes != IntPtr.Zero) UOpenSSLAPI.BIO_free(hBIORes); if(hData != IntPtr.Zero) UOpenSSLAPI.BIO_free(hData); if(hCMS != IntPtr.Zero) UOpenSSLAPI.CMS_ContentInfo_free(hCMS); } }</span></span></code> </pre></div></div><br><p>  La progression de l'algorithme est la suivante.  Tout d'abord, convertissez le certificat entrant (s'il s'agit de X509Certificate2) en notre type.  Parce que  Puisque nous travaillons avec des liens vers une zone de mémoire non gérée, nous devons les surveiller attentivement.  .Net quelque temps après que le lien vers le certificat soit hors de portée, il lancera le destructeur.  Et nous y avons déjà prescrit précisément les méthodes nécessaires pour effacer toute la mémoire non gérée qui lui est associée.  Cette approche nous permet de ne pas perdre de temps à suivre ces liens directement à l'intérieur de la méthode. </p><br><p>  Après avoir traité le certificat, nous formons un BIO avec des données et une structure de signature.  Ensuite, nous ajoutons les données du signataire, définissons le drapeau pour déconnecter la signature et commençons la formation finale de la signature.  Le résultat est transféré à BIO.  Il ne reste plus qu'à extraire un tableau d'octets du BIO.  La conversion de BIO en un ensemble d'octets et vice versa est souvent utilisée, il est donc préférable de les placer dans une méthode distincte: </p><br><div class="spoiler">  <b class="spoiler_title">BIO en octet [] et vice versa</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  BIO    OpenSSL&lt;/summary&gt; * &lt;param name="_hBIO"&gt; BIO&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_arRes"&gt;&lt;/param&gt; * &lt;param name="_iLen"&gt; ,  0 -    &lt;/param&gt; * &lt;returns&gt;   ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFromBIO_OS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hBIO, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arRes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _iLen = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span> { _arRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; IntPtr hRes = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iLen = _iLen; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iLen == <span class="hljs-number"><span class="hljs-number">0</span></span>) iLen = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   iLen = UOpenSSLAPI.BIO_read(_hBIO, IntPtr.Zero, int.MaxValue); // 1)      hRes = Marshal.AllocHGlobal((int)iLen); if (UOpenSSLAPI.BIO_read(_hBIO, hRes, iLen) != iLen) { _sError = UCConsts.S_OS_BIO_READ_LEN_ERR; return UConsts.E_CRYPTO_ERR; } // 2)   _arRes = new byte[iLen]; Marshal.Copy(hRes, _arRes, 0, _arRes.Length); return UConsts.S_OK;; } catch (Exception E) { _sError = UCConsts.S_OS_BIO_READ_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hRes != IntPtr.Zero) Marshal.FreeHGlobal(hRes); } } /**&lt;summary&gt; BIO   &lt;/summary&gt; * &lt;param name="_arData"&gt;&lt;/param&gt; * &lt;param name="_hBIO"&gt;   BIO&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/ internal static int GetBIOByBytesOS(byte[] _arData, out IntPtr _hBIO, ref string _sError) { _hBIO = UOpenSSLAPI.BIO_new_mem_buf( _arData, _arData.Length); if (_hBIO == IntPtr.Zero) return RetErrOS(ref _sError, UCConsts.S_OS_CM_BIO_CR_ERR); return UConsts.S_OK; }</span></span></code> </pre></div></div><br><p>  Comme dans le cas de CryptoPro, il est nécessaire d'extraire des informations sur l'algorithme de hachage de signature du certificat.  Mais dans le cas d'OpenSSL, il est stocké directement dans le certificat: </p><br><div class="spoiler">  <b class="spoiler_title">Récupération d'un algorithme de hachage</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;      OpenSSL&lt;/summary&gt; * &lt;param name="_hCert"&gt;  (X509)&lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDigestAlgOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCert</span></span></span><span class="hljs-function">)</span></span> { x509_st pCert = (x509_st)Marshal.PtrToStructure(_hCert, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(x509_st)); X509_algor_st pAlgInfo = (X509_algor_st)Marshal.PtrToStructure(pCert.sig_alg, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(X509_algor_st)); IntPtr hAlgSn = UOpenSSLAPI.OBJ_nid2sn(UOpenSSLAPI.OBJ_obj2nid(pAlgInfo.algorithm)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UOpenSSLAPI.EVP_get_digestbyname(hAlgSn); }</code> </pre></div></div><br><p>  La méthode s'est avérée assez délicate, mais elle fonctionne.  Vous pouvez trouver la méthode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">EVP_get_digestbynid</a> dans la documentation 1.0.2, mais les bibliothèques de la version que nous utilisons ne l'exportent pas.  Par conséquent, nous formons d'abord nid, et sur sa base un nom court.  Et déjà par un nom court, vous pouvez extraire l'algorithme de la manière habituelle de recherche par nom. </p><br><h2>  Vérification de signature </h2><br><p>  La signature reçue doit être vérifiée.  OpenSSL vérifie la signature comme suit: </p><br><div class="spoiler">  <b class="spoiler_title">Vérification de signature</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_arData"&gt;,   &lt;/param&gt; * &lt;param name="_arSign"&gt;&lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_pLocation"&gt;&lt;/param&gt; * &lt;param name="_fVerifyOnlySign"&gt;  &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * &lt;remarks&gt;   &lt;/remarks&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckSignOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arSign, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _fVerifyOnlySign = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">, StoreLocation _pLocation = StoreLocation.CurrentUser</span></span></span><span class="hljs-function">)</span></span>{ _pCert = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; IntPtr hBIOData = IntPtr.Zero; IntPtr hCMS = IntPtr.Zero; IntPtr hTrStore = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)  BIO     int iRes = GetBIOByBytesOS(_arData, out hBIOData, ref _sError); if (iRes != UConsts.S_OK) return iRes; // 1)   CMS iRes = GetCMSFromBytesOS(_arSign, out hCMS, ref _sError); if (iRes != UConsts.S_OK) return iRes; uint iFlag = UCConsts.CMS_DETACHED; // 2)    if (!_fVerifyOnlySign) { iRes = GetTrustStoreOS(_pLocation, out hTrStore, ref _sError); if (iRes != UConsts.S_OK) return iRes; } else iFlag |= UCConsts.CMS_NO_SIGNER_CERT_VERIFY; // 3)   if (!UOpenSSLAPI.CMS_verify(hCMS, IntPtr.Zero, hTrStore, hBIOData, IntPtr.Zero, iFlag)) return RetErrOS(ref _sError, UCConsts.S_OS_CM_CHECK_ERR); return UConsts.S_OK; } finally { if(hBIOData != IntPtr.Zero) UOpenSSLAPI.BIO_free(hBIOData); if(hCMS != IntPtr.Zero) UOpenSSLAPI.CMS_ContentInfo_free(hCMS); if(hTrStore != IntPtr.Zero) UOpenSSLAPI.X509_STORE_free(hTrStore); } }</span></span></code> </pre></div></div><br><p>  Tout d'abord, les données de signature sont converties du tableau d'octets dans la structure CMS: <br></p><br><div class="spoiler">  <b class="spoiler_title">Formation de la structure CMS</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; CMS   &lt;/summary&gt; * &lt;param name="_arData"&gt; CMS&lt;/param&gt; * &lt;param name="_hCMS"&gt;    CMS&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCMSFromBytesOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntPtr _hCMS, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _hCMS = IntPtr.Zero; IntPtr hBIOCMS = IntPtr.Zero; IntPtr hCMS = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   CMS hCMS = UOpenSSLAPI.CMS_ContentInfo_new(); if (hCMS == IntPtr.Zero) return RetErrOS(ref _sError); if (!UOpenSSLAPI.CMS_SignedData_init(hCMS)) return RetErrOS(ref _sError); // 1)    BIO hBIOCMS = UOpenSSLAPI.BIO_new_mem_buf(_arData, _arData.Length); if (hBIOCMS == IntPtr.Zero) return RetErrOS(ref _sError); // 2)   CMS if (UOpenSSLAPI.d2i_CMS_bio(hBIOCMS, ref hCMS) == IntPtr.Zero) return RetErrOS(ref _sError); // 3)   - ,    _hCMS = hCMS; hCMS = IntPtr.Zero; return UConsts.S_OK; } finally { if(hBIOCMS != IntPtr.Zero) UOpenSSLAPI.BIO_free(hBIOCMS); if(hCMS != IntPtr.Zero) UOpenSSLAPI.CMS_ContentInfo_free(hCMS); } }</span></span></code> </pre></div></div><br><p>     ,     BIO.    ,    ,        (  )      : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;    &lt;/summary&gt; * &lt;param name="_hStore"&gt;   &lt;/param&gt; * &lt;param name="_pLocation"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTrustStoreOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">StoreLocation _pLocation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntPtr _hStore, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _hStore = IntPtr.Zero; IntPtr hStore = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { List&lt;X509Certificate2&gt; pCerts = GetCertList(_pLocation, StoreName.Root, TCryptoPath.cpOpenSSL); pCerts.AddRange(GetCertList(_pLocation, StoreName.AuthRoot, TCryptoPath.cpOpenSSL)); <span class="hljs-comment"><span class="hljs-comment">// 1)   hStore = UOpenSSLAPI.X509_STORE_new(); foreach (X509Certificate2 pCert in pCerts) { //      (    ) UOpenSSLAPI.X509_STORE_add_cert(hStore, pCert.getRealHandle()); } // 2)   UOpenSSLAPI.ERR_clear_error(); _hStore = hStore; hStore = IntPtr.Zero; return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_FORM_TRUST_STORE_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if (hStore != IntPtr.Zero) UOpenSSLAPI.X509_STORE_free(hStore); }</span></span></code> </pre></div></div><br><p>         ,         (   ,    ).     CMS_Verify,    . </p><br><p>       (,       CRL),      iFlag   . </p><br><h2>    </h2><br><p>               .        ,   ,           .  .Net    — SignedCms,                   . </p><br><p>        (   ,     )        .         —     ,    . </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt; * &lt;param name="_arSign"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_arContent"&gt;  &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arSign, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arContent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { IntPtr hBIOData = IntPtr.Zero; IntPtr hCMS = IntPtr.Zero; IntPtr hCerts = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)    MS int iRes = UCUtils.GetCMSFromBytesOS(_arSign, out hCMS, ref _sError); if(iRes != UConsts.S_OK) return iRes; iRes = UCUtils.GetBIOByBytesOS(_arContent, out hBIOData, ref _sError); if(iRes != UConsts.S_OK) return iRes; // 1)   uint iFlags = UCConsts.CMS_NO_SIGNER_CERT_VERIFY; if(_arContent.Length == 0) iFlags |= UCConsts.CMS_NO_CONTENT_VERIFY; // 2)  CMS if (!UOpenSSLAPI.CMS_verify(hCMS, IntPtr.Zero, IntPtr.Zero, hBIOData, IntPtr.Zero, iFlags)) return UCUtils.RetErrOS(ref _sError, UCConsts.S_OS_CMS_VERIFY_ERR); // 3)   hCerts = UOpenSSLAPI.CMS_get0_signers(hCMS); int iCnt = UOpenSSLAPI.sk_num(hCerts); for (int i = 0; i &lt; iCnt; i++) { IntPtr hCert = UOpenSSLAPI.sk_value(hCerts, i); byte[] arData; iRes = UCUtils.GetCertBytesOS(hCert, out arData, ref _sError); if(iRes != UConsts.S_OK) return iRes; fpCertificates.Add(ISDP_X509Cert.Create(arData, TCryptoPath.cpOpenSSL)); } // 4)   IntPtr hSigners = UOpenSSLAPI.CMS_get0_SignerInfos(hCMS); iCnt = UOpenSSLAPI.sk_num(hSigners); for (int i = 0; i &lt; iCnt; i++) { IntPtr hSignerInfo = UOpenSSLAPI.sk_value(hSigners, i); // 4.1)    ISDPSignerInfo pInfo = new ISDPSignerInfo(this); iRes = pInfo.DecodeOS(hSignerInfo, ref _sError); if(iRes != UConsts.S_OK) return iRes; fpSignerInfos.Add(pInfo); } return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_OS_CMS_DECODE.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hCerts != IntPtr.Zero) UOpenSSLAPI.sk_free(hCerts); if(hBIOData != IntPtr.Zero) UOpenSSLAPI.BIO_free(hBIOData); if(hCMS != IntPtr.Zero) UOpenSSLAPI.CMS_ContentInfo_free(hCMS); } }</span></span></code> </pre></div></div><br><p>     ,      BIO     ( )   CMS,    .    ,          —        . </p><br><p>         (STACK_OF(X509)),      sk_pop,       .     ,          sk_value. </p><br><p>  ,         CMS_get0_signers  CMS_get1_certs.     ,   .      ,       ,         : </p><br><pre> <code class="hljs lisp">CRYPTO_add(<span class="hljs-name"><span class="hljs-name">&amp;cch-&gt;d</span></span>.certificate-&gt;references, <span class="hljs-number"><span class="hljs-number">1</span></span>, CRYPTO_LOCK_X509)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><p>   <a href="">1.1.0</a>    X509_up_ref,      . <br>         : </p><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;   &lt;/summary&gt; * &lt;param name="_hSignerInfo"&gt;Handler    (OpenSSL)&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hSignerInfo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)    int iRes = UCUtils.GetSignerInfoCertOS(_hSignerInfo, fpSignedCMS.pCertificates, out fpCertificate, ref _sError); if(iRes != UConsts.S_OK) return iRes; // 1)    uint iPos = UOpenSSLAPI.CMS_signed_get_attr_by_NID(_hSignerInfo, UCConsts.NID_pkcs9_signingTime, 0); IntPtr hAttr = UOpenSSLAPI.CMS_signed_get_attr(_hSignerInfo, iPos); IntPtr hDateTime = UOpenSSLAPI.X509_ATTRIBUTE_get0_data(hAttr, 0, UCConsts.V_ASN1_UTCTIME, IntPtr.Zero); asn1_string_st pDate = (asn1_string_st)Marshal.PtrToStructure(hDateTime, typeof(asn1_string_st)); // 2)   Pkcs9SigningTime byte[] arDateAttr = new byte[pDate.iLength]; Marshal.Copy(pDate.hData, arDateAttr, 0, (int)pDate.iLength); arDateAttr = new byte[] { (byte)UCConsts.V_ASN1_UTCTIME, (byte)pDate.iLength}.Concat(arDateAttr).ToArray(); fpSignedAttributes.Add(new Pkcs9SigningTime(arDateAttr)); return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_CMS_SIGNER_DEC_OS_ER.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } }</span></span></code> </pre></div></div><br><p>  ,    ,     .          ASN.1.      asn1_string_st         Pkcs9SigningTime. </p><br><p>    : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt; * &lt;param name="_hSignerInfo"&gt;  &lt;/param&gt; * &lt;param name="_pCert"&gt; &lt;/param&gt; * &lt;param name="_pCerts"&gt;   &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSignerInfoCertOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hSignerInfo, X509Certificate2Collection _pCerts, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _pCert = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)     IntPtr hKey = IntPtr.Zero; IntPtr hIssuer = IntPtr.Zero; IntPtr hSNO = IntPtr.Zero; if (!UOpenSSLAPI.CMS_SignerInfo_get0_signer_id(_hSignerInfo, ref hKey, ref hIssuer, ref hSNO)) return RetErrOS(ref _sError, UCConsts.S_GET_RECEIP_INFO_ERR); // 1)    string sSerial; int iRes = GetBinaryHexFromASNOS(hSNO, out sSerial, ref _sError); if(iRes != UConsts.S_OK) return iRes; X509Certificate2Collection pResCerts = _pCerts.Find(X509FindType.FindBySerialNumber, sSerial, false); if(pResCerts.Count == 0) return RetErrOS(ref _sError, UCConsts.S_NO_CERTIFICATE, UConsts.E_NO_CERTIFICATE); _pCert = pResCerts[0]; return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_GET_SIGN_INFO_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } }</span></span></code> </pre></div></div><br><p>        ,          .       asn1_string_st,         hex : </p><br><div class="spoiler"> <b class="spoiler_title"> hex    ANS.1</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; Hex     ASN.1&lt;/summary&gt; * &lt;param name="_hASN"&gt;   ASN.1&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_sHexData"&gt;   Hex&lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBinaryHexFromASNOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hASN, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sHexData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _sHexData = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { asn1_string_st pSerial = (asn1_string_st)Marshal.PtrToStructure(_hASN, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(asn1_string_st)); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] arStr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[pSerial.iLength]; Marshal.Copy(pSerial.hData, arStr, <span class="hljs-number"><span class="hljs-number">0</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)pSerial.iLength); _sHexData = arStr.ToHex().ToUpper(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UConsts.S_OK; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception E) { _sError = UCConsts.S_HEX_ASN_BINARY_ERR.Frm(E.Message); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UConsts.E_GEN_EXCEPTION; } }</code> </pre></div></div><br><p>      ,      ,    . </p><br><h2>  </h2><br><p>   OpenSSL    : </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_arInput"&gt;  &lt;/param&gt; * &lt;param name="_pReceipients"&gt;  &lt;/param&gt; * &lt;param name="_arRes"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;   ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EncryptDataOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arInput, List&lt;X509Certificate2&gt; _pReceipients, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arRes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _arRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iFlags = UCConsts.CMS_BINARY; IntPtr hData = IntPtr.Zero; IntPtr hReceipts = IntPtr.Zero; IntPtr hBIORes = IntPtr.Zero; IntPtr hCMS = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)  BIO     int iRes = GetBIOByBytesOS(_arInput, out hData, ref _sError); if (iRes != UConsts.S_OK) return iRes; // 1)     iRes = GetCertsStackOS(_pReceipients, out hReceipts, ref _sError); if (iRes != UConsts.S_OK) return iRes; // 2)  CMS hCMS = UOpenSSLAPI.CMS_encrypt(hReceipts, hData, UOpenSSLAPI.EVP_des_ede3_cbc(), iFlags); if (hCMS == IntPtr.Zero) return RetErrOS(ref _sError, UCConsts.S_ENC_CMS_ERR); // 3)  CMS  BIO hBIORes = UOpenSSLAPI.BIO_new(UOpenSSLAPI.BIO_s_mem()); if (!UOpenSSLAPI.i2d_CMS_bio_stream(hBIORes, hCMS, IntPtr.Zero, iFlags)) return RetErrOS(ref _sError, UCConsts.S_OS_CMS_EXP_TO_BIO_ERR); // 4)   BIO    return ReadFromBIO_OS(hBIORes, out _arRes, ref _sError); } catch (Exception E) { _sError = UCConsts.S_ENC_OS_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hBIORes != IntPtr.Zero) UOpenSSLAPI.BIO_free(hBIORes); if(hData != IntPtr.Zero) UOpenSSLAPI.BIO_free(hData); if(hCMS != IntPtr.Zero) UOpenSSLAPI.CMS_ContentInfo_free(hCMS); if(hReceipts != IntPtr.Zero) UOpenSSLAPI.sk_free(hReceipts); } }</span></span></code> </pre></div></div><br><p>    BIO      — .        .    ,       BIO    . OpenSSL      ,    ,    ,   .          EVP_des_ede3_cbc,       . </p><br><p>         , . .           OpenSSL: </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt;* &lt;param name="_hStack"&gt; &lt;/param&gt; * &lt;param name="_pCerts"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCertsStackOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;X509Certificate2&gt; _pCerts, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntPtr _hStack, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _hStack = IntPtr.Zero; IntPtr hStack = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { hStack = UOpenSSLAPI.sk_new_null(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (X509Certificate2 pCert <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _pCerts) { <span class="hljs-comment"><span class="hljs-comment">// 0)  ,     ISDP_X509Cert pLocCert = ISDP_X509Cert.Convert(pCert, TCryptoPath.cpOpenSSL); // 1)  UOpenSSLAPI.sk_push(hStack, pLocCert.hRealHandle); } _hStack = hStack; hStack = IntPtr.Zero; return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_GEN_CERT_STACK_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hStack != IntPtr.Zero) UOpenSSLAPI.sk_free(hStack); } }</span></span></code> </pre></div></div><br><h2>  </h2><br><p>     ,        .      : </p><br><ol><li> ,       ; </li><li>   ; </li><li>           ; </li><li>     ; </li><li>      BIO    ; </li></ol><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_arInput"&gt;  &lt;/param&gt; * &lt;param name="_arRes"&gt;&lt;/param&gt; * &lt;param name="_pLocation"&gt; ,  &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;returns&gt;  ,  UCOnsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecryptDataOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arInput, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arRes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError, StoreLocation _pLocation = StoreLocation.CurrentUser </span></span></span><span class="hljs-function">)</span></span> { _arRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; _pCert = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iFlag = UCConsts.CMS_BINARY; IntPtr hBIORes = IntPtr.Zero; IntPtr hCMS = IntPtr.Zero; X509Certificate2 pCert; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   CMS int iRes = GetCMSFromBytesOS(_arInput, out hCMS, ref _sError); if (iRes != UConsts.S_OK) return iRes; // 1)     IntPtr hReceipts = UOpenSSLAPI.CMS_get0_RecipientInfos(hCMS); int iCnt = UOpenSSLAPI.sk_num(hReceipts); for(int i = 0; i &lt; iCnt; i++) { IntPtr hRecep = UOpenSSLAPI.sk_value(hReceipts, i); iRes = GetRecepInfoCertOS(hRecep, _pLocation, out pCert, ref _sError); if (iRes != UConsts.S_OK &amp;&amp; iRes != UConsts.E_NO_CERTIFICATE) return iRes; // 1.1)   if (iRes == UConsts.E_NO_CERTIFICATE) continue; ISDP_X509Cert pLocCert = ISDP_X509Cert.Convert(pCert); // 1.2)    if (pLocCert.hOSKey == IntPtr.Zero) continue; // 1.3)   if (!UOpenSSLAPI.CMS_RecipientInfo_set0_pkey(hRecep, pLocCert.hOSKey)) return RetErrOS(ref _sError, UCConsts.S_OS_CMS_SET_DEC_KEY_ERR); try { // 1.4)  if (!UOpenSSLAPI.CMS_RecipientInfo_decrypt(hCMS, hRecep)) return RetErrOS(ref _sError, UCConsts.S_OS_CMS_REC_DEC_ERR); } finally { // !!      UOpenSSLAPI.CMS_RecipientInfo_set0_pkey(hRecep, IntPtr.Zero); } // 1.5)   hBIORes = UOpenSSLAPI.BIO_new(UOpenSSLAPI.BIO_s_mem()); if (!UOpenSSLAPI.CMS_decrypt(hCMS, IntPtr.Zero, pLocCert.hRealHandle, IntPtr.Zero, hBIORes, iFlag)) return RetErrOS(ref _sError, UCConsts.S_OS_CMS_FULL_DEC_ERR); _pCert = pLocCert; // 2)     BIO return ReadFromBIO_OS(hBIORes, out _arRes, ref _sError); } _sError = UCConsts.S_DEC_NO_CERT_ERR; return UConsts.E_NO_CERTIFICATE; } catch (Exception E) { _sError = UCConsts.S_DEC_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hBIORes != IntPtr.Zero) UOpenSSLAPI.BIO_free(hBIORes); if(hCMS != IntPtr.Zero) UOpenSSLAPI.CMS_ContentInfo_free(hCMS); } }</span></span></code> </pre></div></div><br><p>        .   ,          CMS_RecipientInfo_set0_pkey,       CMS,            . </p><br><p>  ,   ,       .        ,        .        : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt; * &lt;param name="_hRecep"&gt;  &lt;/param&gt; * &lt;param name="_pCert"&gt; &lt;/param&gt; * &lt;param name="_pLocation"&gt;   &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRecepInfoCertOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hRecep, StoreLocation _pLocation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _pCert = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)     IntPtr hKey = IntPtr.Zero; IntPtr hIssuer = IntPtr.Zero; IntPtr hSNO = IntPtr.Zero; if (!UOpenSSLAPI.CMS_RecipientInfo_ktri_get0_signer_id(_hRecep, ref hKey, ref hIssuer, ref hSNO)) return RetErrOS(ref _sError, UCConsts.S_GET_RECEIP_INFO_ERR); // 1)    string sSerial; int iRes = GetBinaryHexFromASNOS(hSNO, out sSerial, ref _sError); if(iRes != UConsts.S_OK) return iRes; // 2)   iRes = FindCertificateOS(sSerial, out _pCert, ref _sError, _pLocation, StoreName.My, X509FindType.FindBySerialNumber); if(iRes != UConsts.S_OK) return iRes; return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_GET_RECEIP_INFO_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } }</span></span></code> </pre></div></div><br><p>  CMS_RecipientInfo_ktri_get0_signer_id     ,        hSNO        .      . </p><br><p> C  ,  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> .          ktri —      .      OpenSSL    : CMS_RecipientInfo_kari_*, CMS_RecipientInfo_kekri_*   CMS_RecipientInfo_set0_password  pwri. </p><br><h2>   </h2><br><p>      ,          .               .        , . .         .  OpenSSL     .         (    ),      ,      . <br></p><p> ,  ,   ,           : </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;    OpenSSL&lt;/summary&gt; * &lt;param name="_iRevFlag"&gt; &lt;/param&gt; * &lt;param name="_iRevMode"&gt; &lt;/param&gt; * &lt;param name="_hCert"&gt; &lt;/param&gt; * &lt;param name="_rOnDate"&gt; &lt;/param&gt; * &lt;param name="_pLocation"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VerifyCertificateOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCert, X509RevocationMode _iRevMode, X509RevocationFlag _iRevFlag, StoreLocation _pLocation, DateTime _rOnDate, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { IntPtr hStore = IntPtr.Zero; IntPtr hStoreCtx = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   int iRes = GetTrustStoreOS(_pLocation, out hStore, ref _sError); if(iRes != UConsts.S_OK) return iRes; // 1)    hStoreCtx = UOpenSSLAPI.X509_STORE_CTX_new(); if (!UOpenSSLAPI.X509_STORE_CTX_init(hStoreCtx, hStore, _hCert, IntPtr.Zero)) { _sError = UCConsts.S_CRYPTO_CONTEXT_CER_ERR; return UConsts.E_CRYPTO_ERR; } // 2)       SetStoreCtxCheckDate(hStoreCtx, _rOnDate); // 3)  if (!UOpenSSLAPI.X509_verify_cert(hStoreCtx)) { _sError = UCConsts.S_CRYPTO_CHAIN_CHECK_ERR.Frm(GetCertVerifyErr(hStoreCtx)); return UConsts.E_CRYPTO_ERR; } return UConsts.S_OK; } finally { if (hStore != IntPtr.Zero) UOpenSSLAPI.X509_STORE_free(hStore); if (hStoreCtx != IntPtr.Zero) UOpenSSLAPI.X509_STORE_CTX_free(hStoreCtx); } }</span></span></code> </pre></div></div><br><p>     (X509_STORE_CTX)     .      : </p><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;   &lt;/summary&gt; * &lt;param name="_hStoreCtx"&gt; &lt;/param&gt; * &lt;param name="_rDate"&gt;&lt;/param&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetStoreCtxCheckDate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hStoreCtx, DateTime _rDate</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iFlags = UCConsts.X509_V_FLAG_USE_CHECK_TIME | UCConsts.X509_V_FLAG_X509_STRICT | UCConsts.X509_V_FLAG_CRL_CHECK_ALL; <span class="hljs-comment"><span class="hljs-comment">//   UOpenSSLAPI.X509_STORE_CTX_set_flags(_hStoreCtx, iFlags); //   UOpenSSLAPI.X509_STORE_CTX_set_time(_hStoreCtx, iFlags, (uint)_rDate.ToUnix()); //   -   UOpenSSLAPI.X509_STORE_CTX_set_trust(_hStoreCtx, UCConsts.X509_TRUST_TRUSTED); }</span></span></code> </pre></div></div><br><p>     ,           . </p><br><h1>  Conclusion </h1><br><p>     ,      .       X509Certificate2 (mono)      .      . </p><br><p>   ,  Windows              .       .  Linux ,        ,        . </p><br><p>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CSP 5.0</a> ,     RSA .      ,     ,   ,          RSA, ,    . </p><br><h1>  Les références </h1><br><ol><li> OpenSSL 1.0.2 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ManPages</a> ; </li><li>   OpenSSL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenSSL</a> : <br><ol><li> <a href="">cms_smime.c;</a> </li></ol></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wiki OpenSSL</a> ; </li><li>  mono: <ol><li>  <a href="">RSAManaged</a> ; </li></ol><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423769/">https://habr.com/ru/post/fr423769/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423753/index.html">Gardez les jetons d'autorisation en sécurité</a></li>
<li><a href="../fr423759/index.html">Fintech-digest: données personnelles des citoyens de la Fédération de Russie, place de marché de la Banque centrale, un nouveau service de CloudFlare</a></li>
<li><a href="../fr423763/index.html">Ce qu'Uber Cash enseigne aux innovateurs</a></li>
<li><a href="../fr423765/index.html">Nous écrivons une application pour le contrôle à distance du lecteur MPV de RetroOrangePi</a></li>
<li><a href="../fr423767/index.html">Des pirates ont attaqué British Airways: 380 000 cartes bancaires de clients volées</a></li>
<li><a href="../fr423771/index.html">Encore une fois, l'analyseur PVS-Studio s'est avéré être plus attentif qu'une personne</a></li>
<li><a href="../fr423775/index.html">Je voulais un beau morceau de fer. Il s'est avéré</a></li>
<li><a href="../fr423777/index.html">Projet Keystone: environnement sécurisé pour l'exécution d'applications basées sur RISC-V</a></li>
<li><a href="../fr423779/index.html">Sauvegarde cloud à cloud: de quoi s'agit-il et pourquoi est-il nécessaire</a></li>
<li><a href="../fr423781/index.html">Notes du fournisseur IoT. Cas: nous créons un réseau LoRa pour un distributeur de carburant à Tcheliabinsk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>