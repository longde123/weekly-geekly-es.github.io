<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßö üî¥ üï¶ A hist√≥ria de um problema: o menor memorizador de JavaScript üîù üíë ü§Ωüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foi √† noite, na v√©spera da confer√™ncia anual do HolyJS em S√£o Petersburgo. Nossa empresa √© patrocinadora h√° v√°rios anos: portanto, tamb√©m possui um es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>A hist√≥ria de um problema: o menor memorizador de JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/semrush/blog/413303/"><p><img src="https://habrastorage.org/webt/bn/ca/u1/bncau1_hr7wuzgyelj-ebncmyl4.png" alt="imagem"></p><br><p>  Foi √† noite, na v√©spera da confer√™ncia anual do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HolyJS</a> em S√£o Petersburgo.  Nossa empresa √© patrocinadora h√° v√°rios anos: portanto, tamb√©m possui um estande pr√≥prio com interesses interessantes para a mente inquisitiva de desenvolvedores preocupados.  Quando o prato principal estava pronto e todas as tarefas foram revisadas e conclu√≠das por advogados, decidi oferecer aos meus colegas um pouco mais de comida intelectual √† noite: </p><br><blockquote>  Escreva um memorizador - uma fun√ß√£o decoradora que salva os resultados da execu√ß√£o de uma fun√ß√£o agrupada para evitar c√°lculos repetidos.  Voc√™ tem apenas 50 caracteres. </blockquote><p>  A linguagem √©, obviamente, <strong>JavaScript</strong> .  A tarefa em si √© um cl√°ssico, mas o limite de 50 caracteres se transformou em um verdadeiro desafio. </p><br><p>  Nos intervalos do primeiro dia da confer√™ncia, discutimos op√ß√µes para atingir a meta, reduzindo gradualmente a resposta.  Todo o hype foi coroado com a id√©ia de compartilhar a tarefa com todos os participantes da confer√™ncia e, no segundo dia, visualizamos a tarefa (veja o ap√™ndice) e come√ßamos a distribuir formul√°rios para aqueles que desejavam.  Como resultado, obtivemos cerca de 40 solu√ß√µes e mais uma vez convencemos-nos da extraordin√°ria comunidade de desenvolvedores de js, mas <strong>o</strong> registro de <strong>53</strong> caracteres de <strong>Dmitry Kataev</strong> (SEMrush) permaneceu.  Vamos descobrir! </p><a name="habracut"></a><br><h3 id="privychnaya-realizaciya">  Implementa√ß√£o habitual </h3><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cache = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ret</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cache.hasOwnProperty(key)) { cache[key] = f.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cache[key]; } }</code> </pre> <br><p>  Resultado: ~ <strong>190</strong> caracteres </p><br><ul><li>  memoize - nosso memorizador </li><li>  f - fun√ß√£o decorada e embrulhada </li><li>  ret - fun√ß√£o resultante </li></ul><br><p>  Para obter a resposta - o tamanho da fun√ß√£o - usamos: </p><br><pre> <code class="javascript hljs">memoize.toString().replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s+/g</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).length</code> </pre> <br><p>  Ao avaliar o tamanho de uma fun√ß√£o, prestamos aten√ß√£o ao seu corpo e a uma lista de par√¢metros.  Se a fun√ß√£o for an√¥nima, a declara√ß√£o n√£o ser√° levada em considera√ß√£o. </p><br><p>  Testes simples para testar a sa√∫de ap√≥s abuso: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> log = memoize(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inc = memoize(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o</span></span></span><span class="hljs-function"> =&gt;</span></span> ox + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><table><thead><tr><th>  N√£o. </th><th>  Chamada de fun√ß√£o </th><th>  O resultado da execu√ß√£o no console </th></tr></thead><tbody><tr><td>  1 </td><td> <code>log(false)</code> </td> <td>  &gt; falso </td></tr><tr><td>  2) </td><td> <code>log('2', {x:1})</code> </td> <td>  &gt; '2', {x: 1} </td></tr><tr><td>  3) </td><td> <code>log(false)</code> </td> <td>  Nada, pois a fun√ß√£o j√° foi executada para esses valores. </td></tr><tr><td>  4) </td><td> <code>log('2', {x:1})</code> </td> <td>  Nada, pois a fun√ß√£o j√° foi executada para esses valores. </td></tr><tr><td>  5) </td><td> <code>inc({x:1})</code> </td> <td>  2 </td></tr><tr><td>  6 </td><td> <code>inc({x:2})</code> </td> <td>  3 </td></tr></tbody></table><br><p>  Em seguida, o resultado de cada implementa√ß√£o ser√° marcado pelo resultado do teste. </p><br><h3 id="chistaya-realizaciya">  Implementa√ß√£o l√≠quida </h3><br><p>  Antes de tudo, quero me livrar da <em>Declara√ß√£o</em> de <em>Fun√ß√£o</em> em favor da fun√ß√£o de seta, uma vez que n√£o estamos interessados <em>nesse</em> contexto, n√£o apelamos a <em>argumentos</em> e <em>,</em> como construtor, n√£o pretendemos chamar de <em>novo</em> .  Ao mesmo tempo, reduziremos os nomes das vari√°veis ‚Äã‚Äãlocais usadas: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!c.hasOwnProperty(k)) { c[k] = f.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k]; } }</code> </pre> <br><p>  Resultado: <strong>154</strong> , testes aprovados </p><br><p>  Ent√£o, podemos realizar uma opera√ß√£o semelhante com a fun√ß√£o resultante, mas precisamos de <em>argumentos</em> .  Aqui o <em>operador spread</em> vem em socorro, permitindo substituir o objeto iter√°vel passado dos argumentos pela vari√°vel de matriz <em>a</em> .  Al√©m disso, n√£o passaremos mais <em>esse</em> contexto para a fun√ß√£o que est√° sendo decorada: se necess√°rio, <em>Function.prototype.bind</em> ou nosso polyfil ajudar√°. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!c.hasOwnProperty(k)) { c[k] = f(...a); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k]; } }</code> </pre> <br><p>  Resultado: <strong>127</strong> , testes aprovados </p><br><p>  Agora nos voltamos para o corpo da fun√ß√£o resultante.  Obviamente, encontrar a chave no cache e retornar o valor √© complicado.  Vamos tentar reduzir como: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k] || (c[k] = f(...a)); } }</code> </pre> <br><p>  Resultado: <strong>101</strong> , testes 3 e 4 ca√≠ram </p><br><p>  Aqui abandonamos o m√©todo <em>hasOwnProperty</em> .  Podemos pagar, porque o resultado da serializa√ß√£o da matriz de argumentos via <em>JSON.stringify</em> sempre ser√° "[...]" e √© improv√°vel que essa propriedade <em>apare√ßa</em> no cache do prot√≥tipo ( <em>Object</em> ). </p><br><p>  Em seguida, usamos o recurso do operador OR "l√≥gico" para retornar a primeira express√£o, se puder ser convertida em <em>true</em> , ou de outra forma, a segunda com o c√°lculo da fun√ß√£o anterior. </p><br><p>  E aqui ca√≠mos nos testes 3 e 4. Isso aconteceu porque a fun√ß√£o decorada <em>console.log</em> n√£o retorna um valor: o resultado ser√° <em>indefinido</em> .  Colocamos isso no cache e, quando tentamos verificar o recurso disjuntor quando o chamamos novamente, somos implicitamente exibidos como <em>falsos</em> no primeiro operando e, consequentemente, entramos no segundo, o que leva √† chamada da fun√ß√£o.  Este efeito ocorrer√° para todos os resultados reduzidos a <em>falso</em> : <em>0, "", nulo, NaN</em> , etc. </p><br><p>  Em vez de OR e <em>if,</em> podemos usar um operador tern√°rio condicional: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.hasOwnProperty(k) ?c[k] :c[k] = f(...a); } }</code> </pre> <br><p>  Resultado: <strong>118</strong> , testes aprovados </p><br><p>  Reduzido muito ligeiramente.  Mas e se voc√™ usar o <em>Map</em> como um armazenamento em vez de um objeto simples?  H√° tamb√©m um m√©todo <em>has</em> curto: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (c.has(k) ?c :c.set(k, f(...a))).get(k); } }</code> </pre> <br><p>  Resultado: <strong>121</strong> , testes aprovados </p><br><p>  Reduzir completamente falhou.  Mas descartar o <em>Map</em> imediatamente n√£o vale a pena.  Essa implementa√ß√£o do armazenamento de valor-chave permite usar objetos como chave.  E isso significa que devemos desistir do <em>JSON.stringify</em> ? </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> (c.has(a) ?c :c.set(a, f(...a))).get(a); }</code> </pre> <br><p>  Resultado: <strong>83</strong> , testes 3 e 4 ca√≠ram </p><br><p>  Parece muito promissor!  No entanto, os testes 3 e 4. come√ßaram a cair novamente, porque a compara√ß√£o de chaves no objeto <em>Map</em> √© implementada usando o algoritmo <em>SameValueZero</em> .  Se voc√™ omitir os detalhes com <em>NaN, -0</em> e <em>0</em> , funcionar√° de maneira semelhante ao <em>operador de compara√ß√£o estrita</em> ( <em>===</em> ).  E temos uma nova matriz de argumentos (e, portanto, um objeto) para cada chamada da fun√ß√£o agrupada, mesmo com os mesmos valores.  A compara√ß√£o ocorre de acordo com a refer√™ncia do objeto e, portanto, o m√©todo <em>Map.prototype.has</em> nunca encontrar√° nada. </p><br><p>  Portanto, o uso do <em>Map</em> n√£o nos reduziu <em>hasOwnProperty</em> ou <em>JSON.stringify</em> . </p><br><p>  No <em>operador,</em> trata-se do resgate, que verifica a presen√ßa de uma propriedade em um objeto ou na cadeia de seus prot√≥tipos.  Por que n√£o podemos ter medo da pesquisa em prot√≥tipos foi explicado acima. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c ?c[k] :c[k] = f(...a); } }</code> </pre> <br><p>  Resultado: <strong>105</strong> , testes aprovados </p><br><p>  O corpo do memoizer e da fun√ß√£o resultante consiste em duas express√µes com a necessidade de declarar e inicializar uma vari√°vel local antes da l√≥gica na <em>instru√ß√£o de retorno</em> .  √â poss√≠vel reduzir o corpo da fun√ß√£o de seta para uma express√£o aqui?  Obviamente, usando o <em>padr√£o IIFE</em> ( <em>express√£o de fun√ß√£o imediatamente</em> <em>chamada</em> ): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function"> =&gt;</span></span> (...a) =&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function"> =&gt;</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c ?c[k] : c[k] = f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)) )({});</code> </pre> <br><p>  Resultado: <strong>82</strong> , testes aprovados </p><br><p>  √â hora de se livrar de espa√ßos extras: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c=&gt;(...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[k]:c[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)))({});</code> </pre> <br><p>  Resultado: <strong>68</strong> , testes aprovados </p><br><p>  Obviamente, o gargalo agora √© o m√©todo <em>JSON.stringify</em> longo, que serializa recursivamente o objeto em uma string JSON, que usamos como chave.  De fato, n√£o precisamos de uma fun√ß√£o de serializa√ß√£o, mas de uma fun√ß√£o hash com a qual pudemos verificar a igualdade de objetos, pois ela funciona em outros idiomas.  Infelizmente, por√©m, n√£o h√° solu√ß√£o nativa no JavaScript, e o polifile auto-escrito hashCode no prot√≥tipo <em>Object</em> est√° claramente al√©m do escopo. </p><br><p>  Hmm, por que precisamos nos serializar?  Ao adicionar um elemento a um objeto por chave, seu toString ser√° chamado implicitamente.  Como nos recusamos a usar o objeto de <em>argumentos</em> iter√°veis ‚Äã‚Äãem favor da matriz por meio do <em>operador spread</em> , a chamada <em>toString</em> n√£o ser√° de <em>Object.prototype</em> , mas de <em>Array.prototype</em> , na qual ela √© redefinida e seus elementos s√£o separados por v√≠rgula.  Assim, para um conjunto diferente de argumentos, obtemos uma chave diferente. </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c=&gt;(...a</span></span></span><span class="hljs-function">)=&gt;</span></span>a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[a]:c[a]=f(...a))({});</code> </pre> <br><p>  Resultado: <strong>44</strong> , o teste 6 caiu </p><br><p>  O teste 6. est√° come√ßando a cair.Parece que o valor de retorno √© o resultado de uma chamada de fun√ß√£o anterior no teste 5. Por que isso est√° acontecendo?  Sim, ignoramos a chamada <em>toString</em> para o objeto de <em>argumentos</em> , mas n√£o levamos em conta que qualquer argumento tamb√©m pode ser um objeto complexo, chamando <em>paraString a</em> partir da qual obtemos o <em>[objeto objeto]</em> favorito de todos.  Isso significa que os argumentos {x: 1} e {x: 2} usar√£o a mesma chave no hash. </p><br><p>  O <em>btoa</em> usado para converter em base64 parecia um bom candidato para a fun√ß√£o de serializa√ß√£o.  Mas ele leva primeiro √† corda, ent√£o n√£o h√° chance.  Pensamos na dire√ß√£o de gerar um URI e formar um <em>ArrayBuffer</em> , quaisquer fun√ß√µes para obter um valor hash ou serializado.  Mas eles permaneceram no lugar. </p><br><p>  A prop√≥sito, o <em>JSON.stringify</em> tem suas pr√≥prias peculiaridades: <em>Infinito, NaN, indefinido, S√≠mbolo</em> ser√° convertido em <em>nulo</em> .  O mesmo vale para fun√ß√µes.  Se poss√≠vel, ocorre uma chamada impl√≠cita a <em>JSON</em> do objeto, e <em>Map</em> e <em>Set</em> ser√£o representados por elementos simplesmente enumerados.  √â compreens√≠vel, dado o formato final: JSON. </p><br><p>  O que vem depois? </p><br><h3 id="toksichnaya-dorabotka">  Modifica√ß√£o t√≥xica </h3><br><p>  Todos n√≥s certamente amamos fun√ß√µes puras, mas diante do problema, esse requisito n√£o vale a pena.  E isso significa que √© hora de adicionar uma pitada de efeitos colaterais. </p><br><p>  Primeiro, por que n√£o iniciar o cache da seguinte maneira: </p><br><pre> <code class="javascript hljs">(f,c={})=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[k]:c[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a));</code> </pre> <br><p>  Resultado: <strong>66</strong> , testes aprovados </p><br><p>  Aqui usamos o <em>par√¢metro padr√£o</em> na fun√ß√£o de seta.  Obviamente, damos ao cliente a oportunidade de definir seu cache, e da√≠?  Mas reduzimos 2 caracteres. </p><br><p>  De que outra forma posso iniciar um cache para que uma fun√ß√£o seja decorada?  A resposta correta: por que precisamos inici√°-lo?  Por que n√£o usar algo pronto no contexto de uma fun√ß√£o a ser quebrada.  Mas e se a pr√≥pria fun√ß√£o?  Todos sabemos que fun√ß√µes em JavaScript tamb√©m s√£o objetos: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a));</code> </pre> <br><p>  Resultado: <strong>59</strong> , testes aprovados </p><br><p>  Aqui, o <em>JSON.stringify nos</em> proteger√° da interse√ß√£o com outras propriedades e m√©todos do objeto (fun√ß√£o), envolvendo os argumentos em "[...]". </p><br><p>  Neste exato momento, o padr√£o <em>IIFE</em> aplicado anteriormente <em>n√£o</em> est√° mais se justificando.  Mas manter uma express√£o √∫nica para a fun√ß√£o de seta √© urgentemente necess√°ria para evitar uma <em>declara√ß√£o de retorno</em> : </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a),k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a));</code> </pre> <br><p>  Resultado: <strong>57</strong> , testes aprovados </p><br><p>  Como n√£o usamos a <em>instru√ß√£o block</em> na fun√ß√£o arrow, n√£o podemos declarar uma vari√°vel ( <em>var</em> ou <em>let</em> ), mas podemos usar o contexto global - efeito colateral!  Aqui o conflito j√° tem algumas chances de acontecer. </p><br><p>  Utilizando o <em>operador v√≠rgula,</em> concatenamos duas express√µes em uma: os operandos s√£o avaliados da esquerda para a direita e o resultado √© o valor do √∫ltimo. </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a))<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a);</code> </pre> <br><p>  Resultado: <strong>54</strong> , testes aprovados </p><br><p>  Ent√£o, reorganizando apenas um suporte, nos livramos de tr√™s caracteres ao mesmo tempo.  <em>O operador de agrupamento</em> no c√°lculo da chave nos permitiu combinar os dois operandos da express√£o em apenas uma express√£o, e o colchete de fechamento removeu o espa√ßo antes do <em>operador in</em> . </p><br><p>  E finalmente: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>f[k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)]=k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f(...a);</code> </pre> <br><p>  Resultado: <strong>53</strong> , testes aprovados </p><br><p>  Por que n√£o calcular a chave ao acessar o valor.  E ent√£o - o mesmo operador tern√°rio e atribui√ß√£o.  Total: 53 caracteres! </p><br><p>  √â poss√≠vel remover os 3 caracteres restantes? </p><br><h3 id="osmyslenie">  Compreens√£o </h3><br><p>  Por que tudo isso?  Esta tarefa simples e a subsequente cadeia de convers√µes do habitual para indecente demonstra um n√∫mero consider√°vel de recursos da linguagem JavaScript.  Em nossas discuss√µes, abordamos coisas como: </p><br><ul><li>  Express√£o da fun√ß√£o de seta </li><li>  Escopo lexical e IIFE </li><li>  Objeto de argumentos do tipo matriz </li><li>  Spread, v√≠rgula ou operadores </li><li>  Operador de compara√ß√£o estrita </li><li>  JSON.stringify &amp; toString </li><li>  No operador &amp; hasOwnProperty </li><li>  Operador de agrupamento e instru√ß√£o de bloco </li><li>  Objeto de mapa </li><li>  e outra coisa </li></ul><br><p>  Tais hist√≥rias s√£o uma boa raz√£o para mergulhar no estudo das especificidades de um idioma, ajudar a entend√™-lo melhor (ou vice-versa).  E, claro, apenas por divers√£o! </p><br><h3 id="prilozhenie">  App </h3><br><p><img src="https://habrastorage.org/webt/a8/n5/qp/a8n5qppehvlrsk6lmflpijrazjg.jpeg" alt="imagem"></p><br><p>  <em>Em suas aventuras, Rick geralmente precisa calibrar sua arma portal.</em>  <em>O procedimento leva tempo, mas a entrada √© frequentemente repetida.</em>  <em>O cientista est√° tentando memorizar os resultados j√° obtidos uma vez para n√£o fazer c√°lculos repetidamente, mas o alcoolismo e a senilidade senil afetam fortemente sua mem√≥ria.</em>  <em>Ele pediu a Morty para melhorar o m√≥dulo de configura√ß√µes da pistola, adicionando uma fun√ß√£o de memorizador.</em>  <em>Esta fun√ß√£o deve salvar os resultados da fun√ß√£o que est√° sendo decorada para evitar c√°lculos repetidos.</em>  <em>Apenas Morty est√° em p√¢nico com medo de longas fun√ß√µes.</em>  <em>Ajude-o a resolver o problema da forma <strong>mais</strong> compacta <strong>poss√≠vel</strong> .</em>  <em>A fun√ß√£o que est√° sendo decorada pode usar n√∫meros inteiros, seq√º√™ncias de caracteres, booleanos e objetos como argumentos.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt413303/">https://habr.com/ru/post/pt413303/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt413287/index.html">DocumentFragment: o que √© e como (n√£o) combat√™-lo</a></li>
<li><a href="../pt413289/index.html">Automa√ß√£o de data centers ou "rebeli√£o de m√°quinas"</a></li>
<li><a href="../pt413291/index.html">O livro "Deep Learning in Python"</a></li>
<li><a href="../pt413293/index.html">Grande √™xodo da ind√∫stria de videogames</a></li>
<li><a href="../pt413297/index.html">Fontes da Web vari√°veis</a></li>
<li><a href="../pt413305/index.html">Baterias, Gigafactory, Northvolt e Siemens. Estranho T</a></li>
<li><a href="../pt413307/index.html">A ESET descobriu o banqueiro BackSwap usando o novo m√©todo de manipula√ß√£o do navegador</a></li>
<li><a href="../pt413309/index.html">Lado escuro √°gil</a></li>
<li><a href="../pt413311/index.html">Portando seu aplicativo Web do JavaScript puro para o Vue.js</a></li>
<li><a href="../pt413315/index.html">Sistema clim√°tico no apartamento com suas pr√≥prias m√£os - parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>