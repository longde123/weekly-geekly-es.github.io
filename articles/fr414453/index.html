<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëàüèæ üîÜ üà≤ Impl√©menter Path Finder pour les agents AI avec NavMesh üì§ üíÜüèΩ ‚ôüÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Suivre le chemin et contr√¥ler le trafic 
 Parfois, nous avons besoin de personnages IA pour parcourir le monde du jeu, en suivant un chemin √† peu pr√®s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Impl√©menter Path Finder pour les agents AI avec NavMesh</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414453/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11d/4c5/6ad/11d4c56ad10246e5cb9e56e641938b59.png" alt="image"></div><br><h2>  Suivre le chemin et contr√¥ler le trafic </h2><br>  Parfois, nous avons besoin de personnages IA pour parcourir le monde du jeu, en suivant un chemin √† peu pr√®s d√©fini ou d√©fini avec pr√©cision.  Par exemple, dans un jeu de course, les adversaires de l'IA doivent se d√©placer le long de la route, et dans le RTS, les unit√©s doivent pouvoir se d√©placer jusqu'au point souhait√©, se d√©placer le long du terrain et en tenant compte de la position de l'autre. <br><br>  Pour para√Ætre intelligents, les agents de l'IA doivent √™tre en mesure de d√©terminer ce qu'ils font et s'ils ne peuvent pas atteindre le point souhait√©, ils doivent √™tre en mesure de tracer l'itin√©raire le plus efficace et de changer de trajectoire lorsque des obstacles apparaissent sur le chemin. <br><br>  √âviter les obstacles est un comportement simple qui permet aux entit√©s IA d'atteindre les points cibles.  Il est important de noter que le comportement mis en ≈ìuvre dans ce post concerne des comportements tels que la simulation de foule, dans lesquels l'objectif principal de chaque agent est d'√©viter d'autres agents et d'atteindre l'objectif.  Ils ne d√©terminent pas le chemin le plus efficace et le plus court. <br><br><h2>  Exigences techniques </h2><br>  N√©cessite Unity 2017 install√© sur un syst√®me √©quip√© de Windows 7 SP1 +, 8, 10 ou Mac OS X 10.9+.  Le code de cet article ne fonctionnera pas sur Windows XP et Vista, et les versions serveur de Windows et OS X n'ont pas √©t√© test√©es. <br><br>  Les fichiers de code pour cet article peuvent √™tre trouv√©s sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">GitHub</a> . <br><br>  Pour apprendre le code en action, regardez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">cette vid√©o</a> . <br><a name="habracut"></a><br><h2>  Maillage de navigation </h2><br>  Voyons comment utiliser le g√©n√©rateur de maillage de navigation Unity int√©gr√©, qui peut grandement simplifier la recherche de chemins pour les agents AI.  Dans les premiers stades d'Unity 5.x, la fonction NavMesh est devenue accessible √† tous les utilisateurs, y compris ceux disposant de licences d'√©dition personnelle, bien qu'elle ne l'√©tait auparavant que pour Unity Pro.  Avant la sortie de 2017.1, le syst√®me a √©t√© mis √† jour pour fournir un flux de travail bas√© sur les composants, mais comme il n√©cessite un package t√©l√©chargeable suppl√©mentaire, qui au moment de la r√©daction n'est disponible que dans la version d'aper√ßu, nous respecterons le flux de travail bas√© sur une sc√®ne standard.  Ne vous inqui√©tez pas, les concepts des deux approches sont similaires et lorsque l'impl√©mentation finale atteint finalement 2017.x, il ne devrait pas y avoir de changements significatifs. <br><br>  En savoir plus sur le syst√®me de composants NavMesh dans Unity sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">GitHub</a> . <br><br>  Nous allons maintenant explorer toutes les possibilit√©s que ce syst√®me peut nous offrir.  Pour rechercher des chemins AI, la sc√®ne doit √™tre pr√©sent√©e dans un format sp√©cifique;  sur une carte 2D, une grille bidimensionnelle (tableau) est utilis√©e pour rechercher des chemins √† l'aide de l'algorithme A *.  Les agents de l'IA doivent savoir o√π se trouvent les obstacles, en particulier les obstacles statiques.  La gestion des collisions entre des objets en mouvement dynamique est un autre probl√®me commun√©ment appel√© comportement de direction.  Unity dispose d'un outil int√©gr√© pour g√©n√©rer NavMesh, repr√©sentant la sc√®ne dans un contexte pratique pour que les agents IA trouvent le chemin optimal vers la cible.  Pour commencer, ouvrez un projet de d√©monstration et acc√©dez √† la sc√®ne NavMesh. <br><br><h3>  Carte d'√©tude </h3><br>  Apr√®s avoir ouvert la sc√®ne de d√©monstration NavMesh, cela devrait ressembler √† la capture d'√©cran: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a3/35c/15a/7a335c15ad8084dee2aab59de7cdcd3f.png"></div><br>  <em>Sc√®ne d'obstacle et de pente</em> <br><br>  Ce sera notre bac √† sable pour expliquer et tester la fonctionnalit√© du syst√®me NavMesh.  Le sch√©ma g√©n√©ral est similaire √† un jeu dans le genre de RTS (strat√©gie en temps r√©el).  Nous conduisons un char bleu.  Cliquez sur diff√©rents points pour que le char se d√©place vers eux.  L'indicateur jaune est la cible actuelle du r√©servoir. <br><br><h3>  Navigation statique </h3><br>  Tout d'abord, vous devez dire que vous devez marquer toute la g√©om√©trie de la sc√®ne, cuite dans NavMesh, comme <b>navigation statique</b> .  Vous l'avez peut-√™tre d√©j√† vu, par exemple, dans le syst√®me de carte d'√©clairage Unity.  Pour rendre les objets de jeu statiques est tr√®s simple, il suffit de cocher la case <b>Statique</b> pour toutes leurs propri√©t√©s (navigation, √©clairage, √©limination, traitement par lots, etc.), ou utilisez la liste d√©roulante pour sp√©cifier les propri√©t√©s.  La case √† cocher est situ√©e dans le coin sup√©rieur droit de l'inspecteur des objets s√©lectionn√©s. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7c/cfd/224/f7ccfd224088652d0831282397b5eb5c.png"></div><br>  <em>Navigation de propri√©t√© statique</em> <br><br>  Cela peut √™tre fait individuellement pour diff√©rents objets ou, si vous avez une hi√©rarchie int√©gr√©e d'objets de jeu, appliquez le param√®tre √† l'objet parent, apr√®s quoi Unity proposera de l'appliquer √† tous les objets enfants. <br><br><h3>  R√¥tir un maillage de navigation </h3><br>  Pour la sc√®ne enti√®re, les options de navigation navmesh sont appliqu√©es √† l'aide de la fen√™tre de <b>navigation</b> .  Cette fen√™tre peut √™tre ouverte en allant dans <b>Fen√™tre</b> |  <b>La navigation</b>  Comme toute autre fen√™tre, elle peut √™tre d√©connect√©e pour une libert√© de mouvement ou fix√©e.  Dans nos captures d'√©cran, il est affich√© sous la forme d'un onglet ancr√© √† c√¥t√© de la hi√©rarchie, mais vous pouvez placer cette fen√™tre √† n'importe quel endroit pratique. <br><br>  En ouvrant la fen√™tre, vous verrez des onglets individuels.  Cela ressemblera √† ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/872/7a6/b30/8727a6b301be8f979821ab0446ce5e7d.png"></div><br>  <em>Fen√™tre de navigation</em> <br><br>  Dans notre cas, la capture d'√©cran pr√©c√©dente montre l'onglet <b>Bake</b> , mais dans votre √©diteur, n'importe quel onglet peut √™tre s√©lectionn√© par d√©faut. <br><br>  Regardons chacun des onglets, en commen√ßant par la gauche et en se d√©pla√ßant vers la droite.  Commen√ßons par l'onglet <b>Agents</b> , qui ressemble √† la capture d'√©cran: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e2/3e9/db3/9e23e9db3a55b407af7a7bde83c56c4b.png"></div><br>  <em>Onglet Agents</em> <br><br>  Si vous travaillez sur un autre projet, vous pouvez constater que certains param√®tres sont diff√©rents de ceux que nous avons d√©finis pour l'exemple de projet illustr√© dans la capture d'√©cran.  En haut de l'onglet, il y a une liste o√π vous pouvez ajouter de nouveaux types d'agents en cliquant sur le bouton <b>+</b> .  Vous pouvez supprimer des agents suppl√©mentaires en les s√©lectionnant et en cliquant sur le bouton <b>-</b> .  La fen√™tre montre clairement ce que font les diff√©rents param√®tres lors de leur modification.  Voyons ce que fait chacun des param√®tres: <br><br><ul><li>  Nom: nom du type d'agent affich√© dans la liste d√©roulante Types d'agent. </li><li>  Rayon: Vous pouvez le consid√©rer comme ¬´l'espace personnel¬ª d'un agent.  Les agents tenteront d'√©viter un contact trop √©troit avec d'autres agents sur la base de cette valeur, car elle est utilis√©e √† des fins d'√©vitement. </li><li>  Hauteur: comme vous pouvez le deviner, ce param√®tre d√©finit la hauteur de l'agent qu'il utilise pour l'√©vitement vertical (par exemple, lors du passage sous des objets). </li><li>  Hauteur de marche: cette valeur d√©termine la hauteur que l'agent peut grimper. </li><li>  Pente maximale: comme nous le verrons dans la section suivante, cette valeur d√©termine l'angle maximal auquel l'agent peut monter.  En utilisant ce param√®tre, vous pouvez rendre les pentes abruptes de la carte inaccessibles √† l'agent. </li></ul><br>  Ensuite, nous avons l'onglet <b>Zones</b> , qui ressemble √† celui montr√© dans cette capture d'√©cran: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68b/e36/4f6/68be364f6605a8b3f567dfeb31bf56db.png"></div><br>  Comme vous pouvez le voir sur la capture d'√©cran, Unity propose plusieurs types de zones qui ne peuvent pas √™tre modifi√©es: <b>Walkable</b> , <b>Not Walkable</b> et <b>Jump</b> .  En plus de nommer et de cr√©er de nouvelles zones, vous pouvez attribuer √† ces zones le co√ªt de leur d√©placement. <br><br>  Les zones ont deux objectifs: rendre les zones accessibles ou inaccessibles √† l'agent et marquer les zones comme moins souhaitables en termes de frais de d√©placement.  Par exemple, vous pouvez d√©velopper un RPG dans lequel les ennemis d√©moniaques ne peuvent pas entrer dans les zones marqu√©es comme ¬´terrain consacr√©¬ª.  Vous pouvez √©galement marquer certaines zones de la carte comme un ¬´bourbier¬ª ou un ¬´marais¬ª, ce que l'agent √©vitera en raison du co√ªt √©lev√© du d√©placement. <br><br>  Le troisi√®me onglet <b>Bake</b> est probablement le plus important.  Il vous permet de cr√©er NavMesh lui-m√™me pour la sc√®ne.  Vous devez d√©j√† √™tre familiaris√© avec certaines des options.  L'onglet <b>Bake</b> ressemble √† ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16a/fc2/a66/16afc2a6659910152c0f4d673c9bcacb.png"></div><br>  <em>Onglet de cuisson</em> <br><br>  Les options de taille d'agent de cet onglet d√©terminent la mani√®re dont les agents interagiront avec l'environnement, tandis que les options de l'onglet <b>Agents</b> contr√¥lent les interactions avec d'autres agents et objets en mouvement.  Mais ils contr√¥lent les m√™mes param√®tres, nous allons donc les ignorer.  <b>La hauteur de chute</b> et la <b>distance de saut</b> contr√¥lent jusqu'o√π l'agent peut ¬´sauter¬ª pour atteindre la partie de NavMesh qui n'est pas directement li√©e √† celle dans laquelle l'agent se trouve actuellement.  Nous examinerons cela plus en d√©tail ci-dessous, donc si vous n'√™tes pas s√ªr, vous ne pourrez toujours pas √©tudier ces param√®tres. <br><br>  De plus, il existe des options avanc√©es qui sont g√©n√©ralement masqu√©es par d√©faut.  Pour d√©velopper ces options, cliquez simplement sur le triangle d√©roulant √† c√¥t√© de l'en-t√™te <b>Avanc√©</b> .  <b>La taille manuelle du Voxel</b> peut √™tre consid√©r√©e comme un param√®tre de ¬´qualit√©¬ª.  Plus la taille est petite, plus les d√©tails seront stock√©s dans le maillage.  <b>La zone de r√©gion minimale est</b> utilis√©e pour ignorer les plates-formes de cuisson ou les surfaces inf√©rieures au seuil s√©lectionn√©.  <b>La hauteur du maillage</b> nous donne des donn√©es verticales plus d√©taill√©es lors de la cuisson d'un maillage.  Par exemple, cette option vous permet de conserver l'emplacement correct de l'agent lors de la mont√©e des escaliers. <br><br>  Le bouton <b>Effacer</b> supprime toutes les donn√©es NavMesh de la sc√®ne et le bouton <b>Bake</b> cr√©e un maillage pour la sc√®ne.  Le processus de cuisson est assez rapide.  Tant que vous avez une fen√™tre s√©lectionn√©e, vous pouvez observer la g√©n√©ration de NavMesh avec le bouton <b>Bake</b> dans la fen√™tre de la sc√®ne.  Cliquons sur le bouton <b>Bake</b> pour voir les r√©sultats.  Dans notre exemple de sc√®ne, nous nous retrouvons avec quelque chose de similaire √† cette capture d'√©cran: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11d/4c5/6ad/11d4c56ad10246e5cb9e56e641938b59.png"></div><br>  Les zones bleues montrent NavMesh.  Ci-dessous, nous y reviendrons.  En attendant, passons au dernier onglet - <b>Objet</b> , qui ressemble √† ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/6c7/4e8/b446c74e8154bca80133ff95ce378d31.png"></div><br>  Les trois boutons illustr√©s dans la capture d'√©cran pr√©c√©dente - <b>Tous</b> , <b>Rendu de maillage</b> et <b>Terrains</b> - sont utilis√©s comme filtres de sc√®ne.  Ils sont utiles lorsque vous travaillez dans des sc√®nes complexes avec de nombreux objets dans la hi√©rarchie.  La s√©lection d'une option filtre le type correspondant dans la hi√©rarchie, ce qui facilite leur s√©lection.  Vous pouvez utiliser les boutons pour explorer votre sc√®ne √† la recherche d'objets que vous souhaitez marquer comme navigation statique. <br><br><h3>  Utilisation de Nav Mesh Agent </h3><br>  Maintenant que nous avons configur√© la sc√®ne avec NavMesh, nous avons besoin d'un moyen pour l'agent d'utiliser ces informations.  Heureusement pour nous, Unity a un composant <b>Nav Mesh Agent</b> que vous pouvez faire glisser sur un personnage.  Dans notre sc√®ne d'exemple, il y a un objet de jeu appel√© <b>Tank</b> , auquel un composant est d√©j√† attach√©.  Regardez la hi√©rarchie et vous verrez quelque chose comme ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/3ba/68f/a313ba68f88b2417e0225c6f724cbce8.png"></div><br>  Il y a pas mal de param√®tres ici, et nous ne consid√©rerons pas tout car ils sont assez clairs, et la description peut √™tre trouv√©e dans la documentation officielle de Unity.  Mais nous mentionnerons les principales choses: <br><br><ul><li>  <strong>Type d'agent</strong> : vous vous souvenez de l'onglet <strong>Agents</strong> dans la fen√™tre de <strong>navigation</strong> ?  Les types d'agents attribuables peuvent √™tre s√©lectionn√©s ici. </li><li>  <strong>Traverse automatique hors lien maill√©</strong> : cette option permet aux agents d'utiliser automatiquement la fonction de <strong>liens hors maillage</strong> , dont nous parlerons ci-dessous. </li><li>  <strong>Masque de zone</strong> : vous pouvez s√©lectionner ici les zones configur√©es dans l'onglet <strong>Zones</strong> de la fen√™tre de <strong>navigation</strong> . </li></ul><br>  C‚Äôest tout.  Cette composante fait 90% du travail acharn√© pour nous: ouvrir la voie, √©viter les obstacles, etc.  La seule chose dont vous avez besoin est de transf√©rer le point cible √† l'agent.  Regardons ce probl√®me. <br><br><h3>  R√©glage du point cible </h3><br>  Apr√®s avoir configur√© l'agent AI, nous avons besoin d'un moyen de lui dire o√π aller.  Dans notre exemple de projet, il existe un script appel√© <b>Target.cs</b> qui effectue exactement cette t√¢che. <br><br>  Il s'agit d'une classe simple qui fait trois choses: <br><br><ul><li>  "Tire" le faisceau de la cam√©ra √† la position de la souris dans le monde </li><li>  Met √† jour la position du marqueur </li><li>  Met √† jour la propri√©t√© de destination pour tous les agents NavMesh. </li></ul><br>  Le code est assez simple.  La classe enti√®re est la suivante: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Target</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NavMeshAgent[] navAgents; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform targetMarker; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { navAgents = FindObjectsOfType(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(NavMeshAgent)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> NavMeshAgent[]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateTargets</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 targetPosition </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(NavMeshAgent agent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> navAgents) { agent.destination = targetPosition; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GetInput()) { Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hitInfo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray.origin, ray.direction, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hitInfo)) { Vector3 targetPosition = hitInfo.point; UpdateTargets(targetPosition); targetMarker.position = targetPosition; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.DrawLine(targetMarker.position, targetMarker.position + Vector3.up * <span class="hljs-number"><span class="hljs-number">5</span></span>, Color.red); } }</code> </pre> <br>  Les actions suivantes se produisent ici: dans la m√©thode <b>Start</b> , nous initialisons le tableau <b>navAgents</b> √† l'aide de la m√©thode <b>FindObjectsOfType ()</b> . <br><br>  La m√©thode <b>UpdateTargets ()</b> passe par notre tableau <b>navAgents</b> et d√©finit le point cible pour eux dans le <b>Vector3</b> donn√©.  Ceci est la cl√© du code.  Vous pouvez utiliser n'importe quel m√©canisme pour obtenir le point cible, et pour que l'agent s'y d√©place, il suffit de d√©finir le champ <b>NavMeshAgent.destination</b> ;  l'agent fera le reste. <br><br>  Dans notre exemple, les clics sont utilis√©s pour se d√©placer, donc lorsqu'un joueur clique sur la souris, nous lib√©rons le rayon de la cam√©ra dans le monde dans la direction du curseur de la souris, et s'il intersecte quelque chose, nous attribuons un point de collision au nouvel agent <b>targetPosition</b> .  Nous ajustons √©galement le marqueur cible en cons√©quence pour visualiser facilement la destination dans le jeu. <br><br>  Pour tester l'op√©ration, vous devez cuire NavMesh conform√©ment √† la description de la section pr√©c√©dente, puis d√©marrer le mode Lecture et s√©lectionner n'importe quelle zone sur la carte.  Si vous cliquez plusieurs fois, vous pouvez voir que l'agent ne peut pas atteindre certaines zones - le haut des cubes rouges, la plate-forme sup√©rieure et la plate-forme en bas de l'√©cran. <br><br>  Les cubes rouges sont trop hauts.  La pente menant √† la plate-forme la plus √©lev√©e est trop forte pour nos param√®tres de <b>pente maximale</b> , et l'agent ne peut pas la grimper.  Les captures d'√©cran suivantes montrent comment les param√®tres <b>Max Slope</b> affectent NavMesh: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd7/539/7b8/fd75397b851d088fc1fd8d4d53210cc9.png"></div><br>  <i>NavMesh avec pente maximale = 45</i> <br><br>  Si vous modifiez la valeur de la <b>pente</b> maximale √† quelque chose comme <b>51</b> , puis cliquez √† nouveau sur le bouton <b>Bake</b> pour cuire √† nouveau NavMesh, les r√©sultats seront les suivants: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09a/936/b78/09a936b78c4958c9200d00867dbbc418.png"></div><br>  <em>NavMesh avec pente maximale = 51</em> <br><br>  Comme vous pouvez le voir, nous pouvons personnaliser la conception des niveaux, rendant des zones enti√®res inaccessibles en modifiant un seul param√®tre.  Cela peut √™tre utile, par exemple, lorsque vous avez une plate-forme ou un rebord qui n√©cessite une corde, une √©chelle ou un ascenseur pour grimper.  Ou peut-√™tre une comp√©tence sp√©ciale, par exemple, la capacit√© de grimper? <br><br><h3>  Application hors liens maill√©s </h3><br>  Vous remarquerez peut-√™tre qu'il y a deux ruptures dans notre sc√®ne.  Notre agent peut entrer dans le premier, mais celui en bas de l'√©cran est trop loin.  Ces calculs ne sont pas compl√®tement arbitraires.  <strong>Les liens hors maillage</strong> cr√©ent essentiellement un pont √† travers les espaces entre les segments NavMesh non li√©s.  Ces liens peuvent √™tre vus dans l'√©diteur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4b/b0a/425/b4bb0a425446298ae08ea4684bbcef10.png"></div><br>  <i>Les cercles bleus avec des lignes de connexion sont des connexions.</i> <br><br>  Unity peut g√©n√©rer ces liens de deux mani√®res.  Le premier que nous avons d√©j√† envisag√©.  Vous vous souvenez de la valeur de <b>distance de saut</b> dans l'onglet <b>Bake</b> de la fen√™tre de <b>navigation</b> ?  Unity utilise automatiquement cette valeur pour g√©n√©rer ces liens lors de la cuisson de NavMesh.  Essayez de changer la valeur de notre sc√®ne de test en 5 et de recommencer la cuisson.  Vous voyez, les plateformes sont maintenant connect√©es?  Cela est d√ª au fait que les maillages sont d√©sormais dans le nouveau seuil sp√©cifi√©. <br><br>  Changez √† nouveau la valeur √† 2 et faites cuire.  Voyons maintenant la deuxi√®me fa√ßon.  Cr√©ez les sph√®res qui seront utilis√©es pour connecter les deux plates-formes.  Placez-les approximativement comme indiqu√© dans la capture d'√©cran: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7a/28e/020/a7a28e020255bb8855d48017da4188f1.png"></div><br>  Vous pouvez d√©j√† voir ce qui se passe, mais analysons le processus qui leur permet de se connecter.  Dans notre cas, j'ai appel√© la sph√®re √† droite et la sph√®re √† gauche.  Vous comprendrez bient√¥t pourquoi.  Ensuite, j'ai ajout√© le composant <b>Off Mesh Link</b> √† la plate-forme √† droite (par rapport √† la capture d'√©cran pr√©c√©dente).  Vous remarquerez que le composant a des champs de <b>d√©but</b> et de <b>fin</b> .  Comme vous pouvez le deviner, nous allons faire glisser les sph√®res pr√©c√©demment cr√©√©es dans les emplacements correspondants - la sph√®re de d√©but dans le champ de <b>d√©but</b> et la sph√®re de fin dans le champ de <b>fin</b> .  L'inspecteur ressemblera √† ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/720/2b4/251/7202b4251068b5d0b1b8b1d7e4b09ff2.png"></div><br>  La valeur de <b>Cost Override est</b> prise en compte lorsqu'elle re√ßoit une valeur positive.  Il applique un facteur de co√ªt lors de l'utilisation de cette relation, par opposition √† un itin√©raire plus rentable vers la cible. <br><br>  <b>Bi-directionnel</b> si vrai permet √† l'agent de se d√©placer dans les deux sens.  Pour cr√©er des liens avec un trafic √† sens unique, vous pouvez d√©sactiver cette valeur.  La valeur <b>Activ√© est</b> utilis√©e selon son nom.  Si faux, l'agent ignore cette association.  Vous pouvez l'activer et le d√©sactiver pour cr√©er des sc√©narios de jeu dans lesquels, par exemple, un joueur doit appuyer sur un interrupteur pour activer une connexion. <br><br>  Pour activer cette relation, une nouvelle cuisson n'est pas n√©cessaire.  Regardez votre NavMesh et vous verrez qu'il ressemble exactement √† la capture d'√©cran: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be8/15a/e57/be815ae574360beea94d8907e37fc309.png"></div><br>  Comme vous pouvez le voir, le plus petit espace se connecte toujours automatiquement, et nous avons maintenant une nouvelle connexion g√©n√©r√©e par le composant <b>Off Mesh Link</b> entre les deux sph√®res.  Lancez le mode Play et cliquez sur la plate-forme √©loign√©e.  Comme pr√©vu, l'agent peut d√©sormais acc√©der √† la plateforme d√©connect√©e: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f6/0c7/a61/7f60c7a61db24f3961ea0b7332de56a1.png"></div><br>  Aux niveaux de votre jeu, vous devrez peut-√™tre modifier ces param√®tres pour obtenir les r√©sultats souhait√©s, mais une combinaison de ces fonctionnalit√©s vous fournit un outil pratique et pr√™t √† l'emploi.  Vous pouvez rapidement cr√©er un jeu simple en utilisant la fonctionnalit√© NavMesh. <br><br>  <em>Ce didacticiel fait partie de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">la programmation AI de jeu Unity 2017 - troisi√®me √©dition</a> par Ray Barrera, Aung Sithu Kyaw et Thet Naing Swe.</em> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414453/">https://habr.com/ru/post/fr414453/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414443/index.html">Caract√©ristiques des appels de fonction en C ++</a></li>
<li><a href="../fr414445/index.html">Am√©liorer Zimbra avec la suite Zextras</a></li>
<li><a href="../fr414447/index.html">Des tr√©sors de tous les temps</a></li>
<li><a href="../fr414449/index.html">Comment se faire des amis de tous les op√©rateurs du stade et ne pas l'ensemencer avec des centaines d'antennes</a></li>
<li><a href="../fr414451/index.html">"Calendrier des testeurs" pour juin. Le testeur doit attraper le bug, lire Caner et organiser le d√©placement.</a></li>
<li><a href="../fr414455/index.html">Algorithme de g√©n√©ration de palette de couleurs</a></li>
<li><a href="../fr414459/index.html">D√©tecteurs et descripteurs de points singuliers FAST, BRIEF, ORB</a></li>
<li><a href="../fr414463/index.html">L'IA elle-m√™me a appris √† construire un Rubik's Cube</a></li>
<li><a href="../fr414465/index.html">Meta Crush Saga: jeu de compilation</a></li>
<li><a href="../fr414467/index.html">Articles de la conf√©rence Minsk C ++ CoreHard Spring 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>