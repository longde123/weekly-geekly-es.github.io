<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈🏾 🔆 🈲 Implémenter Path Finder pour les agents AI avec NavMesh 📤 💆🏽 ♟️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Suivre le chemin et contrôler le trafic 
 Parfois, nous avons besoin de personnages IA pour parcourir le monde du jeu, en suivant un chemin à peu près...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implémenter Path Finder pour les agents AI avec NavMesh</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414453/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11d/4c5/6ad/11d4c56ad10246e5cb9e56e641938b59.png" alt="image"></div><br><h2>  Suivre le chemin et contrôler le trafic </h2><br>  Parfois, nous avons besoin de personnages IA pour parcourir le monde du jeu, en suivant un chemin à peu près défini ou défini avec précision.  Par exemple, dans un jeu de course, les adversaires de l'IA doivent se déplacer le long de la route, et dans le RTS, les unités doivent pouvoir se déplacer jusqu'au point souhaité, se déplacer le long du terrain et en tenant compte de la position de l'autre. <br><br>  Pour paraître intelligents, les agents de l'IA doivent être en mesure de déterminer ce qu'ils font et s'ils ne peuvent pas atteindre le point souhaité, ils doivent être en mesure de tracer l'itinéraire le plus efficace et de changer de trajectoire lorsque des obstacles apparaissent sur le chemin. <br><br>  Éviter les obstacles est un comportement simple qui permet aux entités IA d'atteindre les points cibles.  Il est important de noter que le comportement mis en œuvre dans ce post concerne des comportements tels que la simulation de foule, dans lesquels l'objectif principal de chaque agent est d'éviter d'autres agents et d'atteindre l'objectif.  Ils ne déterminent pas le chemin le plus efficace et le plus court. <br><br><h2>  Exigences techniques </h2><br>  Nécessite Unity 2017 installé sur un système équipé de Windows 7 SP1 +, 8, 10 ou Mac OS X 10.9+.  Le code de cet article ne fonctionnera pas sur Windows XP et Vista, et les versions serveur de Windows et OS X n'ont pas été testées. <br><br>  Les fichiers de code pour cet article peuvent être trouvés sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">GitHub</a> . <br><br>  Pour apprendre le code en action, regardez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">cette vidéo</a> . <br><a name="habracut"></a><br><h2>  Maillage de navigation </h2><br>  Voyons comment utiliser le générateur de maillage de navigation Unity intégré, qui peut grandement simplifier la recherche de chemins pour les agents AI.  Dans les premiers stades d'Unity 5.x, la fonction NavMesh est devenue accessible à tous les utilisateurs, y compris ceux disposant de licences d'édition personnelle, bien qu'elle ne l'était auparavant que pour Unity Pro.  Avant la sortie de 2017.1, le système a été mis à jour pour fournir un flux de travail basé sur les composants, mais comme il nécessite un package téléchargeable supplémentaire, qui au moment de la rédaction n'est disponible que dans la version d'aperçu, nous respecterons le flux de travail basé sur une scène standard.  Ne vous inquiétez pas, les concepts des deux approches sont similaires et lorsque l'implémentation finale atteint finalement 2017.x, il ne devrait pas y avoir de changements significatifs. <br><br>  En savoir plus sur le système de composants NavMesh dans Unity sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">GitHub</a> . <br><br>  Nous allons maintenant explorer toutes les possibilités que ce système peut nous offrir.  Pour rechercher des chemins AI, la scène doit être présentée dans un format spécifique;  sur une carte 2D, une grille bidimensionnelle (tableau) est utilisée pour rechercher des chemins à l'aide de l'algorithme A *.  Les agents de l'IA doivent savoir où se trouvent les obstacles, en particulier les obstacles statiques.  La gestion des collisions entre des objets en mouvement dynamique est un autre problème communément appelé comportement de direction.  Unity dispose d'un outil intégré pour générer NavMesh, représentant la scène dans un contexte pratique pour que les agents IA trouvent le chemin optimal vers la cible.  Pour commencer, ouvrez un projet de démonstration et accédez à la scène NavMesh. <br><br><h3>  Carte d'étude </h3><br>  Après avoir ouvert la scène de démonstration NavMesh, cela devrait ressembler à la capture d'écran: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a3/35c/15a/7a335c15ad8084dee2aab59de7cdcd3f.png"></div><br>  <em>Scène d'obstacle et de pente</em> <br><br>  Ce sera notre bac à sable pour expliquer et tester la fonctionnalité du système NavMesh.  Le schéma général est similaire à un jeu dans le genre de RTS (stratégie en temps réel).  Nous conduisons un char bleu.  Cliquez sur différents points pour que le char se déplace vers eux.  L'indicateur jaune est la cible actuelle du réservoir. <br><br><h3>  Navigation statique </h3><br>  Tout d'abord, vous devez dire que vous devez marquer toute la géométrie de la scène, cuite dans NavMesh, comme <b>navigation statique</b> .  Vous l'avez peut-être déjà vu, par exemple, dans le système de carte d'éclairage Unity.  Pour rendre les objets de jeu statiques est très simple, il suffit de cocher la case <b>Statique</b> pour toutes leurs propriétés (navigation, éclairage, élimination, traitement par lots, etc.), ou utilisez la liste déroulante pour spécifier les propriétés.  La case à cocher est située dans le coin supérieur droit de l'inspecteur des objets sélectionnés. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7c/cfd/224/f7ccfd224088652d0831282397b5eb5c.png"></div><br>  <em>Navigation de propriété statique</em> <br><br>  Cela peut être fait individuellement pour différents objets ou, si vous avez une hiérarchie intégrée d'objets de jeu, appliquez le paramètre à l'objet parent, après quoi Unity proposera de l'appliquer à tous les objets enfants. <br><br><h3>  Rôtir un maillage de navigation </h3><br>  Pour la scène entière, les options de navigation navmesh sont appliquées à l'aide de la fenêtre de <b>navigation</b> .  Cette fenêtre peut être ouverte en allant dans <b>Fenêtre</b> |  <b>La navigation</b>  Comme toute autre fenêtre, elle peut être déconnectée pour une liberté de mouvement ou fixée.  Dans nos captures d'écran, il est affiché sous la forme d'un onglet ancré à côté de la hiérarchie, mais vous pouvez placer cette fenêtre à n'importe quel endroit pratique. <br><br>  En ouvrant la fenêtre, vous verrez des onglets individuels.  Cela ressemblera à ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/872/7a6/b30/8727a6b301be8f979821ab0446ce5e7d.png"></div><br>  <em>Fenêtre de navigation</em> <br><br>  Dans notre cas, la capture d'écran précédente montre l'onglet <b>Bake</b> , mais dans votre éditeur, n'importe quel onglet peut être sélectionné par défaut. <br><br>  Regardons chacun des onglets, en commençant par la gauche et en se déplaçant vers la droite.  Commençons par l'onglet <b>Agents</b> , qui ressemble à la capture d'écran: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e2/3e9/db3/9e23e9db3a55b407af7a7bde83c56c4b.png"></div><br>  <em>Onglet Agents</em> <br><br>  Si vous travaillez sur un autre projet, vous pouvez constater que certains paramètres sont différents de ceux que nous avons définis pour l'exemple de projet illustré dans la capture d'écran.  En haut de l'onglet, il y a une liste où vous pouvez ajouter de nouveaux types d'agents en cliquant sur le bouton <b>+</b> .  Vous pouvez supprimer des agents supplémentaires en les sélectionnant et en cliquant sur le bouton <b>-</b> .  La fenêtre montre clairement ce que font les différents paramètres lors de leur modification.  Voyons ce que fait chacun des paramètres: <br><br><ul><li>  Nom: nom du type d'agent affiché dans la liste déroulante Types d'agent. </li><li>  Rayon: Vous pouvez le considérer comme «l'espace personnel» d'un agent.  Les agents tenteront d'éviter un contact trop étroit avec d'autres agents sur la base de cette valeur, car elle est utilisée à des fins d'évitement. </li><li>  Hauteur: comme vous pouvez le deviner, ce paramètre définit la hauteur de l'agent qu'il utilise pour l'évitement vertical (par exemple, lors du passage sous des objets). </li><li>  Hauteur de marche: cette valeur détermine la hauteur que l'agent peut grimper. </li><li>  Pente maximale: comme nous le verrons dans la section suivante, cette valeur détermine l'angle maximal auquel l'agent peut monter.  En utilisant ce paramètre, vous pouvez rendre les pentes abruptes de la carte inaccessibles à l'agent. </li></ul><br>  Ensuite, nous avons l'onglet <b>Zones</b> , qui ressemble à celui montré dans cette capture d'écran: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68b/e36/4f6/68be364f6605a8b3f567dfeb31bf56db.png"></div><br>  Comme vous pouvez le voir sur la capture d'écran, Unity propose plusieurs types de zones qui ne peuvent pas être modifiées: <b>Walkable</b> , <b>Not Walkable</b> et <b>Jump</b> .  En plus de nommer et de créer de nouvelles zones, vous pouvez attribuer à ces zones le coût de leur déplacement. <br><br>  Les zones ont deux objectifs: rendre les zones accessibles ou inaccessibles à l'agent et marquer les zones comme moins souhaitables en termes de frais de déplacement.  Par exemple, vous pouvez développer un RPG dans lequel les ennemis démoniaques ne peuvent pas entrer dans les zones marquées comme «terrain consacré».  Vous pouvez également marquer certaines zones de la carte comme un «bourbier» ou un «marais», ce que l'agent évitera en raison du coût élevé du déplacement. <br><br>  Le troisième onglet <b>Bake</b> est probablement le plus important.  Il vous permet de créer NavMesh lui-même pour la scène.  Vous devez déjà être familiarisé avec certaines des options.  L'onglet <b>Bake</b> ressemble à ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16a/fc2/a66/16afc2a6659910152c0f4d673c9bcacb.png"></div><br>  <em>Onglet de cuisson</em> <br><br>  Les options de taille d'agent de cet onglet déterminent la manière dont les agents interagiront avec l'environnement, tandis que les options de l'onglet <b>Agents</b> contrôlent les interactions avec d'autres agents et objets en mouvement.  Mais ils contrôlent les mêmes paramètres, nous allons donc les ignorer.  <b>La hauteur de chute</b> et la <b>distance de saut</b> contrôlent jusqu'où l'agent peut «sauter» pour atteindre la partie de NavMesh qui n'est pas directement liée à celle dans laquelle l'agent se trouve actuellement.  Nous examinerons cela plus en détail ci-dessous, donc si vous n'êtes pas sûr, vous ne pourrez toujours pas étudier ces paramètres. <br><br>  De plus, il existe des options avancées qui sont généralement masquées par défaut.  Pour développer ces options, cliquez simplement sur le triangle déroulant à côté de l'en-tête <b>Avancé</b> .  <b>La taille manuelle du Voxel</b> peut être considérée comme un paramètre de «qualité».  Plus la taille est petite, plus les détails seront stockés dans le maillage.  <b>La zone de région minimale est</b> utilisée pour ignorer les plates-formes de cuisson ou les surfaces inférieures au seuil sélectionné.  <b>La hauteur du maillage</b> nous donne des données verticales plus détaillées lors de la cuisson d'un maillage.  Par exemple, cette option vous permet de conserver l'emplacement correct de l'agent lors de la montée des escaliers. <br><br>  Le bouton <b>Effacer</b> supprime toutes les données NavMesh de la scène et le bouton <b>Bake</b> crée un maillage pour la scène.  Le processus de cuisson est assez rapide.  Tant que vous avez une fenêtre sélectionnée, vous pouvez observer la génération de NavMesh avec le bouton <b>Bake</b> dans la fenêtre de la scène.  Cliquons sur le bouton <b>Bake</b> pour voir les résultats.  Dans notre exemple de scène, nous nous retrouvons avec quelque chose de similaire à cette capture d'écran: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11d/4c5/6ad/11d4c56ad10246e5cb9e56e641938b59.png"></div><br>  Les zones bleues montrent NavMesh.  Ci-dessous, nous y reviendrons.  En attendant, passons au dernier onglet - <b>Objet</b> , qui ressemble à ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/6c7/4e8/b446c74e8154bca80133ff95ce378d31.png"></div><br>  Les trois boutons illustrés dans la capture d'écran précédente - <b>Tous</b> , <b>Rendu de maillage</b> et <b>Terrains</b> - sont utilisés comme filtres de scène.  Ils sont utiles lorsque vous travaillez dans des scènes complexes avec de nombreux objets dans la hiérarchie.  La sélection d'une option filtre le type correspondant dans la hiérarchie, ce qui facilite leur sélection.  Vous pouvez utiliser les boutons pour explorer votre scène à la recherche d'objets que vous souhaitez marquer comme navigation statique. <br><br><h3>  Utilisation de Nav Mesh Agent </h3><br>  Maintenant que nous avons configuré la scène avec NavMesh, nous avons besoin d'un moyen pour l'agent d'utiliser ces informations.  Heureusement pour nous, Unity a un composant <b>Nav Mesh Agent</b> que vous pouvez faire glisser sur un personnage.  Dans notre scène d'exemple, il y a un objet de jeu appelé <b>Tank</b> , auquel un composant est déjà attaché.  Regardez la hiérarchie et vous verrez quelque chose comme ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/3ba/68f/a313ba68f88b2417e0225c6f724cbce8.png"></div><br>  Il y a pas mal de paramètres ici, et nous ne considérerons pas tout car ils sont assez clairs, et la description peut être trouvée dans la documentation officielle de Unity.  Mais nous mentionnerons les principales choses: <br><br><ul><li>  <strong>Type d'agent</strong> : vous vous souvenez de l'onglet <strong>Agents</strong> dans la fenêtre de <strong>navigation</strong> ?  Les types d'agents attribuables peuvent être sélectionnés ici. </li><li>  <strong>Traverse automatique hors lien maillé</strong> : cette option permet aux agents d'utiliser automatiquement la fonction de <strong>liens hors maillage</strong> , dont nous parlerons ci-dessous. </li><li>  <strong>Masque de zone</strong> : vous pouvez sélectionner ici les zones configurées dans l'onglet <strong>Zones</strong> de la fenêtre de <strong>navigation</strong> . </li></ul><br>  C’est tout.  Cette composante fait 90% du travail acharné pour nous: ouvrir la voie, éviter les obstacles, etc.  La seule chose dont vous avez besoin est de transférer le point cible à l'agent.  Regardons ce problème. <br><br><h3>  Réglage du point cible </h3><br>  Après avoir configuré l'agent AI, nous avons besoin d'un moyen de lui dire où aller.  Dans notre exemple de projet, il existe un script appelé <b>Target.cs</b> qui effectue exactement cette tâche. <br><br>  Il s'agit d'une classe simple qui fait trois choses: <br><br><ul><li>  "Tire" le faisceau de la caméra à la position de la souris dans le monde </li><li>  Met à jour la position du marqueur </li><li>  Met à jour la propriété de destination pour tous les agents NavMesh. </li></ul><br>  Le code est assez simple.  La classe entière est la suivante: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Target</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NavMeshAgent[] navAgents; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform targetMarker; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { navAgents = FindObjectsOfType(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(NavMeshAgent)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> NavMeshAgent[]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateTargets</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 targetPosition </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(NavMeshAgent agent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> navAgents) { agent.destination = targetPosition; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GetInput()) { Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hitInfo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray.origin, ray.direction, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hitInfo)) { Vector3 targetPosition = hitInfo.point; UpdateTargets(targetPosition); targetMarker.position = targetPosition; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.DrawLine(targetMarker.position, targetMarker.position + Vector3.up * <span class="hljs-number"><span class="hljs-number">5</span></span>, Color.red); } }</code> </pre> <br>  Les actions suivantes se produisent ici: dans la méthode <b>Start</b> , nous initialisons le tableau <b>navAgents</b> à l'aide de la méthode <b>FindObjectsOfType ()</b> . <br><br>  La méthode <b>UpdateTargets ()</b> passe par notre tableau <b>navAgents</b> et définit le point cible pour eux dans le <b>Vector3</b> donné.  Ceci est la clé du code.  Vous pouvez utiliser n'importe quel mécanisme pour obtenir le point cible, et pour que l'agent s'y déplace, il suffit de définir le champ <b>NavMeshAgent.destination</b> ;  l'agent fera le reste. <br><br>  Dans notre exemple, les clics sont utilisés pour se déplacer, donc lorsqu'un joueur clique sur la souris, nous libérons le rayon de la caméra dans le monde dans la direction du curseur de la souris, et s'il intersecte quelque chose, nous attribuons un point de collision au nouvel agent <b>targetPosition</b> .  Nous ajustons également le marqueur cible en conséquence pour visualiser facilement la destination dans le jeu. <br><br>  Pour tester l'opération, vous devez cuire NavMesh conformément à la description de la section précédente, puis démarrer le mode Lecture et sélectionner n'importe quelle zone sur la carte.  Si vous cliquez plusieurs fois, vous pouvez voir que l'agent ne peut pas atteindre certaines zones - le haut des cubes rouges, la plate-forme supérieure et la plate-forme en bas de l'écran. <br><br>  Les cubes rouges sont trop hauts.  La pente menant à la plate-forme la plus élevée est trop forte pour nos paramètres de <b>pente maximale</b> , et l'agent ne peut pas la grimper.  Les captures d'écran suivantes montrent comment les paramètres <b>Max Slope</b> affectent NavMesh: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd7/539/7b8/fd75397b851d088fc1fd8d4d53210cc9.png"></div><br>  <i>NavMesh avec pente maximale = 45</i> <br><br>  Si vous modifiez la valeur de la <b>pente</b> maximale à quelque chose comme <b>51</b> , puis cliquez à nouveau sur le bouton <b>Bake</b> pour cuire à nouveau NavMesh, les résultats seront les suivants: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09a/936/b78/09a936b78c4958c9200d00867dbbc418.png"></div><br>  <em>NavMesh avec pente maximale = 51</em> <br><br>  Comme vous pouvez le voir, nous pouvons personnaliser la conception des niveaux, rendant des zones entières inaccessibles en modifiant un seul paramètre.  Cela peut être utile, par exemple, lorsque vous avez une plate-forme ou un rebord qui nécessite une corde, une échelle ou un ascenseur pour grimper.  Ou peut-être une compétence spéciale, par exemple, la capacité de grimper? <br><br><h3>  Application hors liens maillés </h3><br>  Vous remarquerez peut-être qu'il y a deux ruptures dans notre scène.  Notre agent peut entrer dans le premier, mais celui en bas de l'écran est trop loin.  Ces calculs ne sont pas complètement arbitraires.  <strong>Les liens hors maillage</strong> créent essentiellement un pont à travers les espaces entre les segments NavMesh non liés.  Ces liens peuvent être vus dans l'éditeur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4b/b0a/425/b4bb0a425446298ae08ea4684bbcef10.png"></div><br>  <i>Les cercles bleus avec des lignes de connexion sont des connexions.</i> <br><br>  Unity peut générer ces liens de deux manières.  Le premier que nous avons déjà envisagé.  Vous vous souvenez de la valeur de <b>distance de saut</b> dans l'onglet <b>Bake</b> de la fenêtre de <b>navigation</b> ?  Unity utilise automatiquement cette valeur pour générer ces liens lors de la cuisson de NavMesh.  Essayez de changer la valeur de notre scène de test en 5 et de recommencer la cuisson.  Vous voyez, les plateformes sont maintenant connectées?  Cela est dû au fait que les maillages sont désormais dans le nouveau seuil spécifié. <br><br>  Changez à nouveau la valeur à 2 et faites cuire.  Voyons maintenant la deuxième façon.  Créez les sphères qui seront utilisées pour connecter les deux plates-formes.  Placez-les approximativement comme indiqué dans la capture d'écran: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7a/28e/020/a7a28e020255bb8855d48017da4188f1.png"></div><br>  Vous pouvez déjà voir ce qui se passe, mais analysons le processus qui leur permet de se connecter.  Dans notre cas, j'ai appelé la sphère à droite et la sphère à gauche.  Vous comprendrez bientôt pourquoi.  Ensuite, j'ai ajouté le composant <b>Off Mesh Link</b> à la plate-forme à droite (par rapport à la capture d'écran précédente).  Vous remarquerez que le composant a des champs de <b>début</b> et de <b>fin</b> .  Comme vous pouvez le deviner, nous allons faire glisser les sphères précédemment créées dans les emplacements correspondants - la sphère de début dans le champ de <b>début</b> et la sphère de fin dans le champ de <b>fin</b> .  L'inspecteur ressemblera à ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/720/2b4/251/7202b4251068b5d0b1b8b1d7e4b09ff2.png"></div><br>  La valeur de <b>Cost Override est</b> prise en compte lorsqu'elle reçoit une valeur positive.  Il applique un facteur de coût lors de l'utilisation de cette relation, par opposition à un itinéraire plus rentable vers la cible. <br><br>  <b>Bi-directionnel</b> si vrai permet à l'agent de se déplacer dans les deux sens.  Pour créer des liens avec un trafic à sens unique, vous pouvez désactiver cette valeur.  La valeur <b>Activé est</b> utilisée selon son nom.  Si faux, l'agent ignore cette association.  Vous pouvez l'activer et le désactiver pour créer des scénarios de jeu dans lesquels, par exemple, un joueur doit appuyer sur un interrupteur pour activer une connexion. <br><br>  Pour activer cette relation, une nouvelle cuisson n'est pas nécessaire.  Regardez votre NavMesh et vous verrez qu'il ressemble exactement à la capture d'écran: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be8/15a/e57/be815ae574360beea94d8907e37fc309.png"></div><br>  Comme vous pouvez le voir, le plus petit espace se connecte toujours automatiquement, et nous avons maintenant une nouvelle connexion générée par le composant <b>Off Mesh Link</b> entre les deux sphères.  Lancez le mode Play et cliquez sur la plate-forme éloignée.  Comme prévu, l'agent peut désormais accéder à la plateforme déconnectée: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f6/0c7/a61/7f60c7a61db24f3961ea0b7332de56a1.png"></div><br>  Aux niveaux de votre jeu, vous devrez peut-être modifier ces paramètres pour obtenir les résultats souhaités, mais une combinaison de ces fonctionnalités vous fournit un outil pratique et prêt à l'emploi.  Vous pouvez rapidement créer un jeu simple en utilisant la fonctionnalité NavMesh. <br><br>  <em>Ce didacticiel fait partie de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">la programmation AI de jeu Unity 2017 - troisième édition</a> par Ray Barrera, Aung Sithu Kyaw et Thet Naing Swe.</em> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414453/">https://habr.com/ru/post/fr414453/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414443/index.html">Caractéristiques des appels de fonction en C ++</a></li>
<li><a href="../fr414445/index.html">Améliorer Zimbra avec la suite Zextras</a></li>
<li><a href="../fr414447/index.html">Des trésors de tous les temps</a></li>
<li><a href="../fr414449/index.html">Comment se faire des amis de tous les opérateurs du stade et ne pas l'ensemencer avec des centaines d'antennes</a></li>
<li><a href="../fr414451/index.html">"Calendrier des testeurs" pour juin. Le testeur doit attraper le bug, lire Caner et organiser le déplacement.</a></li>
<li><a href="../fr414455/index.html">Algorithme de génération de palette de couleurs</a></li>
<li><a href="../fr414459/index.html">Détecteurs et descripteurs de points singuliers FAST, BRIEF, ORB</a></li>
<li><a href="../fr414463/index.html">L'IA elle-même a appris à construire un Rubik's Cube</a></li>
<li><a href="../fr414465/index.html">Meta Crush Saga: jeu de compilation</a></li>
<li><a href="../fr414467/index.html">Articles de la conférence Minsk C ++ CoreHard Spring 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>