<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💻 🈸 🧒🏿 Praktik Terbaik Node.js - Tip Struktur Proyek 👜 🏧 👩🏾‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya sajikan kepada Anda terjemahan adaptasi dari bab pertama " Praktik Terbaik Node.js " oleh Yoni Goldberg. Pilihan rekomendasi pada Nod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Praktik Terbaik Node.js - Tip Struktur Proyek</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454476/"><img src="https://habrastorage.org/webt/1s/eu/vv/1seuvv9zdxaimyzdcixzoolp1li.png"><br>  Halo, Habr!  Saya sajikan kepada Anda terjemahan adaptasi dari bab pertama " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Praktik Terbaik Node.js</a> " oleh Yoni Goldberg.  Pilihan rekomendasi pada Node.js diposting di github, memiliki hampir 30 ton bintang, tetapi sejauh ini belum disebutkan di Habré.  Saya kira informasi ini akan berguna, setidaknya untuk pemula. <br><a name="habracut"></a><br><h2>  1. Tip struktur proyek </h2><br><h3>  1.1 Struktur proyek Anda dengan komponen </h3><br>  Kesalahan terburuk dari aplikasi besar adalah arsitektur monolit dalam bentuk basis kode besar dengan sejumlah besar dependensi (kode spaghetti), struktur ini sangat memperlambat perkembangan, terutama pengenalan fungsi-fungsi baru.  Tip - pisahkan kode Anda menjadi komponen-komponen terpisah, untuk setiap komponen, pilih folder Anda sendiri untuk modul komponen.  Penting agar setiap modul tetap kecil dan sederhana.  Di bagian "Perincian", Anda dapat melihat contoh struktur proyek yang benar. <br><br>  <b>Jika tidak:</b> akan sulit bagi pengembang untuk mengembangkan produk - menambahkan fungsionalitas baru dan membuat perubahan pada kode akan lambat dan memiliki peluang besar untuk melanggar komponen dependen lainnya.  Diyakini bahwa jika unit bisnis tidak dibagi, maka masalah dapat muncul dengan meningkatkan aplikasi. <br><br><div class="spoiler">  <b class="spoiler_title">Detail</b> <div class="spoiler_text">  <b>Penjelasan satu paragraf</b> <br><br>  Untuk aplikasi ukuran sedang dan di atas, monolith benar-benar buruk - satu program besar dengan banyak dependensi sulit untuk dipahami, dan seringkali mengarah ke kode spageti.  Bahkan programmer berpengalaman yang tahu bagaimana “mempersiapkan modul” dengan baik menghabiskan banyak usaha pada desain arsitektur dan mencoba untuk secara hati-hati mengevaluasi konsekuensi dari setiap perubahan dalam hubungan antara objek.  Pilihan terbaik adalah arsitektur yang didasarkan pada sekumpulan program komponen kecil: bagi program menjadi komponen terpisah yang tidak berbagi file dengan siapa pun, setiap komponen harus terdiri dari sejumlah kecil modul (misalnya, modul: API, layanan, akses basis data, pengujian dll.), sehingga struktur dan komposisi komponennya jelas.  Beberapa orang mungkin menyebut arsitektur ini sebagai "layanan mikro", tetapi penting untuk memahami bahwa layanan mikro bukanlah spesifikasi yang harus Anda ikuti, melainkan serangkaian prinsip.  Atas permintaan Anda, Anda dapat mengadopsi kedua prinsip ini dan semua prinsip arsitektur layanan mikro.  Kedua metode ini baik jika Anda menjaga kompleksitas kode tetap rendah. <br><br>  Paling tidak yang harus Anda lakukan adalah menentukan batas-batas antara komponen: menetapkan folder di root proyek Anda untuk masing-masing komponen dan membuatnya sendiri.  Akses ke fungsionalitas komponen harus dilaksanakan hanya melalui antarmuka publik atau API.  Ini adalah dasar untuk menjaga kesederhanaan komponen Anda, menghindari "neraka ketergantungan" dan membiarkan aplikasi Anda tumbuh menjadi layanan-mikro sepenuhnya. <br><br>  <b>Kutipan dari blog: "Penskalaan membutuhkan penskalaan seluruh aplikasi"</b> <br>  Dari Blog MartinFowler.com <br><blockquote>  Aplikasi monolitik bisa berhasil, tetapi orang semakin frustrasi dengan mereka, terutama ketika berpikir tentang penggelaran ke cloud.  Perubahan apa pun, meskipun kecil, dalam aplikasi memerlukan perakitan dan pemindahan seluruh monolit.  Seringkali sulit untuk mempertahankan struktur modular yang baik di mana perubahan dalam satu modul tidak mempengaruhi modul lainnya.  Penskalaan membutuhkan penskalaan seluruh aplikasi, dan bukan hanya bagian-bagiannya saja, tentu saja, pendekatan ini membutuhkan lebih banyak usaha. </blockquote><br>  <b>Kutipan dari blog: "Apa yang dibicarakan arsitektur aplikasi Anda?"</b> <br>  Dari blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paman-bob</a> <br><blockquote>  ... jika Anda pernah ke perpustakaan, maka Anda mewakili arsitekturnya: pintu masuk utama, meja resepsionis, ruang baca, ruang konferensi, dan banyak aula dengan rak buku.  Arsitekturnya sendiri akan mengatakan: bangunan ini adalah perpustakaan. </blockquote><br>  Jadi apa yang dibicarakan oleh arsitektur aplikasi Anda?  Ketika Anda melihat struktur direktori tingkat atas dan file modul di dalamnya, mereka berkata: Saya adalah toko online, saya seorang akuntan, saya sistem manajemen produksi?  Atau apakah mereka berteriak: Aku Rails, aku Spring / Hibernate, aku ASP? <br>  (Catatan Penerjemah, Rails, Spring / Hibernate, ASP adalah frameworks dan teknologi web). <br><br>  <b>Struktur proyek yang tepat dengan komponen otonom</b> <br><br><img src="https://habrastorage.org/webt/mp/g5/q8/mpg5q82ipd9tnobr96aq8_smbte.png"><br><br>  <b>Struktur proyek salah dengan pengelompokan file berdasarkan tujuan</b> <br><br><img src="https://habrastorage.org/webt/3p/sd/e-/3psde-16jcizpuabedn_afgpfsg.png"><br></div></div><br><h3>  1.2 Pisahkan lapisan komponen Anda dan jangan campur dengan struktur data Express </h3><br>  Setiap komponen Anda harus memiliki "lapisan", misalnya, untuk bekerja dengan web, logika bisnis, akses ke database, lapisan ini harus memiliki format data sendiri tidak dicampur dengan format data perpustakaan pihak ketiga.  Ini tidak hanya secara jelas memisahkan masalah, tetapi juga sangat memudahkan verifikasi dan pengujian sistem.  Seringkali, pengembang API mencampur lapisan dengan mengirimkan objek lapisan web Express (seperti req, res) ke logika bisnis dan lapisan data - ini membuat aplikasi Anda bergantung dan sangat terhubung dengan Express. <br><br>  <b>Kalau tidak:</b> untuk aplikasi di mana objek layer dicampur, lebih sulit untuk menyediakan pengujian kode, pengorganisasian tugas CRON dan panggilan non-Express lainnya. <br><br><div class="spoiler">  <b class="spoiler_title">Detail</b> <div class="spoiler_text">  <b>Bagilah kode komponen menjadi beberapa lapisan: web, layanan, dan <abbr title="Lapisan Akses Data - lapisan akses data">DAL</abbr></b> <br><br><img src="https://habrastorage.org/webt/mp/g5/q8/mpg5q82ipd9tnobr96aq8_smbte.png"><br><br>  <b>Sisi lain adalah mencampur lapisan dalam satu animasi gif</b> <br><br><img src="https://habrastorage.org/webt/ma/to/2e/mato2eau6nrt3dr0kcqi9fawmee.gif"><br></div></div><br><h3>  1.3 Bungkus utilitas dasar Anda dalam paket npm </h3><br>  Dalam aplikasi besar yang terdiri dari berbagai layanan dengan repositori mereka sendiri, utilitas universal seperti logger, enkripsi, dll., Harus dibungkus dengan kode Anda sendiri dan disajikan sebagai paket npm pribadi.  Ini memungkinkan Anda untuk membaginya di antara beberapa basis kode dan proyek. <br><br>  <b>Jika tidak:</b> Anda harus menciptakan sepeda sendiri untuk membagikan kode ini di antara basis kode yang terpisah. <br><br><div class="spoiler">  <b class="spoiler_title">Detail</b> <div class="spoiler_text">  <b>Penjelasan satu paragraf</b> <br><br>  Segera setelah proyek mulai tumbuh dan Anda memiliki komponen yang berbeda di server yang berbeda menggunakan utilitas yang sama, Anda harus mulai mengelola dependensi.  Bagaimana saya bisa mengizinkan beberapa komponen untuk menggunakannya tanpa menduplikasi kode utilitas Anda di antara repositori?  Ada alat khusus untuk ini, dan ini disebut npm ....  Mulailah dengan membungkus paket utilitas pihak ketiga dengan kode Anda sendiri sehingga Anda dapat dengan mudah menggantinya di masa mendatang, dan terbitkan kode ini sebagai paket npm pribadi.  Sekarang seluruh basis kode Anda dapat mengimpor kode utilitas dan menggunakan semua fitur manajemen ketergantungan npm.  Ingatlah bahwa ada cara berikut untuk mempublikasikan paket npm untuk penggunaan pribadi tanpa membukanya untuk akses publik: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pribadi, registri pribadi,</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paket npm lokal</a> . <br><br>  <b>Membagikan utilitas bersama Anda di lingkungan yang berbeda</b> <br><img src="https://habrastorage.org/webt/ll/yp/zt/llypztuehnlrksisayzdto91jzq.png"><br></div></div><br><h3>  1.4 Pisahkan Express menjadi "aplikasi" dan "server" </h3><br>  Hindari kebiasaan yang tidak menyenangkan untuk mendefinisikan seluruh aplikasi Express dalam satu file besar, pisahkan kode 'Express' Anda menjadi setidaknya dua file: deklarasi API (app.js) dan kode server www.  Untuk struktur yang lebih baik lagi, letakkan deklarasi API dalam modul komponen. <br><br>  <b>Jika tidak:</b> API Anda hanya akan tersedia untuk pengujian melalui panggilan HTTP (yang lebih lambat dan jauh lebih sulit untuk menghasilkan laporan cakupan).  Namun, saya rasa, tidak terlalu menyenangkan bekerja dengan ratusan baris kode dalam satu file. <br><br><div class="spoiler">  <b class="spoiler_title">Detail</b> <div class="spoiler_text">  <b>Penjelasan satu paragraf</b> <br><br>  Kami merekomendasikan penggunaan generator aplikasi Express dan pendekatannya untuk membangun database aplikasi: deklarasi API dipisahkan dari konfigurasi server (data port, protokol, dll.).  Ini memungkinkan Anda untuk menguji API tanpa membuat panggilan jaringan, yang mempercepat pengujian dan membuatnya lebih mudah untuk mendapatkan metrik cakupan kode.  Ini juga memungkinkan Anda untuk secara fleksibel menggunakan API yang sama untuk pengaturan jaringan server yang berbeda.  Sebagai bonus, Anda juga mendapatkan pemisahan tanggung jawab dan kode bersih yang lebih baik. <br><br>  <b>Kode sampel: Deklarasi API, harus di app.js</b> <br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = express(); app.use(bodyParser.json()); app.use(<span class="hljs-string"><span class="hljs-string">"/api/events"</span></span>, events.API); app.use(<span class="hljs-string"><span class="hljs-string">"/api/forms"</span></span>, forms);</code> </pre> <br>  <b>Contoh kode: parameter jaringan server, harus dalam / bin / www</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../app'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>); <span class="hljs-comment"><span class="hljs-comment">/** *          Express. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> port = normalizePort(process.env.PORT || <span class="hljs-string"><span class="hljs-string">'3000'</span></span>); app.set(<span class="hljs-string"><span class="hljs-string">'port'</span></span>, port); <span class="hljs-comment"><span class="hljs-comment">/** *  HTTP-. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> server = http.createServer(app);</code> </pre> <br><br>  <b>Contoh: menguji API kami menggunakan supertest (paket pengujian populer)</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express(); app.get(<span class="hljs-string"><span class="hljs-string">'/user'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">) </span></span>{ res.status(<span class="hljs-number"><span class="hljs-number">200</span></span>).json({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'tobi'</span></span> }); }); request(app) .get(<span class="hljs-string"><span class="hljs-string">'/user'</span></span>) .expect(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>, /json/) .expect(<span class="hljs-string"><span class="hljs-string">'Content-Length'</span></span>, <span class="hljs-string"><span class="hljs-string">'15'</span></span>) .expect(<span class="hljs-number"><span class="hljs-number">200</span></span>) .end(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; });</code> </pre> <br></div></div><br><h3>  1.5 Gunakan konfigurasi hierarki aman berdasarkan variabel lingkungan </h3><br>  Pengaturan konfigurasi yang ideal harus menyediakan: <br><br>  (1) membaca kunci dari kedua file konfigurasi dan variabel lingkungan, <br>  (2) menyimpan rahasia di luar kode repositori, <br>  (3) struktur data hierarkis (bukan datar) dari file konfigurasi untuk memudahkan pekerjaan dengan pengaturan. <br><br>  Ada beberapa paket yang dapat membantu mengimplementasikan poin-poin ini, seperti: rc, nconf, dan config. <br><br>  <b>Jika tidak:</b> kegagalan untuk mematuhi persyaratan konfigurasi ini akan menyebabkan terganggunya pekerjaan baik pengembang individu dan seluruh tim. <br><br><div class="spoiler">  <b class="spoiler_title">Detail</b> <div class="spoiler_text">  <b>Penjelasan satu paragraf</b> <br><br>  Saat Anda berhadapan dengan pengaturan konfigurasi, banyak hal yang dapat mengganggu dan memperlambat: <br><br>  1. Mengatur semua parameter menggunakan variabel lingkungan menjadi sangat membosankan jika Anda perlu memasukkan 100+ kunci (alih-alih hanya memperbaikinya dalam file konfigurasi), namun, jika konfigurasi hanya akan ditentukan dalam file pengaturan, ini mungkin merepotkan bagi DevOps.  Solusi konfigurasi yang andal harus menggabungkan kedua metode: file konfigurasi dan parameter yang ditimpa dari variabel lingkungan. <br><br>  2. Jika file konfigurasi JSON "flat" (yaitu, semua kunci ditulis sebagai satu daftar), maka dengan peningkatan jumlah pengaturan akan sulit untuk bekerja dengannya.  Masalah ini dapat diselesaikan dengan membentuk struktur bersarang yang berisi kelompok kunci sesuai dengan bagian pengaturan, mis.  mengatur struktur data JSON hirarkis (lihat contoh di bawah).  Ada pustaka yang memungkinkan Anda untuk menyimpan konfigurasi ini di beberapa file dan menggabungkan data dari mereka pada saat run time. <br><br>  3. Tidak disarankan untuk menyimpan informasi rahasia (seperti kata sandi basis data) dalam file konfigurasi, tetapi tidak ada solusi mudah yang pasti untuk tempat dan cara menyimpan informasi tersebut.  Beberapa perpustakaan konfigurasi memungkinkan Anda untuk mengenkripsi file konfigurasi, yang lain mengenkripsi entri ini selama git melakukan, atau Anda tidak perlu menyimpan parameter rahasia dalam file sama sekali dan menetapkan nilainya selama penyebaran melalui variabel lingkungan. <br><br>  4. Beberapa skenario konfigurasi lanjutan mengharuskan Anda memasukkan kunci melalui baris perintah (vargs) atau menyinkronkan data konfigurasi melalui cache terpusat seperti Redis sehingga beberapa server menggunakan data yang sama. <br><br>  Ada pustaka npm yang akan membantu Anda dengan implementasi sebagian besar dari rekomendasi ini, kami sarankan Anda untuk melihat pustaka berikut: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rc</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nconf</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">config</a> . <br><br>  <b>Contoh kode: struktur hierarkis membantu menemukan catatan dan bekerja dengan file konfigurasi yang banyak</b> <b><br></b> <br><pre> <code class="json hljs">{ // Customer module configs <span class="hljs-attr"><span class="hljs-attr">"Customer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"dbConfig"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"host"</span></span>: <span class="hljs-string"><span class="hljs-string">"localhost"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"port"</span></span>: <span class="hljs-number"><span class="hljs-number">5984</span></span>, <span class="hljs-attr"><span class="hljs-attr">"dbName"</span></span>: <span class="hljs-string"><span class="hljs-string">"customers"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"credit"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"initialLimit"</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, // Set low for development <span class="hljs-attr"><span class="hljs-attr">"initialDays"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } } }</code> </pre><br>  (Catatan Penerjemah, komentar tidak dapat digunakan dalam file JSON klasik. Contoh di atas diambil dari dokumentasi perpustakaan konfigurasi, yang menambahkan fungsionalitas untuk pra-membersihkan file JSON dari komentar. Oleh karena itu, contoh ini cukup berfungsi, namun, serat seperti ESLint dengan pengaturan default dapat "Bersumpah" pada format yang sama). <br></div></div><br>  Kata penutup dari penerjemah: <br><br><ol><li>  Deskripsi proyek mengatakan bahwa terjemahan ke dalam bahasa Rusia telah diluncurkan, tetapi saya tidak menemukan terjemahan ini di sana, jadi saya mengambil artikel itu. </li><li>  Jika terjemahannya tampak sangat singkat bagi Anda, maka cobalah untuk memperluas informasi terperinci di setiap bagian. </li><li>  Maaf ilustrasi tidak diterjemahkan. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454476/">https://habr.com/ru/post/id454476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454462/index.html">Fotogram tanpa kertas foto</a></li>
<li><a href="../id454464/index.html">Pengembangan tes visual berdasarkan Gemini dan Storybook</a></li>
<li><a href="../id454470/index.html">Hidup sebelum runtime. Laporan Yandex</a></li>
<li><a href="../id454472/index.html">Yang Perlu Anda Ketahui Tentang Patch Router Terbaru Cisco</a></li>
<li><a href="../id454474/index.html">Acara digital di Moskow dari 3 hingga 9 Juni</a></li>
<li><a href="../id454478/index.html">Ekstensi Azure IoT Edge Tools (Pratinjau) diumumkan</a></li>
<li><a href="../id454482/index.html">Pelajaran pahit di industri AI</a></li>
<li><a href="../id454484/index.html">Jaringan saraf tiruan dijelaskan dengan kata-kata sederhana</a></li>
<li><a href="../id454486/index.html">Tragedi Common Lisp: mengapa bahasa populer membengkak dalam kompleksitas</a></li>
<li><a href="../id454488/index.html">Keadaan elektronik masa depan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>