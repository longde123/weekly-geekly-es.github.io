<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤥 👨🏿‍🔬 📛 Pengantar Kebijakan Jaringan Kubernet untuk Profesional Keamanan 💪🏼 👶🏾 💛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan perev. : Penulis artikel - Reuven Harrison - memiliki lebih dari 20 tahun pengalaman dalam pengembangan perangkat lunak, dan hari ini adalah d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengantar Kebijakan Jaringan Kubernet untuk Profesional Keamanan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/443190/"><img src="https://habrastorage.org/webt/dt/ya/kp/dtyakpb8umg8hkfvtfcrll8kc9y.png"><br><br>  <i><b>Catatan</b></i>  <i><b>perev.</b></i>  <i>: Penulis artikel - Reuven Harrison - memiliki lebih dari 20 tahun pengalaman dalam pengembangan perangkat lunak, dan hari ini adalah direktur teknis dan salah satu pendiri Tufin, sebuah perusahaan yang menciptakan solusi manajemen kebijakan keamanan.</i>  <i>Mempertimbangkan kebijakan jaringan Kubernetes sebagai alat yang cukup kuat untuk segmentasi jaringan dalam sebuah cluster, ia percaya bahwa mereka tidak begitu mudah untuk diterapkan dalam praktik.</i>  <i>Materi ini (agak banyak) dirancang untuk meningkatkan pengetahuan spesialis dalam hal ini dan membantu mereka dalam membuat konfigurasi yang diperlukan.</i> <a name="habracut"></a><br><br>  Saat ini, banyak perusahaan semakin memilih Kubernetes untuk menjalankan aplikasi mereka.  Ketertarikan pada perangkat lunak ini sangat tinggi sehingga beberapa orang menyebut Kubernetes "sistem operasi pusat data baru."  Secara bertahap, Kubernetes (atau k8s) mulai dianggap sebagai bagian penting dari bisnis, yang membutuhkan organisasi proses bisnis yang matang, termasuk keamanan jaringan. <br><br>  Untuk para profesional keamanan yang bingung karena bekerja dengan Kubernetes, kebijakan default platform ini mungkin merupakan penemuan nyata: biarkan semuanya. <br><br>  Panduan ini akan membantu Anda memahami struktur internal kebijakan jaringan;  Pahami perbedaannya dari aturan untuk firewall biasa.  Beberapa jebakan juga akan dijelaskan dan rekomendasi akan diberikan yang akan membantu melindungi aplikasi di Kubernetes. <br><br><h2>  Kebijakan Jaringan Kubernetes </h2><br>  Mekanisme kebijakan jaringan Kubernetes memungkinkan Anda untuk mengontrol interaksi aplikasi yang digunakan pada platform di tingkat jaringan (yang ketiga dalam model OSI).  Kebijakan jaringan tidak memiliki beberapa fitur canggih firewall modern, seperti pemantauan OSI tingkat 7 dan deteksi ancaman, tetapi mereka memberikan tingkat dasar keamanan jaringan, yang merupakan titik awal yang baik. <br><br><h2>  Kebijakan jaringan mengontrol komunikasi antar pod </h2><br>  Beban kerja Kubernet didistribusikan di seluruh pod yang terdiri dari satu atau lebih kontainer yang digunakan bersama.  Kubernetes memberi setiap pod alamat IP yang dapat diakses dari pod lainnya.  Kebijakan jaringan Kubernetes menetapkan izin untuk grup pod dengan cara yang sama seperti grup keamanan di cloud digunakan untuk mengontrol akses ke mesin virtual virtual. <br><br><h2>  Menentukan Kebijakan Jaringan </h2><br>  Seperti sumber daya Kubernet lainnya, kebijakan jaringan diatur dalam YAML.  Pada contoh di bawah ini, <code>balance</code> diberikan akses ke <code>postgres</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.postgres namespace: default spec: podSelector: matchLabels: app: postgres ingress: - from: - podSelector: matchLabels: app: balance policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/ee/d3/wf/eed3wfhzcdtuhobly7r3wdhyvhk.png"><br><br>  <i>( <b>Catatan</b> : tangkapan layar ini, seperti semua tangkapan layar serupa berikutnya, tidak dibuat menggunakan alat asli Kubernetes, tetapi menggunakan alat Tufin Orca, yang dikembangkan oleh penulis artikel asli dan disebutkan di akhir artikel.)</i> <br><br>  Menentukan kebijakan jaringan Anda sendiri akan membutuhkan pengetahuan dasar YAML.  Bahasa ini didasarkan pada lekukan (ditentukan oleh spasi, bukan tab).  Elemen indentasi milik elemen indentasi terdekat di atasnya.  Item daftar baru dimulai dengan tanda hubung, semua item lainnya <i>bernilai kunci</i> . <br><br>  Setelah mendeskripsikan kebijakan dalam YAML, gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kubectl</a> untuk membuatnya di cluster: <br><br><pre> <code class="bash hljs">kubectl create -f policy.yaml</code> </pre> <br><h2>  Spesifikasi Kebijakan Jaringan </h2><br>  Spesifikasi Kebijakan Jaringan Kubernetes mencakup empat elemen: <br><br><ol><li>  <code>podSelector</code> : mendefinisikan pod yang dipengaruhi oleh kebijakan (sasaran) ini - wajib; </li><li>  <code>policyTypes</code> : menunjukkan jenis kebijakan apa yang termasuk dalam ini: masuk dan / atau keluar - opsional, namun, saya sarankan Anda mendaftar secara eksplisit dalam semua kasus; </li><li>  <code>ingress</code> : menentukan lalu lintas <b>masuk yang</b> diizinkan ke pod target - opsional; </li><li>  <code>egress</code> : menentukan lalu lintas <b>keluar yang</b> diizinkan dari pod target - opsional. </li></ol><br>  Contoh yang dipinjam dari situs web Kubernetes (saya mengganti <code>role</code> dengan <code>app</code> ) menunjukkan bagaimana keempat elemen digunakan: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: test-network-policy namespace: default spec: podSelector: # &lt;&lt;&lt; matchLabels: app: db policyTypes: # &lt;&lt;&lt; - Ingress - Egress ingress: # &lt;&lt;&lt; - from: - ipBlock: cidr: 172.17.0.0/16 except: - 172.17.1.0/24 - namespaceSelector: matchLabels: project: myproject - podSelector: matchLabels: role: frontend ports: - protocol: TCP port: 6379 egress: # &lt;&lt;&lt; - to: - ipBlock: cidr: 10.0.0.0/24 ports: - protocol: TCP port: 5978</code> </pre> <br><img src="https://habrastorage.org/webt/ln/sa/ni/lnsanisggaar5tf3lbda8njxaau.png"><br><img src="https://habrastorage.org/webt/bo/re/in/borein4ll_4hoovj6vdhlo_zfee.png"><br><br>  Harap dicatat bahwa keempat elemen bersifat opsional.  Hanya <code>podSelector</code> yang <code>podSelector</code> , parameter lain dapat digunakan sesuai keinginan. <br><br>  Jika Anda menghilangkan <code>policyTypes</code> , kebijakan tersebut akan ditafsirkan sebagai berikut: <br><br><ul><li>  Secara default, diasumsikan bahwa itu mendefinisikan sisi masuknya.  Jika kebijakan tidak secara eksplisit menunjukkan hal ini, sistem akan mempertimbangkan bahwa semua lalu lintas dilarang. </li><li>  Perilaku di sisi jalan keluar akan ditentukan oleh ada atau tidak adanya parameter jalan keluar yang sesuai. </li></ul><br>  Untuk menghindari kesalahan, saya sarankan untuk <b>selalu secara eksplisit menentukan <code>policyTypes</code></b> . <br><br>  Sesuai dengan logika di atas, jika <code>egress</code> <code>ingress</code> dan / atau <code>egress</code> dihilangkan, kebijakan akan melarang semua lalu lintas (lihat "Aturan pengupasan" di bawah). <br><br><h2>  Kebijakan default adalah mengizinkan </h2><br>  Jika tidak ada kebijakan yang ditentukan, Kubernetes secara default memungkinkan semua lalu lintas.  Semua pod bebas bertukar informasi satu sama lain.  Dari sudut pandang keamanan, ini mungkin tampak berlawanan dengan intuisi, tetapi ingat bahwa Kubernet awalnya dibuat oleh pengembang untuk memastikan interoperabilitas aplikasi.  Kebijakan jaringan ditambahkan kemudian. <br><br><h2>  Ruang nama </h2><br>  Ruang nama adalah mekanisme kolaboratif Kubernetes.  Mereka dirancang untuk mengisolasi lingkungan logis dari satu sama lain, sementara pertukaran data antar ruang diizinkan secara default. <br><br>  Seperti kebanyakan komponen Kubernetes, kebijakan jaringan berada di namespace tertentu.  Di blok <code>metadata</code> , Anda bisa menentukan ruang mana kebijakan itu milik: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: test-network-policy namespace: my-namespace # &lt;&lt;&lt; spec: ...</code> </pre> <br>  Jika namespace tidak ditulis secara eksplisit dalam metadata, sistem akan menggunakan namespace yang ditentukan dalam kubectl (secara default <code>namespace=default</code> ): <br><br><pre> <code class="bash hljs">kubectl apply -n my-namespace -f namespace.yaml</code> </pre> <br>  Saya merekomendasikan <b>secara eksplisit menentukan namespace</b> kecuali Anda menulis kebijakan yang ditujukan untuk beberapa namespace sekaligus. <br><br>  Elemen <code>podSelector</code> <b>utama</b> dalam suatu kebijakan akan memilih pod dari namespace yang dimiliki kebijakan tersebut (ditolak akses ke pod dari namespace lain). <br><br>  Demikian pula, podSelector <b>dalam blok masuk dan keluar</b> dapat memilih pod hanya dari namespace mereka, kecuali, jika Anda menggabungkannya dengan <code>namespaceSelector</code> (ini akan dibahas di bagian “Memfilter menurut namespace dan pod”) . <br><br><h2>  Aturan Penamaan Kebijakan </h2><br>  Nama kebijakan unik dalam satu ruang nama.  Mungkin tidak ada dua kebijakan dengan nama yang sama dalam satu ruang, tetapi mungkin ada kebijakan dengan nama yang sama di ruang yang berbeda.  Ini berguna ketika Anda ingin menerapkan kembali kebijakan yang sama di beberapa ruang. <br><br>  Saya terutama menyukai satu cara penamaan.  Ini terdiri dalam menggabungkan nama namespace dengan pod target.  Sebagai contoh: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.postgres # &lt;&lt;&lt; namespace: default spec: podSelector: matchLabels: app: postgres ingress: - from: - podSelector: matchLabels: app: admin policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/pp/rf/6a/pprf6aa0w2bysbuw6_-lbt926mi.png"><br><br><h2>  Label </h2><br>  Label khusus dapat dilampirkan ke objek Kubernetes, seperti pod dan ruang nama.  Label adalah setara dengan tag di cloud.  Kebijakan jaringan Kubernetes menggunakan label untuk memilih <b>pod</b> yang mereka terapkan: <br><br><pre> <code class="plaintext hljs">podSelector: matchLabels: role: db</code> </pre> <br>  ... atau <b>ruang nama</b> yang mereka terapkan.  Dalam contoh ini, semua pod di ruang nama dengan label yang sesuai dipilih: <br><br><pre> <code class="plaintext hljs">namespaceSelector: matchLabels: project: myproject</code> </pre> <br>  Satu peringatan: ketika menggunakan <code>namespaceSelector</code> <b>pastikan</b> <code>namespaceSelector</code> <b>Anda pilih berisi label yang Anda inginkan</b> .  Ingatlah bahwa ruang nama <code>default</code> seperti <code>default</code> dan <code>kube-system</code> tidak mengandung label secara default. <br><br>  Anda dapat menambahkan label ke spasi sebagai berikut: <br><br><pre> <code class="bash hljs">kubectl label namespace default namespace=default</code> </pre> <br>  Dalam kasus ini, namespace di bagian <code>metadata</code> harus merujuk ke nama sebenarnya dari spasi, dan bukan ke label: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: test-network-policy namespace: default # &lt;&lt;&lt; spec: ...</code> </pre> <br><h2>  Sumber dan Tujuan </h2><br>  Kebijakan untuk firewall terdiri dari aturan dengan sumber dan tujuan.  Kebijakan jaringan Kubernetes didefinisikan untuk tujuan - satu set pod yang menerapkannya, dan kemudian menetapkan aturan untuk lalu lintas masuk (masuk) dan / atau keluar (keluar).  Dalam contoh kami, target kebijakan adalah semua pod di namespace <code>default</code> dengan label dengan kunci <code>app</code> dan nilai <code>db</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: test-network-policy namespace: default spec: podSelector: matchLabels: app: db # &lt;&lt;&lt; policyTypes: - Ingress - Egress ingress: - from: - ipBlock: cidr: 172.17.0.0/16 except: - 172.17.1.0/24 - namespaceSelector: matchLabels: project: myproject - podSelector: matchLabels: role: frontend ports: - protocol: TCP port: 6379 egress: - to: - ipBlock: cidr: 10.0.0.0/24 ports: - protocol: TCP port: 5978</code> </pre> <br><img src="https://habrastorage.org/webt/zd/un/wi/zdunwi6xxqfdkvd7tj0qqpmjxly.png"><br><img src="https://habrastorage.org/webt/se/dj/wp/sedjwp5-arw7sxn7hm4dblgqhku.png"><br><br>  <code>ingress</code> dalam kebijakan ini membuka lalu lintas masuk ke pod target.  Dengan kata lain, masuknya adalah sumber, dan target adalah penerima yang tepat.  Demikian pula, jalan keluar adalah target, dan target adalah sumbernya. <br><br><img src="https://habrastorage.org/webt/rs/nf/u9/rsnfu97eapuetrrhbwejb-awnas.png"><br><br>  <i>Ini sama dengan dua aturan untuk firewall: Ingress → Target;</i>  <i>Sasaran → Jalan keluar.</i> <br><br><h2>  Egress dan DNS (penting!) </h2><br>  Ketika membatasi lalu lintas keluar, <b>perhatikan DNS</b> - Kubernetes menggunakan layanan ini untuk memetakan layanan ke alamat IP.  Misalnya, kebijakan berikut tidak akan berfungsi karena Anda tidak mengizinkan aplikasi <code>balance</code> mengakses DNS: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.balance namespace: default spec: podSelector: matchLabels: app: balance egress: - to: - podSelector: matchLabels: app: postgres policyTypes: - Egress</code> </pre> <br><img src="https://habrastorage.org/webt/6w/dy/jf/6wdyjftwhfiynlxrx22vivumtli.png"><br><br>  Anda dapat memperbaikinya dengan membuka akses ke layanan DNS: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.balance namespace: default spec: podSelector: matchLabels: app: balance egress: - to: - podSelector: matchLabels: app: postgres - to: # &lt;&lt;&lt; ports: # &lt;&lt;&lt; - protocol: UDP # &lt;&lt;&lt; port: 53 # &lt;&lt;&lt; policyTypes: - Egress</code> </pre> <br><img src="https://habrastorage.org/webt/z4/np/5m/z4np5m-afkmcbkqlgoxufjgc4fm.png"><br><br>  Elemen terakhir ke kosong, dan karena itu secara tidak langsung memilih <b>semua pod di semua ruang nama</b> , memungkinkan <code>balance</code> mengirim permintaan DNS ke layanan Kubernetes yang sesuai (biasanya bekerja di ruang <code>kube-system</code> kubus). <br><br>  Pendekatan ini berfungsi, tetapi <b>terlalu permisif dan tidak aman</b> , karena memungkinkan Anda untuk mengarahkan permintaan DNS di luar cluster. <br><br>  Anda dapat meningkatkannya dalam tiga langkah berturut-turut. <br><br>  1. Izinkan permintaan DNS hanya <b>di dalam</b> cluster dengan menambahkan <code>namespaceSelector</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.balance namespace: default spec: podSelector: matchLabels: app: balance egress: - to: - podSelector: matchLabels: app: postgres - to: - namespaceSelector: {} # &lt;&lt;&lt; ports: - protocol: UDP port: 53 policyTypes: - Egress</code> </pre> <br><img src="https://habrastorage.org/webt/a1/hk/8v/a1hk8vmrton9izmj1jwhxtz-q1e.png"><br><br>  2. Izinkan permintaan DNS hanya di namespace <code>kube-system</code> . <br><br>  Untuk melakukan ini, tambahkan label ke <code>kubectl label namespace kube-system namespace=kube-system</code> <code>kube-system</code> <code>kubectl label namespace kube-system namespace=kube-system</code> : <code>kubectl label namespace kube-system namespace=kube-system</code> - dan daftarkan dalam kebijakan menggunakan <code>namespaceSelector</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.balance namespace: default spec: podSelector: matchLabels: app: balance egress: - to: - podSelector: matchLabels: app: postgres - to: - namespaceSelector: # &lt;&lt;&lt; matchLabels: # &lt;&lt;&lt; namespace: kube-system # &lt;&lt;&lt; ports: - protocol: UDP port: 53 policyTypes: - Egress</code> </pre> <br><img src="https://habrastorage.org/webt/q6/e2/ed/q6e2edqwfz63nbamlvk2v5zpjhy.png"><br><br>  3. Paranoid dapat melangkah lebih jauh dan membatasi permintaan DNS ke layanan DNS tertentu di <code>kube-system</code> .  Di bagian "Saring berdasarkan ruang nama &amp; polong", kami akan menjelaskan cara mencapai ini. <br><br>  Pilihan lain adalah menyelesaikan DNS di tingkat namespace.  Dalam hal ini, tidak perlu dibuka untuk setiap layanan: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.dns namespace: default spec: podSelector: {} # &lt;&lt;&lt; egress: - to: - namespaceSelector: {} ports: - protocol: UDP port: 53 policyTypes: - Egress</code> </pre> <br>  <code>podSelector</code> kosong memilih semua pod di namespace. <br><br><img src="https://habrastorage.org/webt/ua/hn/7t/uahn7tgfus08_yt1u-rsilqoi90.png"><br><br><h2>  Pertandingan pertama dan aturan pesanan </h2><br>  Dalam firewall biasa, tindakan ("Izinkan" atau "Tolak") untuk suatu paket ditentukan oleh aturan pertama yang dipenuhi.  <b>Di Kubernetes, urutan kebijakan tidak relevan.</b> <br><br>  Secara default, ketika kebijakan tidak disetel, komunikasi antar pod diperbolehkan dan mereka dapat bertukar informasi secara bebas.  Segera setelah Anda mulai merumuskan kebijakan, setiap polong yang dipengaruhi oleh setidaknya satu dari mereka menjadi terisolasi sesuai dengan disjungsi (logis ATAU) dari semua kebijakan yang telah memilihnya.  Pod tidak terpengaruh oleh kebijakan apa pun tetap terbuka. <br><br>  Anda dapat mengubah perilaku ini menggunakan aturan stripping. <br><br><h2>  Aturan pengupasan (Tolak) </h2><br>  Kebijakan firewall umumnya melarang lalu lintas yang tidak sah secara eksplisit. <br><br>  <b>Kubernetes tidak memiliki tindakan penolakan</b> , namun, efek yang sama dapat dicapai dengan kebijakan reguler (memungkinkan) dengan memilih grup pod sumber kosong (masuk): <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: deny-all namespace: default spec: podSelector: {} policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/65/-s/au/65-sauxptvceaqgedw9xvsadlso.png"><br><br>  Kebijakan ini memilih semua pod di namespace dan membiarkan masuknya tidak terdefinisi, memblokir semua lalu lintas masuk. <br><br>  Demikian pula, Anda dapat membatasi semua lalu lintas keluar dari namespace: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: deny-all-egress namespace: default spec: podSelector: {} policyTypes: - Egress</code> </pre> <br><img src="https://habrastorage.org/webt/bn/fg/vq/bnfgvqcfwsgaj-jyompezzmhz6q.png"><br><br>  Perhatikan bahwa <b>kebijakan tambahan apa pun yang memungkinkan lalu lintas ke pod di namespace akan didahulukan dari aturan ini</b> (mirip dengan menambahkan aturan perbolehkan atas aturan penolakan dalam konfigurasi firewall). <br><br><h2>  Allow All (Any-Any-Any-Allow) </h2><br>  Untuk membuat kebijakan Allow All, Anda harus menambahkan kebijakan larangan di atas dengan elemen <code>ingress</code> kosong: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: allow-all namespace: default spec: podSelector: {} ingress: # &lt;&lt;&lt; - {} # &lt;&lt;&lt; policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/bl/x6/ed/blx6edy0ez8h-yrkil5vb0yeb5g.png"><br><br>  Ini memungkinkan akses dari <b>semua pod di semua namespace (dan semua IP) ke pod apa saja di namespace <code>default</code></b> .  Perilaku ini diaktifkan secara default, jadi biasanya tidak perlu didefinisikan lebih lanjut.  Namun, kadang-kadang mungkin perlu untuk sementara menonaktifkan beberapa izin khusus untuk mendiagnosis masalah. <br><br>  Aturan dapat dipersempit dan diizinkan akses hanya ke <b>kumpulan pod tertentu</b> ( <code>app:balance</code> ) di namespace <code>default</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: allow-all-to-balance namespace: default spec: podSelector: matchLabels: app: balance ingress: - {} policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/ji/jn/ki/jijnkiy1fzkligxx9b2okk8arm8.png"><br><br>  Kebijakan berikut memungkinkan semua lalu lintas masuk dan keluar, termasuk akses ke IP apa pun di luar cluster: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: allow-all spec: podSelector: {} ingress: - {} egress: - {} policyTypes: - Ingress - Egress</code> </pre> <br><img src="https://habrastorage.org/webt/yx/eq/c4/yxeqc4hamtqwvirrodsrym7y4iy.png"><br><img src="https://habrastorage.org/webt/bi/nu/ob/binuob-mafzfz6w_r-2fmdseu2c.png"><br><br><h2>  Menggabungkan banyak kebijakan </h2><br>  Kebijakan digabungkan menggunakan logika ATAU pada tiga tingkatan;  izin setiap pod diatur sesuai dengan disjungsi semua kebijakan yang mempengaruhinya: <br><br>  1. Di bidang <code>from</code> dan <code>to</code> , Anda dapat menentukan tiga jenis elemen (semuanya digabungkan menggunakan OR): <br><br><ul><li>  <code>namespaceSelector</code> - memilih seluruh namespace; </li><li>  <code>podSelector</code> - memilih pod; </li><li>  <code>ipBlock</code> - memilih subnet. </li></ul><br>  Pada saat yang sama, jumlah elemen (bahkan sama) di <code>from</code> / <code>to</code> subbagian tidak terbatas.  Semuanya akan dikombinasikan dengan logika OR. <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.postgres namespace: default spec: ingress: - from: - podSelector: matchLabels: app: indexer - podSelector: matchLabels: app: admin podSelector: matchLabels: app: postgres policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/_y/pu/xy/_ypuxynlq6wslkjk65yyj5_zwsi.png"><br><br>  2. Di dalam kebijakan, bagian <code>ingress</code> dapat memiliki banyak elemen (dikombinasikan dengan logika OR).  Demikian pula, bagian <code>egress</code> dapat menyertakan banyak elemen (juga digabungkan dengan klausa): <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.postgres namespace: default spec: ingress: - from: - podSelector: matchLabels: app: indexer - from: - podSelector: matchLabels: app: admin podSelector: matchLabels: app: postgres policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/4t/-l/f9/4t-lf9a8fm1f4whkitifyhgyfee.png"><br><br>  3. Berbagai kebijakan juga digabungkan dengan logika OR <br><br>  Tetapi ketika menggabungkan mereka, ada satu batasan yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditunjukkan</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chris Cooney</a> : Kubernetes hanya dapat menggabungkan kebijakan dengan berbagai <code>policyTypes</code> kebijakan ( <code>Ingress</code> atau <code>Egress</code> ).  Kebijakan yang menentukan masuknya (atau keluar) akan saling menimpa. <br><br><h2>  Hubungan antara ruang nama </h2><br>  Secara default, pertukaran informasi antara ruang nama diizinkan.  Ini dapat diubah menggunakan kebijakan penghalang yang membatasi lalu lintas keluar dan / atau masuk ke namespace (lihat "Aturan pengupasan" di atas). <br><br>  Dengan memblokir akses ke namespace (lihat "Aturan Stripping" di atas), Anda dapat membuat pengecualian terhadap kebijakan restriktif dengan mengizinkan koneksi dari namespace tertentu menggunakan <code>namespaceSelector</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: database.postgres namespace: database spec: podSelector: matchLabels: app: postgres ingress: - from: - namespaceSelector: # &lt;&lt;&lt; matchLabels: namespace: default policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/gh/-0/ed/gh-0edsyfhl5st5_8nngwadmoai.png"><br><br>  Akibatnya, semua pod di namespace <code>default</code> akan memiliki akses ke pod <code>postgres</code> di namespace <code>database</code> .  Tetapi bagaimana jika Anda ingin membuka akses ke <code>postgres</code> hanya ke pod tertentu di namespace <code>default</code> ? <br><br><h2>  Saring berdasarkan ruang nama &amp; pod </h2><br>  Kubernetes versi 1.11 dan lebih tinggi memungkinkan Anda untuk menggabungkan <code>namespaceSelector</code> dan operator <code>podSelector</code> menggunakan logis I. Sepertinya ini: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: database.postgres namespace: database spec: podSelector: matchLabels: app: postgres ingress: - from: - namespaceSelector: matchLabels: namespace: default podSelector: # &lt;&lt;&lt; matchLabels: app: admin policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/47/_b/op/47_bopr6mjii5-qkujgiwgs2bku.png"><br><br>  Mengapa ini ditafsirkan sebagai DAN bukannya OR biasa? <br><br>  Perhatikan bahwa <code>podSelector</code> tidak dimulai dengan tanda hubung.  Dalam YAML, ini berarti <code>podSelector</code> dan <code>namespaceSelector</code> berdiri di depannya merujuk ke item daftar yang sama.  Oleh karena itu, mereka dikombinasikan oleh I. logis <br><br>  Menambahkan tanda hubung di depan <code>podSelector</code> akan menghasilkan item daftar baru yang akan dikombinasikan dengan <code>namespaceSelector</code> sebelumnya menggunakan OR logis. <br><br>  Untuk memilih pod dengan label tertentu <b>di semua ruang nama</b> , masukkan ruang <code>namespaceSelector</code> kosong: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: database.postgres namespace: database spec: podSelector: matchLabels: app: postgres ingress: - from: - namespaceSelector: {} podSelector: matchLabels: app: admin policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/t9/lc/vn/t9lcvnyl17u39krw9vn1nc-5xmk.png"><br><br><h2>  Beberapa label digabungkan dengan AND </h2><br>  Aturan untuk firewall dengan banyak objek (host, jaringan, grup) digabungkan menggunakan OR logis.  Aturan berikut akan berfungsi jika sumber paket cocok dengan <code>Host_1</code> OR <code>Host_2</code> : <br><br><pre> <code class="plaintext hljs">| Source | Destination | Service | Action | | ----------------------------------------| | Host_1 | Subnet_A | HTTPS | Allow | | Host_2 | | | | | ----------------------------------------|</code> </pre> <br>  Sebaliknya, di Kubernetes, berbagai label di <code>podSelector</code> atau <code>namespaceSelector</code> digabungkan oleh logis I. Misalnya, aturan berikut akan memilih pod yang memiliki kedua label, <code>role=db</code> DAN <code>version=v2</code> : <br><br><pre> <code class="plaintext hljs">podSelector: matchLabels: role: db version: v2</code> </pre> <br>  Logika yang sama berlaku untuk semua jenis operator: pemilih tujuan kebijakan, pemilih pod, dan pemilih namespace. <br><br><h2>  Subnet dan Alamat IP (IPBlocks) </h2><br>  Firewall menggunakan VLAN, alamat IP, dan subnet untuk mengelompokkan jaringan. <br><br>  Di Kubernetes, alamat IP ditetapkan untuk pod secara otomatis dan dapat sering berubah, sehingga label digunakan untuk memilih pod dan ruang nama dalam kebijakan jaringan. <br><br>  <code>ipBlocks</code> ( <code>ipBlocks</code> ) digunakan untuk mengontrol koneksi eksternal (Utara-Selatan) inbound (ingress) atau outbound (egress).  Misalnya, kebijakan ini memberikan semua pod dari akses namespace <code>default</code> ke layanan Google DNS: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: egress-dns namespace: default spec: podSelector: {} policyTypes: - Egress egress: - to: - ipBlock: cidr: 8.8.8.8/32 ports: - protocol: UDP port: 53</code> </pre> <br><img src="https://habrastorage.org/webt/fm/uc/oa/fmucoaptwhse0i5yx-hsize1d0e.png"><br><br>  Pemilih pod kosong dalam contoh ini berarti "pilih semua pod di namespace." <br><br>  Kebijakan ini hanya menyediakan akses ke 8.8.8.8;  akses ke IP lain ditolak.  Dengan demikian, pada dasarnya, Anda memblokir akses ke layanan DNS internal Kubernetes.  Jika Anda masih ingin membukanya, tentukan secara eksplisit. <br><br>  Biasanya <code>ipBlocks</code> dan <code>podSelectors</code> saling eksklusif, karena alamat IP internal pod tidak digunakan di <code>ipBlocks</code> .  <b>Dengan</b> menentukan <b>pod IP internal</b> , Anda sebenarnya akan mengizinkan koneksi ke / dari pod dengan alamat ini.  Dalam praktiknya, Anda tidak akan tahu alamat IP mana yang akan digunakan, itulah sebabnya mereka tidak boleh digunakan untuk memilih pod. <br><br>  Sebagai contoh tandingan, kebijakan berikut mencakup semua IP dan, karenanya, memungkinkan akses ke semua pod lainnya: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: egress-any namespace: default spec: podSelector: {} policyTypes: - Egress egress: - to: - ipBlock: cidr: 0.0.0.0/0</code> </pre> <br><img src="https://habrastorage.org/webt/yt/dt/ow/ytdtowaueimdgmppg5x9mp7y2ec.png"><br><br>  Anda dapat membuka akses hanya ke IP eksternal dengan mengecualikan alamat IP internal pod.  Misalnya, jika subnet pod Anda adalah 10.16.0.0/14: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: egress-any namespace: default spec: podSelector: {} policyTypes: - Egress egress: - to: - ipBlock: cidr: 0.0.0.0/0 except: - 10.16.0.0/14</code> </pre> <br><img src="https://habrastorage.org/webt/9a/iz/c4/9aizc4r0bjzljsl0smkwaagpgfm.png"><br><br><h2>  Port dan Protokol </h2><br>  Biasanya pod mendengarkan pada satu port.  Ini berarti bahwa Anda dapat dengan mudah menghilangkan nomor port dalam kebijakan dan membiarkan semuanya sebagai default.  Namun, disarankan agar kebijakan dibuat seketat mungkin, sehingga dalam beberapa kasus Anda masih dapat menentukan port: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.postgres namespace: default spec: ingress: - from: - podSelector: matchLabels: app: indexer - podSelector: matchLabels: app: admin ports: # &lt;&lt;&lt; - port: 443 # &lt;&lt;&lt; protocol: TCP # &lt;&lt;&lt; - port: 80 # &lt;&lt;&lt; protocol: TCP # &lt;&lt;&lt; podSelector: matchLabels: app: postgres policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/ie/yo/og/ieyoogygmsewwwxtg0ncvsapxmw.png"><br><br>  Perhatikan bahwa pemilih <code>ports</code> berlaku untuk semua elemen di blok <code>to</code> atau <code>from</code> yang dikandungnya.  Untuk menentukan port berbeda untuk set elemen yang berbeda, <code>ingress</code> atau <code>egress</code> ke beberapa subbagian dengan <code>to</code> atau <code>from</code> dan daftarkan port Anda di masing-masing: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.postgres namespace: default spec: ingress: - from: - podSelector: matchLabels: app: indexer ports: # &lt;&lt;&lt; - port: 443 # &lt;&lt;&lt; protocol: TCP # &lt;&lt;&lt; - from: - podSelector: matchLabels: app: admin ports: # &lt;&lt;&lt; - port: 80 # &lt;&lt;&lt; protocol: TCP # &lt;&lt;&lt; podSelector: matchLabels: app: postgres policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/bw/_a/8p/bw_a8p4luekpljv4c9zh6p4hw_y.png"><br><br>  Port default berfungsi: <br><br><ul><li>  Jika Anda sepenuhnya menghilangkan definisi port, ini berarti semua protokol dan semua port; </li><li>  Jika Anda menghilangkan definisi protokol, itu berarti TCP; </li><li>  Jika Anda menghilangkan definisi port, ini berarti semua port. </li></ul><br>  Praktik terbaik: jangan mengandalkan nilai default, tentukan apa yang Anda butuhkan secara eksplisit. <br><br>  Harap dicatat bahwa perlu menggunakan porta pod, bukan layanan (lebih lanjut tentang ini pada paragraf berikutnya). <br><br><h2>  Apakah kebijakan ditentukan untuk pod atau layanan? </h2><br>  Biasanya pod di Kubernet menghubungi satu sama lain melalui layanan - penyeimbang beban virtual yang mengalihkan lalu lintas ke pod yang mengimplementasikan layanan.  Anda mungkin berpikir bahwa kebijakan jaringan mengontrol akses ke layanan, tetapi ini tidak benar.  <b>Kebijakan jaringan Kubernetes bekerja dengan port pod, bukan layanan.</b> <br><br> ,    80- ,      8080  pod',       8080. <br><br>     :      (   pod')    . <br><br>      Service Mesh <i>(, .  Istio  — . .)</i>     . <br><br><h2>     Ingress,   Egress? </h2><br>   — ,  pod     pod' ,       (    egress-),  pod        ( , ,  ingress-). <br><br>         ,       . <br><br>   pod- <b></b>      <b>egress</b> -,        .         pod'- <b></b> .  pod   - ,   (egress)    . <br><br>    pod'- <b></b> ,     <b>ingress</b> -,    .           pod'-.  pod   - ,   (ingress)      . <br><br> .  «Stateful  Stateless» . <br><br><h2>  </h2><br>   Kubernetes    .    ,     ,       . <br><br><h2>       </h2><br>   Kubernetes       (DNS)   egress.             ,   IP- (  aws.com). <br><br><h2>   </h2><br>         . Kubernetes    .      kubectl Kubernetes  ,   ,    .    Kubernetes       .      : <br><br><pre> <code class="plaintext hljs">kubernetes get networkpolicy &lt;policy-name&gt; -o yaml</code> </pre> <br>   ,    Kubernetes        . <br><br><h2>  </h2><br> Kubernetes      ,    API-,        ,  Container Networking Interface (CNI).     Kubernetes    CNI             .        CNI ,    Kubernetes,    <i>(     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> — . .)</i> ,   ,   CNI  . <br><br>  ,  Kubernetes   ,         CNI. <br><br><h3> Stateful  Stateless? </h3><br>  CNI Kubernetes,     ,   (, Calico  Linux conntrack).   pod'      TCP-     .       Kubernetes,      (statefulness). <br><br><h2>     </h2><br>          Kubernetes: <br><br><ol><li>   Service Mesh  sidecar-           .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Istio</a> . </li><li>    CNI   ,        Kubernetes. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tufin Orca</a>       Kubernetes. </li></ol><br>  Tufin Orca    Kubernetes (   ,  ). <br><br><h2>   </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  ,  Ahmet Alp Balkan'  GKE</a> ; </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    Kubernetes</a> ; </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    Kubernetes</a> ; </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    </a> . </li></ul><br><h2>  Kesimpulan </h2><br>   Kubernetes       ,        .  ,  -        .             . <br><br> ,          ,     . <br><br><h2>  PS dari penerjemah </h2><br>  Baca juga di blog kami: <br><br><ul><li> «     Istio»: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> 1 (   )</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> 2 (,  )</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> 3 ()</a> ; </li><li> «      Kubernetes»: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> 1  2 ( ,  )</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> 3 (   )</a> ; </li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Docker  Kubernetes     </a> »; </li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">9       Kubernetes</a> »; </li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">11  ()     Kubernetes</a> ». </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443190/">https://habr.com/ru/post/id443190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443180/index.html">Kru pendaratan Naga dan tangkapan video asteroid</a></li>
<li><a href="../id443182/index.html">Tarik YPbPr dari Commodore 64</a></li>
<li><a href="../id443184/index.html">Dari cinta hingga kontrol satu langkah</a></li>
<li><a href="../id443186/index.html">3CX Dukungan Teknis Menanggapi - 5 Aturan Keamanan IP PBX</a></li>
<li><a href="../id443188/index.html">Tiga mata tergantung pada pilar, atau kisah bahwa lima kaki ATtiny13 sudah cukup</a></li>
<li><a href="../id443192/index.html">Metode pribadi tanpa menggarisbawahi dan antarmuka dalam Python</a></li>
<li><a href="../id443194/index.html">Insinyur WFIRM menemukan bioprinter yang mencetak kulit langsung pada luka</a></li>
<li><a href="../id443196/index.html">Tidak semenit offline - Memilih router LTE industri</a></li>
<li><a href="../id443198/index.html">Mark Zuckerberg mengatakan Facebook sedang bekerja pada antarmuka saraf untuk membaca pikiran</a></li>
<li><a href="../id443200/index.html">Peretas Iran mencuri terabyte data dari Citrix</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>