<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🎤 ⌛️ ➡️ Tautan internal dan eksternal dalam C ++ ♐️ ⛵️ 🚆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari baik untuk semua! 

 Kami hadir untuk Anda terjemahan dari artikel yang menarik yang telah disiapkan untuk Anda sebagai bagian dari kursus "Penge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tautan internal dan eksternal dalam C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/432834/">  Hari baik untuk semua! <br><br>  Kami hadir untuk Anda terjemahan dari artikel yang menarik yang telah disiapkan untuk Anda sebagai bagian dari kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Pengembang C ++"</a> .  Kami berharap ini akan bermanfaat dan menarik bagi Anda, juga bagi pendengar kami. <br><br>  Ayo pergi. <br><br>  Pernahkah Anda menjumpai istilah komunikasi internal dan eksternal?  Ingin tahu untuk apa kata kunci eksternal digunakan, atau bagaimana pernyataan tentang sesuatu yang statis mempengaruhi ruang lingkup global?  Maka artikel ini adalah untuk Anda. <br><br>  <b>Singkatnya</b> <br><br>  Unit terjemahan (.c / .cpp) dan semua file tajuknya (.h / .hpp) dimasukkan dalam unit terjemahan.  Jika suatu objek atau fungsi memiliki ikatan internal di dalam unit terjemahan, maka simbol ini hanya dapat dilihat oleh penghubung di dalam unit terjemahan ini.  Jika objek atau fungsi memiliki tautan eksternal, tautan tersebut akan dapat melihatnya saat memproses unit terjemahan lainnya.  Menggunakan kata kunci statis di namespace global memberikan karakter yang mengikat internal.  Kata kunci eksternal memberikan ikatan eksternal. <br>  Kompiler default memberi karakter binding berikut: <br><br><ul><li>  Variabel global non-const - ikatan eksternal; </li><li>  Variabel global konstan - pengikatan internal; </li><li>  Fungsi - Menghubungkan Eksternal. </li></ul><br><img src="https://habrastorage.org/webt/m5/bl/8d/m5bl8d7e6yb-7qlgsoqf8duzuku.png"><br><a name="habracut"></a><br>  <b>Dasar-dasarnya</b> <br><br>  Pertama, mari kita bicara tentang dua konsep sederhana yang diperlukan untuk membahas ikatan. <br><br><ul><li>  Perbedaan antara deklarasi dan definisi; </li><li>  Unit Siaran. </li></ul><br>  Perhatikan juga nama-nama: kita akan menggunakan konsep "simbol" ketika datang ke "entitas kode" dengan mana linker bekerja, misalnya dengan variabel atau fungsi (atau dengan kelas / struktur, tetapi kita tidak akan fokus pada mereka). <br><br>  <b>Pengumuman VS.</b>  <b>Definisi</b> <br><br>  Kami membahas secara singkat perbedaan antara deklarasi dan definisi simbol: pengumuman (atau deklarasi) memberi tahu kompiler tentang keberadaan simbol tertentu, dan memungkinkan akses ke simbol ini dalam kasus yang tidak memerlukan alamat memori atau penyimpanan simbol yang tepat.  Definisi memberitahu kompiler apa yang terkandung dalam tubuh fungsi atau berapa banyak memori yang perlu dialokasikan variabel. <br><br>  Dalam beberapa situasi, deklarasi tidak cukup untuk kompiler, misalnya, ketika elemen data kelas memiliki tautan atau tipe nilai (yaitu, bukan tautan, dan bukan pointer).  Pada saat yang sama, sebuah penunjuk ke tipe yang dideklarasikan (tetapi tidak terdefinisi) diperbolehkan, karena ia membutuhkan jumlah memori yang tetap (misalnya, 8 byte dalam sistem 64-bit), terlepas dari tipe yang ditunjukkannya.  Untuk mendapatkan nilai dengan pointer ini, diperlukan definisi.  Juga, untuk mendeklarasikan suatu fungsi, Anda perlu mendeklarasikan (tetapi tidak mendefinisikan) semua parameter (apakah itu diambil oleh nilai, referensi atau pointer) dan tipe kembali.  Menentukan jenis nilai balik dan parameter hanya diperlukan untuk mendefinisikan suatu fungsi. <br><br>  <b>Fungsi</b> <br><br>  Perbedaan antara mendefinisikan dan mendeklarasikan suatu fungsi sangat jelas. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//  int f() { return 42; } // </span></span></code> </pre> <br>  <b>Variabel</b> <br><br>  Dengan variabel, ini sedikit berbeda.  Deklarasi dan definisi biasanya tidak dibagikan.  Yang utama adalah: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x;</code> </pre> <br>  Tidak hanya mendeklarasikan <code>x</code> , tetapi juga mendefinisikannya.  Ini karena panggilan ke int konstruktor default.  (Dalam C ++, tidak seperti Java, konstruktor tipe sederhana (seperti int) tidak menginisialisasi nilai ke 0 secara default. Pada contoh di atas, x akan sama dengan sampah apa pun yang terletak di alamat memori yang dialokasikan oleh kompiler). <br><br>  Tetapi Anda dapat secara eksplisit memisahkan deklarasi variabel dan definisinya menggunakan kata kunci <code>extern</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-comment"><span class="hljs-comment">//  int x = 42; // </span></span></code> </pre> <br>  Namun, ketika menginisialisasi dan menambahkan <code>extern</code> ke deklarasi, ekspresi berubah menjadi definisi dan kata kunci <code>extern</code> menjadi tidak berguna. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ,   int x = 5;</span></span></code> </pre> <br>  <b>Pratinjau Iklan</b> <br><br>  Dalam C ++, ada konsep pra-deklarasi karakter.  Ini berarti bahwa kami menyatakan jenis dan nama simbol untuk digunakan dalam situasi yang tidak memerlukan definisi.  Jadi kita tidak perlu memasukkan definisi penuh karakter (biasanya file header) tanpa kebutuhan yang jelas.  Dengan demikian, kami mengurangi ketergantungan pada file yang berisi definisi.  Keuntungan utama adalah bahwa ketika mengubah file dengan definisi, file tempat kita sebelumnya menyatakan simbol ini tidak memerlukan kompilasi ulang (yang berarti bahwa semua file lain termasuk itu). <br><br>  <i>Contoh</i> <br><br>  Misalkan kita memiliki deklarasi fungsi (disebut prototipe) untuk f yang mengambil objek bertipe <code>Class</code> berdasarkan nilai: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// file.hpp void f(Class object);</span></span></code> </pre> <br>  Segera sertakan definisi <code>Class</code> - naif.  Tetapi karena kita baru saja mendeklarasikan <code>f</code> , itu sudah cukup untuk memberikan deklarasi <code>Class</code> kepada kompiler.  Dengan demikian, kompiler dapat mengenali fungsi dengan prototipe-nya, dan kita bisa menghilangkan ketergantungan file.hpp pada file yang mengandung definisi <code>Class</code> , misalkan class.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// file.hpp class Class; void f(Class object);</span></span></code> </pre> <br>  Katakanlah file.hpp terkandung dalam 100 file lainnya.  Dan katakanlah kita mengubah definisi Kelas di class.hpp.  Jika Anda menambahkan class.hpp ke file.hpp, file.hpp dan ke-100 file yang mengandungnya harus dikompilasi ulang.  Berkat deklarasi awal Kelas, satu-satunya file yang memerlukan kompilasi adalah class.hpp dan file.hpp (dengan asumsi f didefinisikan di sana). <br><br>  <b>Frekuensi penggunaan</b> <br><br>  Perbedaan penting antara deklarasi dan definisi adalah bahwa simbol dapat dideklarasikan berkali-kali, tetapi hanya didefinisikan sekali.  Jadi Anda dapat mendeklarasikan fungsi atau kelas sebanyak yang Anda suka, tetapi hanya ada satu definisi.  Ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aturan Satu Definisi</a> .  Di C ++, yang berikut ini berfungsi: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>; }</code> </pre> <br>  Dan ini tidak berhasil: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>; }</code> </pre><br>  <b>Unit Siaran</b> <br><br>  Pemrogram biasanya bekerja dengan file header dan file implementasi.  Tetapi bukan kompiler - mereka bekerja dengan unit terjemahan (unit terjemahan, singkatnya - TU), yang kadang-kadang disebut unit kompilasi.  Definisi unit semacam itu cukup sederhana - file apa pun yang ditransfer ke kompiler setelah pemrosesan awal.  Untuk lebih tepatnya, ini adalah file yang dihasilkan dari pekerjaan preprocessor makro ekstensi yang menyertakan kode sumber, yang bergantung pada ekspresi <code>#ifndef</code> dan <code>#ifndef</code> , dan salin-tempel semua file <code>#include</code> . <br><br>  File-file berikut tersedia: <br><br>  header.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> HEADER_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HEADER_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> VALUE 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> VALUE struct Foo { private: int ryan; }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> int strlen(const char* string); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* HEADER_HPP */</span></span></span></span></code> </pre> <br>  program.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"header.hpp"</span></span></span><span class="hljs-meta"> int strlen(const char* string) { int length = 0; while(string[length]) ++length; return length + VALUE; }</span></span></code> </pre> <br>  Preprocessor akan menghasilkan unit terjemahan berikut, yang kemudian diteruskan ke kompiler: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strlen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strlen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[length]) ++length; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length + <span class="hljs-number"><span class="hljs-number">5</span></span>; }</code> </pre><br>  <b>Komunikasi</b> <br><br>  Setelah membahas dasar-dasarnya, Anda dapat memulai hubungan.  Secara umum, komunikasi adalah visibilitas karakter untuk tautan saat memproses file.  Komunikasi dapat berupa eksternal atau internal. <br><br>  <b>Komunikasi eksternal</b> <br><br>  Ketika simbol (variabel atau fungsi) memiliki koneksi eksternal, itu menjadi terlihat oleh linker dari file lain, yaitu, "terlihat secara global", dapat diakses oleh semua unit terjemahan.  Ini berarti bahwa Anda harus mendefinisikan simbol seperti itu di tempat tertentu dari satu unit terjemahan, biasanya dalam file implementasi (.c / .cpp), sehingga hanya memiliki satu definisi yang terlihat.  Jika Anda mencoba untuk secara bersamaan mendefinisikan simbol pada saat yang sama dengan simbol tersebut dideklarasikan, atau jika Anda menempatkan definisi dalam file untuk deklarasi, Anda berisiko membuat marah penghubung.  Mencoba menambahkan file ke lebih dari satu file implementasi mengarah pada penambahan definisi ke lebih dari satu unit terjemahan - linker Anda akan menangis. <br><br>  Kata kunci eksternal dalam C dan C ++ (secara eksplisit) menyatakan bahwa suatu karakter memiliki koneksi eksternal. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; argument)</span></span></span></span>;</code> </pre><br>  Kedua karakter memiliki koneksi eksternal.  Tercatat di atas bahwa variabel global const memiliki ikatan internal secara default, variabel global non-const memiliki ikatan eksternal.  Ini berarti int x;  - sama seperti extern int x;, kan?  Tidak juga.  int x;  sebenarnya analog dengan extern int x {};  (menggunakan sintaks inisialisasi universal / braket untuk menghindari penguraian yang paling tidak menyenangkan (penguraian paling menjengkelkan)), karena int x;  tidak hanya mendeklarasikan, tetapi juga mendefinisikan x.  Oleh karena itu, jangan tambahkan eksternal ke int x;  global sama buruknya dengan mendefinisikan variabel saat mendeklarasikannya dari luar: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-comment"><span class="hljs-comment">//   ,   extern int x{}; //      . extern int x; //      ,  </span></span></code> </pre> <br>  <i>Contoh yang buruk</i> <br><br>  Mari kita mendeklarasikan fungsi <code>f</code> dengan tautan eksternal di file.hpp dan mendefinisikannya di sana: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// file.hpp #ifndef FILE_HPP #define FILE_HPP extern int f(int x); /* ... */ int f(int) { return x + 1; } /* ... */ #endif /* FILE_HPP */</span></span></code> </pre> <br>  Harap dicatat bahwa Anda tidak perlu menambahkan extern di sini, karena semua fungsi secara eksternal extern.  Pemisahan deklarasi dan definisi juga tidak diperlukan.  Jadi mari kita tulis ulang seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// file.hpp #ifndef FILE_HPP #define FILE_HPP int f(int) { return x + 1; } #endif /* FILE_HPP */</span></span></code> </pre> <br>  Kode semacam itu dapat ditulis sebelum membaca artikel ini, atau setelah membacanya di bawah pengaruh alkohol atau zat-zat berat (misalnya, gulungan kayu manis). <br><br>  Mari kita lihat mengapa ini tidak sepadan.  Sekarang kita memiliki dua file implementasi: a.cpp dan b.cpp, keduanya termasuk dalam file.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// a.cpp #include "file.hpp" /* ... */</span></span></code> </pre> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// b.cpp #include "file.hpp" /* ... */</span></span></code> </pre> <br>  Sekarang biarkan kompiler bekerja dan menghasilkan dua unit terjemahan untuk dua file implementasi di atas (ingat bahwa <code>#include</code> secara harfiah berarti salin / tempel): <br><br><pre> <code class="plaintext hljs">// TU A, from a.cpp int f(int) { return x + 1; } /* ... */</code> </pre> <br><pre> <code class="plaintext hljs">// TU B, from b.cpp int f(int) { return x + 1; } /* ... */</code> </pre> <br>  Pada titik ini, linker melakukan intervensi (pengikatan terjadi setelah kompilasi).  Linker mengambil karakter <code>f</code> dan mencari definisi.  Hari ini dia beruntung, dia menemukan sebanyak dua!  Satu di unit terjemahan A, yang lain di B. Linker membeku dengan bahagia dan memberi tahu Anda sesuatu seperti ini: <br><br><pre> <code class="cpp hljs">duplicate symbol __Z1fv in: /path/to/ao /path/to/bo</code> </pre> <br>  Linker menemukan dua definisi untuk satu karakter <code>f</code> .  Karena <code>f</code> memiliki ikatan eksternal, itu terlihat oleh penghubung ketika memproses A dan B. Jelas, ini melanggar Aturan Satu Definisi dan menyebabkan kesalahan.  Lebih tepatnya, ini menyebabkan kesalahan simbol duplikat, yang Anda akan menerima tidak kurang dari kesalahan simbol tidak terdefinisi yang terjadi ketika Anda mendeklarasikan simbol, tetapi lupa untuk mendefinisikannya. <br><br>  <b>Gunakan</b> <br><br>  Contoh standar untuk mendeklarasikan variabel eksternal adalah variabel global.  Misalkan Anda sedang mengerjakan kue self-baking.  Tentunya ada variabel global yang terkait dengan kue yang harus tersedia di berbagai bagian program Anda.  Katakanlah frekuensi jam dari sirkuit yang dapat dimakan di dalam kue Anda.  Nilai ini diperlukan secara alami di berbagai bagian untuk operasi sinkron dari semua elektronik cokelat.  Cara (jahat) C untuk mendeklarasikan variabel global seperti ini adalah sebagai makro: <br><br><pre> <code class="plaintext hljs">#define CLK 1000000</code> </pre><br>  Seorang programmer C ++ yang merasa jijik dengan makro akan menulis kode nyata lebih baik.  Sebagai contoh, ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// global.hpp namespace Global { extern unsigned int clock_rate; } // global.cpp namespace Global { unsigned int clock_rate = 1000000; }</span></span></code> </pre> <br>  (Seorang programmer C ++ modern akan ingin menggunakan literal pemisahan: unsigned int clock_rate = 1'000'000;) <br><br>  <b>Interkom</b> <br><br>  Jika simbol memiliki koneksi internal, maka simbol hanya akan terlihat di dalam unit terjemahan saat ini.  Jangan mengacaukan visibilitas dengan hak akses, seperti pribadi.  Visibilitas berarti bahwa penghubung akan dapat menggunakan simbol ini hanya ketika memproses unit terjemahan di mana simbol dinyatakan, dan tidak lebih lambat (seperti dalam kasus simbol dengan komunikasi eksternal).  Dalam praktiknya, ini berarti bahwa ketika mendeklarasikan simbol dengan tautan internal di file header, setiap unit siaran yang menyertakan file ini akan menerima salinan unik dari simbol ini.  Seolah-olah Anda telah menentukan masing-masing simbol tersebut di setiap unit terjemahan.  Untuk objek, ini berarti bahwa kompiler secara harfiah akan mengalokasikan salinan yang sama sekali baru dan unik untuk setiap unit terjemahan, yang, jelas, dapat menyebabkan biaya memori tinggi. <br><br>  Untuk mendeklarasikan simbol yang saling berhubungan, kata kunci statis ada di C dan C ++.  Penggunaan ini berbeda dari penggunaan statis di kelas dan fungsi (atau, secara umum, di blok apa pun). <br><br>  <i>Contoh</i> <br><br>  Berikut ini sebuah contoh: <br><br>  header.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> variable = <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre> <br>  file1.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  file2.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  file1.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"header.hpp"</span></span></span><span class="hljs-meta"> void function1() { variable = 10; }</span></span></code> </pre> <br><br>  file2.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"header.hpp"</span></span></span><span class="hljs-meta"> void function2() { variable = 123; }</span></span></code> </pre> <br>  main.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"header.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"file1.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"file2.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; auto main() -&gt; int { function1(); function2(); std::cout &lt;&lt; variable &lt;&lt; std::endl; }</span></span></span></span></code> </pre> <br>  Setiap unit terjemahan, termasuk header.hpp, mendapat salinan variabel yang unik, karena koneksi internalnya.  Ada tiga unit terjemahan: <br><br><ol><li>  file1.cpp </li><li>  file2.cpp </li><li>  main.cpp </li></ol><br>  Ketika function1 dipanggil, salinan variabel file1.cpp mendapatkan nilai 10. Ketika function2 dipanggil, salinan variabel file2.cpp mendapatkan nilai 123. Namun, nilai yang dikembalikan di main.cpp tidak berubah dan tetap sama dengan 42. <br><br>  <b>Ruang nama anonim</b> <br><br>  Di C ++, ada cara lain untuk mendeklarasikan satu atau lebih karakter yang terhubung secara internal: ruang nama anonim.  Ruang seperti itu memastikan bahwa karakter yang dinyatakan di dalamnya hanya dapat dilihat di unit terjemahan saat ini.  Pada dasarnya, ini hanya cara untuk mendeklarasikan beberapa karakter statis.  Untuk sementara, penggunaan kata kunci statis untuk mendeklarasikan karakter terkait-internal ditinggalkan demi ruang nama anonim.  Namun, mereka kembali menggunakannya karena kemudahan mendeklarasikan satu variabel atau fungsi dengan komunikasi internal.  Ada beberapa perbedaan kecil lainnya yang tidak akan saya pikirkan. <br><br>  Bagaimanapun, ini adalah: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> variable = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Apakah (hampir) sama dengan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> variable = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  <b>Gunakan</b> <br><br>  Jadi dalam hal apa menggunakan koneksi internal?  Menggunakannya untuk objek adalah ide yang buruk.  Konsumsi memori benda besar bisa sangat tinggi karena menyalin untuk setiap unit terjemahan.  Tetapi pada dasarnya, itu hanya menyebabkan perilaku aneh dan tidak terduga.  Bayangkan bahwa Anda memiliki singleton (kelas di mana Anda membuat instance hanya satu instance) dan tiba-tiba beberapa contoh "singleton" Anda muncul (satu untuk setiap unit terjemahan). <br><br>  Namun, komunikasi internal dapat digunakan untuk menyembunyikan unit terjemahan dari area global fungsi pembantu lokal.  Misalkan ada fungsi foo helper di file1.hpp yang Anda gunakan di file1.cpp.  Pada saat yang sama, Anda memiliki fungsi foo di file2.hpp digunakan di file2.cpp.  Foo pertama dan kedua berbeda satu sama lain, tetapi Anda tidak dapat menemukan nama lain.  Karena itu, Anda dapat mendeklarasikannya statis.  Jika Anda tidak menambahkan file1.hpp dan file2.hpp ke unit terjemahan yang sama, maka ini akan menyembunyikan foo satu sama lain.  Jika ini tidak dilakukan, maka mereka secara implisit akan memiliki koneksi eksternal dan definisi foo pertama akan menemui definisi yang kedua, menyebabkan kesalahan linker tentang melanggar aturan satu definisi. <br><br>  AKHIR <br><br>  Anda selalu dapat meninggalkan komentar dan / atau pertanyaan Anda di sini atau kunjungi kami di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hari terbuka.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432834/">https://habr.com/ru/post/id432834/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432824/index.html">Mempercepat pembuatan ConcurrentReferenceHashMap</a></li>
<li><a href="../id432826/index.html">Pengembangan Android modern di Kotlin. Bagian 2</a></li>
<li><a href="../id432828/index.html">Menguji dan men-debug MapReduce</a></li>
<li><a href="../id432830/index.html">Sistem otomatis untuk mengenakan denda untuk sampah yang ditinggalkan</a></li>
<li><a href="../id432832/index.html">Cara "merekatkan" server berbasis Intel dan mengatasi peningkatan skala 8 prosesor</a></li>
<li><a href="../id432836/index.html">Bola lampu bagus pertama dari Aliexpress</a></li>
<li><a href="../id432838/index.html">Pengembangan perangkat lunak melalui prisma percobaan Milgram "Pengajuan ke otoritas"</a></li>
<li><a href="../id432840/index.html">Cara meningkatkan efektivitas belajar bahasa Inggris dan mulai menulis dengan lebih baik: pilih asisten online</a></li>
<li><a href="../id432842/index.html">Beberapa catatan tentang desain sistem informasi</a></li>
<li><a href="../id432844/index.html">Survei pra-desain dalam pengembangan sistem informasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>