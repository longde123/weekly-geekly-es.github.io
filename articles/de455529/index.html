<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👋🏿 👨🏽‍⚕️ ⏮️ Umkehren und Hacken der selbstverschlüsselenden externen Festplatte von Aigo. Teil 2: Dumping mit Cypress PSoC ↕️ 💒 📁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist der zweite und letzte Teil des Artikels über das Hacken externer selbstverschlüsselnder Laufwerke. Ich erinnere Sie daran, dass mir ein Kolle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Umkehren und Hacken der selbstverschlüsselenden externen Festplatte von Aigo. Teil 2: Dumping mit Cypress PSoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455529/"><p>  Dies ist der zweite und letzte Teil des Artikels über das Hacken externer selbstverschlüsselnder Laufwerke.  Ich erinnere Sie daran, dass mir ein Kollege kürzlich eine Patriot (Aigo) SK8671-Festplatte gebracht hat, und ich habe beschlossen, sie umzukehren. Jetzt teile ich mit, was daraus geworden ist.  Lesen Sie unbedingt den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil des</a> Artikels, bevor Sie weiterlesen. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4. Wir beginnen, den Speicherauszug vom internen Flash-Laufwerk PSoC zu entfernen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5. ISSP-Protokoll</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 5.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist ein ISSP?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 5.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entmystifizierung von Vektoren</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 5.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chatte mit PSoC</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 5.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Identifizierung von Intra-Chip-Registern</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 5.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schutzbits</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6. Erster (fehlgeschlagener) Angriff: ROMX</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7. Zweiter Angriff: Trace mit Kaltstart</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 7.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 7.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen Sie das Ergebnis</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 7.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rekonstruktion der Flash-Binärdatei</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 7.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Suchen Sie die Pincode-Speicheradresse</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 7.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir entfernen den Dump von Block Nr. 126</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 7.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pincode-Wiederherstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8. Was kommt als nächstes?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">9. Fazit</a> </p><br><p><img src="https://habrastorage.org/webt/wx/nm/gk/wxnmgkeurrmiurx87rujoynxrsq.jpeg"></p><a name="habracut"></a><br><a name="a4"></a><br><h1 id="4-nachinaem-snimat-damp-s-vnutrenney-fleshki-psoc">  4. Wir beginnen, den Speicherauszug vom internen Flash-Laufwerk PSoC zu entfernen </h1><br><p>  Alles deutet also darauf hin (wie wir in [dem ersten Teil] () festgestellt haben), dass der PIN-Code im PSoC-Flash-Darm gespeichert ist.  Deshalb müssen wir diese Blitzdärme lesen.  Vor der notwendigen Arbeit: </p><br><ul><li>  die Kontrolle über die "Kommunikation" mit dem Mikrocontroller übernehmen; </li><li>  einen Weg finden, um zu überprüfen, ob diese "Kommunikation" vor dem Lesen von außen geschützt ist; </li><li>  einen Weg finden, um die Sicherheit zu umgehen. </li></ul><br><p>  Es gibt zwei Stellen, an denen es sinnvoll ist, nach einem gültigen PIN-Code zu suchen: </p><br><ul><li>  interner Flash-Speicher; </li><li>  SRAM, in dem der PIN-Code gespeichert werden kann, um ihn mit dem vom Benutzer eingegebenen PIN-Code zu vergleichen. </li></ul><br><p>  Mit Blick auf die Zukunft stelle ich fest, dass es mir immer noch gelungen ist, den Speicherauszug des internen Flash-Laufwerks PSoC unter Umgehung seines Schutzsystems mithilfe des Hardwareangriffs "Cold Reset Trace" zu entfernen, nachdem die undokumentierten Funktionen des ISSP-Protokolls umgekehrt wurden.  Dadurch konnte ich den aktuellen PIN-Code direkt ausgeben. </p><br><pre><code class="plaintext hljs">$ ./psoc.py syncing: KO OK [...] PIN: 1 2 3 4 5 6 7 8 9</code> </pre> <br><p>  Der resultierende Programmcode: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arduino-Code für HSSP</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python-Treiber und ISSP-Disassembler</a> . </li></ul><br><a name="a5"></a><br><h1 id="5-issp-protokol">  5. ISSP-Protokoll </h1><br><a name="a51"></a><br><h2 id="51-chto-takoe-issp">  5.1.  Was ist ein ISSP? </h2><br><p>  "Kommunikation" mit dem Mikrocontroller kann verschiedene Bedeutungen haben: von "Anbieter zu Anbieter" bis zur Interaktion über ein serielles Protokoll (z. B. ICSP für den PIC von Microchip). </p><br><p>  Cypress verfügt hierfür über ein eigenes Protokoll namens ISSP (In-System Serial Programming Protocol), das teilweise in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">technischen Spezifikation beschrieben ist</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">US7185162</a> bietet auch einige Informationen.  Es gibt auch ein OpenSource-Analogon namens HSSP (wir werden es etwas später verwenden).  ISSP funktioniert wie folgt: </p><br><ul><li>  PSoC neu starten; </li><li>  Bringen Sie die magische Nummer in den seriellen Datenbereich dieses PSoC.  externen Programmiermodus aufrufen; </li><li>  Senden Sie Befehle, bei denen es sich um lange Bitfolgen handelt, die als "Vektoren" bezeichnet werden. </li></ul><br><p>  In der ISSP-Dokumentation werden diese Vektoren nur für eine kleine Handvoll Befehle definiert: </p><br><ul><li>  Initialisieren Sie-1 </li><li>  Initialize-2 </li><li>  Initialize-3 (3V- und 5V-Optionen) </li><li>  ID-SETUP </li><li>  READ-ID-WORD </li><li>  SET-BLOCK-NUM: 10011111010dddddddd111, wobei dddddddd = block # </li><li>  BULK ERASE </li><li>  PROGRAMMBLOCK </li><li>  ÜBERPRÜFEN-SETUP </li><li>  READ-BYTE: 10110aaaaaaZDDDDDDDDZ1, wobei DDDDDDDDD = Datenausgang, aaaaaa = Adresse (6 Bit) </li><li>  WRITE-BYTE: 10010aaaaaadddddddd111, wobei dddddddd = Daten in, aaaaaa = Adresse (6 Bit) </li><li>  Sicher </li><li>  CHECKSUM-SETUP </li><li>  READ-CHECKSUM: 10111111001ZDDDDDDDDDZ110111111000ZDDDDDDDZ1, wobei DDDDDDDDDDDDDDD = Datenausgang: Geräteprüfsumme </li><li>  BLOCK LÖSCHEN </li></ul><br><p>  Zum Beispiel der Vektor für Initialize-2: </p><br><pre> <code class="plaintext hljs">1101111011100000000111 1101111011000000000111 1001111100000111010111 1001111100100000011111 1101111010100000000111 1101111010000000011111 1001111101110000000111 1101111100100110000111 1101111101001000000111 1001111101000000001111 1101111000000000110111 1101111100000000000111 1101111111100010010111</code> </pre> <br><p>  Alle Vektoren haben die gleiche Länge: 22 Bit.  Die HSSP-Dokumentation enthält einige zusätzliche Informationen zu ISSPs: „Ein ISSP-Vektor ist nichts anderes als eine Bitfolge, die einen Befehlssatz darstellt.“ </p><br><a name="a52"></a><br><h2 id="52-demistifikaciya-vektorov">  5.2.  Entmystifizierung von Vektoren </h2><br><p>  Mal sehen, was hier passiert.  Anfangs nahm ich an, dass dieselben Vektoren Rohvarianten der M8C-Anweisungen sind. Nachdem ich diese Hypothese getestet hatte, stellte ich fest, dass die Opcodes der Operationen nicht übereinstimmen. </p><br><p>  Dann habe ich den obigen Vektor gegoogelt und bin auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese</a> Studie gestoßen, in der der Autor, obwohl er nicht auf Details eingeht, einige praktische Hinweise gibt: „Jede Anweisung beginnt mit drei Bits, die einer der vier Mnemoniken entsprechen (aus dem RAM lesen, in den RAM schreiben) , das Register lesen, das Register schreiben).  Dann kommt die 8-Bit-Adresse, gefolgt von 8 Datenbits (entweder gelesen oder geschrieben) und schließlich drei Stoppbits. “ </p><br><p>  Dann konnte ich einige sehr nützliche Informationen aus dem Abschnitt Supervisory ROM (SROM) des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">technischen Handbuchs</a> sammeln.  SROM ist ein fest codiertes ROM in PSoC, das Servicefunktionen (ähnlich wie Syscall) für Software-Code bereitstellt, der im Benutzerbereich ausgeführt wird: </p><br><ul><li>  00h: SWBootReset </li><li>  01h: ReadBlock </li><li>  02h: WriteBlock </li><li>  03h: EraseBlock </li><li>  06h: TableRead </li><li>  07h: CheckSum </li><li>  08h: Calibrate0 </li><li>  09h: Kalibrieren1 </li></ul><br><p>  Durch den Vergleich von Vektornamen mit SROM-Funktionen können wir die verschiedenen von diesem Protokoll unterstützten Operationen den erwarteten SROM-Parametern zuordnen.  Dank dessen können wir die ersten drei Bits von ISSP-Vektoren decodieren: </p><br><ul><li>  100 =&gt; "wrmem" </li><li>  101 =&gt; "rdmem" </li><li>  110 =&gt; "wrreg" </li><li>  111 =&gt; "rdreg" </li></ul><br><p>  Ein umfassendes Verständnis der Intra-Chip-Prozesse kann jedoch nur durch direkte Kommunikation mit PSoC erreicht werden. </p><br><a name="a53"></a><br><h2 id="53-obschenie-s-psoc">  5.3.  Chatte mit PSoC </h2><br><p>  Da Dirk Petrautsky <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den</a> Cypress HSSP-Code bereits nach Arduino <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">portiert</a> hat, habe ich Arduino Uno verwendet, um die Tastaturplatine mit dem ISSP-Anschluss zu verbinden. </p><br><p>  Bitte beachten Sie, dass ich während meiner Recherche den Dirk-Code ziemlich geändert habe.  Sie finden meine Änderung auf GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist das</a> entsprechende Python-Skript für die Kommunikation mit Arduino in meinem Repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cypress_psoc_tools</a> . </p><br><p>  Bei Verwendung von Arduino habe ich zunächst nur "offizielle" Vektoren für "Kommunikation" verwendet.  Ich habe versucht, das interne ROM mit dem Befehl VERIFY zu lesen.  Wie erwartet konnte ich das nicht tun.  Wahrscheinlich aufgrund der Tatsache, dass Leseschutzbits im Flash-Laufwerk aktiviert sind. </p><br><p>  Dann habe ich einige meiner einfachen Vektoren zum Schreiben und Lesen von Speicher / Registern erstellt.  Bitte beachten Sie, dass wir das gesamte SROM lesen können, obwohl das Flash-Laufwerk geschützt ist! </p><br><a name="a54"></a><br><h2 id="54-identifikaciya-vnutrichipovyh-registrov">  5.4.  Identifizierung von Intra-Chip-Registern </h2><br><p>  Bei der Betrachtung der "zerlegten" Vektoren stellte ich fest, dass das Gerät undokumentierte Register (0xF8-0xFA) verwendet, um M8C-Opcodes anzuzeigen, die direkt ausgeführt werden und den Schutz umgehen.  Dadurch konnte ich verschiedene Opcodes wie "ADD", "MOV A, X", "PUSH" oder "JMP" ausführen.  Dank ihnen (unter Berücksichtigung der Nebenwirkungen, die sie auf die Register haben) konnte ich feststellen, welche der nicht dokumentierten Register tatsächlich reguläre Register sind (A, X, SP und PC). </p><br><p>  Infolgedessen sieht der vom Tool HSSP_disas.rb generierte "disassemblierte" Code folgendermaßen aus (aus Gründen der Übersichtlichkeit habe ich Kommentare hinzugefügt): </p><br><pre> <code class="plaintext hljs">--== init2 ==-- [DE E0 1C] wrreg CPU_F (f7), 0x00 #   [DE C0 1C] wrreg SP (f6), 0x00 #  SP [9F 07 5C] wrmem KEY1, 0x3A #    SSC [9F 20 7C] wrmem KEY2, 0x03 #  [DE A0 1C] wrreg PCh (f5), 0x00 #  PC (MSB) ... [DE 80 7C] wrreg PCl (f4), 0x03 # (LSB) ...  3 ?? [9F 70 1C] wrmem POINTER, 0x80 # RAM-    [DF 26 1C] wrreg opc1 (f9), 0x30 #  1 =&gt; "HALT" [DF 48 1C] wrreg opc2 (fa), 0x40 #  2 =&gt; "NOP" [9F 40 3C] wrmem BLOCKID, 0x01 # BLOCK ID   SSC [DE 00 DC] wrreg A (f0), 0x06 #  "Syscall" : TableRead [DF 00 1C] wrreg opc0 (f8), 0x00 #   SSC, "Supervisory SROM Call" [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12 #  :   </code> </pre> <br><a name="a55"></a><br><h2 id="55-zaschitnye-bity">  5.5.  Schutzbits </h2><br><p>  Zu diesem Zeitpunkt kann ich bereits mit PSoC kommunizieren, habe jedoch noch keine zuverlässigen Informationen zu den Schutzbits des Flash-Laufwerks.  Ich war sehr überrascht von der Tatsache, dass Cypress dem Gerätebenutzer keine Möglichkeit bietet, zu überprüfen, ob der Schutz aktiviert ist.  Ich ging tief in Google ein, um endlich zu verstehen, dass der von Cypress bereitgestellte HSSP-Code aktualisiert wurde, nachdem Dirk seine Änderung veröffentlicht hatte.  Und los geht's!  Hier ist ein neuer Vektor wie dieser: </p><br><pre> <code class="plaintext hljs">[DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A [9F 20 7C] wrmem KEY2, 0x03 [9F A0 1C] wrmem 0xFD, 0x00 #   [9F E0 1C] wrmem 0xFF, 0x00 #  [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [DE 02 1C] wrreg A (f0), 0x10 #  syscall ! [DF 00 1C] wrreg opc0 (f8), 0x00 [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Mit diesem Vektor (siehe read_security_data in psoc.py) erhalten wir alle Schutzbits im SRAM bei 0x80, wobei jedes Bit mit zwei Bits geschützt ist. </p><br><p>  Das Ergebnis ist deprimierend: Im Modus "Externes Lesen und Schreiben deaktivieren" ist alles geschützt.  Daher können wir nicht nur etwas vom USB-Stick lesen, sondern auch schreiben (zum Beispiel, um dort einen ROM-Dumper einzuführen).  Die einzige Möglichkeit, den Schutz zu deaktivieren, besteht darin, den gesamten Chip vollständig zu löschen.  :-( </p><br><a name="a6"></a><br><h1 id="6-pervaya-neudavshayasya-ataka-romx">  6. Erster (fehlgeschlagener) Angriff: ROMX </h1><br><p>  Wir können jedoch den folgenden Trick ausprobieren: Da wir beliebige Opcodes ausführen können, können Sie ROMX ausführen, das zum Lesen des Flash-Speichers verwendet wird.  Dieser Ansatz hat gute Erfolgschancen.  Da die ReadBlock-Funktion, die Daten aus dem SROM liest (das von Vektoren verwendet wird), prüft, ob sie vom ISSP aufgerufen werden.  Vermutlich hat der ROMX-Opcode jedoch keine solche Prüfung.  Hier ist also der Python-Code (nachdem dem Arduino C-Code einige Hilfsklassen hinzugefügt wurden): </p><br><pre> <code class="plaintext hljs">for i in range(0, 8192): write_reg(0xF0, i&gt;&gt;8) # A = 0 write_reg(0xF3, i&amp;0xFF) # X = 0 exec_opcodes("\x28\x30\x40") # ROMX, HALT, NOP byte = read_reg(0xF0) # ROMX reads ROM[A|X] into A print "%02x" % ord(byte[0]) # print ROM byte</code> </pre> <br><p>  Leider funktioniert dieser Code nicht.  :-( Es funktioniert eher, aber am Ausgang erhalten wir unsere eigenen Opcodes (0x28 0x30 0x40)! Ich glaube nicht, dass die entsprechende Funktionalität des Geräts ein Element des Leseschutzes ist. Dies ist eher ein technischer Trick: Bei der Ausführung externer Opcodes wird der ROM-Bus umgeleitet zu einem temporären Puffer. </p><br><a name="a7"></a><br><h1 id="7-vtoraya-ataka-trassirovka-s-holodnoy-perezagruzkoy">  7. Zweiter Angriff: Trace mit Kaltstart </h1><br><p>  Da der ROMX-Trick nicht funktionierte, begann ich über eine andere Variante dieses Tricks nachzudenken - beschrieben in der Veröffentlichung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Zu viel Licht auf den Firmware-Schutz eines Mikrocontrollers werfen"</a> . </p><br><a name="a71"></a><br><h2 id="71-realizaciya">  7.1.  Implementierung </h2><br><p>  Der folgende Vektor für CHECKSUM-SETUP ist in der ISSP-Dokumentation aufgeführt: </p><br><pre> <code class="plaintext hljs">[DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A [9F 20 7C] wrmem KEY2, 0x03 [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [9F 40 1C] wrmem BLOCKID, 0x00 [DE 00 FC] wrreg A (f0), 0x07 [DF 00 1C] wrreg opc0 (f8), 0x00 [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Hier wird im Wesentlichen die SROM-Funktion 0x07 aufgerufen, wie in der Dokumentation dargestellt (meine kursiv): </p><br><blockquote>  Diese Funktion Prüfsumme Prüfsumme.  Es berechnet eine 16-Bit-Prüfsumme der Anzahl der vom Benutzer in einer Flash-Bank festgelegten Blöcke, wobei von Null aus gezählt wird.  Mit dem Parameter BLOCKID wird die Anzahl der Blöcke übertragen, die bei der Berechnung der Prüfsumme verwendet werden.  Ein Wert von "1" berechnet die Prüfsumme nur für den Nullblock.  während <em>"0" dazu führt, dass die Gesamtprüfsumme aller 256 Blöcke der Flash-Bank berechnet wird.</em>  <em>Eine 16-Bit-Prüfsumme wird über KEY1 und KEY2 zurückgegeben.</em>  In Parameter KEY1 sind die niedrigen 8 Bits der Prüfsumme festgelegt, und in KEY2 werden die hohen 8 Bits aufgezeichnet.  Bei Geräten mit mehreren Flash-Bänken wird die Prüfsummenfunktion für jedes einzeln aufgerufen.  Die Banknummer, mit der es arbeiten wird, wird durch das Register FLS_PR1 eingestellt (indem ein Bit entsprechend der Ziel-Flash-Bank gesetzt wird). </blockquote><p>  Beachten Sie, dass dies die einfachste Prüfsumme ist: Bytes werden einfach einzeln summiert.  Keine ausgeklügelten CRC-Macken.  Da ich wusste, dass der Registersatz im M8C-Kern sehr klein ist, ging ich davon aus, dass bei der Berechnung der Prüfsumme die Zwischenwerte in denselben Variablen festgelegt werden, die schließlich ausgegeben werden: KEY1 (0xF8) / KEY2 (0xF9). </p><br><p>  Theoretisch sieht mein Angriff also so aus: </p><br><ol><li>  Stellen Sie eine Verbindung über ISSP her. </li><li>  Wir starten die Berechnung der Prüfsumme mit dem Vektor CHECKSUM-SETUP. </li><li>  Wir starten den Prozessor nach der angegebenen Zeit T neu. </li><li>  Lesen Sie den RAM, um die aktuelle Prüfsumme C zu erhalten. </li><li>  Wiederholen Sie die Schritte 3 und 4 jedes Mal, wenn Sie T erhöhen. </li><li>  Wir stellen Daten vom Flash-Laufwerk wieder her, indem wir die vorherige Prüfsumme C von der aktuellen subtrahieren. </li></ol><br><p>  Es trat jedoch ein Problem auf: Der Initialize-1-Vektor, den wir nach dem Neustart senden müssen, überschreibt KEY1 und KEY2: </p><br><pre> <code class="plaintext hljs">1100101000000000000000 # ,  PSoC    nop nop nop nop nop [DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A #     [9F 20 7C] wrmem KEY2, 0x03 #   [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [DE 01 3C] wrreg A (f0), 0x09 # SROM- 9 [DF 00 1C] wrreg opc0 (f8), 0x00 # SSC [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Dieser Code überschreibt unsere wertvolle Prüfsumme durch Aufrufen von Calibrate1 (SROM-Funktion 9) ... Vielleicht können wir einfach in den Programmiermodus wechseln, indem wir die magische Nummer (ab dem Anfang des obigen Codes) senden und dann SRAM lesen?  Und ja, es funktioniert!  Der Arduino-Code, der diesen Angriff implementiert, ist ziemlich einfach: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Cmnd_STK_START_CSUM: checksum_delay = ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">24</span></span>; checksum_delay |= ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>; checksum_delay |= ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; checksum_delay |= getch(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checksum_delay &gt; <span class="hljs-number"><span class="hljs-number">10000</span></span>) { ms_delay = checksum_delay/<span class="hljs-number"><span class="hljs-number">1000</span></span>; checksum_delay = checksum_delay%<span class="hljs-number"><span class="hljs-number">1000</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ms_delay = <span class="hljs-number"><span class="hljs-number">0</span></span>; } send_checksum_v(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checksum_delay) delayMicroseconds(checksum_delay); delay(ms_delay); start_pmode();</code> </pre> <br><ol><li>  Lesen Sie checkum_delay. </li><li>  Führen Sie die Prüfsummenberechnung aus (send_checksum_v). </li><li>  Warten Sie einen bestimmten Zeitraum.  angesichts der folgenden Fallstricke: <br><ul><li>  Ich habe viel Zeit verloren, bis ich herausfand, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">delayMicroseconds</a> nur mit Verzögerungen von nicht mehr als 16383 mks korrekt funktioniert. </li><li>  und dann wieder die gleiche Zeitspanne getötet, bis festgestellt wurde, dass delayMicroseconds, wenn es 0 an seine Eingabe übergeben hat, völlig falsch funktioniert hat! </li></ul></li><li>  Laden Sie PSoC erneut in den Programmiermodus (senden Sie einfach die magische Zahl, ohne Initialisierungsvektoren zu senden). </li></ol><br><p>  Der resultierende Python-Code: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> delay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">150000</span></span>): <span class="hljs-comment"><span class="hljs-comment">#    for i in range(0, 10): #      try: reset_psoc(quiet=True) #       send_vectors() #    ser.write("\x85"+struct.pack("&gt;I", delay)) #    +    res = ser.read(1) #  arduino ACK except Exception as e: print e ser.close() os.system("timeout -s KILL 1s picocom -b 115200 /dev/ttyACM0 2&gt;&amp;1 &gt; /dev/null") ser = serial.Serial('/dev/ttyACM0', 115200, timeout=0.5) #    continue print "%05d %02X %02X %02X" % (delay, #  RAM- read_regb(0xf1), read_ramb(0xf8), read_ramb(0xf9))</span></span></code> </pre> <br><p>  Kurz gesagt, was dieser Code bewirkt: </p><br><ol><li>  Lädt den PSoC neu (und sendet ihm eine magische Nummer). </li><li>  Sendet vollständige Initialisierungsvektoren. </li><li>  Ruft die Arduino-Funktion Cmnd_STK_START_CSUM (0x85) auf, bei der die Verzögerung in Mikrosekunden als Parameter übergeben wird. </li><li>  Liest die Prüfsumme (0xF8 und 0xF9) und das undokumentierte Register 0xF1. </li></ol><br><p>  Dieser Code wird 10 Mal in 1 Mikrosekunde ausgeführt.  0xF1 ist hier enthalten, da es das einzige Register war, das sich bei der Berechnung der Prüfsumme geändert hat.  Vielleicht ist dies eine Art temporäre Variable, die von der arithmetischen Logikvorrichtung verwendet wird.  Achten Sie auf den hässlichen Hack, dass ich Arduino mit Picocom neu starte, wenn der Arduino keine Lebenszeichen mehr gibt (ich habe keine Ahnung warum). </p><br><a name="a72"></a><br><h2 id="72-schityvaem-rezultat">  7.2.  Lesen Sie das Ergebnis </h2><br><p>  Das Ergebnis des Python-Skripts sieht folgendermaßen aus (zur besseren Lesbarkeit vereinfacht): </p><br><pre> <code class="plaintext hljs">DELAY F1 F8 F9 # F1 –    # F8     # F9     00000 03 E1 19 [...] 00016 F9 00 03 00016 F9 00 00 00016 F9 00 03 00016 F9 00 03 00016 F9 00 03 00016 F9 00 00 #     0 00017 FB 00 00 [...] 00023 F8 00 00 00024 80 80 00 # 1- : 0x0080-0x0000 = 0x80 00024 80 80 00 00024 80 80 00 [...] 00057 CC E7 00 # 2- : 0xE7-0x80: 0x67 00057 CC E7 00 00057 01 17 01 #   ,    00057 01 17 01 00057 01 17 01 00058 D0 17 01 00058 D0 17 01 00058 D0 17 01 00058 D0 17 01 00058 F8 E7 00 #  E7? 00058 D0 17 01 [...] 00059 E7 E7 00 00060 17 17 00 #  [...] 00062 00 17 00 00062 00 17 00 00063 01 17 01 # , !        00063 01 17 01 [...] 00075 CC 17 01 # , 0x117-0xE7: 0x30</code> </pre> <br><p>  Gleichzeitig haben wir ein Problem: Da wir mit der tatsächlichen Prüfsumme arbeiten, ändert ein Null-Byte den Lesewert nicht.  Da der gesamte Berechnungsvorgang (8192 Bytes) jedoch 0,1478 Sekunden dauert (mit geringfügigen Abweichungen bei jedem Start), was ungefähr 18,04 μs pro Byte entspricht, können wir diese Zeit verwenden, um den Wert der Prüfsumme zu geeigneten Zeiten zu überprüfen.  Bei den ersten Läufen ist alles recht einfach zu lesen, da die Dauer des Rechenvorgangs immer fast gleich ist.  Das Ende dieses Dumps ist jedoch weniger genau, da die „unbedeutenden Zeitabweichungen“ bei jedem Lauf zusammengefasst werden und signifikant werden: </p><br><pre> <code class="plaintext hljs">134023 D0 02 DD 134023 CC D2 DC 134023 CC D2 DC 134023 CC D2 DC 134023 FB D2 DC 134023 3F D2 DC 134023 CC D2 DC 134024 02 02 DC 134024 CC D2 DC 134024 F9 02 DC 134024 03 02 DD 134024 21 02 DD 134024 02 D2 DC 134024 02 02 DC 134024 02 02 DC 134024 F8 D2 DC 134024 F8 D2 DC 134025 CC D2 DC 134025 EF D2 DC 134025 21 02 DD 134025 F8 D2 DC 134025 21 02 DD 134025 CC D2 DC 134025 04 D2 DC 134025 FB D2 DC 134025 CC D2 DC 134025 FB 02 DD 134026 03 02 DD 134026 21 02 DD</code> </pre> <br><p>  Dies sind 10 Speicherauszüge für jede Mikrosekundenverzögerung.  Die Gesamtbetriebszeit für das Speichern aller 8192 Bytes eines Flash-Laufwerks beträgt ca. 48 Stunden. </p><br><a name="a73"></a><br><h2 id="73-rekonstrukciya-flesh-binarnika">  7.3.  Rekonstruktion der Flash-Binärdatei </h2><br><p>  Ich habe noch keinen Code geschrieben, der den Programmcode des Flash-Laufwerks unter Berücksichtigung aller zeitlichen Abweichungen vollständig rekonstruiert.  Ich habe jedoch bereits den Anfang dieses Codes wiederhergestellt.  Um sicherzustellen, dass ich es richtig gemacht habe, habe ich es mit m8cdis zerlegt: </p><br><pre> <code class="plaintext hljs">0000: 80 67 jmp 0068h ; Reset vector [...] 0068: 71 10 or F,010h 006a: 62 e3 87 mov reg[VLT_CR],087h 006d: 70 ef and F,0efh 006f: 41 fe fb and reg[CPU_SCR1],0fbh 0072: 50 80 mov A,080h 0074: 4e swap A,SP 0075: 55 fa 01 mov [0fah],001h 0078: 4f mov X,SP 0079: 5b mov A,X 007a: 01 03 add A,003h 007c: 53 f9 mov [0f9h],A 007e: 55 f8 3a mov [0f8h],03ah 0081: 50 06 mov A,006h 0083: 00 ssc [...] 0122: 18 pop A 0123: 71 10 or F,010h 0125: 43 e3 10 or reg[VLT_CR],010h 0128: 70 00 and F,000h ; Paging mode changed from 3 to 0 012a: ef 62 jacc 008dh 012c: e0 00 jacc 012dh 012e: 71 10 or F,010h 0130: 62 e0 02 mov reg[OSC_CR0],002h 0133: 70 ef and F,0efh 0135: 62 e2 00 mov reg[INT_VC],000h 0138: 7c 19 30 lcall 1930h 013b: 8f ff jmp 013bh 013d: 50 08 mov A,008h 013f: 7f ret</code> </pre> <br><p>  Sieht ziemlich glaubwürdig aus! </p><br><a name="a74"></a><br><h2 id="74-nahodim-adres-hraneniya-pinkoda">  7.4.  Suchen Sie die Pincode-Speicheradresse </h2><br><p>  Jetzt, da wir die Prüfsumme zum gewünschten Zeitpunkt lesen können, können wir leicht überprüfen, wie und wo sie sich ändert, wenn wir: </p><br><ul><li>  Geben Sie den falschen PIN-Code ein. </li><li>  Ändern Sie den PIN-Code. </li></ul><br><p>  Um die ungefähre Speicheradresse zu ermitteln, habe ich nach einem Neustart einen Prüfsummen-Dump in Schritten von 10 ms erstellt.  Dann habe ich den falschen PIN-Code eingegeben und das Gleiche getan. </p><br><p>  Das Ergebnis war nicht sehr angenehm, da es viele Änderungen gab.  Am Ende konnte ich jedoch feststellen, dass sich die Prüfsumme irgendwo im Intervall zwischen 120.000 μs und 140.000 μs Verzögerung geändert hat.  Aber der „Pincode“, den ich dort erhalten habe, war völlig falsch - aufgrund des Artefakts der delayMicroseconds-Prozedur, das seltsame Dinge tut, wenn es 0 wird. </p><br><p>  Nachdem ich fast 3 Stunden verbracht hatte, fiel mir ein, dass der CheckSum SROM-Systemaufruf am Eingang ein Argument erhält, das die Anzahl der Blöcke für die Prüfsumme angibt!  T.O.  Wir können die Speicheradresse des PIN-Codes und den Zähler für „falsche Versuche“ leicht lokalisieren, genau auf den 64-Byte-Block. </p><br><p>  Meine ersten Läufe ergaben das folgende Ergebnis: </p><br><p><img src="https://habrastorage.org/webt/0n/ol/xc/0nolxcgp8espvfdubrhrmvmbgrg.png"></p><br><p>  Dann habe ich den PIN-Code von "123456" in "1234567" geändert und erhalten: </p><br><p><img src="https://habrastorage.org/webt/0r/zp/s2/0rzps2e2mwldmhtot1tswiv7mdq.png"></p><br><p>  Somit scheinen der Pincode und der Zähler falscher Versuche in Block Nr. 126 gespeichert zu sein. </p><br><a name="a75"></a><br><h2 id="75-snimaem-damp-bloka-126">  7.5.  Wir entfernen den Dump von Block Nr. 126 </h2><br><p>  Block Nr. 126 sollte sich irgendwo in der Region von 125 x 64 x 18 = 144000 mks befinden, vom Beginn der Berechnung der Prüfsumme an, in meinem vollständigen Speicherauszug, und es sieht ziemlich glaubwürdig aus.  Nachdem ich zahlreiche ungültige Speicherauszüge manuell herausgesiebt hatte (aufgrund der Anhäufung von "geringfügigen Zeitabweichungen"), erhielt ich schließlich diese Bytes (mit einer Verzögerung von 145527 μs): </p><br><p><img src="https://habrastorage.org/webt/ji/31/ye/ji31yewphovunymnjxp0fcpwrdw.png"></p><br><p>  Es ist klar, dass der PIN-Code unverschlüsselt gespeichert ist!  Diese Werte sind natürlich nicht in ASCII-Codes geschrieben, aber wie sich herausstellte, spiegeln sie die Messwerte der kapazitiven Tastatur wider. </p><br><p>  Schließlich habe ich noch einige Tests durchgeführt, um herauszufinden, wo der Zähler für falsche Versuche gespeichert ist.  Hier ist das Ergebnis: </p><br><p><img src="https://habrastorage.org/webt/dc/r5/tf/dcr5tf0yevdxcg5lyrbcr9srowu.png"></p><br><p>  0xFF - bedeutet "15 Versuche" und nimmt mit jedem falschen Versuch ab. </p><br><a name="a76"></a><br><h2 id="76-vosstanovlenie-pinkoda">  7.6.  Pincode-Wiederherstellung </h2><br><p>  Hier ist mein hässlicher Code, der all das zusammenbringt: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump_pin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> pin_map = {<span class="hljs-number"><span class="hljs-number">0x24</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-number"><span class="hljs-number">0x25</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-number"><span class="hljs-number">0x26</span></span>: <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-number"><span class="hljs-number">0x27</span></span>:<span class="hljs-string"><span class="hljs-string">"3"</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>: <span class="hljs-string"><span class="hljs-string">"4"</span></span>, <span class="hljs-number"><span class="hljs-number">0x21</span></span>: <span class="hljs-string"><span class="hljs-string">"5"</span></span>, <span class="hljs-number"><span class="hljs-number">0x22</span></span>: <span class="hljs-string"><span class="hljs-string">"6"</span></span>, <span class="hljs-number"><span class="hljs-number">0x23</span></span>: <span class="hljs-string"><span class="hljs-string">"7"</span></span>, <span class="hljs-number"><span class="hljs-number">0x2c</span></span>: <span class="hljs-string"><span class="hljs-string">"8"</span></span>, <span class="hljs-number"><span class="hljs-number">0x2d</span></span>: <span class="hljs-string"><span class="hljs-string">"9"</span></span>} last_csum = <span class="hljs-number"><span class="hljs-number">0</span></span> pin_bytes = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> delay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">145495</span></span>, <span class="hljs-number"><span class="hljs-number">145719</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>): csum = csum_at(delay, <span class="hljs-number"><span class="hljs-number">1</span></span>) byte = (csum-last_csum)&amp;<span class="hljs-number"><span class="hljs-number">0xFF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"%05d %04x (%04x) =&gt; %02x"</span></span> % (delay, csum, last_csum, byte) pin_bytes.append(byte) last_csum = csum <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"PIN: "</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(pin_bytes)): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pin_bytes[i] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pin_map: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> pin_map[pin_bytes[i]], <span class="hljs-keyword"><span class="hljs-keyword">print</span></span></code> </pre> <br><p>  Hier ist das Ergebnis seiner Ausführung: </p><br><pre> <code class="plaintext hljs">$ ./psoc.py syncing: KO OK Resetting PSoC: KO Resetting PSoC: KO Resetting PSoC: OK 145495 53e2 (0000) =&gt; e2 145511 5407 (53e2) =&gt; 25 145527 542d (5407) =&gt; 26 145543 5454 (542d) =&gt; 27 145559 5474 (5454) =&gt; 20 145575 5495 (5474) =&gt; 21 145591 54b7 (5495) =&gt; 22 145607 54da (54b7) =&gt; 23 145623 5506 (54da) =&gt; 2c 145639 5506 (5506) =&gt; 00 145655 5533 (5506) =&gt; 2d 145671 554c (5533) =&gt; 19 145687 554e (554c) =&gt; 02 145703 554e (554e) =&gt; 00 PIN: 1 2 3 4 5 6 7 8 9</code> </pre> <br><p>  Hurra!  Es funktioniert! </p><br><p>  Bitte beachten Sie, dass die von mir verwendeten Verzögerungswerte höchstwahrscheinlich für eine bestimmte PSoC relevant sind - die von mir verwendete. </p><br><a name="a8"></a><br><h1 id="8-chto-dalshe">  8. Was kommt als nächstes? </h1><br><p>  Um es auf der PSoC-Seite im Zusammenhang mit unserem Aigo-Laufwerk zusammenzufassen: </p><br><ul><li>    SRAM,      ; </li><li>      ,   «   »,    . </li></ul><br><p>   ,       – -   .       : </p><br><ul><li>       ,      «   »; </li><li>  FPGA-       (    Arduino); </li><li>    :    ,     RAM,   ,       RAM,  .   Arduino    - ,    Arduino  5 ,            3,3 . </li></ul><br><p>   ,      –   ,     .     ,         , –  ,          . </p><br><p>  SROM,        ReadBlock,       ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>     –     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">«REcon Brussels 2017»</a> . </p><br><p>    ,      –    :    SRAM,      . </p><br><a name="a9"></a><br><h1 id="9-zaklyuchenie"> 9.  </h1><br><p> ,      ,         ( «») …      (),         ! </p><br><p>     Aigo?  -   HDD-,   2015   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  SyScan,        HDD-,   ,       .  :-) </p><br><p>          .     40 .     (   )    ( ).    40   ,       .    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455529/">https://habr.com/ru/post/de455529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455517/index.html">Absolvent des Netologiekurses „Data Science“ über seine Arbeit im Bankensektor</a></li>
<li><a href="../de455519/index.html">Wie wir das Onboarding neuer Entwickler implementiert haben</a></li>
<li><a href="../de455523/index.html">OpenStack LBaaS UI-Implementierung</a></li>
<li><a href="../de455525/index.html">Zimbra und Mail Bomb Defense</a></li>
<li><a href="../de455527/index.html">Was steht darin geschrieben? Hinter den Kulissen von JavaScript-Objekten</a></li>
<li><a href="../de455533/index.html">Blasenphysik: Eine Suche nach Schaumzerstörungsmechanismus</a></li>
<li><a href="../de455535/index.html">Verwalten von SSL / TLS-Zertifikaten in den Clouds und Containern - keine menschliche Arbeit</a></li>
<li><a href="../de455537/index.html">Umfassende Suchoptimierung: So verarbeiten Sie ein Diagramm mit 10 Milliarden Status</a></li>
<li><a href="../de455539/index.html">Mobile Hellseher: 10 neue Fakten darüber, wie tragbare Geräte Sie beobachten</a></li>
<li><a href="../de455543/index.html">Ist Kubernetes Cluster einfach und bequem vorzubereiten? Addon-Operator ankündigen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>