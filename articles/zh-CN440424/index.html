<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔬 😗 🙆🏾 思维与意识算法 👨🏽‍🚀 🔛 👍🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文概述了一种思考和意识的算法。 我对思考和意识如何运作的问题提供答案。 我演示了一种可以真正，创造性地思考并拥有真实意识的算法。 本文面向程序员，由两个主要部分组成。 第一部分纯粹是技术性的，其中包含对算法的描述，其属性列表以及实际应用示例。 第二部分包含解释性论文和建设性意识公理化问题的解决方案...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>思维与意识算法</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440424/"> 本文概述了一种思考和意识的算法。 我对思考和意识如何运作的问题提供答案。 我演示了一种可以真正，创造性地思考并拥有真实意识的算法。 本文面向程序员，由两个主要部分组成。 第一部分纯粹是技术性的，其中包含对算法的描述，其属性列表以及实际应用示例。 第二部分包含解释性论文和建设性意识公理化问题的解决方案。 算法是一个有意义的文本，可以说明一切，因此，实际上只有必要的最少注释。 <br><a name="habracut"></a><br><h2> 算法说明 </h2><br> 根据“自上而下”的原则，以自制的数学形式主义对算法进行描述，即首先给出最终的抽象记录，然后按调用和给出注释的顺序分析算法的各个部分。 因此，“组合”算法是以下形式的递归函数： <br><br>  <font color="#0000ff">t <sub>n +1</sub> = <b>组成</b> [ <b>抽象</b> [ <b>推论</b> [t <sub>n</sub> ]]]；</font>  <font color="#0000ff">t <sub>0</sub> = s;</font>  <font color="#0000ff">t <sub>n</sub> ，s∈S;</font>  <font color="#0000ff">n∈N</font> <br><br> 该函数的计算正在思考中。 如您所见，记录中出现了三个运算符： <br>  <font color="#0000ff"><b>组成</b> []</font> ， <font color="#0000ff"><b>抽象</b> []</font> ， <font color="#0000ff"><b>演绎</b> []</font> ； 还有：种子变量<font color="#0000ff">s∈S</font> ，特殊形式<font color="#0000ff"><b>S</b></font>的行集和步数<font color="#0000ff">n∈N <b>。</b></font> 接下来，我们详细考虑每个备件。 我们从集合<font color="#0000ff"><b>S</b></font>及其元素开始。 <br><br> 为了指定集合<font color="#0000ff"><b>S，</b></font>有必要确定将写入该集合的元素的语法。 集<font color="#0000ff"><b>S的</b></font>元素称为字符串。  <font color="#0000ff"><b>S中的</b></font>任何行都由括号“（”，“）”的层次结构组成，并且任意字符标识符都写在括号内。 为了避免使用术语“标识符”，由于可能出于其他目的而需要使用它，因此括号内的符号标识符将称为“助记符”。 每个助记符都用拉丁字符“ A-z”编写。 括号内的助记符可以用逗号“，”分隔。 如果助记符的长度是固定的（单独指定），则不会设置分隔符。 助记符仅写在括号内。 一行可能包含嵌套的括号。 字符串中括号的层次结构是任意的，但每个开头括号必须有一个结尾括号。 在本文中，我将仅使用拉丁字母的小写字母来编写助记符，并且助记符的长度将是固定的，一个字母对应一个助记符，我不放置分隔符。 线路示例： <br><br>  <font color="#0000ff">（）∅</font>是一个空字符串。 <br>  <font color="#0000ff">（a）</font> -包含一个助记符“ <font color="#0000ff">a</font> ”的字符串。 <br>  <font color="#0000ff">（aa）</font> -包含助记符“ <font color="#0000ff">a</font> ”的两个实例的字符串。 <br>  <font color="#0000ff">（ab）</font>是包含两个助记符“ <font color="#0000ff">a</font> ”和“ <font color="#0000ff">b</font> ”的字符串。 <br>  <font color="#0000ff">（（a）（a））</font> -该行包含助记符“ <font color="#0000ff">a</font> ”的两个副本和括号的嵌套级别。 <br><br> 在需要适当概括的情况下，有时将括号括起来的括号及其内容以及个别的助记符称为“字符串组件”。 例如，行<font color="#0000ff">（（a）ab）</font>包含四个成分，其中：两个成分“ <font color="#0000ff">a</font> ”，一个成分“ <font color="#0000ff">（a）</font> ”和一个成分“ <font color="#0000ff">b</font> ”。 <br><br> 与字符串中各组成部分的重新排列相匹配的字符串记录被视为相同。 相同行的示例： <br><br>  <font color="#0000ff">（ab）≡（ba）</font> 。 <br>  <font color="#0000ff">（（a）（b））≡（（b）（a））</font> 。 <br>  <font color="#0000ff">（abc）≡（bac）≡（cba）≡（acb）≡（bca）≡（cab）</font> 。 <br>  <font color="#0000ff">（（a）（ab））≡（（a）（ba））≡（（ab）（a））≡（（ba）（a））</font> 。 <br><br> 行可以包含任意数量的相同的重复组件，在这种情况下，使用重复索引可以缩短记录的时间，该索引位于左边组件的前面，而没有分隔符。 范例： <br><br>  <font color="#0000ff">（aa）≡（2a）</font> 。 <br>  <font color="#0000ff">（aabb）≡（2a2b）</font> 。 <br>  <font color="#0000ff">（（a）（a））≡（2（a））</font> 。 <br>  <font color="#0000ff">（（aa）（aa））≡（2（2a））</font> 。 <br>  <font color="#0000ff">（aa（bb）（bb）（ccc）（ccc）（ccc））≡（2a2（2b）3（3c））</font> 。 <br><br> 在字符串包含空成分的情况下，例如<font color="#0000ff">（a（））</font> ， <font color="#0000ff">（a（）（）（b）），</font>标识保持： <font color="#0000ff">（a（））≡（a）</font> ， <font color="#0000ff">（a（）（）（b ））≡（a（b））</font> ，即将空的组件丢弃。 <br><br>  <b>定义</b> 集<font color="#0000ff"><b>S</b></font>由满足以上语法标准的所有可能的字符串组成，包括一个空字符串。 <br><br> 推导，抽象和组合运算符在集合<font color="#0000ff"><b>S</b></font>上定义<font color="#0000ff"><b>。</b></font> 运算符自变量用方括号<font color="#0000ff">[]表示</font> ，因为括号保留给字符串语法使用。 术语“操作者”与术语“功能”同义。 <br><br>  <b>演算者</b> 。 定义  <font color="#0000ff">∀s∈S， <b>推导</b> <sup>k</sup> [s]∈S，k∈N，k&gt; 1， <b>推导</b> [s]≝ <b>推导</b> <sup>2</sup> [s]</font> 。 将<font color="#0000ff"><b>S中</b></font>的字符串<font color="#0000ff">s</font>作为参数。 结果，从<font color="#0000ff"><b>S</b></font>返回一个字符串<font color="#0000ff"><b>。</b></font> 行动 运算符<font color="#0000ff">k</font>次复制字符串的每个部分和整个字符串。 最终的结构由通用的外部支架框住。 复制从嵌套最深的组件开始。 整个行最后重复。 出于即时实际目的， <font color="#0000ff">k = 2</font>就足够了，因此我定义了一种特殊情况，即<font color="#0000ff"><b>推导</b> [s]≝ <b>推导</b> <sup>2</sup> [s]</font> 。 使用<font color="#0000ff"><b>deduction</b> []</font>意味着<font color="#0000ff">k = 2</font> ，也就是说，作为<font color="#0000ff"><b>deduction</b> [s]</font>运算符的结果，字符串<font color="#0000ff">s的</font>所有分量<font color="#0000ff">都</font>加倍了。 范例： <br><br>  <font color="#0000ff"><b>推导</b> [（a）] =（（aa）（aa））。</font> <font color="#0000ff"><br></font>  <font color="#0000ff"><b>扣减</b> [（aa）] =（（aaaa）（aaaa））</font> <font color="#0000ff"><br></font>  <font color="#0000ff"><b>推导</b> [（ab）] =（（aabb）（aabb））。</font> <font color="#0000ff"><br></font>  <font color="#0000ff"><b>推导</b> [（a（b））] =（（aa（bb）（bb））（aa（bb）（bb）））。</font> <font color="#0000ff"><br></font>  <font color="#0000ff"><b>推导</b> [[（（a）（b））] =（（（（aa）（aa）（bb）（bb））（（aa）（aa）（bb）（bb）））。</font> <font color="#0000ff"><br></font>  <font color="#0000ff"><b>扣减</b> [[（（a）（b（cc）））] =（（（（aa）（aa）（bb（cccc）（cccc））（bb（cccc）（cccc））））（（aa）（aa）（ bb（cccc）（cccc））（bb（cccc）（cccc））））</font> 。 <br><br>  <b>抽象运算符</b> 。 定义  <font color="#0000ff">∀s∈S， <b>抽象</b> [s]⊂S <b>。</b></font> 将<font color="#0000ff"><b>S中</b></font>的字符串<font color="#0000ff">s</font>作为参数。 结果，它返回许多行。 行动原则。 抽象运算符使用特殊操作-相同组件的括号从源代码行创建许多行。 包围操作仅适用于处于相同嵌套级别的嵌套括号。 包围的一般原则。 如果位于同一级别的括号的任何组合中，相同的组件位于括号内，则可以将任何一组相同的组件放在括号之外，并且保持完整的组件应在同一级别的相同通用括号下进行组合。 考虑一个例子。 字符串<font color="#0000ff">（（ab）（ac））</font> 。 在此行上，有两个处于相同级别的子字符串： <font color="#0000ff">（ab）</font>和<font color="#0000ff">（ac）</font> ，其中有相同的助记符“ <font color="#0000ff">a</font> ”，该助记符可以放在方括号中，结果为<font color="#0000ff">（a（bc））</font> 。 如您所见，其余的助记符“ <font color="#0000ff">b</font> ”和“ <font color="#0000ff">c</font> ”被合并在共同的括号中。 考虑一个不太明显的例子。 字符串<font color="#0000ff">（（aa）（aa））</font>包含子字符串<font color="#0000ff">（aa）</font>和<font color="#0000ff">（aa）</font> ，在这种情况下，有两个不同的选项可以放在括号中。 在第一个变体中，只能从每个子字符串的括号中取出一个助记符“ <font color="#0000ff">a</font> ”，在第二个变体中，可以取出一组助记符“ <font color="#0000ff">aa</font> ”。 让我们更详细地考虑这两个选项。 <br><br> 第一种选择，逐步演示： <br><br><ol><li> 第一步，选择（ <font color="#ff0000">红色</font> ）取出<font color="#0000ff">（（ <font color="#ff0000">a</font> a）（ <font color="#ff0000">a</font> a））</font> 。 </li><li> 第二步，选择<font color="#0000ff">（ <font color="#ff0000">a</font> （... a）（... a））</font> 。 </li><li> 第三步，将余数合并在公共括号<font color="#0000ff">（ <font color="#ff0000">a</font> （... a ... a））中</font> 。 </li><li> 结果<font color="#0000ff">（a（aa））</font> 。 </li></ol><br> 第二个选项，步骤如下： <br><br><ol><li> 第一步，选择要取出的东西<font color="#0000ff">（（ <font color="#ff0000">aa</font> ）（ <font color="#ff0000">aa</font> ））</font> 。 </li><li> 第二步，选择<font color="#0000ff">（ <font color="#ff0000">aa</font> （...）（...））</font> 。 </li><li> 第三步，将余数合并在公共括号<font color="#0000ff">（ <font color="#ff0000">aa</font> （...））中</font> 。 </li><li> 第四步，丢弃空的组件<font color="#0000ff">（ <font color="#ff0000">aa</font> ）</font> 。 </li><li> 结果<font color="#0000ff">（aa）</font> 。 </li></ol><br> 让我们使这个例子复杂化。 假设给定字符串<font color="#0000ff">（（aa）（aab）（aab））</font> ，它具有三个位于相同级别的子字符串： <font color="#0000ff">（aa）</font> ， <font color="#0000ff">（aab）</font> ， <font color="#0000ff">（aab）</font> ，所有三个子字符串具有相同的内容。 括号规则并不要求我们立即对所有三个子字符串执行操作。 对于放样操作，可以选择任何子串组。 <br><br> 在这种情况下，可以使用三种不同的方式对子字符串进行分组： <br><br><ol><li>  <font color="#0000ff">（aa），（aab）</font> 。 </li><li>  <font color="#0000ff">（aab），（aab）</font> 。 </li><li>  <font color="#0000ff">（aa），（aab），（aab）</font> 。 </li></ol><br> 我们将逐步为每个分组选项执行所有可能的声明。 <br><br> 分组<font color="#0000ff">（aa）</font> ， <font color="#0000ff">（aab）</font> 。 字符串<font color="#0000ff">（（aa）（aab）（aab））</font> 。 <br><br> 第一种选择： <br><br><ol><li> 选择内容<font color="#0000ff">（（ <font color="#ff0000">a</font> a）（ <font color="#ff0000">a</font> ab）（aab））</font> 。 </li><li> 我们取出<font color="#0000ff">（ <font color="#ff0000">a</font> （... a）（... ab）（aab））</font> 。 </li><li> 合并<font color="#0000ff">（ <font color="#ff0000">a</font> （... a ... ab）（aab））</font> 。 </li><li> 结果1 <font color="#0000ff">（a（aab）（aab））</font> 。 </li></ol><br> 第二种选择： <br><br><ol><li> 选择内容<font color="#0000ff">（（ <font color="#ff0000">aa</font> ）（ <font color="#ff0000">aa</font> b）（aab））</font> 。 </li><li> 我们取出<font color="#0000ff">（ <font color="#ff0000">aa</font> （...）（... b）（aab））</font> 。 </li><li> 合并<font color="#0000ff">（ <font color="#ff0000">aa</font> （... b）（aab））</font> 。 </li><li> 结果2 <font color="#0000ff">（a（b）（aab））</font> 。 </li></ol><br> 分组<font color="#0000ff">（aab）</font> ， <font color="#0000ff">（aab）</font> 。 字符串<font color="#0000ff">（（aa）（aab）（aab））</font> 。 <br><br> 第一种选择： <br><br><ol><li> 选择内容<font color="#0000ff">（（aa）（ <font color="#ff0000">a</font> ab）（ <font color="#ff0000">a</font> ab））</font> 。 </li><li> 我们取出<font color="#0000ff">（（aa） <font color="#ff0000">a</font> （... ab）（... ab））</font> 。 </li><li> 合并<font color="#0000ff">（（aa） <font color="#ff0000">a</font> （... ab ... ab））</font> 。 </li><li> 结果3 <font color="#0000ff">（a（aa）（aabb））</font> 。 </li></ol><br> 第二种选择： <br><br><ol><li> 选择内容<font color="#0000ff">（（aa）（ <font color="#ff0000">aa</font> b）（ <font color="#ff0000">aa</font> b））</font> 。 </li><li> 我们取出<font color="#0000ff">（（aa） <font color="#ff0000">aa</font> （... b）（... b））</font> 。 </li><li> 合并<font color="#0000ff">（（aa） <font color="#ff0000">aa</font> （... b ... b））</font> 。 </li><li> 结果4 <font color="#0000ff">（aa（aa）（bb））</font> 。 </li></ol><br> 第三种选择： <br><br><ol><li> 选择内容<font color="#0000ff">（（aa）（a <font color="#ff0000">ab</font> ）（a <font color="#ff0000">ab</font> ））</font> 。 </li><li> 我们取出<font color="#0000ff">（（aa） <font color="#ff0000">ab</font> （... a）（... a））</font> 。 </li><li> 合并<font color="#0000ff">（（aa） <font color="#ff0000">ab</font> （... a ... a））</font> 。 </li><li> 结果5 <font color="#0000ff">（ab（aa）（aa））</font> 。 </li></ol><br> 第四种选择： <br><br><ol><li> 选择内容<font color="#0000ff">（（aa）（aa <font color="#ff0000">b</font> ）（aa <font color="#ff0000">b</font> ））</font> 。 </li><li> 我们取出<font color="#0000ff">（（aa） <font color="#ff0000">b</font> （... aa）（... aaa））</font> 。 </li><li> 合并<font color="#0000ff">（（aa） <font color="#ff0000">b</font> （... aa ... aa））</font> 。 </li><li> 结果6 <font color="#0000ff">（b（aa）（aaaa））</font> 。 </li></ol><br> 第五种选择： <br><br><ol><li> 选择内容<font color="#0000ff">（（aa）（ <font color="#ff0000">aab</font> ）（ <font color="#ff0000">aab</font> ））</font> 。 </li><li> 我们取出<font color="#0000ff">（（aa） <font color="#ff0000">aab</font> （...）（...））</font> 。 </li><li> 合并<font color="#0000ff">（（aa） <font color="#ff0000">aab</font> （...））</font> 。 </li><li> 结果7 <font color="#0000ff">（aab（aa））</font> 。 </li></ol><br> 分组<font color="#0000ff">（aa）</font> ， <font color="#0000ff">（aab）</font> ， <font color="#0000ff">（aab）</font> 。 字符串<font color="#0000ff">（（aa）（aab）（aab））</font> 。 <br><br> 第一种选择： <br><br><ol><li> 选择内容<font color="#0000ff">（（ <font color="#ff0000">a</font> a）（ <font color="#ff0000">a</font> ab）（ <font color="#ff0000">a</font> ab））</font> 。 </li><li> 我们取出<font color="#0000ff">（ <font color="#ff0000">a</font> （... a）（... ab）（... ab））</font> 。 </li><li> 合并<font color="#0000ff">（ <font color="#ff0000">a</font> （... a ... ab ... ab））</font> 。 </li><li> 结果8 <font color="#0000ff">（a（aaabb））</font> 。 </li></ol><br> 第二种选择： <br><br><ol><li> 选择内容<font color="#0000ff">（（ <font color="#ff0000">aa</font> ）（ <font color="#ff0000">aa</font> b）（ <font color="#ff0000">aa</font> b））</font> 。 </li><li> 我们取出<font color="#0000ff">（ <font color="#ff0000">aa</font> （...）（... b）（... b））</font> 。 </li><li> 合并<font color="#0000ff">（ <font color="#ff0000">aa</font> （... b ... b））</font> 。 </li><li> 结果9 <font color="#0000ff">（aa（bb））</font> 。 </li></ol><br>  <b>抽象运算符的作用</b> 。 从示例中可以看到，对于原始行<font color="#0000ff">（（aa）（aab）（aab）），</font>有9种不同的选项可以将某些内容放在方括号中，并且有9条结果行与这些选项相对应。 这就是抽象运算符的操作方式-遍历所有可能的选项以放入括号并构建相应的结果行集。 此外，抽象运算符不仅在源代码行中寻找选项，而且还在所有结果行中寻找选项。 换句话说，将抽象运算符递归应用于其结果，依此类推，直到用尽所有可能的选项。 出于明显的原因，对于任何最后一行，可能的删除选项的数量也是有限的。 <br><br> 让我们回到前面的示例。 在所考虑的示例中，我没有写出所有可能的选项，而只写了第一级的九个选项。 为了说明抽象运算符的全部效果，有必要为所有九个先前获得的结果构造所有用于括号的选项。 我们将以更简洁的方式列出所有选项。 <br><br> 结果1 <font color="#0000ff">（a（aab）（aab））</font> ： <br><br>  1.1。  <font color="#0000ff">（a（ab）（ <font color="#ff0000">a</font> ab））=&gt;（a <font color="#ff0000">a</font> （aabb））</font> 。 <br>  1.2。  <font color="#0000ff">（a（ <font color="#ff0000">aa</font> b）（ <font color="#ff0000">aa</font> b））=&gt;（ <font color="#ff0000">aa a</font> （bb））</font> 。 <br>  1.3。  <font color="#0000ff">（a（a <font color="#ff0000">ab</font> ）（a <font color="#ff0000">ab</font> ））=&gt;（a <font color="#ff0000">ab</font> （aa））</font> 。  * 7号 <br>  1.4。  <font color="#0000ff">（a（ <font color="#ff0000">aab</font> ）（ <font color="#ff0000">aab</font> ））=&gt;（a <font color="#ff0000">aab</font> ）</font> 。 <br>  1.5。  <font color="#0000ff">（a（aa <font color="#ff0000">b</font> ）（aa <font color="#ff0000">b</font> ））=&gt;（a <font color="#ff0000">b</font> （aaaa））</font> 。 <br> 结果2 <font color="#0000ff">（a（b）（aab））</font> ： <br>  2.1。  <font color="#0000ff">（a（ <font color="#ff0000">b</font> ）（aa <font color="#ff0000">b</font> ））=&gt;（a <font color="#ff0000">b</font> （aa））</font> 。 <br> 结果3 <font color="#0000ff">（a（aa）（aabb））</font> ： <br>  3.1。  <font color="#0000ff">（a（ <font color="#ff0000">a</font> a）（abb））=&gt;（a <font color="#ff0000">a</font> （aabb））</font> 。  * 1.1号 <br>  3.2。  <font color="#0000ff">（a（ <font color="#ff0000">aa</font> ）（ <font color="#ff0000">aa</font> bb））=&gt;（ <font color="#ff0000">aa</font> （bb））</font>  *第1.2号 <br> 结果4 <font color="#0000ff">（aa（aa）（bb））</font> 。 <br> 结果5 <font color="#0000ff">（ab（aa）（aa））</font> ： <br>  5.1。  <font color="#0000ff">（ab（ <font color="#ff0000">a</font> a）（ <font color="#ff0000">a</font> a））=&gt;（ <font color="#ff0000">a</font> a b（aa））</font> 。  * 7号* 1.3号 <br>  5.2。  <font color="#0000ff">（ab（ <font color="#ff0000">aa</font> ）（ <font color="#ff0000">aa</font> ））=&gt;（ <font color="#ff0000">aa</font> ab）</font> 。  *第1.4号 <br> 结果6 <font color="#0000ff">（b（aa）（aaaa））</font> ： <br>  6.1。  <font color="#0000ff">（b（ <font color="#ff0000">a</font> a）（aaaa））=&gt;（ <font color="#ff0000">a</font> b（aaaa））</font> 。  * 1.5 <br>  6.2。  <font color="#0000ff">（b（ <font color="#ff0000">aa</font> ）（ <font color="#ff0000">aa</font> aa））=&gt;（ <font color="#ff0000">aa</font> b（aa））</font> 。  * 7号* 1.3号* 5.1号 <br> 结果7 <font color="#0000ff">（aab（aa））</font> 。 <br> 结果8 <font color="#0000ff">（a（aaabb））</font> 。 <br> 结果9 <font color="#0000ff">（aa（bb））</font> 。 <br><br> 星号表示重复的选项。 抽象结果中仅包含唯一的变体。 在解析的示例中，有十四个唯一的结果行。 总计： <br><br>  <font color="#0000ff"><b>抽象</b> [[（（aa）（aab）（aab））] =</font> <font color="#0000ff"><br></font>  <font color="#0000ff">{</font> <font color="#0000ff"><br></font>  <font color="#0000ff">（a（aab）（aab）），（aa（aabb）），（aaa（bb）），（aaab），（a（b）（aab）），（ab（aa）），（a（aa） （aabb）），（aa（aa）（bb）），（ab（aa）（aa）），（b（aa）（aaaa）），（ab（aaaa）），（aab（aa）），（ a（aaabb）），（aa（bb））</font> <font color="#0000ff"><br></font>  <font color="#0000ff">}</font> <br><br> 为了清楚起见，请考虑另外两个示例。 <br><br> 字符串<font color="#0000ff">（（a（b））（a（b）））</font> 。 括号选项。 第一次迭代： <br><br>  <font color="#0000ff">（（（ <font color="#ff0000">a</font> （b））（ <font color="#ff0000">a</font> （b））））=&gt;（ <font color="#ff0000">a</font> （（b）（b）））</font> ，结果1 <br>  <font color="#0000ff">（（a <font color="#ff0000">（b）</font> ）（a <font color="#ff0000">（b）</font> ））=&gt;（ <font color="#ff0000">（b）</font> （aa））</font> ，结果2 <br>  <font color="#0000ff">（（（ <font color="#ff0000">a（b）</font> ）（ <font color="#ff0000">a（b）</font> ））=&gt;（ <font color="#ff0000">a（b）</font> ）</font> ，结果3 <br> 在第一个结果中，可以做出另一个决定。 第二次迭代： <br>  <font color="#0000ff">（a（（ <font color="#ff0000">b</font> ）（ <font color="#ff0000">b</font> ）））=&gt;（a（ <font color="#ff0000">b</font> ））</font> ，结果1.2与结果3一致。 <br><br> 总计： <font color="#0000ff"><b>抽象</b> [[（（a（b））（a（b）））] = {（a（（b）（b））），（（b）（aa）），（a（b））}</font> <br><br><div class="spoiler">  <b class="spoiler_title">很好的例子：</b> <div class="spoiler_text">  <font color="#0000ff"><b>抽象</b> [ <b>推论</b> [（a（b））]] = <b>抽象</b> [（（aa（bb）（bb））（aa（bb）（bb）））] =&gt;</font> <br>  1. <font color="#0000ff">（（（aa（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b））（aa（bb）（bb））））=&gt;（（（aa <font color="#ff0000">b</font> （b））（aa（bb）（bb））））</font> 。 <br>  1.1。  <font color="#0000ff">（（（ <font color="#ff0000">a</font> a b（b））（ <font color="#ff0000">a</font> a（bb）（bb））））=&gt;（ <font color="#ff0000">a</font> （aab（b）（bb）（bb））））</font> 。 <br>  1.1.1。  <font color="#0000ff">（a（aab（ <font color="#ff0000">b</font> ）（ <font color="#ff0000">b</font> b）（bb））））=&gt;（a（aab <font color="#ff0000">b</font> （b）（bb））））</font> 。 <br>  1.1.1.1。  <font color="#0000ff">（a（aabb（ <font color="#ff0000">b</font> ）（ <font color="#ff0000">b</font> b））））=&gt;（a（aabb <font color="#ff0000">b</font> （b））））</font> 。 <br>  1.1.2。  <font color="#0000ff">（a（aab（ <font color="#ff0000">b</font> ）（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b））））=&gt;（a（aab <font color="#ff0000">b</font> （bb）））</font> 。 <br>  1.1.3。  <font color="#0000ff">（a（aab（b）（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b））））=&gt;（a（aab <font color="#ff0000">b</font> （b）（bb）））</font> 。 <br>  1.1.3.1。  <font color="#0000ff">（a（aabb（ <font color="#ff0000">b</font> ）（ <font color="#ff0000">b</font> b））））=&gt;（a（aabb <font color="#ff0000">b</font> （b））））</font> 。 <br>  1.1.4。  <font color="#0000ff">（a（aab（b）（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ））））=&gt;（a（aab <font color="#ff0000">bb</font> （b）））</font> 。 <br>  1.2。  <font color="#0000ff">（（（ <font color="#ff0000">aa</font> b（b））（ <font color="#ff0000">aa</font> （bb）（bb）））=&gt;（ <font color="#ff0000">aa</font> （b（b）（bb）（bb））））</font> 。 <br>  1.2.1。  <font color="#0000ff">（aa（b（ <font color="#ff0000">b</font> ）（ <font color="#ff0000">b</font> b）（bb））））=&gt;（aa（b <font color="#ff0000">b</font> （b）（bb））））</font> 。 <br>  1.2.1.1。  <font color="#0000ff">（aa（bb（ <font color="#ff0000">b</font> ）（ <font color="#ff0000">b</font> b））））=&gt;（aa（bb <font color="#ff0000">b</font> （b））））</font> 。 <br>  1.2.2。  <font color="#0000ff">（aa（b（ <font color="#ff0000">b</font> ）（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b）））=&gt;（aa（b <font color="#ff0000">b</font> （bb）））</font> 。 <br>  1.2.3。  <font color="#0000ff">（aa（b（b）（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b））））=&gt;（aa（b <font color="#ff0000">b</font> （b）（bb）））</font> 。 <br>  1.2.3.1。  <font color="#0000ff">（aa（bb（ <font color="#ff0000">b</font> ）（ <font color="#ff0000">b</font> b））））=&gt;（aa（bb <font color="#ff0000">b</font> （b））））</font> 。 <br>  1.2.4。  <font color="#0000ff">（aa（b（b）（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ））））=&gt;（aa（b <font color="#ff0000">bb</font> （b）））</font> 。 <br>  1.3。  <font color="#0000ff">（（（aab（b））（aa（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b））））=&gt;（（（aab（b））（aa <font color="#ff0000">b</font> （bb））））</font> 。 <br>  1.3.1。  <font color="#0000ff">（（（ <font color="#ff0000">a</font> a b（b））（ <font color="#ff0000">a</font> a b（bb）））=&gt;（ <font color="#ff0000">a</font> （aabb（b）（bb））））</font> 。 <br>  1.3.1.1。  <font color="#0000ff">（a（aabb（ <font color="#ff0000">b</font> ）（ <font color="#ff0000">b</font> b））））=&gt;（a（aabb <font color="#ff0000">b</font> （b））））</font> 。 <br>  1.3.2。  <font color="#0000ff">（（（ <font color="#ff0000">aa</font> b（b））（ <font color="#ff0000">aa</font> b（bb）））=&gt;（ <font color="#ff0000">aa</font> （bb（b）（bb））））</font> 。 <br>  1.3.2.1。  <font color="#0000ff">（aa（bb（ <font color="#ff0000">b</font> ）（ <font color="#ff0000">b</font> b））））=&gt;（aa（bb <font color="#ff0000">b</font> （b））））</font> 。 <br>  1.3.3。  <font color="#0000ff">（（（ <font color="#ff0000">aab</font> （b））（ <font color="#ff0000">aab</font> （bb）））=&gt;（ <font color="#ff0000">aab</font> （（b）（bb）））</font> 。 <br>  1.3.3.1。  <font color="#0000ff">（aab（（ <font color="#ff0000">b</font> ）（ <font color="#ff0000">b</font> b））））=&gt;（aab（ <font color="#ff0000">b</font> （b））））</font> 。 <br>  1.3.4。  <font color="#0000ff">（（（a <font color="#ff0000">a b</font> （b））（a <font color="#ff0000">ab</font> （bb））））=&gt;（ <font color="#ff0000">ab</font> （aa（b）（bb）））</font> 。 <br>  1.3.4.1。  <font color="#0000ff">（ab（aa（aa（ <font color="#ff0000">b</font> ）（ <font color="#ff0000">b</font> b）））））=&gt;（ab（aa <font color="#ff0000">b</font> （b））））</font> 。 <br>  1.3.5。  <font color="#0000ff">（（aa <font color="#ff0000">b</font> （b））（aa <font color="#ff0000">b</font> （bb）））=&gt;（ <font color="#ff0000">b</font> （aaaa（b）（bb）））</font> 。 <br>  1.3.5.1。  <font color="#0000ff">（b（aaaa（ <font color="#ff0000">b</font> ）（ <font color="#ff0000">b</font> b））））=&gt;（b（aaaa <font color="#ff0000">b</font> （b）））</font> 。 <br>  1.4。  <font color="#0000ff">（（（aab（b））（aa（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ））））=&gt;（（（aab（b））（aa <font color="#ff0000">bb</font> ））</font> 。 <br>  1.4.1。  <font color="#0000ff">（（ <font color="#ff0000">a</font> a b（b））（ <font color="#ff0000">a</font> abb））=&gt;（ <font color="#ff0000">a</font> （aabbb（b）））</font> 。 <br>  1.4.2。  <font color="#0000ff">（（（ <font color="#ff0000">aa</font> b（b））（ <font color="#ff0000">aa</font> bb））=&gt;（ <font color="#ff0000">aa</font> （bbb（b）））</font> 。 <br>  1.4.3。  <font color="#0000ff">（（（ <font color="#ff0000">aab</font> （b））（ <font color="#ff0000">aab</font> b））=&gt;（ <font color="#ff0000">aab</font> （b（b）））</font> 。 <br>  1.4.4。  <font color="#0000ff">（（（a <font color="#ff0000">a b</font> （b））（a <font color="#ff0000">ab</font> b）））=&gt;（ <font color="#ff0000">ab</font> （aab（b）））</font> 。 <br>  1.4.5。  <font color="#0000ff">（（aa <font color="#ff0000">b</font> （b））（aa <font color="#ff0000">b</font> b））=&gt;（ <font color="#ff0000">b</font> （aaaab（b）））</font> 。 <br>  2. <font color="#0000ff">（（（aa（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ）））（aa（bb）（bb）））=&gt;（（（aa <font color="#ff0000">bb</font> ）（aa（bb）（bb））））</font> 。 <br>  2.1。  <font color="#0000ff">（（aabb）（aa（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b））））=&gt;（（aabb）（aa <font color="#ff0000">b</font> （bb）））</font> 。 <br>  2.1.1。  <font color="#0000ff">（（ <font color="#ff0000">a</font> abb）（ <font color="#ff0000">a</font> ab（bb）））=&gt;（ <font color="#ff0000">a</font> （aabbb（bb）））</font> 。 <br>  2.1.2。  <font color="#0000ff">（（（ <font color="#ff0000">aa</font> bb）（ <font color="#ff0000">aa</font> b（bb）））=&gt;（ <font color="#ff0000">aa</font> （bbb（bb））））</font> 。 <br>  2.1.3。  <font color="#0000ff">（（（ <font color="#ff0000">aab</font> b）（ <font color="#ff0000">aab</font> （bb）））=&gt;（ <font color="#ff0000">aab</font> （b（bb））））</font> 。 <br>  2.1.4。  <font color="#0000ff">（（（a <font color="#ff0000">ab</font> b）（a <font color="#ff0000">ab</font> （bb））））=&gt;（ <font color="#ff0000">ab</font> （aab（bb）））</font> 。 <br>  2.1.5。  <font color="#0000ff">（（aa <font color="#ff0000">b</font> b）（aa <font color="#ff0000">b</font> （bb）））=&gt;（ <font color="#ff0000">b</font> （aaaab（bb）））</font> 。 <br>  2.2。  <font color="#0000ff">（（aabb）（aa（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ））））=&gt;（（（aabb）（aa <font color="#ff0000">bb</font> ））</font> 。 <br>  2.2.1。  <font color="#0000ff">（（ <font color="#ff0000">一个</font> abb）（ <font color="#ff0000">a</font> abb））=&gt;（ <font color="#ff0000">一个</font> （aabbbb））</font> 。 <br>  2.2.2。  <font color="#0000ff">（（（ <font color="#ff0000">aa</font> bb）（ <font color="#ff0000">aa</font> bb））=&gt;（ <font color="#ff0000">aa</font> （bbbb））</font> 。 <br>  2.2.3。  <font color="#0000ff">（（（ <font color="#ff0000">aab</font> b）（ <font color="#ff0000">aab</font> b））=&gt;（ <font color="#ff0000">aab</font> （bb））</font> 。 <br>  2.2.4。  <font color="#0000ff">（（a <font color="#ff0000">abb</font> ）（a <font color="#ff0000">abb</font> ））=&gt;（ <font color="#ff0000">abb</font> （aa））</font> 。 <br>  2.2.5。  <font color="#0000ff">（（ <font color="#ff0000">aabb</font> ）（ <font color="#ff0000">aabb</font> ））=&gt;（ <font color="#ff0000">aabb</font> ）</font> 。 <br>  2.2.6。  <font color="#0000ff">（（（a <font color="#ff0000">ab</font> b）（a <font color="#ff0000">ab</font> b））=&gt;（ <font color="#ff0000">ab</font> （aabb））</font> 。 <br>  2.2.7。  <font color="#0000ff">（（aa <font color="#ff0000">b</font> b）（aa <font color="#ff0000">b</font> b））=&gt;（ <font color="#ff0000">b</font> （aaaabb））</font> 。 <br>  2.2.8。  <font color="#0000ff">（（（aa <font color="#ff0000">bb</font> ）（aa <font color="#ff0000">bb</font> ））=&gt;（ <font color="#ff0000">bb</font> （aaaa））</font> 。 <br>  2.3。  <font color="#0000ff">（（（ <font color="#ff0000">一个</font> abb）（ <font color="#ff0000">一个</font> a（bb）（bb））））=&gt;（（ <font color="#ff0000">一个</font> （aabb（bb）（bb））））</font> 。 <br>  2.3.1。  <font color="#0000ff">（a（aabb（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b））））=&gt;（a（aabb <font color="#ff0000">b</font> （bb））））</font> 。 <br>  2.3.2。  <font color="#0000ff">（a（aabb（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ））））=&gt;（a（aabb <font color="#ff0000">bb</font> ））</font> 。 <br>  2.4。  <font color="#0000ff">（（（ <font color="#ff0000">aa</font> bb）（ <font color="#ff0000">aa</font> （bb）（bb）））=&gt;（ <font color="#ff0000">aa</font> （bb（bb）（bb））））</font> 。 <br>  2.4.1。  <font color="#0000ff">（aa（bb（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b））））=&gt;（aa（bb <font color="#ff0000">b</font> （bb））））</font> 。 <br>  2.4.2。  <font color="#0000ff">（aa（bb（bb（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ））））=&gt;（aa（bb <font color="#ff0000">bb</font> ））</font> 。 <br>  3. <font color="#0000ff">（（ <font color="#ff0000">a</font> a（bb）（bb））（ <font color="#ff0000">a</font> a（bb）（bb）））=&gt;（ <font color="#ff0000">a</font> （aa（bb）（bb）（bb）（bb）））</font> 。 <br>  3.1。  <font color="#0000ff">（a（aa（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b）（bb）（bb））））=&gt;（a（aa <font color="#ff0000">b</font> （bb）（bb）（bb））））</font> 。 <br>  3.1.1。  <font color="#0000ff">（a（aab（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b）（bb））））=&gt;（a（aab <font color="#ff0000">b</font> （bb）（bb））））</font> 。 <br>  3.1.1.1。  <font color="#0000ff">（a（aabb（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b））））=&gt;（a（aabb <font color="#ff0000">b</font> （bb））））</font> 。 <br>  3.1.1.2。  <font color="#0000ff">（a（aabb（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ））））=&gt;（a（aabb <font color="#ff0000">bb</font> ））</font> 。 <br>  3.1.2。  <font color="#0000ff">（a（aab（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b））））=&gt;（a（aab <font color="#ff0000">b</font> （bbb）））</font> 。 <br>  3.1.3。  <font color="#0000ff">（a（aab（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ）（bb））））=&gt;（a（aab <font color="#ff0000">bb</font> （bb））））</font> 。 <br>  3.1.4。  <font color="#0000ff">（a（aab（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ））））=&gt;（a（aab <font color="#ff0000">bb</font> ））</font> 。 <br>  3.2。  <font color="#0000ff">（a（aa（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ）（bb）（bb））））=&gt;（a（aa <font color="#ff0000">bb</font> （bb）（bb））））</font> 。 <br>  3.2.1。  <font color="#0000ff">（a（aabb（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b））））=&gt;（a（aabb <font color="#ff0000">b</font> （bb））））</font> 。 <br>  3.2.2。  <font color="#0000ff">（a（aabb（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ））））=&gt;（a（aabb <font color="#ff0000">bb</font> ））</font> 。 <br>  3.3。  <font color="#0000ff">（a（aa（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b）（bb）））=&gt;（a（aa <font color="#ff0000">b</font> （bbb）（bb））））</font> 。 <br>  3.3.1。  <font color="#0000ff">（a（aab（ <font color="#ff0000">b</font> bb）（ <font color="#ff0000">b</font> b））））=&gt;（a（aab <font color="#ff0000">b</font> （bbb））））</font> 。 <br>  3.3.2。  <font color="#0000ff">（a（aab（ <font color="#ff0000">bb</font> b）（ <font color="#ff0000">bb</font> ））））=&gt;（a（aab <font color="#ff0000">bb</font> （b））））</font> 。 <br>  3.4。  <font color="#0000ff">（a（aa（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b））））（（a（aa <font color="#ff0000">b</font> （bbbb））））</font> 。 <br>  3.5。  <font color="#0000ff">（a（aa（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ）（bb））））=&gt;（a（aa <font color="#ff0000">bb</font> （bb））））</font> 。 <br>  3.6。  <font color="#0000ff">（a（aa（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ））））=&gt;（a（aa <font color="#ff0000">bb</font> ））</font> 。 <br>  4. <font color="#0000ff">（（（ <font color="#ff0000">aa</font> （bb）（bb））（ <font color="#ff0000">aa</font> （bb）（bb）））&gt;&gt;（ <font color="#ff0000">aa</font> （（bb）（bb）（bb）（bb）））</font> 。 <br>  4.1。  <font color="#0000ff">（aa（（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b）（bb）（bb）））=&gt;（aa（ <font color="#ff0000">b</font> （bb）（bb）（bb）））</font> 。 <br>  4.1.1。  <font color="#0000ff">（aa（b（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b）（bb））））=&gt;（aa（b <font color="#ff0000">b</font> （bb）（bb））））</font> 。 <br>  4.1.1.1。  <font color="#0000ff">（aa（bb（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b））））=&gt;（aa（bb <font color="#ff0000">b</font> （bb））））</font> 。 <br>  4.1.1.2。  <font color="#0000ff">（aa（bb（bb（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ））））=&gt;（aa（bb <font color="#ff0000">bb</font> ））</font> 。 <br>  4.1.2。  <font color="#0000ff">（aa（b（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b））））=&gt;（aa（b <font color="#ff0000">b</font> （bbb）））</font> 。 <br>  4.1.3。  <font color="#0000ff">（aa（b（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ）（bb）））=&gt;（aa（b <font color="#ff0000">bb</font> （bb））））</font> 。 <br>  4.1.4。  <font color="#0000ff">（aa（b（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ））））=&gt;（aa（b <font color="#ff0000">bb</font> ））</font> 。 <br>  4.2。  <font color="#0000ff">（aa（（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ）（bb）（bb）））=&gt;（aa（ <font color="#ff0000">bb</font> （bb）（bb））））</font> 。 <br>  4.2.1。  <font color="#0000ff">（aa（bb（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b））））=&gt;（aa（bb <font color="#ff0000">b</font> （bb））））</font> 。 <br>  4.2.2。  <font color="#0000ff">（aa（bb（bb（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ））））=&gt;（aa（bb <font color="#ff0000">bb</font> ））</font> 。 <br>  4.3。  <font color="#0000ff">（aa（（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b）（bb）））=&gt;（aa（ <font color="#ff0000">b</font> （bbb）（bb）））</font> 。 <br>  4.3.1。  <font color="#0000ff">（aa（b（ <font color="#ff0000">b</font> bb）（ <font color="#ff0000">b</font> b））））=&gt;（aa（b <font color="#ff0000">b</font> （bbb）））</font> 。 <br>  4.3.2。  <font color="#0000ff">（aa（b（ <font color="#ff0000">bb</font> b）（ <font color="#ff0000">bb</font> ）））=&gt;（aa（b <font color="#ff0000">bb</font> （b）））</font> 。 <br>  4.4。  <font color="#0000ff">（aa（（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b）））&gt;&gt;（aa（ <font color="#ff0000">b</font> （bbbb）））</font> 。 <br>  4.5。  <font color="#0000ff">（aa（（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ）（bb）））=&gt;（aa（ <font color="#ff0000">bb</font> （bb））））</font> 。 <br>  4.6。  <font color="#0000ff">（aa（（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ）））=&gt;（aa（ <font color="#ff0000">bb</font> ））</font> 。 <br>  5. <font color="#0000ff">（（（aa <font color="#ff0000">（bb）</font> （bb））（aa <font color="#ff0000">（bb）</font> （bb））））=&gt;（ <font color="#ff0000">（bb）</font> （aaaa（bb）（bb）））</font> 。 <br>  5.1。  <font color="#0000ff">（（bb）（aaaa（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b））））=&gt;（（bb）（aaaa <font color="#ff0000">b</font> （bb）））</font> 。 <br>  5.1.1。  <font color="#0000ff">（（ <font color="#ff0000">b</font> b）（aaaa <font color="#ff0000">b</font> （bb）））=&gt;（ <font color="#ff0000">b</font> （aaaab（bb）））</font> 。 <br>  5.2。  <font color="#0000ff">（（bb）（aaaa（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ）））=&gt;（（bb）（aaaa <font color="#ff0000">bb</font> ））</font> 。 <br>  5.2.1。  <font color="#0000ff">（（ <font color="#ff0000">b</font> b）（aaaa <font color="#ff0000">b</font> b））=&gt;（ <font color="#ff0000">b</font> （aaaabb））</font> 。 <br>  5.2.2。  <font color="#0000ff">（（ <font color="#ff0000">bb</font> ）（aaaa <font color="#ff0000">bb</font> ））=&gt;（ <font color="#ff0000">bb</font> （aaaa））</font> 。 <br>  6. <font color="#0000ff">（（（aa <font color="#ff0000">（bb）（bb）</font> ）（aa <font color="#ff0000">（bb）（bb）</font> ）））=&gt;（ <font color="#ff0000">（bb）（bb）</font> （aaaa））</font> 。 <br>  6.1。  <font color="#0000ff">（（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b）（aaaa））=&gt;（ <font color="#ff0000">b</font> （bb）（aaaa））</font> 。 <br>  6.2。  <font color="#0000ff">（（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ）（aaaa））=&gt;（ <font color="#ff0000">bb</font> （aaaa））</font> 。 <br>  7. <font color="#0000ff">（（（a <font color="#ff0000">a（bb）</font> （bb））（a <font color="#ff0000">a（bb）</font> （bb））））=&gt;（（ <font color="#ff0000">a（bb）</font> （aa（bb）（bb））））</font> 。 <br>  7.1。  <font color="#0000ff">（a（bb）（aa（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b））））=&gt;（a（bb）（aa <font color="#ff0000">b</font> （bb））））</font> 。 <br>  7.1.1。  <font color="#0000ff">（a（ <font color="#ff0000">b</font> b）（aa <font color="#ff0000">b</font> （bb）））=&gt;（a <font color="#ff0000">b</font> （aab（bb）））</font> 。 <br>  7.2。  <font color="#0000ff">（a（bb）（aa（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ））））=&gt;（a（bb）（aa <font color="#ff0000">bb</font> ））</font> 。 <br>  7.2.1。  <font color="#0000ff">（a（ <font color="#ff0000">b</font> b）（aa <font color="#ff0000">b</font> b））=&gt;（a <font color="#ff0000">b</font> （aabb））</font> 。 <br>  7.2.2。  <font color="#0000ff">（a（ <font color="#ff0000">bb</font> ）（aa <font color="#ff0000">bb</font> ））=&gt;（a <font color="#ff0000">bb</font> （aa））</font> 。 <br>  8. <font color="#0000ff">（（（ <font color="#ff0000">aa（bb）</font> （bb））（ <font color="#ff0000">aa（bb）</font> （bb）））=&gt;（ <font color="#ff0000">aa（bb）</font> （（bb）（bb）））</font> 。 <br>  8.1。  <font color="#0000ff">（aa（bb）（（（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b））））=&gt;（aa（bb）（ <font color="#ff0000">b</font> （bb））））</font> 。 <br>  8.1.1。  <font color="#0000ff">（aa（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> （bb）））=&gt;（aa <font color="#ff0000">b</font> （b（bb）））</font> 。 <br>  8.2。  <font color="#0000ff">（aa（bb）（（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ）））=&gt;（aa（bb）（ <font color="#ff0000">bb</font> ））</font> 。 <br>  8.2.1。  <font color="#0000ff">（aa（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b））=&gt;（aa <font color="#ff0000">b</font> （bb））</font> 。 <br>  8.2.2。  <font color="#0000ff">（aa（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ））=&gt;（aa <font color="#ff0000">bb</font> ）</font> 。 <br>  9. <font color="#0000ff">（（（a <font color="#ff0000">a（bb）（bb）</font> ）（a <font color="#ff0000">a（bb）（bb）</font> ）））=&gt;（ <font color="#ff0000">a（bb）（bb）</font> （aa））</font> 。 <br>  9.1。  <font color="#0000ff">（a（aa）（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b））=&gt;（a <font color="#ff0000">b</font> （aa）（bb））</font> 。 <br>  9.2。  <font color="#0000ff">（a（aa）（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ））=&gt;（a <font color="#ff0000">bb</font> （aa））</font> 。 <br>  10. <font color="#0000ff">（（（ <font color="#ff0000">aa（bb）（bb）</font> ）（ <font color="#ff0000">aa（bb）（bb）</font> ））=&gt;（ <font color="#ff0000">a（bb）（bb）</font> ）</font> 。 <br>  10.1。  <font color="#0000ff">（a（ <font color="#ff0000">b</font> b）（ <font color="#ff0000">b</font> b））=&gt;（a <font color="#ff0000">b</font> （bb））</font> 。 <br>  10.2。  <font color="#0000ff">（a（ <font color="#ff0000">bb</font> ）（ <font color="#ff0000">bb</font> ））=&gt;（a <font color="#ff0000">bb</font> ）</font> 。 <br><br> 从上面的结果行（在箭头的右边）列表中，您需要选择所有唯一的行，并且这组唯一的行将是<font color="#0000ff"><b>抽象</b> [[（（aa（bb）（bb））（aa（bb）（bb））]]的结果）</font> 。 我不会写出唯一的行，因为这不会在解释中添加任何内容。 下面，在考虑算法的优化和实际使用时，我将参考此示例。 </div></div><br><br>  <b>合成运算符</b> 。 定义  <font color="#0000ff">∀U⊂S，U≠∅， <b>成分</b> [U]≠∅， <b>成分</b> [U]∈S <b>。</b></font> 它接受多行输入，并返回一行。 行动 操作员为算法的下一次迭代准备内容。 在抽象运算符的作用之后，出现了许多行，并且在合成阶段，发生了用于算法的下一次迭代的行的选择和连接。 我将在优化和实际使用部分中更详细地讨论此问题。 在最简单的情况下，组合运算符对所有抽象结果执行简单的串联。 所以我们定义它。 示例： <font color="#0000ff"><b>composition</b> [ <b>抽象</b> [（（（a（b））（a（b）））]] = <b>成分</b> [{（a（（b）（b））），（（b）（aa）），（a（ b））}] =（（（a（（b）（b）））（（b）（aa））（a（b）））</font> 。 <br><br><h2> 算法属性 </h2><br> 该算法产生字符串。 由于算法的迭代操作而形成的所有行的集合将被称为“算法输出”或简称为“输出”。 推断的定义。  <font color="#0000ff"><b>T</b> <sup>s</sup> {{ <sub>n</sub> | t <sub>n + 1</sub> = <b>组成</b> [ <b>抽象</b> [ <b>推论</b> [t <sub>n</sub> ]]]]；</font>  <font color="#0000ff">t <sub>0</sub> = s;</font>  <font color="#0000ff">t <sub>n</sub> ，s∈S;</font>  <font color="#0000ff">n∈N}。</font>  <font color="#0000ff"><b>T</b> <sup>s</sup></font>是种子<font color="#0000ff">s</font>的输出。 在那些<font color="#0000ff"><b>T</b></font>没有参数的情况下，我们谈论的是任何种子的结论。 推论性质： <font color="#0000ff">∀s，e∈S，s≠∅，e≠∅，s≠e， <b>T</b> s∩T <sup>e</sup> =∅</font> 。 这意味着每个输出元素唯一地对应于种子。 结果，每个种子的结论都是唯一的。 <br><br>  <b>对演绎和抽象的有意义的解释</b> 。 推导算子的物理含义如下。 从原始行开始，演绎运算符以通用的方式创建一个具有根本上新的更复杂内部属性的根本上新的构造对象。 用直觉上的近似，我们可以说推论从质上增加了新的信息。 反过来，抽象运算符将新对象分解为多个部分，从而以推论性的等效方式表示在推导阶段添加的信息。 您可能会注意到，由于括号中的步骤导致信息丢失。 此外，对于此语法，在没有任何有关字符串值的先验数据的情况下，放在方括号中是有意义地丢失信息的通用方法。 即，从算法的角度来看，在抽象阶段计算出的所有可能的信息丢失选项实际上都是行的值。 因此，在每个步骤中，该算法都会创建一个新的独特的语法启发式算法。 而且，每一次后续的启发式搜索都比上一次更复杂，更实质。 在算法的每次迭代中，都会出现新知识。 <br><br><h2> 实际应用 </h2><br> 该算法本身就是“事物”。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他认为，但这是“外国人”的想法。为了从外星人思维中获得实际利益，您需要与他一起找到一种共同语言。一方面，需要训练外星人，另一方面，要学会了解他，最终建立有意义的交流。通常，与算法交互的范例类似于与“黑匣子”交互的众所周知的原理。此外，为了更大的方便，我将思维算法称为外星人科尔。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑理想情况。假设我们拥有无限的计算能力，并且我们有能力计算Kolya思想的任何迭代次数，而不必担心优化问题。在这种情况下，与Kolya相互作用需要以下成分：</font></font><br><br><ol><li>        . </li><li>        . </li><li>  ,        <font color="#0000ff"><b>S</b></font> . </li><li>  ,   - ,          <font color="#0000ff"><b>S</b></font>       . </li></ol><br>           ,       .  . <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextThought</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S prevThought, S ExternalSignal, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> exposure = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ S t = composition[prevThought, ExternalSignal]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; exposure; i++) t = composition[abstraction[deduction[t]]]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t; } EnvironmentModel e; S s = encode(e.GetState()); S o = ∅; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>) { S o = NextThought(o, s); e.ImpactTool.perform(decode(o)); s = encode(e.GetState()); }</code> </pre> <br>  <b>反馈电路</b> 。 刚开始，Kolya没有任何想法。  Kolya的第一个想法是媒体的编码初始状态。 每次迭代时，外部信号都会注入Kolya的思想中。 之后，Kolya会在曝光时间内进行思考。 思考的结果被解码并发送到工具。 反过来，工具的操作会以某种方式改变环境的状态。 一切再次重复。 随着时间的流逝，科里亚的思维将适应环境，并且他将开始表现出高度组织化，主观动机的行为的迹象。 但是，科里亚的动机仍然未知。 为了了解他的动机，在下一阶段的培训中，有必要进行实验，即有目的地改变环境并研究Kolya对变化的反应。 如果有可能通过某种目标函数来描述Kolya的期望外部行为，那么学习过程可以自动化，例如使用遗传算法。 <br><br>  <b>解码问题</b> 。 有必要对Kolya的思想进行解码，以便为乐器合成信号。 困难在于，正如我在上一节中提到的那样，每一个想法都是一个全新的设计。 也就是说，假设的研究人员永远无法完全理解科里亚思想的内容。 无论研究了多少内容，由Kolya思维产生的部分内容将永远永远是完全晦涩的。 只有一些最高度组织化的思维碎片才能得到有意义的识别，这是与Kolya进行交流时的根本性和不可克服的限制。 但实际上，这种限制不是根本的。 因为，首先，可以无限地说明科里亚思想的有意义的一面，其次，不需要完全理解科里亚。 开发一种通用语言就足够了，您可以用它来解释实际问题。 从技术角度来看，情况如下。 描述介质状态的输入信号以某种语言编码。 单词和语言陈述是<font color="#0000ff"><b>S的</b></font>字符串<font color="#0000ff"><b>。</b></font> 该语言具有自己的词汇，语法和语义。 根据语法标准进行的每一次思维重复的内容将分为几类： <br><br>  1.词汇不明的片段。 <br>  2.未知语法。 <br>  3.未知语义。 <br>  4.语法和语义上正确的片段。 <br><br> 根据出现的方法，所有这些类别的内容都是任意的。 也就是说，即使在语法上正确的片段的情况下，这也是偶然的，并且不知道Kolya赋予它们的含义是什么，因为Kolya的内部含义只能由他自己访问。 先验地，没有标准可以正确地将科里亚的思想与乐器的相应动作联系起来。 在这件事上，仍然只能依靠科里亚自己。 他的行为是随心所欲的，只有他能理解他的动机，因为他思维的组织程度会提高。 在这种情况下，任何回应科里亚思想的合理方案都是可以接受和富有成效的，唯一的问题是各种方案的相对有效性。 基本选项是响应所有语法正确的片段，即使它们的内容是荒谬的。 通常，所有可以转换为原始编码形式的内容都必须进行转换和作出反应。 依此类推，直到科尔“明智地”做出有意义的反应。 当然，具有大量自由度的最具塑性的环境模型将很有用。 该介质将以某种方式成为Kolya的身体。 <br><br>  <b>计算能力有限的问题</b> 。 就计算量而言，该算法很繁琐。 显然，数十次迭代将耗尽地球的全部计算能力。 我们可以希望有量子设备，并且算法可以有一个量子类似物，但是到目前为止，只有一种出路：代替一个极其复杂的思想，同时思考许多小而简单的思想。 为此有几种技术技巧： <br><br>  <b>1.</b>在组合阶段，不必在结果中包含所有许多抽象。 为了使算法保留其基本属性，仅从集合中选择两个独立的结果行就足够了。 独立性标准是抽象结果的分层编号中前几位的非零差。 我们来看一个很好的例子，在扰流器下更高。 所有行均根据<font color="#0000ff">abcd</font>的原则进行编号<font color="#0000ff">。</font>如果<font color="#0000ff">a1≠a2</font> ， <font color="#0000ff">则</font>一对具有索引<font color="#0000ff">a1.b1.c1.d1 ...</font> ， <font color="#0000ff">a2.b2.c2.d2 ...的行将</font>被称为独立行。 这意味着可以将整个抽象结果分成独立的对，并在下一步中为每个对开始其自己的计算分支。 而且，不需要使用所有抽象结果。 在最小的情况下，您只能选择一对线，而舍弃所有其余的线（不可挽回的输掉），所有的思维原理都会保留下来。 给定失去结果的能力，可以组织一个附加的选择阶段，在该阶段中，以某种合理的方式，例如根据统计意义，选择要进行进一步计算的内容。 <br><br>  <b>2.</b>第二个技巧是基于这样的假设，即括号放在行中的位置越深，它们包含的内容就越没有组织性。 因此，从Kolya的内部含义来看，由于包围而导致的“弹出”内容更加有条理和抽象，这意味着可以消除深层次的嵌套。 因此，在下一次迭代时的计算量呈指数下降。 从直观的角度来看，此过程仅允许您近似思考的最抽象部分。 <br><br>  <b>3.</b>由于并行化到许多较小的分支，计算将“沿宽度”增长。 不仅可以在单个计算分支的级别进行选择，而且可以在整个并行分支的数组中进行选择，从而完全限制此宽度。 这可以通过一个固定大小的公用池来完成，从该池中每个分支将为下一次迭代绘制线条，并因此从该分支中​​转储结果。 对于字符串，您可以绝对限制括号嵌套的允许级别。 这种结合的方法将有助于限制和调节计算量的增长。 <br><br><h2> 口译和评论 </h2><br>  <b>证据</b> 。 没有证据，也没有。 任何思维理论都是定义问题。 提出的算法是一种建设性的思维理论。 因此，他是一个公理。 思维算法在思维上是可以识别的。 可以通过首先采用更直观的非构造公理来促进识别，然后找到构造和非构造定义的性质的重合。 <br><br>  <b>思维的非确定性定义</b> 。 思考不是内容的算法产生。 在直觉上理解，非算法现象具有以下特定特征：独立性，自发性，唯一性，自组织性，任意性，主观性，复杂性，根本的不可预测性和不确定性，没有概念上的障碍以及从最广泛的意义上说，根本的新颖性具有内在和持久的可能性。 列出的所有功能都是所描述的思维算法固有的。 尽管算法和非算法属性的组合不直观，乍看之下是矛盾的，但实际上并没有矛盾。 该算法使用定义明确的算法过程来部署内容，但是在部署过程中，内容具有非算法组织。 给定算法的设计细节，内容组织中的非算法属性源于内容本身的内部，非算法属性。 <br><br>  <b>关于算法的其他观点</b> 。 思维算法包括： <br><br>  <b>1.</b>隐喻的建设性实施。 思考本质上是隐喻的。 除了象征性（可能）之外，没有其他含义。 但是，从象征意义上讲，字面意义（算法）是可能的。 <br>  <b>2.</b>绝对混乱的自组织模型。 概念自发性模型。 <br>  <b>3.</b>完全独立的，主观动机的行为模型。 创造力模型。 <br>  <b>4.</b>自组织语言。 <br>  <b>5.</b>用于非构造性，纯粹可能的语义的构造性近似模型。 <br><br>  <b>意识</b> 意识问题也在定义级别得到解决。 意识超出了任何概念上的限制。 根据这一定义，一个人只能毒害或多或少地涉及到意识的复杂故事，每个故事都将反映出意识的一些可能性，但没有一个是真实的。 同时，关于意识的故事具有不同的启发潜能。 在所有的故事中，难度更大的故事更有用。 从算法的角度来看，意识是一种跨算法的，无限复杂（或简单地-复杂）的对象。 意识故事可以使用算法记录。 听起来像这样： <br><br>  <font color="#0000ff">lim <sub>n→∞</sub> [t <sub>n + 1</sub> = <b>组成</b> [ <b>抽象</b> [ <b>推论</b> [t <sub>n</sub> ]]]]；</font>  <font color="#0000ff">t <sub>0</sub> = s;</font>  <font color="#0000ff">t <sub>n</sub> ，s∈S;</font>  <font color="#0000ff">n∈N</font> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN440424/">https://habr.com/ru/post/zh-CN440424/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN440412/index.html">Zimbra协作套件和MS Exchange在同一域上</a></li>
<li><a href="../zh-CN440414/index.html">关于短绒棉，代码质量，一般质量和质量管理</a></li>
<li><a href="../zh-CN440416/index.html">殖民地 第25章</a></li>
<li><a href="../zh-CN440420/index.html">欢迎参加2月21日的Devleads聚会</a></li>
<li><a href="../zh-CN440422/index.html">当您对礼物的质量负责时。 一个区块链实验的历史</a></li>
<li><a href="../zh-CN440426/index.html">一种理解机器思维的新方法</a></li>
<li><a href="../zh-CN440428/index.html">SMAA：增强的亚像素形态平滑</a></li>
<li><a href="../zh-CN440430/index.html">“别作恶”的口号从何而来</a></li>
<li><a href="../zh-CN440432/index.html">关于未来职业的科幻星期五：“真正的女孩”</a></li>
<li><a href="../zh-CN440434/index.html">俄罗斯汽车工业：添加剂技术之路</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>