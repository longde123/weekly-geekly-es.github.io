<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤗 ⏏️ 📢 Aplikasi Web yang ditingkatkan oleh Cyber 🍊 🦌 👆🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Frontend modern telah berjalan jauh sejak jQuery dan halaman HTML biasa. Kami sekarang memiliki assembler, manajer paket, pendekatan komponen, SPA, SS...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aplikasi Web yang ditingkatkan oleh Cyber</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471702/"><p>  Frontend modern telah berjalan jauh sejak jQuery dan halaman HTML biasa.  Kami sekarang memiliki assembler, manajer paket, pendekatan komponen, SPA, SSR dan banyak lagi. </p><br><p>  Tampaknya kita memiliki semua yang dibutuhkan untuk kebahagiaan.  Tetapi industri ini bergerak maju.  Saya ingin memberi tahu Anda tentang kerangka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Svelte yang</a> dikompilasi, dan apa kelebihannya dibandingkan analog. </p><br><p><img src="https://habrastorage.org/webt/es/5w/wc/es5wwct4qctbavihmd23-k8phvu.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gambar oleh Andrew Walpole</a> </p><a name="habracut"></a><br><h2 id="google-trends">  Tren Google </h2><br><p>  Untuk memahami situasi saat ini di front-end, saya menganalisis popularitas kueri di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Google Trends</a> untuk kata kunci Bereaksi, jQuery, Vue, Angular di Rusia selama 5 tahun terakhir. </p><br><p><img src="https://habrastorage.org/webt/hb/7q/6l/hb7q6lfm_j8pjpkepo4_zcl-rto.png"><br>  <em>Tren Google</em> </p><br><p>  Selama 5 tahun terakhir, jumlah kueri yang terkait dengan jQuery telah menurun secara signifikan, memberi jalan bagi kerangka kerja komponen.  Meskipun jQuery telah kehilangan tempat, itu masih merupakan alat pengembangan yang populer. </p><br><p>  Dari grafik ini, kita dapat menyimpulkan bahwa perpustakaan komponen memenangkan ujung depan, dan Bereaksi adalah pemimpin di Rusia. </p><br><h2 id="rynok-truda">  Pasar tenaga kerja </h2><br><p>  Kami menulis kode tidak hanya untuk diri kami sendiri, tetapi juga untuk uang.  Sebagian besar untuk uang.  Oleh karena itu, bodoh untuk mempertimbangkan popularitas kerangka kerja yang terisolasi dari pasar tenaga kerja. </p><br><p>  Dengan jumlah lowongan di hh, React ada di tempat pertama, diikuti oleh jQuery dan perpustakaan komponen lainnya.  Jika kita melihat jumlah pelamar yang menunjukkan perpustakaan yang bersangkutan dalam keterampilan utama mereka, jQuery tahu pelamar 5 kali lebih banyak daripada Bereaksi.  Dan 15 kali lebih besar dari Angular. </p><br><p><img src="https://habrastorage.org/webt/nk/vt/g0/nkvtg0lfwgjyltdhg6uvkvqfp6i.png"><br>  <em>Pasar tenaga kerja</em> </p><br><p>  Kesimpulan berikut dapat diambil dari grafik ini: </p><br><ul><li>  Kerangka kerja komponen adalah yang paling populer di kalangan pengusaha, yang paling populer di antara mereka adalah React. </li><li>  Di antara pelamar, perpustakaan paling umum adalah jQuery. </li></ul><br><p>  Jadi, kerangka kerja komponen dimenangkan.  Frontend memecahkan masalah yang dihadapi pengembang selama jQuery.  Namun pendekatan baru memunculkan masalah baru.  Masalah apa yang saya lihat? </p><br><ol><li>  Performa. <br>  Pada bulan Januari tahun ini, Google mengumumkan kemungkinan menerbitkan aplikasi PWA di google play, membuka jalan untuk javascript di toko aplikasi asli.  Ini membebankan tanggung jawab tertentu pada pengembang, karena pengguna mengharapkan kinerja aplikasi asli, seharusnya tidak ada perbedaan bagi konsumen. <br>  Javascript juga menaklukkan perangkat berdaya rendah.  Ini adalah TV pintar, tonton, IoT.  Perangkat semacam itu memiliki anggaran memori dan prosesor yang terbatas, sehingga pengembang tidak dapat memboroskan sumber dayanya pada pengguna. <br>  Di tempat kerja, kami memiliki pengalaman menjalankan Bereaksi aplikasi pada hub Internet.  Ternyata begitu-begitu. </li><li>  Ambang entri tinggi. <br>  Seperti yang kita lihat di atas, sebagian besar pencari kerja menunjuk pada keterampilan jQuery, bukan bereaksi.  Menguasai konsep Bereaksi jauh lebih sulit daripada menghubungkan ke halaman jQuery dan mulai membuat. </li><li>  Ketergantungan pada framework. <br>  Jika Anda memiliki pustaka komponen yang ditulis dalam React, Anda tidak mungkin dapat menggunakannya kembali dalam proyek Vue atau Angular.  Anda menjadi sandera ekosistem. </li></ol><br><h2 id="svelte-vanilla-flavored">  Langsing.  Rasa vanila. </h2><br><p>  Pada bulan April tahun ini, versi ketiga dari kerangka kerja Svelte yang dikompilasi dirilis. <br>  Svelte menawarkan pengembang kemampuan untuk menulis kode deklaratif tingkat tinggi yang, setelah dikompilasi, berubah menjadi kode imperatif tingkat rendah.  Ini juga memungkinkan untuk melakukan pengocokan pohon yang efektif, dan sebagai hasilnya memungkinkan pengiriman bundel minimal ke klien. <br>  Mari kita lihat solusi apa yang ditawarkan Svelte untuk masalah yang terdengar. </p><br><p>  Karena React adalah perpustakaan paling populer di Rusia, contoh lebih lanjut akan di React. </p><br><h2 id="1-proizvoditelnost">  1. Kinerja </h2><br><p>  Jika Anda mulai berkenalan dengan perpustakaan baru, maka kemungkinan besar Anda akan memulai tur dengan daftar ToDo.  Ini adalah tugas yang cukup sederhana, yang seringkali lebih mudah untuk ditulis dalam vanilla.  Jika Anda ingin mempelajari lebih dalam kerangka kerja ini, maka tinjauan Aplikasi Dunia Nyata adalah pilihan yang bagus.  Ini adalah blog yang pada dasarnya adalah tiruan dari Medium.  Ada registrasi, otorisasi, membuat posting, berkomentar, suka.  Spesialis kerangka menulis implementasi fungsi dan menambahkannya ke koleksi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aplikasi Dunia Nyata</a> . <br>  Artikel tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membandingkan Aplikasi Dunia Nyata yang</a> ditulis dalam berbagai kerangka kerja diterbitkan di FreeCodeCamp. <br>  Jika kita melihat ukuran bundel terakhir, maka Svelte mengungguli pesaingnya.  Hanya 9,7 kb kode yang dikirim ke klien.  Akibatnya, dibutuhkan lebih sedikit waktu untuk mentransfer data, mem-parsing dan memproses kode Anda. </p><br><p><img src="https://habrastorage.org/webt/q_/nq/rm/q_nqrmfqup3utimvroeu-zsrjza.png"><br>  <em>Perbandingan ukuran bundel Aplikasi Dunia Nyata</em> </p><br><p>  Dan kode terbaik bukan kode tertulis. <br>  Jika kita melihat jumlah baris kode yang diperlukan untuk menulis fungsionalitas aplikasi, maka Svelte akan membutuhkan sekitar 1.000 baris, dan Bereaksi sekitar 2.000 baris. Semakin sedikit kode dalam aplikasi Anda, semakin sedikit bug dan dukungan yang lebih mudah. </p><br><p><img src="https://habrastorage.org/webt/gk/jn/ey/gkjneygjfhfhi1b-cooph8aeqim.png"><br>  <em>Perbandingan Ukuran Kode Aplikasi Dunia Nyata</em> </p><br><p>  Mari kita lihat kinerja.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">js-framework-benchmark</a> menawarkan perbandingan kinerja rendering di antara kerangka front-end.  Tesnya adalah menggambar sebuah meja dengan banyak baris.  Manipulasi lebih lanjut dengan tabel ini dibuat: pembaruan sebagian atau penuh, pembuatan, pembersihan, penghapusan garis. </p><br><p>  Pada saat pembaruan, Svelte menunjukkan waktu terbaik atau sebanding.  Svelte sangat seimbang, tidak ada distorsi saat melakukan berbagai jenis operasi. </p><br><p><img src="https://habrastorage.org/webt/rk/qt/nz/rkqtnzb4ua4zy7vvbnbyonfqxqo.png"><br>  <em>Perbandingan waktu eksekusi pembaruan, ms</em> </p><br><p>  Jika kita melihat jumlah memori yang dikonsumsi, maka Svelte adalah yang paling rakus di antara perpustakaan yang bersangkutan. </p><br><p><img src="https://habrastorage.org/webt/de/d-/p_/ded-p_wuuzcdxlay0duwcubzb6g.png"><br>  <em>Perbandingan jumlah memori yang dikonsumsi, mb</em> </p><br><p>  Saya tidak terbiasa mengambil kata dan memutuskan untuk memeriksa semuanya sendiri.  Saya menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implementasi tolok ukur DBMonster</a> untuk front-end dan menulis ulang implementasi pada React 16.8 dan Svelte 3. Tes terdiri dalam rendering tabel dan kemudian memperbarui baris. </p><br><p><img src="https://habrastorage.org/webt/p2/fc/0j/p2fc0jzzmb3jqkr3pxclinvgrqy.gif"><br>  <em>Seperti apa tes DBMonster?</em> </p><br><p>  Selama pengujian, Svelte mengkonsumsi 10 MB lebih sedikit memori dan memperbarui 10 ms lebih cepat daripada Bereaksi. </p><br><p><img src="https://habrastorage.org/webt/it/xm/si/itxmsiqrktcbuiua--rg32ixlce.gif"><img src="https://habrastorage.org/webt/5c/q2/bu/5cq2buhlzbnbcd9ov0yhi1lh2xu.gif"><br>  <em>Langsing / bereaksi</em> </p><br><p>  Tes di atas adalah sintetis, tetapi dari mereka dapat disimpulkan bahwa ketika mengembangkan pada Svelte Anda akan keluar dari kotak: </p><br><ul><li>  Ukuran bundel yang lebih kecil </li><li>  Konsumsi memori lebih sedikit </li><li>  Rendering lebih cepat. </li></ul><br><h2 id="2-vysokiy-porog-vhoda">  2. Ambang entri tinggi </h2><br><p>  Jika kami melihat komponen paling sederhana pada Bereaksi, maka Anda perlu mengimpor Bereaksi itu sendiri, tulis fungsi yang akan mengembalikan markup dan ekspor komponen Anda.  Total 3 baris kode. </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Hello</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> Component;</code> </pre> <br><p>  Jika kita melihat contoh paling sederhana dari komponen pada langsing, maka Anda cukup menulis markup.  Total 1 baris kode. </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>Hello<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Sebenarnya, komponen Svelte yang paling sederhana adalah file kosong.  Ini memungkinkan untuk membuat templat untuk aplikasi Anda dari file kosong, dan kemudian mulai pengembangan.  Dalam hal ini, tidak ada yang akan rusak. </p><br><p>  Anda juga dapat mengambil tata letak yang diterima dari penata letak dan segera menggunakannya sebagai komponen langsing tanpa transformasi tambahan.  Html yang valid adalah komponen Svelte. </p><br><p>  Saya ingin membagikan contoh dari wawancara tentang posisi pengembang reaksi menengah. </p><br><pre> <code class="javascript hljs">setFilter() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.switchFlag = !<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.switchFlag } ... &lt;button onClick={setFilter}&gt;Filter&lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt;</span></span></code> </pre> <br><p>  Kandidat mencoba untuk menyimpan keadaan tombol filter langsung ke properti kelas.  Bereaksi, terlepas dari namanya, tidak cukup reaktif untuk menanggapi perubahan tersebut.  Ini menunjukkan bahwa bahkan pengembang menengah merasa sulit untuk mendapatkan pola pembaruan keadaan yang Bereaksi menggunakan. </p><br><p>  Mari kita lihat contoh tombol yang menambah penghitung dengan satu klik. </p><br><p><img src="https://habrastorage.org/webt/id/en/d8/idend8qhqefwtl2uumhewmzjkg0.gif"></p><br><p>  Pada Bereaksi, Anda memerlukan variabel untuk menahan status dan fungsi yang dapat memperbarui status.  Selanjutnya, Anda perlu menetapkan handler untuk pembaruan ke tombol itu sendiri.  Secara total, saya mendapat 8 baris kode. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [count, setCount] = React.useState(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> setCount(count + 1)}&gt; Clicked {count} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> Component;</code> </pre> <br><p>  Untuk memecahkan masalah serupa pada Svelte, Anda memerlukan variabel untuk menyimpan status.  Lebih lanjut dalam penangan, Anda cukup mengubah nilai variabel ini.  Total 6 baris kode. </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">let</span></span></span><span class="javascript"> count = </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">0</span></span></span><span class="javascript">; </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">on:click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span><span class="hljs-tag">=&gt;</span></span>count+=1}&gt; Clicked {count} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Mari kita sedikit mempersulit contoh.  Misalkan kita membutuhkan bidang input yang menampilkan statusnya di sebelahnya. </p><br><p><img src="https://habrastorage.org/webt/cc/ld/xt/ccldxto2knv1mrmdxke33yevgse.gif"></p><br><p>  Pada Bereaksi, kita masih membutuhkan variabel dan fungsi untuk memperbarui status.  Kemudian, di bidang input, Anda perlu mentransfer nilai saat ini dan menetapkan pawang untuk perubahan.  Saya berakhir dengan 11 baris kode. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [value, setValue] = React.useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;React.Fragment&gt; &lt;input value={value} onChange={e =&gt; setValue(e.target.value)} /&gt; {value} &lt;/React.Fragment&gt; ); } export default App;</code> </pre> <br><p>  Untuk mengatasi masalah ini pada Svelte, Anda memerlukan variabel yang menyimpan status, dan kemudian lakukan pengikatan dua arah di bidang input.  Total 5 baris kode. </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">let</span></span></span><span class="javascript"> value = </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">''</span></span></span><span class="javascript">; </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">bind:value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{value}/</span></span></span><span class="hljs-tag">&gt;</span></span> {value}</code> </pre> <br><p>  Jika Anda pernah membuat animasi penghapusan elemen dari DOM on React, maka saya bersimpati dengan Anda.  Bereaksi akan membutuhkan pembungkus yang akan menunda penghapusan elemen dari DOM dan membuat animasi, atau elemen akan tetap di DOM, tetapi animasi akan memerlukan kontrol properti tampilan atau manipulasi lain sehingga elemen tidak memakan ruang. </p><br><p><img src="https://habrastorage.org/webt/_w/-7/05/_w-705ykcxp0h5jmajgmgvd6lok.gif"></p><br><p>  Saya mencoba menemukan implementasi paling sederhana pada Bereaksi, pada akhirnya saya mendapat 35 baris kode.  Jika Anda memiliki solusi yang lebih sederhana, bagikan dalam komentar. </p><br><div class="spoiler">  <b class="spoiler_title">Fadein fadeout bereaksi</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"./style.css"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [visible, setVisible] = React.useState(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;React.Fragment&gt; &lt;button onClick={(</span></span></span><span class="hljs-function">) =&gt;</span></span> setVisible(!visible)}&gt;toggle&lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;div className={visible ? "visible" : "invisible"}&gt;Hello&lt;/</span></span>div&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">React.Fragment</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); }; export default App;</span></span></code> </pre> <br><pre> <code class="html hljs xml">.visible { animation: fadeIn 0.5s linear forwards; } .invisible { animation: fadeOut 0.5s linear forwards; } @keyframes fadeOut { 0% { opacity: 1; } 100% { opacity: 0; display: none; } } @keyframes fadeIn { 0% { opacity: 0; } 100% { opacity: 1; } }</code> </pre> </div></div><br><p>  Pada Svelte, komponen serupa hanya membutuhkan 8 baris kode.  Svelte memiliki modul bawaan untuk mengelola animasi.  Anda mengimpor jenis animasi yang diinginkan, dan kemudian mengatakan bagaimana menghidupkan komponen Anda saat menambahkan dan menghapus. </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">import</span></span></span><span class="javascript"> { fade } </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">from</span></span></span><span class="javascript"> </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'svelte/transition'</span></span></span><span class="javascript">; </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">let</span></span></span><span class="javascript"> visible = </span><span class="hljs-literal"><span class="javascript"><span class="hljs-literal">true</span></span></span><span class="javascript">; </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">on:click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span><span class="hljs-tag">=&gt;</span></span>visible=!visible}&gt;toggle<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {#if visible} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">transition:fade</span></span></span><span class="hljs-tag">&gt;</span></span>Hello<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> {/if}</code> </pre> <br><p>  Compilability memungkinkan Svelte untuk memberikan abstraksi keren kepada pengembang.  Dan jika Anda tidak menggunakannya, mereka tidak akan jatuh ke dalam bungkusan akhir. </p><br><p>  Misalnya, modul transisi memiliki fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">crossfade</a> keren yang memungkinkan Anda untuk menghidupkan komponen ketika berpindah dari satu node DOM ke yang lain.  Dengan menggunakannya, Anda dapat melakukan transisi tugas seperti itu di daftar ToDo. </p><br><p><img src="https://habrastorage.org/webt/jy/qx/jk/jyqxjktdonnzxitsm7mdhe0fxgm.gif"></p><br><p>  Contoh lain dari abstraksi keren adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penggunaan:</a> direktif.  Ini memungkinkan Anda untuk menetapkan penangan kustom ke elemen DOM.  Pada contoh di bawah ini, acara menekan dan memindahkan, serta acara sentuh diproses hanya menggunakan satu fungsi. </p><br><p><img src="https://habrastorage.org/webt/vr/ne/xj/vrnexj0zvmftba16ecdnb8klmq4.gif"></p><br><p>  Setelah mengenal Svelte, teman-teman saya biasanya mengatakan bahwa mereka belum pernah mengalami perkembangan front-end menyenangkan seperti ini sejak jQuery. </p><br><h2 id="3-zavisimost-ot-freymvorka">  3. Ketergantungan pada framework </h2><br><p>  Ketika Bereaksi tiba, ada banyak widget jQuery di web.  Menemukan komponen yang tepat pada Bereaksi sulit.  Kemudian, pembungkus untuk widget jQuery mulai muncul, yang dapat menyinkronkan Bereaksi dan jQuery.  Setelah itu, komponen yang ditulis di React sendiri sudah mulai muncul. <br>  Sekarang situasi yang sama dengan Bereaksi sendiri.  Ada banyak solusi dan perpustakaan siap pakai yang tidak memungkinkan Anda untuk mentransfer ke kerangka kerja lain tanpa rasa sakit. </p><br><p>  Apa yang ditawarkan Svelte?  Setelah kompilasi, kode Anda berubah menjadi JS biasa, yang tidak memerlukan runtime.  Ini memungkinkan untuk menggunakan komponen Svelte dalam kerangka kerja lain.  Anda hanya perlu satu pembungkus universal.  Misalnya, adaptor untuk React dan Vue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">svelte-adapter</a> .  Dengan membungkus komponen dalam adaptor, Anda dapat menggunakan elemen sebagai komponen biasa. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SvelteSpinner <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"svelte-spinner"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> toReact <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"svelte-adapter/react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Spinner = toReact(SvelteSpinner, {}, <span class="hljs-string"><span class="hljs-string">"div"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> &lt;Spinner size={<span class="hljs-number"><span class="hljs-number">50</span></span>} /&gt;</code> </pre> <br><p><img src="https://habrastorage.org/webt/y7/xl/l1/y7xll1mvvg0lorjn21kz04_g6sq.gif"></p><br><p>  Svelte mendukung kompilasi dalam elemen kustom, yang selanjutnya memperluas ruang lingkup aplikasi komponen.  Anda dapat melihat dukungan elemen khusus dengan berbagai kerangka kerja di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">elemen-kustom-di mana saja</a> . </p><br><h2 id="lichnyy-opyt">  Pengalaman pribadi </h2><br><p>  Saya belum bisa menulis di Svelte di tempat kerja, karena kami duduk ketat di ekosistem Bereaksi, tetapi saya punya proyek pribadi. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saya sebelumnya menulis</a> bagaimana saya menerbitkan aplikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Metalz</a> di Google Play. </p><br><p><img src="https://habrastorage.org/webt/mr/a8/mm/mra8mmaxfr4odearjgnfbtisbu0.png"></p><br><p>  Menurut perasaan saya, Svelte memungkinkan Anda untuk menulis kode yang lebih ringkas dan dapat dimengerti, sambil menyediakan berbagai alat untuk menyederhanakan implementasi. </p><br><h2 id="minusy">  Cons </h2><br><p>  Seperti halnya kerangka kerja muda, Svelte memiliki ekosistem kecil dari solusi yang sudah jadi dan beberapa artikel di mana Anda dapat menemukan praktik terbaik.  Karena itu, saya tidak akan merekomendasikan segera mengambil Svelte untuk proyek-proyek besar, karena Anda dapat berakhir di jalan buntu arsitektur. </p><br><p>  Coba Svelte pada proyek-proyek kecil, saya yakin Anda akan menyukainya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471702/">https://habr.com/ru/post/id471702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471678/index.html">Beruang layanan sesuai permintaan</a></li>
<li><a href="../id471684/index.html">Mengapa Anda perlu membuat modul untuk nginx</a></li>
<li><a href="../id471686/index.html">Bagaimana AWS mengolah layanannya yang tangguh. Penskalaan server dan basis data</a></li>
<li><a href="../id471688/index.html">Bagaimana AWS mengolah layanannya yang tangguh. Penskalaan jaringan</a></li>
<li><a href="../id471700/index.html">Bagaimana saya memilih tumpukan teknologi dengan fondasi untuk masa depan</a></li>
<li><a href="../id471704/index.html">Buku “Mitokondria egois. Cara menjaga kesehatan dan memindahkan usia lanjut "</a></li>
<li><a href="../id471706/index.html">9 masalah jaringan tipikal yang dapat dideteksi menggunakan analisis NetFlow (menggunakan Flowmon sebagai contoh)</a></li>
<li><a href="../id471708/index.html">Storypoints berbahaya untuk pengembangan aplikasi client-server</a></li>
<li><a href="../id471712/index.html">Membuat aplikasi obrolan seluler di React Native</a></li>
<li><a href="../id471716/index.html">Pameran teknologi GITEX 2019 - bagaimana rasanya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>