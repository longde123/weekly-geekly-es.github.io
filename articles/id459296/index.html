<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ— ğŸ‘†ğŸ½ ğŸ‘´ğŸ» Harga JavaScript 2019 ğŸ‘¨â€ğŸ‘¨â€ğŸ‘§â€ğŸ‘§ ğŸšº âœ¡ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selama beberapa tahun terakhir, apa yang disebut " harga JavaScript " telah melihat perubahan positif besar karena peningkatan kecepatan parsing dan k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Harga JavaScript 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/459296/">  Selama beberapa tahun terakhir, apa yang disebut " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">harga JavaScript</a> " telah melihat perubahan positif besar karena peningkatan kecepatan parsing dan kompilasi skrip browser.  Sekarang, pada 2019, komponen utama pemuatan pada sistem yang dibuat oleh JavaScript adalah waktu pemuatan skrip dan waktu pelaksanaannya. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/7x/g6/g_/7xg6g_poas_6_4qwu5u4clgjxrs.jpeg"></a> <br><br>  Interaksi pengguna dengan situs mungkin sementara terganggu jika peramban sibuk mengeksekusi kode JavaScript.  Sebagai hasilnya, kami dapat mengatakan bahwa optimalisasi kemacetan yang terkait dengan pemuatan dan pelaksanaan skrip dapat memiliki dampak positif yang kuat pada kinerja situs web. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Pedoman Praktis Umum untuk Optimasi Situs Web</font> </h2><br>  Apa arti hal di atas bagi pengembang web?  Intinya di sini adalah bahwa biaya sumber daya untuk parsing (parsing, parsing) dan kompilasi skrip tidak seserius sebelumnya.  Karenanya, saat menganalisis dan mengoptimalkan bundel JavaScript, pengembang harus mempertimbangkan tiga rekomendasi berikut: <br><br><ol><li>  Cobalah untuk mengurangi waktu yang diperlukan untuk mengunduh skrip. <br><br><ul><li>  Cobalah untuk menjaga bundel JS Anda kecil.  Ini sangat penting untuk situs yang dirancang untuk perangkat seluler.  Menggunakan bundel kecil meningkatkan waktu pemuatan kode, mengurangi tingkat penggunaan memori, dan mengurangi beban pada prosesor. </li><li>  Cobalah untuk mencegah semua kode proyek dari disajikan sebagai satu bundel besar.  Jika ukuran bundel melebihi sekitar 50-100 Kb - bagilah menjadi fragmen terpisah berukuran kecil.  Berkat multiplexing HTTP / 2, beberapa permintaan server dan beberapa respons dapat diproses secara bersamaan.  Ini mengurangi beban pada sistem yang terkait dengan kebutuhan untuk memenuhi permintaan tambahan untuk pemuatan data. </li><li>  Jika Anda mengerjakan proyek seluler, usahakan agar kode sekecil mungkin.  Rekomendasi ini dikaitkan dengan kecepatan data yang rendah melalui jaringan seluler.  Selain itu, usahakan untuk penggunaan memori yang ekonomis. </li></ul></li><li>  Cobalah untuk mengurangi waktu yang diperlukan untuk menjalankan skrip. <br><br><ul><li> Hindari menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tugas</a> yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panjang</a> yang dapat memuat utas utama untuk waktu yang lama dan menambah waktu yang dibutuhkan agar laman berada dalam kondisi di mana pengguna dapat berinteraksi dengannya.  Di lingkungan saat ini, skrip yang dijalankan setelah dimuat memberikan kontribusi besar pada "harga JavaScript". </li></ul></li><li>  Jangan menanamkan cuplikan kode besar di halaman. <br><br><ul><li>  Aturan berikut harus dipatuhi di sini: jika ukuran skrip melebihi 1 Kb, cobalah untuk tidak menanamkannya dalam kode halaman.  Salah satu alasan untuk rekomendasi ini adalah kenyataan bahwa 1 Kb adalah batas setelah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">caching</a> kode skrip eksternal mulai berfungsi di Chrome.  Juga, perlu diingat bahwa parsing dan kompilasi skrip tertanam masih berjalan di utas utama. </li></ul></li></ol><br><h2>  <font color="#3AC1EF">Mengapa begitu penting untuk memuat dan menjalankan skrip?</font> </h2><br>  Mengapa penting untuk mengoptimalkan waktu pemuatan dan eksekusi skrip dalam kondisi modern?  Waktu pemuatan skrip sangat penting dalam situasi di mana situs diakses melalui jaringan lambat.  Terlepas dari kenyataan bahwa jaringan 4G (dan bahkan 5G) semakin menyebar, properti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NetworkInformation.effectiveType</a> dalam banyak kasus menggunakan koneksi Internet seluler menunjukkan indikator yang berada pada level jaringan 3G atau bahkan pada level yang lebih rendah. <br><br>  Waktu yang diperlukan untuk menjalankan kode JS penting untuk perangkat seluler dengan prosesor yang lambat.  Karena kenyataan bahwa perangkat seluler menggunakan CPU dan GPU yang berbeda, karena fakta bahwa ketika perangkat terlalu panas, untuk melindunginya, kinerja komponen mereka menurun, Anda dapat mengamati kesenjangan serius antara kinerja ponsel dan tablet yang mahal dan murah.  Ini sangat memengaruhi kinerja kode JavaScript, karena kemampuan untuk mengeksekusi kode tersebut oleh perangkat dibatasi oleh kemampuan prosesor perangkat ini. <br><br>  Faktanya, jika kami menganalisis total waktu yang dihabiskan untuk memuat dan menyiapkan halaman untuk bekerja di browser seperti Chrome, sekitar 30% dari waktu ini dapat dihabiskan untuk mengeksekusi kode JS.  Di bawah ini adalah analisis pemuatan halaman web yang sangat khas (reddit.com) pada komputer desktop berkinerja tinggi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/8f6/af0/31d8f6af06d7158ecc9bd17710d216bb.png"></div><br>  <i><font color="#999999">Dalam proses memuat halaman sekitar 10-30% dari waktu dihabiskan untuk eksekusi kode menggunakan V8</font></i> <br><br>  Jika kita berbicara tentang perangkat seluler, maka pada ponsel rata-rata (Moto G4) dibutuhkan 3-4 kali lebih lama untuk mengeksekusi reddit.com pada kode JS daripada pada perangkat tingkat tinggi (Pixel 3).  Pada perangkat yang lemah (Alcatel 1X berharga kurang dari $ 100), menyelesaikan masalah yang sama membutuhkan waktu setidaknya 6 kali lebih banyak daripada sesuatu seperti Pixel 3. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71a/4f0/3a9/71a4f03a9f7d673740c6917f30cee360.png"></div><br>  <i><font color="#999999">Waktu yang diperlukan untuk memproses kode JS pada perangkat seluler dari berbagai kelas</font></i> <br><br>  Harap dicatat bahwa versi mobile dan desktop reddit.com berbeda.  Karena itu, Anda tidak dapat membandingkan hasil perangkat seluler dan, katakanlah, MacBook Pro. <br><br>  Saat Anda mencoba mengoptimalkan waktu eksekusi kode JavaScript, perhatikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tugas</a> yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panjang</a> yang dapat menangkap aliran UI untuk waktu yang lama.  Tugas-tugas ini dapat menghambat pelaksanaan tugas-tugas lain yang sangat penting, bahkan ketika tampilan halaman tampak benar-benar siap untuk bekerja  Tugas jangka panjang harus dipecah menjadi tugas yang lebih kecil.  Dengan membagi kode menjadi bagian-bagian dan mengendalikan urutan pemuatan bagian-bagian ini, Anda dapat mencapai fakta bahwa halaman-halaman akan mencapai keadaan interaktif lebih cepat.  Mudah-mudahan, ini akan menyebabkan pengguna memiliki sedikit ketidaknyamanan dalam berinteraksi dengan halaman. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/002/eef/32b/002eef32b869be9ae677bc41b41c86c2.png"></div><br>  <i><font color="#999999">Tugas jangka panjang menangkap utas utama.</font></i>  <i><font color="#999999">Mereka harus dipecah-pecah</font></i> <br><br><h2>  <font color="#3AC1EF">Bagaimana peningkatan V8 mempercepat parsing dan kompilasi skrip?</font> </h2><br>  Kecepatan penguraian kode JS sumber di V8, sejak zaman Chrome 60, telah meningkat 2 kali lipat.  Pada saat yang sama, penguraian dan kompilasi sekarang berkontribusi lebih sedikit pada "harga JavaScript."  Ini berkat upaya pengoptimalan Chrome lainnya yang mengarah ke paralelisasi tugas-tugas ini. <br><br>  Di V8, jumlah pekerjaan pada parsing dan kode kompilasi yang dihasilkan di utas utama berkurang rata-rata 40%.  Misalnya, untuk Facebook peningkatan indikator ini adalah 46%, untuk Pinterest - 62%.  Hasil tertinggi, 81%, diperoleh untuk YouTube.  Hasil tersebut dimungkinkan karena fakta bahwa parsing dan kompilasi dipindahkan ke aliran yang terpisah.  Dan ini merupakan tambahan untuk perbaikan yang ada mengenai solusi streaming dari tugas yang sama di luar arus utama. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a7/41e/24c/4a741e24c05a9149d98ee568be74b564.png"></div><br>  <i><font color="#999999">Waktu penguraian JS di berbagai versi Chrome</font></i> <br><br>  Anda juga dapat memvisualisasikan bagaimana pengoptimalan V8 yang dihasilkan dalam berbagai versi Chrome memengaruhi waktu prosesor yang diperlukan untuk memproses kode.  Dalam waktu yang bersamaan dengan Chrome 61 yang diperlukan untuk menguraikan kode JS Facebook, Chrome 75 sekarang dapat menguraikan kode JS Facebook dan, di samping itu, menguraikan kode Twitter 6 kali. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6b/000/0e0/c6b0000e0b2bb98087ff12f8a9eb0d97.png"></div><br>  <i><font color="#999999">Saat Chrome 61 diperlukan untuk memproses kode JS Facebook, Chrome 75 dapat memproses kode Facebook dan enam kali jumlah kode Twitter.</font></i> <br><br>  Mari kita bicara tentang bagaimana perbaikan tersebut dicapai.  Singkatnya, sumber daya skrip dapat diuraikan dan dikompilasi dalam mode streaming dalam alur kerja.  Ini berarti yang berikut: <br><br><ul><li>  V8 dapat mengurai dan mengkompilasi kode JS tanpa memblokir utas. </li><li> Pemrosesan aliran skrip dimulai ketika parser HTML universal menemukan <code>&lt;script&gt;</code> .  Pengurai HTML menangani skrip yang memblokir penguraian halaman.  Bertemu dengan skrip asinkron, ia terus bekerja. </li><li>  Dalam sebagian besar skenario dunia nyata, yang ditandai oleh kecepatan koneksi jaringan tertentu, V8 mem-parsing kode lebih cepat daripada yang bisa dimuat.  Akibatnya, V8 menyelesaikan tugas penguraian dan kompilasi kode beberapa milidetik setelah byte terakhir dari skrip dimuat. </li></ul><br>  Jika Anda membicarakan hal ini dengan sedikit lebih detail, maka intinya di sini adalah sebagai berikut.  Di versi Chrome yang jauh lebih tua, skrip harus diunduh secara keseluruhan sebelum menguraikannya.  Pendekatan ini sederhana dan dapat dimengerti, tetapi ketika digunakan, sumber daya prosesor digunakan secara tidak rasional.  Chrome, antara versi 41 dan 68, mulai parsing dalam mode asinkron, segera setelah skrip mulai memuat, melakukan tugas ini di utas terpisah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/574/43a/4fd/57443a4fd274a348de26652d006941c3.png"></div><br>  <i><font color="#999999">Skrip dikirim ke browser dalam fragmen.</font></i>  <i><font color="#999999">V8 mulai memproses streaming data setelah memiliki setidaknya 30 Kb kode.</font></i> <br><br>  Di Chrome 71, kami beralih ke sistem berbasis tugas.  Di sini, penjadwal dapat secara bersamaan memulai beberapa sesi pemrosesan skrip asinkron / tertunda.  Karena perubahan ini, beban yang dibuat oleh parsing utas utama telah berkurang sekitar 20%.  Hal ini menyebabkan peningkatan sekitar 2% dalam skor TTI / FID yang diperoleh di situs nyata. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3f/161/863/a3f16186348f3773a04f7caccc185592.png"></div><br>  <i><font color="#999999">Chrome 71 menggunakan sistem pemrosesan kode berbasis tugas.</font></i>  <i><font color="#999999">Dengan pendekatan ini, penjadwal dapat memproses beberapa skrip asinkron / tertunda secara bersamaan.</font></i> <br><br>  Di Chrome 72, kami membuat streaming yang memproses cara utama untuk mem-parsing skrip.  Sekarang bahkan skrip sinkron biasa ditangani dengan cara ini (meskipun ini tidak berlaku untuk skrip bawaan).  Selain itu, kami berhenti membatalkan operasi parsing berbasis tugas jika utas utama membutuhkan kode yang diuraikan.  Ini dilakukan karena fakta bahwa ini mengarah pada kebutuhan untuk melakukan kembali beberapa pekerjaan yang sudah dilakukan. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Versi Chrome sebelumnya</a> memiliki dukungan untuk streaming parsing dan stream kompilasi kode.  Kemudian skrip yang diunduh dari jaringan harus terlebih dahulu masuk ke aliran utama, dan kemudian akan dialihkan ke sistem pemrosesan skrip streaming. <br><br>  Ini sering membuat parser aliran menunggu data yang sudah diunduh dari jaringan tetapi belum dialihkan oleh aliran utama ke pemrosesan aliran.  Ini terjadi karena fakta bahwa utas utama bisa sibuk dengan beberapa tugas lain (seperti parsing HTML, membuat tata letak halaman atau menjalankan kode JS). <br><br>  Sekarang kami sedang bereksperimen dengan cara memulai parsing kode saat membuka halaman sebelumnya.  Sebelumnya, implementasi mekanisme seperti itu terhambat oleh kebutuhan untuk menggunakan sumber daya utas utama untuk mentransfer tugas ke parser streaming.  Detail tentang penguraian kode JS yang menjalankan "secara instan" dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  <font color="#3AC1EF">Bagaimana pengaruhnya memengaruhi apa yang bisa dilihat di alat pengembang?</font> </h2><br>  Selain hal di atas, dapat dicatat bahwa ada satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah</a> pada alat pengembang sebelumnya.  Itu terdiri dari fakta bahwa informasi tentang tugas parsing ditampilkan seolah-olah mereka benar-benar memblokir utas utama.  Namun, parser melakukan operasi yang hanya memblokir utas utama saat diperlukan data baru.  Karena kami pindah dari skema menggunakan aliran tunggal untuk memproses data streaming ke skema di mana tugas pemrosesan streaming diterapkan, ini menjadi sangat jelas.  Inilah yang dapat Anda lihat di Chrome 69. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87c/b4c/ab0/87cb4cab05a3c00e7b21dfc25524a9c8.png"></div><br>  <i><font color="#999999">Masalahnya ada di alat pengembang, karena informasi tentang skrip parsing ditampilkan seolah-olah mereka benar-benar memblokir utas utama</font></i> <br><br>  Di sini Anda dapat melihat bahwa tugas Script Parse membutuhkan waktu 1,08 detik.  Tetapi parsing JavaScript, pada kenyataannya, tidak begitu lambat!  Sebagian besar waktu ini, tidak ada yang berguna dilakukan kecuali menunggu data dari utas utama. <br>  Di Chrome 76, Anda sudah dapat melihat gambar yang sama sekali berbeda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef8/874/e37/ef8874e37664a31f03c822c71feb0fa8.png"></div><br>  <i><font color="#999999">Di Chrome 76, penguraian dipecah menjadi banyak tugas kecil</font></i> <br><br>  Secara umum, dapat dicatat bahwa tab Performance dari alat pengembang sangat bagus untuk melihat gambaran keseluruhan dari apa yang terjadi pada halaman.  Untuk mendapatkan informasi lebih rinci yang mencerminkan fitur-fitur V8, seperti waktu penguraian dan waktu kompilasi, Anda dapat menggunakan Chrome Tracing dengan dukungan RCS (Runtime Call Stats).  Dalam data RCS yang diterima, Anda dapat menemukan indikator Parse-Background dan Compile-Background.  Mereka dapat melaporkan berapa banyak waktu yang diperlukan untuk mem-parsing dan mengkompilasi kode JS di luar utas utama.  Metrik Parse dan Kompilasi menunjukkan jumlah waktu yang dihabiskan untuk kegiatan terkait di utas utama. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a4/200/d26/3a4200d269fe47bedac1d84c27722a2b.png"></div><br>  <i><font color="#999999">Analisis data RCS menggunakan Google Tracing</font></i> <br><br><h2>  <font color="#3AC1EF">Bagaimana perubahan memengaruhi pekerjaan dengan situs nyata?</font> </h2><br>  Mari kita lihat beberapa contoh bagaimana pemrosesan skrip streaming memengaruhi penjelajahan situs nyata. <br><br><h3>  <font color="#3AC1EF">EddReddit</font> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d77/4ba/270/d774ba2709a772bbcfb26294b67ab385.png"></div><br>  <i><font color="#999999">Lihat reddit.com di MacBook Pro.</font></i>  <i><font color="#999999">Waktu untuk parsing dan kompilasi kode JS dihabiskan di utas utama dan di utas pekerja</font></i> <br><br>  Ada beberapa bundel JS di situs web reddit.com, yang masing-masing melebihi ukuran 100 Kb.  Mereka dibungkus dengan fungsi eksternal, yang mengarah ke pelaksanaan volume besar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"malas" kompilasi</a> di utas utama.  Penting dalam diagram di atas adalah waktu yang diperlukan untuk memproses skrip di utas utama.  Hal ini disebabkan oleh fakta bahwa beban yang besar pada utas utama dapat meningkatkan waktu yang dibutuhkan halaman untuk beralih ke mode interaktif.  Saat memproses kode situs reddit.com, sebagian besar waktu dihabiskan di utas utama, dan sumber daya utas kerja / latar belakang digunakan seminimal mungkin. <br><br>  Anda dapat mengoptimalkan situs ini dengan membagi beberapa bundel besar menjadi beberapa bagian (masing-masing sekitar 50 Kb) dan melakukan tanpa membungkus kode dalam suatu fungsi.  Ini akan memaksimalkan pemrosesan paralel skrip.  Akibatnya, bundel dapat diuraikan dan dikompilasi pada saat yang sama dalam mode streaming.  Ini akan mengurangi beban pada utas utama saat menyiapkan halaman untuk pekerjaan. <br><br><h3>  <font color="#3AC1EF">â–Facebook</font> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/d83/a53/bc2d83a53f5b73658168e3dba70c9a85.png"></div><br>  <i><font color="#999999">Lihat facebook.com di MacBook Pro Anda.</font></i>  <i><font color="#999999">Waktu untuk parsing dan kompilasi kode JS dihabiskan di utas utama dan di utas pekerja</font></i> <br><br>  Kami juga dapat mempertimbangkan situs seperti facebook.com, yang menggunakan sekitar 6 MB kode JS terkompresi.  Kode ini dimuat menggunakan sekitar 292 permintaan.  Beberapa di antaranya asinkron, beberapa ditujukan untuk preloading data, beberapa memiliki prioritas rendah.  Sebagian besar skrip Facebook berukuran kecil dan fokusnya sempit.  Ini dapat memiliki efek yang baik pada pemrosesan data paralel dengan latar belakang / alur kerja.  Faktanya adalah bahwa banyak skrip kecil dapat diuraikan dan dikompilasi pada saat yang sama melalui pemrosesan skrip streaming. <br><br>  Harap perhatikan bahwa situs Anda mungkin berbeda dari situs Facebook.  Anda mungkin tidak memiliki aplikasi yang dibiarkan terbuka untuk waktu yang lama (seperti apa situs Facebook atau antarmuka Gmail), dan ketika bekerja dengannya, mengunduh skrip dengan volume serius dengan browser desktop dapat dibenarkan.  Namun, meskipun demikian, kami dapat memberikan rekomendasi umum yang adil untuk proyek apa pun.  Itu terletak pada fakta bahwa ada baiknya memecah kode aplikasi menjadi bundel sederhana, dan bahwa Anda perlu mengunduh bundel ini hanya ketika ada kebutuhan bagi mereka. <br><br>  Meskipun sebagian besar pekerjaan pada parsing dan kompilasi kode JS dapat dilakukan menggunakan alat streaming di utas latar, beberapa operasi masih memerlukan utas utama.  Ketika utas utama sibuk dengan sesuatu, halaman tidak dapat menanggapi interaksi pengguna.  Oleh karena itu, disarankan untuk memperhatikan dampak pada situs UX yang dimiliki pemuatan dan pelaksanaan kode JS. <br><br>  Ingatlah bahwa tidak semua mesin JavaScript dan browser sekarang mengalirkan skrip dan mengoptimalkan pemuatannya.  Namun terlepas dari ini, kami berharap bahwa prinsip optimasi umum yang diuraikan di atas dapat meningkatkan pengalaman pengguna bekerja dengan situs yang dilihat di salah satu browser yang ada. <br><br><h2>  <font color="#3AC1EF">Harga parsing JSON</font> </h2><br>  Parsing kode JSON bisa jauh lebih efisien daripada parsing kode JavaScript.  Masalahnya, tata bahasa JSON jauh lebih sederhana daripada tata bahasa JavaScript.  Pengetahuan ini dapat diterapkan untuk meningkatkan kecepatan persiapan untuk pekerjaan aplikasi web yang menggunakan objek konfigurasi besar (seperti repositori Redux), struktur yang menyerupai kode JSON.  Akibatnya, ternyata bahwa alih-alih menyajikan data sebagai objek literal yang tertanam dalam kode, Anda dapat mewakili mereka sebagai string objek JSON dan menguraikan objek-objek ini saat runtime. <br><br>  Pendekatan pertama, menggunakan objek JS, terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-attr"><span class="hljs-attr">bar</span></span>: <span class="hljs-number"><span class="hljs-number">1337</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br>  Pendekatan kedua, menggunakan string JSON, melibatkan penggunaan konstruksi tersebut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(<span class="hljs-string"><span class="hljs-string">'{"foo":42,"bar":1337}'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br>  Karena Anda hanya perlu menjalankan pemrosesan string JSON sekali, pendekatan yang menggunakan <code>JSON.parse</code> jauh lebih cepat daripada menggunakan literal objek JavaScript.  Terutama - pada pemuatan halaman "dingin".  Disarankan agar Anda menggunakan string JSON untuk mewakili objek yang mulai dari 10 Kb.  Namun, seperti tip kinerja apa pun, tip ini seharusnya tidak diikuti tanpa pertimbangan.  Sebelum menerapkan teknik ini untuk menyajikan data dalam produksi, perlu untuk melakukan pengukuran dan mengevaluasi dampak nyata pada proyek. <br><br>  Menggunakan objek literal sebagai penyimpanan untuk sejumlah besar data menimbulkan ancaman lain.  Intinya adalah bahwa ada risiko literal tersebut dapat diproses dua kali: <br><br><ol><li>  Pass pemrosesan pertama dilakukan dengan parsing awal dari literal. </li><li>  Pendekatan kedua dilakukan selama parsing "lazy" dari literal. </li></ol><br>  Anda tidak dapat menyingkirkan pass pertama dari pemrosesan literal objek.  Namun, untungnya, pass kedua dapat dihindari dengan menempatkan objek literal di tingkat atas atau di dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PIFE</a> . <br><br><h2>  <font color="#3AC1EF">Bagaimana dengan parsing dan kompilasi kode pada kunjungan berulang ke situs?</font> </h2><br>  Dimungkinkan untuk mengoptimalkan kinerja situs untuk kasus-kasus ketika pengguna mengunjunginya lebih dari sekali, berkat kemampuan V8 untuk kode caching dan bytecode.  Saat skrip diminta dari server untuk pertama kalinya, Chrome mengunduh dan melewati V8 untuk kompilasi.  Browser, selain itu, menyimpan file skrip ini dalam cache disk-nya.  Ketika permintaan kedua untuk mengunduh file JS yang sama dijalankan, Chrome mengambilnya dari cache browser dan kembali melewati V8 untuk kompilasi.  Namun kali ini, kode yang dikompilasi diserialisasi dan dilampirkan ke file skrip cache sebagai metadata. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b78/216/702/b7821670255f45c9ec4a08217b495153.png"></div><br>  <i><font color="#999999">Sistem caching kode di V8</font></i> <br><br>  Saat skrip diminta untuk ketiga kalinya, Chrome mengambil file dan metadata-nya dari cache, dan kemudian mentransfer V8 keduanya.  V8 menghilangkan desimal metadata dan, sebagai akibatnya, dapat melewati langkah kompilasi.  Caching kode dipicu jika kunjungan ke situs dilakukan dalam 72 jam.  Chrome juga menggunakan strategi caching kode serakah ketika pekerja layanan digunakan untuk me-cache skrip.  Detail tentang caching kode dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Pada 2019, hambatan kinerja utama untuk halaman web adalah memuat dan menjalankan skrip.  Untuk memperbaiki situasi, berusaha untuk menggunakan skrip sinkron (built-in) berukuran kecil, yang diperlukan untuk mengatur interaksi pengguna dengan bagian halaman yang dapat dilihat langsung setelah memuat.  Skrip yang digunakan untuk melayani bagian lain dari halaman disarankan untuk dimuat dalam mode ditangguhkan.  Memecah bundel besar menjadi potongan-potongan kecil.  Ini akan memfasilitasi implementasi strategi untuk bekerja dengan kode, dalam aplikasi kode dimuat hanya ketika dibutuhkan, dan hanya di mana diperlukan.  Ini akan memaksimalkan kemampuan V8, yang ditujukan untuk pemrosesan kode secara paralel. <br><br>  Jika Anda sedang mengembangkan proyek seluler, maka Anda harus berusaha untuk memastikan bahwa mereka menggunakan kode JS sesedikit mungkin.  Rekomendasi ini berasal dari kenyataan bahwa perangkat seluler biasanya bekerja di jaringan yang cukup lambat.  Perangkat seperti itu, di samping itu, mungkin terbatas dalam hal RAM yang tersedia dan sumber daya prosesor yang tersedia.  Cobalah untuk menemukan keseimbangan antara waktu yang diperlukan untuk menyiapkan skrip yang diunduh dari jaringan dan menggunakan cache.  Ini akan memaksimalkan jumlah penguraian dan kompilasi kode yang dilakukan di luar utas utama. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda mengoptimalkan proyek web Anda dengan mempertimbangkan kekhasan pemrosesan kode JS oleh browser modern? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459296/">https://habr.com/ru/post/id459296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459284/index.html">Pengantar Singkat Strategi Produk Dan Prioritas Fitur</a></li>
<li><a href="../id459286/index.html">Telluride tungsten semi-logam - pisau Swiss untuk zaman nanoteknologi</a></li>
<li><a href="../id459288/index.html">Implementasi asli dari perpustakaan ECS</a></li>
<li><a href="../id459292/index.html">Otomasi Uji Aplikasi Seluler: Perbandingan Alat</a></li>
<li><a href="../id459294/index.html">Apa yang lebih penting: untuk mengetahui bahasa pemrograman atau untuk dapat memecahkan masalah bisnis?</a></li>
<li><a href="../id459298/index.html">Sudut: status pada 2019</a></li>
<li><a href="../id459300/index.html">Quasar 1.0: alat berguna baru untuk pengembang Vue dan tidak hanya untuk mereka</a></li>
<li><a href="../id459302/index.html">Mencoba ulang permintaan HTTP yang gagal di Angular</a></li>
<li><a href="../id459304/index.html">Bypass Pitfall Angular dan Penghematan Waktu</a></li>
<li><a href="../id459306/index.html">Perenderan server di lingkungan tanpa server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>