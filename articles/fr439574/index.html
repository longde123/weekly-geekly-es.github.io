<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüè´ üç∂ üë®üèª‚Äçüç≥ Protocole SmartCard I2C. √âchangez les commandes APDU via l'interface I2C ‚òÆÔ∏è üëÇüèø üéá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 Il y a quelque temps, j'ai particip√© au d√©veloppement d'un appareil dans lequel il fallait impl√©menter la cryptographie russe. Puisqu'√†...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protocole SmartCard I2C. √âchangez les commandes APDU via l'interface I2C</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439574/"><h2>  Pr√©sentation </h2><br>  Il y a quelque temps, j'ai particip√© au d√©veloppement d'un appareil dans lequel il fallait impl√©menter la cryptographie russe.  Puisqu'√† l'avenir il √©tait cens√© certifier cette d√©cision, certaines exigences ont √©t√© avanc√©es pour la mise en ≈ìuvre de la cryptographie.  Et comme l'une des options pour simplifier la mise en ≈ìuvre de ces exigences, nous avons envisag√© la possibilit√© d'int√©grer un lecteur de carte √† puce dans l'appareil ou d'installer une puce de carte √† puce, dans laquelle de nombreux sc√©narios n√©cessaires de travail avec des informations cl√©s ont d√©j√† √©t√© mis en ≈ìuvre. <br><br>  Malheureusement, une telle solution ne convenait pas pour une raison quelconque, bien que s'il avait √©t√© possible d'utiliser la cryptographie mat√©rielle russe pr√™te √† l'emploi, cela aurait d√ª acc√©l√©rer consid√©rablement le d√©veloppement et la certification ult√©rieure du produit final.  Et les raisons de l'impossibilit√© d'utiliser des jetons USB ou des cartes √† puce √©taient tr√®s courantes: l'appareil aurait d√ª √™tre assez compact (un petit module pour les appareils M2M ou IoT), fonctionner principalement en mode sans entretien et fonctionner dans une large plage de temp√©ratures. <br><br>  Dans cet article, je veux parler d'une solution possible √† un tel cas en utilisant la puce A7001, qui est connect√©e au syst√®me via l'interface I2C. <br><br><img src="https://habrastorage.org/webt/e5/bw/lh/e5bwlh2fhtuxpwj7cdmmt7ujtjc.png"><br><a name="habracut"></a><br><h2>  Probl√®mes de mise en ≈ìuvre de la cryptographie dans le PAC </h2><br>  Je ne veux pas m'attarder sur les probl√®mes de certification cryptographique.  Quiconque travaille avec cela le sait de toute fa√ßon, mais le reste ne semble pas en avoir besoin.  Mais sur quelques points importants, cela vaut la peine d'√™tre dit. <br><br>  En th√©orie, il ne devrait pas y avoir de probl√®mes particuliers avec la cryptographie.  Apr√®s tout, il suffit de prendre l'une des biblioth√®ques cryptographiques, par exemple, OpenSSL, ou toute autre parmi les nombreuses existantes. <br><br>  Les probl√®mes commencent lorsque cette solution doit √™tre certifi√©e.  Et l'impl√©mentation purement logicielle de la cryptographie dans le micrologiciel transforme l'appareil en un dispositif de protection des informations cryptographiques √† part enti√®re, qui n√©cessite une √©tude approfondie dans un laboratoire de test.  Apr√®s tout, lors du d√©veloppement d'une solution utilisant la cryptographie, vous devrez t√¥t ou tard penser √† des choses comme un sch√©ma de cl√©s, le stockage de cl√©s, la g√©n√©ration de nombres al√©atoires et d'autres questions subtiles. <br><br>  Il existe une m√©thode √©l√©gante pour impl√©menter des algorithmes cryptographiques russes certifi√©s pour certaines solutions, ce qui nous permet de simplifier l√©g√®rement le processus de cr√©ation de terminaux et de r√©duire le temps de leur d√©veloppement et de leur certification ult√©rieure.  Il suffit d'int√©grer une carte √† puce ou une puce de carte √† puce dans l'appareil, en l'utilisant comme une sorte de ¬´racine de confiance¬ª, et ainsi de r√©soudre un nombre important de probl√®mes douloureux qui n√©cessitent de longues recherches et confirmations dans les laboratoires d'essais. <br><br><img src="https://habrastorage.org/webt/e2/iq/6i/e2iq6i49c7ber2rkbgu6sv8fl3u.png"><br><br><h2>  Microcontr√¥leur √† carte √† puce avec interface I2C </h2><br>  Pour √©crire cet article, j'ai utilis√© la puce A7001, qui se connecte √† l'appareil final via le bus I2C, qui est disponible dans presque tous les appareils.  La puce a √©t√© fournie par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Aladdin RD</a> , qui a d√©j√† install√© un firmware prenant en charge la cryptographie russe. <br><br>  Le microcontr√¥leur A7001AG (microcontr√¥leur d'authentification s√©curis√©e) est fabriqu√© par NXP.  Selon la fiche technique de la puce, l' <b>A7001AG</b> est un microcontr√¥leur prot√©g√© contre les acc√®s non autoris√©s bas√© sur l'architecture classique 80C51 avec un coprocesseur cryptographique. <br><br>  En mode √©conomie d'√©nergie, le microcontr√¥leur consomme 50 ŒºA.  Il prend en charge une tension d'alimentation comprise entre 1,62 V et 5,5 V et peut fonctionner √† des temp√©ratures de ‚àí25 ¬∞ C √† + 85 ¬∞ C. <br><br>  Pour interagir avec des appareils externes, l'interface esclave I2C est utilis√©e √† une vitesse pouvant atteindre 100 kbit / s. <br><br>  Le microcontr√¥leur est disponible dans plusieurs options de bo√Ætier.  Je me suis retrouv√© au format HVQFN32.  Il s'agit d'un bo√Ætier en plastique mesurant 5x5x0,85 mm avec 32 contacts et un pas de 0,5 mm. <br><br>  Aspect de l'affaire: <br><br><img src="https://habrastorage.org/webt/tn/7r/mz/tn7rmzk8pbzw1ezupbdv7fxvqhm.png"><br><br>  Son brochage: <br><br><img src="https://habrastorage.org/webt/tr/bo/5r/trbo5rlj2_q0v-lxbs7wbqevlu0.png"><br><br><h2>  Syst√®me h√¥te pour connecter la puce A7001 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La carte ESP32 WiFi Kit 32 de Heltec a</a> √©t√© prise comme disposition du syst√®me h√¥te avec l'interface I2C.  Il co√ªte moins de 1000 roubles, poss√®de toutes les interfaces filaires et sans fil n√©cessaires, il y a un connecteur pour connecter une batterie au lithium avec un circuit de charge, ainsi qu'un √©cran OLED de 0,96 pouce. <br><br><img src="https://habrastorage.org/webt/uf/kq/li/ufkqlihfpi9w0692rq8junv0ybo.jpeg"><br><br>  Un syst√®me presque parfait pour prototyper divers appareils IoT et M2M, avec lesquels j'ai longtemps voulu jouer. <br><br>  La carte peut √™tre programm√©e √† la fois dans l'environnement de d√©veloppement natif et dans l'IDE Arduino.  Il existe de nombreux exemples d'utilisation.  Pour plus de simplicit√©, j'ai opt√© pour l'IDE Arduino standard. <br><br><h2>  Sch√©ma du circuit </h2><br>  Le sch√©ma de circuit pour connecter la puce A7001 est illustr√© dans la figure.  <s>Il est l√©g√®rement diff√©rent de la fiche technique recommand√©e.</s>  <s>Selon la description du constructeur, la borne 22 (signal de r√©initialisation RST_N) devrait avoir un potentiel √©lev√©, mais le circuit n'a pas d√©marr√© selon ce sch√©ma.</s>  <s>En raison du ¬´coup scientifique¬ª, l'op√©rabilit√© a √©t√© obtenue en connectant une r√©sistance de rappel R4 au conducteur de puissance n√©gatif.</s> <br><br>  <i>MISE √Ä JOUR: Comme sugg√©r√© dans les commentaires, le sch√©ma correspond √† la fiche technique, tandis que la description de sortie m'a confondu</i> <blockquote>  RST_N - R√©initialiser l'entr√©e, <b>active LOW</b> </blockquote><br><br><img src="https://habrastorage.org/webt/ud/l3/nd/udl3nd7nz2ck8gtwkb3dhdudzqy.png"><br><br>  Le circuit est assembl√© sur une petite planche √† pain.  Les signaux d'alimentation et I2C sont connect√©s par quatre fils de connexion, et le module ESP32 lui-m√™me est connect√© √† l'ordinateur via USB pour recevoir l'alimentation de l'ensemble du circuit et remplir le firmware. <br><br><img src="https://habrastorage.org/webt/de/xz/w1/dexzw1kvlnoixvk0ko-9svuvkbg.png"><br><br><h2>  Protocole de carte √† puce I2C </h2><br>  Lorsque j'ai entendu parler pour la premi√®re fois de la connexion de microcontr√¥leurs de cartes √† puce via le bus I2C, ils m'ont expliqu√© que la couche physique de l'interface de la carte √† puce (GOST R ISO / IEC 7816-3-2013) avait √©t√© remplac√©e par I2C (SMBus), et tout le reste fonctionnait comme d'habitude. cartes √† puce selon GOST R ISO / IEC 7816-4-2013 utilisant des commandes APDU. <br><br>  Il s'est av√©r√© que ce n'est pas tout √† fait vrai, ou plut√¥t pas du tout.  L'interaction avec le microcontr√¥leur √† un niveau √©lev√© se produit en utilisant des commandes APDU conventionnelles, mais il y avait aussi des ¬´mais¬ª. <br><br><ol><li>  L'interface I2C (SMBus) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ru.wikipedia.org/wiki/I%C2%B2C</a> est un bus avec adressage esclave, qui est fondamentalement diff√©rent de l'interface s√©rie UART, qui est con√ßu pour communiquer deux appareils sur une base point √† point et sans utiliser l'adressage .  Cela signifie que toutes les donn√©es transmises (commandes APDU) doivent √™tre ¬´compress√©es¬ª au format de donn√©es du bus I2C. </li><li>  Le travail avec une carte √† puce commence par sa r√©initialisation, g√©n√©ralement en coupant l'alimentation, par exemple en retirant physiquement la carte du lecteur de carte.  Apr√®s la r√©initialisation, la carte √† puce envoie d'abord le bloc de donn√©es ATR (Answer To Reset), qui contient les informations de configuration n√©cessaires pour configurer l'interaction avec la carte √† puce. <br>  Et la puce sur le bus I2C ne fait pas exception, mais dans le cas o√π le microcontr√¥leur doit √™tre soud√© √† la carte de circuit imprim√©, il peut ne pas avoir de circuit d'alimentation du microcircuit ou de contr√¥le logiciel de la sortie de r√©initialisation.  Par cons√©quent, la r√©initialisation de la puce est impl√©ment√©e, y compris, au niveau des commandes du protocole I2C. </li></ol><br>  Ces probl√®mes et d'autres sont r√©solus par le biais du protocole de la carte √† puce I2C, dont une description peut √™tre trouv√©e sur le site Web de NXP √† l'adresse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.nxp.com/docs/en/supporting-information/AN12207.pdf</a> . <br><br><h2>  Partie logiciel </h2><br>  Une recherche dans la biblioth√®que avec l'impl√©mentation du <i>protocole Smart Card I2C Protocol</i> n'a donn√© aucun r√©sultat.  Par cons√©quent, j'ai d√ª comprendre les sp√©cifications et faire la mise en ≈ìuvre des fonctions de base de ce qui √©tait √† port√©e de main. <br><br><div class="spoiler">  <b class="spoiler_title">Sketch sources pour Arduino IDE</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Wire.h&gt; #include &lt;vector&gt; // I2C address on chip A7001 #define ADDR_A7001 static_cast&lt;uint16_t&gt;(0x48) using namespace std; typedef std::vector&lt;uint8_t&gt; vect; //-------------------------------------------------------------------------- // Output dump data by serial port void vect_dump(const char * prefix, const vect &amp; v, const size_t start = 0, const size_t count = 0) { if(prefix) { Serial.print(prefix); } if(v.size() &lt; start) { Serial.println("Empty"); return; } for(size_t i=0; i &lt; (v.size()-start) &amp;&amp; (count == 0 || i &lt; count); i++) { uint8_t b = v[start + i]; // Format output HEX data if(i) Serial.print(" "); if(b &lt; 0x0F) Serial.print("0"); Serial.print(b, HEX); } Serial.println(""); } //-------------------------------------------------------------------------- // Send array bytes by I2C to address A7001 and read response result_size bytes vect sci2c_exchange(const vect data, const uint8_t result_size) { Wire.beginTransmission(ADDR_A7001); Wire.write(data.data(), data.size()); Wire.endTransmission(false); Wire.requestFrom(ADDR_A7001, result_size, true); //delay(1); vect result(result_size, 0); if(result_size &gt;= 2) { result[0] = Wire.read(); // Data size CDB result[1] = Wire.read(); // PCB for(size_t i=2; i&lt;result.size()-2 &amp;&amp; Wire.available(); i++) { result[i+2] = Wire.read(); } } return result; } //-------------------------------------------------------------------------- // Read Status Code uint8_t sci2c_status(const char * msg = nullptr) { vect v = sci2c_exchange({0b0111}, 2); uint8_t status = v[1] &gt;&gt; 4; if(msg) { Serial.print(msg); // Prefix switch(status) { case 0b0000: Serial.println("OK (Ready)"); break; case 0b0001: Serial.println("OK (Busy)"); break; case 0b1000: Serial.println("ERROR (Exception raised)"); break; case 0b1001: Serial.println("ERROR (Over clocking)"); break; case 0b1010: Serial.println("ERROR (Unexpected Sequence)"); break; case 0b1011: Serial.println("ERROR (Invalid Data Length)"); break; case 0b1100: Serial.println("ERROR (Unexpected Command)"); break; case 0b1101: Serial.println("ERROR (Invalid EDC)"); break; default: Serial.print("ERROR (Other Exception "); Serial.print(status, BIN); Serial.println("b)"); break; } } return status; } static uint8_t apdu_master_sequence_counter = 0; // Sequence Counter Master, Master to Slave //-------------------------------------------------------------------------- // Send APDU void sci2c_apdu_send(const vect apdu) { vect_dump("C-APDU =&gt; ", apdu); vect data(2, 0); // 0x00 - Master to Slave Data Transmission command + reserve to length data.insert(data.end(), std::begin(apdu), std::end(apdu)); data[0] |= (apdu_master_sequence_counter &lt;&lt; 4); if(++apdu_master_sequence_counter &gt; 0b111) { apdu_master_sequence_counter = 0; } data[1] = data.size() - 2; sci2c_exchange(data, 2); delay(10); sci2c_status(""); } //-------------------------------------------------------------------------- // Receive APDU vect sci2c_apdu_recv(uint8_t result_size) { Wire.beginTransmission(ADDR_A7001); Wire.write(0b0010); // 0010b - Slave to Master Data Transmission command Wire.endTransmission(false); Wire.requestFrom(ADDR_A7001, result_size, true); vect result(result_size, 0); for(size_t i=0; i&lt;result.size() &amp;&amp; Wire.available(); i++) { result[i] = Wire.read(); } vect_dump("R-APDU &lt;= ", result); return result; } //-------------------------------------------------------------------------- void setup(){ Wire.begin(); Serial.begin(9600); while (!Serial); Serial.println(""); Serial.println("Smart Card I2C Protocol Arduino demo on A7001"); Serial.println(""); sci2c_exchange({0b00001111}, 2); //The bits b0 to b5 set to 001111b indicate the Wakeup command. sci2c_status("Status Wakeup: "); sci2c_exchange({0b00001111}, 2); //The bits b0 to b5 set to 001111b indicate the Wakeup command. sci2c_status("Status Wakeup: "); // Soft Reset sci2c_exchange({0b00011111}, 2); //The bits b0 to b5 set to 011111b indicate the Soft Reset command. delay(5); // Wait at least tRSTG (time, ReSeT Guard) sci2c_status("Status SoftReset: "); // Read ATR vect ATR = sci2c_exchange({0b101111}, 29+2); //The bits b0 to b5 set to 101111b indicate the Read Answer to Reset command. sci2c_status("Status ATR: "); vect_dump("ATR: ", ATR, 2); // Parameter Exchange // The bits b0 to b5 set to 111111b of the PCB send by the master device indicate the Parameter Exchange command. // The bits b6 and b7 of the PCB send by the master device code the CDBIsm,max(Command Data Bytes Integer, Slave to Master, MAXimum) vect CDB = sci2c_exchange({0b11111111}, 2); sci2c_status("Status CDB: "); vect_dump("CDB: ", CDB, 1); // Further examples of the exchange of APDU // Exchanges APDU from exmaple chapter sci2c_apdu_send({0x00, 0xA4, 0x04, 0x04, 0x04, 0x54, 0x65, 0x73, 0x74, 0x00}); sci2c_status("Status Test send: "); sci2c_apdu_recv(3+1); // R-APDU size + 1 byte PBC sci2c_status("Status Test recv: "); // Read Card Production Life Cycle sci2c_apdu_send({0x80, 0xCA, 0x9F, 0x7F, 0x00}); sci2c_status("Status card LC send: "); sci2c_apdu_recv(0x30+1); // R-APDU size + 1 byte PBC sci2c_status("Status card LC recv: "); // Read Card Info sci2c_apdu_send({0x80, 0xCA, 0x00, 0x66, 0x00}); sci2c_status("Status card info send: "); sci2c_apdu_recv(0x51+1); // R-APDU size + 1 byte PBC sci2c_status("Status card info recv: "); // Read Key Info sci2c_apdu_send({0x80, 0xCA, 0x00, 0xE0, 0x00}); sci2c_status("Status key send: "); sci2c_apdu_recv(0x17+1); // R-APDU size + 1 byte PBC sci2c_status("Status key recv: "); // Again exchanges APDU from exmaple chapter sci2c_apdu_send({0x00, 0xA4, 0x04, 0x04, 0x04, 0x54, 0x65, 0x73, 0x74, 0x00}); sci2c_status("Status Test send: "); sci2c_apdu_recv(3+1); // R-APDU size + 1 byte PBC sci2c_status("Status Test recv: "); Serial.println("Done!\n"); } //-------------------------------------------------------------------------- void loop() { delay(100); }</span></span></span></span></code> </pre> <br></div></div><br>  Pour travailler avec le port I2C, j'ai utilis√© la biblioth√®que Wire standard.  Je dois dire tout de suite que cette biblioth√®que n'est pas adapt√©e √† la mise en ≈ìuvre compl√®te du protocole Smart Card I2C, car  il ne permet pas de contr√¥ler ACK et NACK lors de la transmission et de la lecture d'octets individuels, ce qui est n√©cessaire pour impl√©menter la r√©ception correcte des donn√©es de longueur variable √† partir d'une carte √† puce. <br><br>  Oui, et les exemples habituels du code Wire n'ont pas fonctionn√© la premi√®re fois, mais apr√®s avoir dans√© avec un clavier √† <s>tambourin</s> , plusieurs litres de caf√©, googl√© dans Yandex et Yandex dans google, une solution a √©t√© trouv√©e. <br><br><pre> <code class="cpp hljs">Wire.write ( ); Wire.endTransmission (<span class="hljs-literal"><span class="hljs-literal">false</span></span>); Wire.requestFrom (ADDR_A7001, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br>  A en juger par la documentation de la biblioth√®que, cette conception ne lib√®re pas le bus I2C apr√®s avoir appel√© <i>endTransmission</i> .  Mais il s'est av√©r√© que pour le module bas√© sur ESP32 que j'utilisais, le transfert de donn√©es ne se produit pas physiquement pendant l'appel √† <i>endTransmission (false)</i> , comme √©crit dans la documentation de la biblioth√®que Wire, mais pendant l'appel √† <i>requestFrom (true)</i> , alors que les donn√©es sont uniquement mises en file d'attente avant cette √† transf√©rer. <br><br>  Compte tenu de ces limitations, j'ai d√ª faire des ¬´b√©quilles¬ª, mais je voulais vraiment lancer la puce A7001 sans r√©√©crire les biblioth√®ques standard.  Pour cette raison, la gestion des erreurs de protocole n'a pas √©t√© impl√©ment√©e et il n'a pas √©t√© possible non plus de recevoir des donn√©es de longueur variable (c'est-√†-dire qu'il est toujours n√©cessaire de sp√©cifier le nombre exact d'octets √† lire). <br><br>  De telles restrictions ne sont pas autoris√©es dans un syst√®me r√©el, mais ne sont pas essentielles pour d√©montrer l'utilisation des commandes APDU lorsque vous travaillez sur le bus I2C.  Par cons√©quent, si une erreur se produit dans le protocole d'√©change lors de l'√©change de donn√©es via le port I2C, le commutateur √† bascule d'alimentation est le n√¥tre. <br>  En d'autres termes, si pendant la r√©p√©tition de ces exp√©riences tout fonctionnait et s'arr√™tait soudainement avant de rechercher une erreur dans le code, √©teignez et rallumez l'appareil.  Avec un degr√© de probabilit√© √©lev√©, cela peut r√©soudre le probl√®me. <br><br><h2>  Exemples de code pour travailler avec la puce A7001 </h2><br>  Dans les exemples, j'utilise plusieurs fonctions d'assistance: <br><br>  <b>vect_dump</b> - sortie des donn√©es de vidage au format HEX sur le port de d√©bogage; <br>  <b>sci2c_exchange</b> - envoie un tableau de donn√©es via I2C et lit le nombre sp√©cifi√© d'octets de r√©ponse; <br>  <b>sci2c_status</b> - lit l'√©tat de r√©ponse du microcircuit et, si n√©cessaire, affiche son √©tat dans le port de d√©bogage; <br>  <b>sci2c_apdu_send</b> - envoie une commande APDU; <br>  <b>sci2c_apdu_recv</b> - lit la r√©ponse √† la commande APDU. <br><br><h3>  Initialisation de la puce </h3><br>  Selon la description du <i>protocole</i> de la <i>carte √† puce I2C</i> , avant de commencer √† travailler avec la puce, trois commandes doivent √™tre ex√©cut√©es s√©quentiellement: red√©marrage (r√©initialisation √† froid ou √† chaud), lecture de l'ATR (lecture de la r√©ponse √† la r√©initialisation) et configuration des param√®tres d'√©change (param√®tre d'√©change des appareils principaux).  Et seulement apr√®s cela, la puce est pr√™te √† accepter les commandes APDU. <br><br><h3>  R√©initialisation logicielle </h3><br>  Tout est simple ici, nous envoyons une commande de red√©marrage et attendons l'heure d√©finie: <br><br><pre> <code class="cpp hljs">sci2c_exchange ({<span class="hljs-number"><span class="hljs-number">0b00011111</span></span>}, <span class="hljs-number"><span class="hljs-number">2</span></span>); delay(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      (tRSTG, time, ReSeT Guard)</span></span></code> </pre><br><h3>  Lire la r√©ponse pour r√©initialiser </h3><br>  La lecture de l'ATR est un peu plus compliqu√©e, car  vous devez non seulement envoyer une commande, mais √©galement lire les donn√©es de r√©ponse.  Selon la description du protocole, la taille maximale des donn√©es retourn√©es CDBATS, MAX (Command Data Bytes, Answer To Reset, MAXimum) peut √™tre de 29 octets. <br><br><pre> <code class="cpp hljs">vect ATR = sci2c_exchange({<span class="hljs-number"><span class="hljs-number">0b101111</span></span>}, <span class="hljs-number"><span class="hljs-number">29</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 29  + 1  PCB + 1  ‚Äî   vect_dump("ATR: ", ATR);</span></span></code> </pre><br>  Lire les donn√©es ATR: <b>1E 00 00 00 B8 03 11 01 05 B9 02 01 01 BA 01 01 BB 0D 41 37 30 30 31 43 47 20 32 34 32 52 31</b> <br><br>  O√π 1E est la taille des donn√©es retourn√©es (29 octets + 1 octet du PCB) et 00 est le PCB (Protocol Control Byte), qui devrait √™tre √©gal √† 0 et, apparemment, dans cet exemple, les donn√©es n'ont pas √©t√© lues correctement (il devrait y avoir un octet du PCB, et il y en a trois). <br><br>  Les donn√©es suivantes sont encod√©es au format TLV: <br><br>  <b>B8h</b> - <i>Objet de donn√©es de bas niveau</i> , taille 3 octets ( <i>11h 01h 05h</i> ); <br>  <b>B9h</b> - <i>Objet de donn√©es de liaison de protocole</i> , de 2 octets ( <i>01h 01h</i> ); <br>  <b>BAh</b> - <i>Objet de donn√©es de couche sup√©rieure</i> , de 1 octet ( <i>01h</i> ); <br>  <b>BBh</b> - <i>Objet de donn√©es du syst√®me d'exploitation</i> , 13 octets ( <i>41 37 30 30 31 43 47 20 32 34 32 52 31</i> ). <br><br>  <b>D√©cryptage de la configuration de lecture de la puce</b> <br>  <i>Objet de donn√©es de bas niveau</i> : <b>11h</b> - versions <b>majeures</b> et mineures du protocole pris en charge. <br><br>  <i>Codes de d√©tection d'erreur</i> : <b>01h</b> - prise en charge de la d√©tection d'erreur et du contr√¥le d'int√©grit√© des donn√©es transmises √† l'aide du LRC (Longitudinal Redundancy Code). <br><br>  <i>Entier en attente de trame (FWI)</i> : <b>05h</b> - d√©lai maximum entre deux commandes.  La plage de valeurs peut aller de 10 ms √† 5120 ms, la valeur par d√©faut est 5120 ms.  La valeur est calcul√©e par la formule T = 10 ms x 2 ^ FWI.  Ce qui dans ce cas nous donne un retard de 320 ms (10ms x 2 ^ 5). <br><br>  <i>Objet de donn√©es de liaison de protocole</i> - se compose de deux valeurs, <b>01h 01h</b> , qui codent le protocole pris en charge et le protocole par d√©faut.  Ces valeurs signifient la prise en charge du protocole APDU [GOST R ISO / IEC 7816-3-2013] et, comme vous pouvez le deviner, le m√™me protocole est install√© par d√©faut. <br><br>  <i>Objet de donn√©es de couche sup√©rieure</i> - le nombre <b>01h</b> signifie la prise en charge du format APDU court et √©tendu. <br><br>  <i>L'objet de donn√©es du syst√®me d'exploitation</i> est un identifiant d'une taille maximale de 15 octets, tel que d√©fini dans la norme [GOST R ISO / IEC 7816-4-2013].  Dans notre cas, il s'agit de la cha√Æne " <i>A7001CG 242R1</i> ". <br><br><h3>  Dispositif ma√Ætre √©change le param√®tre </h3><br>  La derni√®re commande pour initialiser les param√®tres d'√©change: <br><br><pre> <code class="cpp hljs">vect CDB = sci2c_exchange({<span class="hljs-number"><span class="hljs-number">0b11111111</span></span>}, <span class="hljs-number"><span class="hljs-number">2</span></span>); sci2c_status(<span class="hljs-string"><span class="hljs-string">"Status CDB: "</span></span>); vect_dump(<span class="hljs-string"><span class="hljs-string">"CDB: "</span></span>, CDB, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Valeur de retour: CCh - (11001100b) selon la fiche technique, 4 et 5 bits doivent √™tre une n√©gation au niveau du bit des bits 2 et 3 (NNb code le CDBIMS au niveau du bit, MAX) et, selon la valeur cod√©e, la puce prend en charge la taille de commande maximale possible de 252 octets CDBIMS , MAX (nombre d'octets de donn√©es de commande, ma√Ætre √† esclave, MAXimum). <br><br>  Selon la description du protocole, apr√®s avoir ex√©cut√© ces trois commandes et dans cet ordre, le microcircuit est pr√™t √† ex√©cuter des commandes APDU ordinaires (bien qu'il semble fonctionner sans d√©finir de param√®tres d'√©change, c'est-√†-dire qu'il suffisait de faire une r√©initialisation logicielle et de lire ATR). <br><br><h2>  Ex√©cution des commandes APDU </h2><br>  <b>Chaque cycle d'ex√©cution des commandes APDU comprend les √©tapes suivantes:</b> <br><br><ol><li>  Envoyer APDU (commande de transmission de donn√©es ma√Ætre √† esclave). </li><li>  Attendez le temps de protection pour recevoir et traiter la commande. </li><li>  Attendez que le traitement de la commande lise l'√©tat (commande Status). </li><li>  Lire les donn√©es de r√©ponse (commande de transmission des donn√©es esclave √† ma√Ætre). </li></ol><br>  Cette logique est impl√©ment√©e dans les fonctions <b>sci2c_apdu_send</b> et <b>sci2c_apdu_recv</b> , et il y a un point important ici: dans le format du protocole Smart Card I2C, il y a des compteurs des commandes APDU transmises.  Ces compteurs doivent contr√¥ler √† la fois les dispositifs ma√Ætre et esclave et ils sont con√ßus pour contr√¥ler la s√©quence des donn√©es transmises, de sorte qu'en cas d'erreur de r√©ception, il serait possible de transmettre ou de demander √† nouveau des donn√©es APDU. <br><br>  Des exemples de la mise en ≈ìuvre de ces fonctions peuvent √™tre trouv√©s dans le code, et ci-dessous ne sont que des commandes APDU et des donn√©es de r√©ponse. <br><br><h3>  Exemple de fiche technique: </h3><br>  C-APDU =&gt; <b>00 A4 04 04 04 54 65 73 74 00</b> - lire le fichier avec le nom "Test". <br>  R-APDU &lt;= <b>6A 86</b> - selon la fiche technique, la r√©ponse devrait √™tre <b>64 82</b> ( <i>fichier ou application introuvable</i> ), mais dans notre cas le firmware est t√©l√©charg√© sur le microcircuit, et la r√©ponse diff√®re de l'exemple d√©crit dans la documentation. <br><br><h3>  Cycle de vie de production des cartes de lecture </h3><br>  C-APDU =&gt; <b>80 CA 9F 7F 00</b> <br>  R-APDU &lt;= <b>9F 7F 2A 47 90 51 67 47 91 12 10 38 00 53 56 00 40 39 93 73 50 48 12 53 63 00 00 00 00 13 2C 19 30 34 30 33 39 00 00 00 00 00 00 00 00 90 00</b> <br><br><h3>  Lire Lire les informations de la carte </h3><br><br>  C-APDU =&gt; <b>80 CA 00 66 00</b> <br>  R-APDU &lt;= <b>66 4C 73 4A 06 07 2A 86 48 86 FC 6B 01 60 0C 06 0A 2A 86 48 86 FC 6B 02 02 01 01 63 09 06 07 2A 86 48 86 FC 6B 03 64 0B 06 09 2A 86 48 86 FC 6B 04 02 55 65 0B 06 09 2B 85 10 86 48 64 02 01 03 66 0C 06 0A 2B 06 01 04 01 2A 02 6E 01 02 90 00</b> <br><br><h3>  Lire Lire les informations cl√©s </h3><br>  C-APDU =&gt; <b>80 CA 00 E0 00</b> <br>  R-APDU &lt;= <b>E0 12 C0 04 01 FF 80 10 C0 04 02 FF 80 10 C0 04 03 FF 80 10 90 00</b> <br><br><h2>  En conclusion </h2><br>  Cette exp√©rience de mise en ≈ìuvre de l'√©change d'√©quipes APDU via l'interface I2C a √©t√© tr√®s int√©ressante.  Je me suis m√™me retrouv√© √† penser √† plusieurs reprises que j'aimais r√©soudre divers probl√®mes dans le domaine des circuits, et aussi de la soudure ordinaire, depuis la derni√®re fois que j'ai d√ª prendre un fer √† souder il y a plus de 5 ans. <br><br>  J'esp√®re que cet article sera utile et aidera √† comprendre ceux qui s'int√©ressent √† ce sujet.  √âcrivez si le mat√©riel vous int√©resse.  Je vais essayer de r√©pondre √† toutes les questions de cet article, et si le sujet de l'utilisation du protocole Smart Card I2C est int√©ressant, je vais essayer de le divulguer plus en d√©tail dans les publications suivantes. <br><br><h2>  R√©f√©rences: </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Description de l'interface I2C (SMBus)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fiche technique sur microcontr√¥leur A7001AG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Description du protocole de la carte √† puce I2C</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GOST R ISO / IEC 7816-3-2013</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GOST R ISO / IEC 7816-4-2013</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439574/">https://habr.com/ru/post/fr439574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439564/index.html">Application pratique de la transformation d'arbre AST en utilisant le putout comme exemple</a></li>
<li><a href="../fr439566/index.html">Pourquoi la documentation SRE est importante. 3e partie</a></li>
<li><a href="../fr439568/index.html">SSD bas√©s sur QLC - un tueur de disque dur? Pas vraiment</a></li>
<li><a href="../fr439570/index.html">Magie IPython pour modifier les balises de cellules Jupyter</a></li>
<li><a href="../fr439572/index.html">Conception assist√©e par ordinateur d'√©quipements √©lectroniques</a></li>
<li><a href="../fr439576/index.html">Un aper√ßu complet des interviews Python. Trucs et astuces</a></li>
<li><a href="../fr439578/index.html">A la question des transformations et autres op√©rations</a></li>
<li><a href="../fr439580/index.html">Faire fonctionner Git pour Windows dans ReactOS</a></li>
<li><a href="../fr439584/index.html">Le projet Lenergy comme repenser les alimentations portables</a></li>
<li><a href="../fr439586/index.html">Le protocole SPBm comme fondement de Extreme Automated Campus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>