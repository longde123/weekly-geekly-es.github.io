<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ñ´Ô∏è üòÇ üìõ M√©tricas de desempenho para pesquisar aplicativos da Web incrivelmente r√°pidos üëéüèæ üë¶üèº üçß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="H√° um ditado: "O que voc√™ n√£o pode medir, n√£o pode melhorar". O autor do artigo, cuja tradu√ß√£o estamos publicando hoje, trabalha para Superhuman . Ele...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√©tricas de desempenho para pesquisar aplicativos da Web incrivelmente r√°pidos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/470872/">  H√° um ditado: "O que voc√™ n√£o pode medir, n√£o pode melhorar".  O autor do artigo, cuja tradu√ß√£o estamos publicando hoje, trabalha para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Superhuman</a> .  Ele diz que esta empresa est√° desenvolvendo o cliente de email mais r√°pido do mundo.  Aqui falaremos sobre o que √© "r√°pido" e como criar ferramentas para medir o desempenho de aplicativos da Web incrivelmente r√°pidos. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/q6/af/pp/q6afppxtd4rv6r-iqwvk9-6nyai.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Medi√ß√£o de velocidade da aplica√ß√£o</font> </h2><br>  Em um esfor√ßo para melhorar nosso desenvolvimento, passamos muito tempo medindo sua velocidade.  E, como se viu, as m√©tricas de desempenho s√£o indicadores surpreendentemente dif√≠ceis de entender e aplicar. <br><br>  Por um lado, √© dif√≠cil projetar m√©tricas que descrevam com precis√£o as sensa√ß√µes que o usu√°rio experimenta enquanto trabalha com o sistema.  Por outro lado, n√£o √© f√°cil criar m√©tricas t√£o precisas que suas an√°lises permitam que voc√™ tome decis√µes informadas.  Como resultado, muitas equipes de desenvolvimento n√£o podem confiar nos dados que coletam sobre o desempenho de seus projetos. <br><br>  Mesmo que os desenvolvedores tenham m√©tricas confi√°veis ‚Äã‚Äãe precisas, us√°-las n√£o √© f√°cil.  Como definir o termo "r√°pido"?  Como encontrar um equil√≠brio entre velocidade e consist√™ncia?  Como aprender a detectar rapidamente a degrada√ß√£o do desempenho ou a avaliar o impacto das otimiza√ß√µes no sistema? <br><br>  Aqui, queremos compartilhar algumas id√©ias sobre o desenvolvimento de ferramentas de an√°lise de desempenho de aplicativos da web. <br><br><h2>  <font color="#3AC1EF">1. Usando o "rel√≥gio" certo</font> </h2><br>  O JavaScript possui dois mecanismos para recuperar registros de data e hora: <code>performance.now()</code> e <code>new Date()</code> . <br><br>  Como eles diferem?  As duas diferen√ßas a seguir s√£o fundamentais para n√≥s: <br><br><ul><li>  O m√©todo <code>performance.now()</code> √© muito mais preciso.  A precis√£o do <code>new Date()</code> construto <code>new Date()</code> √© de ¬± 1 ms, enquanto a precis√£o de <code>performance.now()</code> j√° √© de ¬± 100 ¬µs (sim, trata-se de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">microssegundos</a> !). </li><li>  Os valores retornados pelo m√©todo <code>performance.now()</code> sempre aumentam a uma taxa constante e s√£o independentes da hora do sistema.  Este m√©todo simplesmente mede intervalos de tempo sem focar na hora do sistema.  E na <code>new Date()</code> hora <code>new Date()</code> sistema afeta.  Se voc√™ reorganizar o rel√≥gio do sistema, ele tamb√©m mudar√° o que <code>new Date ()</code> retorna, e isso arruinar√° os dados de monitoramento de desempenho. </li></ul><br>  Embora os ‚Äúrel√≥gios‚Äù representados pelo m√©todo <code>performance.now()</code> sejam obviamente muito mais adequados para medir intervalos de tempo, eles tamb√©m n√£o s√£o ideais.  Tanto o <code>performance.now()</code> quanto o <code>new Date()</code> sofrem do mesmo problema, que se manifesta no caso de o sistema estar em estado de suspens√£o: as medi√ß√µes incluem o tempo em que a m√°quina nem estava ativa. <br><br><h2>  <font color="#3AC1EF">2. Verificando a Atividade do Aplicativo</font> </h2><br>  Se voc√™, medindo o desempenho de um aplicativo Web, alterne de sua guia para outra - isso interromper√° o processo de coleta de dados.  Porque  O fato √© que o navegador restringe os aplicativos localizados nas guias em segundo plano. <br><br>  H√° duas situa√ß√µes nas quais as m√©tricas podem ser distorcidas.  Como resultado, o aplicativo parecer√° muito mais lento do que realmente √©. <br><br><ol><li>  O computador entra no modo de suspens√£o. </li><li>  O aplicativo √© executado na guia segundo plano do navegador. </li></ol><br>  A ocorr√™ncia de ambas as situa√ß√µes n√£o √© incomum.  Felizmente, temos duas op√ß√µes para resolv√™-los. <br><br>  Primeiro, podemos simplesmente ignorar m√©tricas distorcidas, descartando resultados de medi√ß√£o que diferem muito de alguns valores razo√°veis.  Por exemplo, o c√≥digo chamado quando um bot√£o √© pressionado simplesmente n√£o pode ser executado por 15 minutos!  Talvez seja a √∫nica coisa que voc√™ precisa para lidar com os dois problemas descritos acima. <br><br>  Em segundo lugar, voc√™ pode usar a propriedade <code>document.hidden</code> e o evento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">privacychange</a> .  O evento de <code>visibilitychange</code> √© aumentado quando o usu√°rio alterna da guia de interesse do navegador para outra guia ou retorna para a guia de seu interesse.  √â chamado quando a janela do navegador minimiza ou maximiza quando o computador come√ßa a trabalhar, saindo do modo de suspens√£o.  Em outras palavras, √© exatamente disso que precisamos.  Al√©m disso, desde que a guia esteja em segundo plano, a propriedade <code>document.hidden</code> √© <code>true</code> . <br><br>  Aqui est√° um exemplo simples que demonstra o uso da propriedade <code>document.hidden</code> e o evento <code>visibilitychange</code> . <br><br><pre> <code class="plaintext hljs">let lastVisibilityChange = 0 window.addEventListener('visibilitychange', () =&gt; {  lastVisibilityChange = performance.now() }) //    ,      , //  ,   ,     if (metric.start &lt; lastVisibilityChange || document.hidden) return</code> </pre> <br>  Como voc√™ pode ver, descartamos alguns dados, mas isso √© bom.  O fato √© que esses s√£o dados relacionados aos per√≠odos do programa em que n√£o √© poss√≠vel usar totalmente os recursos do sistema. <br><br>  Agora conversamos sobre indicadores que n√£o nos interessam.  Mas h√° muitas situa√ß√µes, os dados coletados s√£o muito interessantes para n√≥s.  Vamos ver como coletar esses dados. <br><br><h2>  <font color="#3AC1EF">3. Procure o indicador que permite capturar melhor a hora em que o evento come√ßou</font> </h2><br>  Um dos recursos mais controversos do JavaScript √© que o loop de eventos para esse idioma √© de thread √∫nico.  Em um determinado momento, apenas um trecho de c√≥digo √© capaz de executar, cuja execu√ß√£o n√£o pode ser interrompida. <br><br>  Se o usu√°rio pressionar o bot√£o durante a execu√ß√£o de um determinado c√≥digo, o programa n√£o saber√° at√© que a execu√ß√£o desse c√≥digo seja conclu√≠da.  Por exemplo, se o aplicativo gastou 1000 ms em um ciclo cont√≠nuo e o usu√°rio pressionou o bot√£o <code>Escape</code> 100 ms ap√≥s o in√≠cio do ciclo, o evento n√£o ser√° gravado por outros 900 ms. <br><br>  Isso pode distorcer gravemente as m√©tricas.  Se precisarmos de precis√£o na medi√ß√£o exata de como o usu√°rio percebe trabalhar com o programa, esse √© um problema enorme! <br><br>  Felizmente, resolver esse problema n√£o √© t√£o dif√≠cil.  Se estamos falando sobre o evento atual, podemos, em vez de usar <code>performance.now()</code> (a hora em que vimos o evento), usar <code>window.event.timeStamp</code> (a hora em que o evento foi criado). <br><br>  O registro de data e hora do evento √© definido pelo processo principal do navegador.  Como esse processo n√£o bloqueia quando o loop de eventos JS est√° bloqueado, <code>event.timeStamp</code> fornece informa√ß√µes muito mais valiosas sobre quando o evento foi realmente disparado. <br><br>  Deve-se notar que esse mecanismo n√£o √© ideal.  Portanto, entre o momento em que o bot√£o f√≠sico √© pressionado e o momento em que o evento correspondente chega no Chrome, decorrem 9 a 15 ms de tempo n√£o contabilizado ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui est√° um</a> excelente artigo do qual voc√™ pode saber por que isso acontece). <br><br>  No entanto, mesmo que possamos medir o tempo que leva para o evento chegar ao Chrome, n√£o devemos incluir esse tempo em nossas m√©tricas.  Porque  O fato √© que n√£o podemos introduzir essas otimiza√ß√µes no c√≥digo que podem afetar significativamente esses atrasos.  N√£o podemos melhor√°-los de nenhuma maneira. <br><br>  Como resultado, se falarmos em encontrar o registro de data e hora para o in√≠cio do evento, o indicador <code>event.timeStamp</code> parecer√° mais adequado aqui. <br><br>  Qual √© a melhor estimativa de quando o evento termina? <br><br><h2>  <font color="#3AC1EF">4. Desligue o cron√¥metro em requestAnimationFrame ()</font> </h2><br>  Mais uma consequ√™ncia segue os recursos do dispositivo de loop de eventos em JavaScript: algum c√≥digo que n√£o est√° relacionado ao seu c√≥digo pode ser executado depois dele, mas antes que o navegador exiba uma vers√£o atualizada da p√°gina na tela. <br><br>  Considere, por exemplo, React.  Depois de executar seu c√≥digo, o React atualiza o DOM.  Se voc√™ medir apenas o tempo no seu c√≥digo, significa que n√£o medir√° o tempo que levou para executar o c√≥digo React. <br><br>  Para medir esse tempo extra, usamos <code>requestAnimationFrame()</code> para desligar o cron√¥metro.  Isso √© feito apenas quando o navegador est√° pronto para gerar o pr√≥ximo quadro. <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; { metric.finish(performance.now()) })</code> </pre> <br>  Aqui est√° o ciclo de vida do quadro (o diagrama √© retirado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">deste</a> material maravilhoso sob <code>requestAnimationFrame</code> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/403/439/0d4/4034390d4dd3060d8653bf03d72d4ca2.png"></div><br>  <i><font color="#999999">Ciclo de vida do quadro</font></i> <br><br>  Como voc√™ pode ver nesta figura, <code>requestAnimationFrame()</code> √© chamado ap√≥s a conclus√£o do processador, logo antes do quadro ser exibido.  Se desligar o cron√¥metro aqui, significa que podemos ter certeza absoluta de que tudo o que levou algum tempo para atualizar a tela est√° inclu√≠do nos dados coletados no intervalo de tempo. <br><br>  At√© a√≠ tudo bem, mas agora a situa√ß√£o est√° se tornando bastante complicada ... <br><br><h2>  <font color="#3AC1EF">5. Ignorando o tempo necess√°rio para criar um layout de p√°gina e sua visualiza√ß√£o.</font> </h2><br>  O diagrama anterior, mostrando o ciclo de vida de um quadro, ilustra outro problema que encontramos.  No final do ciclo de vida do quadro, existem blocos de Layout (formando um layout de p√°gina) e Paint (exibindo uma p√°gina).  Se voc√™ n√£o levar em considera√ß√£o o tempo necess√°rio para concluir essas opera√ß√µes, o tempo medido por n√≥s ser√° menor que o tempo necess√°rio para que alguns dados atualizados apare√ßam na tela. <br><br>  Felizmente, <code>requestAnimationFrame</code> tem outro √°s na manga.  Quando a fun√ß√£o passada por <code>requestAnimationFrame</code> chamada, um registro de data e hora √© passado para essa fun√ß√£o, indicando o hor√°rio de in√≠cio da forma√ß√£o do quadro atual (ou seja, aquele localizado na parte esquerda do diagrama).  Esse registro de data e hora geralmente est√° muito pr√≥ximo do hor√°rio final do quadro anterior. <br><br>  Como resultado, a desvantagem acima pode ser corrigida medindo o tempo total decorrido desde o momento do <code>event.timeStamp</code> at√© a hora do in√≠cio da forma√ß√£o do pr√≥ximo quadro.  Observe o <code>requestAnimationFrame</code> aninhado: <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; {  requestAnimationFrame((timestamp) =&gt; { metric.finish(timestamp) }) })</code> </pre> <br>  Embora o que √© mostrado acima pare√ßa uma excelente solu√ß√£o para o problema, no final, decidimos n√£o usar esse design.  O fato √© que, embora essa t√©cnica permita obter dados mais confi√°veis, a precis√£o desses dados √© reduzida.  Os quadros no Chrome s√£o formados com uma frequ√™ncia de 16 ms.  Isso significa que a maior precis√£o dispon√≠vel para n√≥s √© de ¬± 16 ms.  E se o navegador estiver sobrecarregado e pular quadros, a precis√£o ser√° ainda menor e essa deteriora√ß√£o ser√° imprevis√≠vel. <br><br>  Se voc√™ implementar esta solu√ß√£o, uma grande melhoria no desempenho do seu c√≥digo, como acelerar uma tarefa que foi executada anteriormente 32 ms, at√© 15 ms, pode n√£o afetar os resultados da medi√ß√£o de desempenho. <br><br>  Sem levar em considera√ß√£o o tempo necess√°rio para criar um layout de p√°gina e sua sa√≠da, obtemos m√©tricas muito mais precisas (¬± 100 Œºs) para o c√≥digo que est√° sob nosso controle.  Como resultado, podemos obter uma express√£o num√©rica de qualquer melhoria feita nesse c√≥digo. <br><br>  Tamb√©m exploramos uma ideia semelhante: <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; {  setTimeout(() =&gt; { metric.finish(performance.now()) } })</code> </pre> <br>  Isso incluir√° o tempo de renderiza√ß√£o, mas a precis√£o do indicador n√£o ser√° limitada a ¬± 16 ms.  No entanto, decidimos n√£o usar essa abordagem tamb√©m.  Se o sistema encontrar um evento de entrada longo, a chamada para qual <code>setTimeout</code> transmitido poder√° ser significativamente atrasada e executada ap√≥s a atualiza√ß√£o da interface do usu√°rio. <br><br><h2>  <font color="#3AC1EF">6. Esclarecimento da ‚Äúporcentagem de eventos abaixo da meta‚Äù</font> </h2><br>  Estamos desenvolvendo um projeto e focando no alto desempenho, tentando otimiz√°-lo de duas maneiras: <br><br><ol><li>  Velocidade.  O tempo de execu√ß√£o da tarefa mais r√°pida deve ser o mais pr√≥ximo poss√≠vel de 0 ms. </li><li>  Uniformidade.  O tempo de execu√ß√£o da tarefa mais lenta deve ser o mais pr√≥ximo do tempo de execu√ß√£o da tarefa mais r√°pida. </li></ol><br>  Devido ao fato de esses indicadores mudarem ao longo do tempo, eles s√£o dif√≠ceis de visualizar e n√£o s√£o f√°ceis de discutir.  √â poss√≠vel criar um sistema de visualiza√ß√£o desses indicadores que nos inspiraria a otimizar velocidade e uniformidade? <br><br>  Uma abordagem t√≠pica √© medir o percentil 90 de atraso.  Essa abordagem permite desenhar um gr√°fico de linhas ao longo do eixo Y, no qual o tempo em milissegundos √© salvo.  Este gr√°fico permite ver que 90% dos eventos est√£o abaixo do gr√°fico de linhas, ou seja, eles s√£o executados mais rapidamente do que o tempo indicado pelo gr√°fico de linhas. <br><br>  Sabe-se que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">100 ms</a> √© o limite entre o que √© percebido como "r√°pido" e "lento". <br><br>  Mas o que descobriremos sobre como os usu√°rios se sentem no trabalho se soubermos que o 90¬∫ percentil de atraso √© de 103 ms?  Nem tanto.  Quais indicadores fornecer√£o aos usu√°rios usabilidade?  N√£o h√° como saber isso com certeza. <br><br>  Mas e se soubermos que o 90¬∫ percentil de atraso √© de 93 ms?  H√° um sentimento de que 93 √© melhor que 103, mas n√£o podemos dizer mais nada sobre esses indicadores, bem como o que eles significam em termos de percep√ß√£o do projeto pelo usu√°rio.  Novamente, n√£o h√° resposta exata para essa pergunta. <br><br>  N√≥s encontramos uma solu√ß√£o para este problema.  Consiste em medir a porcentagem de eventos cujo tempo de execu√ß√£o n√£o excede 100 ms.  H√° tr√™s grandes vantagens nessa abordagem: <br><br><ul><li>  A m√©trica √© orientada ao usu√°rio.  Ela pode nos dizer qual a porcentagem de tempo que nosso aplicativo √© r√°pido e qual a porcentagem de usu√°rios que o percebem t√£o r√°pido. </li><li>  Essa m√©trica nos permite retornar as medi√ß√µes com a precis√£o perdida devido ao fato de n√£o termos medido o tempo necess√°rio para concluir as tarefas no final do quadro (falamos sobre isso na se√ß√£o No. 5).  Devido ao fato de definirmos um indicador de meta que se encaixa em v√°rios quadros, os resultados das medi√ß√µes que se aproximam desse indicador acabam sendo inferiores a ele ou mais. </li><li>  Essa m√©trica √© mais f√°cil de calcular.  Basta calcular o n√∫mero de eventos cujo tempo de execu√ß√£o est√° abaixo do indicador de destino e depois disso - dividi-los pelo n√∫mero total de eventos.  Os percentis s√£o muito mais dif√≠ceis de contar.  Existem aproxima√ß√µes eficazes, mas para fazer tudo certo, voc√™ precisa levar em considera√ß√£o cada dimens√£o. </li></ul><br>  Essa abordagem tem apenas um sinal de menos: se os indicadores forem piores que a meta, n√£o ser√° f√°cil perceber a melhora. <br><br><h2>  <font color="#3AC1EF">7. O uso de v√°rios limiares na an√°lise de indicadores</font> </h2><br>  Para visualizar o resultado da otimiza√ß√£o de desempenho, introduzimos v√°rios valores limite adicionais em nosso sistema - acima de 100 ms e abaixo. <br><br>  Agrupamos os atrasos assim: <br><br><ul><li>  Menos de 50 ms (r√°pido). </li><li>  50 a 100 ms (bom). </li><li>  100 a 1000 ms (lento). </li><li>  Mais de 1000 ms (terrivelmente lento). </li></ul><br>  Resultados "terrivelmente lentos" nos permitem ver que perdemos muito em algum lugar.  Portanto, destacamos em vermelho brilhante. <br><br>  O que cabe em 50 ms √© muito sens√≠vel a altera√ß√µes.  Aqui, as melhorias de desempenho geralmente s√£o vis√≠veis muito antes de serem vistas em um grupo que corresponde a 100 ms. <br><br>  Por exemplo, o gr√°fico a seguir visualiza o desempenho da exibi√ß√£o de threads no Superhuman. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb5/773/9e8/eb57739e82476e3b7a2c9212908ff5bf.png"></div><br>  <i><font color="#999999">Ver t√≥pico</font></i> <br><br>  Ele mostra o per√≠odo de decl√≠nio do desempenho e, em seguida, os resultados das melhorias.  √â dif√≠cil avaliar a queda no desempenho se voc√™ observar apenas os indicadores correspondentes a 100 ms (as partes superiores das colunas azuis).  Ao analisar os resultados que se encaixam em 50 ms (as partes superiores das colunas verdes), os problemas de desempenho j√° s√£o vis√≠veis muito mais claramente. <br><br>  Se us√°ssemos a abordagem tradicional para o estudo de m√©tricas de desempenho, provavelmente n√£o ter√≠amos notado um problema cujo efeito no sistema √© mostrado na figura anterior.  Mas, gra√ßas √† maneira como realizamos medi√ß√µes e visualizamos nossas m√©tricas, conseguimos encontrar e resolver rapidamente um problema. <br><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  Verificou-se que era surpreendentemente dif√≠cil encontrar a abordagem correta para trabalhar com m√©tricas de desempenho.  Conseguimos desenvolver uma metodologia que nos permite criar ferramentas de alta qualidade para medir o desempenho de aplicativos da web.  Ou seja, estamos falando sobre o seguinte: <br><br><ol><li>  A hora de in√≠cio de um evento √© medida usando <code>event.timeStamp</code> . </li><li>  O hor√°rio de t√©rmino do evento √© medido usando <code>performance.now()</code> no retorno de chamada passado para <code>requestAnimationFrame()</code> . </li><li>  Tudo o que acontece com o aplicativo enquanto ele est√° na guia inativa do navegador √© ignorado. </li><li>  Os dados s√£o agregados usando um indicador, que pode ser descrito como "a porcentagem de eventos que est√£o abaixo da meta". </li><li>  Os dados s√£o visualizados com v√°rios n√≠veis de valores limite. </li></ol><br>  Essa t√©cnica fornece as ferramentas para criar m√©tricas confi√°veis ‚Äã‚Äãe precisas.  Voc√™ pode criar gr√°ficos que mostram claramente uma queda no desempenho e visualizar os resultados das otimiza√ß√µes.  E o mais importante - voc√™ tem a oportunidade de criar projetos r√°pidos ainda mais rapidamente. <br><br>  <b>Caros leitores!</b>  Como voc√™ analisa o desempenho de seus aplicativos da web? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt470872/">https://habr.com/ru/post/pt470872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt470856/index.html">Telegram GRAM Wallet: termos de servi√ßo</a></li>
<li><a href="../pt470858/index.html">Antiguidades: Refer√™ncia do 386¬∫ processador e dos anos 90</a></li>
<li><a href="../pt470864/index.html">Sobre as del√≠cias de mudar para o painel e n√£o apenas</a></li>
<li><a href="../pt470868/index.html">Hora do primeiro byte: o que √© e por que √© importante</a></li>
<li><a href="../pt470870/index.html">Pr√©-carregando fontes</a></li>
<li><a href="../pt470874/index.html">Otimizando o carregamento do JavaScript na Wikipedia</a></li>
<li><a href="../pt470876/index.html">Crie constru√ß√µes de sintaxe JavaScript personalizadas usando Babel. Parte 1</a></li>
<li><a href="../pt470878/index.html">Crie constru√ß√µes de sintaxe JavaScript personalizadas usando Babel. Parte 2</a></li>
<li><a href="../pt470880/index.html">Mec√¢nica de jogo. Aventura, o conceito de zero e terapia da fala convincente</a></li>
<li><a href="../pt470882/index.html">Por que voc√™ pegou meu mouse ou um jogo de tabuleiro como modelo de intera√ß√£o social</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>