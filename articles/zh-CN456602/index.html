<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚱️ 🥅 🏳️ 在iOS应用程序中实现自动更新订阅的指南 🗼 👩🏻‍⚖️ ✌🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好！ 我叫Denis，我正在开发Apphud ，该服务用于分析iOS应用程序中的自动可更新订阅。 


 在本文中，我将告诉您如何在iOS 12和iOS 13中配置，实施和验证自动更新订阅。此外，我将告诉您一些并非所有开发人员都考虑在内的细微之处和陷阱。 
 在App Store Connect...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在iOS应用程序中实现自动更新订阅的指南</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/apphud/blog/456602/"><p><img src="https://habrastorage.org/webt/qy/ut/ez/qyutezbsfdccsr1yrml6revzsbm.png" alt="图片"></p><br><p> 大家好！ 我叫Denis，我正在开发<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Apphud</a> ，该服务用于分析iOS应用程序中的自动可更新订阅。 </p><br><p> 在本文中，我将告诉您如何在iOS 12和iOS 13中配置，实施和验证自动更新订阅。此外，我将告诉您一些并非所有开发人员都考虑在内的细微之处和陷阱。 <a name="habracut"></a></p><br><h2 id="nastroyka-podpisok-v-app-store-connect"> 在App Store Connect上设置订阅 </h2><br><p> 如果您已经具有捆绑ID和创建的应用程序，则可以跳过这些步骤。 如果您是第一次创建应用程序，请执行以下操作： </p><br><p> 您必须<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Apple Developer Portal</a>上创建<em>一个明确的Bundle ID（应用程序ID）</em> 。 打开一个名为“ <em>证书，标识符和配置文件”</em>的页面，转到“ <em>标识符”</em>选项卡。 在2019年6月，Apple最终根据ASC（App Store Connect的缩写）更新了门户的布局。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fad/ba4/609/fadba4609e2e25bf48f1f9149cf81332.png" alt="2019年Apple Developer Portal的新设计"><br>  <em>2019年Apple Developer Portal的新设计</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/cbb/84c/1ea/cbb84c1eac492c0c10e18aa373272c49.png"></p><br><p>显式捆绑包ID通常以域样式（ <code>com.apphud.subscriptionstest</code> ）指定。 在“ <em>功能”</em>部分，您会注意到<em>In App Purchases</em>旁边的复选标记已被选中。 创建<em>Bundle ID</em> （ <em>App ID</em> ）后，转到App Store Connect。 </p><br><h3 id="testovye-polzovateli-sandbox-users"> 测试用户（沙盒用户） </h3><br><p> 要测试将来的购买，您将需要创建一个测试用户。 为此，请转到“ <em>用户和访问”</em>选项卡中的“ ASC”，然后转到“ <em>沙箱测试器”。</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6b9/15b/25d/6b915b25d4b0ee1374756d84c04d64a4.png" alt="用户沙箱创建表单"><br>  <em>用户沙箱创建表单</em> </p><br><blockquote> 创建测试仪时，您可以指定任何不存在的数据，最重要的是，不要忘记电子邮件和密码！ </blockquote><p> 在本文结尾处，我将讨论如何使用测试凭据来测试购买。 </p><br><p> 另一个重要步骤是在“ <em>协议，税收和银行业务</em> ”部分中设置合同和银行数据。 如果您没有付费应用程序的协议，那么您将无法测试自动续订的订阅！ </p><br><p> 之后，您可以在App Store Connect中创建一个新应用程序。 指定唯一的名称，然后选择您的<em>捆绑包ID</em>作为包<em>ID</em> 。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2b9/15d/251/2b915d25116265c73951ebe326ca672f.png" alt="包裹ID是您的捆绑ID"><br>  <em>包裹ID是您的捆绑ID</em> </p><br><p> 创建应用程序后，立即转到“ <em>功能”</em>选项卡<em>。</em> </p><br><blockquote> 如果您已经创建了应用程序，则可以继续从此处阅读。 </blockquote><p> 创建自动续订的过程包括以下几个阶段： </p><br><p>  <strong>1.创建一个订阅标识符并创建一个<em>订阅组</em> 。</strong> 订阅组是具有不同期间和价格的订阅的集合，但是在应用程序中打开相同的功能。 另外，在订阅组中，您只能激活一次免费试用期，并且只能激活一个订阅。 如果希望您的应用程序同时具有两个不同的订阅，则将需要创建两组订阅。 </p><br><p>  <strong>2.填写订阅数据：持续时间，在App Store中的显示名称（不要与名称混淆）和描述。</strong> 如果将第一个订阅添加到该组，则需要指出订阅组的显示名称。 请记住，要更频繁地保存更改，ASC可能会随时冻结并停止响应。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/62b/639/230/62b6392305ee8cd98000ba60aa408eb8.png" alt="订阅页面"><br>  <em>订阅画面</em> </p><br><p>  <strong>3.填写订阅价格。</strong> 有两个阶段：创建价格和特价。 以任何货币表示实际价格，然后自动为所有其他国家/地区重新计算。 介绍性优惠：您可以在此处为用户提供免费试用期或预付费折扣。 促销活动是在2019年最近出现在App Store上的：促销活动使您可以为未订阅和想要返回的用户提供特别折扣。 </p><br><h3 id="generaciya-sekretnogo-obschego-klyucha-shared-secret-key"> 共享密钥生成 </h3><br><p> 在包含所有已创建订阅的列表的页面上，您将看到<em>应用程序</em>按钮的<em>共享密钥</em> 。 这是在iOS应用程序中验证支票所需的特殊行。 我们将需要验证检查以确定订阅的状态。 </p><br><p> 共享密钥可以有两种类型：应用程序的唯一密钥或帐户的单个密钥。 重要提示：如果您已经在App Store中拥有该应用程序，则无论如何都不要重新创建密钥，否则用户将无法验证支票，并且您的应用程序将无法按预期运行。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/644/ce1/5d1/644ce15d1961d54f5f6cc1cf15b7dda0.png" alt="在此示例中，创建了三个订阅组和3个年度订阅。"><br>  <em>在此示例中，创建了三个订阅组和3个年度订阅。</em> </p><br><p> 复制所有订阅的ID和共享密钥，这将在以后的代码中派上用场。 </p><br><h2 id="programmnaya-chast"> 软件部分 </h2><br><p> 让我们开始实践。 做一个完整的购物经理需要什么？ 至少应执行以下操作： </p><br><ol><li><p> 结帐 </p><br></li><li><p> 检查订阅状态 </p><br></li><li><p> 检查更新 </p><br></li><li><p> 事务恢复（不要与更新支票混淆！） </p><br></li></ol><br><h3 id="oformlenie-pokupok"> 结帐 </h3><br><p> 整个购买过程可以分为两个阶段：接收产品（ <code>SKProduct</code>类）和初始化购买过程（ <code>SKPayment</code>类）。 首先，我们必须指定<code>SKPaymentTransactionObserver</code>协议的委托。 </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Starts products loading and sets transaction observer delegate @objc func startWith(arrayOfIds : Set&lt;String&gt;!, sharedSecret : String){ SKPaymentQueue.default().add(self) self.sharedSecret = sharedSecret self.productIds = arrayOfIds loadProducts() } private func loadProducts(){ let request = SKProductsRequest.init(productIdentifiers: productIds) request.delegate = self request.start() } public func productsRequest(_ request: SKProductsRequest, didReceive response: SKProductsResponse) { products = response.products DispatchQueue.main.async { NotificationCenter.default.post(name: IAP_PRODUCTS_DID_LOAD_NOTIFICATION, object: nil) } } func request(_ request: SKRequest, didFailWithError error: Error){ print("error: \(error.localizedDescription)") }</span></span></code> </pre> <br><p>  <code>IAP_PRODUCTS_DID_LOAD_NOTIFICATION</code>通知用于更新应用程序中的UI。 </p><br><p> 接下来，我们编写一个初始化购买的方法： </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">purchaseProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(product : SKProduct, success: @escaping SuccessBlock, failure: @escaping FailureBlock)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.canMakePayments() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().transactions.last?.transactionState != .purchasing <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.successBlock = success <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.failureBlock = failure <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> payment = <span class="hljs-type"><span class="hljs-type">SKPayment</span></span>(product: product) <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().add(payment) }</code> </pre> <br><p>  <code>SKPaymentTransactionObserver</code>委托看起来像这样： </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAPManager</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SKPaymentTransactionObserver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paymentQueue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> transaction <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> transactions { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (transaction.transactionState) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .purchased: <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().finishTransaction(transaction) notifyIsPurchased(transaction: transaction) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .failed: <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().finishTransaction(transaction) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"purchase error : \(transaction.error?.localizedDescription ?? "</span></span><span class="hljs-string"><span class="hljs-string">")"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.failureBlock?(transaction.error) cleanUp() <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .restored: <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().finishTransaction(transaction) notifyIsPurchased(transaction: transaction) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .deferred, .purchasing: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notifyIsPurchased</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(transaction: SKPaymentTransaction)</span></span></span></span> { refreshSubscriptionsStatus(callback: { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.successBlock?() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cleanUp() }) { (error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">// couldn't verify receipt self.failureBlock?(error) self.cleanUp() } } func cleanUp(){ self.successBlock = nil self.failureBlock = nil } }</span></span></code> </pre> <br><p> 成功订阅后，将调用委托方法，在该方法中，事务具有<code>purchased</code>状态。 </p><br><p> 但是，如何确定订阅的到期日期？ 为此，请单独向Apple请求。 </p><br><h3 id="proverka-statusa-podpiski"> 检查订阅状态 </h3><br><p> 使用对Apple的<code>verifyReceipt</code> POST请求验证了<code>verifyReceipt</code> ，我们将加密的支票作为base64编码的字符串作为参数发送，并且在响应中，我们以JSON格式收到了相同的支票。 在数组中，键<code>latest_receipt_info</code>将列出每个订阅的每个期间的所有交易，包括试用期。 我们只能解析答案并获取每个产品的当前到期日期。 </p><br><blockquote> 在WWDC 2017上，他们增加了使用<code>verifyReceipt</code>请求中的<code>exclude-old-transactions</code>密钥仅接收每个订阅的当前检查的<code>verifyReceipt</code> 。 </blockquote><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refreshSubscriptionsStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callback : @escaping SuccessBlock, failure : @escaping FailureBlock)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// save blocks for further use self.refreshSubscriptionSuccessBlock = callback self.refreshSubscriptionFailureBlock = failure guard let receiptUrl = Bundle.main.appStoreReceiptURL else { refreshReceipt() // do not call block yet return } #if DEBUG let urlString = "https://sandbox.itunes.apple.com/verifyReceipt" #else let urlString = "https://buy.itunes.apple.com/verifyReceipt" #endif let receiptData = try? Data(contentsOf: receiptUrl).base64EncodedString() let requestData = ["receipt-data" : receiptData ?? "", "password" : self.sharedSecret, "exclude-old-transactions" : true] as [String : Any] var request = URLRequest(url: URL(string: urlString)!) request.httpMethod = "POST" request.setValue("Application/json", forHTTPHeaderField: "Content-Type") let httpBody = try? JSONSerialization.data(withJSONObject: requestData, options: []) request.httpBody = httpBody URLSession.shared.dataTask(with: request) { (data, response, error) in DispatchQueue.main.async { if data != nil { if let json = try? JSONSerialization.jsonObject(with: data!, options: .allowFragments){ self.parseReceipt(json as! Dictionary&lt;String, Any&gt;) return } } else { print("error validating receipt: \(error?.localizedDescription ?? "")") } self.refreshSubscriptionFailureBlock?(error) self.cleanUpRefeshReceiptBlocks() } }.resume() }</span></span></code> </pre> <br><p> 在该方法的开头，您可以看到存在一个检查，该检查是否存在该检查的本地副本。 本地检查可能不存在，例如，是否通过iTunes安装了该应用程序。 如果没有检查，我们将无法执行<code>verifyReceipt</code>请求。 我们需要首先获取当前的本地检查，然后再次尝试对其进行验证。 使用<code>SKReceiptRefreshRequest</code>类完成检查的更新： </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refreshReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">SKReceiptRefreshRequest</span></span>(receiptProperties: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) request.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> request.start() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestDidFinish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: SKRequest)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// call refresh subscriptions method again with same blocks if request is SKReceiptRefreshRequest { refreshSubscriptionsStatus(callback: self.successBlock ?? {}, failure: self.failureBlock ?? {_ in}) } } func request(_ request: SKRequest, didFailWithError error: Error){ if request is SKReceiptRefreshRequest { self.refreshSubscriptionFailureBlock?(error) self.cleanUpRefeshReceiptBlocks() } print("error: \(error.localizedDescription)") }</span></span></code> </pre> <br><p>  <strong>检查更新是</strong>在<code>refreshReceipt()</code>函数中实现的。 如果检查成功更新，则将<code>requestDidFinish(_ request : SKRequest)</code>委托方法<code>requestDidFinish(_ request : SKRequest)</code> ，该方法<code>refreshSubscriptionsStatus</code>调用<code>refreshSubscriptionsStatus</code>方法。 </p><br><p> 购买信息的解析是如何实现的？ 我们返回一个JSON对象，其中有一个嵌套的事务数组（通过<code>latest_receipt_info</code>键）。 我们遍历该数组，使用<code>expires_date</code>键获取到期日期，如果该日期尚未到达，则将其保存。 </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> json : Dictionary&lt;String, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// It's the most simple way to get latest expiration date. Consider this code as for learning purposes. Do not use current code in production apps. guard let receipts_array = json["latest_receipt_info"] as? [Dictionary&lt;String, Any&gt;] else { self.refreshSubscriptionFailureBlock?(nil) self.cleanUpRefeshReceiptBlocks() return } for receipt in receipts_array { let productID = receipt["product_id"] as! String let formatter = DateFormatter() formatter.dateFormat = "yyyy-MM-dd HH:mm:ss VV" if let date = formatter.date(from: receipt["expires_date"] as! String) { if date &gt; Date() { // do not save expired date to user defaults to avoid overwriting with expired date UserDefaults.standard.set(date, forKey: productID) } } } self.refreshSubscriptionSuccessBlock?() self.cleanUpRefeshReceiptBlocks() }</span></span></code> </pre> <br><p> 我给出了一个简单的示例，说明如何提取订阅的当前到期日期。 没有错误处理，例如，没有检查退货（添加了<em>取消日期</em> ）。 </p><br><p> 要确定订阅是否处于活动状态，只需将当前日期与<em>用户默认值（</em>按产品密钥）中的日期进行比较即可。 如果它不存在或少于当前日期，则该订阅被视为无效。 </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expirationDateFor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> identifier : String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Date?</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">UserDefaults</span></span>.standard.object(forKey: identifier) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">Date</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subscriptionDate = <span class="hljs-type"><span class="hljs-type">IAPManager</span></span>.shared.expirationDateFor(<span class="hljs-string"><span class="hljs-string">"YOUR_PRODUCT_ID"</span></span>) ?? <span class="hljs-type"><span class="hljs-type">Date</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isActive = subscriptionDate &gt; <span class="hljs-type"><span class="hljs-type">Date</span></span>()</code> </pre> <br><p> 事务恢复在一行<code>SKPaymentQueue.default().restoreCompletedTransactions()</code> 。 此函数通过<code>func paymentQueue(**_** queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction])</code>调用委托方法<code>func paymentQueue(**_** queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction])</code>恢复所有已完成的事务。 </p><br><h3 id="chem-otlichaetsya-obnovlenie-cheka-ot-vosstanovleniya-tranzakciy"> 从事务恢复更新支票有什么区别？ </h3><br><p> 两种方法都有助于恢复您的购买数据。 但是它们有什么区别？  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">wwdc video</a>有一个很棒的桌子： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c21/520/f53/c21520f531f3df7a185296f33bfa8f2b.png" alt="从WWDC恢复购买的两种方法的差异表"><br>  <em>从WWDC恢复购买的两种方法的差异表</em> </p><br><p> 在大多数情况下，您只需要使用<code>SKReceiptRefreshRequest()</code> ，因为我们仅对收到用于后续到期日期计算的支票感兴趣。 </p><br><p> 对于自动续订的订阅，交易本身对我们而言并不重要，因此仅使用支票更新就足够了。 但是，在某些情况下，您需要使用事务恢复方法：应用程序在购买时下载内容（Apple托管的内容），还是仍然支持iOS 7以下的版本。 </p><br><h3 id="testirovanie-pokupok-sandbox-testing"> 购物测试（沙盒测试） </h3><br><p> 以前，要测试购买，您必须从iPhone设置的App Store登录。 这非常不方便（例如，整个Apple音乐库被删除了）。 但是，现在不需要这样做：沙箱帐户现在与主帐户分开存在。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/846/b0d/1d5/846b0d1d5a265e9a3f38ebeaa1bd61ef.jpg"></p><br><p> 与在App Store中进行实际购买相比，购买过程相似，但是有一些要点： </p><br><ul><li><p> 您将始终需要通过系统窗口输入登录密码。 仍不支持使用Touch ID / Face ID进行购买。 </p><br></li><li><p> 如果在正确输入登录名和密码后，系统一次又一次要求输入登录密码， <em>请单击“取消”</em> ，最小化应用程序，然后重试。 看起来像胡话，但它适用于许多人。 但是有时在第二次输入密码后，该过程仍然继续。 </p><br></li><li><p> 您将无法以任何方式测试退订过程。 </p><br></li><li><p> 订阅期的持续时间远少于实际时间。 并且每天更新不超过6次。 </p><br></li></ul><br><div class="scrollable-table"><table><thead><tr><th> 实际持续时间 </th><th> 测试时间 </th></tr></thead><tbody><tr><td>  1个星期 </td><td>  3分钟 </td></tr><tr><td>  1个月 </td><td>  5分钟 </td></tr><tr><td>  2个月 </td><td>  10分钟 </td></tr><tr><td>  3个月 </td><td>  15分钟 </td></tr><tr><td>  6个月 </td><td>  30分钟 </td></tr><tr><td>  1年 </td><td>  1小时 </td></tr></tbody></table></div><br><h3 id="chto-novogo-v-storekit-v-ios-13">  iOS 13中的StoreKit有什么新功能？ </h3><br><p> 在新版本中-仅<code>SKStorefront</code>类，它提供有关用户在App Store中注册的国家/地区的信息。 这对于在不同国家/地区使用不同订阅的开发人员可能有用。 以前，每个人都通过地理位置或设备区域进行检查，但这并未给出准确的结果。 现在，在App Store中查找国家/地区非常容易： <code>SKPaymentQueue.default().storefront?.countryCode</code> 。 如果在购买过程中App Store中的国家/地区发生变化，则还会添加方法委托。 在这种情况下，您可以自己继续或取消购买过程。 </p><br><h2 id="podvodnye-kamni-pri-rabote-s-podpiskami"> 使用订阅时的陷阱 </h2><br><ul><li>  Apple不建议直接从设备检查支票。 他们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在WWDC</a> （从5:50开始）多次谈论了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这一点，</a>并且在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中</a>对此进行了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">说明</a> 。 这是不安全的，因为攻击者可以使用中间人攻击来拦截数据。 检查检查的正确方法是使用服务器进行本地验证。 </li><li> 检查到期日期存在问题。 如果您不使用服务器，则可以将设备上的系统时间更改为较旧的时间，然后我们的代码将给出错误的结果-订阅将被视为活动状态。 如果这不适合您，那么您可以使用发布准确世界时间的任何服务。 </li><li> 并非所有用户都可以免费试用。 用户可以在一段时间后重新安装该应用程序，并且该应用程序将显示试用版照常可用。 更新检查，验证并在JSON中检查该用户是否有试用版是正确的。 许多人没有。 </li><li> 如果用户要求退款，则<code>cancellation_date</code>将被添加到订阅JSON中，但<code>expires_date</code>将保持不变。 因此，重要的是始终检查是否有<code>expires_date</code>字段的存在，这是优于<code>expires_date</code>更好的选择。 </li><li> 每次启动应用程序时都不值得更新支票，因为，首先，这毫无意义，其次，用户很可能会看到Apple ID密码输入窗口。 值得更新支票，例如，当用户本人单击“恢复购物”按钮时。 </li><li> 如何确定在什么时候值得验证支票以获取订阅的当前到期日期？ 您可以在每次开始时或仅在订阅结束时验证支票。 但是，如果您仅在订阅结束时检查支票，则已发出退款的用户将可以免费使用您的应用程序，直到该期限结束为止。 </li></ul><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 希望本文对您有所帮助。 我不仅尝试添加代码，还试图解释开发过程中的细微之处。 完整的类代码可在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>下载。 对于初学者和想要了解更多有关一切工作原理的开发人员的知识，本课程将非常有用。 对于实时应用程序，建议使用更严格的解决方案，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SwiftyStoreKit</a> 。 </p><br><blockquote> 是否想在10分钟内在iOS应用中实现订阅？ 整合<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Apphud</a>并： <br><ul><li> 仅使用一种方法进行购买； </li><li> 自动跟踪每个用户的订阅状态； </li><li> 轻松整合订阅优惠 </li><li> 将订阅事件发送到Amplitude，Mixpanel，Slack和Telegram，并考虑到用户的本地货币； </li><li> 降低应用程序的客户流失率并返回未订阅的用户。 </li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN456602/">https://habr.com/ru/post/zh-CN456602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN456582/index.html">为什么互联网仍然在线？</a></li>
<li><a href="../zh-CN456588/index.html">学习依赖注入</a></li>
<li><a href="../zh-CN456594/index.html">Webpack摇树和重新导出需要2分钟</a></li>
<li><a href="../zh-CN456596/index.html">微生物群。 测试如何进行？</a></li>
<li><a href="../zh-CN456600/index.html">Nginx食谱：带有验证码的LDAP授权</a></li>
<li><a href="../zh-CN456604/index.html">我们如何自动化大型在线商店并开始自动匹配产品</a></li>
<li><a href="../zh-CN456606/index.html">OpenStreetMap第464号世界新闻（04/04/2019-06/10/2019）</a></li>
<li><a href="../zh-CN456608/index.html">车里雅宾斯克的南桥和Kubernetes的Bitrix</a></li>
<li><a href="../zh-CN456610/index.html">不要按也不批准</a></li>
<li><a href="../zh-CN456612/index.html">在一台服务器上发布多个生产项目的数百种方法之一</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>