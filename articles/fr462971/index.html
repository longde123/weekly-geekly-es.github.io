<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤳🏿 🉐 🕴️ Utilisation des déclarations let des variables et des fonctionnalités des fermetures résultantes en JavaScript 🤙 🛌🏼 👩🏻‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'ai été inspiré pour écrire cette note en lisant l'article sur le Habré "Var, let or const? Problèmes de la portée des variables et ES6 » et leurs co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utilisation des déclarations let des variables et des fonctionnalités des fermetures résultantes en JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462971/"> J'ai été inspiré pour écrire cette note en lisant l'article sur le Habré <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Var, let or const?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Problèmes de la portée des variables et ES6 »</a> et leurs commentaires, ainsi que la partie correspondante du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">livre</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Zakas N.« Compréhension d'ECMAScript 6 »</a> .  Sur la base de ce que j'ai lu, je suis arrivé à la conclusion que tout n'est pas si simple pour évaluer l'utilisation de <i>var</i> ou <i>let</i> .  Les auteurs et les commentateurs sont enclins à croire qu'en l'absence de la nécessité de prendre en charge les anciennes versions des navigateurs, il est logique d'abandonner complètement l'utilisation de <i>var</i> , ainsi que d'utiliser certaines constructions simplifiées, au lieu des anciennes, par défaut. <br><br>  On en a déjà assez dit sur la portée de ces publicités, y compris dans les documents ci-dessus, donc je voudrais me concentrer uniquement sur certains points non évidents. <br><a name="habracut"></a><br>  Pour commencer, je voudrais considérer les <b>expressions des fonctions immédiatement appelées (Immediateely Invoked Function Expression, IIFE)</b> dans les boucles. <br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); } }(i)); } func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-comment"><span class="hljs-comment">/*    0 newECMA6add.js:4:59 1 newECMA6add.js:4:59 2 newECMA6add.js:4:59 */</span></span></code> </pre> <br>  ou vous pouvez vous en passer en utilisant <i>let</i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); }); } func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-comment"><span class="hljs-comment">/*     0 newECMA6add.js:4:37 1 newECMA6add.js:4:37 2 newECMA6add.js:4:37 */</span></span></code> </pre><br>  <i>Zakas N.</i> affirme que les deux exemples similaires, donnant le même résultat, fonctionnent également exactement de la même manière: <blockquote>  "Cette boucle fonctionne exactement comme la boucle qui utilisait var et un IIFE mais est sans doute plus propre" </blockquote>  ce que lui-même, un peu plus loin, réfute indirectement. <br><br>  Le fait est que chaque itération de la boucle lors de l'utilisation de <i>let</i> crée une variable locale séparée <i>i</i> , tandis que la liaison dans les fonctions envoyées au tableau va également séparer les variables de chaque itération. <br><br>  Dans ce cas particulier, le résultat n'est vraiment pas différent, mais que faire si on complique un peu le code? <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); } }(i)); ++i; } func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-comment"><span class="hljs-comment">/*    0 newECMA6add.js:4:59 2 newECMA6add.js:4:59 */</span></span></code> </pre> <br>  Ici, en ajoutant <i>++ i,</i> notre résultat s'est avéré tout à fait prévisible, car nous avons appelé la fonction avec des valeurs <i>i</i> qui étaient pertinentes au moment de l'appel, même lorsque la boucle elle-même est passée, donc l'opération suivante <i>++ i</i> n'a pas affecté la valeur transmise à la fonction dans le tableau, car elle déjà a été fermé dans la <i>fonction (i)</i> avec une valeur spécifique de <i>i</i> . <br><br>  Comparez maintenant avec la version <b>let</b> sans <b>IIFE</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); }); ++i; } func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-comment"><span class="hljs-comment">/*    1 newECMA6add.js:4:37 3 newECMA6add.js:4:37 */</span></span></code> </pre> <br>  Le résultat a apparemment changé et la nature de ce changement est que nous n'avons pas appelé la fonction avec la valeur tout de suite, mais la fonction a pris les valeurs disponibles dans les fermetures à des itérations spécifiques du cycle. <br><br>  Pour mieux comprendre l'essence de ce qui se passe, considérez des exemples avec deux tableaux.  Et pour commencer, prenons var, sans <b>IIFE</b> : <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = [], func2 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { func2.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); }); func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); }); ++i; } func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); func2.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-comment"><span class="hljs-comment">/*    5 newECMA6add.js:6:37 6 newECMA6add.js:6:37 7 newECMA6add.js:5:37 8 newECMA6add.js:5:37 */</span></span></code> </pre> <br>  Tout est évident jusqu'à présent - il n'y a pas de fermeture (bien que nous puissions dire que c'est le cas, mais à l'échelle mondiale, bien que ce ne soit pas tout à fait correct, car l'accès à <i>i</i> est essentiellement partout), c'est-à-dire de la même manière, mais avec une zone locale apparemment, la variable <i>i</i> aura une entrée similaire: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = [], func2 = []; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { func2.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); }); func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); }); ++i; } } test(); func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); func2.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-comment"><span class="hljs-comment">/*     5 newECMA6add.js:7:41 6 newECMA6add.js:7:41 7 newECMA6add.js:6:41 8 newECMA6add.js:6:41 */</span></span></code> </pre> <br>  Dans les deux exemples, les événements suivants se produisent: <br><br>  1. Au début de la dernière itération du cycle <i>i == 2</i> , puis incrémenté de <i>1 (++ i)</i> , et à la fin <i>1</i> plus est ajouté à partir de <i>i ++</i> , En conséquence, à la fin de tout le cycle <i>i == 4</i> . <br><br>  2. Les fonctions situées dans les tableaux <i>func1</i> et <i>func2</i> sont <i>appelées une par</i> <i>une</i> , et dans chacune d'elles la même variable <i>i est</i> incrémentée séquentiellement, ce qui est en fermeture par rapport à sa portée, ce qui est particulièrement visible lorsque nous ne traitons pas avec une variable globale, mais avec une variable locale. <br><br>  Ajoutez <b>IIFE</b> . <br>  La première option: <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = [], func2 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { func2.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); } }(i)); func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); } }(i)); ++i; } func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); func2.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-comment"><span class="hljs-comment">/*    1 newECMA6add.js:6:56 3 newECMA6add.js:6:56 1 newECMA6add.js:5:56 3 newECMA6add.js:5:56 */</span></span></code> </pre>  La deuxième option: <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = [], func2 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { func2.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); } }(++i)); func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); } }(++i)); ++i; } func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); func2.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-comment"><span class="hljs-comment">/*    2 newECMA6add.js:6:56 1 newECMA6add.js:5:56 */</span></span></code> </pre> <br>  Lors de l'ajout de l' <b>IIFE</b> dans le premier cas, nous avons simplement appelé les valeurs fixes de <i>i</i> dans la <i>fonction (i)</i> ( <i>0</i> et <i>2</i> , lors des première et deuxième passes du cycle, respectivement), et les avons incrémentées de 1, chaque fonction est distincte de l'autre, car voici la fermeture d'une variable commune il n'y a pas de boucle, du fait que la valeur <i>i a</i> été transmise immédiatement lors des passages de la boucle.  Dans le second cas, il n'y a pas non plus de fermeture de la variable de boucle, mais là la valeur a été transmise avec incrémentation simultanée, donc à la fin du premier passage <i>i == 4</i> , et la boucle n'est pas allée plus loin.  Mais j'attire l'attention sur le fait que les fermetures de variables des fonctions externes dans les fonctions internes, pour chaque fonction séparément, sont toujours présentes dans les première et deuxième variantes.  Par exemple: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = [], func2 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { func2.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); } }(i)); func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); } }(i)); ++i; } func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); func2.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); func2.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-comment"><span class="hljs-comment">/*    1 newECMA6add.js:6:56 3 newECMA6add.js:6:56 1 newECMA6add.js:5:56 3 newECMA6add.js:5:56 2 newECMA6add.js:6:56 4 newECMA6add.js:6:56 2 newECMA6add.js:5:56 4 newECMA6add.js:5:56 */</span></span></code> </pre>  <i>Remarque: même si vous encadrez le cycle avec une fonction, les fermetures courantes ne le seront naturellement pas.</i> <br><br>  Examinons maintenant la déclaration <i>let</i> , sans IIFE, respectivement. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = [], func2 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { func2.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); }); func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); }); ++i; } func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); func2.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-comment"><span class="hljs-comment">/*    2 newECMA6add.js:6:41 4 newECMA6add.js:6:41 3 newECMA6add.js:5:41 5 newECMA6add.js:5:41 */</span></span></code> </pre> <br>  Et ici, nous avons à nouveau formé un court-circuit vers la variable de boucle, et non pas un, mais deux, et non pas séparés, mais communs, ce qui est logique, étant donné le principe bien connu des cycles de passage. <br><br>  Par conséquent, nous avons cela dans la première fermeture, avant d'appeler les fonctions dans les tableaux, la valeur est <i>i == 1</i> , et dans la seconde <i>i == 3</i> .  Ce sont les valeurs que la variable <i>i a</i> reçues avant <i>i ++</i> et l'itération de boucle, mais après toutes les instructions du bloc de boucle, et elles sont fermées pour chaque itération spécifique. <br><br>  Ensuite, les fonctions situées dans le tableau <i>func1</i> sont <i>appelées</i> et elles incrémentent les variables correspondantes dans les deux fermetures et, par conséquent, dans le premier <i>i == 2</i> et dans le second <i>i == 4</i> . <br><br>  L'appel suivant à <i>func2</i> incrémente davantage et obtient <i>i == 3</i> et <i>5,</i> respectivement. <br><br>  J'ai délibérément placé <i>func2</i> et <i>func1</i> à l'intérieur du bloc de manière à ce que l'indépendance par rapport à leur emplacement soit plus clairement visible, et pour souligner l'attention du lecteur sur le fait de fermer les variables en boucle. <br><br>  Enfin, je vais vous donner un exemple trivial visant à renforcer la compréhension des fermetures et à <i>laisser la</i> portée: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func1 = []; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); }); ++i; } func1.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ func(); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); <span class="hljs-comment"><span class="hljs-comment">/* 1 newECMA6add.js:5:34 ReferenceError: i is not definednewECMA6add.js:10:1 */</span></span></code> </pre> <br><h3>  Qu'avons-nous au total </h3><br>  1. L'invocation d'expressions de fonctions immédiatement appelées n'est pas équivalente à l'utilisation de variables <i>let</i> itérables dans des fonctions en boucles et, dans certains cas, conduit à des résultats différents. <br><br>  2. Du fait que lors de l'utilisation d'une déclaration <i>let</i> pour un itérateur, une variable locale distincte est créée à chaque itération, la question se pose de l'élimination des données inutiles par le garbage collector.  À ce stade, j'admets, je voulais d'abord attirer l'attention, soupçonnant que la création d'un grand nombre de variables en grand, respectivement, des boucles ralentirait le compilateur, cependant, lors du tri d'un tableau de test en utilisant uniquement des déclarations de variables <i>let</i> , cela a montré un gain de temps d'exécution de presque deux fois pour un tableau de 100 000 cellules: <br><div class="spoiler">  <b class="spoiler_title">Option avec var:</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = [], func1 = [], func2 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100000</span></span>; i++) { arr.push(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random()); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">99999</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min, minind = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">100000</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[minind] &gt; arr[j]) minind = j; } min = arr[minind]; arr[minind] = arr[i]; arr[i] = min; func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } }(arr[i])); } func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } }(arr[<span class="hljs-number"><span class="hljs-number">99999</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100000</span></span>; i++) { func2.push(func1[i]()); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log((end - start)/<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 9.847</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Et l'option avec let:</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [], func1 = [], func2 = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100000</span></span>; i++) { arr.push(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random()); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">99999</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min, minind = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">100000</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[minind] &gt; arr[j]) minind = j; } min = arr[minind]; arr[minind] = arr[i]; arr[i] = min; func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr[i]; }); } func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr[<span class="hljs-number"><span class="hljs-number">99999</span></span>]; }); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100000</span></span>; i++) { func2.push(func1[i]()); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log((end - start)/<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 5.3</span></span></code> </pre> <br></div></div><br>  Dans le même temps, le temps d'exécution était pratiquement indépendant de la présence / absence d'instructions: <br><br><div class="spoiler">  <b class="spoiler_title">avec IIFE</b> <div class="spoiler_text"><pre> <code class="javascript hljs">func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } }(arr[i]));</code> </pre> <br></div></div>  soit <div class="spoiler">  <b class="spoiler_title">sans IIFE</b> <div class="spoiler_text"><pre> <code class="javascript hljs">func1.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr[i]; });</code> </pre> <br></div></div>  et <div class="spoiler">  <b class="spoiler_title">appel de fonction</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100000</span></span>; i++) { func2.push(func1[i]()); }</code> </pre> <br></div></div><br>  <i>Remarque: Je comprends que les informations sur la vitesse ne sont pas nouvelles, mais pour être complet, je pense que ces deux exemples valent la peine d'être donnés.</i> <br><br>  De tout cela, nous pouvons conclure que l'utilisation de déclarations <i>let</i> au lieu de <i>var</i> , dans les applications qui ne nécessitent pas de compatibilité descendante avec les normes antérieures, est plus que justifiée, en particulier dans les cas avec des boucles.  Mais, en même temps, il convient de se rappeler les caractéristiques du comportement dans les situations de fermeture et, si nécessaire, de continuer à utiliser des expressions de fonctions immédiatement appelées. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462971/">https://habr.com/ru/post/fr462971/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462961/index.html">Data Science Digest (août 2019)</a></li>
<li><a href="../fr462963/index.html">Utilisation de l'API contextuelle dans React pour créer un thème d'application global</a></li>
<li><a href="../fr462965/index.html">Relever le serveur 1c avec la publication de la base de données et des services web sous Linux</a></li>
<li><a href="../fr462967/index.html">Hacks lors de l'utilisation d'un grand nombre de petits fichiers</a></li>
<li><a href="../fr462969/index.html">Comment les autorités kazakhes tentent de couvrir leur échec avec l'introduction du certificat</a></li>
<li><a href="../fr462977/index.html">Accélérez les processus RH de routine avec RPA et BluePrism</a></li>
<li><a href="../fr462979/index.html">Aide-mémoire pour un stagiaire: résolution de problèmes étape par étape lors d'un entretien avec Google</a></li>
<li><a href="../fr462983/index.html">Voice for game dev: comment nous avons développé la quête vocale "Lovecraft World"</a></li>
<li><a href="../fr462989/index.html">BERT conversationnel - Apprenez le réseautage neuronal dans le langage des médias sociaux</a></li>
<li><a href="../fr462991/index.html">Surfer sur la vague du Web 3.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>