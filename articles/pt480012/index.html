<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüëß‚Äçüëß üï∞Ô∏è ü§±üèæ Formato Clang retarda o programa üë®üèº‚Äçüî¨ ü•• üßõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoje, mediremos o desempenho de diferentes implementa√ß√µes da fun√ß√£o toupper, porque √© isso que eles fazem √†s ter√ßas-feiras. 

 Na verdade, eu n√£o me i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Formato Clang retarda o programa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/480012/">  Hoje, mediremos o desempenho de diferentes implementa√ß√µes da fun√ß√£o toupper, porque √© isso que eles fazem √†s ter√ßas-feiras. <br><br>  Na verdade, eu n√£o me importo com a fun√ß√£o <a href="http://man7.org/linux/man-pages/man3/toupper.3.html"><i>toupper</i></a> , acabei de escrever outro post recentemente e precisava de algum tipo de n√∫cleo comum de plotagem, e o <i>toupper</i> parece ser um candidato bastante interessante e inofensivo para benchmarks.  Tentei escolher algo o mais simples poss√≠vel que n√£o me deixasse de lado, mas aconteceu que neste teste tive um problema estranho. <br><a name="habracut"></a><br>  Este post ser√° pequeno - um artigo mais abrangente sobre o t√≥pico original, talvez mais interessante, √© esperado em breve.  Se voc√™ deseja reproduzir os resultados comigo, <a href="https://github.com/travisdowns/toupper-bench">pode usar o</a> c√≥digo-fonte <a href="https://github.com/travisdowns/toupper-bench">no github</a> . <br><br>  Ent√£o, vamos dar uma olhada em tr√™s implementa√ß√µes da fun√ß√£o <i>toupper</i> , que converte os caracteres de uma matriz que consiste em elementos do tipo <i>char</i> em mai√∫sculas - ou seja, usa uma matriz como argumento e altera diretamente seus elementos para que todas as letras min√∫sculas sejam mai√∫sculas. <br><br>  Na primeira implementa√ß√£o, simplesmente chamamos <a href="https://linux.die.net/man/3/toupper">a fun√ß√£o toupper</a> [1] <a href="https://linux.die.net/man/3/toupper">da</a> biblioteca padr√£o C e executamos um loop no estilo C: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toupper_rawloop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { buf[i] = <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>(buf[i]); } }</code> </pre> <br>  Na segunda implementa√ß√£o, usamos uma abordagem <a href="https://www.youtube.com/watch%3Fv%3D2olsGf6JIkU">mais moderna</a> com a substitui√ß√£o do ciclo bruto por <i>std :: transform</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toupper_transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(buf, buf + size, buf, ::<span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>); }</code> </pre> <br>  Finalmente, na terceira implementa√ß√£o, usamos um algoritmo especial que trabalha com caracteres ASCII.  Ele verifica se o caractere est√° no intervalo <i>a - z</i> e, se for bem-sucedido, substitui a mesma letra em mai√∫scula, subtraindo o n√∫mero 32 do c√≥digo de caractere [2]: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toupper_branch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = buf[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt;= <span class="hljs-string"><span class="hljs-string">'a'</span></span> &amp;&amp; c &lt;= <span class="hljs-string"><span class="hljs-string">'z'</span></span>) { buf[i] = c - <span class="hljs-number"><span class="hljs-number">32</span></span>; } } }</code> </pre> <br>  Parece f√°cil, certo? <br><br>  Agora, mediremos a velocidade dessas implementa√ß√µes no meu laptop com o processador Skylake i7-6700HQ no compilador gcc 5.5 com configura√ß√µes padr√£o.  Os resultados s√£o apresentados na forma de um gr√°fico de dispers√£o [3]: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/ps/uf/ecpsuf8lfb6dcp2empyh6vqbkco.png"></div><br>  Imediatamente trataremos de tr√™s perguntas que s√£o irrelevantes para a nossa tarefa. <br><br>  Primeiro, observe o gr√°fico do algoritmo de ramifica√ß√£o (mostrado em verde).  Varia significativamente, dependendo do tamanho dos dados de entrada - os outros dois gr√°ficos permanecem quase planos.  Na verdade, isso √© apenas um artefato de teste.  Os caracteres ASCII de entrada s√£o selecionados aleatoriamente [4], portanto, o fator decisivo no caso da terceira implementa√ß√£o √© a opera√ß√£o do algoritmo de predi√ß√£o de ramifica√ß√£o.  Com uma pequena quantidade de dados, ele memoriza completamente a sequ√™ncia de elementos √† medida que a itera√ß√£o √© executada, de modo que o n√∫mero de erros √© pequeno e a velocidade √© alta, <a href="https://lemire.me/blog/2019/10/16/benchmarking-is-hard-processors-learn-to-predict-branches/">conforme mostrado nesta nota</a> .  √Ä medida que o tamanho da sequ√™ncia de dados aumenta, o algoritmo de previs√£o se lembra cada vez menos at√© finalmente come√ßar a falhar com cada letra mai√∫scula (0,27 falta por caractere) e, em seguida, o gr√°fico √© nivelado. <br><br>  Em segundo lugar, preste aten√ß√£o ao grupo de pontos verdes no canto superior esquerdo, correspondendo a velocidades muito mais baixas da variante com ramifica√ß√£o <i>toupper_branch</i> : <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/b6/kj/by/b6kjbygj9inzadobigp0txj3vxu.png"></div><br>  Este n√£o √© um artefato isolado: esses pontos apareceram durante v√°rios lan√ßamentos.  Ao mesmo tempo, eles n√£o poder√£o ser reproduzidos se voc√™ testar o algoritmo apenas especificamente nesses tamanhos de dados - eles aparecer√£o apenas quando o teste for executado em todos os tamanhos.  Mas neste caso, eles nem sempre aparecem.  N√£o mergulhei nisso particularmente, mas posso assumir que isso se deve a alguns conflitos de nomes ou aliases no algoritmo de previs√£o de ramifica√ß√£o ou ao mapear p√°ginas f√≠sicas de 4 KB de mem√≥ria para virtual (embora a randomiza√ß√£o do espa√ßo de endere√ßo virtual tenha sido desativada). <br><br>  Em terceiro lugar, a implementa√ß√£o de <i>toupper_rawloop</i> (mostrada em azul) no gr√°fico se parece com duas linhas separadas: uma ligeiramente acima da marca de 2 medidas por caractere e a outra no n√≠vel de 1,5 medidas por caractere.  Essas duas linhas apareceram em todos os testadores.  A op√ß√£o mais r√°pida, com uma velocidade de 1,57 caracteres por ciclo, diminui a velocidade nas portas de download: a leitura dos dados nas portas 2 e 3 ocorre a uma velocidade de 1,54 microopera√ß√µes por ciclo, portanto, elas estar√£o 98% ocupadas.  N√£o pude estabelecer a raz√£o do "regime" mais lento. <br><br>  Enquanto eu estava lidando com essa quest√£o, o r√°pido "regime" desapareceu subitamente e apenas o lento permaneceu.  Talvez o processador tenha percebido o que eu estava tentando fazer e baixado secretamente a atualiza√ß√£o do microc√≥digo para remover a contradi√ß√£o, mas eu ainda tenho uma prova - uma imagem vetorial com gr√°ficos. <br><br>  O que ent√£o nos interessa neste exemplo? <br><br>  Mas o que nos interessa √© que a vers√£o com um ciclo bruto √© 3-4 vezes mais r√°pida que a vers√£o com <i>std :: transform</i> : 1.5-2 ciclos por caractere versus 7 com alguns ciclos por caractere. <br><br>  Qual √© o problema aqui?  Algoritmos padr√£o falharam comigo?  <i>Std :: transform</i> tem alguma falha? <br><br>  Na verdade n√£o.  Mais precisamente, nem um pouco. <br><br>  Acontece que esses resultados aparecem quando as fun√ß√µes s√£o compiladas em <a href="">arquivos diferentes</a> .  Se voc√™ coloc√°-los no mesmo arquivo, o desempenho deles se tornar√° igualmente baixo. <br><br>  E n√£o, o alinhamento n√£o tem nada a ver com isso. <br><br>  Mas isso n√£o √© tudo: a vers√£o r√°pida com um ciclo bruto, quando compilada em um arquivo separado, fica mais lenta se voc√™ simplesmente anexar o arquivo de cabe√ßalho <i>&lt;algorithm&gt;</i> .  Sim, est√° certo: basta conectar este arquivo, que nunca √© usado e n√£o gera nenhum c√≥digo no arquivo final do objeto, e a velocidade do ciclo "bruto" cair√° 3-4 vezes.  Pelo contr√°rio, a vers√£o com <i>std :: transform √©</i> acelerada at√© o limite se voc√™ copiar e colar a implementa√ß√£o de <i>std :: transform</i> do arquivo <i>&lt;algorithm&gt;</i> , mas n√£o inclui esse arquivo. <br><br>  As estranhezas n√£o param por a√≠ (n√£o haver√° mais, prometo): incluir o arquivo <i>&lt;algorithm&gt;</i> nem sempre leva ao efeito descrito.  Uma queda de velocidade ocorre se o <i>&lt;algorithm&gt; estiver</i> conectado anteriormente a <i>&lt;ctype.h&gt;</i> , mas se voc√™ os trocar, n√£o haver√°: <br><br>  <b>C√≥digo lento:</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;algorithm&gt; #include &lt;ctype.h&gt;</span></span></span></span></code> </pre> <br>  <b>C√≥digo r√°pido:</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ctype.h&gt; #include &lt;algorithm&gt;</span></span></span></span></code> </pre> <br>  Na verdade, essa anomalia apareceu em mim (em outro projeto) quando o formato clang classificou automaticamente os arquivos de cabe√ßalho inclu√≠dos e colocou o <i>&lt;algorithm&gt;</i> no in√≠cio da lista, onde ele pertence (da√≠ o cabe√ßalho clickbait do artigo). <br><br>  Naturalmente, tivemos que mergulhar na lista de montadoras mais cedo ou mais tarde.  N√£o vamos atrasar esse momento desagrad√°vel. <br><br>  As vers√µes <a href="https://godbolt.org/z/DwZBJM">r√°pidas e lentas</a> das fun√ß√µes [5] s√£o mostradas abaixo, pequenos loops s√£o fornecidos com anota√ß√µes: <br><br>  <b>O &lt;algorithm&gt; se conecta primeiro:</b> <br><br><pre> <code class="cpp hljs">toupper_rawloop(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>): push rbp push rbx lea rbp, [rdi+rsi] sub rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> test rsi, rsi je .L1 mov rbx, rdi .L5: movsx edi, BYTE PTR [rbx] ;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>-  *buf add rbx, <span class="hljs-number"><span class="hljs-number">1</span></span> ; buf++ call <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span> ;  <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>(c) mov BYTE PTR [rbx<span class="hljs-number"><span class="hljs-number">-1</span></span>], al ;    buf[<span class="hljs-number"><span class="hljs-number">-1</span></span>] cmp rbp, rbx ;  buf == buf_end jne .L5 ; .L1: add rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> pop rbx pop rbp ret</code> </pre> <br>  <b>&lt;algorithm&gt; √© conectado em segundo:</b> <br><br><pre> <code class="cpp hljs">toupper_rawloop(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>): test rsi, rsi je .L7 push rbp push rbx mov rbp, rsi mov rbx, rdi sub rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> call __ctype_toupper_loc lea rsi, [rbx+rbp] mov rdi, rbx .L4: ;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>-  buf movsx rcx, BYTE PTR [rdi] ;      <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span> ; (   __ctype_toupper_loc) mov rdx, QWORD PTR [rax] ; buf++ add rdi, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>  , ;       mov edx, DWORD PTR [rdx+rcx*<span class="hljs-number"><span class="hljs-number">4</span></span>] mov BYTE PTR [rdi<span class="hljs-number"><span class="hljs-number">-1</span></span>], dl ;   cmp rsi, rdi ;  buf == end_buf jne .L4 ; add rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> pop rbx pop rbp .L7: rep ret</code> </pre> <br>  A principal diferen√ßa √© que, na vers√£o lenta, a fun√ß√£o toupper √© chamada simplesmente em loop, enquanto na vers√£o r√°pida as chamadas de fun√ß√£o est√£o completamente ausentes, e h√° apenas uma pesquisa na tabela de correspond√™ncia [6], ou seja,  o corpo da fun√ß√£o <i>std :: toupper √©</i> substitu√≠do no local da chamada. <br><br>  Se voc√™ olhar para o <a href="https://sourceware.org/git/%3Fp%3Dglibc.git%3Ba%3Dblob%3Bf%3Dctype/ctype.h%3Bh%3Dd17f727cf0dc2a0f6c62fa50aff799b175dcb426%3Bhb%3D2a764c6ee848dfe92cb2921ed3b14085f15d9e79">c√≥digo fonte da</a> biblioteca glibc, encontramos a implementa√ß√£o da fun√ß√£o <i>toupper</i> : <br><br><pre> <code class="cpp hljs">__extern_inline <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// __NTH ‚Äì  , ,      __NTH (toupper (int __c)) { return __c &gt;= -128 &amp;&amp; __c &lt; 256 ? (*__ctype_toupper_loc ())[__c] : __c; }</span></span></code> </pre> <br>  Como podemos ver, <i>toupper √©</i> definido como uma fun√ß√£o <i>externa interna</i> que primeiro verifica se o tamanho do caractere se encaixa em um byte [7] e, em seguida, procura o caractere na tabela de correspond√™ncia retornada pela fun√ß√£o <i>__ctype_toupper_loc ()</i> .  Esta fun√ß√£o retorna um ponteiro de fluxo local (do tipo <i>const int **</i> ), que, por sua vez, aponta para uma tabela de correspond√™ncia, da qual, em resposta a uma solicita√ß√£o para o nosso s√≠mbolo, sua vers√£o em mai√∫scula √© retornada [8]. <br><br>  Agora est√° claro o que est√° acontecendo na lista.  Na vers√£o r√°pida do algoritmo, o compilador substitui o corpo da fun√ß√£o <i>toupper</i> , mas n√£o pode substituir a chamada para a fun√ß√£o <i>__ctype_toupper_loc ()</i> [9].  Essa chamada, no entanto, √© declarada como <i>__atributo __ ((const))</i> , o que significa que o valor de retorno depende apenas dos argumentos (que n√£o est√£o aqui).  O compilador sabe que essa fun√ß√£o retorna o mesmo valor todas as vezes e, portanto, realiza sua chamada fora do loop, e no pr√≥prio loop existem apenas algumas opera√ß√µes de leitura associadas ao acesso √† tabela de correspond√™ncia, grava√ß√£o de um novo valor no buffer e controle do loop. <br><br>  Na vers√£o lenta, a chamada para <i>toupper ()</i> permanece no corpo do loop.  O loop em si √© mais curto em um comando, mas, √© claro, agora voc√™ ainda precisa executar todo o c√≥digo dentro da fun√ß√£o <i>toupper</i> .  No meu sistema, fica assim: <br><br><pre> <code class="cpp hljs"> lea edx,[rdi+<span class="hljs-number"><span class="hljs-number">0x80</span></span>] ; edx = rdi + <span class="hljs-number"><span class="hljs-number">0x80</span></span> movsxd rax,edi ;    c cmp edx,<span class="hljs-number"><span class="hljs-number">0x17f</span></span> ; ,  c     <span class="hljs-number"><span class="hljs-number">-128</span></span>  <span class="hljs-number"><span class="hljs-number">255</span></span> ja <span class="hljs-number"><span class="hljs-number">2</span></span>a ;  ,   mov rdx,QWORD PTR [rip+<span class="hljs-number"><span class="hljs-number">0x395f30</span></span>] ;    ;   mov rdx,QWORD PTR fs:[rdx] ;     ;     mov rdx,QWORD PTR [rdx] ;    ;    mov rdx,QWORD PTR [rdx+<span class="hljs-number"><span class="hljs-number">0x48</span></span>] ;     <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span> mov eax,DWORD PTR [rdx+rax*<span class="hljs-number"><span class="hljs-number">4</span></span>+<span class="hljs-number"><span class="hljs-number">0x200</span></span>] ;  c   <span class="hljs-number"><span class="hljs-number">2</span></span>a: ret</code> </pre> <br>  Como esta √© uma chamada n√£o incorporada, o programa trabalha mais.  Existem pelo menos cinco opera√ß√µes consecutivas de acesso √† mem√≥ria (a chamada busca de ponteiros, <i>persegui√ß√£o de ponteiros</i> ).  Na vers√£o r√°pida, apenas dois deles permanecem, pois todos os outros s√£o retirados do circuito.  O atraso entre chamar uma fun√ß√£o e sair dela deve ser de cerca de 25 ciclos, e temos cerca de 7 ciclos - isso significa que o processador conseguiu paralelizar a chamada, o que √© bastante bom, dadas as circunst√¢ncias. <br><br>  Por que isso √© assim? <br><br>  Em uma longa cadeia de arquivos include, os arquivos de cabe√ßalho C ++, como <i>&lt;algorithm&gt;</i> , incluem, por sua vez, o arquivo <i>&lt;bits / os_defines.h&gt;</i> , que cont√©m a seguinte linha: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      isanum  .  //   . #define __NO_CTYPE 1</span></span></code> </pre> <br>  Quando o arquivo <i>&lt;ctype.h&gt;</i> finalmente <i>est√°</i> conectado, por causa dessa diretiva, o c√≥digo no qual o <i>toupper √©</i> definido como <i>externo interno</i> n√£o pode ser inclu√≠do: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !defined __NO_CTYPE # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __isctype_f __isctype_f (alnum) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  ..  .. __isctype_f (xdigit) # elif defined __isctype # define isalnum(c) __isctype((c), _ISalnum) # define isalpha(c) __isctype((c), _ISalpha) //  ..  .. # endif //      # ifdef __USE_EXTERN_INLINES __extern_inline int __NTH (tolower (int __c)) { return __c &gt;= -128 &amp;&amp; __c &lt; 256 ? (*__ctype_tolower_loc ())[__c] : __c; } __extern_inline int __NTH (toupper (int __c)) { return __c &gt;= -128 &amp;&amp; __c &lt; 256 ? (*__ctype_toupper_loc ())[__c] : __c; } # endif //   tolower     # if __GNUC__ &gt;= 2 &amp;&amp; defined __OPTIMIZE__ &amp;&amp; !defined __cplusplus # define tolower(c) __tobody (c, tolower, *__ctype_tolower_loc (), (c)) # define toupper(c) __tobody (c, toupper, *__ctype_toupper_loc (), (c)) # endif /* Optimizing gcc */ #endif /* Not __NO_CTYPE. */</span></span></span></span></code> </pre> <br>  Observe que, ao conectar <i>&lt;ctype.h&gt;, a</i> vers√£o C ++ do <i>toupper</i> nunca <i>√©</i> definida como uma macro - no m√°ximo como <i>externa</i> <i>interna</i> -, pois as defini√ß√µes das macros s√£o protegidas pela <i>verifica√ß√£o! Defined __cplusplus</i> e, portanto, nunca ter√£o efeito. <br><br>  Em geral, n√£o sei ao certo se <i>__NO_CTYPE</i> nesse caso deve excluir os corpos das fun√ß√µes <i>tolower</i> e <i>toupper</i> declarados como <i>externos externos</i> , mas √© exatamente isso que acontece - e, portanto, uma queda significativa na velocidade do nosso ciclo.  Concluindo, posso dizer que, se voc√™ incluir <i>&lt;cctype&gt; em</i> vez de <i>&lt;ctype.h&gt;</i> (ou seja, C ++ √© a vers√£o do arquivo de cabe√ßalho C que coloca fun√ß√µes no <i>espa√ßo de nome std :: namespace</i> ), nesse caso, o c√≥digo funcionar√° lentamente porque <i>&lt;cctype&gt;</i> finalmente inclui <i>&lt;bits / os_defines.h&gt;</i> . <br><br>  Isso √© t√£o importante?  N√£o n√£o <br><br>  A fun√ß√£o <i>toupper</i> n√£o √© adequada para trabalhos s√©rios com caracteres de idiomas diferentes; portanto, se voc√™ precisar processar apenas caracteres ASCII, poder√° escrever sua pr√≥pria implementa√ß√£o mais r√°pida.  Se voc√™ precisar de um trabalho s√©rio com texto, provavelmente usar√° UTF-8 e precisar√° usar algum tipo de UTI para dar suporte √†s configura√ß√µes regionais ou aguarde at√© que o suporte a Unicode apare√ßa em C ++ (pode demorar muito tempo) .  Portanto, a declara√ß√£o "formato clang pode causar uma queda de 4x no desempenho" √© adequada apenas como um cabe√ßalho clickbait. <br><br>  Esse efeito √© observado em todas as vers√µes da libc?  Sim, em quase todos, mas mesmo aqui n√£o √© t√£o simples. <br><br>  Os resultados mostrados acima s√£o verdadeiros para o gcc 5.5 e glibc 2.23, desde que eu usei essas vers√µes, mas algo novo est√° acontecendo nas novas vers√µes (a partir do glibc 2.27).  L√°, ativar o <i>&lt;algorithm&gt;</i> antes de <i>&lt;ctype.h&gt;</i> ainda d√° o mesmo efeito, mas agora <i>&lt;stdlib.h&gt;</i> [10] tamb√©m cria problemas: se voc√™ ativ√°-lo antes de <i>&lt;ctype.h&gt;</i> , o desempenho tamb√©m cair√°, o que n√£o √© observado em vers√µes anteriores.  Obviamente, nas vers√µes mais recentes, o arquivo <i>&lt;stdlib.h&gt;</i> tamb√©m cont√©m a defini√ß√£o <i>__NO_CTYPE</i> .  Pelo menos, agora n√£o ser√° poss√≠vel culpar o formato clang pela classifica√ß√£o - aqui apenas pode ajudar a resolver o problema (se n√£o houver outros arquivos de problemas na lista de arquivos conectados). <br><br>  Como publiquei <a href="https://sourceware.org/bugzilla/show_bug.cgi%3Fid%3D25214">um relat√≥rio de bug na libc</a> , √© prov√°vel que esse bug seja corrigido, mas n√£o h√° d√∫vida de que erros relacionados √† ordem na qual os arquivos de cabe√ßalho est√£o conectados nos incomodar√£o ainda mais. <br><br><h2>  Coment√°rios </h2><br>  N√£o tenho um sistema de coment√°rios no meu site, mas estou trabalhando nele (ou seja, periodicamente reclamando que √© dif√≠cil fazer coment√°rios em um site est√°tico). <br><br>  Enquanto isso, voc√™ pode discutir este artigo no site do <a href="https://news.ycombinator.com/item%3Fid%3D21579333">Hacker News</a> ou em <a href="https://lobste.rs/s/tjxzck/clang_format_tanks_performance">lobste.rs</a> . <br><br><h2>  Agradecimentos </h2><br>  Gra√ßas ao usu√°rio ufo do Hacker News, que <a href="https://news.ycombinator.com/item%3Fid%3D21579483">apontou</a> que n√£o √© necess√°rio usar a fun√ß√£o lambda para adaptar o <i>std :: toupper</i> para uso no <i>std :: transform</i> , e tamb√©m a Jonathan Muller, que <a href="https://twitter.com/foonathan/status/1197051249822195712">explicou</a> que a fun√ß√£o lambda ainda √© necess√°ria. <br><br><ol><li>  Sim, a fun√ß√£o <i>toupper (3)</i> do arquivo de cabe√ßalho <i>&lt;ctype.h&gt;</i> n√£o √© adequada para trabalhar com a maioria dos caracteres n√£o ASCII, pois  n√£o pode manipular caracteres maiores que um byte, mas √© adequado para a nossa tarefa, pois passaremos apenas cadeias de caracteres ASCII. </li><li>  Na tabela ASCII, os caracteres mai√∫sculos e min√∫sculos est√£o convenientemente localizados - a uma dist√¢ncia de 32 posi√ß√µes um do outro, o que significa que voc√™ pode transferir caracteres de um caso para outro simplesmente subtraindo ou adicionando 32. Em geral, se soub√©ssemos com certeza que todas as entradas como os dados s√£o letras ASCII, poder√≠amos redefinir o quinto bit sem nenhuma verifica√ß√£o (por exemplo, <i>c &amp; 0b11011111</i> ) para transformar qualquer letra mai√∫scula em min√∫scula, enquanto isso n√£o seria refletido em letras min√∫sculas.  Mas provavelmente n√£o sabemos, ent√£o precisamos verificar se o caractere √© uma letra, para n√£o quebrar acidentalmente caracteres n√£o-letra, como <i>char</i> . </li><li>  Deve ser chamado de gr√°fico de dispers√£o com a adi√ß√£o de "ru√≠do" na localiza√ß√£o dos pontos.  De fato, este √© um diagrama de dispers√£o comum, no qual o par√¢metro de interesse para n√≥s (o tamanho dos dados de entrada) √© plotado no eixo x, e a velocidade de trabalho est√° no eixo y (medidas por s√≠mbolo - <i>quanto menor o valor, maior a velocidade</i> ).  A principal caracter√≠stica deste diagrama √© que, para cada valor de par√¢metro no eixo x, a amostragem √© realizada v√°rias vezes: nesse caso, o teste √© repetido 10 vezes para cada tamanho de matriz. </li><li>  Ou seja, os caracteres s√£o selecionados aleatoriamente e uniformemente no intervalo [32, 127]; portanto, a condi√ß√£o na fun√ß√£o ser√° verdadeira em cerca de 27% dos casos. </li><li>  Ambas as listagens se referem a uma implementa√ß√£o de ciclo bruto e diferem apenas na ordem em que os <i>arquivos</i> <i>&lt;algorithm&gt;</i> e <i>&lt;ctype.h&gt; est√£o inclu√≠dos</i> .  O c√≥digo fonte gerado √© o mesmo para todas as implementa√ß√µes - nas vers√µes r√°pida e lenta.  Por exemplo, uma implementa√ß√£o com <i>std :: transform</i> produzir√° o mesmo c√≥digo lento do assembler se voc√™ incluir o arquivo <i>&lt;algorithm&gt;</i> e o mesmo c√≥digo r√°pido se voc√™ copiar apenas a defini√ß√£o da fun√ß√£o e n√£o incluir o arquivo. </li><li>  No entanto, esse loop r√°pido √© mais lento do que poderia, porque o ponteiro para a tabela de correspond√™ncia √© lido muitas vezes ( <i>mov rdx, QWORD PTR [rax]</i> ) dentro do loop.  Esse ponteiro pode ser diferente dependendo das configura√ß√µes regionais, mas n√£o √© atualizado durante a execu√ß√£o do ciclo e, portanto, pode ser movido para fora do ciclo.  Deve ser que o compilador acredite que n√£o h√° raz√µes suficientes para isso, j√° que estamos escrevendo para uma matriz de elementos do tipo <i>char</i> , e eles podem, em princ√≠pio, ser usados ‚Äã‚Äãcomo aliases para <i>[rax]</i>  ponteiro para a mesa.  De qualquer forma, mesmo <i>__restrict__</i> n√£o ajudar√° aqui.  Mas em outra vers√£o do loop, em que os valores do <i>toupper</i> s√£o simplesmente adicionados e nada √© gravado no array, <a href="https://godbolt.org/z/Kb6pc8">essa otimiza√ß√£o √© aplicada</a> - o ponteiro √© lido fora do loop. </li><li>  Essa verifica√ß√£o n√£o √© refletida no c√≥digo substitu√≠vel do montador, pois o compilador j√° sabe que os valores de <i>caracteres</i> est√£o sempre no intervalo <i>[-128, 255]</i> .  A verifica√ß√£o √© necess√°ria apenas porque a API da fun√ß√£o <i>toupper ¬©</i> aceita um valor do tipo <i>int em</i> vez de <i>char</i> , para que o usu√°rio possa transmitir qualquer n√∫mero familiar do tipo <i>int</i> , enquanto as tabelas de correspond√™ncia s√£o projetadas apenas para valores do tipo <i>char</i> , portanto, a verifica√ß√£o ajuda a evitar a leitura fora do buffer . </li><li>  A prop√≥sito, isso explica por que os procedimentos <i>std :: toupper</i> s√£o independentes do tamanho dos dados de entrada: eles n√£o usam ramifica√ß√µes (exceto para verifica√ß√µes de intervalo, que s√£o notavelmente previstas), mas usam uma tabela de correspond√™ncia independente de ramifica√ß√£o.  <a href="https://habr.com/ru/company/pvs-studio/blog/480012/">‚Üµ</a> </li><li>  Substituir esta chamada n√£o funcionar√° mesmo com um desejo muito forte: o corpo da fun√ß√£o n√£o est√° dispon√≠vel no arquivo de cabe√ßalho. </li><li>  Eu nunca encontrei uma falha no <i>stdlib.h</i> (ou <i>&lt;algoritmo&gt;</i> , por falar nisso) - √© bem poss√≠vel que muitos outros arquivos de cabe√ßalho C e todos os arquivos de cabe√ßalho C ++ tamb√©m causem esse comportamento, apenas n√£o os testei.  Conectei o <i>stdlib.h</i> apenas para determinar o <i>tamanho_t</i> . </li></ol><br>  <b>Nota</b>  Este artigo foi publicado pela primeira vez no site <a href="https://travisdowns.github.io/blog/2019/11/19/toupper.html">Performance Matters</a> .  Os artigos traduzidos s√£o postados aqui com permiss√£o do autor. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt480012/">https://habr.com/ru/post/pt480012/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt480000/index.html">Indicador de qualidade do canal WebRTC do servidor sobre TCP</a></li>
<li><a href="../pt480002/index.html">Analise o DevOpsDays Moscow: insights de 6 relat√≥rios</a></li>
<li><a href="../pt480006/index.html">Indicador de qualidade do canal para o servidor WebRTC sobre TCP</a></li>
<li><a href="../pt480008/index.html">Yuri Rogachev: "Vim fazer o M-1, sem conhecer a inform√°tica"</a></li>
<li><a href="../pt480010/index.html">Os 3 principais elementos HTML que esquecemos</a></li>
<li><a href="../pt480016/index.html">39% das empresas russas de pequenas e m√©dias empresas enfrentam ataques cibern√©ticos direcionados</a></li>
<li><a href="../pt480018/index.html">Desenvolvimento de aplicativos m√≥veis em Python. Biblioteca KivyMD</a></li>
<li><a href="../pt480022/index.html">Instancia√ß√£o Python</a></li>
<li><a href="../pt480024/index.html">Pervinca: processador de instru√ß√£o √∫nica</a></li>
<li><a href="../pt480026/index.html">Anunciando a visualiza√ß√£o das M√°quinas Virtuais Spot do Azure</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>