<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏥 🚴🏿 🧙🏻 移动OAuth 2.0安全性 🗼 👋🏽 🆙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好！ 我是Mail.Ru Mail的信息安全专员Nikita Stupin。 不久前，我对移动OAuth 2.0进行了漏洞研究。 要创建安全的移动OAuth 2.0方案，仅以纯形式实现标准并检查redirect_uri是不够的。 有必要考虑到移动应用程序的细节并应用其他保护机制。 

 在本文中...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>移动OAuth 2.0安全性</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/417031/"><img src="https://habrastorage.org/getpro/habr/post_images/205/605/cd5/205605cd5b166f65aa8085fe1606779f.jpg"><br><br> 大家好！ 我是Mail.Ru Mail的信息安全专员Nikita Stupin。 不久前，我对移动OAuth 2.0进行了漏洞研究。 要创建安全的移动OAuth 2.0方案，仅以纯形式实现标准并检查redirect_uri是不够的。 有必要考虑到移动应用程序的细节并应用其他保护机制。 <br><br> 在本文中，我想与您分享有关对移动OAuth 2.0的攻击，保护方法和该协议的安全实现的知识。 我将在下面讨论的所有必要的保护组件都已在Mail.Ru Mail移动客户端的最新SDK中实现。 <br><a name="habracut"></a><br><h1>  OAuth 2.0的性质和功能 </h1><br>  OAuth 2.0是一种授权协议，描述了客户端服务访问服务提供商上用户资源的安全性。 同时，OAuth 2.0使得用户不必在服务提供商外部输入密码：整个过程简化为单击“我同意授予...的访问权限”按钮。 <br><br> 就OAuth 2.0而言，提供程序是一种拥有用户数据的服务，并且在用户的许可下，向第三方服务（客户端）提供对此数据的安全访问。 客户端是想要从提供者接收用户数据的应用程序。 <br><br>  OAuth 2.0协议发布后的一段时间，普通开发人员对其进行了修改以进行身份​​验证，尽管它最初并非旨在用于此目的。 身份验证将攻击向量从存储在服务提供商处的用户数据转移到用户服务用户帐户。 <br><br> 它不仅限于认证。 在移动应用程序和转换的崇高时代，仅需一个按钮即可进入应用程序。 开发人员将OAuth 2.0放在了移动轨道上。 自然，很少有人考虑过移动应用程序的安全性和特性：一次又一次地在生产中。 但是，OAuth 2.0通常无法在Web应用程序之外正常运行：在移动和桌面应用程序中都观察到相同的问题。 <br><br> 让我们弄清楚如何制作安全的移动OAuth 2.0。 <br><br><h1> 如何运作？ </h1><br> 请记住，在移动设备上，客户端可能不是浏览器，而是没有后端的移动应用程序。 因此，我们面临移动OAuth 2.0的两个主要安全问题： <br><br><ol><li> 客户端不受信任。 </li><li> 从浏览器重定向到移动应用程序的行为取决于用户安装的设置和应用程序。 </li></ol><br><h4> 移动应用程序是公共客户端 </h4><br> 为了了解第一个问题的根源，让我们看看在服务器到服务器交互的情况下OAuth 2.0的工作原理，然后在客户端到服务器交互的情况下将其与OAuth 2.0进行比较。 <br><br> 在这两种情况下，一切都始于服务客户端向服务提供者注册并接​​收<code>client_id</code>以及在某些情况下为<code>client_secret</code>的事实。  <code>client_id</code>值为public，是标识客户端服务所必需的，与<code>client_secret</code>的值为private不同。 注册过程在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC 7591</a>中有更详细的描述。 <br><br> 下图显示了OAuth 2.0在服务器到服务器通信中的操作。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f06/279/e8a/f06279e8ac68f2fe664362caec6fa063.png"><br>  <i>图片取自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tools.ietf.org/html/rfc6749#section-1.2</a></i> <br><br>  OAuth 2.0协议分为3个主要阶段： <br><br><ol><li>  [AC步骤]获取授权码（以下简称<code>code</code> ）。 </li><li>  [DE步骤]交换<code>access_token</code> <code>code</code> 。 </li><li> 使用<code>access_token</code>访问资源。 </li></ol><br> 让我们更详细地检查代码的接收： <br><br><ol><li>  [步骤A]服务客户端将用户重定向到服务提供商。 </li><li>  [步骤B]服务提供商向用户请求允许向客户端服务提供数据的权限（箭头B向上）。 用户可以访问数据（右侧的箭头B）。 </li><li>  [步骤C]服务提供商将<code>code</code>返回到用户的浏览器，该浏览器将<code>code</code>重定向<code>code</code>客户端服务。 </li></ol><br> 让我们<code>access_token</code>更详细的获取<code>access_token</code>信息： <br><br><ol><li>  [步骤D]客户端服务器发送一个<code>access_token</code>请求。 该请求包括： <code>code</code> ， <code>client_secret</code>和<code>redirect_uri</code> 。 </li><li>  [步骤E]在有效<code>code</code> <code>client_secret</code>和<code>redirect_uri</code>的情况下，提供<code>client_secret</code> 。 </li></ol><br> 对<code>access_token</code>的请求是根据服务器到服务器的方案执行的，因此，通常，为了窃取<code>client_secret</code>攻击者必须入侵服务器-客户端-服务器或服务提供商的服务器。 <br><br> 现在，让我们看看在没有后端（客户端到服务器交互）的移动设备上OAuth 2.0方案的外观。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cb/9fb/b7d/7cb9fbb7dcc35c74e921f18d22584254.png"><br>  <i>图片取自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br> 总体方案分为相同的3个主要步骤： <br><br><ol><li>  [图片中的步骤1-4]获取<code>code</code> 。 </li><li>  [图片中的步骤5-6]交换<code>access_token</code> <code>code</code> 。 </li><li> 使用<code>access_token</code>访问资源。 </li></ol><br> 但是，在这种情况下，移动应用程序还充当服务器，这意味着<code>client_secret</code>将被<code>client_secret</code>到应用程序内部。 这导致以下事实：在移动设备上，不可能对攻击者保密<code>lient_secret</code> 。  <code>client_secret</code>两种方法可以将<code>client_secret</code>到应用程序中：过滤从应用程序到服务器的流量或对应用程序进行反向工程。 两种方法都易于实现，因此<code>client_secret</code>在移动设备上毫无用处。 <br><br> 关于客户端到服务器方案，您可能会有一个问题：“为什么不立即获得<code>access_token</code> ？”。 看来，为什么我们需要额外的步骤？ 此外，存在一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">隐式授予</a>方案，其中客户端立即收到<code>access_token</code> 。 尽管可以在某些情况下使用它，但下面我们将看到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">隐式授予</a>不适用于安全的移动OAuth 2.0。 <br><br><h4> 在移动设备上重定向 </h4><br> 通常，要从浏览器重定向到移动设备上的应用程序，将使用“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自定义URI方案”</a>和“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AppLink”</a>机制。 这些机制的纯形式都不像浏览器重定向那样可靠。 <br><br> 自定义URI方案（或深层链接）的用法如下：开发人员在组装之前定义应用程序方案。 该方案可以是任意的，而在同一设备上可以安装具有相同方案的多个应用程序。 当设备上的每个应用程序都对应一个应用程序时，一切都非常简单。 但是，如果两个应用程序在同一设备上注册了相同的电路怎么办？ 访问自定义URI方案时，操作系统如何确定要打开两个应用程序中的哪个？  Android将显示一个窗口，其中包含您要在其中打开链接的应用程序的选择。 在iOS中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">未定义行为</a> ，这意味着可以打开两个应用程序中的任何一个。 在这两种情况下，攻击者<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">都可以拦截代码或access_token</a> 。 <br><br> 与自定义URI方案相比，AppLink可以确保打开正确的应用程序，但是此机制有几个缺点： <br><br><ol><li> 每个服务客户必须独立通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">验证程序</a> 。 </li><li>  Android用户可以在设置中关闭特定应用程序的AppLink。 </li><li>  6.0以下的Android和9.0以下的iOS不支持AppLink。 </li></ol><br>  AppLink的上述缺点首先会增加潜在客户服务的进入门槛，其次会导致在某些情况下用户将无法使用OAuth 2.0。 这使得AppLink不适合替换OAuth 2.0协议中的浏览器重定向。 <br><br><h1> 好吧，要攻击什么？ </h1><br> 移动OAuth 2.0的问题也引起了特定的攻击。 让我们看看它们是什么以及它们如何工作。 <br><br><a name="1"></a><h4> 授权码拦截攻击 </h4><br> 初始数据：在用户设备上安装了合法应用程序（OAuth 2.0客户端）和注册了与合法方案相同方案的恶意应用程序。 下图显示了攻击方案。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a87/336/d4c/a87336d4c0d73c89a62bb448cb12d49b.png"><br>  <i>图片取自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tools.ietf.org/html/rfc7636#section-1</a></i> <br><br> 这就是问题所在：在第4步中，浏览器通过“自定义URI方案”将<code>code</code>返回给应用程序，因此该<code>code</code>可能会被恶意软件拦截（因为它注册的程序与合法应用程序相同）。 之后，恶意软件将<code>code</code>更改为<code>access_token</code>并获得对用户数据的访问权限。 <br><br> 如何保护自己？ 在某些情况下，可以使用进程间通信机制；我们将在下面讨论它们。 在一般情况下，您需要应用一种称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码交换证明密钥</a>的方案。 其实质反映在下图中。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/123/67e/349/12367e3497cbbd54d007a18a678bfc0d.png"><br>  <i>图片取自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tools.ietf.org/html/rfc7636#section-1.1</a></i> <br><br> 在来自客户端的请求中，有几个附加参数： <code>code_verifier</code> ， <code>code_challenge</code> （在<code>t(code_verifier)</code> ）和<code>code_challenge_method</code> （在<code>t_m</code>图上）。 <br><br>  <code>Code_verifier</code>是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">长度至少为256位</a>的随机数<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">只能使用一次</a> 。 也就是说，对于<b>每个</b> <code>code</code>请求<code>code</code>客户端必须生成一个新的<code>code_verifier</code> 。 <br><br>  <code>Code_challenge_method</code>是转换函数的名称，通常是SHA-256。 <br><br>  <code>Code_challenge</code>是一个<code>code_verifier</code> ，已对其<code>code_challenge_method</code>转换并将其编码在Safe Base64 URL中。 <br><br> 在请求<code>code</code>时，必须基于对<code>code_verifier</code>的拦截（例如，来自设备的系统日志），将<code>code_challenge</code>转换为<code>code_verifier</code>以防止受到攻击矢量的<code>code_verifier</code> 。 <br><br> 如果用户的设备<b>不支持</b> SHA-256，则<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">允许降级，直到缺少code_verifier转换为止</a> 。 在所有其他情况下，您必须使用SHA-256。 <br><br> 该方案的工作原理如下： <br><br><ol><li> 客户端生成一个<code>code_verifier</code>并记住它。 </li><li> 客户端选择<code>code_challenge_method</code>并从<code>code_verifier</code>获得<code>code_verifier</code> 。 </li><li>  [步骤A]客户请求<code>code</code> ，其中<code>code_challenge</code>和<code>code_challenge_method</code>添加到请求中。 </li><li>  [步骤B]提供程序会记住服务器上的<code>code_challenge</code>和<code>code_challenge_method</code> ，并将<code>code</code>返回<code>code</code>客户端。 </li><li>  [步骤C]客户端请求<code>access_token</code> ，并将<code>access_token</code>添加到<code>code_verifier</code> 。 </li><li> 提供程序从传入的<code>code_verifier</code>接收到<code>code_challenge</code> ，然后对照他记得的<code>code_challenge</code>进行检查。 </li><li>  [步骤D]如果值匹配，则提供者<code>access_token</code>客户端发出<code>access_token</code> 。 </li></ol><br> 让我们<code>code_challenge</code>为什么<code>code_challenge</code>允许<code>code_challenge</code>保护自己免受代码拦截攻击。 为此，我们将经历获取<code>access_token</code>的阶段。 <br><br><ol><li> 首先，合法的应用程序请求<code>code</code> （ <code>code_challenge</code>和<code>code_challenge_method</code>与<b>请求</b>一起<b>发送</b> ）。 </li><li> 恶意软件拦截<code>code</code> （但不会拦截<code>code_challenge</code> ，因为<b>响应中</b>没有<code>code_challenge</code> ）。 </li><li> 恶意软件请求<code>access_token</code> （具有有效<code>code</code> ，但<b>没有</b>有效<code>code_verifier</code> ）。 </li><li> 服务器注意到<code>code_challenge</code>不匹配，并引发错误。 </li></ol><br> 请注意，攻击者无法猜测<code>code_verifier</code> （随机256位！）或在日志中的某个位置找到它（ <code>code_verifier</code>传输一次）。 <br><br> 如果将所有内容简化为一个短语，则<code>code_challenge</code>允许服务提供商回答以下问题：“ <code>access_token</code>由请求<code>code</code>的同一客户端应用程序请求，还是由另一个请求<code>code</code>客户端应用程序请求？” <br><br><h4>  OAuth 2.0 CSRF </h4><br> 在移动设备上，OAuth 2.0通常用作身份验证机制。 我们记得，通过OAuth 2.0进行的身份验证与授权不同，因为OAuth 2.0漏洞会影响服务客户端（而不是服务提供商）一侧的用户数据。 因此，对OAuth 2.0的CSRF攻击使您可以窃取他人的帐户。 <br><br> 考虑使用出租车客户端应用程序和provider.com提供程序示例的针对OAuth 2.0的CSRF攻击。 首先，攻击者在其设备上登录Attacker@provider.com并接收出租车<code>code</code> 。 之后，攻击者中断OAuth 2.0进程并生成一个链接： <br><br> <code>com.taxi.app://oauth? <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4 <br></code> <br> 然后，攻击者以出租车管理部门的信件或短信为幌子，向受害者发送链接。 受害人<code>access_token</code>链接，在她的手机上打开出租车应用程序，该应用程序接收<code>access_token</code> ，结果受害人最终进入了<b>攻击者</b>的出租车帐户。 受害人不知道渔获，使用此帐户：旅行，输入数据等。 <br><br> 现在，攻击者可以随时登录受害者的出租车帐户，因为他已绑定到<code>attacker@provider.com</code> 。  CSRF的登录攻击允许窃取帐户。 <br><br>  CSRF攻击通常使用CSRF令牌（也称为<code>state</code> ）进行保护，OAuth 2.0也不例外。 如何使用CSRF令牌： <br><br><ol><li> 客户端应用程序生成CSRF令牌并将其存储在用户的移动设备上。 </li><li> 客户端应用程序在请求<code>code</code>包含CSRF令牌。 </li><li> 服务器在响应中返回相同的CSRF令牌以及代码。 </li><li> 客户端应用程序比较传入和存储的CSRF令牌。 如果值匹配，则过程继续。 </li></ol><br>  CSRF令牌要求： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">随机数</a>至少为256位，可从良好的伪随机序列源获得。 <br><br> 简而言之，CSRF令牌允许客户端应用程序回答以下问题：“我是在开始获取<code>access_token</code>还是有人在试图欺骗我？” <br><br><h4> 假冒合法客户的恶意软件 </h4><br> 某些恶意软件可以模仿合法应用程序，并代表它们提出同意屏幕（同意屏幕是用户看到的屏幕：“我同意授予...的访问权限”）。 不专心的用户可以单击“允许”，结果，恶意软件可以访问用户数据。 <br><br>  Android和iOS提供了用于相互验证应用程序的机制。 提供者应用程序可以验证客户端应用程序的合法性，反之亦然。 <br><br> 不幸的是，如果OAuth 2.0机制通过浏览器使用流，那么您将无法防御这种攻击。 <br><br><h4> 其他攻击 </h4><br> 我们研究了移动OAuth 2.0特有的攻击。 但是，请不要忘记对常规OAuth 2.0的攻击： <code>redirect_uri</code>欺骗，不安全连接上的流量拦截等。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读有关它们的更多信息。 <br><br><h1> 怎么办 </h1><br> 我们了解了OAuth 2.0协议的工作原理，并弄清了该协议在移动设备上的实现中存在哪些漏洞。 现在，让我们从各个方面来构建一个安全的移动OAuth 2.0方案。 <br><br><h4>  OAuth 2.0的好坏 </h4><br> 让我们从如何正确​​显示同意屏幕开始。 在移动设备上，有两种方法可以从本机应用程序打开网页（本机应用程序示例：Mail.Ru Mail，VK，Facebook）。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ee/bd1/d02/7eebd1d02b5fa11a820fe37abbd1c552.png"><br><br> 第一种方法称为“浏览器自定义选项卡”（在左图中）。  <b>注意</b> ：Android上的“浏览器自定义”选项卡在iOS上称为Chrome“自定义”选项卡。 实际上，这是一个正常的浏览器标签，直接在应用程序中显示，即 应用程序之间没有视觉切换。 <br><br> 第二种方法称为“提升WebView”（如右图所示），相对于移动OAuth 2.0，我认为这很糟糕。 <br><br>  WebView是用于本机应用程序的独立浏览器。 <br><br>  “独立<i>浏览器</i> ”是指WebView不允许从Safari和Chrome浏览器访问cookie，存储，缓存，历史记录和其他数据。 反之亦然：Safari和Chrome无法访问WebView数据。 <br><br>  “ <i>本机应用程序的浏览器</i> ”是指引发WebView的本机应用程序具有对Cookie，存储，缓存，历史记录和其他WebView数据的<b>完全</b>访问权限。 <br><br> 现在想象：用户按下“使用...登录”按钮，恶意应用程序的WebView向服务提供商询问其用户名和密码。 <br><br> 在所有方面立即失败： <br><br><ol><li> 用户从应用程序中服务提供商的帐户输入用户名和密码，可以轻松窃取此数据。 </li><li>  OAuth 2.0最初是为了<i>避免输入</i>服务提供商<i>的用户名和密码</i>而开发的。 </li><li> 用户习惯于在任何地方输入登录名和密码， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">网络钓鱼</a>的可能性增加。 <br></li></ol><br> 鉴于所有论点都反对WebView，结论本身表明：提高“浏览器自定义选项卡以显示同意”屏幕。 <br><br> 如果有任何人赞成使用WebView而不是“浏览器自定义选项卡”，请在评论中写出来，我将不胜感激。 <br><br><h4> 安全移动OAuth 2.0方案 </h4><br> 我们将使用授权代码授予方案，因为它允许我们添加<code>code_challenge</code>并保护<code>code_challenge</code>免受代码拦截攻击。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cb/9fb/b7d/7cb9fbb7dcc35c74e921f18d22584254.png"><br>  <i>图片取自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br> 代码请求（步骤1-2）将如下所示： <br><br> <code>https://o2.mail.ru/code? <br> redirect_uri=com.mail.cloud.app%3A%2F%2Foauth&amp; <br> anti_csrf=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24&amp; code_challenge=ZjYxNzQ4ZjI4YjdkNWRmZjg4MWQ1N2FkZjQzNGVkODE1YTRhNjViNjJjMGY5MGJjNzdiOGEzMDU2ZjE3NGFiYw%3D%3D&amp; <br> code_challenge_method=S256&amp; <br> scope=email%2Cid&amp; <br> response_type=code&amp; <br> client_id=984a644ec3b56d32b0404777e1eb73390c <br></code> <br> 在步骤3中，浏览器收到重定向的响应： <br><br> <code>com.mail.cloud.app://outh? <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; <br> anti_csrf=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24</code> <br> <br> 在步骤4中，浏览器打开“自定义URI方案”，并将<code>code</code>和CSRF令牌传递给客户端应用程序。 <br><br> 要求<code>access_token</code> （步骤5）： <br><br> <code>https://o2.mail.ru/token? <br> code_verifier=e61748f28b7d5daf881d571df434ed815a4a65b62c0f90bc77b8a3056f174abc&amp; <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; <br> client_id=984a644ec3b56d32b0404777e1eb73390c <br></code> <br> 最后一步返回一个带有<code>access_token</code>的响应。 <br><br> 通常，上述方案是安全的，但是在某些特殊情况下，可以使OAuth 2.0变得更简单，更安全。 <br><br><h4>  Android IPC </h4><br>  Android具有在进程之间进行双向数据交换的机制：IPC（进程间通信）。 与自定义URI方案相比，首选IPC的原因有两个： <br><br><ol><li> 打开IPC通道的应用程序可以通过其证书来验证打开的应用程序的真实性。 反之亦然：打开的应用程序可以验证打开它的应用程序的真实性。 </li><li> 通过IPC通道发送请求，发送方可以通过同一通道接收响应。 连同相互验证（项目1）一起，这意味着没有第三方进程可以拦截<code>access_token</code> 。 </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/693/84d/6f6/69384d6f63788694137f8d559d6469fa.png"><br><br> 因此，我们可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">隐式授予，</a>并大大简化移动OAuth 2.0方案。 没有<code>code_challenge</code>和CSRF令牌。 此外，我们将能够保护自己免受模仿合法客户端的恶意软件的侵害，从而窃取用户帐户。 <br><br><h4> 客户SDK </h4><br> 除了实施上述的安全移动OAuth 2.0方案外，提供商还应为其客户开发一个SDK。 这将有助于在客户端实施OAuth 2.0，同时减少错误和漏洞的数量。 <br><br><h1> 得出结论 </h1><br> 对于OAuth 2.0提供程序，我编写了“安全移动OAuth 2.0检查表”： <br><br><ol><li> 坚实的基础至关重要。 在移动OAuth 2.0的情况下，基础是我们选择实现的方案或协议。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实施自己的OAuth 2.0架构时，</a>很容易出错。 其他人已经填补了障碍并做出了结论，从错误中吸取教训并立即进行安全实施并没有错。 通常，最安全的移动OAuth 2.0方案是“怎么做？”部分中的方案。 </li><li>  <code>Access_token</code>和其他敏感数据存储在iOS下-钥匙串中，Android下-内部存储中。 这些存储库是专门为此类目的而设计的。 如有必要，您可以在Android中使用Content Provider，但必须对其进行安全配置。 </li><li>  <code>Code</code>应该是一次性的，寿命很短。 </li><li> 为了防止代码被拦截，请使用<code>code_challenge</code> 。 </li><li> 为了防止登录时遭受CSRF攻击，请使用CSRF令牌。 </li><li> 不要将WebView用于同意屏幕，请使用“浏览器自定义选项卡”。 </li><li> 如果<code>Client_secret</code>没有存储在后端，则它<code>Client_secret</code> <b>无用</b>的。 不要将其提供给公共客户。 </li><li>  <b>在所有地方都</b>使用HTTPS，禁止降级为HTTP。 </li><li> 遵循标准中的加密建议（密码选择，令牌长度等）。 您可以复制数据并找出这样做的原因，但<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不能进行加密</a> 。 </li><li> 在客户端应用程序中，验证您为OAuth 2.0打开的用户，然后在提供商应用程序中，检查谁为OAuth 2.0打开的用户。 </li><li> 请注意<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通常的OAuth 2.0漏洞</a> 。 移动OAuth 2.0扩展并补充了常规OAuth 2.0，因此没有人取消过<code>redirect_uri</code>检查以获取完全匹配以及常规OAuth 2.0的其他建议。 </li><li> 确保向客户提供SDK。 客户端中的代码错误和漏洞更少，并且对他来说，实现您的OAuth 2.0更容易。 </li></ol><br><h1> 读什么 </h1><br><ol><li>  [RFC]适用于本机应用程序的OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tools.ietf.org/html/rfc8252</a> </li><li> 适用于移动和桌面应用程序的Google OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://developers.google.com/identity/protocols/OAuth2InstalledApp</a> </li><li>  [RFC] OAuth公共客户端用于代码交换的证明密钥<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tools.ietf.org/html/rfc7636</a> </li><li>  OAuth 2.0竞赛条件<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://hackerone.com/reports/55140</a> </li><li>  [RFC] OAuth 2.0威胁模型和安全注意事项<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tools.ietf.org/html/rfc6819</a> </li><li> 对常规OAuth 2.0的攻击<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://sakurity.com/oauth</a> </li><li>  [RFC] OAuth 2.0动态客户端注册协议<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tools.ietf.org/html/rfc7591</a> </li></ol><br><h1> 致谢 </h1><br> 感谢所有帮助撰写本文的人员，特别是谢尔盖·贝洛夫（Sergey Belov），安德烈·苏敏（Andrey Sumin），安德烈·拉宾兹（Andrey Labunts）（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@isciurus</a> ）和Daria Yakovleva。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN417031/">https://habr.com/ru/post/zh-CN417031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN417015/index.html">我们了解什么记录和什么不记录汉堡王申请</a></li>
<li><a href="../zh-CN417017/index.html">失败的核实验如何偶然产生中微子天文学</a></li>
<li><a href="../zh-CN417023/index.html">Rambler Group的经验：我们如何开始完全控制前端React组件的形成和行为</a></li>
<li><a href="../zh-CN417027/index.html">我如何编写标准的C ++ 11库，或者为什么boost如此令人恐惧。 引言</a></li>
<li><a href="../zh-CN417029/index.html">使用LLVM进行代码分析</a></li>
<li><a href="../zh-CN417033/index.html">6月7日的QIWI Kitchen-演讲者讲话的视频</a></li>
<li><a href="../zh-CN417035/index.html">UnnyWorld：验尸</a></li>
<li><a href="../zh-CN417037/index.html">啤酒。 灯光控制。 泼妇灯3.快速入门（1/4）</a></li>
<li><a href="../zh-CN417039/index.html">学习wordpress（以及更多）以快速渲染Youtube播放器</a></li>
<li><a href="../zh-CN417041/index.html">eslint-scope v3.7.2窃取NPM令牌</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>