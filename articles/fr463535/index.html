<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎸 🚫 👃🏿 Vérification du code source des bibliothèques .NET Core par l'analyseur statique PVS-Studio 🙇🏻 👖 🕺🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les bibliothèques .NET Core sont l'un des projets C # les plus populaires sur GitHub. Ce n'est pas une surprise, car il est largement connu et utilisé...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vérification du code source des bibliothèques .NET Core par l'analyseur statique PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/463535/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/-a/bm/pb/-abmpb2yelga7y1zu59bejm6vgo.png" alt="Image 19"></div><br>  Les bibliothèques .NET Core sont l'un des projets C # les plus populaires sur GitHub.  Ce n'est pas une surprise, car il est largement connu et utilisé.  De ce fait, une tentative de révéler les coins sombres du code source devient plus captivante.  C'est donc ce que nous allons essayer de faire avec l'aide de l'analyseur statique PVS-Studio.  Que pensez-vous - trouverons-nous finalement quelque chose d'intéressant? <br><a name="habracut"></a><br>  Je me dirige vers cet article depuis plus d'un an et demi.  À un moment donné, j'ai eu l'idée dans ma tête que les bibliothèques .NET Core sont une friandise, et sa vérification est très prometteuse.  Je vérifiais le projet plusieurs fois, l'analyseur continuait de trouver des fragments de code de plus en plus intéressants, mais cela n'allait pas plus loin que faire défiler la liste des avertissements.  Et le voici - c'est finalement arrivé!  Le projet est vérifié, l'article est juste devant vous. <br><br><h2>  Détails sur le projet et la vérification </h2><br>  Si vous vous efforcez de plonger dans l'enquête sur le code - vous pouvez omettre cette section.  Cependant, j'aimerais beaucoup que vous le lisiez, car ici j'en dis plus sur le projet et l'analyseur, ainsi que sur la réalisation de l'analyse et la reproduction des erreurs. <br><br><h3>  Projet sous contrôle </h3><br>  Peut-être que j'aurais pu ignorer ce qu'est CoreFX (bibliothèques .NET Core), mais au cas où vous n'en auriez pas entendu parler, la description est donnée ci-dessous.  C'est la même chose que sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page</a> du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet sur GitHub</a> , où vous pouvez également télécharger le code source. <br><br>  Description: <i>ce dépôt contient l'implémentation de la bibliothèque (appelée "CoreFX") pour .NET Core.</i>  <i>Il comprend System.Collections, System.IO, System.Xml et de nombreux autres composants.</i>  <i>Le référentiel .NET Core Runtime correspondant (appelé "CoreCLR") contient l'implémentation d'exécution pour .NET Core.</i>  <i>Il comprend RyuJIT, le GC .NET et de nombreux autres composants.</i>  <i>Le code de bibliothèque spécifique au runtime (System.Private.CoreLib) réside dans le référentiel CoreCLR.</i>  <i>Il doit être construit et versionné en tandem avec le runtime.</i>  <i>Le reste de CoreFX est indépendant de l'implémentation du runtime et peut être exécuté sur n'importe quel runtime .NET compatible (par exemple CoreRT)</i> . <br><br><h3>  Analyseur utilisé et méthode d'analyse </h3><br>  J'ai vérifié le code en utilisant l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>analyseur statique PVS-Studio</u></a> .  De manière générale, PVS-Studio peut analyser non seulement le code C #, mais aussi C, C ++, Java.  Jusqu'à présent, l'analyse de code C # fonctionne uniquement sous Windows, tandis que le code C, C ++, Java peut être analysé sous Windows, Linux, macOS. <br><br>  Habituellement, pour vérifier les projets C #, j'utilise le plugin PVS-Studio pour Visual Studio (prend en charge les versions 2010-2019), car c'est probablement le scénario d'analyse le plus simple et le plus pratique dans ce cas: solution ouverte, exécutez l'analyse, gérez la liste des avertissements.  Cependant, c'est sorti un peu plus compliqué avec CoreFX. <br><br>  La partie délicate est que le projet n'a pas un seul fichier .sln, donc l'ouvrir dans Visual Studio et effectuer une analyse complète, en utilisant le plugin PVS-Studio, n'est pas possible.  C'est probablement une bonne chose - je ne sais pas vraiment comment Visual Studio gérerait une solution de cette taille. <br><br>  Cependant, il n'y a eu aucun problème avec l'analyse, car la distribution PVS-Studio inclut la version en ligne de commande de l'analyseur pour les projets MSBuild (et .sln).  Tout ce que j'avais à faire était d'écrire un petit script, qui exécuterait "PVS-Studio_Cmd.exe" pour chaque .sln dans le répertoire CoreFX et enregistrer les résultats dans un répertoire séparé (il est spécifié par un drapeau de ligne de commande de l'analyseur) . <br><br>  Presto!  En conséquence, j'ai une boîte Pandora avec un ensemble de rapports stockant des choses intéressantes.  Si vous le souhaitez, ces journaux peuvent être combinés avec l'utilitaire PlogConverter, faisant partie de la distribution.  Pour moi, il était plus pratique de travailler avec des journaux distincts, donc je ne les ai pas fusionnés. <br><br>  Pour décrire certaines erreurs, je me réfère à la documentation des packages docs.microsoft.com et NuGet, téléchargeables sur nuget.org.  Je suppose que le code décrit dans la documentation / packages peut être légèrement différent du code analysé.  Cependant, il serait très étrange si, par exemple, la documentation ne décrivait pas les exceptions générées lors de la possession d'un certain ensemble de données d'entrée, mais la nouvelle version du package les inclurait.  Vous devez admettre que ce serait une surprise douteuse.  La reproduction des erreurs dans les packages de NuGet en utilisant les mêmes données d'entrée que celles utilisées pour le débogage des bibliothèques montre que ce problème n'est pas nouveau.  Plus important encore, vous pouvez le «toucher» sans construire le projet à partir de sources. <br><br>  Ainsi, tenant compte de la possibilité d'une désynchronisation théorique du code, je trouve acceptable de se référer à la description des méthodes pertinentes sur docs.microsoft.com et de reproduire les problèmes en utilisant des packages de nuget.org. <br><br>  De plus, je voudrais noter que la description par les liens donnés, les informations (commentaires) dans les packages (dans d'autres versions) auraient pu être modifiées au cours de la rédaction de l'article. <br><br><h3>  Autres projets vérifiés </h3><br>  Au fait, cet article n'est pas unique en son genre.  Nous écrivons d'autres articles sur les contrôles de projets.  Par ce lien, vous pouvez trouver la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liste des projets vérifiés</a> .  De plus, sur notre site, vous trouverez non seulement des articles de vérification de projets, mais aussi divers articles techniques sur C, C ++, C #, Java, ainsi que quelques notes intéressantes.  Vous pouvez trouver tout cela dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>blog</u></a> . <br><br>  Mon collègue a déjà vérifié les bibliothèques .NET Core en 2015. Les résultats de l'analyse précédente se trouvent dans l'article correspondant: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>Analyse de Noël des bibliothèques .NET Core (CoreFX)</u></a> ". <br><br><h2>  Erreurs détectées, fragments suspects et intéressants </h2><br>  Comme toujours, pour plus d'intérêt, je vous suggère de rechercher d'abord les erreurs dans les fragments donnés vous-même, puis de lire le message de l'analyseur et la description du problème. <br><br>  Pour plus de commodité, j'ai clairement séparé les pièces les unes des autres à l'aide des étiquettes du <b>numéro N</b> - de cette façon, il est plus facile de savoir où se termine la description d'une erreur, puis de la suivante.  De plus, il est plus facile de se référer à des fragments spécifiques. <br><br>  <b>Numéro 1</b> <br><br><pre><code class="cpp hljs">abstract <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Principal</span></span></span><span class="hljs-class"> :</span></span> IDisposable { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PrincipalContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( context.ContextType == ContextType.Machine || _ctx.ContextType == ContextType.Machine) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( SR.SaveToNotSupportedAgainstMachineStore); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context == null) { Debug.Assert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unpersisted == <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(SR.NullArguments); } .... } .... }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3095</u></a> L'objet 'context' a été utilisé avant d'être vérifié par rapport à null.  Vérifier les lignes: 340, 346. Principal.cs 340 <br><br>  Les développeurs indiquent clairement que la valeur <i>nulle</i> pour le paramètre de <i>contexte</i> n'est pas valide, ils souhaitent le souligner en utilisant l'exception du type <i>InvalidOperationException</i> .  Cependant, juste au-dessus dans la condition précédente, nous pouvons voir une déréférence inconditionnelle du <i>contexte de</i> référence - <i>context.ContextType</i> .  Par conséquent, si la valeur de <i>contexte</i> est <i>null,</i> l'exception du type <i>NullReferenceException</i> sera générée à la place de la valeur <i>InvalidOperationExcetion</i> attendue <i>.</i> <br><br>  Essayons de reproduire le problème.  Nous ajouterons une référence à la bibliothèque <i>System.DirectoryServices.AccountManagement</i> au projet et exécuterons le code suivant: <br><br><pre> <code class="cpp hljs">GroupPrincipal groupPrincipal = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroupPrincipal(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrincipalContext(ContextType.Machine)); groupPrincipal.Save(null);</code> </pre> <br>  <i>GroupPrincipal</i> hérite de la classe abstraite <i>Principal</i> qui implémente la méthode <i>Save qui</i> nous intéresse.  Nous exécutons donc le code et voyons ce qu'il fallait prouver. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/290/09a/2cc/29009a2cc3a5408808b9814d48bb0dea.png" alt="Image 1"></div><br>  Par souci d'intérêt, vous pouvez essayer de télécharger le package approprié à partir de NuGet et répéter le problème de la même manière.  J'ai installé le package 4.5.0 et obtenu le résultat attendu. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3de/891/b4a/3de891b4a4ba8100bb63af19e4455842.png" alt="Image 2"></div><br>  <b>Numéro 2</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SearchResultCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> findMoreThanOne)</span></span></span><span class="hljs-function"> </span></span>{ searchResult = null; DirectoryEntry clonedRoot = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_assertDefaultNamingContext == null) { clonedRoot = SearchRoot.CloneBrowsable(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { clonedRoot = SearchRoot.CloneBrowsable(); } .... }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3004</u></a> L' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>instruction</u></a> 'then' est équivalente à l'instruction 'else'.  DirectorySearcher.cs 629 <br><br>  Indépendamment du fait que la condition <i>null _assertDefaultNamingContext ==</i> soit vraie ou fausse, les mêmes actions seront prises, comme <i>alors</i> et <i>sinon les</i> branches de l'instruction <i>if</i> ont les mêmes corps.  Soit il doit y avoir une autre action dans une branche, soit vous pouvez omettre l'instruction <i>if</i> pour ne pas confondre les développeurs et l'analyseur. <br><br>  <b>Numéro 3</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DirectoryEntry</span></span></span><span class="hljs-class"> :</span></span> Component { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] propertyNames)</span></span></span><span class="hljs-function"> </span></span>{ .... object[] names = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> object[propertyNames.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; propertyNames.Length; i++) names[i] = propertyNames[i]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_propertyCollection != null &amp;&amp; propertyNames != null) .... .... } .... }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3095</u></a> L'objet 'propertyNames' a été utilisé avant d'être vérifié par rapport à null.  Vérifiez les lignes: 990, 1004. DirectoryEntry.cs 990 <br><br>  Encore une fois, nous voyons un étrange ordre d'actions.  Dans la méthode, il y a un check <i>propertyNames! = Null</i> , c'est-à-dire que les développeurs couvrent leurs bases de <i>null</i> entrant dans la méthode.  Mais ci-dessus, vous pouvez voir quelques opérations d'accès par cette référence potentiellement nulle - <i>propertyNames.Length</i> et <i>propertyNames [i]</i> .  Le résultat est tout à fait prévisible - l'occurrence d'une exception du type <i>NullReferenceExcepption</i> dans le cas où une référence nulle est passée à la méthode. <br><br>  Quelle coïncidence!  <i>RefreshCache</i> est une méthode publique dans la classe publique.  Et si vous essayiez de reproduire le problème?  Pour ce faire, nous inclurons le système de bibliothèque nécessaire. <i>Services d'</i> annuaire dans le projet et nous allons écrire du code comme ceci: <br><br><pre> <code class="cpp hljs">DirectoryEntry de = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DirectoryEntry(); de.RefreshCache(null);</code> </pre> <br>  Après avoir exécuté le code, nous pouvons voir ce que nous attendions. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/040/d0a/2d9040d0ae8d91394c476d6788aa7275.png" alt="Image 3"></div><br>  Juste pour le plaisir, vous pouvez essayer de reproduire le problème sur la version finale du package NuGet.  Ensuite, nous ajoutons une référence au package <i>System.DirectoryServices</i> (j'ai utilisé la version 4.5.0) au projet et exécutons le code déjà familier.  Le résultat est ci-dessous. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d6/31e/309/0d631e3096fa8ba00b41fe10ad1001db.png" alt="Image 4"></div><br>  <b>Numéro 4</b> <br><br>  Maintenant, nous allons partir du contraire - nous allons d'abord essayer d'écrire le code, qui utilise une instance de classe, puis nous regarderons à l'intérieur.  Faisons référence à la structure <i>System.Drawing.CharacterRange</i> de la bibliothèque <i>System.Drawing.Common</i> et du package NuGet du même nom. <br><br>  Nous allons utiliser ce morceau de code: <br><br><pre> <code class="cpp hljs">CharacterRange range = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CharacterRange(); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> eq = range.Equals(null); Console.WriteLine(eq);</code> </pre> <br>  Juste au cas où, afin de simplement parcourir notre mémoire, nous nous adresserons à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>docs.microsoft.com</u></a> pour rappeler la valeur retournée attendue de l'expression <i>obj.Equals (null)</i> : <br><br>  <i>Les instructions suivantes doivent être vraies pour toutes les implémentations de la méthode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u><i>Equals (Object)</i></u></a> .</i>  <i>Dans la liste, x, y et z représentent des références d'objet qui ne sont pas nulles.</i> <br><br>  <i>....</i> <br><br>  <b><i>x.Equals (null) renvoie false.</i></b> <br><br>  Pensez-vous que le texte "False" sera affiché dans la console?  Bien sûr que non.  Ce serait trop facile.  :) Par conséquent, nous exécutons le code et examinons le résultat. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e87/159/8f6/e871598f6ca5dacdb4a4fae7b5776520.png" alt="Image 5"></div><br>  Il s'agissait de la sortie du code ci-dessus à l'aide du package NuGet <i>System.Drawing.Common</i> de la version 4.5.1.  L'étape suivante consiste à exécuter le même code avec la version de la bibliothèque de débogage.  Voici ce que nous voyons: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e9/f27/f1a/6e9f27f1a78768078fdd940e0a4be0ad.png" alt="Image 6"></div><br>  Examinons maintenant le code source, en particulier, l'implémentation de la méthode <i>Equals</i> dans la structure <i>CharacterRange</i> et l'avertissement de l'analyseur: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj.GetType() != typeof(CharacterRange)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; CharacterRange cr = (CharacterRange)obj; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((_first == cr.First) &amp;&amp; (_length == cr.Length)); }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3115</u></a> Passer la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>méthode</u></a> 'null' à 'Equals' ne devrait pas entraîner 'NullReferenceException'.  CharacterRange.cs 56 <br><br>  Nous pouvons observer ce qui devait être prouvé - le paramètre <i>obj</i> est mal géré.  Pour cette raison, l'exception <i>NullReferenceException</i> se produit dans l'expression conditionnelle lors de l'appel de la méthode d'instance <i>GetType.</i> <br><br>  <b>Numéro 5</b> <br><br>  Pendant que nous explorons cette bibliothèque, considérons un autre fragment intéressant - la méthode <i>Icon</i> <i>.</i> <i>Save</i> <i>.</i>  Avant la recherche, regardons la description de la méthode. <br><br>  Il n'y a pas de description de la méthode: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffd/fef/402/ffdfef402f77c462c94b9ff284f42e0c.png" alt="Image 7"></div><br>  Abordons docs.microsoft.com - " <u>Icon.Save (Stream) Method</u> ".  Cependant, il n'y a également aucune restriction sur les entrées ou les informations sur les exceptions générées. <br><br>  Passons maintenant à l'inspection du code. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Icon</span></span></span><span class="hljs-class"> :</span></span> MarshalByRefObject, ICloneable, IDisposable, ISerializable { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream outputStream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_iconData != null) { outputStream.Write(_iconData, <span class="hljs-number"><span class="hljs-number">0</span></span>, _iconData.Length); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (outputStream == null) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"dataStream"</span></span>); .... } } .... }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3095</u></a> L'objet 'outputStream' a été utilisé avant d'être vérifié par rapport à null.  Vérifiez les lignes: 654, 672. Icon.Windows.cs 654 <br><br>  Encore une fois, c'est l'histoire que nous connaissons déjà - déréférence possible d'une référence nulle, car le paramètre de la méthode est déréférencé sans vérifier la valeur <i>nulle</i> .  Encore une fois, une coïncidence réussie des circonstances - la classe et la méthode sont publiques, afin que nous puissions essayer de reproduire le problème. <br><br>  Notre tâche est simple: apporter l'exécution de code à l'expression <i>outputStream.Write (_iconData, 0, _iconData.Length);</i>  et en même temps, enregistrez la valeur de la variable <i>outputStream</i> - <i>null</i> .  La condition <i>_iconData! = Null</i> suffit pour cela. <br><br>  Regardons le constructeur public le plus simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Icon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fileName, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br>  Il délègue simplement le travail à un autre constructeur. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Icon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (FileStream f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read)) { Debug.Assert(f != null, <span class="hljs-string"><span class="hljs-string">"File.OpenRead returned null instead of throwing an exception"</span></span>); _iconData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)f.Length]; f.Read(_iconData, <span class="hljs-number"><span class="hljs-number">0</span></span>, _iconData.Length); } Initialize(width, height); }</code> </pre> <br>  Voilà, c'est ce dont nous avons besoin.  Après avoir appelé ce constructeur, si nous lisons avec succès les données du fichier et qu'il n'y a pas de plantage dans la méthode <i>Initialize</i> , le champ <i>_iconData</i> contiendra une référence à un objet, c'est ce dont nous avons besoin. <br><br>  Il s'avère que nous devons créer l'instance de la classe <i>Icon</i> et spécifier un fichier d'icône réel pour reproduire le problème.  Après cela, nous devons appeler la méthode <i>Save</i> , après avoir passé la valeur <i>nulle</i> en argument, c'est ce que nous faisons.  Le code pourrait ressembler à ceci, par exemple: <br><br><pre> <code class="cpp hljs">Icon icon = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Icon(@<span class="hljs-string"><span class="hljs-string">"D:\document.ico"</span></span>); icon.Save(null);</code> </pre> <br>  Le résultat de l'exécution est attendu. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b37/fdb/dd1/b37fdbdd1288c054fdaaa0add0ffcfcf.png" alt="Image 8"></div><br>  <b>Numéro 6</b> <br><br>  Nous continuons l'examen et continuons.  Essayez de trouver 3 différences entre les actions, exécutées dans le <i>cas CimType.UInt32</i> et dans les autres <i>cas</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertToNumericValueAndAddToArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> retFunctionName = <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Empty; enumType = <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Empty; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(cimType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.UInt8: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.SInt8: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.SInt16: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.UInt16: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.SInt32: arrayToAdd.Add(System.Convert.ToInt32( numericValue, (IFormatProvider)CultureInfo.InvariantCulture .GetFormat(typeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)))); retFunctionName = <span class="hljs-string"><span class="hljs-string">"ToInt32"</span></span>; enumType = <span class="hljs-string"><span class="hljs-string">"System.Int32"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.UInt32: arrayToAdd.Add(System.Convert.ToInt32( numericValue, (IFormatProvider)CultureInfo.InvariantCulture .GetFormat(typeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)))); retFunctionName = <span class="hljs-string"><span class="hljs-string">"ToInt32"</span></span>; enumType = <span class="hljs-string"><span class="hljs-string">"System.Int32"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retFunctionName; }</code> </pre> <br>  Bien sûr, il n'y a aucune différence, car l'analyseur nous en avertit. <br><br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3139</u></a> Deux ou plusieurs branches de cas effectuent les mêmes actions.  WMIGenerator.cs 5220 <br><br>  Personnellement, ce style de code n'est pas très clair.  S'il n'y a pas d'erreur, je pense, la même logique n'aurait pas dû être appliquée à différents cas. <br><br>  <b>Numéro 7</b> <br><br>  Bibliothèque <i>Microsoft.CSharp</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IList&lt;KeyValuePair&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, object&gt;&gt; QueryDynamicObject(object obj) { .... List&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; names = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(mo.GetDynamicMemberNames()); names.Sort(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (names != null) { .... } .... }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3022 L'</u></a> expression 'names! = Null' est toujours vraie.  DynamicDebuggerProxy.cs 426 <br><br>  Je pourrais probablement ignorer cet avertissement ainsi que de nombreux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>messages</u></a> similaires émis par les diagnostics <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3022</u></a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3063</u></a> .  Il y a eu beaucoup (beaucoup) de vérifications étranges, mais celle-ci est entrée dans mon âme.  Peut-être, la raison réside dans ce qui se passe avant de comparer la variable des <i>noms</i> locaux avec <i>null.</i>  Non seulement la référence est stockée dans la variable <i>names</i> pour un objet nouvellement créé, mais la méthode <i>Sort de</i> l'instance est également appelée.  Bien sûr, ce n'est pas une erreur mais, pour moi, ça vaut la peine d'y prêter attention. <br><br>  <b>Numéro 8</b> <br><br>  Un autre morceau de code intéressant: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertChildNoGrow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Symbol child)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sym?.nextSameName != null) { sym = sym.nextSameName; } Debug.Assert(sym != null &amp;&amp; sym.nextSameName == null); sym.nextSameName = child; .... }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3042</u></a> Exception <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>NullReferenceException</u></a> possible.  Le '?.'  et '.'  les opérateurs sont utilisés pour accéder aux membres de l'objet 'sym' SymbolStore.cs 56 <br><br>  Regardez ce que c'est.  La boucle se termine lors du respect d'au moins une des deux conditions: <br><br><ul><li>  <i>sym == null</i> ; </li><li>  <i>sym.nextSameName == null</i> . </li></ul><br>  Il n'y a aucun problème avec la deuxième condition, qui ne peut pas être dite à propos de la première.  Étant donné que le champ d'instance de <i>noms</i> est accessible sans condition ci-dessous et si <i>sym</i> - <i>null</i> , une exception du type <i>NullReferenceException</i> se produira. <br><br>  Êtes-vous aveugle?  Il y a l'appel <i>Debug.Assert</i> , où il est vérifié que <i>sym! = Null</i> ”- quelqu'un pourrait discuter.  Bien au contraire, c'est le point!  Lorsque vous travaillez dans la version Release, <i>Debug.Assert</i> ne sera d'aucune aide et avec la condition ci-dessus, tout ce que nous obtiendrons sera <i>NullReferenceException</i> .  De plus, j'ai déjà vu une erreur similaire dans un autre projet de Microsoft - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>Roslyn</u></a> , où une situation similaire avec <i>Debug.Assert a</i> eu lieu.  Permettez-moi de me détourner un instant pour Roslyn. <br><br>  Le problème peut être reproduit lors de l'utilisation des bibliothèques <i>Microsoft.CodeAnalysis</i> ou directement dans Visual Studio lors de l'utilisation de Syntax Visualizer.  Dans Visual Studio 16.1.6 + Syntax Visualizer 1.0, ce problème peut toujours être reproduit. <br><br>  Ce code lui suffit: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C1</span></span></span><span class="hljs-class">&lt;T1, T2&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T1 val = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val is null) { } } }</code> </pre> <br>  De plus, dans Syntax Visualizer, nous devons trouver le nœud de l'arbre de syntaxe du type <i>ConstantPatternSyntax</i> , correspondant à <i>null</i> dans le code et demander <i>TypeSymbol</i> pour cela. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/855/b9c/baa/855b9cbaa67c9a5909117d513e154293.png" alt="Image 9"></div><br>  Après cela, Visual Studio redémarrera.  Si nous allons à l'Observateur d'événements, nous trouverons des informations sur les problèmes dans les bibliothèques: <br><br><pre> <code class="cpp hljs">Application: devenv.exe Framework Version: v4<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.30319</span></span> Description: The process was terminated due to an unhandled exception. Exception Info: System.Resources.MissingManifestResourceException at System.Resources.ManifestBasedResourceGroveler .HandleResourceStreamMissing(System.String) at System.Resources.ManifestBasedResourceGroveler.GrovelForResourceSet( System.Globalization.CultureInfo, System.Collections.Generic.Dictionary<span class="hljs-string"><span class="hljs-string">'2 &lt;System.String,System.Resources.ResourceSet&gt;, Boolean, Boolean, System.Threading.StackCrawlMark ByRef) at System.Resources.ResourceManager.InternalGetResourceSet( System.Globalization.CultureInfo, Boolean, Boolean, System.Threading.StackCrawlMark ByRef) at System.Resources.ResourceManager.InternalGetResourceSet( System.Globalization.CultureInfo, Boolean, Boolean) at System.Resources.ResourceManager.GetString(System.String, System.Globalization.CultureInfo) at Roslyn.SyntaxVisualizer.DgmlHelper.My. Resources.Resources.get_SyntaxNodeLabel() ....</span></span></code> </pre> <br>  Quant au problème avec devenv.exe: <br><br><pre> <code class="cpp hljs">Faulting application name: devenv.exe, version: <span class="hljs-number"><span class="hljs-number">16.1</span></span><span class="hljs-number"><span class="hljs-number">.29102</span></span><span class="hljs-number"><span class="hljs-number">.190</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5d1c133b</span></span> Faulting <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> name: KERNELBASE.dll, version: <span class="hljs-number"><span class="hljs-number">10.0</span></span><span class="hljs-number"><span class="hljs-number">.18362</span></span><span class="hljs-number"><span class="hljs-number">.145</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0xf5733ace</span></span> Exception code: <span class="hljs-number"><span class="hljs-number">0xe0434352</span></span> Fault offset: <span class="hljs-number"><span class="hljs-number">0x001133d2</span></span> ....</code> </pre> <br>  Avec les versions de débogage des bibliothèques Roslyn, vous pouvez trouver l'endroit où il y avait une exception: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Conversion </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassifyImplicitBuiltInConversionSlow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeSymbol source, TypeSymbol destination, ref HashSet&lt;DiagnosticInfo&gt; useSiteDiagnostics)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert((object)source != null); Debug.Assert((object)destination != null); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( source.SpecialType == SpecialType.System_Void || destination.SpecialType == SpecialType.System_Void) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; } .... }</code> </pre> <br>  Ici, de la même manière que dans le code des bibliothèques .NET Core considéré ci-dessus, il y a une vérification de <i>Debug.Assert</i> qui n'aiderait pas lors de l'utilisation des versions de libération des bibliothèques. <br><br>  <b>Numéro 9</b> <br><br>  Nous avons un petit décalage ici, revenons donc aux bibliothèques .NET Core.  Le package <i>System.IO.IsolatedStorage</i> contient le code intéressant suivant. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ContainsUnknownFiles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> directory)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (files.Length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> || ( (!IsIdFile(files[<span class="hljs-number"><span class="hljs-number">0</span></span>]) &amp;&amp; !IsInfoFile(files[<span class="hljs-number"><span class="hljs-number">0</span></span>]))) || (files.Length == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; !IsIdFile(files[<span class="hljs-number"><span class="hljs-number">1</span></span>]) &amp;&amp; !IsInfoFile(files[<span class="hljs-number"><span class="hljs-number">1</span></span>])) ); }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3088</u></a> L'expression a été placée entre parenthèses deux fois: ((expression)).  Une paire de parenthèses n'est pas nécessaire ou une erreur d'impression est présente.  IsolatedStorageFile.cs 839 <br><br>  Dire que le formatage du code prête à confusion est une autre façon de ne rien dire.  Après avoir regardé brièvement ce code, je dirais que l'opérande gauche du premier ||  L'opérateur que j'ai rencontré était des <i>fichiers. Longueur&gt; 2</i> , celle de droite est celle entre parenthèses.  Au moins, le code est formaté comme ceci.  Après avoir regardé un peu plus attentivement, vous pouvez comprendre que ce n'est pas le cas.  En fait, l'opérande droit - <i>((!! IsIdFile (fichiers [0]) &amp;&amp;! IsInfoFile (fichiers [0])))</i> .  Je pense que ce code est assez déroutant. <br><br>  <b>Numéro 10</b> <br><br>  PVS-Studio 7.03 a introduit la règle de diagnostic <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3138</u></a> , qui recherche les erreurs dans la chaîne interpolée.  Plus précisément, dans la chaîne qui a probablement dû être interpolée, mais à cause du symbole <i>$</i> manqué, ils ne le sont pas <i>.</i>  Dans les bibliothèques <i>System.Net</i> , j'ai trouvé plusieurs occurrences intéressantes de cette règle de diagnostic. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CacheCredential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SafeFreeCredentials newHandle)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ExceptionCheck.IsFatal(e)) { NetEventSource.Fail(null, <span class="hljs-string"><span class="hljs-string">"Attempted to throw: {e}"</span></span>); } } }</code> </pre> <br>  <b>Avertissement PVS-Studio: le</b> littéral de chaîne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3138</u></a> contient une expression interpolée potentielle.  Envisagez d'inspecter: e.  SSPIHandleCache.cs 42 <br><br>  Il est très probable que le deuxième argument de la méthode <i>Fail</i> devait être une chaîne interpolée, dans laquelle la représentation de chaîne de l'exception <i>e</i> serait remplacée.  Cependant, en raison d'un symbole <i>$</i> manqué, aucune représentation sous forme de chaîne n'a été remplacée. <br><br>  <b>Numéro 11</b> <br><br>  Voici un autre cas similaire. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> async Task&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; GetDigestTokenForCredential(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NetEventSource.IsEnabled) NetEventSource.Error(digestResponse, <span class="hljs-string"><span class="hljs-string">"Algorithm not supported: {algorithm}"</span></span>); .... }</code> </pre> <br>  <b>Avertissement PVS-Studio: le</b> littéral de chaîne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3138</u></a> contient une expression interpolée potentielle.  Pensez à inspecter: algorithme.  AuthenticationHelper.Digest.cs 58 <br><br>  La situation est similaire à celle ci-dessus, encore une fois le symbole <i>$</i> est manquant, ce qui entraîne une chaîne incorrecte, entrant dans la méthode <i>Error</i> <i>.</i> <br><br>  <b>Numéro 12</b> <br><br>  <i>Package System.Net.Mail</i> .  La méthode est petite, je vais la citer en entier afin de rendre la recherche du bug plus intéressante. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream stream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stream == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(nameof(stream)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_streamSet) { _stream.Close(); _stream = null; _streamSet = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } _stream = stream; _streamSet = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; _streamUsedOnce = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; TransferEncoding = TransferEncoding.Base64; }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3008</u></a> La variable '_streamSet' se voit attribuer des valeurs deux fois de suite.  C'est peut-être une erreur.  Vérifiez les lignes: 123, 119. MimePart.cs 123 <br><br>  L'affectation d'une valeur double à la variable <i>_streamSet</i> semble étrange (d'abord - sous la condition, puis - à l'extérieur).  Même histoire avec la réinitialisation de la variable de <i>flux</i> .  Par conséquent, <i>_stream</i> aura toujours le <i>flux de</i> valeurs et <i>_streamSet</i> sera <i>vrai.</i> <br><br>  <b>Numéro 13</b> <br><br>  Un fragment de code intéressant de la bibliothèque <i>System.Linq.Expressions</i> qui déclenche 2 avertissements d'analyseur à la fois.  Dans ce cas, cela ressemble plus à une fonctionnalité qu'à un bug.  Cependant, la méthode est assez inhabituelle ... <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// throws NRE when o is null protected static void NullCheck(object o) { if (o == null) { o.GetType(); } }</span></span></code> </pre> <br>  <b>Avertissements de PVS-Studio:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3010</u></a> La valeur de retour de la fonction 'GetType' doit être utilisée.  Instruction.cs 36 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3080 Déréférence</u></a> nulle possible.  Pensez à inspecter «o».  Instruction.cs 36 </li></ul><br>  Il n'y a probablement rien à commenter ici. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c9/a88/a22/5c9a88a221d4cd5ba5f4f1d9f74a346b.png" alt="Image 20"></div><br>  <b>Numéro 14</b> <br><br>  Prenons un autre cas, que nous traiterons "de l'extérieur".  D'abord, nous allons écrire le code, détecter les problèmes, puis nous allons regarder à l'intérieur.  Nous prendrons la bibliothèque <i>System.Configuration.ConfigurationManager</i> et le package NuGet du même nom pour examen.  J'ai utilisé le package de version 4.5.0.  Nous traiterons de la classe <i>System.Configuration.CommaDelimitedStringCollection</i> . <br><br>  Faisons quelque chose de peu sophistiqué.  Par exemple, nous allons créer un objet, extraire sa représentation de chaîne et obtenir la longueur de cette chaîne, puis l'imprimer.  Le code correspondant: <br><br><pre> <code class="cpp hljs">CommaDelimitedStringCollection collection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CommaDelimitedStringCollection(); Console.WriteLine(collection.ToString().Length);</code> </pre> <br>  Au cas où, nous allons consulter la description de la méthode <i>ToString</i> : <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8dc/544/56d/8dc54456dd1296d89fbe447fac71ac17.png" alt="Image 11"></div><br>  Rien de spécial - la représentation sous forme de chaîne d'un objet est renvoyée.  Au cas où, je vais consulter docs.microsoft.com - " <u>CommaDelimitedStringCollection.ToString Method</u> ".  Il semble qu'il n'y ait rien de spécial ici. <br><br>  D'accord, exécutons le code, aaand ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa5/89f/1af/fa589f1afc8ceb9415694e1261e59ab7.png" alt="Image 12"></div><br>  Hum, surprise.  Eh bien, essayons d'ajouter un élément à la collection, puis d'obtenir sa représentation sous forme de chaîne.  Ensuite, nous allons "absolument accidentellement" ajouter une chaîne vide :).  Le code changera et ressemblera à ceci: <br><br><pre> <code class="cpp hljs">CommaDelimitedStringCollection collection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CommaDelimitedStringCollection(); collection.Add(String.Empty); Console.WriteLine(collection.ToString().Length);</code> </pre> <br>  Exécutez et voyez ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d37/4bc/d2e/d374bcd2ed23bd048276493ed19d30fe.png" alt="Image 13"></div><br>  Quoi encore?!  Eh bien, abordons enfin l'implémentation de la méthode <i>ToString à</i> partir de la classe <i>CommaDelimitedStringCollection</i> .  Le code est ci-dessous: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Count &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); foreach (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> str in <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { ThrowIfContainsDelimiter(str); <span class="hljs-comment"><span class="hljs-comment">// .... sb.Append(str.Trim()); sb.Append(','); } if (sb.Length &gt; 0) sb.Length = sb.Length - 1; return sb.Length == 0 ? null : sb.ToString(); }</span></span></code> </pre> <br>  <b>Avertissements de PVS-Studio:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3108</u></a> Il n'est pas recommandé de renvoyer 'null' à partir de la méthode 'ToSting ()'.  StringAttributeCollection.cs 57 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3108</u></a> Il n'est pas recommandé de renvoyer 'null' à partir de la méthode 'ToSting ()'.  StringAttributeCollection.cs 71 </li></ul><br>  Ici, nous pouvons voir 2 fragments, où l'implémentation actuelle de <i>ToString</i> peut retourner <i>null.</i>  À ce stade, nous nous souviendrons de la recommandation de Microsoft sur la mise en œuvre de la méthode <i>ToString</i> .  Consultez donc docs.microsoft.com - " <u>Méthode Object.ToString</u> ": <br><br>  <i>Notes aux héritiers .... Les remplacements de la méthode ToString () doivent suivre ces directives:</i> <br><br><ul><li>  <i>....</i> </li><li>  <i>Votre remplacement ToString () ne doit pas renvoyer vide ou une</i> <i>chaîne</i> <b><i>nulle</i></b> <i>.</i> </li><li>  <i>....</i> </li></ul><br>  C'est ce à quoi PVS-Studio met en garde.  Deux fragments de code donnés ci-dessus que nous écrivions pour reproduire le problème obtiennent des points de sortie différents - le premier et le deuxième point de retour <i>nul</i> respectivement.  Creusons un peu plus profondément. <br><br>  Premier cas.  <i>Count</i> est une propriété de la classe <i>StringCollection de</i> base.  Aucun élément n'ayant été ajouté, <i>Count == 0</i> , la condition <i>Count &lt;= 0</i> est vraie, la valeur <i>nulle</i> est renvoyée. <br><br>  Dans le deuxième cas, nous avons ajouté l'élément en utilisant la méthode d'instance <i>CommaDelimitedStringCollection.Add</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">new</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ ThrowIfReadOnly(); ThrowIfContainsDelimiter(value); _modified = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; base.Add(value.Trim()); }</code> </pre> <br>  Les vérifications réussissent dans la méthode <i>ThrowIf ...</i> et l'élément est ajouté dans la collection de base.  Par conséquent, la valeur <i>Count</i> devient 1. Revenons maintenant à la méthode <i>ToString</i> .  Valeur de l'expression <i>Count &lt;= 0</i> - <i>false</i> , donc la méthode ne retourne pas et l'exécution du code continue.  La collection interne est traversée, 2 éléments sont ajoutés à l'instance de type <i>StringBuilder</i> - une chaîne vide et une virgule.  Par conséquent, il s'avère que <i>sb</i> ne contient qu'une virgule, la valeur de la propriété <i>Length</i> est respectivement égale à 1. La valeur de l'expression <i>sb.Length&gt; 0</i> est <i>vraie</i> , la soustraction et l'écriture en <i>sb.Length</i> sont effectuées, maintenant la valeur de <i>sb.Length</i> est 0. Cela conduit au fait que la valeur <i>nulle</i> est à nouveau renvoyée par la méthode. <br><br>  <b>Numéro 15</b> <br><br>  Tout d'un coup, j'ai eu envie d'utiliser la classe <i>System.Configuration.ConfigurationProperty</i> .  Prenons un constructeur avec le plus grand nombre de paramètres: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigurationProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, Type type, object defaultValue, TypeConverter typeConverter, ConfigurationValidatorBase validator, ConfigurationPropertyOptions options, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> description)</span></span></span></span>;</code> </pre> <br>  Voyons la description du dernier paramètre: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// description: // The description of the configuration entity.</span></span></code> </pre> <br>  La même chose est écrite dans la description du constructeur sur docs.microsoft.com.  Eh bien, regardons comment ce paramètre est utilisé dans le corps du constructeur: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigurationProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> description)</span></span></span><span class="hljs-function"> </span></span>{ ConstructorInit(name, type, options, validator, typeConverter); SetDefaultValue(defaultValue); }</code> </pre> <br>  Croyez-le ou non, le paramètre n'est pas utilisé. <br><br>  <b>Avertissement PVS-Studio: le</b> paramètre constructeur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3117</u></a> 'description' n'est pas utilisé.  ConfigurationProperty.cs 62 <br><br>  Les auteurs de code ne l'utilisent probablement pas intentionnellement, mais la description du paramètre pertinent est très déroutante. <br><br>  <b>Numéro 16</b> <br><br>  Voici un autre fragment similaire: essayez de trouver l'erreur vous-même, je donne le code du constructeur ci-dessous. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SectionXmlInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> configKey, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> definitionConfigPath, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetConfigPath, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> subPath, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lineNumber, object streamVersion, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rawXml, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> configSource, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> configSourceStreamName, object configSourceStreamVersion, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> protectionProviderName, OverrideModeSetting overrideMode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> skipInChildApps)</span></span></span><span class="hljs-function"> </span></span>{ ConfigKey = configKey; DefinitionConfigPath = definitionConfigPath; TargetConfigPath = targetConfigPath; SubPath = subPath; Filename = filename; LineNumber = lineNumber; StreamVersion = streamVersion; RawXml = rawXml; ConfigSource = configSource; ConfigSourceStreamName = configSourceStreamName; ProtectionProviderName = protectionProviderName; OverrideModeSetting = overrideMode; SkipInChildApps = skipInChildApps; }</code> </pre> <br>  <b>Avertissement PVS-Studio: le</b> paramètre constructeur V3117 'configSourceStreamVersion' n'est pas utilisé.  SectionXmlInfo.cs 16 <br><br>  Il y a une propriété appropriée, mais franchement, cela semble un peu étrange: <br><br><pre> <code class="cpp hljs">internal object ConfigSourceStreamVersion { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { } }</code> </pre> <br>  Généralement, le code semble suspect.  Peut-être que le paramètre / la propriété est laissé pour la compatibilité, mais c'est juste ma supposition. <br><br>  <b>Numéro 17</b> <br><br>  Jetons un coup d'œil aux éléments intéressants de la bibliothèque <i>System.Runtime.WindowsRuntime.UI.Xaml</i> et du code de package du même nom. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RepeatBehavior</span></span></span><span class="hljs-class"> :</span></span> IFormattable { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InternalToString(null, null); } .... }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3108</u></a> Il n'est pas recommandé de renvoyer 'null' à partir de la méthode 'ToSting ()'.  RepeatBehavior.cs 113 <br><br>  Histoire familière que nous connaissons déjà - la méthode <i>ToString</i> peut renvoyer la valeur <i>nulle</i> .  Pour cette raison, l'auteur du code de l'appelant, qui suppose que <i>RepeatBehavior.ToString</i> renvoie toujours une référence non nulle, peut être désagréablement surpris à un moment donné.  Encore une fois, cela contredit les directives de Microsoft. <br><br>  Eh bien, mais la méthode ne précise pas que <i>ToString</i> peut retourner <i>null</i> - nous devons aller plus loin et jeter un œil à la méthode <i>InternalToString</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InternalToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> format, IFormatProvider formatProvider)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (_Type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RepeatBehaviorType.Forever: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Forever"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RepeatBehaviorType.Count: StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.AppendFormat( formatProvider, <span class="hljs-string"><span class="hljs-string">"{0:"</span></span> + format + <span class="hljs-string"><span class="hljs-string">"}x"</span></span>, _Count); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sb.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RepeatBehaviorType.Duration: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _Duration.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } }</code> </pre> <br>  L'analyseur a détecté que si la branche <i>par défaut</i> s'exécute dans <i>switch</i> , <i>InternalToString</i> renverra la valeur <i>nulle</i> .  Par conséquent, <i>ToString</i> renverra également <i>null</i> . <br><br>  <i>RepeatBehavior</i> est une structure publique et <i>ToString</i> est une méthode publique, nous pouvons donc essayer de reproduire le problème dans la pratique.  Pour ce faire, nous allons créer l'instance <i>RepeatBehavior</i> , appeler la méthode <i>ToString à</i> partir de celle-ci et tout en faisant cela, nous ne devons pas manquer que <i>_Type</i> ne doit pas être égal à <i>RepeatBehaviorType.Forever</i> , <i>RepeatBehaviorType.Count</i> ou <i>RepeatBehaviorType.Duration</i> . <br><br>  <i>_Type</i> est un champ privé, qui peut être attribué via une propriété publique: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RepeatBehavior</span></span></span><span class="hljs-class"> :</span></span> IFormattable { .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> RepeatBehaviorType _Type; .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RepeatBehaviorType Type { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _Type; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { _Type = value; } } .... }</code> </pre> <br>  Jusqu'à présent, tout va bien.  Passons à autre chose et voyons quel est le type <i>RepeatBehaviorType</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> RepeatBehaviorType { Count, Duration, Forever }</code> </pre> <br>  Comme nous pouvons le voir, <i>RepeatBehaviorType</i> est l'énumération, contenant les trois éléments.  Parallèlement à cela, ces trois éléments sont couverts par l'expression de <i>commutateur</i> qui nous intéresse.  Cependant, cela ne signifie pas que la branche par défaut est inaccessible. <br><br>  Pour reproduire le problème, nous ajouterons une référence au package <i>System.Runtime.WindowsRuntime.UI.Xaml</i> au projet (j'utilisais la version 4.3.0) et exécuterons le code suivant. <br><br><pre> <code class="cpp hljs">RepeatBehavior behavior = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RepeatBehavior() { Type = (RepeatBehaviorType)<span class="hljs-number"><span class="hljs-number">666</span></span> }; Console.WriteLine(behavior.ToString() is null);</code> </pre> <br>  <i>True</i> est affiché dans la console comme prévu, ce qui signifie que <i>ToString a</i> retourné <i>null</i> , car <i>_Type</i> n'était égal à aucune des valeurs des branches de <i>cas</i> et la branche <i>par défaut</i> a reçu le contrôle.  C'est ce que nous essayions de faire. <br><br>  Je voudrais également noter que ni les commentaires sur la méthode, ni <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>docs.microsoft.com ne</u></a> spécifient que la méthode peut renvoyer la valeur <i>nulle</i> . <br><br>  <b>Numéro 18</b> <br><br>  Ensuite, nous vérifierons plusieurs avertissements de <i>System.Private.DataContractSerialization</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CharType</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte None = <span class="hljs-number"><span class="hljs-number">0x00</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte FirstName = <span class="hljs-number"><span class="hljs-number">0x01</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte Name = <span class="hljs-number"><span class="hljs-number">0x02</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte Whitespace = <span class="hljs-number"><span class="hljs-number">0x04</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte Text = <span class="hljs-number"><span class="hljs-number">0x08</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte AttributeText = <span class="hljs-number"><span class="hljs-number">0x10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte SpecialWhitespace = <span class="hljs-number"><span class="hljs-number">0x20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte Comment = <span class="hljs-number"><span class="hljs-number">0x40</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> byte[] s_charType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[<span class="hljs-number"><span class="hljs-number">256</span></span>] { .... CharType.None, <span class="hljs-comment"><span class="hljs-comment">/* 9 (.) */</span></span> CharType.None| CharType.Comment| CharType.Comment| CharType.Whitespace| CharType.Text| CharType.SpecialWhitespace, <span class="hljs-comment"><span class="hljs-comment">/* A (.) */</span></span> CharType.None| CharType.Comment| CharType.Comment| CharType.Whitespace| CharType.Text| CharType.SpecialWhitespace, <span class="hljs-comment"><span class="hljs-comment">/* B (.) */</span></span> CharType.None, <span class="hljs-comment"><span class="hljs-comment">/* C (.) */</span></span> CharType.None, <span class="hljs-comment"><span class="hljs-comment">/* D (.) */</span></span> CharType.None| CharType.Comment| CharType.Comment| CharType.Whitespace, <span class="hljs-comment"><span class="hljs-comment">/* E (.) */</span></span> CharType.None, .... };</code> </pre> <br>  <b>Avertissements de PVS-Studio:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3001</u></a> Il existe des sous-expressions identiques 'CharType.Comment' à gauche et à droite de '|'  opérateur.  XmlUTF8TextReader.cs 56 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3001</u></a> Il existe des sous-expressions identiques 'CharType.Comment' à gauche et à droite de '|'  opérateur.  XmlUTF8TextReader.cs 58 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3001</u></a> Il existe des sous-expressions identiques 'CharType.Comment' à gauche et à droite de '|'  opérateur.  XmlUTF8TextReader.cs 64 </li></ul><br>  L'analyseur a trouvé l'utilisation de l'expression <i>CharType.Comment | CharType.Comment</i> suspecte.  Semble un peu étrange, car <i>(CharType.Comment | CharType.Comment) == CharType.Comment</i> .  Lors de l'initialisation d'autres éléments de tableau, qui utilisent <i>CharType.Comment</i> , il n'y a pas une telle duplication. <br><br>  <b>Numéro 19</b> <br><br>  Continuons.  Examinons les informations sur la <i>valeur</i> de retour de la méthode XmlBinaryWriterSession.TryAdd dans la description de la méthode et sur docs.microsoft.com - " <u>Méthode XmlBinaryWriterSession.TryAdd (XmlDictionaryString, Int32)</u> ": <i>renvoie: true si la chaîne peut être ajoutée;</i>  <i>sinon, faux.</i> <br><br>  Examinons maintenant le corps de la méthode: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlDictionaryString value, out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>{ IntArray keys; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == null) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> System.Runtime .Serialization .DiagnosticUtility .ExceptionUtility .ThrowHelperArgumentNull(nameof(value)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_maps.TryGetValue(value.Dictionary, out keys)) { key = (keys[value.Key] - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// If the key is already set, then something is wrong throw System.Runtime .Serialization .DiagnosticUtility .ExceptionUtility .ThrowHelperError( new InvalidOperationException( SR.XmlKeyAlreadyExists)); } key = Add(value.Value); keys[value.Key] = (key + 1); return true; } key = Add(value.Value); keys = AddKeys(value.Dictionary, value.Key + 1); keys[value.Key] = (key + 1); return true; }</span></span></code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3009</u></a> Il est étrange que cette méthode renvoie toujours une seule et même valeur de «vrai».  XmlBinaryWriterSession.cs 29 <br><br>  Il semble étrange que la méthode renvoie <i>true</i> ou lève une exception, mais la valeur <i>false</i> n'est jamais renvoyée. <br><br>  <b>Numéro 20</b> <br><br>  Je suis tombé sur le code avec un problème similaire, mais dans ce cas, au contraire - la méthode retourne toujours <i>false</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnHandleReference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xmlWriter.depth &lt; depthToCheckCyclicReference) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (canContainCyclicReference) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_byValObjectsInScope.Contains(obj)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; _byValObjectsInScope.Push(obj); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3009</u></a> Il est étrange que cette méthode renvoie toujours une seule et même valeur de "false".  XmlObjectSerializerWriteContext.cs 415 <br><br>  Eh bien, nous avons déjà parcouru un long chemin!  Alors avant de continuer, je vous suggère de faire une petite pause: remuez vos muscles, promenez-vous, reposez vos yeux, regardez par la fenêtre ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/008/d6a/92d/008d6a92d6f4cf4066e744e4c857b47d.png" alt="Image 24"></div><br>  J'espère qu'à ce stade, vous êtes à nouveau plein d'énergie, alors continuons.  :) <br><br>  <b>Numéro 21</b> <br><br>  Passons en revue quelques fragments intéressants du projet <i>System.Security.Cryptography.Algorithms</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> override byte[] GenerateMask(byte[] rgbSeed, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cbReturn) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (HashAlgorithm hasher = (HashAlgorithm)CryptoConfig.CreateFromName(_hashNameValue)) { byte[] rgbCounter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[<span class="hljs-number"><span class="hljs-number">4</span></span>]; byte[] rgbT = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[cbReturn]; uint counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ib = <span class="hljs-number"><span class="hljs-number">0</span></span>; ib &lt; rgbT.Length;) { <span class="hljs-comment"><span class="hljs-comment">// Increment counter -- up to 2^32 * sizeof(Hash) Helpers.ConvertIntToByteArray(counter++, rgbCounter); hasher.TransformBlock(rgbSeed, 0, rgbSeed.Length, rgbSeed, 0); hasher.TransformFinalBlock(rgbCounter, 0, 4); byte[] hash = hasher.Hash; hasher.Initialize(); Buffer.BlockCopy(hash, 0, rgbT, ib, Math.Min(rgbT.Length - ib, hash.Length)); ib += hasher.Hash.Length; } return rgbT; } }</span></span></code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3080 Déréférence</u></a> nulle possible.  Envisagez d'inspecter «hasher».  PKCS1MaskGenerationMethod.cs 37 <br><br>  L'analyseur avertit que la valeur de la variable de <i>hachage</i> peut être <i>nulle</i> lors de l'évaluation du <i>hachage.</i> Expression de <i>TransformBlock</i> résultant en une exception du type <i>NullReferenceException</i> .  L'occurrence de cet avertissement est devenue possible grâce à l'analyse interprocédurale. <br><br>  Donc, pour savoir si <i>hasher</i> peut prendre la valeur <i>nulle</i> dans ce cas, nous devons plonger dans la méthode <i>CreateFromName</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateFromName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CreateFromName(name, null); }</code> </pre> <br>  Rien pour l'instant - allons plus loin.  Le corps de la version <i>CreateFromName</i> surchargée avec deux paramètres est assez grand, donc je cite la version courte. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateFromName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, params object[] args)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retvalType == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cons == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidates.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rci == null || typeof(Delegate).IsAssignableFrom(rci.DeclaringType)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retval; }</code> </pre> <br> As you can see, there are several exit points in the method where the <i>null</i> value is explicitly returned. Therefore, at least theoretically, in the method above, that triggered a warning, an exception of the <i>NullReferenceException</i> type might occur. <br><br> Theory is great, but let's try to reproduce the problem in practice. To do this, we'll take another look at the original method and note the key points. Also, we'll reduce the irrelevant code from the method. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PKCS1MaskGenerationMethod</span></span></span><span class="hljs-class"> :</span></span> .... <span class="hljs-comment"><span class="hljs-comment">// &lt;= 1 { .... public PKCS1MaskGenerationMethod() // &lt;= 2 { _hashNameValue = DefaultHash; } .... public override byte[] GenerateMask(byte[] rgbSeed, int cbReturn) // &lt;= 3 { using (HashAlgorithm hasher = (HashAlgorithm)CryptoConfig.CreateFromName(_hashNameValue)) // &lt;= 4 { byte[] rgbCounter = new byte[4]; byte[] rgbT = new byte[cbReturn]; // &lt;= 5 uint counter = 0; for (int ib = 0; ib &lt; rgbT.Length;) // &lt;= 6 { .... Helpers.ConvertIntToByteArray(counter++, rgbCounter); // &lt;= 7 hasher.TransformBlock(rgbSeed, 0, rgbSeed.Length, rgbSeed, 0); .... } .... } } }</span></span></code> </pre> <br> Let's take a closer look at the key points: <br><br> <b>1, 3</b> . The class and method have <i>public</i> access modifiers. Hence, this interface is available when adding reference to a library — we can try reproducing this issue. <br><br> <b>2</b> . The class is non-abstract instance, has a public constructor. It must be easy to create an instance, which we'll work with. In some cases, that I considered, classes were abstract, so to reproduce the issue I had to search for inheritors and ways to obtain them. <br><br> <b>4</b> . <i>CreateFromName</i> mustn't generate any exceptions and must return <i>null</i> — the most important point, we'll get back to it later. <br><br> <b>5, 6</b> . The <i>cbReturn</i> value has to be &gt; 0 (but, of course, within adequate limits for the successful creation of an array). Compliance of the <i>cbReturn &gt; 0</i> condition is needed to meet the further condition <i>ib &lt; rgbT.Length</i> and enter the loop body. <br><br> <b>7</b> . <i>Helpres.ConvertIntToByteArray</i> must work without exceptions. <br><br> To meet the conditions that depend on the method parameters, it is enough to simply pass appropriate arguments, for example: <br><br><ul><li> <i>rgbCeed</i> — new byte[] { 0, 1, 2, 3 }; </li><li> <i>cbReturn</i> — 42. </li></ul><br> In order to «discredit» the <i>CryptoConfig.CreateFromName</i> method, we need to be able to change the value of the <i>_hashNameValue</i> field. Fortunately, we have it, as the class defines a wrapper property for this field: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> HashName { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _hashNameValue; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { _hashNameValue = value ?? DefaultHash; } }</code> </pre> <br> By setting a 'synthetic' value for <i>HashName</i> (that is <i>_hashNameValue),</i> we can get the <i>null</i> value from the <i>CreateFromName</i> method at the first exit point from the ones we marked. I won't go into the details of analyzing this method (hope you'll forgive me for this), as the method is quite large. <br><br> As a result, the code which will lead to an exception of the <i>NullReferenceException</i> type, might look as follows: <br><br><pre> <code class="cpp hljs">PKCS1MaskGenerationMethod tempObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PKCS1MaskGenerationMethod(); tempObj.HashName = <span class="hljs-string"><span class="hljs-string">"Dummy"</span></span>; tempObj.GenerateMask(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[] { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }, <span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre> <br> Now we add reference to the debugging library, run the code and get the expected result: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ab/384/8e5/2ab3848e542172cd92a7e03f55bba9fe.png" alt="Image 10"></div><br> Just for the fun of it, I tried to execute the same code using the NuGet package of the 4.3.1 version. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b4/a94/766/7b4a947666444496ca077e7530415c76.png" alt="Image 14"></div><br> There's no information on generated exceptions, limitations of output parameters in the method description. Docs.microsoft.com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>PKCS1MaskGenerationMethod.GenerateMask(Byte[], Int32) Method</u></a> " doesn't specify it either. <br><br> By the way, right when writing the article and describing the order of actions to reproduce the problem, I found 2 more ways to «break» this method: <br><br><ul><li> pass a too large value as a <i>cbReturn</i> argument; </li><li> pass the <i>null</i> value as <i>rgbSeed.</i> </li></ul><br> In the first case, we'll get an exception of the <i>OutOfMemoryException</i> type. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c50/474/7f9/c504747f9a771843da10a128866811dd.png" alt="Image 15"></div><br> In the second case, we'll get an exception of the <i>NullReferenceException</i> type when executing the <i>rgbSeed.Length</i> expression. In this case, it's important, that <i>hasher</i> has a non-null value. Otherwise, the control flow won't get to <i>rgbSeed.Length</i> . <br><br> <b>Issue 22</b> <br><br> I came across a couple of similar places. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignatureDescription</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> FormatterAlgorithm { get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> DeformatterAlgorithm { get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SignatureDescription</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> AsymmetricSignatureDeformatter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDeformatter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AsymmetricAlgorithm key)</span></span></span><span class="hljs-function"> </span></span>{ AsymmetricSignatureDeformatter item = (AsymmetricSignatureDeformatter) CryptoConfig.CreateFromName(DeformatterAlgorithm); item.SetKey(key); <span class="hljs-comment"><span class="hljs-comment">// &lt;= return item; } public virtual AsymmetricSignatureFormatter CreateFormatter( AsymmetricAlgorithm key) { AsymmetricSignatureFormatter item = (AsymmetricSignatureFormatter) CryptoConfig.CreateFromName(FormatterAlgorithm); item.SetKey(key); // &lt;= return item; } .... }</span></span></code> </pre> <br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3080</u></a> Possible null dereference. Consider inspecting 'item'. SignatureDescription.cs 31 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3080</u></a> Possible null dereference. Consider inspecting 'item'. SignatureDescription.cs 38 </li></ul><br> Again, in <i>FormatterAlgorithm</i> and <i>DeformatterAlgorithm</i> properties we can write such values, for which the <i>CryptoConfig.CreateFromName</i> method return the <i>null</i> value in the <i>CreateDeformatter</i> and <i>CreateFormatter</i> methods. Further, when calling the <i>SetKey</i> instance method, a <i>NullReferenceException</i> exception will be generated. The problem, again, is easily reproduced in practice: <br><br><pre> <code class="cpp hljs">SignatureDescription signature = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SignatureDescription() { DeformatterAlgorithm = <span class="hljs-string"><span class="hljs-string">"Dummy"</span></span>, FormatterAlgorithm = <span class="hljs-string"><span class="hljs-string">"Dummy"</span></span> }; signature.CreateDeformatter(null); <span class="hljs-comment"><span class="hljs-comment">// NRE signature.CreateFormatter(null); // NRE</span></span></code> </pre> <br> In this case, when calling <i>CreateDeformatter</i> as well as calling <i>CreateFormatter</i> , an exception of the <i>NullReferenceException</i> type is thrown. <br><br> <b>Issue 23</b> <br><br> Let's review interesting fragments from the <i>System.Private.Xml</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteBase64</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte[] buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_inAttr &amp;&amp; (_inCDataSection || StartCDataSection())) _wrapped.WriteBase64(buffer, index, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> _wrapped.WriteBase64(buffer, index, count); }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3004</u></a> The 'then' statement is equivalent to the 'else' statement. QueryOutputWriterV1.cs 242 <br><br> It looks strange that <i>then</i> and <i>else</i> branches of the <i>if</i> statement contain the same code. Either there's an error here and another action has to be made in one of the branches, or the <i>if</i> statement can be omitted. <br><br> <b>Issue 24</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Depends</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlSchemaObject item, ArrayList refs)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content is XmlSchemaSimpleTypeRestriction) { baseType = ((XmlSchemaSimpleTypeRestriction)content).BaseType; baseName = ((XmlSchemaSimpleTypeRestriction)content).BaseTypeName; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content is XmlSchemaSimpleTypeList) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content is XmlSchemaSimpleTypeRestriction) { baseName = ((XmlSchemaSimpleTypeRestriction)content).BaseTypeName; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == typeof(XmlSchemaSimpleTypeUnion)) { .... } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3003</u></a> The use of 'if (A) {...} else if (A) {...}' pattern was detected. There is a probability of logical error presence. Check lines: 381, 396. ImportContext.cs 381 <br><br> In the <i>if-else-if</i> sequence there are two equal conditional expressions — <i>content is XmlSchemaSimpleTypeRestriction</i> . What is more, bodies of <i>then</i> branches of respective statements contain a different set of expressions. Anyway, either the body of the first relevant <i>then</i> branch will be executed (if the conditional expression is true), or none of them in case if the relevant expression is false. <br><br> <b>Issue 25</b> <br><br> To make it more intriguing to search for the error in the next method, I'll cite is entire body. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MatchesXmlType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IList&lt;XPathItem&gt; seq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> indexType)</span></span></span><span class="hljs-function"> </span></span>{ XmlQueryType typBase = GetXmlType(indexType); XmlQueryCardinality card; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (seq.Count) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: card = XmlQueryCardinality.Zero; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: card = XmlQueryCardinality.One; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: card = XmlQueryCardinality.More; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(card &lt;= typBase.Cardinality)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; typBase = typBase.Prime; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; seq.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateXmlType(seq[<span class="hljs-number"><span class="hljs-number">0</span></span>]).IsSubtypeOf(typBase)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br> If you've coped — congratulations! <br> If not — PVS-Studio to the rescue: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3102</u></a> Suspicious access to element of 'seq' object by a constant index inside a loop. XmlQueryRuntime.cs 738 <br><br> The <i>for</i> loop is executed, the expression <i>i &lt; seq.Count</i> is used as an exit condition. It suggests the idea that developers want to bypass the <i>seq</i> sequence. But in the loop, authors access sequence elements not by using the counter — <i>seq[i]</i> , but a number literal — zero ( <i>seq[0]</i> ). <br><br> <b>Issue 26</b> <br><br> The next error fits in a small piece of code, but it's no less interesting. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ WriteValue(value); }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3110</u></a> Possible infinite recursion inside 'WriteValue' method. XmlAttributeCache.cs 166 <br><br> The method calls itself, forming recursion without an exit condition. <br><br> <b>Issue 27</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IList&lt;XPathNavigator&gt; DocOrderDistinct(IList&lt;XPathNavigator&gt; seq) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (seq.Count &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq; XmlQueryNodeSequence nodeSeq = (XmlQueryNodeSequence)seq; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nodeSeq == null) nodeSeq = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlQueryNodeSequence(seq); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nodeSeq.DocOrderDistinct(_docOrderCmp); }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3095</u></a> The 'seq' object was used before it was verified against null. Check lines: 880, 884. XmlQueryRuntime.cs 880 <br><br> The method can get the <i>null</i> value as an argument. Due to this, when accessing the <i>Count</i> property, an exception of the <i>NullReferenceException</i> type will be generated. Below the variable <i>nodeSeq</i> is checked. <i>nodeSeq</i> is obtained as a result of explicit <i>seq</i> casting, still it's not clear why the check takes place. If the <i>seq</i> value is <i>null</i> , the control flow won't get to this check because of the exception. If the <i>seq</i> value isn't <i>null</i> , then: <br><br><ul><li> if casting fails, an exception of the <i>InvalidCastException</i> type will be generated; </li><li> if casting is successful, <i>nodeSeq</i> definitely isn't <i>null</i> . </li></ul><br> <b>Issue 28</b> <br><br> I came across 4 constructors, containing unused parameters. Perhaps, they are left for compatibility, but I found no additional comments on these unused parameters. <br><br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3117</u></a> Constructor parameter 'securityUrl' is not used. XmlSecureResolver.cs 15 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3117</u></a> Constructor parameter 'strdata' is not used. XmlEntity.cs 18 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3117</u></a> Constructor parameter 'location' is not used. Compilation.cs 58 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3117</u></a> Constructor parameter 'access' is not used. XmlSerializationILGen.cs 38 </li></ul><br> The first one interested me the most (at least, it got into the list of warnings for the article). What's so special? Not sure. Perhaps, its name. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">XmlSecureResolver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlResolver resolver, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> securityUrl)</span></span></span><span class="hljs-function"> </span></span>{ _resolver = resolver; }</code> </pre> <br> Just for the sake of interest, I checked out what's written at docs.microsoft.com — " <u>XmlSecureResolver Constructors</u> " about the <i>securityUrl</i> parameter: <br><br> <i>The URL used to create the PermissionSet that will be applied to the underlying XmlResolver. The XmlSecureResolver calls PermitOnly() on the created PermissionSet before calling GetEntity(Uri, String, Type) on the underlying XmlResolver.</i> <br><br> <b>Issue 29</b> <br><br> In the <i>System.Private.Uri</i> package I found the method, which wasn't following exactly Microsoft guidelines on the <i>ToString</i> method overriding. Here we need to recall one of the tips from the page " <u>Object.ToString Method</u> ": <b><i>Your ToString() override should not throw an exception</i></b> <i>.</i> <br><br> The overridden method itself looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_username.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; _password.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UriFormatException(SR.net_uri_BadUserPassword); } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3108</u></a> It is not recommended to throw exceptions from 'ToSting()' method. UriBuilder.cs 406 <br><br> The code first sets an empty string for the <i>_username</i> field and a nonempty one for the <i>_password</i> field respectively through the public properties <i>UserName</i> and <i>Password.</i> After that it calls the <i>ToString</i> method. Eventually this code will get an exception. An example of such code: <br><br><pre> <code class="cpp hljs">UriBuilder uriBuilder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UriBuilder() { UserName = String.Empty, Password = <span class="hljs-string"><span class="hljs-string">"Dummy"</span></span> }; String stringRepresentation = uriBuilder.ToString(); Console.WriteLine(stringRepresentation);</code> </pre> <br> But in this case developers honestly warn that calling might result in an exception. It is described in comments to the method and at docs.microsoft.com — " <u>UriBuilder.ToString Method</u> ". <br><br> <b>Issue 30</b> <br><br> Look at the warnings, issued on the <i>System.Data.Common</i> project code. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ArrayList _tables; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> DataTable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tableName, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ns)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_tables.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (DataTable)_tables[<span class="hljs-number"><span class="hljs-number">0</span></span>]; .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3106</u></a> Possibly index is out of bound. The '0' index is pointing beyond '_tables' bound. XMLDiffLoader.cs 277 <br><br> Does this piece of code look unusual? What do you think it is? An unusual way to generate an exception of the <i>ArgumentOutOfRangeException</i> type? I wouldn't be surprised by this approach. Overall, it's very strange and suspicious code. <br><br> <b>Issue 31</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal XmlNodeOrder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComparePosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XPathNodePointer other)</span></span></span><span class="hljs-function"> </span></span>{ RealFoliate(); other.RealFoliate(); Debug.Assert(other != null); .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3095</u></a> The 'other' object was used before it was verified against null. Check lines: 1095, 1096. XPathNodePointer.cs 1095 <br><br> The expression <i>other != null</i> as an argument of the <i>Debug.Assert</i> method suggests, that the <i>ComparePosition</i> method can obtain the <i>null</i> value as an argument. At least, the intention was to catch such cases. But at the same time, the line above the <i>other.RealFoliate</i> instance method is called. As a result, if <i>other</i> has the <i>null</i> value, an exception of the <i>NullReferenceException</i> type will be generated before checking through <i>Assert</i> . <br><br> <b>Issue 32</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> PropertyDescriptorCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetProperties</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Attribute[] attributes)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (Attribute attribute in attributes) { Attribute attr = property.Attributes[attribute.GetType()]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (attr == null &amp;&amp; !attribute.IsDefaultAttribute()) || !attr.Match(attribute)) { match = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3080</u></a> Possible null dereference. Consider inspecting 'attr'. DbConnectionStringBuilder.cs 534 <br><br> Conditional expression of the <i>if</i> statement looks quite suspicious. <i>Match</i> is an instance method. According to the check <i>attr == null</i> , <i>null</i> is the acceptable (expected) value for this variable. Therefore, if control flow gets to the right operand of the || operator (if <i>attr</i> — <i>null</i> ), we'll get an exception of the <i>NullReferenceException</i> type. <br><br> Accordingly, conditions of the exception occurrence are the following: <br><br><ol><li> The value of <i>attr</i> — <i>null</i> . The right operand of the &amp;&amp; operator is evaluated. </li><li> The value of <i>!attribute.IsDefaultAttribute()</i> — <i>false</i> . The overall result of the expression with the &amp;&amp; operator — <i>false</i> . </li><li> Since the left operand of the || operator is of the <i>false</i> value, the right operand is evaluated. </li><li> Since <i>attr</i> — <i>null</i> , when calling the <i>Match</i> method, an exception is generated. </li></ol><br> <b>Issue 33</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadOldRowData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DataSet ds, ref DataTable table, ref </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pos, XmlReader row)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (table == null) { row.Skip(); <span class="hljs-comment"><span class="hljs-comment">// need to skip this element if we dont know about it, // before returning -1 return -1; } .... if (table == null) throw ExceptionBuilder.DiffgramMissingTable( XmlConvert.DecodeName(row.LocalName)); .... }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3021</u></a> There are two 'if' statements with identical conditional expressions. The first 'if' statement contains method return. This means that the second 'if' statement is senseless XMLDiffLoader.cs 301 <br><br> There are two <i>if</i> statements, containing the equal expression — <i>table == null</i> . With that, <i>then</i> branches of these statements contain different actions — in the first case, the method exits with the value -1, in the second one — an exception is generated. The <i>table</i> variable isn't changed between the checks. Thus, the considered exception won't be generated. <br><br> <b>Issue 34</b> <br><br> Look at the interesting method from the <i>System.ComponentModel.TypeConverter</i> project. Well, let's first read the comment, describing it: <br><br> <i>Removes the last character from the formatted string. (Remove last character in virtual string). On exit the out param contains the position where the operation was actually performed. This position is relative to the test string. The MaskedTextResultHint out param gives more information about the operation result. Returns</i> <b><i>true</i></b> <i>on success,</i> <b><i>false</i></b> <i>otherwise.</i> <br><br> The key point on the return value: if an operation is successful, the method returns <i>true</i> , otherwise — <i>false</i> . Let's see what happens in fact. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> testPosition, out MaskedTextResultHint resultHint)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lastAssignedPos == INVALID_INDEX) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// nothing to remove. } .... return true; }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3009</u></a> It's odd that this method always returns one and the same value of 'true'. MaskedTextProvider.cs 1529 <br><br> In fact, it turns out that the only return value of the method is <i>true</i> . <br><br> <b>Issue 35</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_table != null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_table.fInitInProgress &amp;&amp; _delayLoadingConstraints != null) { .... } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3125</u></a> The '_table' object was used after it was verified against null. Check lines: 437, 423. ConstraintCollection.cs 437 <br><br> The <i>_table != null</i> check speaks for itself — the <i>_table</i> variable can have the <i>null</i> value. At least, in this case code authors get reinsured. However, below they address the instance field via <i>_table</i> but without the check for <i>null</i> — <i>_table .fInitInProgress</i> . <br><br> <b>Issue 36</b> <br><br> Now let's consider several warnings, issued for the code of the <i>System.Runtime.Serialization.Formatters</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (memberNameInfo != null) { .... _serWriter.WriteObjectEnd(memberNameInfo, typeNameInfo); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((objectInfo._objectId == _topId) &amp;&amp; (_topName != null)) { _serWriter.WriteObjectEnd(topNameInfo, typeNameInfo); .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ReferenceEquals(objectInfo._objectType, Converter.s_typeofString)) { _serWriter.WriteObjectEnd(typeNameInfo, typeNameInfo); } }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3038</u></a> The argument was passed to method several times. It is possible that other argument should be passed instead. BinaryObjectWriter.cs 262 <br><br> The analyzer was confused by the last call <i>_serWriter.WriteObjectEnd</i> with two equal arguments — <i>typeNameInfo</i> . It looks like a typo, but I can't say for sure. I decided to check out what is the callee <i>WriteObjectEnd</i> method. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteObjectEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NameInfo memberNameInfo, NameInfo typeNameInfo)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br> Well… Let's move on.  :) <br><br> <b>Issue 37</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteSerializationHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> topId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> headerId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minorVersion, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> majorVersion)</span></span></span><span class="hljs-function"> </span></span>{ var record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializationHeaderRecord( BinaryHeaderEnum.SerializedStreamHeader, topId, headerId, minorVersion, majorVersion); record.Write(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br> When reviewing this code, I wouldn't say at once what's wrong here or what looks suspicious. But the analyzer may well say what's the thing. <br><br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3066</u></a> Possible incorrect order of arguments passed to 'SerializationHeaderRecord' constructor: 'minorVersion' and 'majorVersion'. BinaryFormatterWriter.cs 111 <br><br> See the callee constructor of the <i>SerializationHeaderRecord</i> class. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SerializationHeaderRecord</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BinaryHeaderEnum binaryHeaderEnum, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> topId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> headerId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> majorVersion, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minorVersion)</span></span></span><span class="hljs-function"> </span></span>{ _binaryHeaderEnum = binaryHeaderEnum; _topId = topId; _headerId = headerId; _majorVersion = majorVersion; _minorVersion = minorVersion; }</code> </pre> <br> As we can see, constructor's parameters follow in the order <i>majorVersion</i> , <i>minorVersion</i> ; whereas when calling the constructor they are passed in this order: <i>minorVersion</i> , <i>majorVersion</i> . Seems like a typo. In case it was made deliberately (what if?) — I think it would require an additional comment. <br><br> <b>Issue 38</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ObjectManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ISurrogateSelector selector, StreamingContext context, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> checkSecurity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isCrossAppDomain)</span></span></span><span class="hljs-function"> </span></span>{ _objects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectHolder[DefaultInitialSize]; _selector = selector; _context = context; _isCrossAppDomain = isCrossAppDomain; }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3117</u></a> Constructor parameter 'checkSecurity' is not used. ObjectManager.cs 33 <br><br> The <i>checkSecurity</i> parameter of the constructor isn't used in any way. There are no comments on it. I guess it's left for compatibility, but anyway, in the context of recent security conversations, it looks interesting. <br><br> <b>Issue 39</b> <br><br> Here's the code that seemed unusual to me. The pattern looks one and the same in all three detected cases and is located in methods with equal names and variables names. Consequently: <br><br><ul><li> either I'm not enlightened enough to get the purpose of such duplication; </li><li> or the error was spread by the copy-paste method. </li></ul><br> The code itself: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnlargeArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newLength = _values.Length * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newLength &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newLength == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializationException(SR.Serialization_TooManyElements); } newLength = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } FixupHolder[] temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FixupHolder[newLength]; Array.Copy(_values, <span class="hljs-number"><span class="hljs-number">0</span></span>, temp, <span class="hljs-number"><span class="hljs-number">0</span></span>, _count); _values = temp; }</code> </pre> <br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3022</u></a> Expression 'newLength == int.MaxValue' is always false. ObjectManager.cs 1423 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3022</u></a> Expression 'newLength == int.MaxValue' is always false. ObjectManager.cs 1511 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3022</u></a> Expression 'newLength == int.MaxValue' is always false. ObjectManager.cs 1558 </li></ul><br> What is different in other methods is the type of the <i>temp</i> array elements (not <i>FixupHolder</i> , but <i>long</i> or <i>object</i> ). So I still have suspicions of copy-paste… <br><br> <b>Issue 40</b> <br><br> Code from the <i>System.Data.Odbc</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnquoteIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(quotePrefix) || quotePrefix != <span class="hljs-string"><span class="hljs-string">" "</span></span>) { .... } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3022</u></a> Expression '!string.IsNullOrEmpty(quotePrefix) || quotePrefix != " "' is always true. OdbcCommandBuilder.cs 338 <br><br> The analyzer assumes that the given expression always has the <i>true</i> value. It is really so. It even doesn't matter what value is actually in <i>quotePrefix</i> — the condition itself is written incorrectly. Let's get to the bottom of this. <br><br> We have the || operator, so the expression value will be <i>true</i> , if the left or right (or both) operand will have the <i>true</i> value. It's all clear with the left one. The right one will be evaluated only in case if the left one has the <i>false</i> value. This means, if the expression is composed in the way that the value of the right operand is always <i>true</i> when the value of the left one is <i>false</i> , the result of the entire expression will permanently be <i>true</i> . <br><br> From the code above we know that if the right operand is evaluated, the value of the expression <i>string.IsNullOrEmpty(quotePrefix)</i> — <i>true</i> , so one of these statements is true: <br><br><ul><li> <i>quotePrefix == null</i> ; </li><li> <i>quotePrefix.Length == 0</i> . </li></ul><br> If one of these statements is true, the expression <i>quotePrefix != " "</i> will also be true, which we wanted to prove. Meaning that the value of the entire expression is always <i>true</i> , regardless of the <i>quotePrefix</i> contents. <br><br> <b>Issue 41</b> <br><br> Going back to constructors with unused parameters: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PendingGetConnection</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PendingGetConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dueTime, DbConnection owner, TaskCompletionSource&lt;DbConnectionInternal&gt; completion, DbConnectionOptions userOptions)</span></span></span><span class="hljs-function"> </span></span>{ DueTime = dueTime; Owner = owner; Completion = completion; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> DueTime { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DbConnection Owner { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TaskCompletionSource&lt;DbConnectionInternal&gt; Completion { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DbConnectionOptions UserOptions { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3117</u></a> Constructor parameter 'userOptions' is not used. DbConnectionPool.cs 26 <br><br> We can see from the analyzer warnings and the code, that only one constructor's parameter isn't used <i>— userOptions</i> , and others are used for initializing same-name properties. It looks like a developer forgot to initialize one of the properties. <br><br> <b>Issue 42</b> <br><br> There's suspicious code, that we've come across 2 times. The pattern is the same. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> DataTable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (DataRow row in schemaTable.Rows) { resultTable.Columns .Add(row[<span class="hljs-string"><span class="hljs-string">"ColumnName"</span></span>] as <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, (Type)row[<span class="hljs-string"><span class="hljs-string">"DataType"</span></span>] as Type); } .... }</code> </pre> <br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3051</u></a> An excessive type cast. The object is already of the 'Type' type. DbMetaDataFactory.cs 176 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3051</u></a> An excessive type cast. The object is already of the 'Type' type. OdbcMetaDataFactory.cs 1109 </li></ul><br> The expression <i>(Type)row[«DataType»] as Type</i> looks suspicious. First, explicit casting will be performed, after that — casting via the <i>as</i> operator. If the value <i>row[«DataType»]</i> — <i>null,</i> it will successfully 'pass' through both castings and will do as an argument to the <i>Add</i> method. If <i>row[«DataType»]</i> returns the value, which cannot be casted to the <i>Type</i> type, an exception of the <i>InvalidCastException</i> type will be generated right during the explicit cast. In the end, why do we need two castings here? The question is open. <br><br> <b>Issue 43</b> <br><br> Let's look at the suspicious fragment from <i>System.Runtime.InteropServices.RuntimeInformation</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> FrameworkDescription { get { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s_frameworkDescription == null) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> versionString = (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)AppContext.GetData(<span class="hljs-string"><span class="hljs-string">"FX_PRODUCT_VERSION"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (versionString == null) { .... versionString = typeof(object).Assembly .GetCustomAttribute&lt; AssemblyInformationalVersionAttribute&gt;() ?.InformationalVersion; .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> plusIndex = versionString.IndexOf(<span class="hljs-string"><span class="hljs-string">'+'</span></span>); .... } .... } .... } }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3105</u></a> The 'versionString' variable was used after it was assigned through null-conditional operator. NullReferenceException is possible. RuntimeInformation.cs 29 <br><br> The analyzer warns about a possible exception of the <i>NullReferenceException</i> type when calling the <i>IndexOf</i> method for the <i>versionString</i> variable. When receiving the value for a variable, code authors use the '?.' operator to avoid a <i>NullReferenceException</i> exception when accessing the <i>InfromationalVersion</i> property. The trick is that if the call of <i>GetCustomAttribute&lt;...&gt;</i> returns <i>null</i> , an exception will still be generated, but below — when calling the <i>IndexOf</i> method, as <i>versionString</i> will have the <i>null</i> value. <br><br> <b>Issue 44</b> <br><br> Let's address the <i>System.ComponentModel.Composition</i> project and look through several warnings. Two warnings were issued for the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanSpecialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... object[] genericParameterConstraints = ....; GenericParameterAttributes[] genericParameterAttributes = ....; <span class="hljs-comment"><span class="hljs-comment">// if no constraints and attributes been specifed, anything can be created if ((genericParameterConstraints == null) &amp;&amp; (genericParameterAttributes == null)) { return true; } if ((genericParameterConstraints != null) &amp;&amp; (genericParameterConstraints.Length != partArity)) { return false; } if ((genericParameterAttributes != null) &amp;&amp; (genericParameterAttributes.Length != partArity)) { return false; } for (int i = 0; i &lt; partArity; i++) { if (!GenericServices.CanSpecialize( specialization[i], (genericParameterConstraints[i] as Type[]). CreateTypeSpecializations(specialization), genericParameterAttributes[i])) { return false; } } return true; }</span></span></code> </pre> <br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3125</u></a> The 'genericParameterConstraints' object was used after it was verified against null. Check lines: 603, 589. GenericSpecializationPartCreationInfo.cs 603 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3125</u></a> The 'genericParameterAttributes' object was used after it was verified against null. Check lines: 604, 594. GenericSpecializationPartCreationInfo.cs 604 </li></ul><br> In code there are checks <i>genericParameterAttributes != null</i> and <i>genericParameterConstraints != null</i> . Therefore, <i>null</i> — acceptable values for these variables, we'll take it into account. If both variables have the <i>null</i> value, we'll exit the method, no questions. What if one of two variables mentioned above is <i>null</i> , but in doing so we don't exit the method? If such case is possible and execution gets to traversing the loop, we'll get an exception of the <i>NullReferenceException</i> type. <br><br> <b>Issue 45</b> <br><br> Next we'll move to another interesting warning from this project. And though, let's do something different — first we'll use the class again, and then look at the code. Next, we'll add reference to the same-name NuGet package of the last available prerelease version in the project (I installed the package of the version 4.6.0-preview6.19303.8). Let's write simple code, for example, such as: <br><br><pre> <code class="cpp hljs">LazyMemberInfo lazyMemberInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LazyMemberInfo(); var eq = lazyMemberInfo.Equals(null); Console.WriteLine(eq);</code> </pre> <br> The <i>Equals</i> method isn't commented, I didn't find this method description for .NET Core at docs.microsoft.com, only for .NET Framework. If we look at it (" <u>LazyMemberInfo.Equals(Object) Method</u> ") — we won't see anything special whether it returns <i>true</i> or <i>false</i> , there is no information on generated exceptions. We'll execute the code and see: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e5/8f7/aa4/8e58f7aa4e5a274751cde57da4d9497f.png" alt="Image 16"></div><br> We can get a little twisted and write the following code and also get interesting output: <br><br><pre> <code class="cpp hljs">LazyMemberInfo lazyMemberInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LazyMemberInfo(); var eq = lazyMemberInfo.Equals(typeof(String)); Console.WriteLine(eq);</code> </pre> <br> The result of the code execution. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e74/199/292/e74199292d39b2df8a7b205218c9c1fe.png" alt="Image 17"></div><br><br> Interestingly, these both exceptions are generated in the same expression. Let's look insidethe <i>Equals</i> method. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object obj)</span></span></span><span class="hljs-function"> </span></span>{ LazyMemberInfo that = (LazyMemberInfo)obj; <span class="hljs-comment"><span class="hljs-comment">// Difefrent member types mean different members if (_memberType != that._memberType) { return false; } // if any of the lazy memebers create accessors in a delay-loaded fashion, // we simply compare the creators if ((_accessorsCreator != null) || (that._accessorsCreator != null)) { return object.Equals(_accessorsCreator, that._accessorsCreator); } // we are dealing with explicitly passed accessors in both cases if(_accessors == null || that._accessors == null) { throw new Exception(SR.Diagnostic_InternalExceptionMessage); } return _accessors.SequenceEqual(that._accessors); }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3115</u></a> Passing 'null' to 'Equals' method should not result in 'NullReferenceException'. LazyMemberInfo.cs 116 <br><br> Actually in this case the analyzer screwed up a bit, as it issued a warning for the <i>that._memberType</i> expression. However, exceptions occur earlier when executing the expression <i>(LazyMemberInfo)obj</i> . We've already made a note of it. <br><br> I think it's all clear with <i>InvalidCastException.</i> Why is <i>NullReferenceException</i> generated? The fact is that <i>LazyMemberInfo</i> is a struct, therefore, it gets unboxed. The <i>null</i> value unboxing, in turns, leads to occurrence of an exception of the <i>NullReferenceException</i> type. Also there is a couple of typos in comments — authors should probably fix them. An explicit exception throwing is still on the authors hands. <br><br> <b>Issue 46</b> <br><br> By the way, I came across a similar case in <i>System.Drawing.Common</i> in the <i>TriState</i> structure. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>{ TriState state = (TriState)o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _value == state._value; }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3115</u></a> Passing 'null' to 'Equals' method should not result in 'NullReferenceException'. TriState.cs 53 <br><br> The problems are the same as in the case described above. <br><br> <b>Issue 47</b> <br><br> Let's consider several fragments from <i>System.Text.Json</i> . <br><br> Remember I wrote that <i>ToString</i> mustn't return <i>null</i> ? Time to solidify this knowledge. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (TokenType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.None: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.Null: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Empty; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.True: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>.TrueString; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.False: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>.FalseString; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.Number: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.StartArray: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.StartObject: { <span class="hljs-comment"><span class="hljs-comment">// null parent should have hit the None case Debug.Assert(_parent != null); return _parent.GetRawValueAsString(_idx); } case JsonTokenType.String: return GetString(); case JsonTokenType.Comment: case JsonTokenType.EndArray: case JsonTokenType.EndObject: default: Debug.Fail($"No handler for {nameof(JsonTokenType)}.{TokenType}"); return string.Empty; } }</span></span></code> </pre> <br> At first sight, this method doesn't return <i>null</i> , but the analyzer argues the converse. <br><br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3108</u></a> It is not recommended to return 'null' from 'ToSting()' method. JsonElement.cs 1460 <br><br> The analyzer points to the line with calling the <i>GetString()</i> method. Let's have a look at it. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CheckValidInstance(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _parent.GetString(_idx, JsonTokenType.String); }</code> </pre> <br> Let's go deeper in the overloaded version of the <i>GetString</i> method: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, JsonTokenType expectedType)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tokenType == JsonTokenType.Null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... }</code> </pre> <br> Right after we see the condition, whose execution will result in the <i>null</i> value — both from this method and <i>ToString</i> which we initially considered. <br><br> <b>Issue 48</b> <br><br> Another interesting fragment: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal JsonPropertyInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreatePolymorphicProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ JsonPropertyInfo runtimeProperty = CreateProperty(property.DeclaredPropertyType, runtimePropertyType, property.ImplementedPropertyType, property?.PropertyInfo, Type, options); property.CopyRuntimeSettingsTo(runtimeProperty); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> runtimeProperty; }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3042</u></a> Possible NullReferenceException. The '?.' and '.' operators are used for accessing members of the 'property' object JsonClassInfo.AddProperty.cs 179 <br><br> When calling the <i>CreateProperty</i> method, properties are referred several times through the variable <i>property</i> : <i>property.DeclaredPropertyType</i> , <i>property.ImplementedPropertyType</i> , <i>property?.PropertyInfo</i> . As you can see, in one case code authors use the '?.'  opérateur. If it's not out of place here and <i>property</i> can have the <i>null</i> value, this operator won't be of any help, as an exception of the <i>NullReferenceException</i> type will be generated with direct access. <br><br> <b>Issue 49</b> <br><br> The following suspicious fragments were found in the <i>System.Security.Cryptography.Xml</i> project. They are paired up, the same as it has been several times with other warnings. Again, the code looks like copy-paste, compare these yourself. <br><br> The first fragment: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)</span></span></span><span class="hljs-function"> </span></span>{ docPos = DocPosition.BeforeRootElement; foreach (XmlNode childNode in ChildNodes) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (childNode.NodeType == XmlNodeType.Element) { CanonicalizationDispatcher.Write( childNode, strBuilder, DocPosition.InRootElement, anc); docPos = DocPosition.AfterRootElement; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CanonicalizationDispatcher.Write(childNode, strBuilder, docPos, anc); } } }</code> </pre> <br> The second fragment. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteHash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)</span></span></span><span class="hljs-function"> </span></span>{ docPos = DocPosition.BeforeRootElement; foreach (XmlNode childNode in ChildNodes) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (childNode.NodeType == XmlNodeType.Element) { CanonicalizationDispatcher.WriteHash( childNode, hash, DocPosition.InRootElement, anc); docPos = DocPosition.AfterRootElement; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CanonicalizationDispatcher.WriteHash(childNode, hash, docPos, anc); } } }</code> </pre> <br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3061</u></a> Parameter 'docPos' is always rewritten in method body before being used. CanonicalXmlDocument.cs 37 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3061</u></a> Parameter 'docPos' is always rewritten in method body before being used. CanonicalXmlDocument.cs 54 </li></ul><br> In both methods the <i>docPos</i> parameter is overwritten before its value is used. Therefore, the value, used as a method argument, is simply ignored. <br><br> <b>Issue 50</b> <br><br> Let's consider several warnings on the code of the <i>System.Data.SqlClient</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsBOMNeeded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MetaType type, object value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type.NullableType == TdsEnums.SQLXMLTYPE) { Type currentType = value.GetType(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == typeof(SqlString)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!((SqlString)value).IsNull &amp;&amp; ((((SqlString)value).Value).Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((((SqlString)value).Value[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) != <span class="hljs-number"><span class="hljs-number">0xff</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((currentType == typeof(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)) &amp;&amp; (((String)value).Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((value != null) &amp;&amp; (((<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) != <span class="hljs-number"><span class="hljs-number">0xff</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == typeof(SqlXml)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!((SqlXml)value).IsNull) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == typeof(XmlDataFeed)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Values will eventually converted to unicode string here } } return false; }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3095</u></a> The 'value' object was used before it was verified against null. Check lines: 8696, 8708. TdsParser.cs 8696 <br><br> The analyzer was confused by the check <i>value != null</i> in one of the conditions. It seems like it was lost there during refactoring, as <i>value</i> gets dereferenced many times. If <i>value</i> can have the <i>null</i> value — things are bad. <br><br> <b>Issue 51</b> <br><br> The next error is from tests, but it seemed interesting to me, so I decided to cite it. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> TDSMessageCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateQueryResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( lowerBatchText.Contains(<span class="hljs-string"><span class="hljs-string">"name"</span></span>) &amp;&amp; lowerBatchText.Contains(<span class="hljs-string"><span class="hljs-string">"state"</span></span>) &amp;&amp; lowerBatchText.Contains(<span class="hljs-string"><span class="hljs-string">"databases"</span></span>) &amp;&amp; lowerBatchText.Contains(<span class="hljs-string"><span class="hljs-string">"db_name"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// SELECT [name], [state] FROM [sys].[databases] WHERE [name] = db_name() { // Delegate to current database response responseMessage = _PrepareDatabaseResponse(session); } .... }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3053</u></a> An excessive expression. Examine the substrings 'name' and 'db_name'. QueryEngine.cs 151 <br><br> The fact is that in this case the combination of subexpressions <i>lowerBatchText.Contains(«name»)</i> and <i>lowerBatchText.Contains(«db_name»)</i> is redundant. Indeed, if the checked string contains the substring <i>«db_name»</i> , it will contain the <i>«name»</i> substring as well. If the string doesn't contain <i>«name»</i> , it won't contain <i>«db_name»</i> either. As a result, it turns out that the check <i>lowerBatchText.Contains(«name»)</i> is redundant. Unless it can reduce the number of evaluated expressions, if the checked string doesn't contain <i>«name»</i> . <br><br> <b>Issue 52</b> <br><br> A suspicious fragment from the code of the <i>System.Net.Requests</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override PipelineInstruction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PipelineCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PipelineEntry entry, ResponseDescription response, ....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NetEventSource.IsEnabled) NetEventSource.Info(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, $<span class="hljs-string"><span class="hljs-string">"Command:{entry?.Command} Description:{response?.StatusDescription}"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// null response is not expected if (response == null) return PipelineInstruction.Abort; .... if (entry.Command == "OPTS utf8 on\r\n") .... .... }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3125</u></a> The 'entry' object was used after it was verified against null. Check lines: 270, 227. FtpControlStream.cs 270 <br><br> When composing an interpolated string, such expressions as <i>entry?.Command</i> and <i>response?.Description</i> are used. The '?.' operator is used instead of the '.' operator not to get an exception of the <i>NullReferenceException</i> type in case if any of the corresponding parameters has the <i>null</i> value. In this case, this technique works. Further, as we can see from the code, a possible <i>null</i> value for <i>response</i> gets split off (exit from the method if <i>response == null</i> ), whereas there's nothing similar for <i>entry.</i> As a result, if <i>entry</i> — <i>null</i> further along the code when evaluating <i>entry.Command</i> (with the usage of '.', not '?.'), an exception will be generated. <br><br> At this point, a fairly detailed code review is waiting for us, so I suggest that you have another break — chill out, make some tea or coffee. After that I'll be right here to continue. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/3fc/f07/56a3fcf075284f021a56249627e518bb.png" alt="Image 21"></div><br> Are you back? Then let's keep going.  :) <br><br> <b>Issue 53</b> <br><br> Now let's find something interesting in the <i>System.Collections.Immutable</i> project. This time we'll have some experiments with the <i>System.Collections.Immutable.ImmutableArray&lt;T&gt;</i> struct. The methods <i>IStructuralEquatable.Equals</i> and <i>IStructuralComparable.CompareTo</i> are of special interest for us. <br><br> Let's start with the <i>IStructuralEquatable.Equals</i> method. The code is given below, I suggest that you try to get what's wrong yourself: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IStructuralEquatable.Equals(object other, IEqualityComparer comparer) { var self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; Array otherArray = other as Array; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherArray == null) { var theirs = other as IImmutableArray; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (theirs != null) { otherArray = theirs.Array; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null &amp;&amp; otherArray == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } } IStructuralEquatable ours = self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ours.Equals(otherArray, comparer); }</code> </pre> <br> Did you manage? If yes — my congrats.  :) <br><br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3125</u></a> The 'ours' object was used after it was verified against null. Check lines: 1212, 1204. ImmutableArray_1.cs 1212 <br><br> The analyzer was confused by the call of the instance <i>Equals</i> method through the <i>ours</i> variable, located in the last <i>return</i> expression, as it suggests that an exception of the <i>NullReferenceException</i> type might occur here. Why does the analyzer suggest so? To make it easier to explain, I'm giving a simplified code fragment of the same method below. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IStructuralEquatable.Equals(object other, IEqualityComparer comparer) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null &amp;&amp; otherArray == null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null) { .... } } } IStructuralEquatable ours = self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ours.Equals(otherArray, comparer); }</code> </pre> <br> In the last expressions, we can see, that the value of the <i>ours</i> variable comes from <i>self.array</i> . The check <i>self.array == null</i> is performed several times above. Which means, <i>ours,</i> the same as <i>self.array,</i> can have the <i>null</i> value. At least in theory. Is this state reachable in practice? Let's try to find out. To do this, once again I cite the body of the method with set key points. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IStructuralEquatable.Equals(object other, IEqualityComparer comparer) { var self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= 1 Array otherArray = other as Array; if (otherArray == null) // &lt;= 2 { var theirs = other as IImmutableArray; if (theirs != null) // &lt;= 3 { otherArray = theirs.Array; if (self.array == null &amp;&amp; otherArray == null) { return true; } else if (self.array == null) // &lt;= 4 { return false; } } IStructuralEquatable ours = self.array; // &lt;= 5 return ours.Equals(otherArray, comparer); }</span></span></code> </pre> <br> <b>Key point 1.</b> <i>self.array == this.array</i> (due to <i>self = this</i> ). Therefore, before calling the method, we need to get the condition <i>this.array == null</i> . <br><br> <b>Key point 2</b> . We can ignore this <i>if</i> , which will be the simplest way to get what we want. To ignore this <i>if</i> , we only need the <i>other</i> variable to be of the <i>Array</i> type or a derived one, and not to contain the <i>null</i> value. This way, after using the <i>as</i> operator, a non-null reference will be written in <i>otherArray</i> and we'll ignore the first <i>if</i> statement <i>.</i> <br><br> <b>Key point 3</b> . This point requires a more complex approach. We definitely need to exit on the second <i>if</i> statement (the one with the conditional expression <i>theirs != null</i> ). If it doesn't happen and <i>then</i> branch starts to execute, most certainly we won't get the needed point 5 under the condition <i>self.array == null</i> due to the key point 4. To avoid entering the <i>if</i> statement of the key point 3, one of these conditions has to be met: <br><br><ul><li> the <i>other</i> value has to be <i>null</i> ; </li><li> the actual <i>other</i> type mustn't implement the <i>IImmutableArray</i> interface. </li></ul><br> <b>Key point 5</b> . If we get to this point with the value <i>self.array == null</i> , it means that we've reached our aim, and an exception of the <i>NullReferenceException</i> type will be generated. <br><br> We get the following datasets that will lead us to the needed point. <br><br> First: <i>this.array — null</i> . <br><br> Second — one of the following ones: <br><br><ul><li> <i>other</i> — <i>null</i> ; </li><li> <i>other</i> has the <i>Array</i> type or one derived from it; </li><li> <i>other</i> doesn't have the <i>Array</i> type or a derived from it and in doing so, doesn't implement the <i>IImmutableArray</i> interface. </li></ul><br> <i>array</i> is the field, declared in the following way: <br><br><pre> <code class="cpp hljs">internal T[] <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>;</code> </pre> <br> As <i>ImmutableArray&lt;T&gt;</i> is a structure, it has a default constructor (without arguments) that will result in the <i>array</i> field taking value by default, which is <i>null.</i> And that's what we need. <br><br> Let's not forget that we were investigating an explicit implementation of the interface method, therefore, casting has to be done before the call. <br><br> Now we have the game in hands to reach the exception occurrence in three ways. We add reference to the debugging library version, write the code, execute and see what happens. <br><br> <b>Code fragment 1.</b> <br><br><pre> <code class="cpp hljs">var comparer = EqualityComparer&lt;String&gt;.Default; ImmutableArray&lt;String&gt; immutableArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableArray&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); ((IStructuralEquatable)immutableArray).Equals(null, comparer);</code> </pre> <br> <b>Code fragment 2.</b> <br><br><pre> <code class="cpp hljs">var comparer = EqualityComparer&lt;String&gt;.Default; ImmutableArray&lt;String&gt; immutableArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableArray&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); ((IStructuralEquatable)immutableArray).Equals(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] { }, comparer);</code> </pre> <br> <b>Code fragment 3.</b> <br><br><pre> <code class="cpp hljs">var comparer = EqualityComparer&lt;String&gt;.Default; ImmutableArray&lt;String&gt; immutableArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableArray&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); ((IStructuralEquatable)immutableArray).Equals(typeof(Object), comparer);</code> </pre> <br> The execution result of all three code fragments will be the same, only achieved by different input entry data, and execution paths. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13a/a3b/e8a/13aa3be8a0b68a646aee130773f2c862.png" alt="Image 18"></div><br> <b>Issue 54</b> <br><br> If you didn't forget, we have another method that we need to discredit. :) But this time we won't cover it in such detail. Moreover, we already know some information from the previous example. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IStructuralComparable.CompareTo(object other, IComparer comparer) { var self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; Array otherArray = other as Array; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherArray == null) { var theirs = other as IImmutableArray; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (theirs != null) { otherArray = theirs.Array; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null &amp;&amp; otherArray == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null ^ otherArray == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException( SR.ArrayInitializedStateNotEqual, nameof(other)); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherArray != null) { IStructuralComparable ours = self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ours.CompareTo(otherArray, comparer); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } throw new ArgumentException(SR.ArrayLengthsNotEqual, nameof(other)); }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3125</u></a> The 'ours' object was used after it was verified against null. Check lines: 1265, 1251. ImmutableArray_1.cs 1265 <br><br> As you can see, the case is very similar to the previous example. <br><br> Let's write the following code: <br><br><pre> <code class="cpp hljs">Object other = ....; var comparer = Comparer&lt;String&gt;.Default; ImmutableArray&lt;String&gt; immutableArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableArray&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); ((IStructuralComparable)immutableArray).CompareTo(other, comparer);</code> </pre> <br> We'll try to find some entry data to reach the point, where exception of the <i>NullReferenceException</i> type might occur: <br><br> <b>Value:</b> <i>other</i> — <i>new String[]{ }</i> ; <br><br> Result: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eef/d77/08a/eefd7708a187f5060f2074e642f18434.png" alt="Image 22"></div><br> Thus, we again managed to figure out such data, with which an exception occurs in the method. <br><br> <b>Issue 55</b> <br><br> In the <i>System.Net.HttpListener</i> project I stumbled upon several both suspicious and very similar places. Once again, I can't shake the feeling about copy-paste, taking place here. Since the pattern is the same, we'll look at one code example. I'll cite analyzer warnings for the rest cases. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override IAsyncResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginRead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte[] buffer, ....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NetEventSource.IsEnabled) { NetEventSource.Enter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); NetEventSource.Info(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"buffer.Length:"</span></span> + buffer.Length + <span class="hljs-string"><span class="hljs-string">" size:"</span></span> + size + <span class="hljs-string"><span class="hljs-string">" offset:"</span></span> + offset); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(nameof(buffer)); } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3095</u></a> The 'buffer' object was used before it was verified against null. Check lines: 51, 53. HttpRequestStream.cs 51 <br><br> Generation of an exception of the <i>ArgumentNullException</i> type under the condition <i>buffer == null</i> obviously suggests that <i>null</i> is an unacceptable value for this variable. However, if the value of the <i>NetEventSource.IsEnabled</i> expression is <i>true</i> and <i>buffer</i> — <i>null</i> , when evaluating the <i>buffer.Length</i> expression, an exception of the <i>NullReferenceException</i> type will be generated. As we can see, we won't even reach the <i>buffer == null</i> check in this case. <br><br> PVS-Studio warnings issued for other methods with the pattern: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3095</u></a> The 'buffer' object was used before it was verified against null. Check lines: 49, 51. HttpResponseStream.cs 49 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3095</u></a> The 'buffer' object was used before it was verified against null. Check lines: 74, 75. HttpResponseStream.cs 74 </li></ul><br> <b>Issue 56</b> <br><br> A similar code snippet was in the <i>System.Transactions.Local</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnterState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InternalTransaction tx)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tx._outcomeSource._isoLevel == IsolationLevel.Snapshot) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> TransactionException.CreateInvalidOperationException( TraceSourceType.TraceSourceLtm, SR.CannotPromoteSnapshot, null, tx == null ? Guid.Empty : tx.DistributedTxId); } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3095</u></a> The 'tx' object was used before it was verified against null. Check lines: 3282, 3285. TransactionState.cs 3282 <br><br> Under a certain condition, an author wants to throw an exception of the <i>InvalidOperationException</i> type. When calling the method for creating an exception object, code authors use the <i>tx</i> parameter, check it for <i>null</i> to avoid an exception of the <i>NullReferenceException</i> type when evaluating the <i>tx.DistributedTxId</i> expression. It's ironic that the check won't be of help, as when evaluating the condition of the <i>if</i> statement, instance fields are accessed via the <i>tx</i> variable — <i>tx._outcomeSource._isoLevel</i> . <br><br> <b>Issue 57</b> <br><br> Code from the <i>System.Runtime.Caching</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLimit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cacheMemoryLimitMegabytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> cacheMemoryLimit = cacheMemoryLimitMegabytes; cacheMemoryLimit = cacheMemoryLimit &lt;&lt; MEGABYTE_SHIFT; _memoryLimit = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// never override what the user specifies as the limit; // only call AutoPrivateBytesLimit when the user does not specify one. if (cacheMemoryLimit == 0 &amp;&amp; _memoryLimit == 0) { // Zero means we impose a limit _memoryLimit = EffectiveProcessMemoryLimit; } else if (cacheMemoryLimit != 0 &amp;&amp; _memoryLimit != 0) { // Take the min of "cache memory limit" and // the host's "process memory limit". _memoryLimit = Math.Min(_memoryLimit, cacheMemoryLimit); } else if (cacheMemoryLimit != 0) { // _memoryLimit is 0, but "cache memory limit" // is non-zero, so use it as the limit _memoryLimit = cacheMemoryLimit; } .... }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3022</u></a> Expression 'cacheMemoryLimit != 0 &amp;&amp; _memoryLimit != 0' is always false. CacheMemoryMonitor.cs 250 <br><br> If you look closely at the code, you'll notice that one of the expressions — <i>cacheMemoryLimit != 0 &amp;&amp; _memoryLimit != 0</i> will always be <i>false</i> . Since <i>_memoryLimit</i> has the 0 value (is set before the <i>if</i> statement), the right operand of the &amp;&amp; operator is <i>false</i> . Therefore, the result of the entire expression is <i>false</i> . <br><br> <b>Issue 58</b> <br><br> I cite a suspicious code fragment from the <i>System.Diagnostics.TraceSource</i> project below. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StackNode n = _stack.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == null) { base.Pop(); } _stack.Value = n.Prev; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n.Value; }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3125</u></a> The 'n' object was used after it was verified against null. Check lines: 115, 111. CorrelationManager.cs 115 <br><br> In fact, it is an interesting case. Due to the check <i>n == null,</i> I assume, that <i>null</i> is an expected value for this local variable. If so, an exception of the <i>NullReferenceException</i> type will be generated when accessing the instance property — <i>n.Prev</i> . If in this case <i>n</i> can never be <i>null</i> , <i>base.Pop()</i> will never be called. <br><br> <b>Issue 59</b> <br><br> An interesting code fragment from the <i>System.Drawing.Primitives</i> project. Again, I suggest that you try to find the problem yourself. Here's the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToHtml</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Color c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> colorString = <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Empty; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c.IsEmpty) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> colorString; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ColorUtil.IsSystemColor(c)) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (c.ToKnownColor()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ActiveBorder: colorString = <span class="hljs-string"><span class="hljs-string">"activeborder"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.GradientActiveCaption: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ActiveCaption: colorString = <span class="hljs-string"><span class="hljs-string">"activecaption"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.AppWorkspace: colorString = <span class="hljs-string"><span class="hljs-string">"appworkspace"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Desktop: colorString = <span class="hljs-string"><span class="hljs-string">"background"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Control: colorString = <span class="hljs-string"><span class="hljs-string">"buttonface"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlLight: colorString = <span class="hljs-string"><span class="hljs-string">"buttonface"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlDark: colorString = <span class="hljs-string"><span class="hljs-string">"buttonshadow"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlText: colorString = <span class="hljs-string"><span class="hljs-string">"buttontext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ActiveCaptionText: colorString = <span class="hljs-string"><span class="hljs-string">"captiontext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.GrayText: colorString = <span class="hljs-string"><span class="hljs-string">"graytext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.HotTrack: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Highlight: colorString = <span class="hljs-string"><span class="hljs-string">"highlight"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.MenuHighlight: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.HighlightText: colorString = <span class="hljs-string"><span class="hljs-string">"highlighttext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.InactiveBorder: colorString = <span class="hljs-string"><span class="hljs-string">"inactiveborder"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.GradientInactiveCaption: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.InactiveCaption: colorString = <span class="hljs-string"><span class="hljs-string">"inactivecaption"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.InactiveCaptionText: colorString = <span class="hljs-string"><span class="hljs-string">"inactivecaptiontext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Info: colorString = <span class="hljs-string"><span class="hljs-string">"infobackground"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.InfoText: colorString = <span class="hljs-string"><span class="hljs-string">"infotext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.MenuBar: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Menu: colorString = <span class="hljs-string"><span class="hljs-string">"menu"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.MenuText: colorString = <span class="hljs-string"><span class="hljs-string">"menutext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ScrollBar: colorString = <span class="hljs-string"><span class="hljs-string">"scrollbar"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlDarkDark: colorString = <span class="hljs-string"><span class="hljs-string">"threeddarkshadow"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlLightLight: colorString = <span class="hljs-string"><span class="hljs-string">"buttonhighlight"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Window: colorString = <span class="hljs-string"><span class="hljs-string">"window"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.WindowFrame: colorString = <span class="hljs-string"><span class="hljs-string">"windowframe"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.WindowText: colorString = <span class="hljs-string"><span class="hljs-string">"windowtext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c.IsNamedColor) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == Color.LightGray) { <span class="hljs-comment"><span class="hljs-comment">// special case due to mismatch between Html and enum spelling colorString = "LightGrey"; } else { colorString = c.Name; } } else { colorString = "#" + cRToString("X2", null) + cGToString("X2", null) + cBToString("X2", null); } return colorString; }</span></span></code> </pre> <br> Okay, okay, just kidding… Or did you still find something? Anyway, let's reduce the code to clearly state the issue. <br><br> Here is the short code version: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (c.ToKnownColor()) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Control: colorString = <span class="hljs-string"><span class="hljs-string">"buttonface"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlLight: colorString = <span class="hljs-string"><span class="hljs-string">"buttonface"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3139</u></a> Two or more case-branches perform the same actions. ColorTranslator.cs 302 <br><br> I can't say for sure, but I think it's an error. In other cases, when a developer wanted to return the same value for several enumerators he used several <i>case(s)</i> , following each other. And it's easy enough to make a mistake with copy-paste here, I think. <br><br> Let's dig a little deeper. To get the <i>«buttonface»</i> value from the analyzed <i>ToHtml</i> method, you can pass one of the following values to it (expected): <br><br><ul><li> <i>SystemColors.Control</i> ; </li><li> <i>SystemColors.ControlLight</i> . </li></ul><br> If we check ARGB values for each of these colors, we'll see the following: <br><br><ul><li> <i>SystemColors.Control</i> — <i>(255, 240, 240, 240)</i> ; </li><li> <i>SystemColors.ControlLight — (255, 227, 227, 227)</i> . </li></ul><br> If we call the inverse conversion method <i>FromHtml</i> on the received value ( <i>«buttonface»</i> ), we'll get the color <i>Control (255, 240, 240, 240)</i> . Can we get the <i>ControlLight</i> color from <i>FromHtml</i> ? Yes. This method contains the table of colors, which is the basis for composing colors (in this case). The table's initializer has the following line: <br><br><pre> <code class="cpp hljs">s_htmlSysColorTable[<span class="hljs-string"><span class="hljs-string">"threedhighlight"</span></span>] = ColorUtil.FromKnownColor(KnownColor.ControlLight);</code> </pre> <br> Accordingly, <i>FromHtml</i> returns the <i>ControlLight (255, 227, 227, 227)</i> color for the <i>«threedhighlight»</i> value. I think that's exactly what should have been used in <i>case KnownColor.ControlLight</i> . <br><br> <b>Issue 60</b> <br><br> We'll check out a couple of interesting warnings from the <i>System.Text.RegularExpressions</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TextposDescription</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ var sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> remaining; sb.Append(runtextpos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sb.Length &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) sb.Append(<span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span> - sb.Length); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (runtextpos &gt; runtextbeg) sb.Append(RegexCharClass.CharDescription(runtext[runtextpos - <span class="hljs-number"><span class="hljs-number">1</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sb.Append(<span class="hljs-string"><span class="hljs-string">'^'</span></span>); sb.Append(<span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>); remaining = runtextend - runtextpos; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = runtextpos; i &lt; runtextend; i++) { sb.Append(RegexCharClass.CharDescription(runtext[i])); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sb.Length &gt;= <span class="hljs-number"><span class="hljs-number">64</span></span>) { sb.Length = <span class="hljs-number"><span class="hljs-number">61</span></span>; sb.Append(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { sb.Append(<span class="hljs-string"><span class="hljs-string">'$'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sb.ToString(); }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3137</u></a> The 'remaining' variable is assigned but is not used by the end of the function. RegexRunner.cs 612 <br><br> A value is written in the local <i>remaining</i> variable, but it's not longer used in the method. Perhaps, some code, using it, was removed, but the variable itself was forgotten. Or there is a crucial error and this variable has to somehow be used. <br><br> <b>Issue 61</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> first, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> last)</span></span></span><span class="hljs-function"> </span></span>{ _rangelist.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SingleRange(first, last)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_canonical &amp;&amp; _rangelist.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; first &lt;= _rangelist[_rangelist.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Last) { _canonical = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3063</u></a> A part of conditional expression is always true if it is evaluated: _rangelist.Count &gt; 0. RegexCharClass.cs 523 <br><br> The analyzer rightly noted, that a part of the expression <i>_rangelist.Count &gt; 0</i> will always be <i>true</i> , if this code is executed. Even if this list (which <i>_rangelist</i> points at), was empty, after adding the element <i>_rangelist.Add(....)</i> it wouldn't be the same. <br><br> <b>Issue 62</b> <br><br> Let's look at the warnings of the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3128</u></a> diagnostic rule in the projects <i>System.Drawing.Common</i> and <i>System.Transactions.Local</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayEnumerator</span></span></span><span class="hljs-class"> :</span></span> IEnumerator { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> object[] _array; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> object _item; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _index; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _startIndex; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _endIndex; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArrayEnumerator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object[] </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{ _array = <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; _startIndex = startIndex; _endIndex = _index + count; _index = _startIndex; } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3128</u></a> The '_index' field is used before it is initialized in constructor. PrinterSettings.Windows.cs 1679 <br><br> When initializing the <i>_endIndex</i> field, another <i>_index</i> field is used, which has a standard value <i>default(int)</i> , (that is <i>0</i> ) at the moment of its usage. The <i>_index</i> field is initialized below. In case if it's not an error — the <i>_index</i> variable should have been omitted in this expression not to be confusing. <br><br> <b>Issue 63</b> <br><br><pre> <code class="cpp hljs">internal <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransactionTable</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _timerInterval; .... <span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TransactionTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Create a timer that is initially disabled by specifing // an Infinite time to the first interval _timer = new Timer(new TimerCallback(ThreadTimer), null, Timeout.Infinite, _timerInterval); .... // Store the timer interval _timerInterval = 1 &lt;&lt; TransactionTable.timerInternalExponent; .... } }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3128</u></a> The '_timerInterval' field is used before it is initialized in constructor. TransactionTable.cs 151 <br><br> The case is similar to the one above. First the value of the <i>_timerInterval</i> field is used (while it's still <i>default(int)</i> ) to initialize <i>_timer.</i> Only after that the <i>_timerInterval</i> field itself will be initialized. <br><br> <b>Issue 64</b> <br><br> Next warnings were issued by the diagnostic rule, which is still in development. There's no documentation or final message, but we've already found a couple of interesting fragments with its help. Again these fragments look like <i>copy-paste</i> , so we'll consider only one code fragment. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessNotifyConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... WeakReference reference = (WeakReference)( LdapConnection.s_handleTable[referralFromConnection]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( reference != null &amp;&amp; reference.IsAlive &amp;&amp; null != ((LdapConnection)reference.Target)._ldapHandle) { .... } .... }</code> </pre> <br> <b>PVS-Studio warning (stub):</b> VXXXX TODO_MESSAGE. LdapSessionOptions.cs 974 <br><br> The trick is that after checking <i>reference.IsAlive</i> , garbage might be collected and the object, which <i>WeakReference</i> points to, will be garbage collected. In this case, <i>Target</i> will return the <i>null</i> value. As a result, when accessing the instance field <i>_ldapHandle</i> , an exception of the <i>NullReferenceException</i> type will occur. Microsoft itself warns about this trap with the check IsAlive. A quote from docs.microsoft.com — " <u>WeakReference.IsAlive Property</u> ": <i>Because an object could potentially be reclaimed for garbage collection immediately after the IsAlive property returns true, using this property is not recommended unless you are testing only for a false return value.</i> <br><br><h2> Summary on Analysis </h2><br> Are these all errors and interesting places, found during the analysis? Of course, not! When looking through the analysis results, I was thoroughly checking out the warnings. As their number increased and it became clear there were enough of them for an article, I was scrolling through the results, trying to select only the ones that seemed to me the most interesting. When I got to the last ones (the largest logs), I was only able to look though the warnings until the sight caught on something unusual. So if you dig around, I'm sure you can find much more interesting places. <br><br> For example, I ignored almost all <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3022</u></a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3063</a> warnings. So to speak, if I came across such code: <br><br><pre> <code class="cpp hljs">String str = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str == null) ....</code> </pre> <br> I would omit it, as there were many other interesting places that I wanted to describe. There were warnings on unsafe locking using the <i>lock statement</i> with locking by <i>this</i> and so on — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3090</u></a> ; unsafe event calls — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3083</u></a> <u>;</u> objects, which types implement <i>IDisposable</i> , but for which <i>Dispose</i> / <i>Close</i> isn't called — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3072</u></a> and similar diagnostics and much more. <br><br> I also didn't note problems, written in tests. At least, I tried, but could accidentally take some. Except for a couple of places that I found interesting enough to draw attention to them. But the testing code can also contain errors, due to which the tests will work incorrectly. <br><br> Generally, there are still many things to investigate — but I didn't have the intention to mark <i>all found issues</i> . <br><br> The quality of the code seemed uneven to me. Some projects were perfectly clean, others contained suspicious places. Perhaps we might expect clean projects, especially when it comes to the most commonly used library classes. <br><br> To sum up, we can say, that the code is of quite high-quality, as its amount was considerable. But, as this article suggests, there were some dark corners. <br><br> By the way, a project of this size is also a good test for the analyzer. I managed to find a number of false / weird warnings that I selected to study and correct. So as a result of the analysis, I managed to find the points, where we have to work on the PVS-Studio itself. <br><br><h2>  Conclusion </h2><br> If you got to this place by reading the whole article — let me shake your hand! I hope that I was able to show you interesting errors and demonstrate the benefit of static analysis. If you have learned something new for yourself, that will let you write better code — I will be doubly pleased. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ef/dbc/f2d/6efdbcf2d984bef000cf44face04c6a4.png" alt="Image 23"></div><br> Anyway, some help by the static analysis won't hurt, so suggest that you <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>try PVS-Studio</u></a> on your project and see what interesting places can be found with its usage. If you have any questions or you just want to share interesting found fragments — don't hesitate to write at <a href="">support@viva64.com</a> .  :) <br><br> Best regards! <br><br><h2> PS For .NET Core libraries developers </h2><br> Thank you so much for what you do! Good job! Hopefully this article will help you make the code a bit better. Remember, that I haven't written all suspicious places and you'd better check the project yourself using the analyzer. This way, you'll be able to investigate all warnings in details. Moreover, it'll be more convenient to work with it, rather than with simple text log / list of errors ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">I wrote about this in more details here</a> ). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr463535/">https://habr.com/ru/post/fr463535/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr463513/index.html">Meilleurs cadres de développement Web en 2019</a></li>
<li><a href="../fr463515/index.html">Utilisation de l'API HTMS pour travailler avec une base de données réseau relationnelle</a></li>
<li><a href="../fr463525/index.html">Sélénium, sélénoïde, séléniure, sélendroïde ... Qu'est-ce que tout cela signifie?</a></li>
<li><a href="../fr463527/index.html">Pop up! Transcrit sur iOS</a></li>
<li><a href="../fr463533/index.html">Ce que chaque développeur doit savoir dès le départ</a></li>
<li><a href="../fr463537/index.html">Vérification du code source des bibliothèques .NET Core par l'analyseur statique PVS-Studio</a></li>
<li><a href="../fr463541/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 17. Résumé et feuille de route du cours CCNA</a></li>
<li><a href="../fr463551/index.html">Comment interagir avec les employés et organiser le flux de travail dans les grandes entreprises informatiques</a></li>
<li><a href="../fr463553/index.html">"Allez-vous sur Google?" ou 5 choses que nous avons faites lors de l'embauche (mais plus)</a></li>
<li><a href="../fr463559/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 18. Bases du routage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>