<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé∏ üö´ üëÉüèø V√©rification du code source des biblioth√®ques .NET Core par l'analyseur statique PVS-Studio üôáüèª üëñ üï∫üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les biblioth√®ques .NET Core sont l'un des projets C # les plus populaires sur GitHub. Ce n'est pas une surprise, car il est largement connu et utilis√©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>V√©rification du code source des biblioth√®ques .NET Core par l'analyseur statique PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/463535/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/-a/bm/pb/-abmpb2yelga7y1zu59bejm6vgo.png" alt="Image 19"></div><br>  Les biblioth√®ques .NET Core sont l'un des projets C # les plus populaires sur GitHub.  Ce n'est pas une surprise, car il est largement connu et utilis√©.  De ce fait, une tentative de r√©v√©ler les coins sombres du code source devient plus captivante.  C'est donc ce que nous allons essayer de faire avec l'aide de l'analyseur statique PVS-Studio.  Que pensez-vous - trouverons-nous finalement quelque chose d'int√©ressant? <br><a name="habracut"></a><br>  Je me dirige vers cet article depuis plus d'un an et demi.  √Ä un moment donn√©, j'ai eu l'id√©e dans ma t√™te que les biblioth√®ques .NET Core sont une friandise, et sa v√©rification est tr√®s prometteuse.  Je v√©rifiais le projet plusieurs fois, l'analyseur continuait de trouver des fragments de code de plus en plus int√©ressants, mais cela n'allait pas plus loin que faire d√©filer la liste des avertissements.  Et le voici - c'est finalement arriv√©!  Le projet est v√©rifi√©, l'article est juste devant vous. <br><br><h2>  D√©tails sur le projet et la v√©rification </h2><br>  Si vous vous efforcez de plonger dans l'enqu√™te sur le code - vous pouvez omettre cette section.  Cependant, j'aimerais beaucoup que vous le lisiez, car ici j'en dis plus sur le projet et l'analyseur, ainsi que sur la r√©alisation de l'analyse et la reproduction des erreurs. <br><br><h3>  Projet sous contr√¥le </h3><br>  Peut-√™tre que j'aurais pu ignorer ce qu'est CoreFX (biblioth√®ques .NET Core), mais au cas o√π vous n'en auriez pas entendu parler, la description est donn√©e ci-dessous.  C'est la m√™me chose que sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page</a> du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet sur GitHub</a> , o√π vous pouvez √©galement t√©l√©charger le code source. <br><br>  Description: <i>ce d√©p√¥t contient l'impl√©mentation de la biblioth√®que (appel√©e "CoreFX") pour .NET Core.</i>  <i>Il comprend System.Collections, System.IO, System.Xml et de nombreux autres composants.</i>  <i>Le r√©f√©rentiel .NET Core Runtime correspondant (appel√© "CoreCLR") contient l'impl√©mentation d'ex√©cution pour .NET Core.</i>  <i>Il comprend RyuJIT, le GC .NET et de nombreux autres composants.</i>  <i>Le code de biblioth√®que sp√©cifique au runtime (System.Private.CoreLib) r√©side dans le r√©f√©rentiel CoreCLR.</i>  <i>Il doit √™tre construit et versionn√© en tandem avec le runtime.</i>  <i>Le reste de CoreFX est ind√©pendant de l'impl√©mentation du runtime et peut √™tre ex√©cut√© sur n'importe quel runtime .NET compatible (par exemple CoreRT)</i> . <br><br><h3>  Analyseur utilis√© et m√©thode d'analyse </h3><br>  J'ai v√©rifi√© le code en utilisant l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>analyseur statique PVS-Studio</u></a> .  De mani√®re g√©n√©rale, PVS-Studio peut analyser non seulement le code C #, mais aussi C, C ++, Java.  Jusqu'√† pr√©sent, l'analyse de code C # fonctionne uniquement sous Windows, tandis que le code C, C ++, Java peut √™tre analys√© sous Windows, Linux, macOS. <br><br>  Habituellement, pour v√©rifier les projets C #, j'utilise le plugin PVS-Studio pour Visual Studio (prend en charge les versions 2010-2019), car c'est probablement le sc√©nario d'analyse le plus simple et le plus pratique dans ce cas: solution ouverte, ex√©cutez l'analyse, g√©rez la liste des avertissements.  Cependant, c'est sorti un peu plus compliqu√© avec CoreFX. <br><br>  La partie d√©licate est que le projet n'a pas un seul fichier .sln, donc l'ouvrir dans Visual Studio et effectuer une analyse compl√®te, en utilisant le plugin PVS-Studio, n'est pas possible.  C'est probablement une bonne chose - je ne sais pas vraiment comment Visual Studio g√©rerait une solution de cette taille. <br><br>  Cependant, il n'y a eu aucun probl√®me avec l'analyse, car la distribution PVS-Studio inclut la version en ligne de commande de l'analyseur pour les projets MSBuild (et .sln).  Tout ce que j'avais √† faire √©tait d'√©crire un petit script, qui ex√©cuterait "PVS-Studio_Cmd.exe" pour chaque .sln dans le r√©pertoire CoreFX et enregistrer les r√©sultats dans un r√©pertoire s√©par√© (il est sp√©cifi√© par un drapeau de ligne de commande de l'analyseur) . <br><br>  Presto!  En cons√©quence, j'ai une bo√Æte Pandora avec un ensemble de rapports stockant des choses int√©ressantes.  Si vous le souhaitez, ces journaux peuvent √™tre combin√©s avec l'utilitaire PlogConverter, faisant partie de la distribution.  Pour moi, il √©tait plus pratique de travailler avec des journaux distincts, donc je ne les ai pas fusionn√©s. <br><br>  Pour d√©crire certaines erreurs, je me r√©f√®re √† la documentation des packages docs.microsoft.com et NuGet, t√©l√©chargeables sur nuget.org.  Je suppose que le code d√©crit dans la documentation / packages peut √™tre l√©g√®rement diff√©rent du code analys√©.  Cependant, il serait tr√®s √©trange si, par exemple, la documentation ne d√©crivait pas les exceptions g√©n√©r√©es lors de la possession d'un certain ensemble de donn√©es d'entr√©e, mais la nouvelle version du package les inclurait.  Vous devez admettre que ce serait une surprise douteuse.  La reproduction des erreurs dans les packages de NuGet en utilisant les m√™mes donn√©es d'entr√©e que celles utilis√©es pour le d√©bogage des biblioth√®ques montre que ce probl√®me n'est pas nouveau.  Plus important encore, vous pouvez le ¬´toucher¬ª sans construire le projet √† partir de sources. <br><br>  Ainsi, tenant compte de la possibilit√© d'une d√©synchronisation th√©orique du code, je trouve acceptable de se r√©f√©rer √† la description des m√©thodes pertinentes sur docs.microsoft.com et de reproduire les probl√®mes en utilisant des packages de nuget.org. <br><br>  De plus, je voudrais noter que la description par les liens donn√©s, les informations (commentaires) dans les packages (dans d'autres versions) auraient pu √™tre modifi√©es au cours de la r√©daction de l'article. <br><br><h3>  Autres projets v√©rifi√©s </h3><br>  Au fait, cet article n'est pas unique en son genre.  Nous √©crivons d'autres articles sur les contr√¥les de projets.  Par ce lien, vous pouvez trouver la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liste des projets v√©rifi√©s</a> .  De plus, sur notre site, vous trouverez non seulement des articles de v√©rification de projets, mais aussi divers articles techniques sur C, C ++, C #, Java, ainsi que quelques notes int√©ressantes.  Vous pouvez trouver tout cela dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>blog</u></a> . <br><br>  Mon coll√®gue a d√©j√† v√©rifi√© les biblioth√®ques .NET Core en 2015. Les r√©sultats de l'analyse pr√©c√©dente se trouvent dans l'article correspondant: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>Analyse de No√´l des biblioth√®ques .NET Core (CoreFX)</u></a> ". <br><br><h2>  Erreurs d√©tect√©es, fragments suspects et int√©ressants </h2><br>  Comme toujours, pour plus d'int√©r√™t, je vous sugg√®re de rechercher d'abord les erreurs dans les fragments donn√©s vous-m√™me, puis de lire le message de l'analyseur et la description du probl√®me. <br><br>  Pour plus de commodit√©, j'ai clairement s√©par√© les pi√®ces les unes des autres √† l'aide des √©tiquettes du <b>num√©ro N</b> - de cette fa√ßon, il est plus facile de savoir o√π se termine la description d'une erreur, puis de la suivante.  De plus, il est plus facile de se r√©f√©rer √† des fragments sp√©cifiques. <br><br>  <b>Num√©ro 1</b> <br><br><pre><code class="cpp hljs">abstract <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Principal</span></span></span><span class="hljs-class"> :</span></span> IDisposable { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PrincipalContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( context.ContextType == ContextType.Machine || _ctx.ContextType == ContextType.Machine) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( SR.SaveToNotSupportedAgainstMachineStore); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context == null) { Debug.Assert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unpersisted == <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(SR.NullArguments); } .... } .... }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3095</u></a> L'objet 'context' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifier les lignes: 340, 346. Principal.cs 340 <br><br>  Les d√©veloppeurs indiquent clairement que la valeur <i>nulle</i> pour le param√®tre de <i>contexte</i> n'est pas valide, ils souhaitent le souligner en utilisant l'exception du type <i>InvalidOperationException</i> .  Cependant, juste au-dessus dans la condition pr√©c√©dente, nous pouvons voir une d√©r√©f√©rence inconditionnelle du <i>contexte de</i> r√©f√©rence - <i>context.ContextType</i> .  Par cons√©quent, si la valeur de <i>contexte</i> est <i>null,</i> l'exception du type <i>NullReferenceException</i> sera g√©n√©r√©e √† la place de la valeur <i>InvalidOperationExcetion</i> attendue <i>.</i> <br><br>  Essayons de reproduire le probl√®me.  Nous ajouterons une r√©f√©rence √† la biblioth√®que <i>System.DirectoryServices.AccountManagement</i> au projet et ex√©cuterons le code suivant: <br><br><pre> <code class="cpp hljs">GroupPrincipal groupPrincipal = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroupPrincipal(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrincipalContext(ContextType.Machine)); groupPrincipal.Save(null);</code> </pre> <br>  <i>GroupPrincipal</i> h√©rite de la classe abstraite <i>Principal</i> qui impl√©mente la m√©thode <i>Save qui</i> nous int√©resse.  Nous ex√©cutons donc le code et voyons ce qu'il fallait prouver. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/290/09a/2cc/29009a2cc3a5408808b9814d48bb0dea.png" alt="Image 1"></div><br>  Par souci d'int√©r√™t, vous pouvez essayer de t√©l√©charger le package appropri√© √† partir de NuGet et r√©p√©ter le probl√®me de la m√™me mani√®re.  J'ai install√© le package 4.5.0 et obtenu le r√©sultat attendu. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3de/891/b4a/3de891b4a4ba8100bb63af19e4455842.png" alt="Image 2"></div><br>  <b>Num√©ro 2</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SearchResultCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> findMoreThanOne)</span></span></span><span class="hljs-function"> </span></span>{ searchResult = null; DirectoryEntry clonedRoot = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_assertDefaultNamingContext == null) { clonedRoot = SearchRoot.CloneBrowsable(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { clonedRoot = SearchRoot.CloneBrowsable(); } .... }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3004</u></a> L' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>instruction</u></a> 'then' est √©quivalente √† l'instruction 'else'.  DirectorySearcher.cs 629 <br><br>  Ind√©pendamment du fait que la condition <i>null _assertDefaultNamingContext ==</i> soit vraie ou fausse, les m√™mes actions seront prises, comme <i>alors</i> et <i>sinon les</i> branches de l'instruction <i>if</i> ont les m√™mes corps.  Soit il doit y avoir une autre action dans une branche, soit vous pouvez omettre l'instruction <i>if</i> pour ne pas confondre les d√©veloppeurs et l'analyseur. <br><br>  <b>Num√©ro 3</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DirectoryEntry</span></span></span><span class="hljs-class"> :</span></span> Component { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] propertyNames)</span></span></span><span class="hljs-function"> </span></span>{ .... object[] names = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> object[propertyNames.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; propertyNames.Length; i++) names[i] = propertyNames[i]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_propertyCollection != null &amp;&amp; propertyNames != null) .... .... } .... }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3095</u></a> L'objet 'propertyNames' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 990, 1004. DirectoryEntry.cs 990 <br><br>  Encore une fois, nous voyons un √©trange ordre d'actions.  Dans la m√©thode, il y a un check <i>propertyNames! = Null</i> , c'est-√†-dire que les d√©veloppeurs couvrent leurs bases de <i>null</i> entrant dans la m√©thode.  Mais ci-dessus, vous pouvez voir quelques op√©rations d'acc√®s par cette r√©f√©rence potentiellement nulle - <i>propertyNames.Length</i> et <i>propertyNames [i]</i> .  Le r√©sultat est tout √† fait pr√©visible - l'occurrence d'une exception du type <i>NullReferenceExcepption</i> dans le cas o√π une r√©f√©rence nulle est pass√©e √† la m√©thode. <br><br>  Quelle co√Øncidence!  <i>RefreshCache</i> est une m√©thode publique dans la classe publique.  Et si vous essayiez de reproduire le probl√®me?  Pour ce faire, nous inclurons le syst√®me de biblioth√®que n√©cessaire. <i>Services d'</i> annuaire dans le projet et nous allons √©crire du code comme ceci: <br><br><pre> <code class="cpp hljs">DirectoryEntry de = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DirectoryEntry(); de.RefreshCache(null);</code> </pre> <br>  Apr√®s avoir ex√©cut√© le code, nous pouvons voir ce que nous attendions. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/040/d0a/2d9040d0ae8d91394c476d6788aa7275.png" alt="Image 3"></div><br>  Juste pour le plaisir, vous pouvez essayer de reproduire le probl√®me sur la version finale du package NuGet.  Ensuite, nous ajoutons une r√©f√©rence au package <i>System.DirectoryServices</i> (j'ai utilis√© la version 4.5.0) au projet et ex√©cutons le code d√©j√† familier.  Le r√©sultat est ci-dessous. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d6/31e/309/0d631e3096fa8ba00b41fe10ad1001db.png" alt="Image 4"></div><br>  <b>Num√©ro 4</b> <br><br>  Maintenant, nous allons partir du contraire - nous allons d'abord essayer d'√©crire le code, qui utilise une instance de classe, puis nous regarderons √† l'int√©rieur.  Faisons r√©f√©rence √† la structure <i>System.Drawing.CharacterRange</i> de la biblioth√®que <i>System.Drawing.Common</i> et du package NuGet du m√™me nom. <br><br>  Nous allons utiliser ce morceau de code: <br><br><pre> <code class="cpp hljs">CharacterRange range = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CharacterRange(); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> eq = range.Equals(null); Console.WriteLine(eq);</code> </pre> <br>  Juste au cas o√π, afin de simplement parcourir notre m√©moire, nous nous adresserons √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>docs.microsoft.com</u></a> pour rappeler la valeur retourn√©e attendue de l'expression <i>obj.Equals (null)</i> : <br><br>  <i>Les instructions suivantes doivent √™tre vraies pour toutes les impl√©mentations de la m√©thode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u><i>Equals (Object)</i></u></a> .</i>  <i>Dans la liste, x, y et z repr√©sentent des r√©f√©rences d'objet qui ne sont pas nulles.</i> <br><br>  <i>....</i> <br><br>  <b><i>x.Equals (null) renvoie false.</i></b> <br><br>  Pensez-vous que le texte "False" sera affich√© dans la console?  Bien s√ªr que non.  Ce serait trop facile.  :) Par cons√©quent, nous ex√©cutons le code et examinons le r√©sultat. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e87/159/8f6/e871598f6ca5dacdb4a4fae7b5776520.png" alt="Image 5"></div><br>  Il s'agissait de la sortie du code ci-dessus √† l'aide du package NuGet <i>System.Drawing.Common</i> de la version 4.5.1.  L'√©tape suivante consiste √† ex√©cuter le m√™me code avec la version de la biblioth√®que de d√©bogage.  Voici ce que nous voyons: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e9/f27/f1a/6e9f27f1a78768078fdd940e0a4be0ad.png" alt="Image 6"></div><br>  Examinons maintenant le code source, en particulier, l'impl√©mentation de la m√©thode <i>Equals</i> dans la structure <i>CharacterRange</i> et l'avertissement de l'analyseur: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj.GetType() != typeof(CharacterRange)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; CharacterRange cr = (CharacterRange)obj; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((_first == cr.First) &amp;&amp; (_length == cr.Length)); }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3115</u></a> Passer la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>m√©thode</u></a> 'null' √† 'Equals' ne devrait pas entra√Æner 'NullReferenceException'.  CharacterRange.cs 56 <br><br>  Nous pouvons observer ce qui devait √™tre prouv√© - le param√®tre <i>obj</i> est mal g√©r√©.  Pour cette raison, l'exception <i>NullReferenceException</i> se produit dans l'expression conditionnelle lors de l'appel de la m√©thode d'instance <i>GetType.</i> <br><br>  <b>Num√©ro 5</b> <br><br>  Pendant que nous explorons cette biblioth√®que, consid√©rons un autre fragment int√©ressant - la m√©thode <i>Icon</i> <i>.</i> <i>Save</i> <i>.</i>  Avant la recherche, regardons la description de la m√©thode. <br><br>  Il n'y a pas de description de la m√©thode: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffd/fef/402/ffdfef402f77c462c94b9ff284f42e0c.png" alt="Image 7"></div><br>  Abordons docs.microsoft.com - " <u>Icon.Save (Stream) Method</u> ".  Cependant, il n'y a √©galement aucune restriction sur les entr√©es ou les informations sur les exceptions g√©n√©r√©es. <br><br>  Passons maintenant √† l'inspection du code. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Icon</span></span></span><span class="hljs-class"> :</span></span> MarshalByRefObject, ICloneable, IDisposable, ISerializable { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream outputStream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_iconData != null) { outputStream.Write(_iconData, <span class="hljs-number"><span class="hljs-number">0</span></span>, _iconData.Length); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (outputStream == null) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"dataStream"</span></span>); .... } } .... }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3095</u></a> L'objet 'outputStream' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 654, 672. Icon.Windows.cs 654 <br><br>  Encore une fois, c'est l'histoire que nous connaissons d√©j√† - d√©r√©f√©rence possible d'une r√©f√©rence nulle, car le param√®tre de la m√©thode est d√©r√©f√©renc√© sans v√©rifier la valeur <i>nulle</i> .  Encore une fois, une co√Øncidence r√©ussie des circonstances - la classe et la m√©thode sont publiques, afin que nous puissions essayer de reproduire le probl√®me. <br><br>  Notre t√¢che est simple: apporter l'ex√©cution de code √† l'expression <i>outputStream.Write (_iconData, 0, _iconData.Length);</i>  et en m√™me temps, enregistrez la valeur de la variable <i>outputStream</i> - <i>null</i> .  La condition <i>_iconData! = Null</i> suffit pour cela. <br><br>  Regardons le constructeur public le plus simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Icon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fileName, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br>  Il d√©l√®gue simplement le travail √† un autre constructeur. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Icon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (FileStream f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read)) { Debug.Assert(f != null, <span class="hljs-string"><span class="hljs-string">"File.OpenRead returned null instead of throwing an exception"</span></span>); _iconData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)f.Length]; f.Read(_iconData, <span class="hljs-number"><span class="hljs-number">0</span></span>, _iconData.Length); } Initialize(width, height); }</code> </pre> <br>  Voil√†, c'est ce dont nous avons besoin.  Apr√®s avoir appel√© ce constructeur, si nous lisons avec succ√®s les donn√©es du fichier et qu'il n'y a pas de plantage dans la m√©thode <i>Initialize</i> , le champ <i>_iconData</i> contiendra une r√©f√©rence √† un objet, c'est ce dont nous avons besoin. <br><br>  Il s'av√®re que nous devons cr√©er l'instance de la classe <i>Icon</i> et sp√©cifier un fichier d'ic√¥ne r√©el pour reproduire le probl√®me.  Apr√®s cela, nous devons appeler la m√©thode <i>Save</i> , apr√®s avoir pass√© la valeur <i>nulle</i> en argument, c'est ce que nous faisons.  Le code pourrait ressembler √† ceci, par exemple: <br><br><pre> <code class="cpp hljs">Icon icon = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Icon(@<span class="hljs-string"><span class="hljs-string">"D:\document.ico"</span></span>); icon.Save(null);</code> </pre> <br>  Le r√©sultat de l'ex√©cution est attendu. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b37/fdb/dd1/b37fdbdd1288c054fdaaa0add0ffcfcf.png" alt="Image 8"></div><br>  <b>Num√©ro 6</b> <br><br>  Nous continuons l'examen et continuons.  Essayez de trouver 3 diff√©rences entre les actions, ex√©cut√©es dans le <i>cas CimType.UInt32</i> et dans les autres <i>cas</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertToNumericValueAndAddToArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> retFunctionName = <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Empty; enumType = <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Empty; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(cimType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.UInt8: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.SInt8: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.SInt16: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.UInt16: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.SInt32: arrayToAdd.Add(System.Convert.ToInt32( numericValue, (IFormatProvider)CultureInfo.InvariantCulture .GetFormat(typeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)))); retFunctionName = <span class="hljs-string"><span class="hljs-string">"ToInt32"</span></span>; enumType = <span class="hljs-string"><span class="hljs-string">"System.Int32"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.UInt32: arrayToAdd.Add(System.Convert.ToInt32( numericValue, (IFormatProvider)CultureInfo.InvariantCulture .GetFormat(typeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)))); retFunctionName = <span class="hljs-string"><span class="hljs-string">"ToInt32"</span></span>; enumType = <span class="hljs-string"><span class="hljs-string">"System.Int32"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retFunctionName; }</code> </pre> <br>  Bien s√ªr, il n'y a aucune diff√©rence, car l'analyseur nous en avertit. <br><br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3139</u></a> Deux ou plusieurs branches de cas effectuent les m√™mes actions.  WMIGenerator.cs 5220 <br><br>  Personnellement, ce style de code n'est pas tr√®s clair.  S'il n'y a pas d'erreur, je pense, la m√™me logique n'aurait pas d√ª √™tre appliqu√©e √† diff√©rents cas. <br><br>  <b>Num√©ro 7</b> <br><br>  Biblioth√®que <i>Microsoft.CSharp</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IList&lt;KeyValuePair&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, object&gt;&gt; QueryDynamicObject(object obj) { .... List&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; names = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(mo.GetDynamicMemberNames()); names.Sort(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (names != null) { .... } .... }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3022 L'</u></a> expression 'names! = Null' est toujours vraie.  DynamicDebuggerProxy.cs 426 <br><br>  Je pourrais probablement ignorer cet avertissement ainsi que de nombreux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>messages</u></a> similaires √©mis par les diagnostics <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3022</u></a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3063</u></a> .  Il y a eu beaucoup (beaucoup) de v√©rifications √©tranges, mais celle-ci est entr√©e dans mon √¢me.  Peut-√™tre, la raison r√©side dans ce qui se passe avant de comparer la variable des <i>noms</i> locaux avec <i>null.</i>  Non seulement la r√©f√©rence est stock√©e dans la variable <i>names</i> pour un objet nouvellement cr√©√©, mais la m√©thode <i>Sort de</i> l'instance est √©galement appel√©e.  Bien s√ªr, ce n'est pas une erreur mais, pour moi, √ßa vaut la peine d'y pr√™ter attention. <br><br>  <b>Num√©ro 8</b> <br><br>  Un autre morceau de code int√©ressant: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertChildNoGrow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Symbol child)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sym?.nextSameName != null) { sym = sym.nextSameName; } Debug.Assert(sym != null &amp;&amp; sym.nextSameName == null); sym.nextSameName = child; .... }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3042</u></a> Exception <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>NullReferenceException</u></a> possible.  Le '?.'  et '.'  les op√©rateurs sont utilis√©s pour acc√©der aux membres de l'objet 'sym' SymbolStore.cs 56 <br><br>  Regardez ce que c'est.  La boucle se termine lors du respect d'au moins une des deux conditions: <br><br><ul><li>  <i>sym == null</i> ; </li><li>  <i>sym.nextSameName == null</i> . </li></ul><br>  Il n'y a aucun probl√®me avec la deuxi√®me condition, qui ne peut pas √™tre dite √† propos de la premi√®re.  √âtant donn√© que le champ d'instance de <i>noms</i> est accessible sans condition ci-dessous et si <i>sym</i> - <i>null</i> , une exception du type <i>NullReferenceException</i> se produira. <br><br>  √ätes-vous aveugle?  Il y a l'appel <i>Debug.Assert</i> , o√π il est v√©rifi√© que <i>sym! = Null</i> ‚Äù- quelqu'un pourrait discuter.  Bien au contraire, c'est le point!  Lorsque vous travaillez dans la version Release, <i>Debug.Assert</i> ne sera d'aucune aide et avec la condition ci-dessus, tout ce que nous obtiendrons sera <i>NullReferenceException</i> .  De plus, j'ai d√©j√† vu une erreur similaire dans un autre projet de Microsoft - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>Roslyn</u></a> , o√π une situation similaire avec <i>Debug.Assert a</i> eu lieu.  Permettez-moi de me d√©tourner un instant pour Roslyn. <br><br>  Le probl√®me peut √™tre reproduit lors de l'utilisation des biblioth√®ques <i>Microsoft.CodeAnalysis</i> ou directement dans Visual Studio lors de l'utilisation de Syntax Visualizer.  Dans Visual Studio 16.1.6 + Syntax Visualizer 1.0, ce probl√®me peut toujours √™tre reproduit. <br><br>  Ce code lui suffit: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C1</span></span></span><span class="hljs-class">&lt;T1, T2&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T1 val = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val is null) { } } }</code> </pre> <br>  De plus, dans Syntax Visualizer, nous devons trouver le n≈ìud de l'arbre de syntaxe du type <i>ConstantPatternSyntax</i> , correspondant √† <i>null</i> dans le code et demander <i>TypeSymbol</i> pour cela. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/855/b9c/baa/855b9cbaa67c9a5909117d513e154293.png" alt="Image 9"></div><br>  Apr√®s cela, Visual Studio red√©marrera.  Si nous allons √† l'Observateur d'√©v√©nements, nous trouverons des informations sur les probl√®mes dans les biblioth√®ques: <br><br><pre> <code class="cpp hljs">Application: devenv.exe Framework Version: v4<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.30319</span></span> Description: The process was terminated due to an unhandled exception. Exception Info: System.Resources.MissingManifestResourceException at System.Resources.ManifestBasedResourceGroveler .HandleResourceStreamMissing(System.String) at System.Resources.ManifestBasedResourceGroveler.GrovelForResourceSet( System.Globalization.CultureInfo, System.Collections.Generic.Dictionary<span class="hljs-string"><span class="hljs-string">'2 &lt;System.String,System.Resources.ResourceSet&gt;, Boolean, Boolean, System.Threading.StackCrawlMark ByRef) at System.Resources.ResourceManager.InternalGetResourceSet( System.Globalization.CultureInfo, Boolean, Boolean, System.Threading.StackCrawlMark ByRef) at System.Resources.ResourceManager.InternalGetResourceSet( System.Globalization.CultureInfo, Boolean, Boolean) at System.Resources.ResourceManager.GetString(System.String, System.Globalization.CultureInfo) at Roslyn.SyntaxVisualizer.DgmlHelper.My. Resources.Resources.get_SyntaxNodeLabel() ....</span></span></code> </pre> <br>  Quant au probl√®me avec devenv.exe: <br><br><pre> <code class="cpp hljs">Faulting application name: devenv.exe, version: <span class="hljs-number"><span class="hljs-number">16.1</span></span><span class="hljs-number"><span class="hljs-number">.29102</span></span><span class="hljs-number"><span class="hljs-number">.190</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5d1c133b</span></span> Faulting <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> name: KERNELBASE.dll, version: <span class="hljs-number"><span class="hljs-number">10.0</span></span><span class="hljs-number"><span class="hljs-number">.18362</span></span><span class="hljs-number"><span class="hljs-number">.145</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0xf5733ace</span></span> Exception code: <span class="hljs-number"><span class="hljs-number">0xe0434352</span></span> Fault offset: <span class="hljs-number"><span class="hljs-number">0x001133d2</span></span> ....</code> </pre> <br>  Avec les versions de d√©bogage des biblioth√®ques Roslyn, vous pouvez trouver l'endroit o√π il y avait une exception: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Conversion </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassifyImplicitBuiltInConversionSlow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeSymbol source, TypeSymbol destination, ref HashSet&lt;DiagnosticInfo&gt; useSiteDiagnostics)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert((object)source != null); Debug.Assert((object)destination != null); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( source.SpecialType == SpecialType.System_Void || destination.SpecialType == SpecialType.System_Void) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; } .... }</code> </pre> <br>  Ici, de la m√™me mani√®re que dans le code des biblioth√®ques .NET Core consid√©r√© ci-dessus, il y a une v√©rification de <i>Debug.Assert</i> qui n'aiderait pas lors de l'utilisation des versions de lib√©ration des biblioth√®ques. <br><br>  <b>Num√©ro 9</b> <br><br>  Nous avons un petit d√©calage ici, revenons donc aux biblioth√®ques .NET Core.  Le package <i>System.IO.IsolatedStorage</i> contient le code int√©ressant suivant. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ContainsUnknownFiles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> directory)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (files.Length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> || ( (!IsIdFile(files[<span class="hljs-number"><span class="hljs-number">0</span></span>]) &amp;&amp; !IsInfoFile(files[<span class="hljs-number"><span class="hljs-number">0</span></span>]))) || (files.Length == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; !IsIdFile(files[<span class="hljs-number"><span class="hljs-number">1</span></span>]) &amp;&amp; !IsInfoFile(files[<span class="hljs-number"><span class="hljs-number">1</span></span>])) ); }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3088</u></a> L'expression a √©t√© plac√©e entre parenth√®ses deux fois: ((expression)).  Une paire de parenth√®ses n'est pas n√©cessaire ou une erreur d'impression est pr√©sente.  IsolatedStorageFile.cs 839 <br><br>  Dire que le formatage du code pr√™te √† confusion est une autre fa√ßon de ne rien dire.  Apr√®s avoir regard√© bri√®vement ce code, je dirais que l'op√©rande gauche du premier ||  L'op√©rateur que j'ai rencontr√© √©tait des <i>fichiers. Longueur&gt; 2</i> , celle de droite est celle entre parenth√®ses.  Au moins, le code est format√© comme ceci.  Apr√®s avoir regard√© un peu plus attentivement, vous pouvez comprendre que ce n'est pas le cas.  En fait, l'op√©rande droit - <i>((!! IsIdFile (fichiers [0]) &amp;&amp;! IsInfoFile (fichiers [0])))</i> .  Je pense que ce code est assez d√©routant. <br><br>  <b>Num√©ro 10</b> <br><br>  PVS-Studio 7.03 a introduit la r√®gle de diagnostic <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3138</u></a> , qui recherche les erreurs dans la cha√Æne interpol√©e.  Plus pr√©cis√©ment, dans la cha√Æne qui a probablement d√ª √™tre interpol√©e, mais √† cause du symbole <i>$</i> manqu√©, ils ne le sont pas <i>.</i>  Dans les biblioth√®ques <i>System.Net</i> , j'ai trouv√© plusieurs occurrences int√©ressantes de cette r√®gle de diagnostic. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CacheCredential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SafeFreeCredentials newHandle)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ExceptionCheck.IsFatal(e)) { NetEventSource.Fail(null, <span class="hljs-string"><span class="hljs-string">"Attempted to throw: {e}"</span></span>); } } }</code> </pre> <br>  <b>Avertissement PVS-Studio: le</b> litt√©ral de cha√Æne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3138</u></a> contient une expression interpol√©e potentielle.  Envisagez d'inspecter: e.  SSPIHandleCache.cs 42 <br><br>  Il est tr√®s probable que le deuxi√®me argument de la m√©thode <i>Fail</i> devait √™tre une cha√Æne interpol√©e, dans laquelle la repr√©sentation de cha√Æne de l'exception <i>e</i> serait remplac√©e.  Cependant, en raison d'un symbole <i>$</i> manqu√©, aucune repr√©sentation sous forme de cha√Æne n'a √©t√© remplac√©e. <br><br>  <b>Num√©ro 11</b> <br><br>  Voici un autre cas similaire. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> async Task&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; GetDigestTokenForCredential(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NetEventSource.IsEnabled) NetEventSource.Error(digestResponse, <span class="hljs-string"><span class="hljs-string">"Algorithm not supported: {algorithm}"</span></span>); .... }</code> </pre> <br>  <b>Avertissement PVS-Studio: le</b> litt√©ral de cha√Æne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3138</u></a> contient une expression interpol√©e potentielle.  Pensez √† inspecter: algorithme.  AuthenticationHelper.Digest.cs 58 <br><br>  La situation est similaire √† celle ci-dessus, encore une fois le symbole <i>$</i> est manquant, ce qui entra√Æne une cha√Æne incorrecte, entrant dans la m√©thode <i>Error</i> <i>.</i> <br><br>  <b>Num√©ro 12</b> <br><br>  <i>Package System.Net.Mail</i> .  La m√©thode est petite, je vais la citer en entier afin de rendre la recherche du bug plus int√©ressante. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream stream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stream == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(nameof(stream)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_streamSet) { _stream.Close(); _stream = null; _streamSet = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } _stream = stream; _streamSet = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; _streamUsedOnce = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; TransferEncoding = TransferEncoding.Base64; }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3008</u></a> La variable '_streamSet' se voit attribuer des valeurs deux fois de suite.  C'est peut-√™tre une erreur.  V√©rifiez les lignes: 123, 119. MimePart.cs 123 <br><br>  L'affectation d'une valeur double √† la variable <i>_streamSet</i> semble √©trange (d'abord - sous la condition, puis - √† l'ext√©rieur).  M√™me histoire avec la r√©initialisation de la variable de <i>flux</i> .  Par cons√©quent, <i>_stream</i> aura toujours le <i>flux de</i> valeurs et <i>_streamSet</i> sera <i>vrai.</i> <br><br>  <b>Num√©ro 13</b> <br><br>  Un fragment de code int√©ressant de la biblioth√®que <i>System.Linq.Expressions</i> qui d√©clenche 2 avertissements d'analyseur √† la fois.  Dans ce cas, cela ressemble plus √† une fonctionnalit√© qu'√† un bug.  Cependant, la m√©thode est assez inhabituelle ... <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// throws NRE when o is null protected static void NullCheck(object o) { if (o == null) { o.GetType(); } }</span></span></code> </pre> <br>  <b>Avertissements de PVS-Studio:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3010</u></a> La valeur de retour de la fonction 'GetType' doit √™tre utilis√©e.  Instruction.cs 36 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3080 D√©r√©f√©rence</u></a> nulle possible.  Pensez √† inspecter ¬´o¬ª.  Instruction.cs 36 </li></ul><br>  Il n'y a probablement rien √† commenter ici. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c9/a88/a22/5c9a88a221d4cd5ba5f4f1d9f74a346b.png" alt="Image 20"></div><br>  <b>Num√©ro 14</b> <br><br>  Prenons un autre cas, que nous traiterons "de l'ext√©rieur".  D'abord, nous allons √©crire le code, d√©tecter les probl√®mes, puis nous allons regarder √† l'int√©rieur.  Nous prendrons la biblioth√®que <i>System.Configuration.ConfigurationManager</i> et le package NuGet du m√™me nom pour examen.  J'ai utilis√© le package de version 4.5.0.  Nous traiterons de la classe <i>System.Configuration.CommaDelimitedStringCollection</i> . <br><br>  Faisons quelque chose de peu sophistiqu√©.  Par exemple, nous allons cr√©er un objet, extraire sa repr√©sentation de cha√Æne et obtenir la longueur de cette cha√Æne, puis l'imprimer.  Le code correspondant: <br><br><pre> <code class="cpp hljs">CommaDelimitedStringCollection collection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CommaDelimitedStringCollection(); Console.WriteLine(collection.ToString().Length);</code> </pre> <br>  Au cas o√π, nous allons consulter la description de la m√©thode <i>ToString</i> : <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8dc/544/56d/8dc54456dd1296d89fbe447fac71ac17.png" alt="Image 11"></div><br>  Rien de sp√©cial - la repr√©sentation sous forme de cha√Æne d'un objet est renvoy√©e.  Au cas o√π, je vais consulter docs.microsoft.com - " <u>CommaDelimitedStringCollection.ToString Method</u> ".  Il semble qu'il n'y ait rien de sp√©cial ici. <br><br>  D'accord, ex√©cutons le code, aaand ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa5/89f/1af/fa589f1afc8ceb9415694e1261e59ab7.png" alt="Image 12"></div><br>  Hum, surprise.  Eh bien, essayons d'ajouter un √©l√©ment √† la collection, puis d'obtenir sa repr√©sentation sous forme de cha√Æne.  Ensuite, nous allons "absolument accidentellement" ajouter une cha√Æne vide :).  Le code changera et ressemblera √† ceci: <br><br><pre> <code class="cpp hljs">CommaDelimitedStringCollection collection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CommaDelimitedStringCollection(); collection.Add(String.Empty); Console.WriteLine(collection.ToString().Length);</code> </pre> <br>  Ex√©cutez et voyez ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d37/4bc/d2e/d374bcd2ed23bd048276493ed19d30fe.png" alt="Image 13"></div><br>  Quoi encore?!  Eh bien, abordons enfin l'impl√©mentation de la m√©thode <i>ToString √†</i> partir de la classe <i>CommaDelimitedStringCollection</i> .  Le code est ci-dessous: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Count &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); foreach (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> str in <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { ThrowIfContainsDelimiter(str); <span class="hljs-comment"><span class="hljs-comment">// .... sb.Append(str.Trim()); sb.Append(','); } if (sb.Length &gt; 0) sb.Length = sb.Length - 1; return sb.Length == 0 ? null : sb.ToString(); }</span></span></code> </pre> <br>  <b>Avertissements de PVS-Studio:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3108</u></a> Il n'est pas recommand√© de renvoyer 'null' √† partir de la m√©thode 'ToSting ()'.  StringAttributeCollection.cs 57 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3108</u></a> Il n'est pas recommand√© de renvoyer 'null' √† partir de la m√©thode 'ToSting ()'.  StringAttributeCollection.cs 71 </li></ul><br>  Ici, nous pouvons voir 2 fragments, o√π l'impl√©mentation actuelle de <i>ToString</i> peut retourner <i>null.</i>  √Ä ce stade, nous nous souviendrons de la recommandation de Microsoft sur la mise en ≈ìuvre de la m√©thode <i>ToString</i> .  Consultez donc docs.microsoft.com - " <u>M√©thode Object.ToString</u> ": <br><br>  <i>Notes aux h√©ritiers .... Les remplacements de la m√©thode ToString () doivent suivre ces directives:</i> <br><br><ul><li>  <i>....</i> </li><li>  <i>Votre remplacement ToString () ne doit pas renvoyer vide ou une</i> <i>cha√Æne</i> <b><i>nulle</i></b> <i>.</i> </li><li>  <i>....</i> </li></ul><br>  C'est ce √† quoi PVS-Studio met en garde.  Deux fragments de code donn√©s ci-dessus que nous √©crivions pour reproduire le probl√®me obtiennent des points de sortie diff√©rents - le premier et le deuxi√®me point de retour <i>nul</i> respectivement.  Creusons un peu plus profond√©ment. <br><br>  Premier cas.  <i>Count</i> est une propri√©t√© de la classe <i>StringCollection de</i> base.  Aucun √©l√©ment n'ayant √©t√© ajout√©, <i>Count == 0</i> , la condition <i>Count &lt;= 0</i> est vraie, la valeur <i>nulle</i> est renvoy√©e. <br><br>  Dans le deuxi√®me cas, nous avons ajout√© l'√©l√©ment en utilisant la m√©thode d'instance <i>CommaDelimitedStringCollection.Add</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">new</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ ThrowIfReadOnly(); ThrowIfContainsDelimiter(value); _modified = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; base.Add(value.Trim()); }</code> </pre> <br>  Les v√©rifications r√©ussissent dans la m√©thode <i>ThrowIf ...</i> et l'√©l√©ment est ajout√© dans la collection de base.  Par cons√©quent, la valeur <i>Count</i> devient 1. Revenons maintenant √† la m√©thode <i>ToString</i> .  Valeur de l'expression <i>Count &lt;= 0</i> - <i>false</i> , donc la m√©thode ne retourne pas et l'ex√©cution du code continue.  La collection interne est travers√©e, 2 √©l√©ments sont ajout√©s √† l'instance de type <i>StringBuilder</i> - une cha√Æne vide et une virgule.  Par cons√©quent, il s'av√®re que <i>sb</i> ne contient qu'une virgule, la valeur de la propri√©t√© <i>Length</i> est respectivement √©gale √† 1. La valeur de l'expression <i>sb.Length&gt; 0</i> est <i>vraie</i> , la soustraction et l'√©criture en <i>sb.Length</i> sont effectu√©es, maintenant la valeur de <i>sb.Length</i> est 0. Cela conduit au fait que la valeur <i>nulle</i> est √† nouveau renvoy√©e par la m√©thode. <br><br>  <b>Num√©ro 15</b> <br><br>  Tout d'un coup, j'ai eu envie d'utiliser la classe <i>System.Configuration.ConfigurationProperty</i> .  Prenons un constructeur avec le plus grand nombre de param√®tres: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigurationProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, Type type, object defaultValue, TypeConverter typeConverter, ConfigurationValidatorBase validator, ConfigurationPropertyOptions options, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> description)</span></span></span></span>;</code> </pre> <br>  Voyons la description du dernier param√®tre: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// description: // The description of the configuration entity.</span></span></code> </pre> <br>  La m√™me chose est √©crite dans la description du constructeur sur docs.microsoft.com.  Eh bien, regardons comment ce param√®tre est utilis√© dans le corps du constructeur: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigurationProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> description)</span></span></span><span class="hljs-function"> </span></span>{ ConstructorInit(name, type, options, validator, typeConverter); SetDefaultValue(defaultValue); }</code> </pre> <br>  Croyez-le ou non, le param√®tre n'est pas utilis√©. <br><br>  <b>Avertissement PVS-Studio: le</b> param√®tre constructeur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3117</u></a> 'description' n'est pas utilis√©.  ConfigurationProperty.cs 62 <br><br>  Les auteurs de code ne l'utilisent probablement pas intentionnellement, mais la description du param√®tre pertinent est tr√®s d√©routante. <br><br>  <b>Num√©ro 16</b> <br><br>  Voici un autre fragment similaire: essayez de trouver l'erreur vous-m√™me, je donne le code du constructeur ci-dessous. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SectionXmlInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> configKey, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> definitionConfigPath, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetConfigPath, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> subPath, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lineNumber, object streamVersion, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rawXml, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> configSource, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> configSourceStreamName, object configSourceStreamVersion, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> protectionProviderName, OverrideModeSetting overrideMode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> skipInChildApps)</span></span></span><span class="hljs-function"> </span></span>{ ConfigKey = configKey; DefinitionConfigPath = definitionConfigPath; TargetConfigPath = targetConfigPath; SubPath = subPath; Filename = filename; LineNumber = lineNumber; StreamVersion = streamVersion; RawXml = rawXml; ConfigSource = configSource; ConfigSourceStreamName = configSourceStreamName; ProtectionProviderName = protectionProviderName; OverrideModeSetting = overrideMode; SkipInChildApps = skipInChildApps; }</code> </pre> <br>  <b>Avertissement PVS-Studio: le</b> param√®tre constructeur V3117 'configSourceStreamVersion' n'est pas utilis√©.  SectionXmlInfo.cs 16 <br><br>  Il y a une propri√©t√© appropri√©e, mais franchement, cela semble un peu √©trange: <br><br><pre> <code class="cpp hljs">internal object ConfigSourceStreamVersion { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { } }</code> </pre> <br>  G√©n√©ralement, le code semble suspect.  Peut-√™tre que le param√®tre / la propri√©t√© est laiss√© pour la compatibilit√©, mais c'est juste ma supposition. <br><br>  <b>Num√©ro 17</b> <br><br>  Jetons un coup d'≈ìil aux √©l√©ments int√©ressants de la biblioth√®que <i>System.Runtime.WindowsRuntime.UI.Xaml</i> et du code de package du m√™me nom. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RepeatBehavior</span></span></span><span class="hljs-class"> :</span></span> IFormattable { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InternalToString(null, null); } .... }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3108</u></a> Il n'est pas recommand√© de renvoyer 'null' √† partir de la m√©thode 'ToSting ()'.  RepeatBehavior.cs 113 <br><br>  Histoire famili√®re que nous connaissons d√©j√† - la m√©thode <i>ToString</i> peut renvoyer la valeur <i>nulle</i> .  Pour cette raison, l'auteur du code de l'appelant, qui suppose que <i>RepeatBehavior.ToString</i> renvoie toujours une r√©f√©rence non nulle, peut √™tre d√©sagr√©ablement surpris √† un moment donn√©.  Encore une fois, cela contredit les directives de Microsoft. <br><br>  Eh bien, mais la m√©thode ne pr√©cise pas que <i>ToString</i> peut retourner <i>null</i> - nous devons aller plus loin et jeter un ≈ìil √† la m√©thode <i>InternalToString</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InternalToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> format, IFormatProvider formatProvider)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (_Type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RepeatBehaviorType.Forever: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Forever"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RepeatBehaviorType.Count: StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.AppendFormat( formatProvider, <span class="hljs-string"><span class="hljs-string">"{0:"</span></span> + format + <span class="hljs-string"><span class="hljs-string">"}x"</span></span>, _Count); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sb.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RepeatBehaviorType.Duration: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _Duration.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } }</code> </pre> <br>  L'analyseur a d√©tect√© que si la branche <i>par d√©faut</i> s'ex√©cute dans <i>switch</i> , <i>InternalToString</i> renverra la valeur <i>nulle</i> .  Par cons√©quent, <i>ToString</i> renverra √©galement <i>null</i> . <br><br>  <i>RepeatBehavior</i> est une structure publique et <i>ToString</i> est une m√©thode publique, nous pouvons donc essayer de reproduire le probl√®me dans la pratique.  Pour ce faire, nous allons cr√©er l'instance <i>RepeatBehavior</i> , appeler la m√©thode <i>ToString √†</i> partir de celle-ci et tout en faisant cela, nous ne devons pas manquer que <i>_Type</i> ne doit pas √™tre √©gal √† <i>RepeatBehaviorType.Forever</i> , <i>RepeatBehaviorType.Count</i> ou <i>RepeatBehaviorType.Duration</i> . <br><br>  <i>_Type</i> est un champ priv√©, qui peut √™tre attribu√© via une propri√©t√© publique: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RepeatBehavior</span></span></span><span class="hljs-class"> :</span></span> IFormattable { .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> RepeatBehaviorType _Type; .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RepeatBehaviorType Type { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _Type; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { _Type = value; } } .... }</code> </pre> <br>  Jusqu'√† pr√©sent, tout va bien.  Passons √† autre chose et voyons quel est le type <i>RepeatBehaviorType</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> RepeatBehaviorType { Count, Duration, Forever }</code> </pre> <br>  Comme nous pouvons le voir, <i>RepeatBehaviorType</i> est l'√©num√©ration, contenant les trois √©l√©ments.  Parall√®lement √† cela, ces trois √©l√©ments sont couverts par l'expression de <i>commutateur</i> qui nous int√©resse.  Cependant, cela ne signifie pas que la branche par d√©faut est inaccessible. <br><br>  Pour reproduire le probl√®me, nous ajouterons une r√©f√©rence au package <i>System.Runtime.WindowsRuntime.UI.Xaml</i> au projet (j'utilisais la version 4.3.0) et ex√©cuterons le code suivant. <br><br><pre> <code class="cpp hljs">RepeatBehavior behavior = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RepeatBehavior() { Type = (RepeatBehaviorType)<span class="hljs-number"><span class="hljs-number">666</span></span> }; Console.WriteLine(behavior.ToString() is null);</code> </pre> <br>  <i>True</i> est affich√© dans la console comme pr√©vu, ce qui signifie que <i>ToString a</i> retourn√© <i>null</i> , car <i>_Type</i> n'√©tait √©gal √† aucune des valeurs des branches de <i>cas</i> et la branche <i>par d√©faut</i> a re√ßu le contr√¥le.  C'est ce que nous essayions de faire. <br><br>  Je voudrais √©galement noter que ni les commentaires sur la m√©thode, ni <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>docs.microsoft.com ne</u></a> sp√©cifient que la m√©thode peut renvoyer la valeur <i>nulle</i> . <br><br>  <b>Num√©ro 18</b> <br><br>  Ensuite, nous v√©rifierons plusieurs avertissements de <i>System.Private.DataContractSerialization</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CharType</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte None = <span class="hljs-number"><span class="hljs-number">0x00</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte FirstName = <span class="hljs-number"><span class="hljs-number">0x01</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte Name = <span class="hljs-number"><span class="hljs-number">0x02</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte Whitespace = <span class="hljs-number"><span class="hljs-number">0x04</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte Text = <span class="hljs-number"><span class="hljs-number">0x08</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte AttributeText = <span class="hljs-number"><span class="hljs-number">0x10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte SpecialWhitespace = <span class="hljs-number"><span class="hljs-number">0x20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte Comment = <span class="hljs-number"><span class="hljs-number">0x40</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> byte[] s_charType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[<span class="hljs-number"><span class="hljs-number">256</span></span>] { .... CharType.None, <span class="hljs-comment"><span class="hljs-comment">/* 9 (.) */</span></span> CharType.None| CharType.Comment| CharType.Comment| CharType.Whitespace| CharType.Text| CharType.SpecialWhitespace, <span class="hljs-comment"><span class="hljs-comment">/* A (.) */</span></span> CharType.None| CharType.Comment| CharType.Comment| CharType.Whitespace| CharType.Text| CharType.SpecialWhitespace, <span class="hljs-comment"><span class="hljs-comment">/* B (.) */</span></span> CharType.None, <span class="hljs-comment"><span class="hljs-comment">/* C (.) */</span></span> CharType.None, <span class="hljs-comment"><span class="hljs-comment">/* D (.) */</span></span> CharType.None| CharType.Comment| CharType.Comment| CharType.Whitespace, <span class="hljs-comment"><span class="hljs-comment">/* E (.) */</span></span> CharType.None, .... };</code> </pre> <br>  <b>Avertissements de PVS-Studio:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3001</u></a> Il existe des sous-expressions identiques 'CharType.Comment' √† gauche et √† droite de '|'  op√©rateur.  XmlUTF8TextReader.cs 56 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3001</u></a> Il existe des sous-expressions identiques 'CharType.Comment' √† gauche et √† droite de '|'  op√©rateur.  XmlUTF8TextReader.cs 58 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3001</u></a> Il existe des sous-expressions identiques 'CharType.Comment' √† gauche et √† droite de '|'  op√©rateur.  XmlUTF8TextReader.cs 64 </li></ul><br>  L'analyseur a trouv√© l'utilisation de l'expression <i>CharType.Comment | CharType.Comment</i> suspecte.  Semble un peu √©trange, car <i>(CharType.Comment | CharType.Comment) == CharType.Comment</i> .  Lors de l'initialisation d'autres √©l√©ments de tableau, qui utilisent <i>CharType.Comment</i> , il n'y a pas une telle duplication. <br><br>  <b>Num√©ro 19</b> <br><br>  Continuons.  Examinons les informations sur la <i>valeur</i> de retour de la m√©thode XmlBinaryWriterSession.TryAdd dans la description de la m√©thode et sur docs.microsoft.com - " <u>M√©thode XmlBinaryWriterSession.TryAdd (XmlDictionaryString, Int32)</u> ": <i>renvoie: true si la cha√Æne peut √™tre ajout√©e;</i>  <i>sinon, faux.</i> <br><br>  Examinons maintenant le corps de la m√©thode: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlDictionaryString value, out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>{ IntArray keys; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == null) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> System.Runtime .Serialization .DiagnosticUtility .ExceptionUtility .ThrowHelperArgumentNull(nameof(value)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_maps.TryGetValue(value.Dictionary, out keys)) { key = (keys[value.Key] - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// If the key is already set, then something is wrong throw System.Runtime .Serialization .DiagnosticUtility .ExceptionUtility .ThrowHelperError( new InvalidOperationException( SR.XmlKeyAlreadyExists)); } key = Add(value.Value); keys[value.Key] = (key + 1); return true; } key = Add(value.Value); keys = AddKeys(value.Dictionary, value.Key + 1); keys[value.Key] = (key + 1); return true; }</span></span></code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3009</u></a> Il est √©trange que cette m√©thode renvoie toujours une seule et m√™me valeur de ¬´vrai¬ª.  XmlBinaryWriterSession.cs 29 <br><br>  Il semble √©trange que la m√©thode renvoie <i>true</i> ou l√®ve une exception, mais la valeur <i>false</i> n'est jamais renvoy√©e. <br><br>  <b>Num√©ro 20</b> <br><br>  Je suis tomb√© sur le code avec un probl√®me similaire, mais dans ce cas, au contraire - la m√©thode retourne toujours <i>false</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnHandleReference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xmlWriter.depth &lt; depthToCheckCyclicReference) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (canContainCyclicReference) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_byValObjectsInScope.Contains(obj)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; _byValObjectsInScope.Push(obj); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3009</u></a> Il est √©trange que cette m√©thode renvoie toujours une seule et m√™me valeur de "false".  XmlObjectSerializerWriteContext.cs 415 <br><br>  Eh bien, nous avons d√©j√† parcouru un long chemin!  Alors avant de continuer, je vous sugg√®re de faire une petite pause: remuez vos muscles, promenez-vous, reposez vos yeux, regardez par la fen√™tre ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/008/d6a/92d/008d6a92d6f4cf4066e744e4c857b47d.png" alt="Image 24"></div><br>  J'esp√®re qu'√† ce stade, vous √™tes √† nouveau plein d'√©nergie, alors continuons.  :) <br><br>  <b>Num√©ro 21</b> <br><br>  Passons en revue quelques fragments int√©ressants du projet <i>System.Security.Cryptography.Algorithms</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> override byte[] GenerateMask(byte[] rgbSeed, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cbReturn) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (HashAlgorithm hasher = (HashAlgorithm)CryptoConfig.CreateFromName(_hashNameValue)) { byte[] rgbCounter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[<span class="hljs-number"><span class="hljs-number">4</span></span>]; byte[] rgbT = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[cbReturn]; uint counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ib = <span class="hljs-number"><span class="hljs-number">0</span></span>; ib &lt; rgbT.Length;) { <span class="hljs-comment"><span class="hljs-comment">// Increment counter -- up to 2^32 * sizeof(Hash) Helpers.ConvertIntToByteArray(counter++, rgbCounter); hasher.TransformBlock(rgbSeed, 0, rgbSeed.Length, rgbSeed, 0); hasher.TransformFinalBlock(rgbCounter, 0, 4); byte[] hash = hasher.Hash; hasher.Initialize(); Buffer.BlockCopy(hash, 0, rgbT, ib, Math.Min(rgbT.Length - ib, hash.Length)); ib += hasher.Hash.Length; } return rgbT; } }</span></span></code> </pre> <br>  <b>Avertissement PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3080 D√©r√©f√©rence</u></a> nulle possible.  Envisagez d'inspecter ¬´hasher¬ª.  PKCS1MaskGenerationMethod.cs 37 <br><br>  L'analyseur avertit que la valeur de la variable de <i>hachage</i> peut √™tre <i>nulle</i> lors de l'√©valuation du <i>hachage.</i> Expression de <i>TransformBlock</i> r√©sultant en une exception du type <i>NullReferenceException</i> .  L'occurrence de cet avertissement est devenue possible gr√¢ce √† l'analyse interproc√©durale. <br><br>  Donc, pour savoir si <i>hasher</i> peut prendre la valeur <i>nulle</i> dans ce cas, nous devons plonger dans la m√©thode <i>CreateFromName</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateFromName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CreateFromName(name, null); }</code> </pre> <br>  Rien pour l'instant - allons plus loin.  Le corps de la version <i>CreateFromName</i> surcharg√©e avec deux param√®tres est assez grand, donc je cite la version courte. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateFromName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, params object[] args)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retvalType == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cons == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidates.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rci == null || typeof(Delegate).IsAssignableFrom(rci.DeclaringType)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retval; }</code> </pre> <br> As you can see, there are several exit points in the method where the <i>null</i> value is explicitly returned. Therefore, at least theoretically, in the method above, that triggered a warning, an exception of the <i>NullReferenceException</i> type might occur. <br><br> Theory is great, but let's try to reproduce the problem in practice. To do this, we'll take another look at the original method and note the key points. Also, we'll reduce the irrelevant code from the method. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PKCS1MaskGenerationMethod</span></span></span><span class="hljs-class"> :</span></span> .... <span class="hljs-comment"><span class="hljs-comment">// &lt;= 1 { .... public PKCS1MaskGenerationMethod() // &lt;= 2 { _hashNameValue = DefaultHash; } .... public override byte[] GenerateMask(byte[] rgbSeed, int cbReturn) // &lt;= 3 { using (HashAlgorithm hasher = (HashAlgorithm)CryptoConfig.CreateFromName(_hashNameValue)) // &lt;= 4 { byte[] rgbCounter = new byte[4]; byte[] rgbT = new byte[cbReturn]; // &lt;= 5 uint counter = 0; for (int ib = 0; ib &lt; rgbT.Length;) // &lt;= 6 { .... Helpers.ConvertIntToByteArray(counter++, rgbCounter); // &lt;= 7 hasher.TransformBlock(rgbSeed, 0, rgbSeed.Length, rgbSeed, 0); .... } .... } } }</span></span></code> </pre> <br> Let's take a closer look at the key points: <br><br> <b>1, 3</b> . The class and method have <i>public</i> access modifiers. Hence, this interface is available when adding reference to a library ‚Äî we can try reproducing this issue. <br><br> <b>2</b> . The class is non-abstract instance, has a public constructor. It must be easy to create an instance, which we'll work with. In some cases, that I considered, classes were abstract, so to reproduce the issue I had to search for inheritors and ways to obtain them. <br><br> <b>4</b> . <i>CreateFromName</i> mustn't generate any exceptions and must return <i>null</i> ‚Äî the most important point, we'll get back to it later. <br><br> <b>5, 6</b> . The <i>cbReturn</i> value has to be &gt; 0 (but, of course, within adequate limits for the successful creation of an array). Compliance of the <i>cbReturn &gt; 0</i> condition is needed to meet the further condition <i>ib &lt; rgbT.Length</i> and enter the loop body. <br><br> <b>7</b> . <i>Helpres.ConvertIntToByteArray</i> must work without exceptions. <br><br> To meet the conditions that depend on the method parameters, it is enough to simply pass appropriate arguments, for example: <br><br><ul><li> <i>rgbCeed</i> ‚Äî new byte[] { 0, 1, 2, 3 }; </li><li> <i>cbReturn</i> ‚Äî 42. </li></ul><br> In order to ¬´discredit¬ª the <i>CryptoConfig.CreateFromName</i> method, we need to be able to change the value of the <i>_hashNameValue</i> field. Fortunately, we have it, as the class defines a wrapper property for this field: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> HashName { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _hashNameValue; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { _hashNameValue = value ?? DefaultHash; } }</code> </pre> <br> By setting a 'synthetic' value for <i>HashName</i> (that is <i>_hashNameValue),</i> we can get the <i>null</i> value from the <i>CreateFromName</i> method at the first exit point from the ones we marked. I won't go into the details of analyzing this method (hope you'll forgive me for this), as the method is quite large. <br><br> As a result, the code which will lead to an exception of the <i>NullReferenceException</i> type, might look as follows: <br><br><pre> <code class="cpp hljs">PKCS1MaskGenerationMethod tempObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PKCS1MaskGenerationMethod(); tempObj.HashName = <span class="hljs-string"><span class="hljs-string">"Dummy"</span></span>; tempObj.GenerateMask(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[] { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }, <span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre> <br> Now we add reference to the debugging library, run the code and get the expected result: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ab/384/8e5/2ab3848e542172cd92a7e03f55bba9fe.png" alt="Image 10"></div><br> Just for the fun of it, I tried to execute the same code using the NuGet package of the 4.3.1 version. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b4/a94/766/7b4a947666444496ca077e7530415c76.png" alt="Image 14"></div><br> There's no information on generated exceptions, limitations of output parameters in the method description. Docs.microsoft.com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>PKCS1MaskGenerationMethod.GenerateMask(Byte[], Int32) Method</u></a> " doesn't specify it either. <br><br> By the way, right when writing the article and describing the order of actions to reproduce the problem, I found 2 more ways to ¬´break¬ª this method: <br><br><ul><li> pass a too large value as a <i>cbReturn</i> argument; </li><li> pass the <i>null</i> value as <i>rgbSeed.</i> </li></ul><br> In the first case, we'll get an exception of the <i>OutOfMemoryException</i> type. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c50/474/7f9/c504747f9a771843da10a128866811dd.png" alt="Image 15"></div><br> In the second case, we'll get an exception of the <i>NullReferenceException</i> type when executing the <i>rgbSeed.Length</i> expression. In this case, it's important, that <i>hasher</i> has a non-null value. Otherwise, the control flow won't get to <i>rgbSeed.Length</i> . <br><br> <b>Issue 22</b> <br><br> I came across a couple of similar places. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignatureDescription</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> FormatterAlgorithm { get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> DeformatterAlgorithm { get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SignatureDescription</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> AsymmetricSignatureDeformatter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDeformatter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AsymmetricAlgorithm key)</span></span></span><span class="hljs-function"> </span></span>{ AsymmetricSignatureDeformatter item = (AsymmetricSignatureDeformatter) CryptoConfig.CreateFromName(DeformatterAlgorithm); item.SetKey(key); <span class="hljs-comment"><span class="hljs-comment">// &lt;= return item; } public virtual AsymmetricSignatureFormatter CreateFormatter( AsymmetricAlgorithm key) { AsymmetricSignatureFormatter item = (AsymmetricSignatureFormatter) CryptoConfig.CreateFromName(FormatterAlgorithm); item.SetKey(key); // &lt;= return item; } .... }</span></span></code> </pre> <br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3080</u></a> Possible null dereference. Consider inspecting 'item'. SignatureDescription.cs 31 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3080</u></a> Possible null dereference. Consider inspecting 'item'. SignatureDescription.cs 38 </li></ul><br> Again, in <i>FormatterAlgorithm</i> and <i>DeformatterAlgorithm</i> properties we can write such values, for which the <i>CryptoConfig.CreateFromName</i> method return the <i>null</i> value in the <i>CreateDeformatter</i> and <i>CreateFormatter</i> methods. Further, when calling the <i>SetKey</i> instance method, a <i>NullReferenceException</i> exception will be generated. The problem, again, is easily reproduced in practice: <br><br><pre> <code class="cpp hljs">SignatureDescription signature = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SignatureDescription() { DeformatterAlgorithm = <span class="hljs-string"><span class="hljs-string">"Dummy"</span></span>, FormatterAlgorithm = <span class="hljs-string"><span class="hljs-string">"Dummy"</span></span> }; signature.CreateDeformatter(null); <span class="hljs-comment"><span class="hljs-comment">// NRE signature.CreateFormatter(null); // NRE</span></span></code> </pre> <br> In this case, when calling <i>CreateDeformatter</i> as well as calling <i>CreateFormatter</i> , an exception of the <i>NullReferenceException</i> type is thrown. <br><br> <b>Issue 23</b> <br><br> Let's review interesting fragments from the <i>System.Private.Xml</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteBase64</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte[] buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_inAttr &amp;&amp; (_inCDataSection || StartCDataSection())) _wrapped.WriteBase64(buffer, index, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> _wrapped.WriteBase64(buffer, index, count); }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3004</u></a> The 'then' statement is equivalent to the 'else' statement. QueryOutputWriterV1.cs 242 <br><br> It looks strange that <i>then</i> and <i>else</i> branches of the <i>if</i> statement contain the same code. Either there's an error here and another action has to be made in one of the branches, or the <i>if</i> statement can be omitted. <br><br> <b>Issue 24</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Depends</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlSchemaObject item, ArrayList refs)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content is XmlSchemaSimpleTypeRestriction) { baseType = ((XmlSchemaSimpleTypeRestriction)content).BaseType; baseName = ((XmlSchemaSimpleTypeRestriction)content).BaseTypeName; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content is XmlSchemaSimpleTypeList) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content is XmlSchemaSimpleTypeRestriction) { baseName = ((XmlSchemaSimpleTypeRestriction)content).BaseTypeName; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == typeof(XmlSchemaSimpleTypeUnion)) { .... } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3003</u></a> The use of 'if (A) {...} else if (A) {...}' pattern was detected. There is a probability of logical error presence. Check lines: 381, 396. ImportContext.cs 381 <br><br> In the <i>if-else-if</i> sequence there are two equal conditional expressions ‚Äî <i>content is XmlSchemaSimpleTypeRestriction</i> . What is more, bodies of <i>then</i> branches of respective statements contain a different set of expressions. Anyway, either the body of the first relevant <i>then</i> branch will be executed (if the conditional expression is true), or none of them in case if the relevant expression is false. <br><br> <b>Issue 25</b> <br><br> To make it more intriguing to search for the error in the next method, I'll cite is entire body. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MatchesXmlType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IList&lt;XPathItem&gt; seq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> indexType)</span></span></span><span class="hljs-function"> </span></span>{ XmlQueryType typBase = GetXmlType(indexType); XmlQueryCardinality card; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (seq.Count) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: card = XmlQueryCardinality.Zero; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: card = XmlQueryCardinality.One; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: card = XmlQueryCardinality.More; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(card &lt;= typBase.Cardinality)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; typBase = typBase.Prime; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; seq.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateXmlType(seq[<span class="hljs-number"><span class="hljs-number">0</span></span>]).IsSubtypeOf(typBase)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br> If you've coped ‚Äî congratulations! <br> If not ‚Äî PVS-Studio to the rescue: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3102</u></a> Suspicious access to element of 'seq' object by a constant index inside a loop. XmlQueryRuntime.cs 738 <br><br> The <i>for</i> loop is executed, the expression <i>i &lt; seq.Count</i> is used as an exit condition. It suggests the idea that developers want to bypass the <i>seq</i> sequence. But in the loop, authors access sequence elements not by using the counter ‚Äî <i>seq[i]</i> , but a number literal ‚Äî zero ( <i>seq[0]</i> ). <br><br> <b>Issue 26</b> <br><br> The next error fits in a small piece of code, but it's no less interesting. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ WriteValue(value); }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3110</u></a> Possible infinite recursion inside 'WriteValue' method. XmlAttributeCache.cs 166 <br><br> The method calls itself, forming recursion without an exit condition. <br><br> <b>Issue 27</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IList&lt;XPathNavigator&gt; DocOrderDistinct(IList&lt;XPathNavigator&gt; seq) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (seq.Count &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq; XmlQueryNodeSequence nodeSeq = (XmlQueryNodeSequence)seq; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nodeSeq == null) nodeSeq = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlQueryNodeSequence(seq); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nodeSeq.DocOrderDistinct(_docOrderCmp); }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3095</u></a> The 'seq' object was used before it was verified against null. Check lines: 880, 884. XmlQueryRuntime.cs 880 <br><br> The method can get the <i>null</i> value as an argument. Due to this, when accessing the <i>Count</i> property, an exception of the <i>NullReferenceException</i> type will be generated. Below the variable <i>nodeSeq</i> is checked. <i>nodeSeq</i> is obtained as a result of explicit <i>seq</i> casting, still it's not clear why the check takes place. If the <i>seq</i> value is <i>null</i> , the control flow won't get to this check because of the exception. If the <i>seq</i> value isn't <i>null</i> , then: <br><br><ul><li> if casting fails, an exception of the <i>InvalidCastException</i> type will be generated; </li><li> if casting is successful, <i>nodeSeq</i> definitely isn't <i>null</i> . </li></ul><br> <b>Issue 28</b> <br><br> I came across 4 constructors, containing unused parameters. Perhaps, they are left for compatibility, but I found no additional comments on these unused parameters. <br><br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3117</u></a> Constructor parameter 'securityUrl' is not used. XmlSecureResolver.cs 15 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3117</u></a> Constructor parameter 'strdata' is not used. XmlEntity.cs 18 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3117</u></a> Constructor parameter 'location' is not used. Compilation.cs 58 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3117</u></a> Constructor parameter 'access' is not used. XmlSerializationILGen.cs 38 </li></ul><br> The first one interested me the most (at least, it got into the list of warnings for the article). What's so special? Not sure. Perhaps, its name. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">XmlSecureResolver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlResolver resolver, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> securityUrl)</span></span></span><span class="hljs-function"> </span></span>{ _resolver = resolver; }</code> </pre> <br> Just for the sake of interest, I checked out what's written at docs.microsoft.com ‚Äî " <u>XmlSecureResolver Constructors</u> " about the <i>securityUrl</i> parameter: <br><br> <i>The URL used to create the PermissionSet that will be applied to the underlying XmlResolver. The XmlSecureResolver calls PermitOnly() on the created PermissionSet before calling GetEntity(Uri, String, Type) on the underlying XmlResolver.</i> <br><br> <b>Issue 29</b> <br><br> In the <i>System.Private.Uri</i> package I found the method, which wasn't following exactly Microsoft guidelines on the <i>ToString</i> method overriding. Here we need to recall one of the tips from the page " <u>Object.ToString Method</u> ": <b><i>Your ToString() override should not throw an exception</i></b> <i>.</i> <br><br> The overridden method itself looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_username.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; _password.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UriFormatException(SR.net_uri_BadUserPassword); } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3108</u></a> It is not recommended to throw exceptions from 'ToSting()' method. UriBuilder.cs 406 <br><br> The code first sets an empty string for the <i>_username</i> field and a nonempty one for the <i>_password</i> field respectively through the public properties <i>UserName</i> and <i>Password.</i> After that it calls the <i>ToString</i> method. Eventually this code will get an exception. An example of such code: <br><br><pre> <code class="cpp hljs">UriBuilder uriBuilder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UriBuilder() { UserName = String.Empty, Password = <span class="hljs-string"><span class="hljs-string">"Dummy"</span></span> }; String stringRepresentation = uriBuilder.ToString(); Console.WriteLine(stringRepresentation);</code> </pre> <br> But in this case developers honestly warn that calling might result in an exception. It is described in comments to the method and at docs.microsoft.com ‚Äî " <u>UriBuilder.ToString Method</u> ". <br><br> <b>Issue 30</b> <br><br> Look at the warnings, issued on the <i>System.Data.Common</i> project code. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ArrayList _tables; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> DataTable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tableName, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ns)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_tables.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (DataTable)_tables[<span class="hljs-number"><span class="hljs-number">0</span></span>]; .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3106</u></a> Possibly index is out of bound. The '0' index is pointing beyond '_tables' bound. XMLDiffLoader.cs 277 <br><br> Does this piece of code look unusual? What do you think it is? An unusual way to generate an exception of the <i>ArgumentOutOfRangeException</i> type? I wouldn't be surprised by this approach. Overall, it's very strange and suspicious code. <br><br> <b>Issue 31</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal XmlNodeOrder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComparePosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XPathNodePointer other)</span></span></span><span class="hljs-function"> </span></span>{ RealFoliate(); other.RealFoliate(); Debug.Assert(other != null); .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3095</u></a> The 'other' object was used before it was verified against null. Check lines: 1095, 1096. XPathNodePointer.cs 1095 <br><br> The expression <i>other != null</i> as an argument of the <i>Debug.Assert</i> method suggests, that the <i>ComparePosition</i> method can obtain the <i>null</i> value as an argument. At least, the intention was to catch such cases. But at the same time, the line above the <i>other.RealFoliate</i> instance method is called. As a result, if <i>other</i> has the <i>null</i> value, an exception of the <i>NullReferenceException</i> type will be generated before checking through <i>Assert</i> . <br><br> <b>Issue 32</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> PropertyDescriptorCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetProperties</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Attribute[] attributes)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (Attribute attribute in attributes) { Attribute attr = property.Attributes[attribute.GetType()]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (attr == null &amp;&amp; !attribute.IsDefaultAttribute()) || !attr.Match(attribute)) { match = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3080</u></a> Possible null dereference. Consider inspecting 'attr'. DbConnectionStringBuilder.cs 534 <br><br> Conditional expression of the <i>if</i> statement looks quite suspicious. <i>Match</i> is an instance method. According to the check <i>attr == null</i> , <i>null</i> is the acceptable (expected) value for this variable. Therefore, if control flow gets to the right operand of the || operator (if <i>attr</i> ‚Äî <i>null</i> ), we'll get an exception of the <i>NullReferenceException</i> type. <br><br> Accordingly, conditions of the exception occurrence are the following: <br><br><ol><li> The value of <i>attr</i> ‚Äî <i>null</i> . The right operand of the &amp;&amp; operator is evaluated. </li><li> The value of <i>!attribute.IsDefaultAttribute()</i> ‚Äî <i>false</i> . The overall result of the expression with the &amp;&amp; operator ‚Äî <i>false</i> . </li><li> Since the left operand of the || operator is of the <i>false</i> value, the right operand is evaluated. </li><li> Since <i>attr</i> ‚Äî <i>null</i> , when calling the <i>Match</i> method, an exception is generated. </li></ol><br> <b>Issue 33</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadOldRowData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DataSet ds, ref DataTable table, ref </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pos, XmlReader row)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (table == null) { row.Skip(); <span class="hljs-comment"><span class="hljs-comment">// need to skip this element if we dont know about it, // before returning -1 return -1; } .... if (table == null) throw ExceptionBuilder.DiffgramMissingTable( XmlConvert.DecodeName(row.LocalName)); .... }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3021</u></a> There are two 'if' statements with identical conditional expressions. The first 'if' statement contains method return. This means that the second 'if' statement is senseless XMLDiffLoader.cs 301 <br><br> There are two <i>if</i> statements, containing the equal expression ‚Äî <i>table == null</i> . With that, <i>then</i> branches of these statements contain different actions ‚Äî in the first case, the method exits with the value -1, in the second one ‚Äî an exception is generated. The <i>table</i> variable isn't changed between the checks. Thus, the considered exception won't be generated. <br><br> <b>Issue 34</b> <br><br> Look at the interesting method from the <i>System.ComponentModel.TypeConverter</i> project. Well, let's first read the comment, describing it: <br><br> <i>Removes the last character from the formatted string. (Remove last character in virtual string). On exit the out param contains the position where the operation was actually performed. This position is relative to the test string. The MaskedTextResultHint out param gives more information about the operation result. Returns</i> <b><i>true</i></b> <i>on success,</i> <b><i>false</i></b> <i>otherwise.</i> <br><br> The key point on the return value: if an operation is successful, the method returns <i>true</i> , otherwise ‚Äî <i>false</i> . Let's see what happens in fact. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> testPosition, out MaskedTextResultHint resultHint)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lastAssignedPos == INVALID_INDEX) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// nothing to remove. } .... return true; }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3009</u></a> It's odd that this method always returns one and the same value of 'true'. MaskedTextProvider.cs 1529 <br><br> In fact, it turns out that the only return value of the method is <i>true</i> . <br><br> <b>Issue 35</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_table != null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_table.fInitInProgress &amp;&amp; _delayLoadingConstraints != null) { .... } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3125</u></a> The '_table' object was used after it was verified against null. Check lines: 437, 423. ConstraintCollection.cs 437 <br><br> The <i>_table != null</i> check speaks for itself ‚Äî the <i>_table</i> variable can have the <i>null</i> value. At least, in this case code authors get reinsured. However, below they address the instance field via <i>_table</i> but without the check for <i>null</i> ‚Äî <i>_table .fInitInProgress</i> . <br><br> <b>Issue 36</b> <br><br> Now let's consider several warnings, issued for the code of the <i>System.Runtime.Serialization.Formatters</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (memberNameInfo != null) { .... _serWriter.WriteObjectEnd(memberNameInfo, typeNameInfo); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((objectInfo._objectId == _topId) &amp;&amp; (_topName != null)) { _serWriter.WriteObjectEnd(topNameInfo, typeNameInfo); .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ReferenceEquals(objectInfo._objectType, Converter.s_typeofString)) { _serWriter.WriteObjectEnd(typeNameInfo, typeNameInfo); } }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3038</u></a> The argument was passed to method several times. It is possible that other argument should be passed instead. BinaryObjectWriter.cs 262 <br><br> The analyzer was confused by the last call <i>_serWriter.WriteObjectEnd</i> with two equal arguments ‚Äî <i>typeNameInfo</i> . It looks like a typo, but I can't say for sure. I decided to check out what is the callee <i>WriteObjectEnd</i> method. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteObjectEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NameInfo memberNameInfo, NameInfo typeNameInfo)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br> Well‚Ä¶ Let's move on.  :) <br><br> <b>Issue 37</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteSerializationHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> topId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> headerId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minorVersion, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> majorVersion)</span></span></span><span class="hljs-function"> </span></span>{ var record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializationHeaderRecord( BinaryHeaderEnum.SerializedStreamHeader, topId, headerId, minorVersion, majorVersion); record.Write(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br> When reviewing this code, I wouldn't say at once what's wrong here or what looks suspicious. But the analyzer may well say what's the thing. <br><br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3066</u></a> Possible incorrect order of arguments passed to 'SerializationHeaderRecord' constructor: 'minorVersion' and 'majorVersion'. BinaryFormatterWriter.cs 111 <br><br> See the callee constructor of the <i>SerializationHeaderRecord</i> class. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SerializationHeaderRecord</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BinaryHeaderEnum binaryHeaderEnum, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> topId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> headerId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> majorVersion, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minorVersion)</span></span></span><span class="hljs-function"> </span></span>{ _binaryHeaderEnum = binaryHeaderEnum; _topId = topId; _headerId = headerId; _majorVersion = majorVersion; _minorVersion = minorVersion; }</code> </pre> <br> As we can see, constructor's parameters follow in the order <i>majorVersion</i> , <i>minorVersion</i> ; whereas when calling the constructor they are passed in this order: <i>minorVersion</i> , <i>majorVersion</i> . Seems like a typo. In case it was made deliberately (what if?) ‚Äî I think it would require an additional comment. <br><br> <b>Issue 38</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ObjectManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ISurrogateSelector selector, StreamingContext context, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> checkSecurity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isCrossAppDomain)</span></span></span><span class="hljs-function"> </span></span>{ _objects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectHolder[DefaultInitialSize]; _selector = selector; _context = context; _isCrossAppDomain = isCrossAppDomain; }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3117</u></a> Constructor parameter 'checkSecurity' is not used. ObjectManager.cs 33 <br><br> The <i>checkSecurity</i> parameter of the constructor isn't used in any way. There are no comments on it. I guess it's left for compatibility, but anyway, in the context of recent security conversations, it looks interesting. <br><br> <b>Issue 39</b> <br><br> Here's the code that seemed unusual to me. The pattern looks one and the same in all three detected cases and is located in methods with equal names and variables names. Consequently: <br><br><ul><li> either I'm not enlightened enough to get the purpose of such duplication; </li><li> or the error was spread by the copy-paste method. </li></ul><br> The code itself: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnlargeArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newLength = _values.Length * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newLength &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newLength == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializationException(SR.Serialization_TooManyElements); } newLength = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } FixupHolder[] temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FixupHolder[newLength]; Array.Copy(_values, <span class="hljs-number"><span class="hljs-number">0</span></span>, temp, <span class="hljs-number"><span class="hljs-number">0</span></span>, _count); _values = temp; }</code> </pre> <br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3022</u></a> Expression 'newLength == int.MaxValue' is always false. ObjectManager.cs 1423 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3022</u></a> Expression 'newLength == int.MaxValue' is always false. ObjectManager.cs 1511 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3022</u></a> Expression 'newLength == int.MaxValue' is always false. ObjectManager.cs 1558 </li></ul><br> What is different in other methods is the type of the <i>temp</i> array elements (not <i>FixupHolder</i> , but <i>long</i> or <i>object</i> ). So I still have suspicions of copy-paste‚Ä¶ <br><br> <b>Issue 40</b> <br><br> Code from the <i>System.Data.Odbc</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnquoteIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(quotePrefix) || quotePrefix != <span class="hljs-string"><span class="hljs-string">" "</span></span>) { .... } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3022</u></a> Expression '!string.IsNullOrEmpty(quotePrefix) || quotePrefix != " "' is always true. OdbcCommandBuilder.cs 338 <br><br> The analyzer assumes that the given expression always has the <i>true</i> value. It is really so. It even doesn't matter what value is actually in <i>quotePrefix</i> ‚Äî the condition itself is written incorrectly. Let's get to the bottom of this. <br><br> We have the || operator, so the expression value will be <i>true</i> , if the left or right (or both) operand will have the <i>true</i> value. It's all clear with the left one. The right one will be evaluated only in case if the left one has the <i>false</i> value. This means, if the expression is composed in the way that the value of the right operand is always <i>true</i> when the value of the left one is <i>false</i> , the result of the entire expression will permanently be <i>true</i> . <br><br> From the code above we know that if the right operand is evaluated, the value of the expression <i>string.IsNullOrEmpty(quotePrefix)</i> ‚Äî <i>true</i> , so one of these statements is true: <br><br><ul><li> <i>quotePrefix == null</i> ; </li><li> <i>quotePrefix.Length == 0</i> . </li></ul><br> If one of these statements is true, the expression <i>quotePrefix != " "</i> will also be true, which we wanted to prove. Meaning that the value of the entire expression is always <i>true</i> , regardless of the <i>quotePrefix</i> contents. <br><br> <b>Issue 41</b> <br><br> Going back to constructors with unused parameters: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PendingGetConnection</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PendingGetConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dueTime, DbConnection owner, TaskCompletionSource&lt;DbConnectionInternal&gt; completion, DbConnectionOptions userOptions)</span></span></span><span class="hljs-function"> </span></span>{ DueTime = dueTime; Owner = owner; Completion = completion; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> DueTime { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DbConnection Owner { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TaskCompletionSource&lt;DbConnectionInternal&gt; Completion { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DbConnectionOptions UserOptions { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3117</u></a> Constructor parameter 'userOptions' is not used. DbConnectionPool.cs 26 <br><br> We can see from the analyzer warnings and the code, that only one constructor's parameter isn't used <i>‚Äî userOptions</i> , and others are used for initializing same-name properties. It looks like a developer forgot to initialize one of the properties. <br><br> <b>Issue 42</b> <br><br> There's suspicious code, that we've come across 2 times. The pattern is the same. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> DataTable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (DataRow row in schemaTable.Rows) { resultTable.Columns .Add(row[<span class="hljs-string"><span class="hljs-string">"ColumnName"</span></span>] as <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, (Type)row[<span class="hljs-string"><span class="hljs-string">"DataType"</span></span>] as Type); } .... }</code> </pre> <br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3051</u></a> An excessive type cast. The object is already of the 'Type' type. DbMetaDataFactory.cs 176 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3051</u></a> An excessive type cast. The object is already of the 'Type' type. OdbcMetaDataFactory.cs 1109 </li></ul><br> The expression <i>(Type)row[¬´DataType¬ª] as Type</i> looks suspicious. First, explicit casting will be performed, after that ‚Äî casting via the <i>as</i> operator. If the value <i>row[¬´DataType¬ª]</i> ‚Äî <i>null,</i> it will successfully 'pass' through both castings and will do as an argument to the <i>Add</i> method. If <i>row[¬´DataType¬ª]</i> returns the value, which cannot be casted to the <i>Type</i> type, an exception of the <i>InvalidCastException</i> type will be generated right during the explicit cast. In the end, why do we need two castings here? The question is open. <br><br> <b>Issue 43</b> <br><br> Let's look at the suspicious fragment from <i>System.Runtime.InteropServices.RuntimeInformation</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> FrameworkDescription { get { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s_frameworkDescription == null) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> versionString = (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)AppContext.GetData(<span class="hljs-string"><span class="hljs-string">"FX_PRODUCT_VERSION"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (versionString == null) { .... versionString = typeof(object).Assembly .GetCustomAttribute&lt; AssemblyInformationalVersionAttribute&gt;() ?.InformationalVersion; .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> plusIndex = versionString.IndexOf(<span class="hljs-string"><span class="hljs-string">'+'</span></span>); .... } .... } .... } }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3105</u></a> The 'versionString' variable was used after it was assigned through null-conditional operator. NullReferenceException is possible. RuntimeInformation.cs 29 <br><br> The analyzer warns about a possible exception of the <i>NullReferenceException</i> type when calling the <i>IndexOf</i> method for the <i>versionString</i> variable. When receiving the value for a variable, code authors use the '?.' operator to avoid a <i>NullReferenceException</i> exception when accessing the <i>InfromationalVersion</i> property. The trick is that if the call of <i>GetCustomAttribute&lt;...&gt;</i> returns <i>null</i> , an exception will still be generated, but below ‚Äî when calling the <i>IndexOf</i> method, as <i>versionString</i> will have the <i>null</i> value. <br><br> <b>Issue 44</b> <br><br> Let's address the <i>System.ComponentModel.Composition</i> project and look through several warnings. Two warnings were issued for the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanSpecialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... object[] genericParameterConstraints = ....; GenericParameterAttributes[] genericParameterAttributes = ....; <span class="hljs-comment"><span class="hljs-comment">// if no constraints and attributes been specifed, anything can be created if ((genericParameterConstraints == null) &amp;&amp; (genericParameterAttributes == null)) { return true; } if ((genericParameterConstraints != null) &amp;&amp; (genericParameterConstraints.Length != partArity)) { return false; } if ((genericParameterAttributes != null) &amp;&amp; (genericParameterAttributes.Length != partArity)) { return false; } for (int i = 0; i &lt; partArity; i++) { if (!GenericServices.CanSpecialize( specialization[i], (genericParameterConstraints[i] as Type[]). CreateTypeSpecializations(specialization), genericParameterAttributes[i])) { return false; } } return true; }</span></span></code> </pre> <br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3125</u></a> The 'genericParameterConstraints' object was used after it was verified against null. Check lines: 603, 589. GenericSpecializationPartCreationInfo.cs 603 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3125</u></a> The 'genericParameterAttributes' object was used after it was verified against null. Check lines: 604, 594. GenericSpecializationPartCreationInfo.cs 604 </li></ul><br> In code there are checks <i>genericParameterAttributes != null</i> and <i>genericParameterConstraints != null</i> . Therefore, <i>null</i> ‚Äî acceptable values for these variables, we'll take it into account. If both variables have the <i>null</i> value, we'll exit the method, no questions. What if one of two variables mentioned above is <i>null</i> , but in doing so we don't exit the method? If such case is possible and execution gets to traversing the loop, we'll get an exception of the <i>NullReferenceException</i> type. <br><br> <b>Issue 45</b> <br><br> Next we'll move to another interesting warning from this project. And though, let's do something different ‚Äî first we'll use the class again, and then look at the code. Next, we'll add reference to the same-name NuGet package of the last available prerelease version in the project (I installed the package of the version 4.6.0-preview6.19303.8). Let's write simple code, for example, such as: <br><br><pre> <code class="cpp hljs">LazyMemberInfo lazyMemberInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LazyMemberInfo(); var eq = lazyMemberInfo.Equals(null); Console.WriteLine(eq);</code> </pre> <br> The <i>Equals</i> method isn't commented, I didn't find this method description for .NET Core at docs.microsoft.com, only for .NET Framework. If we look at it (" <u>LazyMemberInfo.Equals(Object) Method</u> ") ‚Äî we won't see anything special whether it returns <i>true</i> or <i>false</i> , there is no information on generated exceptions. We'll execute the code and see: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e5/8f7/aa4/8e58f7aa4e5a274751cde57da4d9497f.png" alt="Image 16"></div><br> We can get a little twisted and write the following code and also get interesting output: <br><br><pre> <code class="cpp hljs">LazyMemberInfo lazyMemberInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LazyMemberInfo(); var eq = lazyMemberInfo.Equals(typeof(String)); Console.WriteLine(eq);</code> </pre> <br> The result of the code execution. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e74/199/292/e74199292d39b2df8a7b205218c9c1fe.png" alt="Image 17"></div><br><br> Interestingly, these both exceptions are generated in the same expression. Let's look insidethe <i>Equals</i> method. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object obj)</span></span></span><span class="hljs-function"> </span></span>{ LazyMemberInfo that = (LazyMemberInfo)obj; <span class="hljs-comment"><span class="hljs-comment">// Difefrent member types mean different members if (_memberType != that._memberType) { return false; } // if any of the lazy memebers create accessors in a delay-loaded fashion, // we simply compare the creators if ((_accessorsCreator != null) || (that._accessorsCreator != null)) { return object.Equals(_accessorsCreator, that._accessorsCreator); } // we are dealing with explicitly passed accessors in both cases if(_accessors == null || that._accessors == null) { throw new Exception(SR.Diagnostic_InternalExceptionMessage); } return _accessors.SequenceEqual(that._accessors); }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3115</u></a> Passing 'null' to 'Equals' method should not result in 'NullReferenceException'. LazyMemberInfo.cs 116 <br><br> Actually in this case the analyzer screwed up a bit, as it issued a warning for the <i>that._memberType</i> expression. However, exceptions occur earlier when executing the expression <i>(LazyMemberInfo)obj</i> . We've already made a note of it. <br><br> I think it's all clear with <i>InvalidCastException.</i> Why is <i>NullReferenceException</i> generated? The fact is that <i>LazyMemberInfo</i> is a struct, therefore, it gets unboxed. The <i>null</i> value unboxing, in turns, leads to occurrence of an exception of the <i>NullReferenceException</i> type. Also there is a couple of typos in comments ‚Äî authors should probably fix them. An explicit exception throwing is still on the authors hands. <br><br> <b>Issue 46</b> <br><br> By the way, I came across a similar case in <i>System.Drawing.Common</i> in the <i>TriState</i> structure. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>{ TriState state = (TriState)o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _value == state._value; }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3115</u></a> Passing 'null' to 'Equals' method should not result in 'NullReferenceException'. TriState.cs 53 <br><br> The problems are the same as in the case described above. <br><br> <b>Issue 47</b> <br><br> Let's consider several fragments from <i>System.Text.Json</i> . <br><br> Remember I wrote that <i>ToString</i> mustn't return <i>null</i> ? Time to solidify this knowledge. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (TokenType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.None: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.Null: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Empty; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.True: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>.TrueString; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.False: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>.FalseString; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.Number: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.StartArray: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.StartObject: { <span class="hljs-comment"><span class="hljs-comment">// null parent should have hit the None case Debug.Assert(_parent != null); return _parent.GetRawValueAsString(_idx); } case JsonTokenType.String: return GetString(); case JsonTokenType.Comment: case JsonTokenType.EndArray: case JsonTokenType.EndObject: default: Debug.Fail($"No handler for {nameof(JsonTokenType)}.{TokenType}"); return string.Empty; } }</span></span></code> </pre> <br> At first sight, this method doesn't return <i>null</i> , but the analyzer argues the converse. <br><br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3108</u></a> It is not recommended to return 'null' from 'ToSting()' method. JsonElement.cs 1460 <br><br> The analyzer points to the line with calling the <i>GetString()</i> method. Let's have a look at it. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CheckValidInstance(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _parent.GetString(_idx, JsonTokenType.String); }</code> </pre> <br> Let's go deeper in the overloaded version of the <i>GetString</i> method: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, JsonTokenType expectedType)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tokenType == JsonTokenType.Null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... }</code> </pre> <br> Right after we see the condition, whose execution will result in the <i>null</i> value ‚Äî both from this method and <i>ToString</i> which we initially considered. <br><br> <b>Issue 48</b> <br><br> Another interesting fragment: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal JsonPropertyInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreatePolymorphicProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ JsonPropertyInfo runtimeProperty = CreateProperty(property.DeclaredPropertyType, runtimePropertyType, property.ImplementedPropertyType, property?.PropertyInfo, Type, options); property.CopyRuntimeSettingsTo(runtimeProperty); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> runtimeProperty; }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3042</u></a> Possible NullReferenceException. The '?.' and '.' operators are used for accessing members of the 'property' object JsonClassInfo.AddProperty.cs 179 <br><br> When calling the <i>CreateProperty</i> method, properties are referred several times through the variable <i>property</i> : <i>property.DeclaredPropertyType</i> , <i>property.ImplementedPropertyType</i> , <i>property?.PropertyInfo</i> . As you can see, in one case code authors use the '?.'  op√©rateur. If it's not out of place here and <i>property</i> can have the <i>null</i> value, this operator won't be of any help, as an exception of the <i>NullReferenceException</i> type will be generated with direct access. <br><br> <b>Issue 49</b> <br><br> The following suspicious fragments were found in the <i>System.Security.Cryptography.Xml</i> project. They are paired up, the same as it has been several times with other warnings. Again, the code looks like copy-paste, compare these yourself. <br><br> The first fragment: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)</span></span></span><span class="hljs-function"> </span></span>{ docPos = DocPosition.BeforeRootElement; foreach (XmlNode childNode in ChildNodes) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (childNode.NodeType == XmlNodeType.Element) { CanonicalizationDispatcher.Write( childNode, strBuilder, DocPosition.InRootElement, anc); docPos = DocPosition.AfterRootElement; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CanonicalizationDispatcher.Write(childNode, strBuilder, docPos, anc); } } }</code> </pre> <br> The second fragment. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteHash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)</span></span></span><span class="hljs-function"> </span></span>{ docPos = DocPosition.BeforeRootElement; foreach (XmlNode childNode in ChildNodes) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (childNode.NodeType == XmlNodeType.Element) { CanonicalizationDispatcher.WriteHash( childNode, hash, DocPosition.InRootElement, anc); docPos = DocPosition.AfterRootElement; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CanonicalizationDispatcher.WriteHash(childNode, hash, docPos, anc); } } }</code> </pre> <br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3061</u></a> Parameter 'docPos' is always rewritten in method body before being used. CanonicalXmlDocument.cs 37 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3061</u></a> Parameter 'docPos' is always rewritten in method body before being used. CanonicalXmlDocument.cs 54 </li></ul><br> In both methods the <i>docPos</i> parameter is overwritten before its value is used. Therefore, the value, used as a method argument, is simply ignored. <br><br> <b>Issue 50</b> <br><br> Let's consider several warnings on the code of the <i>System.Data.SqlClient</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsBOMNeeded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MetaType type, object value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type.NullableType == TdsEnums.SQLXMLTYPE) { Type currentType = value.GetType(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == typeof(SqlString)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!((SqlString)value).IsNull &amp;&amp; ((((SqlString)value).Value).Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((((SqlString)value).Value[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) != <span class="hljs-number"><span class="hljs-number">0xff</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((currentType == typeof(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)) &amp;&amp; (((String)value).Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((value != null) &amp;&amp; (((<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) != <span class="hljs-number"><span class="hljs-number">0xff</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == typeof(SqlXml)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!((SqlXml)value).IsNull) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == typeof(XmlDataFeed)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Values will eventually converted to unicode string here } } return false; }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3095</u></a> The 'value' object was used before it was verified against null. Check lines: 8696, 8708. TdsParser.cs 8696 <br><br> The analyzer was confused by the check <i>value != null</i> in one of the conditions. It seems like it was lost there during refactoring, as <i>value</i> gets dereferenced many times. If <i>value</i> can have the <i>null</i> value ‚Äî things are bad. <br><br> <b>Issue 51</b> <br><br> The next error is from tests, but it seemed interesting to me, so I decided to cite it. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> TDSMessageCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateQueryResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( lowerBatchText.Contains(<span class="hljs-string"><span class="hljs-string">"name"</span></span>) &amp;&amp; lowerBatchText.Contains(<span class="hljs-string"><span class="hljs-string">"state"</span></span>) &amp;&amp; lowerBatchText.Contains(<span class="hljs-string"><span class="hljs-string">"databases"</span></span>) &amp;&amp; lowerBatchText.Contains(<span class="hljs-string"><span class="hljs-string">"db_name"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// SELECT [name], [state] FROM [sys].[databases] WHERE [name] = db_name() { // Delegate to current database response responseMessage = _PrepareDatabaseResponse(session); } .... }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3053</u></a> An excessive expression. Examine the substrings 'name' and 'db_name'. QueryEngine.cs 151 <br><br> The fact is that in this case the combination of subexpressions <i>lowerBatchText.Contains(¬´name¬ª)</i> and <i>lowerBatchText.Contains(¬´db_name¬ª)</i> is redundant. Indeed, if the checked string contains the substring <i>¬´db_name¬ª</i> , it will contain the <i>¬´name¬ª</i> substring as well. If the string doesn't contain <i>¬´name¬ª</i> , it won't contain <i>¬´db_name¬ª</i> either. As a result, it turns out that the check <i>lowerBatchText.Contains(¬´name¬ª)</i> is redundant. Unless it can reduce the number of evaluated expressions, if the checked string doesn't contain <i>¬´name¬ª</i> . <br><br> <b>Issue 52</b> <br><br> A suspicious fragment from the code of the <i>System.Net.Requests</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override PipelineInstruction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PipelineCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PipelineEntry entry, ResponseDescription response, ....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NetEventSource.IsEnabled) NetEventSource.Info(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, $<span class="hljs-string"><span class="hljs-string">"Command:{entry?.Command} Description:{response?.StatusDescription}"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// null response is not expected if (response == null) return PipelineInstruction.Abort; .... if (entry.Command == "OPTS utf8 on\r\n") .... .... }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3125</u></a> The 'entry' object was used after it was verified against null. Check lines: 270, 227. FtpControlStream.cs 270 <br><br> When composing an interpolated string, such expressions as <i>entry?.Command</i> and <i>response?.Description</i> are used. The '?.' operator is used instead of the '.' operator not to get an exception of the <i>NullReferenceException</i> type in case if any of the corresponding parameters has the <i>null</i> value. In this case, this technique works. Further, as we can see from the code, a possible <i>null</i> value for <i>response</i> gets split off (exit from the method if <i>response == null</i> ), whereas there's nothing similar for <i>entry.</i> As a result, if <i>entry</i> ‚Äî <i>null</i> further along the code when evaluating <i>entry.Command</i> (with the usage of '.', not '?.'), an exception will be generated. <br><br> At this point, a fairly detailed code review is waiting for us, so I suggest that you have another break ‚Äî chill out, make some tea or coffee. After that I'll be right here to continue. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/3fc/f07/56a3fcf075284f021a56249627e518bb.png" alt="Image 21"></div><br> Are you back? Then let's keep going.  :) <br><br> <b>Issue 53</b> <br><br> Now let's find something interesting in the <i>System.Collections.Immutable</i> project. This time we'll have some experiments with the <i>System.Collections.Immutable.ImmutableArray&lt;T&gt;</i> struct. The methods <i>IStructuralEquatable.Equals</i> and <i>IStructuralComparable.CompareTo</i> are of special interest for us. <br><br> Let's start with the <i>IStructuralEquatable.Equals</i> method. The code is given below, I suggest that you try to get what's wrong yourself: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IStructuralEquatable.Equals(object other, IEqualityComparer comparer) { var self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; Array otherArray = other as Array; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherArray == null) { var theirs = other as IImmutableArray; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (theirs != null) { otherArray = theirs.Array; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null &amp;&amp; otherArray == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } } IStructuralEquatable ours = self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ours.Equals(otherArray, comparer); }</code> </pre> <br> Did you manage? If yes ‚Äî my congrats.  :) <br><br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3125</u></a> The 'ours' object was used after it was verified against null. Check lines: 1212, 1204. ImmutableArray_1.cs 1212 <br><br> The analyzer was confused by the call of the instance <i>Equals</i> method through the <i>ours</i> variable, located in the last <i>return</i> expression, as it suggests that an exception of the <i>NullReferenceException</i> type might occur here. Why does the analyzer suggest so? To make it easier to explain, I'm giving a simplified code fragment of the same method below. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IStructuralEquatable.Equals(object other, IEqualityComparer comparer) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null &amp;&amp; otherArray == null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null) { .... } } } IStructuralEquatable ours = self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ours.Equals(otherArray, comparer); }</code> </pre> <br> In the last expressions, we can see, that the value of the <i>ours</i> variable comes from <i>self.array</i> . The check <i>self.array == null</i> is performed several times above. Which means, <i>ours,</i> the same as <i>self.array,</i> can have the <i>null</i> value. At least in theory. Is this state reachable in practice? Let's try to find out. To do this, once again I cite the body of the method with set key points. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IStructuralEquatable.Equals(object other, IEqualityComparer comparer) { var self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= 1 Array otherArray = other as Array; if (otherArray == null) // &lt;= 2 { var theirs = other as IImmutableArray; if (theirs != null) // &lt;= 3 { otherArray = theirs.Array; if (self.array == null &amp;&amp; otherArray == null) { return true; } else if (self.array == null) // &lt;= 4 { return false; } } IStructuralEquatable ours = self.array; // &lt;= 5 return ours.Equals(otherArray, comparer); }</span></span></code> </pre> <br> <b>Key point 1.</b> <i>self.array == this.array</i> (due to <i>self = this</i> ). Therefore, before calling the method, we need to get the condition <i>this.array == null</i> . <br><br> <b>Key point 2</b> . We can ignore this <i>if</i> , which will be the simplest way to get what we want. To ignore this <i>if</i> , we only need the <i>other</i> variable to be of the <i>Array</i> type or a derived one, and not to contain the <i>null</i> value. This way, after using the <i>as</i> operator, a non-null reference will be written in <i>otherArray</i> and we'll ignore the first <i>if</i> statement <i>.</i> <br><br> <b>Key point 3</b> . This point requires a more complex approach. We definitely need to exit on the second <i>if</i> statement (the one with the conditional expression <i>theirs != null</i> ). If it doesn't happen and <i>then</i> branch starts to execute, most certainly we won't get the needed point 5 under the condition <i>self.array == null</i> due to the key point 4. To avoid entering the <i>if</i> statement of the key point 3, one of these conditions has to be met: <br><br><ul><li> the <i>other</i> value has to be <i>null</i> ; </li><li> the actual <i>other</i> type mustn't implement the <i>IImmutableArray</i> interface. </li></ul><br> <b>Key point 5</b> . If we get to this point with the value <i>self.array == null</i> , it means that we've reached our aim, and an exception of the <i>NullReferenceException</i> type will be generated. <br><br> We get the following datasets that will lead us to the needed point. <br><br> First: <i>this.array ‚Äî null</i> . <br><br> Second ‚Äî one of the following ones: <br><br><ul><li> <i>other</i> ‚Äî <i>null</i> ; </li><li> <i>other</i> has the <i>Array</i> type or one derived from it; </li><li> <i>other</i> doesn't have the <i>Array</i> type or a derived from it and in doing so, doesn't implement the <i>IImmutableArray</i> interface. </li></ul><br> <i>array</i> is the field, declared in the following way: <br><br><pre> <code class="cpp hljs">internal T[] <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>;</code> </pre> <br> As <i>ImmutableArray&lt;T&gt;</i> is a structure, it has a default constructor (without arguments) that will result in the <i>array</i> field taking value by default, which is <i>null.</i> And that's what we need. <br><br> Let's not forget that we were investigating an explicit implementation of the interface method, therefore, casting has to be done before the call. <br><br> Now we have the game in hands to reach the exception occurrence in three ways. We add reference to the debugging library version, write the code, execute and see what happens. <br><br> <b>Code fragment 1.</b> <br><br><pre> <code class="cpp hljs">var comparer = EqualityComparer&lt;String&gt;.Default; ImmutableArray&lt;String&gt; immutableArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableArray&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); ((IStructuralEquatable)immutableArray).Equals(null, comparer);</code> </pre> <br> <b>Code fragment 2.</b> <br><br><pre> <code class="cpp hljs">var comparer = EqualityComparer&lt;String&gt;.Default; ImmutableArray&lt;String&gt; immutableArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableArray&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); ((IStructuralEquatable)immutableArray).Equals(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] { }, comparer);</code> </pre> <br> <b>Code fragment 3.</b> <br><br><pre> <code class="cpp hljs">var comparer = EqualityComparer&lt;String&gt;.Default; ImmutableArray&lt;String&gt; immutableArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableArray&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); ((IStructuralEquatable)immutableArray).Equals(typeof(Object), comparer);</code> </pre> <br> The execution result of all three code fragments will be the same, only achieved by different input entry data, and execution paths. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13a/a3b/e8a/13aa3be8a0b68a646aee130773f2c862.png" alt="Image 18"></div><br> <b>Issue 54</b> <br><br> If you didn't forget, we have another method that we need to discredit. :) But this time we won't cover it in such detail. Moreover, we already know some information from the previous example. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IStructuralComparable.CompareTo(object other, IComparer comparer) { var self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; Array otherArray = other as Array; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherArray == null) { var theirs = other as IImmutableArray; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (theirs != null) { otherArray = theirs.Array; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null &amp;&amp; otherArray == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null ^ otherArray == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException( SR.ArrayInitializedStateNotEqual, nameof(other)); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherArray != null) { IStructuralComparable ours = self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ours.CompareTo(otherArray, comparer); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } throw new ArgumentException(SR.ArrayLengthsNotEqual, nameof(other)); }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3125</u></a> The 'ours' object was used after it was verified against null. Check lines: 1265, 1251. ImmutableArray_1.cs 1265 <br><br> As you can see, the case is very similar to the previous example. <br><br> Let's write the following code: <br><br><pre> <code class="cpp hljs">Object other = ....; var comparer = Comparer&lt;String&gt;.Default; ImmutableArray&lt;String&gt; immutableArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableArray&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); ((IStructuralComparable)immutableArray).CompareTo(other, comparer);</code> </pre> <br> We'll try to find some entry data to reach the point, where exception of the <i>NullReferenceException</i> type might occur: <br><br> <b>Value:</b> <i>other</i> ‚Äî <i>new String[]{ }</i> ; <br><br> Result: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eef/d77/08a/eefd7708a187f5060f2074e642f18434.png" alt="Image 22"></div><br> Thus, we again managed to figure out such data, with which an exception occurs in the method. <br><br> <b>Issue 55</b> <br><br> In the <i>System.Net.HttpListener</i> project I stumbled upon several both suspicious and very similar places. Once again, I can't shake the feeling about copy-paste, taking place here. Since the pattern is the same, we'll look at one code example. I'll cite analyzer warnings for the rest cases. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override IAsyncResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginRead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte[] buffer, ....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NetEventSource.IsEnabled) { NetEventSource.Enter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); NetEventSource.Info(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"buffer.Length:"</span></span> + buffer.Length + <span class="hljs-string"><span class="hljs-string">" size:"</span></span> + size + <span class="hljs-string"><span class="hljs-string">" offset:"</span></span> + offset); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(nameof(buffer)); } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3095</u></a> The 'buffer' object was used before it was verified against null. Check lines: 51, 53. HttpRequestStream.cs 51 <br><br> Generation of an exception of the <i>ArgumentNullException</i> type under the condition <i>buffer == null</i> obviously suggests that <i>null</i> is an unacceptable value for this variable. However, if the value of the <i>NetEventSource.IsEnabled</i> expression is <i>true</i> and <i>buffer</i> ‚Äî <i>null</i> , when evaluating the <i>buffer.Length</i> expression, an exception of the <i>NullReferenceException</i> type will be generated. As we can see, we won't even reach the <i>buffer == null</i> check in this case. <br><br> PVS-Studio warnings issued for other methods with the pattern: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3095</u></a> The 'buffer' object was used before it was verified against null. Check lines: 49, 51. HttpResponseStream.cs 49 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3095</u></a> The 'buffer' object was used before it was verified against null. Check lines: 74, 75. HttpResponseStream.cs 74 </li></ul><br> <b>Issue 56</b> <br><br> A similar code snippet was in the <i>System.Transactions.Local</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnterState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InternalTransaction tx)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tx._outcomeSource._isoLevel == IsolationLevel.Snapshot) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> TransactionException.CreateInvalidOperationException( TraceSourceType.TraceSourceLtm, SR.CannotPromoteSnapshot, null, tx == null ? Guid.Empty : tx.DistributedTxId); } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3095</u></a> The 'tx' object was used before it was verified against null. Check lines: 3282, 3285. TransactionState.cs 3282 <br><br> Under a certain condition, an author wants to throw an exception of the <i>InvalidOperationException</i> type. When calling the method for creating an exception object, code authors use the <i>tx</i> parameter, check it for <i>null</i> to avoid an exception of the <i>NullReferenceException</i> type when evaluating the <i>tx.DistributedTxId</i> expression. It's ironic that the check won't be of help, as when evaluating the condition of the <i>if</i> statement, instance fields are accessed via the <i>tx</i> variable ‚Äî <i>tx._outcomeSource._isoLevel</i> . <br><br> <b>Issue 57</b> <br><br> Code from the <i>System.Runtime.Caching</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLimit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cacheMemoryLimitMegabytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> cacheMemoryLimit = cacheMemoryLimitMegabytes; cacheMemoryLimit = cacheMemoryLimit &lt;&lt; MEGABYTE_SHIFT; _memoryLimit = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// never override what the user specifies as the limit; // only call AutoPrivateBytesLimit when the user does not specify one. if (cacheMemoryLimit == 0 &amp;&amp; _memoryLimit == 0) { // Zero means we impose a limit _memoryLimit = EffectiveProcessMemoryLimit; } else if (cacheMemoryLimit != 0 &amp;&amp; _memoryLimit != 0) { // Take the min of "cache memory limit" and // the host's "process memory limit". _memoryLimit = Math.Min(_memoryLimit, cacheMemoryLimit); } else if (cacheMemoryLimit != 0) { // _memoryLimit is 0, but "cache memory limit" // is non-zero, so use it as the limit _memoryLimit = cacheMemoryLimit; } .... }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3022</u></a> Expression 'cacheMemoryLimit != 0 &amp;&amp; _memoryLimit != 0' is always false. CacheMemoryMonitor.cs 250 <br><br> If you look closely at the code, you'll notice that one of the expressions ‚Äî <i>cacheMemoryLimit != 0 &amp;&amp; _memoryLimit != 0</i> will always be <i>false</i> . Since <i>_memoryLimit</i> has the 0 value (is set before the <i>if</i> statement), the right operand of the &amp;&amp; operator is <i>false</i> . Therefore, the result of the entire expression is <i>false</i> . <br><br> <b>Issue 58</b> <br><br> I cite a suspicious code fragment from the <i>System.Diagnostics.TraceSource</i> project below. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StackNode n = _stack.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == null) { base.Pop(); } _stack.Value = n.Prev; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n.Value; }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3125</u></a> The 'n' object was used after it was verified against null. Check lines: 115, 111. CorrelationManager.cs 115 <br><br> In fact, it is an interesting case. Due to the check <i>n == null,</i> I assume, that <i>null</i> is an expected value for this local variable. If so, an exception of the <i>NullReferenceException</i> type will be generated when accessing the instance property ‚Äî <i>n.Prev</i> . If in this case <i>n</i> can never be <i>null</i> , <i>base.Pop()</i> will never be called. <br><br> <b>Issue 59</b> <br><br> An interesting code fragment from the <i>System.Drawing.Primitives</i> project. Again, I suggest that you try to find the problem yourself. Here's the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToHtml</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Color c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> colorString = <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Empty; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c.IsEmpty) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> colorString; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ColorUtil.IsSystemColor(c)) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (c.ToKnownColor()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ActiveBorder: colorString = <span class="hljs-string"><span class="hljs-string">"activeborder"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.GradientActiveCaption: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ActiveCaption: colorString = <span class="hljs-string"><span class="hljs-string">"activecaption"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.AppWorkspace: colorString = <span class="hljs-string"><span class="hljs-string">"appworkspace"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Desktop: colorString = <span class="hljs-string"><span class="hljs-string">"background"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Control: colorString = <span class="hljs-string"><span class="hljs-string">"buttonface"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlLight: colorString = <span class="hljs-string"><span class="hljs-string">"buttonface"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlDark: colorString = <span class="hljs-string"><span class="hljs-string">"buttonshadow"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlText: colorString = <span class="hljs-string"><span class="hljs-string">"buttontext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ActiveCaptionText: colorString = <span class="hljs-string"><span class="hljs-string">"captiontext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.GrayText: colorString = <span class="hljs-string"><span class="hljs-string">"graytext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.HotTrack: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Highlight: colorString = <span class="hljs-string"><span class="hljs-string">"highlight"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.MenuHighlight: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.HighlightText: colorString = <span class="hljs-string"><span class="hljs-string">"highlighttext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.InactiveBorder: colorString = <span class="hljs-string"><span class="hljs-string">"inactiveborder"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.GradientInactiveCaption: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.InactiveCaption: colorString = <span class="hljs-string"><span class="hljs-string">"inactivecaption"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.InactiveCaptionText: colorString = <span class="hljs-string"><span class="hljs-string">"inactivecaptiontext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Info: colorString = <span class="hljs-string"><span class="hljs-string">"infobackground"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.InfoText: colorString = <span class="hljs-string"><span class="hljs-string">"infotext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.MenuBar: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Menu: colorString = <span class="hljs-string"><span class="hljs-string">"menu"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.MenuText: colorString = <span class="hljs-string"><span class="hljs-string">"menutext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ScrollBar: colorString = <span class="hljs-string"><span class="hljs-string">"scrollbar"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlDarkDark: colorString = <span class="hljs-string"><span class="hljs-string">"threeddarkshadow"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlLightLight: colorString = <span class="hljs-string"><span class="hljs-string">"buttonhighlight"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Window: colorString = <span class="hljs-string"><span class="hljs-string">"window"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.WindowFrame: colorString = <span class="hljs-string"><span class="hljs-string">"windowframe"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.WindowText: colorString = <span class="hljs-string"><span class="hljs-string">"windowtext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c.IsNamedColor) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == Color.LightGray) { <span class="hljs-comment"><span class="hljs-comment">// special case due to mismatch between Html and enum spelling colorString = "LightGrey"; } else { colorString = c.Name; } } else { colorString = "#" + cRToString("X2", null) + cGToString("X2", null) + cBToString("X2", null); } return colorString; }</span></span></code> </pre> <br> Okay, okay, just kidding‚Ä¶ Or did you still find something? Anyway, let's reduce the code to clearly state the issue. <br><br> Here is the short code version: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (c.ToKnownColor()) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Control: colorString = <span class="hljs-string"><span class="hljs-string">"buttonface"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlLight: colorString = <span class="hljs-string"><span class="hljs-string">"buttonface"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3139</u></a> Two or more case-branches perform the same actions. ColorTranslator.cs 302 <br><br> I can't say for sure, but I think it's an error. In other cases, when a developer wanted to return the same value for several enumerators he used several <i>case(s)</i> , following each other. And it's easy enough to make a mistake with copy-paste here, I think. <br><br> Let's dig a little deeper. To get the <i>¬´buttonface¬ª</i> value from the analyzed <i>ToHtml</i> method, you can pass one of the following values to it (expected): <br><br><ul><li> <i>SystemColors.Control</i> ; </li><li> <i>SystemColors.ControlLight</i> . </li></ul><br> If we check ARGB values for each of these colors, we'll see the following: <br><br><ul><li> <i>SystemColors.Control</i> ‚Äî <i>(255, 240, 240, 240)</i> ; </li><li> <i>SystemColors.ControlLight ‚Äî (255, 227, 227, 227)</i> . </li></ul><br> If we call the inverse conversion method <i>FromHtml</i> on the received value ( <i>¬´buttonface¬ª</i> ), we'll get the color <i>Control (255, 240, 240, 240)</i> . Can we get the <i>ControlLight</i> color from <i>FromHtml</i> ? Yes. This method contains the table of colors, which is the basis for composing colors (in this case). The table's initializer has the following line: <br><br><pre> <code class="cpp hljs">s_htmlSysColorTable[<span class="hljs-string"><span class="hljs-string">"threedhighlight"</span></span>] = ColorUtil.FromKnownColor(KnownColor.ControlLight);</code> </pre> <br> Accordingly, <i>FromHtml</i> returns the <i>ControlLight (255, 227, 227, 227)</i> color for the <i>¬´threedhighlight¬ª</i> value. I think that's exactly what should have been used in <i>case KnownColor.ControlLight</i> . <br><br> <b>Issue 60</b> <br><br> We'll check out a couple of interesting warnings from the <i>System.Text.RegularExpressions</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TextposDescription</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ var sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> remaining; sb.Append(runtextpos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sb.Length &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) sb.Append(<span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span> - sb.Length); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (runtextpos &gt; runtextbeg) sb.Append(RegexCharClass.CharDescription(runtext[runtextpos - <span class="hljs-number"><span class="hljs-number">1</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sb.Append(<span class="hljs-string"><span class="hljs-string">'^'</span></span>); sb.Append(<span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>); remaining = runtextend - runtextpos; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = runtextpos; i &lt; runtextend; i++) { sb.Append(RegexCharClass.CharDescription(runtext[i])); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sb.Length &gt;= <span class="hljs-number"><span class="hljs-number">64</span></span>) { sb.Length = <span class="hljs-number"><span class="hljs-number">61</span></span>; sb.Append(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { sb.Append(<span class="hljs-string"><span class="hljs-string">'$'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sb.ToString(); }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3137</u></a> The 'remaining' variable is assigned but is not used by the end of the function. RegexRunner.cs 612 <br><br> A value is written in the local <i>remaining</i> variable, but it's not longer used in the method. Perhaps, some code, using it, was removed, but the variable itself was forgotten. Or there is a crucial error and this variable has to somehow be used. <br><br> <b>Issue 61</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> first, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> last)</span></span></span><span class="hljs-function"> </span></span>{ _rangelist.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SingleRange(first, last)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_canonical &amp;&amp; _rangelist.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; first &lt;= _rangelist[_rangelist.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Last) { _canonical = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3063</u></a> A part of conditional expression is always true if it is evaluated: _rangelist.Count &gt; 0. RegexCharClass.cs 523 <br><br> The analyzer rightly noted, that a part of the expression <i>_rangelist.Count &gt; 0</i> will always be <i>true</i> , if this code is executed. Even if this list (which <i>_rangelist</i> points at), was empty, after adding the element <i>_rangelist.Add(....)</i> it wouldn't be the same. <br><br> <b>Issue 62</b> <br><br> Let's look at the warnings of the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3128</u></a> diagnostic rule in the projects <i>System.Drawing.Common</i> and <i>System.Transactions.Local</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayEnumerator</span></span></span><span class="hljs-class"> :</span></span> IEnumerator { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> object[] _array; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> object _item; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _index; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _startIndex; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _endIndex; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArrayEnumerator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object[] </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{ _array = <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; _startIndex = startIndex; _endIndex = _index + count; _index = _startIndex; } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3128</u></a> The '_index' field is used before it is initialized in constructor. PrinterSettings.Windows.cs 1679 <br><br> When initializing the <i>_endIndex</i> field, another <i>_index</i> field is used, which has a standard value <i>default(int)</i> , (that is <i>0</i> ) at the moment of its usage. The <i>_index</i> field is initialized below. In case if it's not an error ‚Äî the <i>_index</i> variable should have been omitted in this expression not to be confusing. <br><br> <b>Issue 63</b> <br><br><pre> <code class="cpp hljs">internal <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransactionTable</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _timerInterval; .... <span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TransactionTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Create a timer that is initially disabled by specifing // an Infinite time to the first interval _timer = new Timer(new TimerCallback(ThreadTimer), null, Timeout.Infinite, _timerInterval); .... // Store the timer interval _timerInterval = 1 &lt;&lt; TransactionTable.timerInternalExponent; .... } }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3128</u></a> The '_timerInterval' field is used before it is initialized in constructor. TransactionTable.cs 151 <br><br> The case is similar to the one above. First the value of the <i>_timerInterval</i> field is used (while it's still <i>default(int)</i> ) to initialize <i>_timer.</i> Only after that the <i>_timerInterval</i> field itself will be initialized. <br><br> <b>Issue 64</b> <br><br> Next warnings were issued by the diagnostic rule, which is still in development. There's no documentation or final message, but we've already found a couple of interesting fragments with its help. Again these fragments look like <i>copy-paste</i> , so we'll consider only one code fragment. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessNotifyConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... WeakReference reference = (WeakReference)( LdapConnection.s_handleTable[referralFromConnection]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( reference != null &amp;&amp; reference.IsAlive &amp;&amp; null != ((LdapConnection)reference.Target)._ldapHandle) { .... } .... }</code> </pre> <br> <b>PVS-Studio warning (stub):</b> VXXXX TODO_MESSAGE. LdapSessionOptions.cs 974 <br><br> The trick is that after checking <i>reference.IsAlive</i> , garbage might be collected and the object, which <i>WeakReference</i> points to, will be garbage collected. In this case, <i>Target</i> will return the <i>null</i> value. As a result, when accessing the instance field <i>_ldapHandle</i> , an exception of the <i>NullReferenceException</i> type will occur. Microsoft itself warns about this trap with the check IsAlive. A quote from docs.microsoft.com ‚Äî " <u>WeakReference.IsAlive Property</u> ": <i>Because an object could potentially be reclaimed for garbage collection immediately after the IsAlive property returns true, using this property is not recommended unless you are testing only for a false return value.</i> <br><br><h2> Summary on Analysis </h2><br> Are these all errors and interesting places, found during the analysis? Of course, not! When looking through the analysis results, I was thoroughly checking out the warnings. As their number increased and it became clear there were enough of them for an article, I was scrolling through the results, trying to select only the ones that seemed to me the most interesting. When I got to the last ones (the largest logs), I was only able to look though the warnings until the sight caught on something unusual. So if you dig around, I'm sure you can find much more interesting places. <br><br> For example, I ignored almost all <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3022</u></a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3063</a> warnings. So to speak, if I came across such code: <br><br><pre> <code class="cpp hljs">String str = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str == null) ....</code> </pre> <br> I would omit it, as there were many other interesting places that I wanted to describe. There were warnings on unsafe locking using the <i>lock statement</i> with locking by <i>this</i> and so on ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3090</u></a> ; unsafe event calls ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3083</u></a> <u>;</u> objects, which types implement <i>IDisposable</i> , but for which <i>Dispose</i> / <i>Close</i> isn't called ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>V3072</u></a> and similar diagnostics and much more. <br><br> I also didn't note problems, written in tests. At least, I tried, but could accidentally take some. Except for a couple of places that I found interesting enough to draw attention to them. But the testing code can also contain errors, due to which the tests will work incorrectly. <br><br> Generally, there are still many things to investigate ‚Äî but I didn't have the intention to mark <i>all found issues</i> . <br><br> The quality of the code seemed uneven to me. Some projects were perfectly clean, others contained suspicious places. Perhaps we might expect clean projects, especially when it comes to the most commonly used library classes. <br><br> To sum up, we can say, that the code is of quite high-quality, as its amount was considerable. But, as this article suggests, there were some dark corners. <br><br> By the way, a project of this size is also a good test for the analyzer. I managed to find a number of false / weird warnings that I selected to study and correct. So as a result of the analysis, I managed to find the points, where we have to work on the PVS-Studio itself. <br><br><h2>  Conclusion </h2><br> If you got to this place by reading the whole article ‚Äî let me shake your hand! I hope that I was able to show you interesting errors and demonstrate the benefit of static analysis. If you have learned something new for yourself, that will let you write better code ‚Äî I will be doubly pleased. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ef/dbc/f2d/6efdbcf2d984bef000cf44face04c6a4.png" alt="Image 23"></div><br> Anyway, some help by the static analysis won't hurt, so suggest that you <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>try PVS-Studio</u></a> on your project and see what interesting places can be found with its usage. If you have any questions or you just want to share interesting found fragments ‚Äî don't hesitate to write at <a href="">support@viva64.com</a> .  :) <br><br> Best regards! <br><br><h2> PS For .NET Core libraries developers </h2><br> Thank you so much for what you do! Good job! Hopefully this article will help you make the code a bit better. Remember, that I haven't written all suspicious places and you'd better check the project yourself using the analyzer. This way, you'll be able to investigate all warnings in details. Moreover, it'll be more convenient to work with it, rather than with simple text log / list of errors ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">I wrote about this in more details here</a> ). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr463535/">https://habr.com/ru/post/fr463535/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr463513/index.html">Meilleurs cadres de d√©veloppement Web en 2019</a></li>
<li><a href="../fr463515/index.html">Utilisation de l'API HTMS pour travailler avec une base de donn√©es r√©seau relationnelle</a></li>
<li><a href="../fr463525/index.html">S√©l√©nium, s√©l√©no√Øde, s√©l√©niure, s√©lendro√Øde ... Qu'est-ce que tout cela signifie?</a></li>
<li><a href="../fr463527/index.html">Pop up! Transcrit sur iOS</a></li>
<li><a href="../fr463533/index.html">Ce que chaque d√©veloppeur doit savoir d√®s le d√©part</a></li>
<li><a href="../fr463537/index.html">V√©rification du code source des biblioth√®ques .NET Core par l'analyseur statique PVS-Studio</a></li>
<li><a href="../fr463541/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 17. R√©sum√© et feuille de route du cours CCNA</a></li>
<li><a href="../fr463551/index.html">Comment interagir avec les employ√©s et organiser le flux de travail dans les grandes entreprises informatiques</a></li>
<li><a href="../fr463553/index.html">"Allez-vous sur Google?" ou 5 choses que nous avons faites lors de l'embauche (mais plus)</a></li>
<li><a href="../fr463559/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 18. Bases du routage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>