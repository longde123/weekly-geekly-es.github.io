<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♥️ 🚕 🙋🏿 Mencoba ulang permintaan HTTP yang gagal di Angular 👩🏻‍🎨 👎🏼 👨🏿‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Organisasi akses ke data server adalah dasar dari hampir semua aplikasi satu halaman. Semua konten dinamis dalam aplikasi tersebut diunduh dari backen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mencoba ulang permintaan HTTP yang gagal di Angular</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/459302/">  Organisasi akses ke data server adalah dasar dari hampir semua aplikasi satu halaman.  Semua konten dinamis dalam aplikasi tersebut diunduh dari backend. <br><br>  Dalam kebanyakan kasus, permintaan HTTP ke server berfungsi dengan andal dan mengembalikan hasil yang diinginkan.  Namun, dalam beberapa situasi, permintaan mungkin gagal. <br><br>  Bayangkan bagaimana seseorang bekerja dengan situs web Anda melalui titik akses di kereta api yang bepergian di seluruh negeri dengan kecepatan 200 kilometer per jam.  Koneksi jaringan dalam skenario ini bisa lambat, tetapi server meminta, meskipun demikian, melakukan pekerjaan mereka. <br><br>  Tetapi bagaimana jika kereta itu masuk ke dalam terowongan?  Ada kemungkinan besar bahwa koneksi ke Internet akan terputus dan aplikasi web tidak akan dapat "menjangkau" ke server.  Dalam hal ini, pengguna harus memuat ulang halaman aplikasi setelah kereta meninggalkan terowongan dan koneksi Internet dipulihkan. <br><br>  Muat ulang halaman dapat memengaruhi kondisi aplikasi saat ini.  Ini berarti bahwa pengguna dapat, misalnya, kehilangan data yang ia masukkan ke dalam formulir. <br><br>  Daripada hanya berdamai dengan fakta bahwa permintaan tertentu tidak berhasil, akan lebih baik untuk mengulanginya beberapa kali dan menunjukkan kepada pengguna pemberitahuan yang sesuai.  Dengan pendekatan ini, ketika pengguna menyadari bahwa aplikasi sedang mencoba untuk mengatasi masalah, ia kemungkinan besar tidak akan memuat ulang halaman. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/tq/jn/st/tqjnsttqoifuf4p9-rnt_g1dfwg.jpeg"></a> <br><br>  Bahan, terjemahan yang kami terbitkan hari ini, dikhususkan untuk analisis beberapa cara mengulangi permintaan yang gagal dalam aplikasi Angular. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Ulangi permintaan yang gagal</font> </h2><br>  Mari kita mereproduksi situasi yang mungkin ditemui pengguna yang bekerja di Internet dari kereta.  Kami akan membuat backend yang memproses permintaan secara tidak benar selama tiga upaya pertama untuk mengaksesnya, mengembalikan data hanya dari upaya keempat. <br>  Biasanya, menggunakan Angular, kami membuat layanan, menghubungkan <code>HttpClient</code> dan menggunakannya untuk mendapatkan data dari backend. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Injectable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {HttpClient} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {EMPTY, Observable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {catchError} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreetingService</span></span></span><span class="hljs-class"> </span></span>{  private GREET_ENDPOINT = <span class="hljs-string"><span class="hljs-string">'http://localhost:3000'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private httpClient: HttpClient) {  }  greet(): Observable&lt;string&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.get&lt;string&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">`</span></span></span><span class="hljs-subst"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">${</span></span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">.GREET_ENDPOINT}</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">/greet`</span></span></span></span></span><span class="hljs-function">).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">      catchError((</span></span></span><span class="hljs-function">) =&gt;</span></span> {        <span class="hljs-comment"><span class="hljs-comment">//           return EMPTY;      })    );  } }</span></span></code> </pre> <br>  Tidak ada yang istimewa di sini.  Kami menyambungkan modul <code>HttpClient</code> Angular dan menjalankan permintaan GET sederhana.  Jika permintaan mengembalikan kesalahan, kami menjalankan beberapa kode untuk memprosesnya dan mengembalikan yang <code>Observable</code> diamati (objek yang dapat diobservasi) untuk menginformasikan tentang apa yang memulai permintaan.  Kode ini, seolah-olah, mengatakan: "Ada kesalahan, tetapi semuanya beres, saya bisa mengatasinya." <br><br>  Sebagian besar aplikasi melakukan permintaan HTTP dengan cara ini.  Dalam kode di atas, permintaan dieksekusi hanya sekali.  Setelah itu, ia mengembalikan data yang diterima dari server, atau tidak berhasil. <br><br>  Bagaimana cara mengulang permintaan jika titik akhir <code>/greet</code> tidak tersedia atau mengembalikan kesalahan?  Mungkin ada pernyataan RxJS yang cocok?  Tentu saja ada.  RxJS memiliki operator untuk semuanya. <br><br>  Hal pertama yang mungkin terpikirkan dalam situasi ini adalah <code>retry</code> .  Mari kita lihat definisinya: “Mengembalikan Observable yang memainkan Observable original kecuali untuk <code>error</code> .  Jika <code>error</code> Observable original dapat diobservasi, maka metode ini, alih-alih menyebarkan kesalahan, akan berlangganan kembali ke Observable original. <br><br>  Jumlah maksimum berlangganan ulang terbatas untuk <code>count</code> (ini adalah parameter numerik yang diteruskan ke metode). " <br><br>  <code>retry</code> sangat mirip dengan yang kita butuhkan.  Jadi mari kita tanamkan dalam rantai kita. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Injectable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {HttpClient} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {EMPTY, Observable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {catchError, retry, shareReplay} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreetingService</span></span></span><span class="hljs-class"> </span></span>{  private GREET_ENDPOINT = <span class="hljs-string"><span class="hljs-string">'http://localhost:3000'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private httpClient: HttpClient) {  }  greet(): Observable&lt;string&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.get&lt;string&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">`</span></span></span><span class="hljs-subst"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">${</span></span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">.GREET_ENDPOINT}</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">/greet`</span></span></span></span></span><span class="hljs-function">).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">      retry(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span></span><span class="hljs-function">),      </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">catchError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> {        <span class="hljs-comment"><span class="hljs-comment">//           return EMPTY;      }),      shareReplay()    );  } }</span></span></code> </pre> <br>  Kami telah berhasil menggunakan operator <code>retry</code> .  Mari kita lihat bagaimana ini mempengaruhi perilaku permintaan HTTP yang dieksekusi di aplikasi eksperimental.  <a href="">Berikut adalah</a> file GIF besar yang menunjukkan layar aplikasi ini dan tab Jaringan alat pengembang browser.  Anda akan menemukan beberapa demonstrasi lagi di sini. <br><br>  Aplikasi kami sangat sederhana.  Itu hanya membuat permintaan HTTP ketika tombol <code>PING THE SERVER</code> diklik. <br><br>  Seperti yang telah disebutkan, backend mengembalikan kesalahan saat melakukan tiga upaya pertama untuk mengeksekusi permintaan, dan ketika permintaan keempat datang, itu mengembalikan respons normal. <br><br>  Pada tab Alat pengembang jaringan, Anda dapat melihat bahwa <code>retry</code> memecahkan tugas yang ditugaskan untuk itu dan mengulangi pelaksanaan permintaan gagal tiga kali.  Upaya terakhir berhasil, aplikasi menerima respons, pesan yang sesuai muncul di halaman. <br><br>  Semua ini sangat bagus.  Sekarang aplikasi dapat mengulangi permintaan yang gagal. <br><br>  Namun, contoh ini masih bisa diperbaiki.  Harap perhatikan bahwa sekarang permintaan yang berulang akan dieksekusi segera setelah eksekusi permintaan yang tidak berhasil.  Perilaku sistem ini tidak akan membawa banyak manfaat dalam situasi kita - ketika kereta memasuki terowongan dan koneksi internet terputus untuk sementara waktu. <br><br><h2>  <font color="#3AC1EF">Coba lagi permintaan yang gagal</font> </h2><br>  Kereta yang masuk ke terowongan tidak langsung meninggalkannya.  Dia menghabiskan beberapa waktu di sana.  Oleh karena itu, kita perlu "meregangkan" periode di mana kita melakukan permintaan berulang ke server.  Anda dapat melakukan ini dengan menunda coba lagi. <br><br>  Untuk melakukan ini, kita perlu lebih mengontrol proses mengeksekusi permintaan berulang.  Kita harus dapat membuat keputusan tentang kapan tepatnya mengulangi permintaan.  Ini berarti bahwa kemampuan operator <code>retry</code> lagi tidak lagi cukup bagi kami.  Karena itu, kami kembali membuka dokumentasi tentang RxJS. <br><br>  Dokumentasi berisi deskripsi <code>retryWhen</code> , yang tampaknya cocok untuk kita.  Dalam dokumentasi, dijelaskan sebagai berikut: “Mengembalikan Observable yang memainkan Observable asli dengan pengecualian <code>error</code> .  Jika <code>error</code> dapat diobservasi asli, maka metode ini akan melempar Throwable, yang menyebabkan kesalahan, Observable kembali dari <code>notifier</code> .  Jika panggilan yang diamati ini <code>complete</code> atau <code>error</code> , maka metode ini akan memanggil <code>complete</code> atau <code>error</code> pada langganan anak.  Jika tidak, metode ini akan berlangganan kembali ke Observable original. " <br><br>  Ya, definisi itu tidak sederhana.  Mari kita gambarkan hal yang sama dalam bahasa yang lebih mudah diakses. <br><br>  <code>retryWhen</code> menerima panggilan balik yang mengembalikan Observable.  Observable yang dikembalikan memutuskan bagaimana <code>retryWhen</code> operator akan berperilaku berdasarkan beberapa aturan.  Yaitu, ini adalah bagaimana <code>retryWhen</code> operator <code>retryWhen</code> : <br><br><ul><li>  Itu berhenti bekerja dan melempar kesalahan jika yang diamati kembali melemparkan kesalahan. </li><li>  Itu keluar jika laporan yang diamati diamati selesai. </li><li>  Dalam kasus lain, ketika Observable kembali dengan sukses, ia mengulangi eksekusi Observable yang asli </li></ul><br>  Panggilan balik hanya dipanggil saat Observable yang asli melontarkan kesalahan untuk pertama kalinya. <br><br>  Sekarang kita bisa menggunakan pengetahuan ini untuk membuat mekanisme coba lagi yang ditunda untuk permintaan gagal menggunakan coba lagi <code>retryWhen</code> . <br><br><pre> <code class="plaintext hljs">retryWhen((errors: Observable&lt;any&gt;) =&gt; errors.pipe(    delay(delayMs),    mergeMap(error =&gt; retries-- &gt; 0 ? of(error) : throwError(getErrorMessage(maxEntry))    )) )</code> </pre> <br>  Jika Observable asli, yang merupakan permintaan HTTP kami, mengembalikan kesalahan, maka <code>retryWhen</code> pernyataan <code>retryWhen</code> .  Dalam panggilan balik, kami memiliki akses ke kesalahan yang menyebabkan kegagalan.  Kami menangguhkan <code>errors</code> , mengurangi jumlah percobaan ulang, dan mengembalikan Observable baru yang melempar kesalahan. <br><br>  Berdasarkan aturan <code>retryWhen</code> , diamati ini, karena <code>retryWhen</code> , <code>retryWhen</code> permintaan.  Jika pengulangan tidak berhasil beberapa kali dan nilai variabel <code>retries</code> menurun menjadi 0, maka kami mengakhiri tugas dengan kesalahan yang terjadi saat menjalankan permintaan. <br><br>  Hebat!  Tampaknya, kita dapat mengambil kode di atas dan mengganti operator <code>retry</code> di rantai kami dengannya.  Tapi di sini kita sedikit melambat. <br><br>  Bagaimana cara <code>retries</code> variabel?  Variabel ini berisi kondisi saat ini dari sistem coba lagi permintaan yang gagal.  Di mana dia diumumkan?  Kapan kondisinya diatur ulang?  Negara perlu dikelola di dalam aliran, bukan di luarnya. <br><br><h3>  <font color="#3AC1EF">▍Membuat pernyataanRedri Anda sendiri yang tertunda</font> </h3><br>  Kita dapat memecahkan masalah manajemen negara dan meningkatkan keterbacaan kode dengan menulis kode di atas sebagai operator RxJS terpisah. <br><br>  Ada berbagai cara untuk membuat operator RxJS Anda sendiri.  Metode mana yang digunakan tergantung pada bagaimana operator terstruktur. <br><br>  Operator kami didasarkan pada operator RxJS yang ada.  Akibatnya, kita dapat menggunakan cara paling sederhana untuk membuat operator kita sendiri.  Dalam kasus kami, operator RxJ hanya fungsi dengan tanda tangan berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> customOperator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;A&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> Observable&lt;B&gt;</code> </pre> <br>  Pernyataan ini mengambil Observable asli dan mengembalikan Observable lainnya. <br><br>  Karena operator kami memungkinkan pengguna untuk menentukan seberapa sering permintaan berulang harus dieksekusi, dan berapa kali mereka perlu dieksekusi, kita perlu membungkus deklarasi fungsi di atas dalam fungsi pabrik, yang membutuhkan <code>delayMs</code> (keterlambatan antara <code>maxRetry</code> ) dan <code>maxRetry</code> ( jumlah pengulangan maksimum). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> customOperator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delayMs: number, maxRetry: number</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;A&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> Observable&lt;B&gt; }</code> </pre> <br>  Jika Anda ingin membuat operator yang tidak didasarkan pada operator yang ada, Anda perlu memperhatikan penanganan kesalahan dan langganan.  Selain itu, Anda perlu memperluas kelas yang Dapat <code>Observable</code> dan mengimplementasikan fungsi <code>lift</code> . <br><br>  Jika Anda tertarik, silakan lihat di <a href="">sini</a> . <br><br>  Jadi, berdasarkan cuplikan kode di atas, mari kita tulis operator RxJ kita sendiri. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Observable, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>, throwError} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {delay, mergeMap, retryWhen} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getErrorMessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">maxRetry: number</span></span></span><span class="hljs-function">) =&gt;</span></span>  <span class="hljs-string"><span class="hljs-string">`Tried to load Resource over XHR for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${maxRetry}</span></span></span><span class="hljs-string"> times without success. Giving up`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_MAX_RETRIES = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delayedRetry</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delayMs: number, maxRetry = DEFAULT_MAX_RETRIES</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retries = maxRetry;  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span>    src.pipe(      retryWhen(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">errors: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> errors.pipe(        delay(delayMs),        mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> retries-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(error) : throwError(getErrorMessage(maxRetry))        ))      )    ); }</code> </pre> <br>  Bagus  Sekarang kita dapat mengimpor operator ini ke dalam kode klien.  Kami akan menggunakannya saat menjalankan permintaan HTTP. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.get&lt;string&gt;(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.GREET_ENDPOINT}</span></span></span><span class="hljs-string">/greet`</span></span>).pipe(        delayedRetry(<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>),        catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {            <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error);            <span class="hljs-comment"><span class="hljs-comment">//               return EMPTY;        }),        shareReplay()    );</span></span></code> </pre> <br>  Kami menempatkan operator <code>delayedRetry</code> di rantai dan meneruskan angka 1000 dan 3. sebagai parameter. Parameter pertama menetapkan penundaan dalam milidetik di antara upaya membuat permintaan berulang.  Parameter kedua menentukan jumlah maksimum permintaan berulang. <br><br>  Mulai ulang aplikasi dan <a href="">lihat</a> bagaimana operator baru bekerja. <br><br>  Setelah menganalisis perilaku program menggunakan alat pengembang peramban, kita dapat melihat bahwa pelaksanaan upaya berulang untuk mengeksekusi permintaan ditunda selama sedetik.  Setelah menerima jawaban yang benar untuk permintaan tersebut, pesan yang sesuai akan muncul di jendela aplikasi. <br><br><h2>  <font color="#3AC1EF">Permintaan eksponensial tertunda</font> </h2><br>  Mari kita kembangkan gagasan penundaan coba lagi permintaan yang gagal.  Sebelumnya, kami selalu menunda eksekusi setiap permintaan yang berulang pada saat yang bersamaan. <br><br>  Di sini kita berbicara tentang cara meningkatkan penundaan setelah setiap upaya.  Upaya pertama untuk mencoba kembali permintaan dilakukan setelah satu detik, yang kedua setelah dua detik, yang ketiga setelah tiga. <br><br>  Buat pernyataan baru, <code>retryWithBackoff</code> , yang mengimplementasikan perilaku ini. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Observable, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>, throwError} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {delay, mergeMap, retryWhen} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getErrorMessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">maxRetry: number</span></span></span><span class="hljs-function">) =&gt;</span></span>  <span class="hljs-string"><span class="hljs-string">`Tried to load Resource over XHR for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${maxRetry}</span></span></span><span class="hljs-string"> times without success. Giving up.`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_MAX_RETRIES = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_BACKOFF = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retryWithBackoff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delayMs: number, maxRetry = DEFAULT_MAX_RETRIES, backoffMs = DEFAULT_BACKOFF</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retries = maxRetry;  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span>    src.pipe(      retryWhen(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">errors: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> errors.pipe(        mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retries-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {              <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> backoffTime = delayMs + (maxRetry - retries) * backoffMs;              <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(error).pipe(delay(backoffTime));            }            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> throwError(getErrorMessage(maxRetry));          }        )))); }</code> </pre> <br>  Jika Anda menggunakan operator ini dalam aplikasi dan mengujinya, Anda dapat <a href="">melihat</a> bagaimana penundaan dalam menjalankan permintaan yang diulang meningkat setelah setiap upaya baru. <br><br>  Setelah setiap upaya, kami menunggu waktu tertentu, ulangi permintaan dan menambah waktu tunggu.  Di sini, seperti biasa, setelah server mengembalikan jawaban yang benar ke permintaan, kami menampilkan pesan di jendela aplikasi. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Mengulangi permintaan HTTP yang gagal membuat aplikasi lebih stabil.  Ini sangat penting ketika melakukan permintaan yang sangat penting, tanpa data yang diperoleh, aplikasi tidak dapat bekerja secara normal.  Misalnya, itu bisa berupa data konfigurasi yang berisi alamat server yang dengannya aplikasi perlu berinteraksi. <br><br>  Dalam sebagian besar skenario, <code>retry</code> coba lagi RxJ tidak cukup untuk menyediakan sistem coba lagi yang dapat diandalkan untuk permintaan gagal.  <code>retryWhen</code> memberi pengembang tingkat kontrol yang lebih tinggi atas permintaan berulang.  Ini memungkinkan Anda untuk mengkonfigurasi interval untuk permintaan yang berulang.  Karena kemampuan operator ini, dimungkinkan untuk menerapkan skema pengulangan tertunda atau pengulangan tertunda secara eksponensial. <br><br>  Ketika menerapkan pola perilaku yang cocok untuk digunakan kembali dalam rantai RxJS, disarankan agar mereka diformat sebagai operator baru.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://github.com/kreuzerk/">Berikut adalah</a> repositori tempat kode digunakan dalam artikel ini. <br><br>  <b>Pembaca yang budiman!</b>  Bagaimana Anda memecahkan masalah mencoba kembali permintaan HTTP yang gagal? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459302/">https://habr.com/ru/post/id459302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459292/index.html">Otomasi Uji Aplikasi Seluler: Perbandingan Alat</a></li>
<li><a href="../id459294/index.html">Apa yang lebih penting: untuk mengetahui bahasa pemrograman atau untuk dapat memecahkan masalah bisnis?</a></li>
<li><a href="../id459296/index.html">Harga JavaScript 2019</a></li>
<li><a href="../id459298/index.html">Sudut: status pada 2019</a></li>
<li><a href="../id459300/index.html">Quasar 1.0: alat berguna baru untuk pengembang Vue dan tidak hanya untuk mereka</a></li>
<li><a href="../id459304/index.html">Bypass Pitfall Angular dan Penghematan Waktu</a></li>
<li><a href="../id459306/index.html">Perenderan server di lingkungan tanpa server</a></li>
<li><a href="../id459308/index.html">SEO tidak berfungsi di 2019?</a></li>
<li><a href="../id459310/index.html">Alat uji otomatisasi atau penguji steroid seluler</a></li>
<li><a href="../id459312/index.html">Dear Agile, aku muak berpura-pura</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>