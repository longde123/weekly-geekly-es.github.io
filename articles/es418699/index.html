<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüíº üë©üèæ üßôüèª Creaci√≥n de una m√°quina arcade emulador. Parte 3 üßëüèø üîÇ üïö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partes uno y dos . 

 Emulador de procesador 8080 
 C√°scara del emulador 
 Ahora debe tener todos los conocimientos necesarios para comenzar a crear u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Creaci√≥n de una m√°quina arcade emulador. Parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418699/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ec/e50/f3a/4ece50f3a555bfb39878326ec26addd5.jpg" alt="imagen"></div><br>  Partes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uno</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dos</a> . <br><br><h1>  Emulador de procesador 8080 </h1><br><h1>  C√°scara del emulador </h1><br>  Ahora debe tener todos los conocimientos necesarios para comenzar a crear un emulador de procesador 8080. <br><br>  <em>Intentar√© que mi c√≥digo sea lo m√°s claro posible, cada c√≥digo de operaci√≥n se implementa por separado.</em>  <em>Cuando se sienta c√≥modo con √©l, es posible que desee volver a escribirlo para optimizar el rendimiento o reutilizar el c√≥digo.</em> <br><br>  Para empezar, crear√© una estructura de memoria que contendr√° campos para todo lo que me pareci√≥ necesario al escribir un desensamblador.  Tambi√©n habr√° un lugar para un b√∫fer de memoria, que ser√° RAM. <br><a name="habracut"></a><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConditionCodes</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> z:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> s:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> p:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> cy:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ac:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pad:<span class="hljs-number"><span class="hljs-number">3</span></span>; } ConditionCodes; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State8080</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> c; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> d; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> e; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> h; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> l; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> sp; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *memory; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConditionCodes</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cc</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> int_enable; } State8080;</code> </pre> <br>  Ahora cree un procedimiento con una llamada de error que finalizar√° el programa con un error.  Se ver√° m√°s o menos as√≠: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnimplementedInstruction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// pc    ,     printf ("Error: Unimplemented instruction\n"); exit(1); } int Emulate8080Op(State8080* state) { unsigned char *opcode = &amp;state-&gt;memory[state-&gt;pc]; switch(*opcode) { case 0x00: UnimplementedInstruction(state); break; case 0x01: UnimplementedInstruction(state); break; case 0x02: UnimplementedInstruction(state); break; case 0x03: UnimplementedInstruction(state); break; case 0x04: UnimplementedInstruction(state); break; /*....*/ case 0xfe: UnimplementedInstruction(state); break; case 0xff: UnimplementedInstruction(state); break; } state-&gt;pc+=1; //  }</span></span></code> </pre> <br>  Implementemos algunos c√≥digos de operaci√≥n. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emulate8080Op</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opcode = &amp;state-&gt;memory[state-&gt;pc]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(*opcode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">//NOP -  ! case 0x01: //LXI B, state-&gt;c = opcode[1]; state-&gt;b = opcode[2]; state-&gt;pc += 2; //   2  break; /*....*/ case 0x41: state-&gt;b = state-&gt;c; break; //MOV B,C case 0x42: state-&gt;b = state-&gt;d; break; //MOV B,D case 0x43: state-&gt;b = state-&gt;e; break; //MOV B,E } state-&gt;pc+=1; }</span></span></code> </pre> <br>  Ah√≠ tienes.  Para cada c√≥digo de operaci√≥n, cambiamos el estado y la memoria, como lo har√≠a un comando ejecutado en un 8080 real. <br><br>  El 8080 tiene aproximadamente 7 tipos, dependiendo de c√≥mo los clasifique: <br><br><ul><li>  Transferencia de datos </li><li>  Aritm√©tica </li><li>  L√≥gico </li><li>  Ramas </li><li>  Pila </li><li>  Entrada-salida </li><li>  Especial </li></ul><br>  Miremos cada uno de ellos individualmente. <br><br><h1>  Grupo aritm√©tico </h1><br>  Las instrucciones aritm√©ticas son muchos de los 256 c√≥digos de operaci√≥n del procesador 8080, que incluyen varios tipos de suma y resta.  La mayor√≠a de las instrucciones aritm√©ticas funcionan con el registro A y guardan el resultado en A. (El registro A tambi√©n se llama acumulador). <br><br>  Es interesante notar que estos comandos afectan los c√≥digos de condici√≥n.  Los c√≥digos de estado (tambi√©n llamados indicadores) se establecen seg√∫n el resultado del comando ejecutado.  No todos los comandos afectan a las banderas, y no todos los equipos que afectan las banderas afectan a todas las banderas a la vez. <br><br><h3>  Banderas 8080 </h3><br>  En un procesador 8080, los indicadores se denominan Z, S, P, CY y AC. <br><br><ul><li>  Z (cero, cero) toma el valor 1 cuando el resultado es cero </li><li>  S (signo) toma el valor 1 cuando se da el bit 7 (el bit m√°s significativo, el m√°s significativo, MSB) del comando matem√°tico </li><li>  P (paridad, paridad) se establece cuando el resultado es par y se restablece cuando es impar </li><li>  CY (carry) toma el valor 1 cuando, como resultado del comando, se realiza una transferencia o pr√©stamo en un bit de orden superior </li><li>  AC (transporte auxiliar) se utiliza principalmente para las matem√°ticas BCD (decimal codificado en binario).  Para obtener m√°s detalles, consulte el manual, en Space Invaders este indicador no se utiliza. </li></ul><br>  Los c√≥digos de estado se usan en comandos de ramificaci√≥n condicionales, por ejemplo, JZ realiza ramificaciones solo si se establece la bandera Z. <br><br>  La mayor√≠a de las instrucciones tienen tres formas: para registros, para valores inmediatos y para memoria.  Implementemos algunas instrucciones para comprender sus formularios y ver c√≥mo es trabajar con c√≥digos de estado.  (Tenga en cuenta que no implemento el indicador de transferencia auxiliar porque no se usa. Si lo implement√©, no podr√≠a probarlo). <br><br><h4>  Formulario de registro </h4><br>  Aqu√≠ hay un ejemplo de implementaci√≥n de dos instrucciones con un formulario de registro;  en el primero, implement√© el c√≥digo para que su trabajo sea m√°s f√°cil de entender, y en el segundo, se presenta una forma m√°s compacta que hace lo mismo. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADD B { //      , //      uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) state-&gt;b; //  :    , //    , //      if ((answer &amp; 0xff) == 0) state-&gt;cc.z = 1; else state-&gt;cc.z = 0; //  :   7 , //    , //      if (answer &amp; 0x80) state-&gt;cc.s = 1; else state-&gt;cc.s = 0; //   if (answer &gt; 0xff) state-&gt;cc.cy = 1; else state-&gt;cc.cy = 0; //    state-&gt;cc.p = Parity( answer &amp; 0xff); state-&gt;a = answer &amp; 0xff; } //  ADD     case 0x81: //ADD C { uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) state-&gt;c; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br>  Emulo comandos matem√°ticos de 8 bits con un n√∫mero de 16 bits.  Esto facilita el seguimiento de los casos en que los c√°lculos generan un acarreo. <br><br><h4>  Formulario para valores inmediatos </h4><br>  La forma de los valores inmediatos es casi la misma, excepto que el byte despu√©s del comando es la fuente del agregado.  Como "opcode" es un puntero al comando actual en la memoria, opcode [1] ser√° inmediatamente el siguiente byte. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xC6</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADI  { uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) opcode[1]; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br><h4>  Forma para la memoria </h4><br>  En el formulario para memoria, se agregar√° un byte al que indica la direcci√≥n almacenada en un par de registros HL. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x86</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADD M { uint16_t offset = (state-&gt;h&lt;&lt;8) | (state-&gt;l); uint16_t answer = (uint16_t) state-&gt;a + state-&gt;memory[offset]; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br><h3>  Notas </h3><br>  Las instrucciones aritm√©ticas restantes se implementan de manera similar.  Adiciones: <br><br><ul><li>  En diferentes versiones con carry (ADC, ACI, SBB, SUI), de acuerdo con el manual de referencia, utilizamos bits de carry en los c√°lculos. </li><li>  INX y DCX afectan a los pares de registros; estos comandos no afectan a las banderas. </li><li>  DAD es otro comando de un par de registros, solo afecta a la bandera de acarreo </li><li>  INR y DCR no afectan la bandera de acarreo </li></ul><br><h1>  Grupo de sucursal </h1><br>  Despu√©s de tratar con los c√≥digos de estado, el grupo de sucursales se volver√° lo suficientemente claro para usted.  Hay dos tipos de ramificaci√≥n: transiciones (JMP) y llamadas (CALL).  JMP simplemente establece la PC en el valor del destino del salto.  CALL se usa para rutinas, escribe la direcci√≥n de retorno en la pila y luego asigna a la PC la direcci√≥n de destino.  RET regresa de CALL, recibe la direcci√≥n de la pila y la escribe en la PC. <br><br>  Tanto JMP como CALL solo van a direcciones absolutas que est√°n codificadas en bytes despu√©s del c√≥digo de operaci√≥n. <br><br><h3>  Jmp </h3><br>  El comando JMP se ramifica incondicionalmente a la direcci√≥n de destino.  Tambi√©n hay comandos de ramificaci√≥n condicionales para todos los c√≥digos de estado (excepto para AC): <br><br><ul><li>  JNZ y JZ para cero </li><li>  JNC y JC para migraci√≥n </li><li>  JPO y JPE por paridad </li><li>  JP (m√°s) y JM (menos) para el signo </li></ul><br>  Aqu√≠ hay una implementaci√≥n de algunos de ellos: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xc2</span></span>: <span class="hljs-comment"><span class="hljs-comment">//JNZ  if (0 == state-&gt;cc.z) state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; else //    state-&gt;pc += 2; break; case 0xc3: //JMP  state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; break;</span></span></code> </pre> <br><h3>  LLAME Y RETIRE </h3><br>  CALL empuja la direcci√≥n de la instrucci√≥n en la pila despu√©s de la llamada y luego salta a la direcci√≥n de destino.  RET recibe la direcci√≥n de la pila y la guarda en la PC.  Existen versiones condicionales de CALL y RET para todos los estados. <br><br><ul><li>  CZ, CNZ, RZ, RNZ para cero </li><li>  CNC, CC, RNC, RC para transferencia </li><li>  CPO, CPE, RPO, RPE para paridad </li><li>  CP, CM, RP, RM para firmar </li></ul><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xcd</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CALL  { uint16_t ret = state-&gt;pc+2; state-&gt;memory[state-&gt;sp-1] = (ret &gt;&gt; 8) &amp; 0xff; state-&gt;memory[state-&gt;sp-2] = (ret &amp; 0xff); state-&gt;sp = state-&gt;sp - 2; state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; } break; case 0xc9: //RET state-&gt;pc = state-&gt;memory[state-&gt;sp] | (state-&gt;memory[state-&gt;sp+1] &lt;&lt; 8); state-&gt;sp += 2; break;</span></span></code> </pre> <br><h3>  Notas </h3><br><ul><li>  El comando PCHL salta incondicionalmente a una direcci√≥n en un par de registros HL. </li><li>  No inclu√≠ el RST discutido anteriormente en este grupo.  Escribe la direcci√≥n de retorno en la pila y luego salta a la direcci√≥n predefinida en la parte inferior de la memoria. </li></ul><br><h1>  Grupo l√≥gico </h1><br>  Este grupo realiza operaciones l√≥gicas (consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera publicaci√≥n del</a> tutorial).  Por su naturaleza, son similares a un grupo aritm√©tico en que la mayor√≠a de las operaciones funcionan con el registro A (unidad), y la mayor√≠a de las operaciones afectan a las banderas.  Todas las operaciones se realizan en valores de 8 bits, en este grupo no hay comandos que afecten a pares de registros. <br><br><h3>  Operaciones booleanas </h3><br>  AND, OR, NOT (CMP) y "exclusivo o" (XOR) se denominan operaciones booleanas.  OR y AND expliqu√© anteriormente.  El comando NOT (para el procesador 8080 se llama CMA, o acumulador de complemento) simplemente cambia los valores de bits: todas las unidades se convierten en ceros y los ceros se convierten en unos. <br><br>  Percibo a XOR como un "reconocedor de diferencia".  Su tabla de verdad se ve as√≠: <br><br><table><tbody><tr><td>  x </td><td>  y </td><td>  Resultado </td></tr><tr><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td></tr><tr><td>  0 0 </td><td>  1 </td><td>  1 </td></tr><tr><td>  1 </td><td>  0 0 </td><td>  1 </td></tr><tr><td>  1 </td><td>  1 </td><td>  0 0 </td></tr></tbody></table><br>  AND, OR y XOR tienen una forma para registros, memoria y valores inmediatos.  (CMP solo tiene un comando que distingue entre may√∫sculas y min√∫sculas).  Aqu√≠ hay una implementaci√≥n de un par de c√≥digos de operaci√≥n: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x2F</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CMA (not) state-&gt;a = ~state-&gt;a //  ,  CMA     break; case 0xe6: //ANI  { uint8_t x = state-&gt;a &amp; opcode[1]; state-&gt;cc.z = (x == 0); state-&gt;cc.s = (0x80 == (x &amp; 0x80)); state-&gt;cc.p = parity(x, 8); state-&gt;cc.cy = 0; //  ,  ANI  CY state-&gt;a = x; state-&gt;pc++; //   } break;</span></span></code> </pre> <br><h3>  Comandos de desplazamiento c√≠clico </h3><br>  Estos comandos cambian el orden de los bits en los registros.  Un desplazamiento hacia la derecha los mueve un bit hacia la derecha y un desplazamiento hacia la izquierda, un bit hacia la izquierda: <br><br> <code>  (0b00010000) = 0b00001000</code> <br> <br> <code>  (0b00000001) = 0b00000010</code> <br> <br>  Parecen no tener valor, pero en realidad esto no es as√≠.  Se pueden usar para multiplicar y dividir por potencias de dos.  Tome el desplazamiento a la izquierda como ejemplo.  <code>0b00000001</code> es decimal 1, y desplazarlo hacia la izquierda lo convierte en <code>0b00000010</code> , es decir, decimal 2. Si realizamos otro desplazamiento hacia la izquierda, obtenemos <code>0b00000100</code> , que es 4. Otro desplazamiento hacia la izquierda, y lo multiplicamos por 8. Esto funcionar√° con cualquier por n√∫meros: 5 ( <code>0b00000101</code> ) cuando se desplaza hacia la izquierda da 10 ( <code>0b00001010</code> ).  Otro desplazamiento a la izquierda da 20 ( <code>0b00010100</code> ).  Un cambio a la derecha hace lo mismo, pero para la divisi√≥n. <br><br>  El 8080 no tiene un comando de multiplicaci√≥n, pero se puede implementar con estos comandos.  Si comprende c√≥mo hacer esto, recibir√° puntos de bonificaci√≥n.  Una vez me hicieron esa pregunta en una entrevista.  (Lo hice, aunque me tom√≥ unos minutos). <br><br>  Estos comandos rotan el disco c√≠clicamente y solo afectan la bandera de acarreo.  Aqu√≠ hay un par de comandos: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x0f</span></span>: <span class="hljs-comment"><span class="hljs-comment">//RRC { uint8_t x = state-&gt;a; state-&gt;a = ((x &amp; 1) &lt;&lt; 7) | (x &gt;&gt; 1); state-&gt;cc.cy = (1 == (x&amp;1)); } break; case 0x1f: //RAR { uint8_t x = state-&gt;a; state-&gt;a = (state-&gt;cc.cy &lt;&lt; 7) | (x &gt;&gt; 1); state-&gt;cc.cy = (1 == (x&amp;1)); } break;</span></span></code> </pre> <br><h3>  Comparaci√≥n </h3><br>  La tarea de CMP y CPI es solo establecer marcas (para ramificaci√≥n).  Lo hacen restando banderas, pero no almacenando el resultado. <br><br><ul><li>  Igualmente: si dos n√∫meros son iguales, entonces se establece la bandera Z, ya que su resta entre s√≠ da cero. </li><li>  Mayor que: si A es mayor que el valor que se est√° comparando, entonces el indicador CY se borra (ya que la sustracci√≥n se puede hacer sin pedir prestado). </li><li>  Menor: si A es menor que el valor comparado, se establece el indicador CY (porque A debe completar el pr√©stamo para completar la resta). </li></ul><br>  Hay versiones de estos comandos para registros, memoria y valores inmediatos.  La implementaci√≥n es una simple resta sin guardar el resultado: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xfe</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CPI  { uint8_t x = state-&gt;a - opcode[1]; state-&gt;cc.z = (x == 0); state-&gt;cc.s = (0x80 == (x &amp; 0x80)); //  ,    p -   state-&gt;cc.p = parity(x, 8); state-&gt;cc.cy = (state-&gt;a &lt; opcode[1]); state-&gt;pc++; } break;</span></span></code> </pre> <br><h3>  CMC y STC </h3><br>  Completan el grupo l√≥gico.  Se utilizan para establecer y borrar la bandera de transporte. <br><br><h1>  Grupo de entrada-salida y comandos especiales. </h1><br>  Estos comandos no pueden asignarse a ninguna otra categor√≠a.  Los mencionar√© para completar, pero me parece que tendremos que volver a ellos cuando comencemos a emular el hardware de Space Invaders. <br><br><ul><li>  EI y DI habilitan o deshabilitan la capacidad del procesador para manejar las interrupciones.  Agregu√© el indicador interrupt_enabled a la estructura de estado del procesador y lo configur√© / reinici√© usando estos comandos. </li><li>  Parece que RIM y SIM se utilizan principalmente para E / S en serie.  Si est√° interesado, puede leer el manual, pero estos comandos no se utilizan en Space Invaders.  No los emular√©. </li><li>  HLT es una parada.  No creo que debamos emularlo, pero puede llamar a su c√≥digo para salir (o salir (0)) cuando vea este comando. </li><li>  IN y OUT son comandos que el equipo procesador 8080 usa para comunicarse con equipos externos.  Mientras los estamos implementando, no har√°n nada m√°s que saltear su byte de datos.  (M√°s tarde volveremos a ellos). </li><li>  NOP es "sin operaci√≥n".  Una aplicaci√≥n de NOP es controlar la sincronizaci√≥n del panel (se requieren cuatro ciclos de CPU para ejecutarse). </li></ul><br>  Otra aplicaci√≥n de NOP es la modificaci√≥n del c√≥digo.  Digamos que necesitamos cambiar el c√≥digo ROM del juego.  No podemos simplemente eliminar c√≥digos de operaci√≥n innecesarios, porque no queremos cambiar todos los comandos CALL y JMP (ser√°n incorrectos si al menos una parte del c√≥digo se mueve).  Con NOP podemos deshacernos del c√≥digo.  <em>¬°Agregar c√≥digo es mucho m√°s dif√≠cil!</em>  <em>Puede agregarlo buscando espacio en alg√∫n lugar de la ROM y cambiando el comando a JMP.</em> <br><br><h1>  Grupo de pila </h1><br>  Ya hemos completado la mec√°nica para la mayor√≠a de los equipos en el grupo de pila.  Si hiciste el trabajo conmigo, entonces estos comandos ser√°n f√°ciles de implementar. <br><br><h3>  EMPUJE y POP </h3><br>  PUSH y POP solo funcionan con pares de registros.  PUSH escribe un par de registros en la pila, y POP toma 2 bytes de la parte superior de la pila y los escribe en un par de registros. <br><br>  Hay cuatro c√≥digos de operaci√≥n para PUSH y POP, uno para cada uno de los pares: BC, DE, HL y PSW.  PSW es ‚Äã‚Äãun par especial de registros de banderas de unidades y c√≥digos de estado.  Aqu√≠ est√° mi implementaci√≥n de PUSH y POP para BC y PSW.  No hay comentarios en √©l, no creo que haya nada particularmente complicado aqu√≠. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xc1</span></span>: <span class="hljs-comment"><span class="hljs-comment">//POP B { state-&gt;c = state-&gt;memory[state-&gt;sp]; state-&gt;b = state-&gt;memory[state-&gt;sp+1]; state-&gt;sp += 2; } break; case 0xc5: //PUSH B { state-&gt;memory[state-&gt;sp-1] = state-&gt;b; state-&gt;memory[state-&gt;sp-2] = state-&gt;c; state-&gt;sp = state-&gt;sp - 2; } break; case 0xf1: //POP PSW { state-&gt;a = state-&gt;memory[state-&gt;sp+1]; uint8_t psw = state-&gt;memory[state-&gt;sp]; state-&gt;cc.z = (0x01 == (psw &amp; 0x01)); state-&gt;cc.s = (0x02 == (psw &amp; 0x02)); state-&gt;cc.p = (0x04 == (psw &amp; 0x04)); state-&gt;cc.cy = (0x05 == (psw &amp; 0x08)); state-&gt;cc.ac = (0x10 == (psw &amp; 0x10)); state-&gt;sp += 2; } break; case 0xf5: //PUSH PSW { state-&gt;memory[state-&gt;sp-1] = state-&gt;a; uint8_t psw = (state-&gt;cc.z | state-&gt;cc.s &lt;&lt; 1 | state-&gt;cc.p &lt;&lt; 2 | state-&gt;cc.cy &lt;&lt; 3 | state-&gt;cc.ac &lt;&lt; 4 ); state-&gt;memory[state-&gt;sp-2] = psw; state-&gt;sp = state-&gt;sp - 2; } break;</span></span></code> </pre> <br><h3>  SPHL y XTHL </h3><br>  Hay dos equipos m√°s en el grupo de pila: SPHL y XTHL. <br><br><ul><li>  <code>SPHL</code> mueve HL a SP (obligando a SP a obtener una nueva direcci√≥n). </li><li>  <code>XTHL</code> intercambia lo que est√° encima de la pila con lo que hay en un par de registros HL.  ¬øPor qu√© necesitar√≠as hacer esto?  No lo se </li></ul><br><h1>  Un poco m√°s sobre los n√∫meros binarios. </h1><br>  Al escribir un programa de computadora, una de las decisiones que debe tomar es elegir el tipo de datos utilizados para los n√∫meros, si desea que sean negativos y cu√°l deber√≠a ser su tama√±o m√°ximo.  Para el emulador de CPU, necesitamos que el tipo de datos coincida con el tipo de datos de la CPU de destino. <br><br><h3>  Firmado y sin firmar </h3><br>  Cuando comenzamos a hablar de n√∫meros hexadecimales, los consideramos sin signo, es decir, cada d√≠gito binario del n√∫mero hexadecimal ten√≠a un valor positivo, y cada uno se consideraba una potencia de dos (unidades, dos, cuatro, etc.). <br><br>  Nos ocupamos del problema del almacenamiento en la computadora de n√∫meros negativos.  Si sabe que los datos en cuesti√≥n tienen un signo, es decir, pueden ser negativos, entonces puede reconocer un n√∫mero negativo por el bit m√°s significativo del n√∫mero (bit m√°s significativo, MSB).  Si el tama√±o de los datos es de un byte, cada n√∫mero con un valor de bit MSB dado es negativo, y cada uno con un MSB cero es positivo. <br><br>  El valor de un n√∫mero negativo se almacena como un c√≥digo adicional.  Si tenemos un n√∫mero con signo, y el MSB es igual a uno, y queremos saber cu√°l es este n√∫mero, entonces podemos convertirlo de la siguiente manera: realice el "NO" binario para los n√∫meros hexadecimales y luego agregue uno. <br><br>  Por ejemplo, para un n√∫mero hexadecimal 0x80, se establece el bit MSB, es decir, es negativo.  El "NO" binario del n√∫mero 0x80 es 0x7f, o decimal 127. 127 + 1 = 128. Es decir, 0x80 en decimal es -128.  Segundo ejemplo: 0xC5.  No (0xC5) = 0x3A = decimal 58 +1 = decimal 59. Es decir, 0xC5 es decimal -59. <br><br>  Lo sorprendente de los n√∫meros con c√≥digo adicional es que podemos realizar c√°lculos con ellos como con n√∫meros sin signo, y <em>seguir√°n funcionando</em> .  La computadora no necesita hacer nada especial con signos.  Mostrar√© un par de ejemplos que prueban esto. <br><br><pre>  Ejemplo 1<font></font>
<font></font>
      decimal hexadecimal binario    
       -3 0xFD 1111 1101    
    + 10 0x0A +0000 1010    
    ----- -----------    
        7 0x07 1 0000 0111    
                        ^ Esto se registra en el bit de acarreo<font></font>
<font></font>
    Ejemplo 2    <font></font>
<font></font>
      decimal hexadecimal binario    
      -59 0xC5 1100 0101    
    + 33 0x21 +0010 0001    
    ----- -----------    
      -26 0xE6 1110 0110 </pre><br><br>  En el Ejemplo 1, vemos que sumar 10 y -3 da como resultado 7. El resultado de la suma se transfiri√≥, por lo que se puede establecer el indicador C. En el Ejemplo 2, el resultado de la suma fue negativo, por lo que decodificamos esto: No (0xE6) = 0x19 = 25 + 1 = 26. <code>0xE6 = -26</code> Explosi√≥n del cerebro! <br><br>  Si lo desea, lea m√°s sobre el c√≥digo adicional en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wikipedia</a> . <br><br><h3>  Tipos de datos </h3><br>  En C, existe una relaci√≥n entre los tipos de datos y el n√∫mero de bytes utilizados para este tipo.  De hecho, solo nos interesan los enteros.  Los tipos de datos C est√°ndar / de la vieja escuela son char, int y long, as√≠ como sus amigos unsigned char, unsigned int y unsigned long.  El problema es que en diferentes plataformas y en diferentes compiladores, estos tipos pueden tener diferentes tama√±os. <br><br>  Por lo tanto, es mejor seleccionar un tipo de datos para nuestra plataforma que declare expl√≠citamente el tama√±o de los datos.  Si su plataforma tiene stdint.h, puede usar int8_t, uint8_t, etc. <br><br>  El tama√±o de un n√∫mero entero determina el n√∫mero m√°ximo que se puede almacenar en √©l.  En el caso de enteros sin signo, puede almacenar n√∫meros de 0 a 255 en 8 bits. Si traduce a hexadecimal, entonces es de 0x00 a 0xFF.  Dado que 0xFF tiene "todos los bits establecidos", y corresponde al decimal 255, es completamente l√≥gico que el intervalo de un entero sin signo de un solo byte sea 0-255.  Los intervalos nos dicen que todos los tama√±os de enteros funcionar√°n exactamente igual: los n√∫meros corresponden al n√∫mero que se obtiene cuando se establecen todos los bits. <br><br><table><tbody><tr><th>  Tipo </th><th>  Intervalo </th><th>  Maleficio </th></tr><tr><td>  8 bits sin signo </td><td>  0-255 </td><td>  0x0-0xFF </td></tr><tr><td>  8 bits firmado </td><td>  -128-127 </td><td>  0x80-0x7F </td></tr><tr><td>  16 bits sin signo </td><td>  0-65535 </td><td>  0x0-0xFFFF </td></tr><tr><td>  16 bits firmado </td><td>  -32768-32767 </td><td>  0x8000-0x7FFF </td></tr><tr><td>  32 bits sin signo </td><td>  0-4294967295 </td><td>  0x0-0xFFFFFFFFFF </td></tr><tr><td>  32 bits firmado </td><td>  -2147483648-2147483647 </td><td>  0x80000000-0x7FFFFFFF </td></tr></tbody></table><br>  A√∫n m√°s interesante es que -1 en cada tipo de datos con signo es un n√∫mero que tiene todos los bits establecidos (0xFF para el byte con signo, 0xFFFF para el n√∫mero de 16 bits con signo y 0xFFFFFFFF para el n√∫mero de 32 bits con signo).  Si los datos se consideran sin signo, entonces para todos los bits dados, se obtiene el n√∫mero m√°ximo posible para este tipo de datos. <br><br>  Para emular registros de procesador, seleccionamos el tipo de datos correspondiente al tama√±o de este registro.  Probablemente valga la pena seleccionar tipos sin firmar de forma predeterminada y convertirlos cuando necesite considerarlos firmados.  Por ejemplo, usamos el tipo de datos uint8_t para representar un registro de 8 bits. <br><br><h3>  Sugerencia: use un depurador para convertir tipos de datos </h3><br>  Si gdb est√° instalado en su plataforma, entonces es muy conveniente usarlo para trabajar con n√∫meros binarios.  A continuaci√≥n, mostrar√© un ejemplo: en la sesi√≥n que se muestra a continuaci√≥n, las l√≠neas que comienzan con # son comentarios que agregu√© m√°s adelante. <br><br> <code>#  /c,   gdb      <br> (gdb) print /c 0xFD <br> $1 = -3 '?' <br> <br> #  /x,   gdb    hex <br> #   "p"  "print" <br> (gdb) p /c 0xA <br> $2 = 10 '\n' <br> <br> #    2  " " <br> (gdb) p /c 0xC5 <br> $3 = -59 '?' <br> (gdb) p /c 0xC5+0x21 <br> $4 = -26 '?' <br> <br> #  print  ,  gdb    <br> (gdb) p 0x21 <br> $9 = 33 <br> <br> #     ,     gdb, <br> #  ,      <br> (gdb) p 0xc5 <br> $5 = 197 # <br> (gdb) p /c 0xc5 <br> $3 = -59 '?' # <br> (gdb) p 0xfd <br> $6 = 253 <br> <br> #        (   32- ) <br> (gdb) p /x -3 <br> $7 = 0xfffffffd <br> <br> #   1     <br> (gdb) print (char) 0xff <br> $1 = -1 '?' <br> #   1     <br> (gdb) print (unsigned char) 0xff <br> $2 = 255 '?'</code> <br> <br>  Cuando trabajo con n√∫meros hexadecimales, siempre lo hago en gdb, y sucede casi todos los d√≠as.  Mucho m√°s f√°cil que abrir la calculadora de un programador con una GUI.  En m√°quinas Linux (y Mac OS X), para iniciar una sesi√≥n de gdb, simplemente abra un terminal e ingrese "gdb".  Si usa Xcode en OS X, luego de iniciar el programa, puede usar la consola dentro de Xcode (en la que se imprime la salida de printf).  En Windows, el depurador gdb est√° disponible en Cygwin. <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terminaci√≥n del emulador de CPU </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habiendo recibido toda esta informaci√≥n, est√°s listo para un largo viaje. </font><font style="vertical-align: inherit;">Debes decidir c√≥mo implementar el emulador: crear una emulaci√≥n 8080 completa o implementar solo los comandos necesarios para completar el juego. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si decide hacer una emulaci√≥n completa, necesitar√° algunas herramientas m√°s. </font><font style="vertical-align: inherit;">Hablar√© de ellos en la siguiente secci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otra forma es emular solo las instrucciones utilizadas por el juego. </font><font style="vertical-align: inherit;">Continuaremos completando esa construcci√≥n de interruptor enorme que creamos en la secci√≥n Shell del emulador. </font><font style="vertical-align: inherit;">Repetiremos el siguiente proceso hasta que tengamos un solo comando no realizado:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inicie el emulador con ROM Space Invaders </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La llamada se </font></font><code>UnimplementedInstruction()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cierra si el comando no est√° listo</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Emula esta instrucci√≥n </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Goto 1 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo primero que hice al comenzar a escribir mi emulador fue agregar c√≥digo de mi desensamblador. </font><font style="vertical-align: inherit;">Entonces pude generar un comando que deber√≠a ejecutarse de la siguiente manera:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emulate8080Op</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opcode = &amp;state-&gt;memory[state-&gt;pc]; Disassemble8080Op(state-&gt;memory, state-&gt;pc); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (*opcode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>: <span class="hljs-comment"><span class="hljs-comment">//NOP /* ... */ } /*    */ printf("\tC=%d,P=%d,S=%d,Z=%d\n", state-&gt;cc.cy, state-&gt;cc.p, state-&gt;cc.s, state-&gt;cc.z); printf("\tA $%02x B $%02x C $%02x D $%02x E $%02x H $%02x L $%02x SP %04x\n", state-&gt;a, state-&gt;b, state-&gt;c, state-&gt;d, state-&gt;e, state-&gt;h, state-&gt;l, state-&gt;sp); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n agregu√© c√≥digo al final para mostrar todos los registros y banderas de estado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buenas noticias: para profundizar en el programa para 50 mil equipos, solo necesitamos un subconjunto de los c√≥digos de operaci√≥n 8080. Incluso dar√© una lista de c√≥digos de operaci√≥n que deben implementarse:</font></font><br><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Opcode </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El equipo </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x00 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nop </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x01 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI B, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x05 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCR B </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x06 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI B, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x09 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pap√° b </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0d </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCR C </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI C, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0f </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rrc </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x11 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI D, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x13 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inx d </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x19 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pap√° d </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x1a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LDAX D </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x21 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI H, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x23 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inx h </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x26 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI H, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x29 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pap√° h </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x31 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI SP, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x32 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> STA adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x36 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI M, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x3a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lda adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x3e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI A, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x56 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV D, M </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x5e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV E, M </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x66 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV H, M </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x6f </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV L, A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x77 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV M, A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, D </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7b </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, E </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7c </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, H </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, M </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xa7 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ANA A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xaf </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> XRA A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pop b </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jnz adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jmp adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PULSE B </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc6 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ADI D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc9 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ret </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xcd </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Llamar adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pop d </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> OUT D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PULSAR D </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pop h </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EMPUJE H </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe6 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ANI D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xeb </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Xchg </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xf1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> POP PSW </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xf5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EMPUJE PSW </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xfb </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ei </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xfe </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IPC D8 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estas son solo 50 instrucciones, y 10 de ellas son movimientos que se implementan trivialmente. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Depuraci√≥n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero tengo algunas malas noticias. </font><font style="vertical-align: inherit;">Su emulador seguramente no funcionar√° correctamente, y los errores en dicho c√≥digo son muy dif√≠ciles de encontrar. </font><font style="vertical-align: inherit;">Si sabe qu√© comando se est√° comportando mal (por ejemplo, una transici√≥n o una llamada que va a un c√≥digo sin sentido), puede intentar corregir el error examinando su c√≥digo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s de examinar el c√≥digo, hay otra forma de solucionar el problema: comparando su emulador con uno que funcione con seguridad. </font><font style="vertical-align: inherit;">Suponemos que otro emulador siempre funciona correctamente, y todas las diferencias son errores en su emulador. </font><font style="vertical-align: inherit;">Por ejemplo, puedes usar mi emulador. </font><font style="vertical-align: inherit;">Puede ejecutarlos manualmente en paralelo. </font><font style="vertical-align: inherit;">Puede ahorrar tiempo si integra mi c√≥digo en su proyecto para obtener el siguiente proceso:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crea un estado para tu emulador </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crea un estado para el m√≠o </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para el proximo equipo </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Llamar a tu emulador con tu estado </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Llamando a los m√≠os con mi fortuna </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compara nuestros dos estados </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buscando errores en cualquier diferencia </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ir a 3 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otra forma es usar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este sitio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> manualmente </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este es un emulador de procesador Javascript 8080 que incluso incluye ROM Space Invaders. </font><font style="vertical-align: inherit;">Aqu√≠ est√° el proceso:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reinicie la emulaci√≥n de Space Invaders haciendo clic en el bot√≥n Space Invaders </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Presione el bot√≥n "Ejecutar 1" para ejecutar el comando. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ejecutamos el siguiente comando en nuestro emulador </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compare el estado del procesador con el suyo </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si las condiciones coinciden, pase a 2 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si las condiciones no coinciden, entonces su emulaci√≥n de instrucciones es err√≥nea. </font><font style="vertical-align: inherit;">Corr√≠jalo y luego comience nuevamente desde el paso 1.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al principio utilic√© este m√©todo para depurar mi emulador 8080. No mentir√©, el proceso puede ser largo. Como resultado, muchos de mis problemas resultaron ser errores tipogr√°ficos y de copiar y pegar, que despu√©s de la detecci√≥n fueron muy f√°ciles de solucionar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si ejecuta su c√≥digo paso a paso, la mayor√≠a de las primeras 30 mil instrucciones se ejecutan en un ciclo de aproximadamente $ 1a5f. Si observa </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">javascript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">emulador</font></a><font style="vertical-align: inherit;"> , puede ver que este c√≥digo copia datos en la pantalla. Estoy seguro de que este c√≥digo se llama con frecuencia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de la primera representaci√≥n de la pantalla, despu√©s de 50 mil comandos, el programa se atasca en este ciclo sin fin:</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-number"><span class="hljs-number">0</span></span>ada LDA <span class="hljs-meta"><span class="hljs-meta">$20</span></span>c0 <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ANA A <span class="hljs-number"><span class="hljs-number">0</span></span>ade JNZ <span class="hljs-meta"><span class="hljs-meta">$0</span></span>ada</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espera hasta que el valor en la memoria a $ 20c0 cambie a cero. </font><font style="vertical-align: inherit;">Dado que el c√≥digo en este bucle no cambia exactamente $ 20c0, debe ser una se√±al de otro lugar. </font><font style="vertical-align: inherit;">Es hora de hablar sobre emular el "hierro" de una m√°quina arcade. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de pasar a la siguiente secci√≥n, aseg√∫rese de que su emulador de CPU se encuentre en este ciclo sin fin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para referencia, vea </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mis fuentes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Emulaci√≥n 8080 completa </font></font></h1><br> ,   :   ,    .        .     ,     .         ,     . <br><br>     ,       8080     .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  8080</a>   cpudiag.asm,       8080. <br><br>           : <br><br><ol><li>  ,          .  ,   cpudiag.asm    . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como puede ver, el proceso es bastante laborioso. </font><font style="vertical-align: inherit;">Creo que un novato en la depuraci√≥n del c√≥digo del ensamblador experimentar√° grandes dificultades si estos pasos no se enumeran.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As√≠ es como us√© esta prueba con mi emulador. </font><font style="vertical-align: inherit;">Puede usarlo o encontrar una mejor manera de integrarlo.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conjunto de prueba </font></font></h3><br>    ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> .    cpudiag.asm   ,     .   ,  ,   ,     ¬´Make Beautiful Code¬ª  ,      test.bin,    8080.     ,   . <br><br> <a href=""> cpudiag.asm</a>     . <br><br> <a href=""> cpudiag.bin</a> (  8080)   . <br><br><h3>      </h3><br>    invaders.*     . <br><br>    . -,       <code>ORG 00100H</code> ,   ,      ,       0x100 hex.         8080,   ,    .    ,  ,          ,     0x100. <br><br> -,      ,           .       hex- <code>JMP $0100</code> ,    . (     PC   0x100.) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En tercer lugar, encontr√© un error en el c√≥digo compilado. </font><font style="vertical-align: inherit;">Creo que la raz√≥n es el procesamiento incorrecto de la √∫ltima l√≠nea de c√≥digo </font></font><code>STACK EQU TEMPP+256</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero no estoy seguro. </font><font style="vertical-align: inherit;">Sea como fuere, la pila durante la compilaci√≥n se ubic√≥ en $ 6ad, y los primeros PUSH comenzaron a reescribir el c√≥digo. </font><font style="vertical-align: inherit;">Suger√≠ que la variable tambi√©n deber√≠a estar compensada por 0x100, como el resto del c√≥digo, as√≠ que lo arregl√© insertando "0x7" en la l√≠nea de c√≥digo que inicializa el puntero de la pila. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, dado que no implement√© DAA o la migraci√≥n auxiliar en mi emulador, modifico el c√≥digo para omitir esta verificaci√≥n (simplemente la omitimos usando JMP).</font></font><br><br><pre> <code class="cpp hljs"> ReadFileIntoMemoryAt(state, <span class="hljs-string"><span class="hljs-string">"/Users/kpmiller/Desktop/invaders/cpudiag.bin"</span></span>, <span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ,   JMP 0x100 state-&gt;memory[0]=0xc3; state-&gt;memory[1]=0; state-&gt;memory[2]=0x01; //Fix the stack pointer from 0x6ad to 0x7ad // this 0x06 byte 112 in the code, which is // byte 112 + 0x100 = 368 in memory state-&gt;memory[368] = 0x7; //  DAA state-&gt;memory[0x59c] = 0xc3; //JMP state-&gt;memory[0x59d] = 0xc2; state-&gt;memory[0x59e] = 0x05;</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La prueba est√° tratando de llegar a una conclusi√≥n. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, esta prueba se basa en la ayuda del sistema operativo CP / M. Descubr√≠ que CP / M tiene un c√≥digo de $ 0005 que imprime mensajes en la consola, y cambi√© mi emulaci√≥n CALL para manejar este comportamiento. No estoy seguro de si todo sali√≥ bien, pero funcion√≥ para los dos mensajes que el programa est√° tratando de imprimir. Mi emulaci√≥n CALL para ejecutar esta prueba se ve as√≠:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xcd</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CALL  #ifdef FOR_CPUDIAG if (5 == ((opcode[2] &lt;&lt; 8) | opcode[1])) { if (state-&gt;c == 9) { uint16_t offset = (state-&gt;d&lt;&lt;8) | (state-&gt;e); char *str = &amp;state-&gt;memory[offset+3]; // - while (*str != '$') printf("%c", *str++); printf("\n"); } else if (state-&gt;c == 2) { //    ,   ,    printf ("print char routine called\n"); } } else if (0 == ((opcode[2] &lt;&lt; 8) | opcode[1])) { exit(0); } else #endif { uint16_t ret = state-&gt;pc+2; state-&gt;memory[state-&gt;sp-1] = (ret &gt;&gt; 8) &amp; 0xff; state-&gt;memory[state-&gt;sp-2] = (ret &amp; 0xff); state-&gt;sp = state-&gt;sp - 2; state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; } break;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con esta prueba, encontr√© varios problemas en mi emulador. No estoy seguro de cu√°l de ellos estar√≠a involucrado en el juego, pero si lo estuvieran, ser√≠a muy dif√≠cil encontrarlos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segu√≠ adelante e implement√© todos los c√≥digos de operaci√≥n (con la excepci√≥n de DAA y sus amigos). Me llev√≥ 3-4 horas solucionar problemas en mis desaf√≠os e implementar otros nuevos. Definitivamente fue m√°s r√°pido que el proceso manual que describ√≠ anteriormente: antes de encontrar esta prueba, pas√© m√°s de 4 horas en el proceso manual. Si puede encontrar esta explicaci√≥n, le recomiendo usar este m√©todo en lugar de compararlo manualmente. Sin embargo, conocer el proceso manual tambi√©n es una gran habilidad, y si desea emular otro procesador, entonces debe volver a √©l.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si no puede realizar este proceso o parece demasiado complicado, definitivamente vale la pena elegir el enfoque descrito anteriormente con dos emuladores diferentes que se ejecutan dentro de su programa. </font><font style="vertical-align: inherit;">Cuando aparecen varios millones de comandos en el programa y se agregan interrupciones, ser√° imposible comparar manualmente dos emuladores.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418699/">https://habr.com/ru/post/es418699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418687/index.html">Revoluci√≥n de 3.5 ": detalles de un peque√±o boom de disquetes con vapores</a></li>
<li><a href="../es418689/index.html">C√≥mo crear bibliotecas de componentes en Figma, ahorrando un presupuesto, usando el ejemplo de una subasta en l√≠nea</a></li>
<li><a href="../es418691/index.html">Ganadero: Kubernetes en 5 minutos sobre metal desnudo.</a></li>
<li><a href="../es418693/index.html">¬øPor qu√© es tan dif√≠cil detectar la felicidad en el cerebro?</a></li>
<li><a href="../es418695/index.html">Guerras contra la pirater√≠a: el imperio contraataca</a></li>
<li><a href="../es418701/index.html">Estudiamos analizadores sint√°cticos para el idioma ruso</a></li>
<li><a href="../es418705/index.html">Fundamentos de Futex</a></li>
<li><a href="../es418707/index.html">KDispatcher: bus de eventos ligero y conveniente para el uso diario</a></li>
<li><a href="../es418709/index.html">Necesidad de forzarse: controladores y barreras de interfaz</a></li>
<li><a href="../es418711/index.html">Token Managed Registers 1.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>