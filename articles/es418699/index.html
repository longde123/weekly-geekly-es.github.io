<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍💼 👩🏾 🧙🏻 Creación de una máquina arcade emulador. Parte 3 🧑🏿 🔂 🕚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partes uno y dos . 

 Emulador de procesador 8080 
 Cáscara del emulador 
 Ahora debe tener todos los conocimientos necesarios para comenzar a crear u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Creación de una máquina arcade emulador. Parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418699/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ec/e50/f3a/4ece50f3a555bfb39878326ec26addd5.jpg" alt="imagen"></div><br>  Partes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uno</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dos</a> . <br><br><h1>  Emulador de procesador 8080 </h1><br><h1>  Cáscara del emulador </h1><br>  Ahora debe tener todos los conocimientos necesarios para comenzar a crear un emulador de procesador 8080. <br><br>  <em>Intentaré que mi código sea lo más claro posible, cada código de operación se implementa por separado.</em>  <em>Cuando se sienta cómodo con él, es posible que desee volver a escribirlo para optimizar el rendimiento o reutilizar el código.</em> <br><br>  Para empezar, crearé una estructura de memoria que contendrá campos para todo lo que me pareció necesario al escribir un desensamblador.  También habrá un lugar para un búfer de memoria, que será RAM. <br><a name="habracut"></a><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConditionCodes</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> z:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> s:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> p:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> cy:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ac:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pad:<span class="hljs-number"><span class="hljs-number">3</span></span>; } ConditionCodes; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State8080</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> c; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> d; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> e; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> h; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> l; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> sp; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *memory; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConditionCodes</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cc</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> int_enable; } State8080;</code> </pre> <br>  Ahora cree un procedimiento con una llamada de error que finalizará el programa con un error.  Se verá más o menos así: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnimplementedInstruction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// pc    ,     printf ("Error: Unimplemented instruction\n"); exit(1); } int Emulate8080Op(State8080* state) { unsigned char *opcode = &amp;state-&gt;memory[state-&gt;pc]; switch(*opcode) { case 0x00: UnimplementedInstruction(state); break; case 0x01: UnimplementedInstruction(state); break; case 0x02: UnimplementedInstruction(state); break; case 0x03: UnimplementedInstruction(state); break; case 0x04: UnimplementedInstruction(state); break; /*....*/ case 0xfe: UnimplementedInstruction(state); break; case 0xff: UnimplementedInstruction(state); break; } state-&gt;pc+=1; //  }</span></span></code> </pre> <br>  Implementemos algunos códigos de operación. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emulate8080Op</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opcode = &amp;state-&gt;memory[state-&gt;pc]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(*opcode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">//NOP -  ! case 0x01: //LXI B, state-&gt;c = opcode[1]; state-&gt;b = opcode[2]; state-&gt;pc += 2; //   2  break; /*....*/ case 0x41: state-&gt;b = state-&gt;c; break; //MOV B,C case 0x42: state-&gt;b = state-&gt;d; break; //MOV B,D case 0x43: state-&gt;b = state-&gt;e; break; //MOV B,E } state-&gt;pc+=1; }</span></span></code> </pre> <br>  Ahí tienes.  Para cada código de operación, cambiamos el estado y la memoria, como lo haría un comando ejecutado en un 8080 real. <br><br>  El 8080 tiene aproximadamente 7 tipos, dependiendo de cómo los clasifique: <br><br><ul><li>  Transferencia de datos </li><li>  Aritmética </li><li>  Lógico </li><li>  Ramas </li><li>  Pila </li><li>  Entrada-salida </li><li>  Especial </li></ul><br>  Miremos cada uno de ellos individualmente. <br><br><h1>  Grupo aritmético </h1><br>  Las instrucciones aritméticas son muchos de los 256 códigos de operación del procesador 8080, que incluyen varios tipos de suma y resta.  La mayoría de las instrucciones aritméticas funcionan con el registro A y guardan el resultado en A. (El registro A también se llama acumulador). <br><br>  Es interesante notar que estos comandos afectan los códigos de condición.  Los códigos de estado (también llamados indicadores) se establecen según el resultado del comando ejecutado.  No todos los comandos afectan a las banderas, y no todos los equipos que afectan las banderas afectan a todas las banderas a la vez. <br><br><h3>  Banderas 8080 </h3><br>  En un procesador 8080, los indicadores se denominan Z, S, P, CY y AC. <br><br><ul><li>  Z (cero, cero) toma el valor 1 cuando el resultado es cero </li><li>  S (signo) toma el valor 1 cuando se da el bit 7 (el bit más significativo, el más significativo, MSB) del comando matemático </li><li>  P (paridad, paridad) se establece cuando el resultado es par y se restablece cuando es impar </li><li>  CY (carry) toma el valor 1 cuando, como resultado del comando, se realiza una transferencia o préstamo en un bit de orden superior </li><li>  AC (transporte auxiliar) se utiliza principalmente para las matemáticas BCD (decimal codificado en binario).  Para obtener más detalles, consulte el manual, en Space Invaders este indicador no se utiliza. </li></ul><br>  Los códigos de estado se usan en comandos de ramificación condicionales, por ejemplo, JZ realiza ramificaciones solo si se establece la bandera Z. <br><br>  La mayoría de las instrucciones tienen tres formas: para registros, para valores inmediatos y para memoria.  Implementemos algunas instrucciones para comprender sus formularios y ver cómo es trabajar con códigos de estado.  (Tenga en cuenta que no implemento el indicador de transferencia auxiliar porque no se usa. Si lo implementé, no podría probarlo). <br><br><h4>  Formulario de registro </h4><br>  Aquí hay un ejemplo de implementación de dos instrucciones con un formulario de registro;  en el primero, implementé el código para que su trabajo sea más fácil de entender, y en el segundo, se presenta una forma más compacta que hace lo mismo. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADD B { //      , //      uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) state-&gt;b; //  :    , //    , //      if ((answer &amp; 0xff) == 0) state-&gt;cc.z = 1; else state-&gt;cc.z = 0; //  :   7 , //    , //      if (answer &amp; 0x80) state-&gt;cc.s = 1; else state-&gt;cc.s = 0; //   if (answer &gt; 0xff) state-&gt;cc.cy = 1; else state-&gt;cc.cy = 0; //    state-&gt;cc.p = Parity( answer &amp; 0xff); state-&gt;a = answer &amp; 0xff; } //  ADD     case 0x81: //ADD C { uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) state-&gt;c; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br>  Emulo comandos matemáticos de 8 bits con un número de 16 bits.  Esto facilita el seguimiento de los casos en que los cálculos generan un acarreo. <br><br><h4>  Formulario para valores inmediatos </h4><br>  La forma de los valores inmediatos es casi la misma, excepto que el byte después del comando es la fuente del agregado.  Como "opcode" es un puntero al comando actual en la memoria, opcode [1] será inmediatamente el siguiente byte. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xC6</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADI  { uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) opcode[1]; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br><h4>  Forma para la memoria </h4><br>  En el formulario para memoria, se agregará un byte al que indica la dirección almacenada en un par de registros HL. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x86</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADD M { uint16_t offset = (state-&gt;h&lt;&lt;8) | (state-&gt;l); uint16_t answer = (uint16_t) state-&gt;a + state-&gt;memory[offset]; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br><h3>  Notas </h3><br>  Las instrucciones aritméticas restantes se implementan de manera similar.  Adiciones: <br><br><ul><li>  En diferentes versiones con carry (ADC, ACI, SBB, SUI), de acuerdo con el manual de referencia, utilizamos bits de carry en los cálculos. </li><li>  INX y DCX afectan a los pares de registros; estos comandos no afectan a las banderas. </li><li>  DAD es otro comando de un par de registros, solo afecta a la bandera de acarreo </li><li>  INR y DCR no afectan la bandera de acarreo </li></ul><br><h1>  Grupo de sucursal </h1><br>  Después de tratar con los códigos de estado, el grupo de sucursales se volverá lo suficientemente claro para usted.  Hay dos tipos de ramificación: transiciones (JMP) y llamadas (CALL).  JMP simplemente establece la PC en el valor del destino del salto.  CALL se usa para rutinas, escribe la dirección de retorno en la pila y luego asigna a la PC la dirección de destino.  RET regresa de CALL, recibe la dirección de la pila y la escribe en la PC. <br><br>  Tanto JMP como CALL solo van a direcciones absolutas que están codificadas en bytes después del código de operación. <br><br><h3>  Jmp </h3><br>  El comando JMP se ramifica incondicionalmente a la dirección de destino.  También hay comandos de ramificación condicionales para todos los códigos de estado (excepto para AC): <br><br><ul><li>  JNZ y JZ para cero </li><li>  JNC y JC para migración </li><li>  JPO y JPE por paridad </li><li>  JP (más) y JM (menos) para el signo </li></ul><br>  Aquí hay una implementación de algunos de ellos: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xc2</span></span>: <span class="hljs-comment"><span class="hljs-comment">//JNZ  if (0 == state-&gt;cc.z) state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; else //    state-&gt;pc += 2; break; case 0xc3: //JMP  state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; break;</span></span></code> </pre> <br><h3>  LLAME Y RETIRE </h3><br>  CALL empuja la dirección de la instrucción en la pila después de la llamada y luego salta a la dirección de destino.  RET recibe la dirección de la pila y la guarda en la PC.  Existen versiones condicionales de CALL y RET para todos los estados. <br><br><ul><li>  CZ, CNZ, RZ, RNZ para cero </li><li>  CNC, CC, RNC, RC para transferencia </li><li>  CPO, CPE, RPO, RPE para paridad </li><li>  CP, CM, RP, RM para firmar </li></ul><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xcd</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CALL  { uint16_t ret = state-&gt;pc+2; state-&gt;memory[state-&gt;sp-1] = (ret &gt;&gt; 8) &amp; 0xff; state-&gt;memory[state-&gt;sp-2] = (ret &amp; 0xff); state-&gt;sp = state-&gt;sp - 2; state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; } break; case 0xc9: //RET state-&gt;pc = state-&gt;memory[state-&gt;sp] | (state-&gt;memory[state-&gt;sp+1] &lt;&lt; 8); state-&gt;sp += 2; break;</span></span></code> </pre> <br><h3>  Notas </h3><br><ul><li>  El comando PCHL salta incondicionalmente a una dirección en un par de registros HL. </li><li>  No incluí el RST discutido anteriormente en este grupo.  Escribe la dirección de retorno en la pila y luego salta a la dirección predefinida en la parte inferior de la memoria. </li></ul><br><h1>  Grupo lógico </h1><br>  Este grupo realiza operaciones lógicas (consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera publicación del</a> tutorial).  Por su naturaleza, son similares a un grupo aritmético en que la mayoría de las operaciones funcionan con el registro A (unidad), y la mayoría de las operaciones afectan a las banderas.  Todas las operaciones se realizan en valores de 8 bits, en este grupo no hay comandos que afecten a pares de registros. <br><br><h3>  Operaciones booleanas </h3><br>  AND, OR, NOT (CMP) y "exclusivo o" (XOR) se denominan operaciones booleanas.  OR y AND expliqué anteriormente.  El comando NOT (para el procesador 8080 se llama CMA, o acumulador de complemento) simplemente cambia los valores de bits: todas las unidades se convierten en ceros y los ceros se convierten en unos. <br><br>  Percibo a XOR como un "reconocedor de diferencia".  Su tabla de verdad se ve así: <br><br><table><tbody><tr><td>  x </td><td>  y </td><td>  Resultado </td></tr><tr><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td></tr><tr><td>  0 0 </td><td>  1 </td><td>  1 </td></tr><tr><td>  1 </td><td>  0 0 </td><td>  1 </td></tr><tr><td>  1 </td><td>  1 </td><td>  0 0 </td></tr></tbody></table><br>  AND, OR y XOR tienen una forma para registros, memoria y valores inmediatos.  (CMP solo tiene un comando que distingue entre mayúsculas y minúsculas).  Aquí hay una implementación de un par de códigos de operación: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x2F</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CMA (not) state-&gt;a = ~state-&gt;a //  ,  CMA     break; case 0xe6: //ANI  { uint8_t x = state-&gt;a &amp; opcode[1]; state-&gt;cc.z = (x == 0); state-&gt;cc.s = (0x80 == (x &amp; 0x80)); state-&gt;cc.p = parity(x, 8); state-&gt;cc.cy = 0; //  ,  ANI  CY state-&gt;a = x; state-&gt;pc++; //   } break;</span></span></code> </pre> <br><h3>  Comandos de desplazamiento cíclico </h3><br>  Estos comandos cambian el orden de los bits en los registros.  Un desplazamiento hacia la derecha los mueve un bit hacia la derecha y un desplazamiento hacia la izquierda, un bit hacia la izquierda: <br><br> <code>  (0b00010000) = 0b00001000</code> <br> <br> <code>  (0b00000001) = 0b00000010</code> <br> <br>  Parecen no tener valor, pero en realidad esto no es así.  Se pueden usar para multiplicar y dividir por potencias de dos.  Tome el desplazamiento a la izquierda como ejemplo.  <code>0b00000001</code> es decimal 1, y desplazarlo hacia la izquierda lo convierte en <code>0b00000010</code> , es decir, decimal 2. Si realizamos otro desplazamiento hacia la izquierda, obtenemos <code>0b00000100</code> , que es 4. Otro desplazamiento hacia la izquierda, y lo multiplicamos por 8. Esto funcionará con cualquier por números: 5 ( <code>0b00000101</code> ) cuando se desplaza hacia la izquierda da 10 ( <code>0b00001010</code> ).  Otro desplazamiento a la izquierda da 20 ( <code>0b00010100</code> ).  Un cambio a la derecha hace lo mismo, pero para la división. <br><br>  El 8080 no tiene un comando de multiplicación, pero se puede implementar con estos comandos.  Si comprende cómo hacer esto, recibirá puntos de bonificación.  Una vez me hicieron esa pregunta en una entrevista.  (Lo hice, aunque me tomó unos minutos). <br><br>  Estos comandos rotan el disco cíclicamente y solo afectan la bandera de acarreo.  Aquí hay un par de comandos: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x0f</span></span>: <span class="hljs-comment"><span class="hljs-comment">//RRC { uint8_t x = state-&gt;a; state-&gt;a = ((x &amp; 1) &lt;&lt; 7) | (x &gt;&gt; 1); state-&gt;cc.cy = (1 == (x&amp;1)); } break; case 0x1f: //RAR { uint8_t x = state-&gt;a; state-&gt;a = (state-&gt;cc.cy &lt;&lt; 7) | (x &gt;&gt; 1); state-&gt;cc.cy = (1 == (x&amp;1)); } break;</span></span></code> </pre> <br><h3>  Comparación </h3><br>  La tarea de CMP y CPI es solo establecer marcas (para ramificación).  Lo hacen restando banderas, pero no almacenando el resultado. <br><br><ul><li>  Igualmente: si dos números son iguales, entonces se establece la bandera Z, ya que su resta entre sí da cero. </li><li>  Mayor que: si A es mayor que el valor que se está comparando, entonces el indicador CY se borra (ya que la sustracción se puede hacer sin pedir prestado). </li><li>  Menor: si A es menor que el valor comparado, se establece el indicador CY (porque A debe completar el préstamo para completar la resta). </li></ul><br>  Hay versiones de estos comandos para registros, memoria y valores inmediatos.  La implementación es una simple resta sin guardar el resultado: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xfe</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CPI  { uint8_t x = state-&gt;a - opcode[1]; state-&gt;cc.z = (x == 0); state-&gt;cc.s = (0x80 == (x &amp; 0x80)); //  ,    p -   state-&gt;cc.p = parity(x, 8); state-&gt;cc.cy = (state-&gt;a &lt; opcode[1]); state-&gt;pc++; } break;</span></span></code> </pre> <br><h3>  CMC y STC </h3><br>  Completan el grupo lógico.  Se utilizan para establecer y borrar la bandera de transporte. <br><br><h1>  Grupo de entrada-salida y comandos especiales. </h1><br>  Estos comandos no pueden asignarse a ninguna otra categoría.  Los mencionaré para completar, pero me parece que tendremos que volver a ellos cuando comencemos a emular el hardware de Space Invaders. <br><br><ul><li>  EI y DI habilitan o deshabilitan la capacidad del procesador para manejar las interrupciones.  Agregué el indicador interrupt_enabled a la estructura de estado del procesador y lo configuré / reinicié usando estos comandos. </li><li>  Parece que RIM y SIM se utilizan principalmente para E / S en serie.  Si está interesado, puede leer el manual, pero estos comandos no se utilizan en Space Invaders.  No los emularé. </li><li>  HLT es una parada.  No creo que debamos emularlo, pero puede llamar a su código para salir (o salir (0)) cuando vea este comando. </li><li>  IN y OUT son comandos que el equipo procesador 8080 usa para comunicarse con equipos externos.  Mientras los estamos implementando, no harán nada más que saltear su byte de datos.  (Más tarde volveremos a ellos). </li><li>  NOP es "sin operación".  Una aplicación de NOP es controlar la sincronización del panel (se requieren cuatro ciclos de CPU para ejecutarse). </li></ul><br>  Otra aplicación de NOP es la modificación del código.  Digamos que necesitamos cambiar el código ROM del juego.  No podemos simplemente eliminar códigos de operación innecesarios, porque no queremos cambiar todos los comandos CALL y JMP (serán incorrectos si al menos una parte del código se mueve).  Con NOP podemos deshacernos del código.  <em>¡Agregar código es mucho más difícil!</em>  <em>Puede agregarlo buscando espacio en algún lugar de la ROM y cambiando el comando a JMP.</em> <br><br><h1>  Grupo de pila </h1><br>  Ya hemos completado la mecánica para la mayoría de los equipos en el grupo de pila.  Si hiciste el trabajo conmigo, entonces estos comandos serán fáciles de implementar. <br><br><h3>  EMPUJE y POP </h3><br>  PUSH y POP solo funcionan con pares de registros.  PUSH escribe un par de registros en la pila, y POP toma 2 bytes de la parte superior de la pila y los escribe en un par de registros. <br><br>  Hay cuatro códigos de operación para PUSH y POP, uno para cada uno de los pares: BC, DE, HL y PSW.  PSW es ​​un par especial de registros de banderas de unidades y códigos de estado.  Aquí está mi implementación de PUSH y POP para BC y PSW.  No hay comentarios en él, no creo que haya nada particularmente complicado aquí. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xc1</span></span>: <span class="hljs-comment"><span class="hljs-comment">//POP B { state-&gt;c = state-&gt;memory[state-&gt;sp]; state-&gt;b = state-&gt;memory[state-&gt;sp+1]; state-&gt;sp += 2; } break; case 0xc5: //PUSH B { state-&gt;memory[state-&gt;sp-1] = state-&gt;b; state-&gt;memory[state-&gt;sp-2] = state-&gt;c; state-&gt;sp = state-&gt;sp - 2; } break; case 0xf1: //POP PSW { state-&gt;a = state-&gt;memory[state-&gt;sp+1]; uint8_t psw = state-&gt;memory[state-&gt;sp]; state-&gt;cc.z = (0x01 == (psw &amp; 0x01)); state-&gt;cc.s = (0x02 == (psw &amp; 0x02)); state-&gt;cc.p = (0x04 == (psw &amp; 0x04)); state-&gt;cc.cy = (0x05 == (psw &amp; 0x08)); state-&gt;cc.ac = (0x10 == (psw &amp; 0x10)); state-&gt;sp += 2; } break; case 0xf5: //PUSH PSW { state-&gt;memory[state-&gt;sp-1] = state-&gt;a; uint8_t psw = (state-&gt;cc.z | state-&gt;cc.s &lt;&lt; 1 | state-&gt;cc.p &lt;&lt; 2 | state-&gt;cc.cy &lt;&lt; 3 | state-&gt;cc.ac &lt;&lt; 4 ); state-&gt;memory[state-&gt;sp-2] = psw; state-&gt;sp = state-&gt;sp - 2; } break;</span></span></code> </pre> <br><h3>  SPHL y XTHL </h3><br>  Hay dos equipos más en el grupo de pila: SPHL y XTHL. <br><br><ul><li>  <code>SPHL</code> mueve HL a SP (obligando a SP a obtener una nueva dirección). </li><li>  <code>XTHL</code> intercambia lo que está encima de la pila con lo que hay en un par de registros HL.  ¿Por qué necesitarías hacer esto?  No lo se </li></ul><br><h1>  Un poco más sobre los números binarios. </h1><br>  Al escribir un programa de computadora, una de las decisiones que debe tomar es elegir el tipo de datos utilizados para los números, si desea que sean negativos y cuál debería ser su tamaño máximo.  Para el emulador de CPU, necesitamos que el tipo de datos coincida con el tipo de datos de la CPU de destino. <br><br><h3>  Firmado y sin firmar </h3><br>  Cuando comenzamos a hablar de números hexadecimales, los consideramos sin signo, es decir, cada dígito binario del número hexadecimal tenía un valor positivo, y cada uno se consideraba una potencia de dos (unidades, dos, cuatro, etc.). <br><br>  Nos ocupamos del problema del almacenamiento en la computadora de números negativos.  Si sabe que los datos en cuestión tienen un signo, es decir, pueden ser negativos, entonces puede reconocer un número negativo por el bit más significativo del número (bit más significativo, MSB).  Si el tamaño de los datos es de un byte, cada número con un valor de bit MSB dado es negativo, y cada uno con un MSB cero es positivo. <br><br>  El valor de un número negativo se almacena como un código adicional.  Si tenemos un número con signo, y el MSB es igual a uno, y queremos saber cuál es este número, entonces podemos convertirlo de la siguiente manera: realice el "NO" binario para los números hexadecimales y luego agregue uno. <br><br>  Por ejemplo, para un número hexadecimal 0x80, se establece el bit MSB, es decir, es negativo.  El "NO" binario del número 0x80 es 0x7f, o decimal 127. 127 + 1 = 128. Es decir, 0x80 en decimal es -128.  Segundo ejemplo: 0xC5.  No (0xC5) = 0x3A = decimal 58 +1 = decimal 59. Es decir, 0xC5 es decimal -59. <br><br>  Lo sorprendente de los números con código adicional es que podemos realizar cálculos con ellos como con números sin signo, y <em>seguirán funcionando</em> .  La computadora no necesita hacer nada especial con signos.  Mostraré un par de ejemplos que prueban esto. <br><br><pre>  Ejemplo 1<font></font>
<font></font>
      decimal hexadecimal binario    
       -3 0xFD 1111 1101    
    + 10 0x0A +0000 1010    
    ----- -----------    
        7 0x07 1 0000 0111    
                        ^ Esto se registra en el bit de acarreo<font></font>
<font></font>
    Ejemplo 2    <font></font>
<font></font>
      decimal hexadecimal binario    
      -59 0xC5 1100 0101    
    + 33 0x21 +0010 0001    
    ----- -----------    
      -26 0xE6 1110 0110 </pre><br><br>  En el Ejemplo 1, vemos que sumar 10 y -3 da como resultado 7. El resultado de la suma se transfirió, por lo que se puede establecer el indicador C. En el Ejemplo 2, el resultado de la suma fue negativo, por lo que decodificamos esto: No (0xE6) = 0x19 = 25 + 1 = 26. <code>0xE6 = -26</code> Explosión del cerebro! <br><br>  Si lo desea, lea más sobre el código adicional en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wikipedia</a> . <br><br><h3>  Tipos de datos </h3><br>  En C, existe una relación entre los tipos de datos y el número de bytes utilizados para este tipo.  De hecho, solo nos interesan los enteros.  Los tipos de datos C estándar / de la vieja escuela son char, int y long, así como sus amigos unsigned char, unsigned int y unsigned long.  El problema es que en diferentes plataformas y en diferentes compiladores, estos tipos pueden tener diferentes tamaños. <br><br>  Por lo tanto, es mejor seleccionar un tipo de datos para nuestra plataforma que declare explícitamente el tamaño de los datos.  Si su plataforma tiene stdint.h, puede usar int8_t, uint8_t, etc. <br><br>  El tamaño de un número entero determina el número máximo que se puede almacenar en él.  En el caso de enteros sin signo, puede almacenar números de 0 a 255 en 8 bits. Si traduce a hexadecimal, entonces es de 0x00 a 0xFF.  Dado que 0xFF tiene "todos los bits establecidos", y corresponde al decimal 255, es completamente lógico que el intervalo de un entero sin signo de un solo byte sea 0-255.  Los intervalos nos dicen que todos los tamaños de enteros funcionarán exactamente igual: los números corresponden al número que se obtiene cuando se establecen todos los bits. <br><br><table><tbody><tr><th>  Tipo </th><th>  Intervalo </th><th>  Maleficio </th></tr><tr><td>  8 bits sin signo </td><td>  0-255 </td><td>  0x0-0xFF </td></tr><tr><td>  8 bits firmado </td><td>  -128-127 </td><td>  0x80-0x7F </td></tr><tr><td>  16 bits sin signo </td><td>  0-65535 </td><td>  0x0-0xFFFF </td></tr><tr><td>  16 bits firmado </td><td>  -32768-32767 </td><td>  0x8000-0x7FFF </td></tr><tr><td>  32 bits sin signo </td><td>  0-4294967295 </td><td>  0x0-0xFFFFFFFFFF </td></tr><tr><td>  32 bits firmado </td><td>  -2147483648-2147483647 </td><td>  0x80000000-0x7FFFFFFF </td></tr></tbody></table><br>  Aún más interesante es que -1 en cada tipo de datos con signo es un número que tiene todos los bits establecidos (0xFF para el byte con signo, 0xFFFF para el número de 16 bits con signo y 0xFFFFFFFF para el número de 32 bits con signo).  Si los datos se consideran sin signo, entonces para todos los bits dados, se obtiene el número máximo posible para este tipo de datos. <br><br>  Para emular registros de procesador, seleccionamos el tipo de datos correspondiente al tamaño de este registro.  Probablemente valga la pena seleccionar tipos sin firmar de forma predeterminada y convertirlos cuando necesite considerarlos firmados.  Por ejemplo, usamos el tipo de datos uint8_t para representar un registro de 8 bits. <br><br><h3>  Sugerencia: use un depurador para convertir tipos de datos </h3><br>  Si gdb está instalado en su plataforma, entonces es muy conveniente usarlo para trabajar con números binarios.  A continuación, mostraré un ejemplo: en la sesión que se muestra a continuación, las líneas que comienzan con # son comentarios que agregué más adelante. <br><br> <code>#  /c,   gdb      <br> (gdb) print /c 0xFD <br> $1 = -3 '?' <br> <br> #  /x,   gdb    hex <br> #   "p"  "print" <br> (gdb) p /c 0xA <br> $2 = 10 '\n' <br> <br> #    2  " " <br> (gdb) p /c 0xC5 <br> $3 = -59 '?' <br> (gdb) p /c 0xC5+0x21 <br> $4 = -26 '?' <br> <br> #  print  ,  gdb    <br> (gdb) p 0x21 <br> $9 = 33 <br> <br> #     ,     gdb, <br> #  ,      <br> (gdb) p 0xc5 <br> $5 = 197 # <br> (gdb) p /c 0xc5 <br> $3 = -59 '?' # <br> (gdb) p 0xfd <br> $6 = 253 <br> <br> #        (   32- ) <br> (gdb) p /x -3 <br> $7 = 0xfffffffd <br> <br> #   1     <br> (gdb) print (char) 0xff <br> $1 = -1 '?' <br> #   1     <br> (gdb) print (unsigned char) 0xff <br> $2 = 255 '?'</code> <br> <br>  Cuando trabajo con números hexadecimales, siempre lo hago en gdb, y sucede casi todos los días.  Mucho más fácil que abrir la calculadora de un programador con una GUI.  En máquinas Linux (y Mac OS X), para iniciar una sesión de gdb, simplemente abra un terminal e ingrese "gdb".  Si usa Xcode en OS X, luego de iniciar el programa, puede usar la consola dentro de Xcode (en la que se imprime la salida de printf).  En Windows, el depurador gdb está disponible en Cygwin. <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terminación del emulador de CPU </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habiendo recibido toda esta información, estás listo para un largo viaje. </font><font style="vertical-align: inherit;">Debes decidir cómo implementar el emulador: crear una emulación 8080 completa o implementar solo los comandos necesarios para completar el juego. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si decide hacer una emulación completa, necesitará algunas herramientas más. </font><font style="vertical-align: inherit;">Hablaré de ellos en la siguiente sección. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otra forma es emular solo las instrucciones utilizadas por el juego. </font><font style="vertical-align: inherit;">Continuaremos completando esa construcción de interruptor enorme que creamos en la sección Shell del emulador. </font><font style="vertical-align: inherit;">Repetiremos el siguiente proceso hasta que tengamos un solo comando no realizado:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inicie el emulador con ROM Space Invaders </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La llamada se </font></font><code>UnimplementedInstruction()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cierra si el comando no está listo</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Emula esta instrucción </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Goto 1 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo primero que hice al comenzar a escribir mi emulador fue agregar código de mi desensamblador. </font><font style="vertical-align: inherit;">Entonces pude generar un comando que debería ejecutarse de la siguiente manera:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emulate8080Op</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opcode = &amp;state-&gt;memory[state-&gt;pc]; Disassemble8080Op(state-&gt;memory, state-&gt;pc); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (*opcode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>: <span class="hljs-comment"><span class="hljs-comment">//NOP /* ... */ } /*    */ printf("\tC=%d,P=%d,S=%d,Z=%d\n", state-&gt;cc.cy, state-&gt;cc.p, state-&gt;cc.s, state-&gt;cc.z); printf("\tA $%02x B $%02x C $%02x D $%02x E $%02x H $%02x L $%02x SP %04x\n", state-&gt;a, state-&gt;b, state-&gt;c, state-&gt;d, state-&gt;e, state-&gt;h, state-&gt;l, state-&gt;sp); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">También agregué código al final para mostrar todos los registros y banderas de estado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buenas noticias: para profundizar en el programa para 50 mil equipos, solo necesitamos un subconjunto de los códigos de operación 8080. Incluso daré una lista de códigos de operación que deben implementarse:</font></font><br><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Opcode </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El equipo </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x00 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nop </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x01 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI B, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x05 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCR B </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x06 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI B, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x09 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Papá b </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0d </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCR C </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI C, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0f </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rrc </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x11 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI D, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x13 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inx d </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x19 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Papá d </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x1a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LDAX D </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x21 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI H, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x23 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inx h </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x26 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI H, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x29 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Papá h </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x31 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI SP, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x32 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> STA adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x36 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI M, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x3a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lda adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x3e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI A, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x56 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV D, M </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x5e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV E, M </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x66 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV H, M </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x6f </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV L, A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x77 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV M, A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, D </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7b </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, E </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7c </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, H </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, M </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xa7 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ANA A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xaf </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> XRA A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pop b </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jnz adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jmp adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PULSE B </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc6 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ADI D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc9 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ret </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xcd </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Llamar adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pop d </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> OUT D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PULSAR D </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pop h </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EMPUJE H </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe6 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ANI D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xeb </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Xchg </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xf1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> POP PSW </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xf5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EMPUJE PSW </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xfb </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ei </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xfe </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IPC D8 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estas son solo 50 instrucciones, y 10 de ellas son movimientos que se implementan trivialmente. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Depuración </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero tengo algunas malas noticias. </font><font style="vertical-align: inherit;">Su emulador seguramente no funcionará correctamente, y los errores en dicho código son muy difíciles de encontrar. </font><font style="vertical-align: inherit;">Si sabe qué comando se está comportando mal (por ejemplo, una transición o una llamada que va a un código sin sentido), puede intentar corregir el error examinando su código. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Además de examinar el código, hay otra forma de solucionar el problema: comparando su emulador con uno que funcione con seguridad. </font><font style="vertical-align: inherit;">Suponemos que otro emulador siempre funciona correctamente, y todas las diferencias son errores en su emulador. </font><font style="vertical-align: inherit;">Por ejemplo, puedes usar mi emulador. </font><font style="vertical-align: inherit;">Puede ejecutarlos manualmente en paralelo. </font><font style="vertical-align: inherit;">Puede ahorrar tiempo si integra mi código en su proyecto para obtener el siguiente proceso:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crea un estado para tu emulador </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crea un estado para el mío </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para el proximo equipo </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Llamar a tu emulador con tu estado </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Llamando a los míos con mi fortuna </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compara nuestros dos estados </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buscando errores en cualquier diferencia </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ir a 3 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otra forma es usar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este sitio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> manualmente </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este es un emulador de procesador Javascript 8080 que incluso incluye ROM Space Invaders. </font><font style="vertical-align: inherit;">Aquí está el proceso:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reinicie la emulación de Space Invaders haciendo clic en el botón Space Invaders </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Presione el botón "Ejecutar 1" para ejecutar el comando. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ejecutamos el siguiente comando en nuestro emulador </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compare el estado del procesador con el suyo </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si las condiciones coinciden, pase a 2 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si las condiciones no coinciden, entonces su emulación de instrucciones es errónea. </font><font style="vertical-align: inherit;">Corríjalo y luego comience nuevamente desde el paso 1.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al principio utilicé este método para depurar mi emulador 8080. No mentiré, el proceso puede ser largo. Como resultado, muchos de mis problemas resultaron ser errores tipográficos y de copiar y pegar, que después de la detección fueron muy fáciles de solucionar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si ejecuta su código paso a paso, la mayoría de las primeras 30 mil instrucciones se ejecutan en un ciclo de aproximadamente $ 1a5f. Si observa </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">javascript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">emulador</font></a><font style="vertical-align: inherit;"> , puede ver que este código copia datos en la pantalla. Estoy seguro de que este código se llama con frecuencia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Después de la primera representación de la pantalla, después de 50 mil comandos, el programa se atasca en este ciclo sin fin:</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-number"><span class="hljs-number">0</span></span>ada LDA <span class="hljs-meta"><span class="hljs-meta">$20</span></span>c0 <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ANA A <span class="hljs-number"><span class="hljs-number">0</span></span>ade JNZ <span class="hljs-meta"><span class="hljs-meta">$0</span></span>ada</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espera hasta que el valor en la memoria a $ 20c0 cambie a cero. </font><font style="vertical-align: inherit;">Dado que el código en este bucle no cambia exactamente $ 20c0, debe ser una señal de otro lugar. </font><font style="vertical-align: inherit;">Es hora de hablar sobre emular el "hierro" de una máquina arcade. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de pasar a la siguiente sección, asegúrese de que su emulador de CPU se encuentre en este ciclo sin fin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para referencia, vea </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mis fuentes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Emulación 8080 completa </font></font></h1><br> ,   :   ,    .        .     ,     .         ,     . <br><br>     ,       8080     .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  8080</a>   cpudiag.asm,       8080. <br><br>           : <br><br><ol><li>  ,          .  ,   cpudiag.asm    . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como puede ver, el proceso es bastante laborioso. </font><font style="vertical-align: inherit;">Creo que un novato en la depuración del código del ensamblador experimentará grandes dificultades si estos pasos no se enumeran.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Así es como usé esta prueba con mi emulador. </font><font style="vertical-align: inherit;">Puede usarlo o encontrar una mejor manera de integrarlo.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conjunto de prueba </font></font></h3><br>    ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> .    cpudiag.asm   ,     .   ,  ,   ,     «Make Beautiful Code»  ,      test.bin,    8080.     ,   . <br><br> <a href=""> cpudiag.asm</a>     . <br><br> <a href=""> cpudiag.bin</a> (  8080)   . <br><br><h3>      </h3><br>    invaders.*     . <br><br>    . -,       <code>ORG 00100H</code> ,   ,      ,       0x100 hex.         8080,   ,    .    ,  ,          ,     0x100. <br><br> -,      ,           .       hex- <code>JMP $0100</code> ,    . (     PC   0x100.) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En tercer lugar, encontré un error en el código compilado. </font><font style="vertical-align: inherit;">Creo que la razón es el procesamiento incorrecto de la última línea de código </font></font><code>STACK EQU TEMPP+256</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero no estoy seguro. </font><font style="vertical-align: inherit;">Sea como fuere, la pila durante la compilación se ubicó en $ 6ad, y los primeros PUSH comenzaron a reescribir el código. </font><font style="vertical-align: inherit;">Sugerí que la variable también debería estar compensada por 0x100, como el resto del código, así que lo arreglé insertando "0x7" en la línea de código que inicializa el puntero de la pila. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, dado que no implementé DAA o la migración auxiliar en mi emulador, modifico el código para omitir esta verificación (simplemente la omitimos usando JMP).</font></font><br><br><pre> <code class="cpp hljs"> ReadFileIntoMemoryAt(state, <span class="hljs-string"><span class="hljs-string">"/Users/kpmiller/Desktop/invaders/cpudiag.bin"</span></span>, <span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ,   JMP 0x100 state-&gt;memory[0]=0xc3; state-&gt;memory[1]=0; state-&gt;memory[2]=0x01; //Fix the stack pointer from 0x6ad to 0x7ad // this 0x06 byte 112 in the code, which is // byte 112 + 0x100 = 368 in memory state-&gt;memory[368] = 0x7; //  DAA state-&gt;memory[0x59c] = 0xc3; //JMP state-&gt;memory[0x59d] = 0xc2; state-&gt;memory[0x59e] = 0x05;</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La prueba está tratando de llegar a una conclusión. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, esta prueba se basa en la ayuda del sistema operativo CP / M. Descubrí que CP / M tiene un código de $ 0005 que imprime mensajes en la consola, y cambié mi emulación CALL para manejar este comportamiento. No estoy seguro de si todo salió bien, pero funcionó para los dos mensajes que el programa está tratando de imprimir. Mi emulación CALL para ejecutar esta prueba se ve así:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xcd</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CALL  #ifdef FOR_CPUDIAG if (5 == ((opcode[2] &lt;&lt; 8) | opcode[1])) { if (state-&gt;c == 9) { uint16_t offset = (state-&gt;d&lt;&lt;8) | (state-&gt;e); char *str = &amp;state-&gt;memory[offset+3]; // - while (*str != '$') printf("%c", *str++); printf("\n"); } else if (state-&gt;c == 2) { //    ,   ,    printf ("print char routine called\n"); } } else if (0 == ((opcode[2] &lt;&lt; 8) | opcode[1])) { exit(0); } else #endif { uint16_t ret = state-&gt;pc+2; state-&gt;memory[state-&gt;sp-1] = (ret &gt;&gt; 8) &amp; 0xff; state-&gt;memory[state-&gt;sp-2] = (ret &amp; 0xff); state-&gt;sp = state-&gt;sp - 2; state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; } break;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con esta prueba, encontré varios problemas en mi emulador. No estoy seguro de cuál de ellos estaría involucrado en el juego, pero si lo estuvieran, sería muy difícil encontrarlos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seguí adelante e implementé todos los códigos de operación (con la excepción de DAA y sus amigos). Me llevó 3-4 horas solucionar problemas en mis desafíos e implementar otros nuevos. Definitivamente fue más rápido que el proceso manual que describí anteriormente: antes de encontrar esta prueba, pasé más de 4 horas en el proceso manual. Si puede encontrar esta explicación, le recomiendo usar este método en lugar de compararlo manualmente. Sin embargo, conocer el proceso manual también es una gran habilidad, y si desea emular otro procesador, entonces debe volver a él.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si no puede realizar este proceso o parece demasiado complicado, definitivamente vale la pena elegir el enfoque descrito anteriormente con dos emuladores diferentes que se ejecutan dentro de su programa. </font><font style="vertical-align: inherit;">Cuando aparecen varios millones de comandos en el programa y se agregan interrupciones, será imposible comparar manualmente dos emuladores.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418699/">https://habr.com/ru/post/es418699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418687/index.html">Revolución de 3.5 ": detalles de un pequeño boom de disquetes con vapores</a></li>
<li><a href="../es418689/index.html">Cómo crear bibliotecas de componentes en Figma, ahorrando un presupuesto, usando el ejemplo de una subasta en línea</a></li>
<li><a href="../es418691/index.html">Ganadero: Kubernetes en 5 minutos sobre metal desnudo.</a></li>
<li><a href="../es418693/index.html">¿Por qué es tan difícil detectar la felicidad en el cerebro?</a></li>
<li><a href="../es418695/index.html">Guerras contra la piratería: el imperio contraataca</a></li>
<li><a href="../es418701/index.html">Estudiamos analizadores sintácticos para el idioma ruso</a></li>
<li><a href="../es418705/index.html">Fundamentos de Futex</a></li>
<li><a href="../es418707/index.html">KDispatcher: bus de eventos ligero y conveniente para el uso diario</a></li>
<li><a href="../es418709/index.html">Necesidad de forzarse: controladores y barreras de interfaz</a></li>
<li><a href="../es418711/index.html">Token Managed Registers 1.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>