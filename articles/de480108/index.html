<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è≥ üòÄ ‚ôäÔ∏è Physik in einem Unity-Projekt am Beispiel des Mobile Fighting üëΩ üåü üßëüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Physik ist zu einem festen Bestandteil jedes modernen Spiels geworden. Egal, ob es sich um eine einfache Gewebesimulation oder eine vollwertige Ve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Physik in einem Unity-Projekt am Beispiel des Mobile Fighting</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/banzai/blog/480108/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/b_/ey/um/b_eyummqzvcslojzhc6pvvkgqn4.gif"></div><br>  Die Physik ist zu einem festen Bestandteil jedes modernen Spiels geworden.  Egal, ob es sich um eine einfache Gewebesimulation oder eine vollwertige Verkehrsphysik handelt.  Handyspiele sind keine Ausnahme.  Wenn Sie jedoch die Physik f√ºr sie einrichten, m√ºssen Sie auf die Einschr√§nkungen zur√ºckblicken, die mit der relativ schlechten Leistung der unterst√ºtzten Ger√§te der √§lteren Generation verbunden sind.  Der f√ºhrende technische 3D-K√ºnstler <a href="https://banzai.games/">Banzai.Games</a> Roman Tersky berichtete, wie sein Team die Physik in das Gameplay des mobilen Kampfspiels Shadow Fight 3 integriert hat, welche Techniken f√ºr die Optimierung verwendet wurden und wie er die Physik f√ºr Charaktere von Grund auf neu schrieb, um ihren vollst√§ndigen Determinismus in synchronem PVP zu erreichen. <br><a name="habracut"></a><br><h3>  Festk√∂rperphysik </h3><br><img src="https://habrastorage.org/webt/8c/ja/r7/8cjar7zihv322c1ld3p_t6q214w.gif"><br><br>  Die Ausr√ºstung der Charaktere in Shadow Fight 3 besteht aus vielen Elementen, die einer physikalischen Simulation unterliegen, die dem Geschehen auf dem Bildschirm Dynamik verleiht.  Eine der Hauptschwierigkeiten, auf die wir bei der Einrichtung der Physik f√ºr diese Elemente gesto√üen sind, ist die Tatsache, dass sich die Knochen, an die sie gebunden sind, innerhalb der Hierarchie des Skeletts der Figur selbst befinden.  Beim Bewegen wiederholen sie die Transformation der Elternknochen und erhalten keinen physikalisch realistischen Impuls. <br><br><h3>  Knochendetektor </h3><br>  Die einfachste L√∂sung war eine Knochenabl√∂sung.  Nachdem alle Ausstattungselemente mithilfe eines Skripts initialisiert wurden, entfernen wir die Knochen der physisch aktiven Elemente aus der Hierarchie des Charakterskeletts und stellen mit der Zeichenverbindungskomponente eine Verbindung mit dem √ºbergeordneten Knochen her. <br><br><img src="https://habrastorage.org/webt/n7/up/n-/n7upn-3csflipqe49vakr_dbty4.png"><br><br>  Wir hatten jedoch einen kleinen Fehler, der sich aus dem fps-Drawdown ergab: In diesem Fall ‚Äûholt‚Äú ein Knochen, der einer physikalischen Simulation unterzogen wurde, mit einer leichten Verz√∂gerung den Knochen ein, mit dem das Gelenk verbunden ist.  Dieser Fehler ist in der Regel so gering, dass er vernachl√§ssigt werden kann.  In anderen F√§llen wurde eine alternative L√∂sung angewendet. <br><br><h3>  Gef√§lschter Impuls </h3><br>  Betrachten Sie diese L√∂sung am Beispiel eines Marodeur-Helms, dessen spartanisches Wappen einer physikalischen Simulation unterzogen wird.  Wir teilten den Kamm in 5 Teile, von denen jeder auf verschiedene Knochen geh√§utet wurde.  In den Gelenkeinstellungen dieser Knochen legen Sie die Grenzen f√ºr die Drehung entlang der gew√ºnschten Achse fest und legen den Parameter <b>Twist Limit Spring fest</b> , der f√ºr den Federeffekt verantwortlich ist. <br><br><img src="https://habrastorage.org/webt/-9/ha/b4/-9hab404oqtlgoi4bgaynjfdf_g.png"><br><br>  F√ºr eine physikalisch realistische Simulation wurden die Kammknochen aus der Zeichenhierarchie herausgenommen. Im Falle eines fps-Drawdowns, zum Beispiel auf einem schwachen Ger√§t, wurde das Netz h√§sslich gedehnt, weil Knochen ‚Äûaufgeholt‚Äú wurden. <br><br><img src="https://habrastorage.org/webt/lk/xz/qs/lkxzqsmhn7v03d2ylne5m5hg1xs.gif"><br><br>  Aus diesem Grund haben wir beschlossen, die Kammknochen in der Charakterhierarchie zu belassen und ihre Dynamik zu erh√∂hen, um ihnen einen falschen Impuls zu geben.  Dazu mussten wir in jeder Animation (mit Ausnahme der Kampfhaltung) den Zeitpunkt bestimmen, an dem der Impuls angewendet werden soll, sowie die Richtung. <br><br>  Man k√∂nnte die Anzahl der Bilder in der aktuellen Animation lesen, dann 15-20 Bilder von diesem Wert abziehen und einen Impuls nach der empfangenen Differenz anwenden.  Wir haben es jedoch geschafft, unn√∂tige Arithmetik zu vermeiden, indem wir den Moment des Impulses mit dem Ende des <i>ununterbrochenen</i> Animationsintervalls verkn√ºpft haben. <br><br>  Jede Animation (wieder mit Ausnahme der Kampfhaltung) hat einen vorkonfigurierten Zeitraum, in dem der Spieler sie nicht unterbrechen kann.  Nach dieser Zeit oder zum Zeitpunkt des Eintreffens des Aufpralls beendet das <i>ununterbrochene</i> Intervall seine Wirkung und in diesem Moment wird unser Impuls ausgel√∂st.  Es mussten lediglich Ausnahmen f√ºr mehrere Animationen konfiguriert werden. <br><br><img src="https://habrastorage.org/webt/al/dp/_y/aldp_yji9besba4c8o41afwrzka.gif"><br><br>  Daher wird der Impuls vor dem Ende jeder Animation mehrere Frames lang ausgel√∂st, je nach Bedarf.  Zum Zeitpunkt der Pulsinitialisierung lesen wir die Koordinaten, in denen sich der Knochen im vorherigen und aktuellen Frame befand, und empfangen seinen Bewegungsvektor.  Auf diese Achse wird unser Impuls angewendet. <br><br><h3>  Ausr√ºstungsgegenst√§nde </h3><br>  Zur Optimierung versuchen wir, Collider so wenig wie m√∂glich zu verwenden, wenn wir die Physik f√ºr verschiedene Elemente der Ausr√ºstung von Charakteren simulieren.  In den meisten F√§llen erreichen wir dies, indem wir in den Gelenkeinstellungen der Bones, f√ºr die die Simulation durchgef√ºhrt wird, nur die Einschr√§nkungen entlang der Achsen bearbeiten. <br><br><img src="https://habrastorage.org/webt/xn/bw/ub/xnbwubqnvvxtzrlebwb_huqnxy8.gif"><img src="https://habrastorage.org/webt/yn/a-/ja/yna-javmxmnzvnuh-aswpfl-w3o.gif"><br><br>  In einigen F√§llen (zum Beispiel bei Metallplatten) ist die Verwendung von Kollidern unvermeidlich.  Die Hauptlast ist jedoch nicht das Vorhandensein von Kollisionen, sondern die Berechnung ihrer Kollisionen.  Die Feinabstimmung der <b>Ebenenkollisionsmatrix</b> in den <b>Projekteinstellungen tr√§gt</b> zur Minimierung dieser Belastung bei.  F√ºr solche Elemente verwenden wir zwei separate Ebenen, die nur untereinander kollidieren, wodurch die Fehleinsch√§tzung von Kollisionen mit Kollidern anderer Ebenen (Waffen, B√∂den, W√§nde usw.) vermieden wird. <br><br><img src="https://habrastorage.org/webt/lu/az/og/luazogouubyghoajmiapbikohc0.png"><br><br><h3>  Physischer Klon </h3><br>  Shadow Fight 3 verf√ºgt √ºber verschiedene Arten von Waffen, f√ºr die au√üerhalb von Angriffsanimationen eine physikalische Simulation verwendet wird.  Im Moment ist dies ein Messer an einer Kette, Kusarigama, Nunchaku und Dreschflegel.  Aus den oben beschriebenen Gr√ºnden haben wir beschlossen, die Knochen der Waffe aus der Charakterhierarchie au√üerhalb der angreifenden Animationen zu entfernen und sie zur√ºckzusenden, wenn keine physische Simulation erforderlich ist.  Durch Manipulieren des Parameters <b>Is Kinematic</b> in der <b>Rigidbody-</b> Komponente der Knochen schalten wir je nach Situation die Physik f√ºr sie ein und aus. <br><br>  Bei Verwendung von Kusarigama und einem Messer an der Kette stie√üen wir jedoch auf eine erh√∂hte Last bei schwachen Ger√§ten und bekamen einen fps-Verlust.  Das Problem trat genau dann auf, wenn die Knochen in die Hierarchie des Charakters zur√ºckkehrten und die physikalische Simulation f√ºr ihn ausgeschaltet wurde.  Dies liegt an der Tatsache, dass das √Ñndern der √ºbergeordneten Knochentransformationen in der <b>Skeletthierarchie</b> die Physik-Engine f√ºr jeden Tochterknochen belastet, f√ºr den eine <b>Rigidbody-</b> Komponente vorhanden ist, selbst wenn der Parameter <b>Is Kinematic</b> aktiv ist.  Und je l√§nger die Hierarchie ist, desto gr√∂√üer ist die Last. <br><br><img src="https://habrastorage.org/webt/te/tj/39/tetj39yfqebmxb4pkgv8-fztc14.gif"><br><br>  Die L√∂sung bestand darin, einen physischen Klon zu erstellen.  Betrachten Sie dies am Beispiel eines Messers an einer Kette. <br><br>  W√§hrend des Ladens des Kampfes werden 2 Skelette f√ºr ihn initialisiert: das Haupt-Skelett, das sich in der Hierarchie des Charakters befindet, und sein physischer Klon.  Es gibt keine <b>Rigidbody-</b> Komponente in den Bones des Hauptskeletts, nur Animationsspuren wirken sich auf deren Transformation aus.  Die Knochen des zweiten haben abgestimmte Verbindungen (Gelenke) und eine <b>Rigidbody-</b> Komponente mit dem aktiven Parameter Is Kinematic. <br><br>  W√§hrend die Transformation der Knochen des Hauptskeletts durch die Animationsspur beeinflusst wird, z. B. w√§hrend eines Treffers, bleibt der Parameter <b>Is Kinematic</b> in der <b>Rigidbody-</b> Komponente der Knochen des physischen Klons aktiv.  Knochen werden nicht transformiert und unterliegen keiner physikalischen Simulation.  W√§hrend des letzten Frames der Animation werden die Knochentransformationen der beiden Skelette synchronisiert.  Ein physischer Klon liest die Position und Rotation der Knochen des Hauptskeletts und legt genau dieselben Parameter fest.  Is Kinematic wird dann deaktiviert und die Knochen des physischen Klons werden simuliert.  Bis zum Beginn der n√§chsten angreifenden Animation, die bereits das Hauptskelett ist, liest jeder Frame die Transformationen der Knochen des physischen Klons, die sich in diesem Moment in der Physik bewegen, und setzt diese Parameter auf ihre Knochen.  Dieser Ansatz hat die Belastung der Physik-Engine erheblich verringert und die Leistung schwacher Ger√§te verbessert. <br><br><img src="https://habrastorage.org/webt/c-/zz/2w/c-zz2w_tz4ivlrqcwihofotgiqu.gif"><br><br><h3>  Gewebesimulation </h3><br>  Beim Einrichten der Gewebesimulation als Teil der Leistung mobiler Ger√§te besteht die Haupteinschr√§nkung in der Verwendung von Gewebekollisionen mit Kollidern.  Eine billigere Alternative ist die Feinabstimmung der <b>Oberfl√§chenpenetration</b> f√ºr Stoffkonstrate.  Da es in unserem Spiel viele Animationen und verschiedene Posen von Charakteren gibt, wurde eine Liste der "gef√§hrlichsten" zusammengestellt, bei der alle Gewebe auf das Eindringen in andere K√∂rperteile √ºberpr√ºft wurden. <br><br><img src="https://habrastorage.org/webt/lg/jo/fe/lgjofebnfacq_llzmywkkmuw5f0.png" width="228"><img src="https://habrastorage.org/webt/jc/su/mv/jcsumv5vumpaagaappctp5-4hcs.gif"><br><br>  Wir haben auch eine Gewebesimulation verwendet, um den FX-Flammeneffekt auf Waffen und den Kopf des Bosses Shadow Mind zu erzeugen.  In den <b>Stoffeinstellungen</b> f√ºr diese Elemente haben wir den Einfluss der Schwerkraft ausgeschaltet und die Beschleunigungswerte entlang der Y-Achse festgelegt: konstant, sodass sich die Flamme f√ºr den Flattereffekt nach oben und zuf√§llig bewegt.  Damit bei Bewegungen die Geometrie nicht stark verzerrt wird, setzen wir den erh√∂hten Widerstandswert ( <b>Damping</b> ).  Somit haben wir einen relativ realistischen und in Bezug auf Leistung g√ºnstigen Flammeneffekt erhalten. <br><br><img src="https://habrastorage.org/webt/tn/cn/zj/tncnzjmwecvndqkorcschfs_ufo.png"><br><br><img src="https://habrastorage.org/webt/ui/it/rp/uiitrpffrvxnjpa9tsvpdez9ano.gif"><br><br><h3>  Deterministische Physik f√ºr synchrones PvP </h3><br>  Zum Zeitpunkt des Todes und in bestimmten Situationen, wenn in Shadow Fight 3 Charaktere angegriffen werden, wird eine Simulation der Physik aktiviert.  Lange Zeit wurde hierf√ºr die Festk√∂rperphysik von Unity Stock verwendet.  Bei der Einf√ºhrung von synchronem PVP in das Projekt musste es jedoch zugunsten seiner eigenen Entwicklung aufgegeben werden. <br><br>  Synchrones PVP impliziert die gleiche Simulation eines Spiels auf zwei Clients.  Es gibt keine Probleme mit der Animation, da alles im Voraus berechnet wurde, w√§hrend bestimmte Probleme mit der Physik auftreten. <br><br>  Tatsache ist, dass Gleitkommaberechnungen, die in Unity in der Physik verwendet werden, auf Prozessoren verschiedener Hersteller unterschiedlich funktionieren.  In dieser Hinsicht h√§ufen sich w√§hrend des Spiels Fehler in der Position der Charaktere - auf einem Client befindet sich der Charakter anders als der andere.  Und wenn diese Diskrepanz au√üerhalb der Physik leicht durch periodisches Synchronisieren der Position auf der Grundlage von Indikatoren von einem der Clients korrigiert werden kann, dann entwickelt sich zum Zeitpunkt der Initialisierung der Physik aufgrund des Startfehlers der Position die physikalische Simulation auf zwei Clients unterschiedlich. <br><br>  Infolgedessen befindet sich der Charakter signifikant an verschiedenen Orten und an verschiedenen Positionen.  Nach einer solchen Diskrepanz tritt fr√ºher oder sp√§ter eine Situation auf, in der Angriffe auf einen Client und nicht auf den anderen Client aufgezeichnet werden. <br><br>  Die auf den ersten Blick einfachste L√∂sung besteht darin, die Position des Charakters auf einem Client zu erfassen und auf einen anderen zu √ºbertragen, w√§hrend sie w√§hrend einer physischen Simulation synchronisiert werden.  Das Regdoll des Charakters besteht jedoch aus einer langen Hierarchie von Knochen mit einer gro√üen Anzahl separater unabh√§ngiger K√∂rper (Gliedma√üen, Kopf), damit die Position, an der Sie eine gro√üe Datenmenge in kurzer Zeit √ºbertragen m√ºssen, korrekt synchronisiert werden kann.  Diese Option erwies sich als zu ‚Äûteuer‚Äú, sodass wir beschlossen, unsere eigene Physik zu schreiben, die deterministisch sein w√ºrde.  Damit wir sicher sein k√∂nnen, dass auf jedem Client die physischen Zust√§nde der Zeichen √ºbereinstimmen, unabh√§ngig davon, auf welchem ‚Äã‚ÄãProzessor die Berechnungen durchgef√ºhrt werden. <br><br><img src="https://habrastorage.org/webt/id/kp/uv/idkpuvdwccnghub-gt_i9zg7esq.png"><br><br>  Also, was ist unsere Regdoll?  Der K√∂rper besteht aus Knoten, die materielle Punkte sind. Sie haben keine Orientierung, aber es gibt eine Position und Masse, und zwischen ihnen werden Verbindungen mit einstellbarer Steifheit realisiert.  Eine Gruppe solcher Knoten ist mit jedem Knochen im Skelett des Charakters verbunden.  Diese Architektur impliziert das Fehlen von internen Kollisionen und Einschr√§nkungen in den Gelenken, und externe Kollisionen und Reibung werden auf Knotenebene implementiert.  Wenn sich Knoten im Raum bewegen, werden Schwerkraft, √§u√üere Kr√§fte und Tr√§gheit ber√ºcksichtigt. <br><br>  Zwischen Knoten gibt es zwei Arten von Verbindungen: <i>starre Rippen</i> (blau) und <i>elastische Muskeln</i> (rot).  Die Rippen spielen die Rolle von Knochen und zwingen die Knoten, in einem bestimmten Abstand voneinander zu sein, und verhindern, dass sie sich in verschiedene Richtungen zerstreuen.  Muskeln aus jeder Ausgangsposition bilden eine bestimmte Pose aus den Knoten, ziehen sie zusammen, wenn der Abstand zwischen ihnen gr√∂√üer als der Zielwert ist, und schieben sie auseinander, wenn er kleiner ist. <br><br><img src="https://habrastorage.org/webt/i6/zp/yu/i6zpyumeub7danaylwnop54av2o.gif" width="200"><img src="https://habrastorage.org/webt/lt/ee/7j/ltee7j3ejnice_ww_9zmz1wgqy4.gif" width="256"><br><br>  Schauen Sie ‚Äûunter die Haube‚Äú und sehen Sie, wie es funktioniert.  Zuerst erlauben wir den Knoten, sich frei zu bewegen, und passen dann iterativ die Verkn√ºpfungen an, damit sie sich auf ihre Zieleigenschaften erholen.  F√ºr eine Iteration der Muskelanpassung sind zwei Iterationen der Rippenanpassung erforderlich.  Indem wir die Rippen steifer machen, k√∂nnen wir sicher sein, dass die Rippenverbindungen nicht brechen, nachdem die Muskeln den Knoten ausgesetzt sind. <br><br><img src="https://habrastorage.org/webt/8w/gp/oj/8wgpojyvyq-8xri-klubhqefizm.png"><br><br>  Je st√§rker sich die Knoten im Stadium der freien Bewegung verschieben, desto mehr Rechenaufwand muss aufgewendet werden, um die Rippen und Muskeln wiederherzustellen.  Um diese Kosten und das Risiko von strukturellen St√∂rungen zu minimieren, haben wir uns entschlossen, den iterativen Prozess in mehrere Schritte zu unterteilen.  Das hei√üt, in einem Frame findet mehrmals die freie Bewegung von Knoten und deren Korrektur statt.  In einem Schritt k√∂nnen sich die Knoten viel weniger bewegen, und das Anpassen wird viel einfacher.  Auf diese Weise sparen wir die Anzahl der f√ºr die Anpassung der Rippen und Muskeln erforderlichen Iterationen erheblich ein. <br><br><img src="https://habrastorage.org/webt/3b/gi/fb/3bgifbrbqqsanddmmjjujyt5t9m.png"><br><br>  Die Menge der Muskell√§ngen bestimmt die Zielpose, die der Charakter nach dem √úbergang zu einer physischen Simulation von jeder Position aus sucht.  Um zu abrupte √úberg√§nge und strukturelle St√∂rungen zu vermeiden, haben wir die Interpolationsposition hinzugef√ºgt.  Im Moment des Eintritts in die Physik nehmen wir die aktuelle Pose des Charakters und machen sie zum Ziel. Dann interpolieren wir sie f√ºr f√ºnfzig Frames auf die voreingestellte Zielpose, um einen reibungslosen √úbergang zu erzielen. <br><br><img src="https://habrastorage.org/webt/r_/qm/z1/r_qmz1ghpgoe13z7mbwtfumnn_w.gif" width="480"><br><br>  Das Hauptproblem, auf das wir bei der Verwendung unserer Physik gesto√üen sind, ist das periodische Verdrehen von Gliedma√üen, haupts√§chlich von Armen.  Dies ist auf die Tatsache zur√ºckzuf√ºhren, dass sich der Charakter zum Zeitpunkt des √úbergangs in die Physik m√∂glicherweise in einer Position weit vom Ziel entfernt befindet, auf die sich seine Muskeln verengen.  Um solche Situationen zu minimieren und in Zukunft vollst√§ndig zu vermeiden, wurde eine Reihe von Ma√ünahmen ergriffen.  Zuallererst haben wir mehrere Zielpositionen eingerichtet, an denen die Muskeln die Knoten straffen k√∂nnen.  In dem Moment, in dem wir in die Physik eintreten, nehmen wir die aktuelle Pose ein, schauen, welcher der voreingestellten Zielposen sie am n√§chsten ist, und ziehen die Knoten daran fest. <br><br><img src="https://habrastorage.org/webt/jq/az/-f/jqaz-fbsyq1n1rb8b0ddo6v944a.png"><br><br>  Anf√§nglich haben die Muskeln beim √úbergang in die Physik die Knoten starr gedr√ºckt und in die gew√ºnschte Position gebracht.  Oft f√ºhrte die Sch√§rfe dieser Absto√üung auch dazu, dass sich die Extremit√§ten stark verdrehten.  Wir haben eine sanfte Steigerung der Muskelkraft hinzugef√ºgt, was die Situation erheblich verbessert hat.  W√§hrend der ersten beiden Frames nach dem Start der Physiksimulation bleibt die Muskelkraft auf ihrem Maximum, um die Knoten zu stabilisieren, nachdem ein Impuls auf sie ausge√ºbt wurde.  Dann entspannen sich die Muskeln, ihre Kraft wird 55%, und √ºber 120 Frames steigt die Kraft allm√§hlich auf 100% an. <br><br><img src="https://habrastorage.org/webt/o2/t0/bx/o2t0bxsfhq1eg3kj1uj6mft5lw0.png" width="450"><br><br>  Der letzte Schritt bestand darin, zwei Stabilisierungsknoten hinzuzuf√ºgen: den vorderen auf Brusth√∂he und den hinteren auf Beinh√∂he.  Diese Knoten haben Rippenverbindungen mit festen Knoten der Brust bzw. des Beckens, und instabile Knoten ziehen sich mit den Muskeln zusammen.  Die Stabilisierungsknoten haben einen niedrigen Massenwert und haben im Gegensatz zu anderen Knoten keine Kollision mit dem Boden. <br><br><img src="https://habrastorage.org/webt/t6/u6/g7/t6u6g7zz-u85gjundzcmxdn5eta.png" width="360"><br><br>  Im GIF unten sehen Sie das Ergebnis: Wir haben eine vollst√§ndig deterministische Physik, die auf ganzzahligen Berechnungen basiert und selbst auf den schw√§chsten von uns unterst√ºtzten Ger√§ten stabil mit 60 fps arbeitet. <br><br><img src="https://habrastorage.org/webt/9v/da/_f/9vda_fr5h5evquyazx43opukdei.gif"><br><br><blockquote>  Folgen Sie Banzai Games in sozialen Netzwerken: <a href="https://www.facebook.com/BanzaiGamesOfficial/">Facebook</a> , <a href="https://vk.com/banzaigamesofficial">Vkontakte</a> , <a href="https://www.instagram.com/banzai.games/">Instagram</a> , <a href="https://www.linkedin.com/company/banzai-games/">LinkedIn</a> </blockquote><br>  <i>Das Banzai Games-Team ben√∂tigt einen erfahrenen VFX-Spezialisten.</i>  <i>Lesen Sie hier mehr √ºber die Vakanz.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480108/">https://habr.com/ru/post/de480108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480098/index.html">JH Regenwasser "Wie man Katzen weidet": auf der anderen Seite der Entwicklung</a></li>
<li><a href="../de480100/index.html">Anf√§nger √ºber SEO</a></li>
<li><a href="../de480102/index.html">November Product Management Digest</a></li>
<li><a href="../de480104/index.html">9 n√ºtzliche HTML-Tricks</a></li>
<li><a href="../de480106/index.html">So stellen Sie ein Oracle DB-Image f√ºr Testcontainer zusammen</a></li>
<li><a href="../de480110/index.html">uMCPIno: Schreiben eines einfachen Protokolls mit garantierter Zustellung f√ºr Arduino</a></li>
<li><a href="../de480112/index.html">Unterschiede zwischen C ++ / Visual Basic und Java auf allgemeiner Ebene (f√ºr Anf√§nger und Studenten)</a></li>
<li><a href="../de480114/index.html">Alles √ºber Steuern f√ºr IT-Freiberufler. IE und selbst√§ndig. Teil 1</a></li>
<li><a href="../de480116/index.html">Die Position der Mail.ru-Gruppe zur Entwicklung von Open Source in Russland</a></li>
<li><a href="../de480118/index.html">Wir schreiben einen Touch-Typing-Simulator mit reinem JavaScript. Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>