<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõï üöÉ ‚è© Reaccionar y dividir c√≥digo üë®‚Äç‚öñÔ∏è ü§Æ üßô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Conoc√≠ la divisi√≥n de c√≥digos hace mucho tiempo, en el a√±o 2008, cuando Yandex estaba un poco suspendido, y los scripts Yandex.Direct conectados sincr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reaccionar y dividir c√≥digo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442046/"><p>  Conoc√≠ la divisi√≥n de c√≥digos hace mucho tiempo, en el a√±o 2008, cuando Yandex estaba un poco suspendido, y los scripts Yandex.Direct conectados sincr√≥nicamente al sitio simplemente mataron este sitio.  En general, era normal en esos d√≠as si sus "secuencias de comandos" son 10 archivos que conecta en el √∫nico orden correcto, que todav√≠a (con aplazamiento) todav√≠a funciona bien. <br>  Luego comenc√© a trabajar activamente con tarjetas, y todav√≠a est√°n conectadas como scripts externos, por supuesto, carga diferida.  Luego, como miembro del equipo de Yandex.Maps, utilic√© activamente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ymodules</a> para usar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">intercambio</a> de √°rboles en el cliente, lo que proporcion√≥ una divisi√≥n de c√≥digo perfecta. </p><br><p> Y luego me acerqu√© a <code>webpack</code> y <code>React</code> , al pa√≠s de los idiotas asustados que miraban <code>require.ensure</code> como un carnero en una nueva puerta, y a√∫n lo hago. </p><br><p>  La divisi√≥n de c√≥digo no es una caracter√≠stica sorprendente, es imprescindible.  A√∫n as√≠, la <code>SSR</code> no interferir√≠a ... </p><br><p><img src="https://habrastorage.org/webt/47/7y/ay/477yayld6xtgc06hmgfejbrfpxc.jpeg"></p><a name="habracut"></a><br><h3 id="malenkoe-vvedenie">  Peque√±a introducci√≥n </h3><br><p>  Hoy en d√≠a, cuando los paquetes se hacen m√°s gordos todos los d√≠as, la divisi√≥n de c√≥digos se vuelve m√°s importante que nunca.  Al principio, la gente sali√≥ de esta situaci√≥n simplemente creando puntos de entrada separados para cada p√°gina de su aplicaci√≥n, lo que generalmente es bueno, pero no funcionar√° para SPA. <br>  Luego vino la funci√≥n <code>require.ensure</code> , hoy conocida como <code>dynamic import</code> (solo importaci√≥n), a trav√©s de la cual simplemente puede solicitar un m√≥dulo, que recibir√° un poco m√°s tarde. </p><br><p>  La primera biblioteca sobre este caso para React fue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cargable por reacci√≥n</a> , el bombo en torno al cual todav√≠a no me queda muy claro y que ya ha muerto (simplemente dej√≥ de complacer al autor). </p><br><p>  En este momento, la opci√≥n m√°s o menos "oficial" ser√° <code>React.lazy</code> y <code>React.lazy</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">-components</a> (solo <code>@loadable</code> ), y la elecci√≥n entre ellos es obvia: </p><br><ul><li>  React.lazy es completamente incapaz de SSR (Representaci√≥n del lado del servidor), de la palabra en general.  Incluso en las pruebas, caer√° sin bailes especiales con una pandereta, como "promesas sincr√≥nicas". </li><li>  Una SSR cargable puede, y aunque admite Suspenso, no es peor que React.Lazy. </li></ul><br><p>  En particular, loadable admite envoltorios hermosos para cargar bibliotecas (loadable.lib, puede tomar moment.js en React renderProp), y ayuda al paquete web en el lado del servidor a recopilar una lista de scripts, estilos y recursos usados ‚Äã‚Äãpara la captaci√≥n previa (que el paquete web en s√≠ no sabe realmente).  En general, lea la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n oficial</a> . </p><br><h3 id="ssr">  SSR </h3><br><p>  En general, todo el problema est√° en la RSS.  Para CSR (Client Side Render), se ajustar√° React.lazy o un peque√±o script con 10 l√≠neas; esto definitivamente ser√° suficiente, y no tiene sentido conectar una gran biblioteca externa.  Pero en el servidor esto no ser√° suficiente.  Y si realmente no necesita un SSR, puede omitir m√°s la lectura.  No tienes problemas que necesites resolver por mucho tiempo. </p><br><p>  La RSS es un dolor.  Yo (de alguna manera) es uno de los mantenedores de componentes cargables y es horrible cu√°ntos errores salen de diferentes lugares.  Y con cada actualizaci√≥n, el paquete web vuela a√∫n m√°s. </p><br><h3 id="ssr--css">  SSR + CSS </h3><br><p>  Una fuente a√∫n mayor de problemas con los SSR es CSS. <br>  Si tiene componentes con estilo, no duele tanto, vienen con <code>transform-stream</code> que agregar√° lo que se necesita al c√≥digo final.  Lo principal es que debe haber una versi√≥n de SC en todas partes, de lo contrario el enfoque no funcionar√°: una versi√≥n de SC no podr√° contar nada m√°s sobre s√≠ misma, y ‚Äã‚Äãa SC le encanta multiplicar (verifique su paquete).  Para ser honesto, es precisamente debido a esta limitaci√≥n que el enfoque generalmente <strong>falla</strong> . </p><br><p>  La emoci√≥n C es m√°s simple: su adaptador con <code>styled</code> simplemente escupe <code>&lt;style&gt;</code> delante del componente en s√≠, y el problema est√° resuelto.  Simple, barato y alegre.  En principio, es muy amigable para dispositivos m√≥viles y optimiza enormemente la primera vista.  Pero un poco estropea el segundo.  Y personalmente, mi conciencia no me permite incorporar estilos como ese. </p><br><p>  Con CSS ordinario (incluido el obtenido de varias bibliotecas CSS-in-JS con diferente magia) es a√∫n m√°s f√°cil: hay informaci√≥n sobre ellos en la columna del paquete web y se "sabe" qu√© CSS necesita estar conectado. </p><br><h3 id="poryadok-podklyucheniya">  Orden de conexi√≥n </h3><br><p>  Aqu√≠ el perro se enterr√≥ a s√≠ mismo.  ¬øCu√°ndo debo conectarme? <br>  El significado de la divisi√≥n de c√≥digo amigable de SSR es que antes de llamar a <code>ReactDOM.hydrate</code> debe descargar todos los "componentes" que ya est√°n presentes en la respuesta del servidor, pero los scripts actualmente cargados en el cliente no pueden permitirse. </p><br><p>  Por lo tanto, todas las bibliotecas ofrecen una cierta devoluci√≥n de llamada que se llamar√° cuando se necesite cargar todo y todo, y puede iniciar el <em>cerebro</em> .  Este es el significado del trabajo de las bibliotecas de divisi√≥n de c√≥digos SSR. </p><br><p>  JS se puede cargar en cualquier momento y, por lo general, su lista se agrega al final del HTML, pero CSS, para que no haya FOUC, debe agregarse al principio. <br>  Todas las bibliotecas pueden hacer esto para el <code>renderToString</code> , y todas las bibliotecas <strong>no</strong> pueden hacer esto para <code>renderToNodeStream</code> . <br>  No importa si solo tiene JS (esto no sucede) o SC / Emotion (que se sumar√°n).  Pero, si tienes "solo CSS", eso es todo.  O estar√°n al final, o tendr√°n que usar <code>renderToString</code> u otro almacenamiento en b√∫fer, que proporcionar√° un retraso TTFB (Tiempo hasta el primer byte) y reducir√° ligeramente la sensaci√≥n de tener este SSR en general. </p><br><p>  Y, por supuesto, todo esto est√° relacionado con el paquete web y de ninguna otra manera.  Por lo tanto, con el debido respeto a Greg, el autor de los componentes cargables, propongo considerar otras opciones. </p><br><blockquote>  Lo siguiente es una agenda de tres partes, cuya idea principal es hacer algo que no se elimine y que no dependa del paquete. </blockquote><br><h3 id="1-react-imported-component">  1. Componente importado por reacci√≥n </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">React-Imported-Component</a> no es un mal "cargador", con una interfaz m√°s o menos est√°ndar, muy similar a los componentes cargables, que pueden SSR para todo lo que se mueve. </p><br><p>  La idea es muy simple. </p><br><ul><li>  los c√≥digos fuente se escanean, todas las <code>import</code> se encuentran y se <strong>copian</strong> en un archivo separado </li><li>  usando el <code>babel plugin</code> cada llamada para <code>import</code> convierte en algo de az√∫car <br><pre> <code class="plaintext hljs">const AsyncComponent1 = imported(() =&gt; import('./MyComponent')); ///// const AsyncComponent1 = imported(() =&gt; importedWrapper("imported_18g2v0c_component", import('./MyComponent')));</code> </pre> </li><li>  al llamar a la funci√≥n "import" .toString simplemente se hace y se saca el n√∫mero m√°gico.  Por lo tanto, queda claro lo que se caus√≥.  (S√≠, esto impone algunas restricciones en el c√≥digo, pero menos que otros cargadores que no pueden "no importar" en absoluto) </li><li>  en el cliente tenemos un archivo donde se recopilan todas las importaciones posibles, y cualquier importaci√≥n puede <em>repetirse</em> . </li></ul><br><p>  No es necesario <code>stats.json</code> , adaptarlo para la optimizaci√≥n del paquete web (concatenaci√≥n o c√≥digo com√∫n): solo necesita hacer coincidir la "etiqueta" de una importaci√≥n en la clave de la matriz e importar de nuevo.  C√≥mo se realizar√° como parte de un paquete espec√≠fico, cu√°ntos archivos se descargar√°n realmente y de d√≥nde no es su problema. </p><br><p>  Menos: el inicio de la carga de fragmentos "usados" se produce despu√©s de cargar el paquete principal, que almacena la asignaci√≥n, que es un poco "posterior" que en el caso de los componentes cargables, que agregar√°n esta informaci√≥n directamente a HTML. </p><br><p>  S√≠, con CCS no funciona de la palabra de ninguna manera. </p><br><h3 id="2-used-styles">  2. estilos usados </h3><br><p>  Pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los estilos usados</a> solo funcionan con CSS, pero de la misma manera que los componentes react-importados. </p><br><ul><li>  escanea todos los css (en el directorio de compilaci√≥n) </li><li>  recuerda d√≥nde se define qu√© clase </li><li>  analiza la salida renderToNodeStream (o la respuesta <code>renderToString</code> ) </li><li>  encuentra class = 'XXX', coincide con el archivo y lo escupe en la respuesta del servidor. </li><li>  (bueno, y luego teletransporta todos esos estilos a la cabeza para no romper el hidrato).  Los componentes de estilo funcionan igual. </li></ul><br><p>  No hay demora TTBT, no est√° vinculado al paquete, un cuento de hadas.  Funciona como un reloj si los estilos est√°n bien escritos. </p><br><p>  <a href="">React-import-component + used-styles + parcel</a> ejemplo de trabajo. </p><br><blockquote>  No es la ventaja m√°s obvia: en el servidor, ambas bibliotecas har√°n "todo lo necesario" durante el inicio, hasta que el servidor express pueda recibir el primer cliente, y se sincronizar√°n completamente tanto en el servidor como durante las pruebas. </blockquote><br><h3 id="3-react-prerendered-component">  3. componente de reacci√≥n previa </h3><br><p>  Y la biblioteca cierra los tres primeros, lo que hace una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"rehidrataci√≥n parcial"</a> , y lo hace de una manera tan abuela que me pregunto de inmediato.  Ella realmente agrega "divas". </p><br><ul><li>  en el servidor: <br><ul><li>  envuelve un pedazo de madera en un div con una "identificaci√≥n famosa" </li></ul></li><li>  en el cliente: <br><ul><li>  el constructor de componentes encuentra su propio div </li><li>  copia su innerHTML antes de que React lo tome. </li><li>  usa este HTML hasta que el cliente est√© listo para <code>hydrate</code> </li><li>  t√©cnicamente, esto permite el uso de SSR h√≠brido (Rendertron) </li></ul></li></ul><br><pre> <code class="plaintext hljs">const AsyncLoadedComponent = loadable(() =&gt; import('./deferredComponent')); const AsyncLoadedComponent = imported(() =&gt; import('./deferredComponent')); &lt;PrerenderedComponent live={AsyncLoadedComponent.preload()} // when Promise got resolve - component will go "live" &gt; &lt;AsyncLoadedComponent /&gt; // meanwhile you will see "preexisting" content &lt;/PrerenderedComponent&gt;</code> </pre> <br><p>  Este enfoque no funciona con componentes cargables, ya que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no regresa de una promesa de precarga</a> .  Esto es especialmente importante para bibliotecas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">react-snap</a> (y otros "prerrenders") que tienen "contenido" pero no han pasado por un SSR "real". </p><br><p><img src="https://habrastorage.org/webt/av/oa/uy/avoauymgvrxzwyo18-8skc69cws.png"></p><br><p>  Desde el punto de vista del c√≥digo, se trata de 10 l√≠neas, m√°s un poco m√°s para obtener <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UID SSR-CSR estables</a> teniendo en cuenta el orden aleatorio de carga y ejecuci√≥n del c√≥digo. </p><br><p>  Bonificaciones: </p><br><ul><li>  no tiene que esperar a que se "carguen todos los guiones" antes de comenzar los <em>cerebros</em> : los cerebros comenzar√°n cuando est√©n listos </li><li>  no tiene que cargar cerebros en absoluto, dejando datos SSR-ed (si no hay una versi√≥n SSR, los cerebros a√∫n se cargar√°n).  Como en los tiempos de jQuery. </li><li>  Tambi√©n puede implementar el <strong>almacenamiento</strong> en <strong>cach√© de</strong> flujos <strong>de</strong> bloques de renderizado grandes (te√≥ricamente compatibles con Suspence), nuevamente utilizando el flujo de transformaci√≥n. </li><li>  y serializar / deserializar el estado a / desde HTML, como durante jQuery </li></ul><br><p>  En principio, la serializaci√≥n y la deserializaci√≥n fueron la idea principal de crear una biblioteca para resolver el problema de duplicar el estado (imagen del art√≠culo sobre SSR).  El almacenamiento en cach√© lleg√≥ m√°s tarde. <br><img src="https://habrastorage.org/webt/wb/9q/ni/wb9qniykqfav6ouzmjkrtpjhy5w.png"></p><br><h3 id="itogo">  Total </h3><br><p>  En total, hay tres enfoques que pueden cambiar su visi√≥n de SSR y divisi√≥n de c√≥digo.  El primero funciona con la divisi√≥n de c√≥digos JS, y no se rompe.  El segundo funciona con la divisi√≥n de c√≥digos CSS, y no se rompe.  El tercero funciona a nivel HTML simplificando y acelerando algunos procesos, y nuevamente, no se rompe. </p><br><p>  Enlaces a bibliotecas: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/theKashey/react-imported-component/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/theKashey/react-prerendered-component</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/theKashey/used-styles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/smooth-code/loadable-components/</a> </li><li>  (para aquellos que est√°n en el tanque) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://reactjs.org/blog/2018/10/23/react-v-16-6.html#reactlazy-code-splitting-with-suspense</a> </li></ul><br><p>  Art√≠culos (en ingl√©s) </p><br><ul><li>  (sobre importados) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://hackernoon.com/react-and-code-splitting-made-easy-f118befb5168</a> </li><li>  (sobre prerrendido) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://medium.com/@antonkorzunov/react-server-side-code-splitting-made-again-a61f8cbbd64b</a> </li><li>  (sobre SSR) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://developers.google.com/web/updates/2019/02/rendering-on-the-web#partial-rehydration</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442046/">https://habr.com/ru/post/442046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442034/index.html">ReCaptcha bypass en pruebas de selenio</a></li>
<li><a href="../442036/index.html">Tiempo de ejecuci√≥n de contenedor maduro: containerd se grad√∫a de CNCF</a></li>
<li><a href="../442038/index.html">El resumen de eventos para profesionales de recursos humanos en el campo de TI en marzo de 2019</a></li>
<li><a href="../442040/index.html">La asociaci√≥n como herramienta efectiva para el desarrollo empresarial</a></li>
<li><a href="../442044/index.html">C√≥mo usamos el sistema de monitoreo minorista Zabbix</a></li>
<li><a href="../442048/index.html">C√≥mo Google Programmer resuelve problemas comunes</a></li>
<li><a href="../442050/index.html">Qu√© hacer si desea recaudar dinero para la reparaci√≥n de Falla, y solo Wikipedia est√° a la mano</a></li>
<li><a href="../442052/index.html">La nueva tecnolog√≠a puede mejorar diez veces la resoluci√≥n de im√°genes de tejidos biol√≥gicos</a></li>
<li><a href="../442054/index.html">Febrero de 2019 Joomla Digest</a></li>
<li><a href="../442056/index.html">Resumen de eventos de TI de marzo (primera parte)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>