<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ò£Ô∏è ü•ï üë®üèª‚Äç‚öïÔ∏è Bonjour tout le monde! Immersion profonde dans les terminaux üèâ üßíüèΩ üïü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'ai √©t√© inspir√© pour √©crire cet article par un article sur l'analyse de Sishny printf . Cependant, il y a eu un moment manquant sur la fa√ßon dont les...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bonjour tout le monde! Immersion profonde dans les terminaux</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460257/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/ha/5f/0v/ha5f0vjiijc9c92bnnt56z7jcpg.jpeg"></a> </p><br><p>  J'ai √©t√© inspir√© pour √©crire cet article par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article sur l'analyse de Sishny printf</a> .  Cependant, il y a eu un moment manquant sur la fa√ßon dont les donn√©es vont apr√®s leur entr√©e dans le terminal.  Dans cet article, je souhaite corriger ce d√©faut et analyser le chemin des donn√©es dans le terminal.  Nous d√©couvrirons √©galement en quoi Terminal diff√®re de Shell, ce qu'est le pseudoterminal, comment fonctionnent les √©mulateurs de terminaux, et bien plus encore. </p><a name="habracut"></a><br><h2 id="osnovy">  Les bases </h2><br><p>  Commen√ßons par comprendre ce qu'est Terminal, Shell, Console, en quoi l'√©mulateur de terminal diff√®re du terminal ordinaire et pourquoi il est ainsi nomm√©.  Beaucoup d'informations ont d√©j√† √©t√© √©crites √† ce sujet, vous n'entendrez donc rien de nouveau ici.  Presque toutes les informations ici ont √©t√© tir√©es d'Internet, je fournirai des liens √† la fin de l'article.  Qui sait d√©j√† ce que toutes ces choses signifient, peut sauter cette section en toute s√©curit√©. </p><br><hr><br><h3 id="terminal">  Terminal </h3><br><p>  <strong>Un terminal</strong> est une combinaison d'un √©cran et d'un clavier, c'est-√†-dire un p√©riph√©rique physique.  Avant que les terminaux ne deviennent cette combinaison particuli√®re, ils √©taient une sorte d'appareil appel√© t√©l√©imprimeur (t√©l√©scripteur, t√©l√©scripteur ou ATS pour faire court), c'est-√†-dire une combinaison d'une imprimante et d'un clavier.  En r√®gle g√©n√©rale, plusieurs terminaux sont connect√©s au m√™me ordinateur.  Ainsi, il √©tait possible de travailler pour plusieurs utilisateurs sur le m√™me ordinateur, et chacun avait sa propre session, ind√©pendante des autres.  Le terminal a √©t√© nomm√© ainsi car il √©tait situ√© √† l'extr√©mit√© du c√¢ble du terminal. </p><br><p>  Voici le <strong>t√©l√©type</strong> : </p><br><img src="https://habrastorage.org/webt/m3/_3/yt/m3_3ytmmoofzwgpr3dpu78w8m7i.jpeg" alt="Teletype" title="T√©l√©type" width="430" height="370"><br><br><p>  Et <strong>voici Terminal</strong> : </p><br><img src="https://habrastorage.org/webt/pz/lj/eu/pzljeumccjvqmrunt-pqolnyx-c.jpeg" alt="Terminal" title="Terminal" width="430" height="370"><br><br><hr><br><h3 id="console">  La console </h3><br><p>  <strong>Console (console)</strong> - un terminal qui est connect√© directement √† l'ordinateur.  Le fait est que la plupart des terminaux √©taient connect√©s implicitement, mais au moins un √©tait connect√© directement √† l'ordinateur.  La console √©tait autoris√©e √† utiliser un cercle de personnes strictement d√©fini, car elle vous permettait de configurer l'ordinateur. </p><br><hr><br><h3 id="shell">  Coquille </h3><br><p>  Si les deux pr√©c√©dents sont des p√©riph√©riques physiques, cette d√©finition se r√©f√®re exclusivement aux logiciels. </p><br><p>  <strong>Shell</strong> est un interpr√©teur de ligne de commande.  Le but principal est d'ex√©cuter d'autres programmes.  Il existe un grand nombre de coquilles diff√©rentes.  Le plus commun est Bash (de l'anglais Bourne Again SHell, qui, comme le sugg√®re <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wikipedia</a> , est un jeu de mots pour Shell ¬´Born again¬ª, c'est-√†-dire un shell ¬´revived¬ª).  Autres exemples: Dash (un Shell l√©ger, disponible si vous ex√©cutez le binaire dans / bin / sh), Zsh. </p><br><hr><br><p>  Bien s√ªr, les terminaux et les consoles ne pouvaient que trouver leur reflet dans les temps modernes.  Par cons√©quent, nous examinerons plus loin des choses telles que l' <em>√©mulateur de terminal</em> et la <em>console virtuelle</em> . </p><br><h3 id="terminal-emulator">  √âmulateur de terminal </h3><br><p>  <strong>Terminal Emulator</strong> - un √©mulateur du bon vieux terminal.  Un √©mulateur de terminal est requis pour les programmes qui ne peuvent pas interagir directement avec le syst√®me X Window - Bash, Vim et autres. </p><br><p>  √âtablissons d'abord les responsabilit√©s du terminal: </p><br><ol><li>  Transf√©rer les entr√©es utilisateur sur un ordinateur </li><li>  Livraison de la sortie de l'ordinateur √† l'√©cran </li></ol><br><p>  Notre √©mulateur de terminal fait donc exactement la m√™me chose: il fournit une entr√©e utilisateur au programme en cours d'ex√©cution et affiche √©galement la sortie du programme sur l'√©cran.  Dans tous les cas, la signification demeure - entre l'utilisateur et le programme en cours d'ex√©cution, il existe une sorte de couche responsable des entr√©es / sorties.  Exemples d'√©mulateur de terminal: gnome-terminal, xterm, konsole. </p><br><p>  <strong>Veuillez ne pas confondre Shell et l'√©mulateur de terminal!</strong> <br>  Terminal Emulator est une application GUI, c'est-√†-dire une fen√™tre du syst√®me X Window.  Shell est un interpr√©teur de ligne de commande, c'est-√†-dire juste un ex√©cuteur de commandes, il n'a pas de shell graphique.  En parlant assez correctement, vous <strong>ne lancez pas Bash</strong> , vous <strong>ex√©cutez Terminal Emulator, qui lance Bash en lui-m√™me</strong> .  Terminal Emulator et Bash sont absolument 2 programmes diff√©rents.  Le premier est seul responsable des entr√©es / sorties, le second - du traitement des commandes. </p><br><p>  Plus loin dans l'article, toutes les r√©f√©rences au terminal feront r√©f√©rence √† l'√©mulateur de terminal. </p><br><hr><br><h3 id="virtual-console-virtual-terminal">  Console virtuelle (terminal virtuel) </h3><br><p>  Appuyez sur Ctrl + Alt + FN, o√π N a g√©n√©ralement des valeurs de 1 √† 6. Ce que vous venez de voir s'appelle Virtual Console (console virtuelle) ou Virtual Terminal (terminal virtuel).  Rappelez-vous ce que j'ai dit plus t√¥t √† propos des terminaux?  De nombreux terminaux √©taient connect√©s √† un ordinateur et chaque terminal √©tait une session distincte, ind√©pendante des autres.  La console virtuelle reprend cette id√©e: il peut y avoir plusieurs sessions ind√©pendantes √† l'int√©rieur de votre ordinateur (cependant, les ressources informatiques sont toujours √©videmment partag√©es). </p><br><p>  Vous pouvez nommer cette entit√© √† la fois console virtuelle et terminal virtuel, car par d√©finition, une console est un terminal connect√© directement √† un ordinateur, mais tous les terminaux virtuels sont, en un sens, connect√©s directement √† un ordinateur. </p><br><hr><br><h3 id="tty-ustroystva">  Appareils ATS </h3><br><p>  Chaque terminal se voit attribuer son propre <em>appareil TTY</em> (appareil terminal), qui fournit la console.  Il est peu probable que vous trouviez des t√©l√©types, mais la r√©duction des ATS a surv√©cu √† ce jour. </p><br><p>  Un appareil TTY se compose de deux composants fondamentaux: </p><br><ol><li>  <strong>Pilote de p√©riph√©rique</strong>  Il est charg√© de fournir une entr√©e clavier au programme et d'afficher la sortie du programme sur l'√©cran. </li><li>  <strong>TTY Line Discipline</strong> (russe - discipline de ligne).  La discipline de ligne est l'interface d'acc√®s au pilote, qui, cependant, apporte beaucoup de logique au dispositif TTY.  Nous pouvons dire que la discipline de ligne fait appel au conducteur.  Quel est le domaine de responsabilit√© de cette composante, nous le d√©couvrirons dans l'article. </li></ol><br><p>  Construire un appareil TTY: </p><br><p><img src="https://habrastorage.org/webt/zn/zw/dy/znzwdyjadyeidyogqoap8kfvgng.jpeg" title="Cr√©er un appareil TTY"></p><br><p>  Il existe 3 types d'appareils TTY: </p><br><ol><li>  <em>P√©riph√©rique de console</em> - fournit le fonctionnement de la console virtuelle.  L'entr√©e et la sortie de ce p√©riph√©rique sont enti√®rement contr√¥l√©es par le noyau. </li><li>  <em>Dispositif PTY</em> (pseudo-terminal) - assure le fonctionnement du terminal dans l'interface de fen√™tre.  L'entr√©e et la sortie de cet appareil sont contr√¥l√©es par un √©mulateur de terminal qui fonctionne dans l'espace utilisateur. </li><li>  <em>P√©riph√©rique s√©rie</em> - communique directement avec le mat√©riel.  Il n'est g√©n√©ralement pas utilis√© directement, mais existe en tant que niveau le plus bas dans l'organisation de l'architecture d'un terminal. </li></ol><br><p>  Dans cet article, nous parlerons sp√©cifiquement du deuxi√®me type d'appareils TTY - les pseudo-terminaux. </p><br><hr><br><h2 id="tty-line-discipline">  Discipline de la ligne ATS </h2><br><p>  Nous commen√ßons √† examiner la discipline de la gamme d'appareils TTY. </p><br><p>  La premi√®re caract√©ristique importante d'une discipline de ligne est qu'elle est responsable du traitement des E / S.  Cela inclut, par exemple, le traitement des caract√®res de contr√¥le (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Caract√®res de contr√¥le">Caract√®res de contr√¥le</a> ) et le formatage de la sortie.  Par exemple, vous saisissez n'importe quel texte, mais soudain vous vous rendez compte que vous vous √™tes tromp√© en √©crivant quelque chose et que vous voulez l'effacer - c'est l√† que la discipline de ligne entre en jeu. </p><br><p>  Nous analyserons en d√©tail ce qui se passe exactement lorsque nous travaillons dans Bash en cours d'ex√©cution dans le terminal.  Par d√©faut, un appareil TTY fonctionne en mode canonique avec l' <em>√©cho activ√©</em> .  Un √©cho est un affichage des caract√®res que vous avez entr√©s √† l'√©cran. </p><br><p> Lorsque nous saisissons, par exemple, le caract√®re <code>a</code> , ce caract√®re est envoy√© au dispositif ATS, mais est intercept√© par la discipline de la ligne ATS du dispositif.  Elle lit un caract√®re dans sa m√©moire tampon interne, voit que le mode <code>echo</code> est activ√© et affiche le caract√®re √† l'√©cran.  √Ä l'heure actuelle, rien n'est encore disponible pour la lecture dans le programme auquel le terminal est connect√©.  Appuyez sur la touche de <code>backspace</code> sur le clavier.  Symbole <code>^?</code>  √† nouveau intercept√© par la discipline de la ligne, et cette derni√®re, r√©alisant que l'utilisateur veut effacer le dernier caract√®re saisi, supprime ce caract√®re de sa m√©moire tampon interne et efface √©galement ce caract√®re de l'√©cran.  Maintenant, si nous appuyons sur Entr√©e, la discipline de ligne TTY envoie finalement au tampon de lecture du p√©riph√©rique terminal tout ce qui a √©t√© √©crit pr√©c√©demment dans le tampon interne de la discipline, y compris LF.  En m√™me temps, les caract√®res CR et LF sont affich√©s √† l'√©cran afin de d√©placer le curseur sur une nouvelle ligne - c'est le formatage de la sortie. </p><br><p>  Voici comment fonctionne le mode canonique - il transf√®re tous les caract√®res saisis vers l'appareil uniquement apr√®s avoir appuy√© sur <code>Enter</code> , traite les caract√®res de contr√¥le et formate la sortie. </p><br><h3 id="tty-line-editing">  Modification de la ligne ATS </h3><br><p>  <strong>TTY Line Editing</strong> est le composant qui est responsable du traitement des entr√©es dans la discipline de ligne.  Il faut dire que l' <em>√©dition de ligne</em> est un concept g√©n√©ral et concerne le traitement d'entr√©e.  Par exemple, Bash et Vim ont leur propre √©dition de ligne. </p><br><p>  Nous pouvons contr√¥ler les param√®tres de discipline de la ligne de l'appareil TTY actuel √† l'aide du programme <strong>stty</strong> .  Essayons un peu. </p><br><p>  Ouvrez Bash ou tout autre Shell et tapez: </p><br><pre> <code class="plaintext hljs">stty icanon -echo</code> </pre> <br><p>  Maintenant, essayez de taper quelque chose et vous ne verrez pas votre saisie (ne vous inqui√©tez pas, vous pouvez toujours transmettre la saisie au programme).  Vous venez de d√©sactiver l'√©cho, c'est-√†-dire l'affichage des caract√®res saisis √† l'√©cran.  Entrez maintenant: </p><br><pre> <code class="plaintext hljs">stty raw echo</code> </pre> <br><p>  Essayez de taper quelque chose.  Vous voyez comment la conclusion est rompue.  Mais pour plus d'effet, allons dans Dash - tapez <code>/bin/sh</code> .  Essayez maintenant de saisir des caract√®res sp√©ciaux ( <code>Ctrl</code> + n'importe quel caract√®re du clavier) ou appuyez simplement sur <code>Enter</code> .  Vous √™tes perplexe - quels sont ces √©tranges personnages √† l'√©cran?  Le fait est que, √©tant entr√© dans le Shell le plus simple, en plus de la modification de ligne de la discipline elle-m√™me, nous avons √©galement d√©sactiv√© la modification de ligne Bash, et maintenant nous pouvons observer avec puissance et maintenir l'effet de l'inclusion du mode <em>brut</em> de discipline de la ligne.  Ce mode ne traite pas du tout l'entr√©e et ne formate pas la sortie.  Pourquoi le mode brut est-il n√©cessaire?  Par exemple, pour <em>Vim</em> : il s'ouvre dans toute la fen√™tre du terminal et traite l'entr√©e elle-m√™me, au moins de sorte que les symboles sp√©ciaux de la discipline de ligne ne se croisent pas avec les symboles sp√©ciaux de Vim lui-m√™me. </p><br><p>  Pour encore plus de compr√©hension, examinons la personnalisation des caract√®res de contr√¥le.  La commande <code>stty &lt;control-character&gt; &lt;string&gt;</code> nous aidera avec cela. <br>  Entrez dans Bash: </p><br><pre> <code class="bash hljs">stty erase 0</code> </pre> <br><p>  Maintenant, le caract√®re de contr√¥le d' <code>erase</code> sera assign√© au caract√®re <code>0</code> .  Le bouton de <code>backspace</code> compte g√©n√©ralement <code>^?</code>  , mais maintenant ce caract√®re sp√©cial sera envoy√© au tampon de lecture PTS litt√©ralement - essayez-le vous-m√™me.  Vous pouvez maintenant effacer des caract√®res √† l'aide du bouton <code>0</code> du clavier, car vous avez vous-m√™me demand√© √† la discipline de ligne tty de reconna√Ætre le caract√®re entr√© comme caract√®re de contr√¥le d' <code>erase</code> .  Vous pouvez retourner le param√®tre √† l'aide de la commande <code>stty erase ^\?</code>  ou simplement fermer le terminal, car nous n'avons affect√© que le p√©riph√©rique tty actuel. </p><br><p>  Vous pouvez trouver plus d'informations dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="homme stty">man stty</a> . </p><br><hr><br><h2 id="terminal-emulator-i-pseudoterminal">  √âmulateur de terminal et pseudoterminal </h2><br><p>  Chaque fois que nous ouvrons un nouveau terminal dans le syst√®me X Window, le serveur de terminaux GNOME g√©n√®re un nouveau processus et y lance le programme par d√©faut.  Il s'agit g√©n√©ralement d'une sorte de Shell (par exemple, Bash). </p><br><p>  La communication avec le programme en cours se fait via le <strong>pseudoterminal</strong> (pseudo-terminal, PTY).  Le pseudo-terminal lui-m√™me existe dans le noyau, cependant, il re√ßoit des entr√©es de l'espace utilisateur - de l'√©mulateur de terminal. </p><br><p>  Le pseudo-terminal se compose des deux <em>appareils TTY virtuels</em> suivants: <br>  1) <strong>Ma√Ætre PTY (PTM)</strong> - la partie principale du pseudo-terminal.  Utilis√© par GNOME Terminal Server pour transf√©rer les entr√©es du clavier vers un programme s'ex√©cutant √† l'int√©rieur du terminal, ainsi que pour lire la sortie du programme et afficher la sortie.  Le serveur de terminaux GNOME, √† son tour, communique avec le syst√®me X Window via le protocole X. <br>  2) <strong>esclave PTY (PTS)</strong> - partie esclave du pseudo-terminal.  Utilis√© par un programme ex√©cut√© √† l'int√©rieur du terminal pour lire les entr√©es du clavier et afficher les sorties √† l'√©cran.  Du moins, le programme lui-m√™me le pense (je vais expliquer ce que cela signifie, un peu plus loin). </p><br><p>  Toutes les donn√©es enregistr√©es dans le dispositif PTS sont l'entr√©e du dispositif PTM, c'est-√†-dire qu'elles deviennent lisibles sur le dispositif PTM.  Et vice versa: toutes les donn√©es enregistr√©es dans le dispositif PTM sont l'entr√©e du dispositif PTS.  C'est ainsi que GNOME Terminal Server et le programme s'ex√©cutant √† l'int√©rieur du terminal communiquent.  Chaque appareil PTM est associ√© √† son propre appareil PTS. </p><br><p>  Le processus de lancement d'un nouveau terminal ressemble √† ceci: <br>  1) GNOME Terminal Server cr√©e des p√©riph√©riques ma√Ætres et esclaves en appelant la fonction open () sur un p√©riph√©rique sp√©cial <strong>/ dev / ptmx</strong> .  L'appel open () renvoie le descripteur de fichier du p√©riph√©rique PTM cr√©√© - <em>master_fd</em> . <br>  2) GNOME Terminal Server cr√©e un nouveau processus en appelant <code>fork()</code> .  Ce processus sera le nouveau terminal. <br>  3) Dans le terminal PTS, l'appareil s'ouvre sur les descripteurs de fichiers 0, 1, 2 (stdin, stdout et stderr, respectivement).  Maintenant, les E / S du terminal standard circulent vers cet appareil. <br>  4) Le programme souhait√© est lanc√© dans le terminal en appelant la fonction <code>exec()</code> .  Certains Shell d√©marrent g√©n√©ralement (par exemple, Bash).  Tout programme lanc√© ult√©rieurement √† partir de Bash aura les m√™mes descripteurs de fichier que Bash lui-m√™me, c'est-√†-dire que les flux de programme seront dirig√©s vers le p√©riph√©rique PTS. </p><br><p>  Vous pouvez voir par vous-m√™me o√π les flux de sortie de terminal standard sont dirig√©s √† l'aide de la commande <code>ls -la /proc/self/fd</code> : <br><img src="https://habrastorage.org/webt/nr/dx/97/nrdx97wllflvapnt76p3qqki3fw.jpeg"></p><br><p>  Le p√©riph√©rique PTS est situ√© sur le chemin <strong>/ dev / pts / N</strong> , et le chemin vers le p√©riph√©rique PTM ne nous int√©resse pas du tout.  Le fait est que GNOME Terminal Server poss√®de d√©j√† un descripteur de fichier pour le p√©riph√©rique PTM ouvert et qu'il n'a pas besoin de chemin d'acc√®s, cependant, dans le processus enfant, nous devons ouvrir le p√©riph√©rique PTS sur des flux de sortie standard en appelant la fonction <code>open()</code> , qui n√©cessite le chemin d'acc√®s au fichier. </p><br><p>  Rappelez-vous, j'ai dit qu'un programme utilisant un appareil PTS pense seulement qu'il communique directement avec le terminal?  Le fait est que le PTS est √©galement un <em>appareil terminal</em> ( <em>appareil</em> TTY), mais la diff√©rence entre l'appareil PTS et l'appareil TTY r√©el est que l'appareil PTS re√ßoit une entr√©e non pas du clavier, mais de l'appareil ma√Ætre, et la sortie ne va pas √† l'affichage, mais √† appareil ma√Ætre.  C'est pourquoi le pseudo-terminal est nomm√© ainsi: le pseudo-terminal imite (encore une fois ??) le terminal.  La diff√©rence entre l'√©mulateur de terminal et le pseudo-terminal est que l'√©mulateur de terminal n'est qu'un programme graphique qui vous permet d'ex√©cuter le terminal directement √† l'int√©rieur de l'interface de la fen√™tre, mais cette fonctionnalit√© est impl√©ment√©e √† l'aide du pseudo-terminal. </p><br><p>  Le fait que l' <em>appareil PTS soit un appareil TTY</em> est tr√®s important.  Voici pourquoi: </p><br><ol><li>  Le programme auquel le terminal est connect√© poss√®de toutes les capacit√©s d'un terminal conventionnel.  Par exemple: d√©sactiver l'√©cho, d√©sactiver / activer la vue canonique. </li><li>  Le programme, sachant qu'un terminal est attach√© √† celui-ci (il est dit que le programme a un terminal de contr√¥le), peut fonctionner de mani√®re interactive et demander √† l'utilisateur de le saisir.  Par exemple, demandez un nom d'utilisateur et un mot de passe. </li><li>  Il existe √©galement une discipline de ligne TTY, nous avons donc la possibilit√© de traiter les caract√®res de contr√¥le avant qu'ils n'atteignent le programme, ainsi que de formater la sortie du programme. </li></ol><br><p>  Le dispositif PTM est √©galement un dispositif ATS, mais cela ne joue aucun r√¥le, car il n'est pas utilis√© comme terminal de commande.  De plus, la discipline de ligne du p√©riph√©rique PTM est d√©finie sur le mode brut, par cons√©quent, le traitement n'est pas effectu√© lors du transfert de donn√©es du PTS vers le p√©riph√©rique PTM.  Cependant, les appels √† <code>read()</code> et <code>write()</code> partir de l'espace utilisateur sont toujours trait√©s en premier par la discipline de ligne sur les deux appareils.  Ce moment jouera un r√¥le encore plus important, comme nous le verrons plus loin. </p><br><p>  Le processus de communication entre GNOME Terminal Server et le programme ex√©cut√© √† l'int√©rieur du terminal est le suivant: </p><br><p><img src="https://habrastorage.org/webt/jz/y0/sg/jzy0sg0zjcceaflg6wyg7d5lkti.jpeg" title="Processus de communication de GNOME Terminal Server et d'un programme ex√©cut√© √† l'int√©rieur du terminal"></p><br><p>  Il convient d'examiner plus en d√©tail le r√¥le que la discipline de ligne joue dans la communication entre les deux parties d'un pseudo-terminal.  Ici, la discipline de ligne est responsable du traitement des donn√©es <em>passant du PTM au dispositif PTS</em> , ainsi que de la livraison des donn√©es d'une partie du pseudo-terminal √† une autre.  Lorsque nous sommes dans le pilote de p√©riph√©rique PTS, nous engageons la discipline de ligne du p√©riph√©rique PTM, et vice versa. </p><br><hr><br><h2 id="virtualnye-ustroystva">  Appareils virtuels </h2><br><p>  Vous auriez probablement pens√© que vous pourriez ouvrir le fichier le long du chemin <em>/ dev / pts / N</em> et y √©crire ou lire des donn√©es, comme √† partir d'un fichier texte normal?  Oui, tous les appareils sur les syst√®mes de type Unix sont des fichiers, gr√¢ce au principe fondamental d'Unix, qui stipule que tout est un fichier.  Cependant, aucun fichier de p√©riph√©rique sp√©cial (anglais - fichier de p√©riph√©rique) n'est un fichier texte.  Ces p√©riph√©riques sont appel√©s <strong>p√©riph√©riques virtuels,</strong> c'est-√†-dire qu'ils existent exclusivement en m√©moire et non sur disque. </p><br><p>  N'essayez pas d'ouvrir ces fichiers en tant que fichiers texte standard.  Cependant, vous pouvez utiliser ces p√©riph√©riques via des op√©rations d' <code>write()</code> et de <code>read()</code> , dont l'appel sera servi par le pilote de p√©riph√©rique.  Essayons de le faire. </p><br><p>  Ouvrez deux fen√™tres de terminal et entrez <code>tty</code> dans chaque commande.  Cette commande montrera quel appareil TTY dessert le terminal actuellement actif.  Entrez maintenant l' <code>echo "Hello, World!" &gt; /dev/pts/N</code>  <code>echo "Hello, World!" &gt; /dev/pts/N</code> dans la premi√®re fen√™tre de terminal, o√π N est l'index PTS du deuxi√®me p√©riph√©rique de fen√™tre, passez √† la deuxi√®me fen√™tre et vous verrez votre entr√©e √† partir de la premi√®re fen√™tre.  Vous avez maintenant √©crit les donn√©es sur le p√©riph√©rique PTS de la deuxi√®me fen√™tre <em>comme si elles avaient √©t√© effectu√©es par un programme ex√©cut√© sur ce terminal</em> . </p><br><p><img src="https://habrastorage.org/webt/nj/3s/rp/nj3srpuzyahyvukzicfr0b5wnja.png"></p><br><hr><br><h2 id="ustroystvo-psevdoterminala">  Dispositif pseudo-terminal </h2><br><p>  Nous nous rapprochons de plus en plus de la derni√®re partie de l'article, mais avant cela, nous jetons un ≈ìil ¬´sous le capot¬ª de Linux - consid√©rons le p√©riph√©rique du pseudo-terminal au niveau du noyau.  Il y aura beaucoup de code, mais j'essaierai d'expliquer chaque bloc de code donn√© avec autant de d√©tails que possible, de r√©duire les d√©tails sans importance et d'aller en s√©quence. </p><br><p>  Avant de commencer, nous vous pr√©sentons le soi-disant "panier de composants".  Au fur et √† mesure que nous progressons dans le c≈ìur, nous y ajouterons de plus en plus de composants et trouverons une connexion entre eux.  J'esp√®re que cela vous aidera √† mieux comprendre le dispositif pseudo-terminal.  Commen√ßons. </p><br><p>  Lorsque Linux d√©marre, il charge les pilotes de p√©riph√©riques n√©cessaires.  Notre pseudo-terminal dispose √©galement d'un tel pilote.  Son enregistrement commence par un appel √† cette fonction: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __init pty_init(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { legacy_pty_init(); unix98_pty_init(); <span class="hljs-comment"><span class="hljs-comment">// &lt;- ,    return 0; } device_initcall(pty_init); // ,      </span></span></code> </pre> <br><p>  Pour tous les syst√®mes modernes, la fonction <code>unix98_pty_init()</code> sera appel√©e: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __init unix98_pty_init(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { ptm_driver = tty_alloc_driver(NR_UNIX98_PTY_MAX, TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_DEVPTS_MEM | TTY_DRIVER_DYNAMIC_ALLOC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(ptm_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't allocate Unix98 ptm driver"</span></span>); pts_driver = tty_alloc_driver(NR_UNIX98_PTY_MAX, TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_DEVPTS_MEM | TTY_DRIVER_DYNAMIC_ALLOC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(pts_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't allocate Unix98 pts driver"</span></span>); ptm_driver-&gt;driver_name = <span class="hljs-string"><span class="hljs-string">"pty_master"</span></span>; ptm_driver-&gt;name = <span class="hljs-string"><span class="hljs-string">"ptm"</span></span>; ptm_driver-&gt;major = UNIX98_PTY_MASTER_MAJOR; ptm_driver-&gt;minor_start = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;type = TTY_DRIVER_TYPE_PTY; ptm_driver-&gt;subtype = PTY_TYPE_MASTER; ptm_driver-&gt;init_termios = tty_std_termios; ptm_driver-&gt;init_termios.c_iflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_oflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_cflag = B38400 | CS8 | CREAD; ptm_driver-&gt;init_termios.c_lflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_ispeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; ptm_driver-&gt;init_termios.c_ospeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; ptm_driver-&gt;other = pts_driver; tty_set_operations(ptm_driver, &amp;ptm_unix98_ops); pts_driver-&gt;driver_name = <span class="hljs-string"><span class="hljs-string">"pty_slave"</span></span>; pts_driver-&gt;name = <span class="hljs-string"><span class="hljs-string">"pts"</span></span>; pts_driver-&gt;major = UNIX98_PTY_SLAVE_MAJOR; pts_driver-&gt;minor_start = <span class="hljs-number"><span class="hljs-number">0</span></span>; pts_driver-&gt;type = TTY_DRIVER_TYPE_PTY; pts_driver-&gt;subtype = PTY_TYPE_SLAVE; pts_driver-&gt;init_termios = tty_std_termios; pts_driver-&gt;init_termios.c_cflag = B38400 | CS8 | CREAD; pts_driver-&gt;init_termios.c_ispeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; pts_driver-&gt;init_termios.c_ospeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; pts_driver-&gt;other = ptm_driver; tty_set_operations(pts_driver, &amp;pty_unix98_ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty_register_driver(ptm_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register Unix98 ptm driver"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty_register_driver(pts_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register Unix98 pts driver"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Now create the /dev/ptmx special device */</span></span> tty_default_fops(&amp;ptmx_fops); ptmx_fops.open = ptmx_open; cdev_init(&amp;ptmx_cdev, &amp;ptmx_fops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cdev_add(&amp;ptmx_cdev, <span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>) || register_chrdev_region(<span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"/dev/ptmx"</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register /dev/ptmx driver"</span></span>); device_create(tty_class, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">"ptmx"</span></span>);</code> </pre> <br><p>  Ici, nous sommes int√©ress√©s par 3 choses: </p><br><ol><li>  Appelle <code>tty_set_operatons</code> pour le pilote ma√Ætre pty et les p√©riph√©riques esclaves pty. </li><li>  La fonction <code>ptmx_open</code> , qui est responsable de la cr√©ation des deux parties du pseudo-terminal lors de l'ouverture du p√©riph√©rique sp√©cial <em>/ dev / ptmx</em> .  Important: / dev / ptmx n'est pas un p√©riph√©rique PTM, mais juste une interface pour cr√©er un nouveau pseudo-terminal. </li><li>  Enregistrez les pilotes de p√©riph√©rique PTM et PTS. </li></ol><br><p>  Allons dans l'ordre: </p><br><h4 id="1-tty_set_operations">  1. tty_set_operations </h4><br><p>  La fonction <strong>tty_set_operations ()</strong> configure simplement une table de fonctions pour le pilote actuel: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_set_operations(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations *op) { driver-&gt;ops = op; };</code> </pre> <br><p>  La structure <strong>tty_operations</strong> est une table de fonctions utilis√©e pour acc√©der aux fonctions du pilote TTY du p√©riph√©rique. </p><br><p>  Je vais souligner la chose la plus importante dans les structures <code>pty_unix98_ops</code> et <code>ptm_unix98_ops</code> , qui sont le tableau des fonctions pour les parties correspondantes du pseudo-terminal: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations ptm_unix98_ops = { .install = pty_unix98_install, .remove = pty_unix98_remove, .open = pty_open, .close = pty_close, .write = pty_write, <span class="hljs-comment"><span class="hljs-comment">// ... }; static const struct tty_operations pty_unix98_ops = { .install = pty_unix98_install, .remove = pty_unix98_remove, .open = pty_open, .close = pty_close, .write = pty_write, // ... };</span></span></code> </pre> <br><p>  Ici, vous pouvez observer la fonction pty_write, <code>pty_write</code> est d√©j√† famili√®re dans l'article sur Sishny printf - nous y reviendrons un peu plus tard. </p><br><p>  Ajoutons cette structure √† notre panier de composants: <br><img src="https://habrastorage.org/webt/o8/e-/kc/o8e-kcpqestn7f481gcx38qmzuo.jpeg"></p><br><p>  Comme vous pouvez le voir, les principales m√©thodes des deux pilotes ne sont pas du tout diff√©rentes.  Soit dit en passant, notez qu'il n'y a pas de fonction pour l'op√©ration read () - il n'y a rien de tel que <code>pty_read()</code> .  Le fait est que la lecture sera servie uniquement par discipline de ligne.  Ainsi, nous d√©couvrons la deuxi√®me caract√©ristique importante de la discipline de ligne - la lecture de donn√©es √† partir d'un appareil TTY. </p><br><hr><br><h4 id="2-ptmx_open">  2. ptmx_open </h4><br><p>  Passons maintenant √† <strong>ptmx_open ()</strong> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ptmx_open(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> inode *inode, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *filp) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; <span class="hljs-comment"><span class="hljs-comment">//    -   ! fsi = devpts_acquire(filp); //     devpts index = devpts_new_index(fsi); //       /dev/pts // ... tty = tty_init_dev(ptm_driver, index); // ... devpts_pty_new(fsi, index, tty-&gt;link); //     /dev/pts retval = ptm_driver-&gt;ops-&gt;open(tty, filp); //  PTM ,   }</span></span></code> </pre> <br><p>  Nous nous int√©ressons √† la fonction <code>tty_init_dev()</code> , o√π le premier argument est le pilote de p√©riph√©rique PTM et le second est l'index de p√©riph√©rique.  Ici, nous quittons la zone de responsabilit√© du pilote PTY et allons dans le fichier, qui n'est responsable que des appareils TTY g√©n√©raux et ne sait rien de notre pseudo-terminal. </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty_init_dev(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; tty = alloc_tty_struct(driver, idx); retval = tty_driver_install_tty(driver, tty); <span class="hljs-comment"><span class="hljs-comment">/* * Structures all installed ... call the ldisc open routines. */</span></span> retval = tty_ldisc_setup(tty, tty-&gt;link); <span class="hljs-comment"><span class="hljs-comment">//  ,       return tty; }</span></span></code> </pre> <br><p>  Tout d'abord, nous <code>alloc_tty_struct()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *alloc_tty_struct(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; tty = kzalloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*tty), GFP_KERNEL); <span class="hljs-comment"><span class="hljs-comment">//  tty_struct tty_ldisc_init(tty) //      tty_struct tty-&gt;driver = driver; //       tty_struct tty-&gt;ops = driver-&gt;ops; //        tty_struct.     tty-&gt;index = idx; //   tty  return tty; }</span></span></code> </pre> <br><p>  La seule chose qui nous int√©resse ici est la fonction <code>tty_ldisc_init()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_ldisc_init(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld = tty_ldisc_get(tty, N_TTY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(ld)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PTR_ERR(ld); tty-&gt;ldisc = ld; <span class="hljs-comment"><span class="hljs-comment">//        tty_struct return 0; }</span></span></code> </pre> <br><p>  Qui appelle <code>tty_ldisc_get()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *tty_ldisc_get(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> disc) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld; <span class="hljs-comment"><span class="hljs-comment">//    struct tty_ldisc_ops *ldops; //     ldops = get_ldops(disc); //      .   ,       .   - N_TTY ld = kmalloc(sizeof(struct tty_ldisc), GFP_KERNEL | __GFP_NOFAIL); ld-&gt;ops = ldops; //       ld-&gt;tty = tty; //    tty_struct   .          return ld; }</span></span></code> </pre> <br><p>  Nous avons donc examin√© l'appel √† la fonction <code>alloc_tty_struct()</code> , qui cr√©e la structure <em>tty_struct</em> avec la discipline de ligne - la structure <em>tty_ldisc</em> .  Les deux structures sont li√©es l'une √† l'autre.  Examinons de plus pr√®s ces structures. </p><br><ul><li>  <strong>tty_struct</strong> est une structure permettant d'acc√©der au pilote de p√©riph√©rique TTY et √† d'autres champs.  Cela ressemble √† ceci: </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver; <span class="hljs-comment"><span class="hljs-comment">//  TTY  const struct tty_operations *ops; //  .    ,   driver-&gt;ops,       int index; //   struct tty_ldisc *ldisc; //     struct tty_struct *link; //     PTY // ... }</span></span></code> </pre> <br><ul><li>  <strong>tty_ldisc</strong> est la structure de la discipline de la ligne TTY de l'appareil.  Il se compose de seulement deux champs et se pr√©sente comme suit: </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc_ops *ops; <span class="hljs-comment"><span class="hljs-comment">//    struct tty_struct *tty; //   tty_struct  .       };</span></span></code> </pre> <br><p>  Cela ne semble rien de compliqu√©?  Ajoutons toutes les structures consid√©r√©es jusqu'√† pr√©sent √† notre panier et relions-les de la m√™me mani√®re qu'elles sont connect√©es dans le code: <br><img src="https://habrastorage.org/webt/1d/bt/n4/1dbtn4m_6c6i4n7oaohoguci2m0.jpeg" alt=" tty_struct" title="Construire tty_struct"></p><br><p>  Mais nous avons cr√©√© tty_struct juste pour le p√©riph√©rique PTM.  Et l'appareil PTS?  Pour ce faire, nous revenons √† la fonction <code>tty_init_dev()</code> et rappelons que l'on est alors cens√© appeler la fonction <code>tty_driver_install_tty()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This method is responsible * for ensuring any need additional structures are allocated and configured. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_driver_install_tty(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> driver-&gt;ops-&gt;install ? driver-&gt;ops-&gt;install(driver, tty) : tty_standard_install(driver, tty); }</code> </pre> <br><p>  Le commentaire nous dit que cette m√©thode est responsable de la cr√©ation de diverses structures suppl√©mentaires.  Appareil PTS et sera notre structure suppl√©mentaire.  J'avoue, c'√©tait extr√™mement surprenant pour moi, car c'est l'enfer, tout l'appareil, et pas seulement une sorte de structure suppl√©mentaire!  Mais nous comprenons tous que tous les appareils ne sont qu'une sorte de structure, alors passez √† autre chose.  Ok, qu'est-ce que <em>driver-&gt; ops-&gt; installer ici</em> ?  Pour ce faire, consultez √† nouveau le tableau des fonctions du pilote PTM: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations ptm_unix98_ops = { .install = pty_unix98_install, <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br><p>  Et nous comprenons que nous sommes int√©ress√©s par la fonction <code>pty_unix98_install()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_unix98_install(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pty_common_install(driver, tty, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><p>  Qui appelle la fonction <code>pty_common_install()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_common_install(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> legacy) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *o_tty; <span class="hljs-comment"><span class="hljs-comment">// tty_struct    PTY -    PTS  //    ,       install.   ,   PTM     tty_struct,        if (driver-&gt;subtype != PTY_TYPE_MASTER) return -EIO; o_tty = alloc_tty_struct(driver-&gt;other, idx); tty-&gt;link = o_tty; o_tty-&gt;link = tty; }</span></span></code> </pre> <br><p>  ,   PTS       <em>tty_struct</em>   ,       PTS .           .  tty_struct  PTS    . </p><br><hr><br><h4 id="registraciya-drayvera">   </h4><br><p>        ,           TTY  (   -         ?). <br>  ‚Äî  ,       PTM,   PTS : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file_operations tty_fops = { .llseek = no_llseek, .read = tty_read, .write = tty_write, .poll = tty_poll, .unlocked_ioctl = tty_ioctl, .compat_ioctl = tty_compat_ioctl, .open = tty_open, .release = tty_release, .fasync = tty_fasync, .show_fdinfo = tty_show_fdinfo, };</code> </pre> <br><p>         ,                  TTY . </p><br><hr><br><p> .      ,       <em>/dev/ptmx</em> .  ,   PTS ,      ,   PTM ,      : </p><br><p><img src="https://habrastorage.org/webt/5w/aw/rg/5wawrgbqqw1_llmi1r8g2kbwrzc.jpeg" title=" PTY"></p><br><hr><br><h2 id="hello-world">  Bonjour tout le monde! </h2><br><p>        .          "Hello, World!",        . </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><span class="hljs-meta"> void main() { printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Hello, World!\n"</span></span></span><span class="hljs-meta">); }</span></span></code> </pre> <br><p> ,   "Hello, World!"    .   ,    ,  ,       .    ,    .  stdout  <em>/dev/null</em> ‚Äî       .          ,       Linux. </p><br><p>      Unix        <em>write()</em> , <em>read()</em> , <em>close()</em>  ,    write()  /dev/pts/0         <code>__vfs_write()</code> : </p><br><pre> <code class="objectivec hljs">ssize_t __vfs_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *buf, size_t count, loff_t *pos) { ssize_t ret; <span class="hljs-comment"><span class="hljs-comment">//... ret = file-&gt;f_op-&gt;write(file, buf, count, pos); //... return ret; }</span></span></code> </pre> <br><p>     write()      .   ,            : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file_operations tty_fops = { <span class="hljs-comment"><span class="hljs-comment">// ... .write = tty_write, // ...</span></span></code> </pre> <br><p>  <code>tty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ssize_t tty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *buf, size_t count, loff_t *ppos) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty = file_tty(file); <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld; ssize_t ret; ld = tty_ldisc_ref_wait(tty); ret = do_tty_write(ld-&gt;ops-&gt;write, tty, file, buf, count); tty_ldisc_deref(ld); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br><p>     <em>tty_struct</em>    TTY ,           write()  .       : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc_ops n_tty_ops = { .write = n_tty_write, <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>    <code>n_tty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * n_tty_write - write function for tty * @tty: tty device * @file: file object * @buf: userspace buffer pointer * @nr: size of I/O */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ssize_t n_tty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf, size_t nr) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *b = buf; <span class="hljs-comment"><span class="hljs-comment">// b - ,       "Hello, World!".          int c; //    //     PTS ,  write()    0,  ,     while (nr &gt; 0) { c = tty-&gt;ops-&gt;write(tty, b, nr); //  write()       TTY  if (!c) break; b += c; //     nr -= c; //      :  -  -  -  } }</span></span></code> </pre> <br><p> ,  "Hello, World!"    write()   PTS .       : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations pty_unix98_ops = { .write = pty_write, <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  <code>pty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *to = tty-&gt;link; <span class="hljs-comment"><span class="hljs-comment">//      PTY.    -  PTM  if (c &gt; 0) { //    PTM  c = tty_insert_flip_string(to-&gt;port, buf, c); //     ,       if (c) { tty_flip_buffer_push(to-&gt;port); tty_wakeup(tty); } } return c; }</span></span></code> </pre> <br><p>          : </p><br><pre> <code class="objectivec hljs"> __vfs_write() -&gt; <span class="hljs-comment"><span class="hljs-comment">// 1- :   tty_write() -&gt; do_tty_write() -&gt; n_tty_write() -&gt; // 2- :   pty_write() // 3- : </span></span></code> </pre> <br><p>     . ,       PTM . ,    . </p><br><p>  ,          <em>flip buffer</em> . <strong>Flip buffer</strong> ‚Äî   ,    .  tty driver   ,      .   ,              .      ,        ,       .     ,      ,            .  -        flip buffer ‚Äî       (,    -  ,         flip). </p><br><p>          ,       .  <code>tty_insert_flip_string()</code>         <code>tty_insert_flip_string_fixed_flag()</code> ,           PTM : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_insert_flip_string_fixed_flag(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *chars, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> flag, size_t size) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> copied = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> goal = min_t(size_t, size - copied, TTY_BUFFER_PAGE); <span class="hljs-comment"><span class="hljs-comment">//      int space = __tty_buffer_request_room(port, goal, flags); //     struct tty_buffer *tb = port-&gt;buf.tail; //       if (unlikely(space == 0)) break; memcpy(char_buf_ptr(tb, tb-&gt;used), chars, space); //      tb-&gt;used += space; copied += space; chars += space; /* There is a small chance that we need to split the data over several buffers. If this is the case we must loop */ } while (unlikely(size &gt; copied)); return copied; }</span></span></code> </pre> <br><p>   , flip buffer        ,       ,         .        ,   ‚Äî        PTM ,             . </p><br><p> ,   "Hello, World!"   PTM .    GNOME Terminal Server    <em>poll()</em> (  I/O)        master .  ,         ?  Peu importe comment.      ,     ,      ‚Äî        . </p><br><p>            <code>tty_flip_buffer_push()</code> (   pty_write): </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * tty_flip_buffer_push - terminal * @port: tty port to push * * Queue a push of the terminal flip buffers to the line discipline. * Can be called from IRQ/atomic context. * * In the event of the queue being busy for flipping the work will be * held off and retried later. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_flip_buffer_push(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port) { tty_schedule_flip(port); }</code> </pre> <br><p>  <code>tty_schedule_flip()</code> ,   ,        : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * tty_schedule_flip - push characters to ldisc * @port: tty port to push from * * Takes any pending buffers and transfers their ownership to the * ldisc side of the queue. It then schedules those characters for * processing by the line discipline. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_schedule_flip(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_bufhead *buf = &amp;port-&gt;buf; <span class="hljs-comment"><span class="hljs-comment">/* paired w/ acquire in flush_to_ldisc(); ensures * flush_to_ldisc() sees buffer data. */</span></span> smp_store_release(&amp;buf-&gt;tail-&gt;commit, buf-&gt;tail-&gt;used); queue_work(system_unbound_wq, &amp;buf-&gt;work); }</code> </pre> <br><p>   ,     <em>work</em> (,   -       )       ,      ‚Äî    ,    <code>flush_to_ldisc()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> flush_to_ldisc(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> work_struct *work) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port = container_of(work, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port, buf.work); <span class="hljs-comment"><span class="hljs-comment">//   tty_port PTM . tty_port -       TTY  struct tty_bufhead *buf = &amp;port-&gt;buf; struct tty_buffer *head = buf-&gt;head; // ... receive_buf(port, head); // ... }</span></span></code> </pre> <br><p>  <code>receive_buf()</code>          <code>__receive_buf()</code> ,      : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __receive_buf(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *fp, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> n_tty_data *ldata = tty-&gt;disc_data; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> preops = I_ISTRIP(tty) || (I_IUCLC(tty) &amp;&amp; L_IEXTEN(tty)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;real_raw) n_tty_receive_buf_real_raw(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;raw || (L_EXTPROC(tty) &amp;&amp; !preops)) n_tty_receive_buf_raw(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty-&gt;closing &amp;&amp; !L_EXTPROC(tty)) n_tty_receive_buf_closing(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;lnext) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> flag = TTY_NORMAL; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fp) flag = *fp++; n_tty_receive_char_lnext(tty, *cp++, flag); count--; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!preops &amp;&amp; !I_PARMRK(tty)) n_tty_receive_buf_fast(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> n_tty_receive_buf_standard(tty, cp, fp, count); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (read_cnt(ldata)) { kill_fasync(&amp;tty-&gt;fasync, SIGIO, POLL_IN); wake_up_interruptible_poll(&amp;tty-&gt;read_wait, EPOLLIN); } }</code> </pre> <br><p>  ,   <em>n_tty_receive_buf</em> ( ,    _raw)           <strong>read_buf</strong> ,         TTY .      PTM    raw ,           read_buf. ,        PTM  PTS ,     . </p><br><p>       ,   : </p><br><pre> <code class="objectivec hljs"> ... pty_write() -&gt; <span class="hljs-comment"><span class="hljs-comment">// 3- :  PTS  tty_insert_flip_string + tty_flip_buffer_push() -&gt; tty_schedule_flip() -&gt; --- //    PTM  flush_to_ldisc() -&gt; // 2- :   PTM  receive_buf() -&gt; n_tty_receive_buf -&gt; n_tty_receive_buf_common -&gt; __receive_buf()</span></span></code> </pre> <br><p> ,   PTM        ‚Äî         PTS . </p><br><p>  :       PTM .  GNOME Terminal Server      "Hello, World!",  read()  PTM .  read()    write()    ‚Äî  <code>n_tty_read()</code> .      ,  ,          ‚Äî <em>read_buf</em> ‚Äî   .  GNOME Terminal Server    X Server,     . </p><br><p>  ,   "Hello, World!"   : </p><br><pre> <code class="plaintext hljs"> -&gt; PTY slave -&gt; PTY master -&gt; GNOME-TERMINAl-SERVER -&gt; X Server -&gt; -&gt; </code> </pre> <br><hr><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  .     : </p><br><ol><li>     </li><li>     </li><li>   TTY  </li><li>    </li><li>    ,         </li></ol><br><p>   ,   !     -  ‚Äî     ,   ! </p><br><h3 id="istochniki">  Les sources </h3><br><ul><li> Linux man pages </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://unix.stackexchange.com/q/96694/346664</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://unix.stackexchange.com/q/93531/346664</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://unix.stackexchange.com/q/117981/346664</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://askubuntu.com/q/506510</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.linusakesson.net/programming/tty/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://spin0r.wordpress.com/2012/12/28/terminally-confused-part-seven/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://habr.com/ru/company/neobit/blog/330764/</a> </li><li>  Advanced Programming in the UNIX Environment, 3rd Edition </li></ul><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460257/">https://habr.com/ru/post/fr460257/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460247/index.html">Recettes pour ELF</a></li>
<li><a href="../fr460249/index.html">Solution de la t√¢che avec pwnable.kr 07 - entr√©e. Comprendre pwntools</a></li>
<li><a href="../fr460251/index.html">Stupidit√© artificielle: un bot qui ne m'a pas aid√©</a></li>
<li><a href="../fr460253/index.html">10 raisons de faire vos comp√©tences d'assistant vocal</a></li>
<li><a href="../fr460255/index.html">Backdoor sur Node.js: pourquoi, pourquoi et comment cela fonctionne</a></li>
<li><a href="../fr460259/index.html">Qu'est-ce que la conception UI et UX? Qu'est-ce qui est commun et diff√©rent?</a></li>
<li><a href="../fr460261/index.html">Amazon: 25 ans de succ√®s dans le commerce √©lectronique</a></li>
<li><a href="../fr460263/index.html">Faire une recherche vraiment intelligente: guide √©tape par √©tape</a></li>
<li><a href="../fr460265/index.html">Cr√©er un mod√®le de projet Xcode</a></li>
<li><a href="../fr460273/index.html">Autorisation dans Apple Pay pour le plus petit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>