<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öïÔ∏è üë©üèΩ‚Äçü§ù‚Äçüë©üèº üèûÔ∏è Soporte para instrucciones espec√≠ficas de hardware en .NET Core (ahora no solo SIMD) ü§î üåö ‚è∫Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 


 Hace unos a√±os, decidimos que era hora de admitir el c√≥digo SIMD en .NET . Introdujimos el espacio de nombres System.Numerics con los...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Soporte para instrucciones espec√≠ficas de hardware en .NET Core (ahora no solo SIMD)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/467663/"><h2 id="vvedenie">  Introduccion </h2><br><p> Hace unos a√±os, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">decidimos que era hora de admitir el c√≥digo SIMD en .NET</a> .  Introdujimos el espacio de nombres <code>System.Numerics</code> con los tipos <code>Vector2</code> , <code>Vector3</code> , <code>Vector4</code> y <code>Vector&lt;T&gt;</code> .  Estos tipos representan una API de prop√≥sito general para crear, acceder y manipular instrucciones vectoriales siempre que sea posible.  Tambi√©n proporcionan compatibilidad de software para aquellos casos en los que el hardware no admite instrucciones adecuadas.  Esto permiti√≥, con una refactorizaci√≥n m√≠nima, vectorizar varios algoritmos.  Sea como fuere, la generalidad de este enfoque hace que sea dif√≠cil de aplicar para aprovechar al m√°ximo todas las instrucciones vectoriales disponibles en el hardware moderno.  Adem√°s, el hardware moderno proporciona una serie de instrucciones especializadas, no vectoriales, que pueden mejorar significativamente el rendimiento.  En este art√≠culo, hablar√© sobre c√≥mo eludimos estas limitaciones en .NET Core 3.0. </p><br><p><img src="https://habrastorage.org/webt/4d/mx/lt/4dmxlt8xgnpgncvellsujvoe_rk.jpeg"><br>  <strong>Nota: Todav√≠a</strong> <em>no hay un t√©rmino establecido para la traducci√≥n de <strong>Intrisics</strong> .</em>  <em>Al final del art√≠culo hay un voto para la opci√≥n de traducci√≥n.</em>  <em>Si elegimos una buena opci√≥n, cambiaremos el art√≠culo.</em> </p><a name="habracut"></a><br><h2 id="chto-takoe-vstroennye-funkcii">  ¬øCu√°les son las funciones integradas? </h2><br><p>  En .NET Core 3.0, agregamos una nueva funcionalidad llamada funciones <em>integradas espec√≠ficas de hardware</em> (WF lejano).  Esta <em>funcionalidad</em> proporciona acceso a muchas instrucciones de hardware espec√≠ficas que no pueden representarse simplemente mediante mecanismos de prop√≥sito m√°s general.  Se diferencian de las instrucciones SIMD existentes en que no tienen un prop√≥sito general (los nuevos <em>WF</em> no son multiplataforma y su arquitectura no proporciona compatibilidad de software).  En cambio, proporcionan directamente la plataforma y la funcionalidad espec√≠fica del hardware para los desarrolladores de .NET.  Las funciones SIMD existentes, por ejemplo, multiplataforma, proporcionan compatibilidad de software, y se abstraen ligeramente del hardware subyacente.  Esta abstracci√≥n puede ser costosa, adem√°s, puede evitar la divulgaci√≥n de alguna funcionalidad (cuando, por ejemplo, la funcionalidad no existe o es dif√≠cil de emular en todas las plataformas de destino). </p><br><p>  Las nuevas <em>funciones integradas</em> y los tipos compatibles se encuentran en el <code>System.Runtime.Intrinsics</code> .  Para .NET Core 3.0, por el momento, hay un <code>System.Runtime.Intrinsics.X86</code> .  Estamos trabajando para admitir <em>funciones integradas</em> para otras plataformas como <code>System.Runtime.Intrinsics.Arm</code> . </p><br><p>  Bajo espacios de nombres espec√≠ficos de la plataforma, los <em>WF</em> se agrupan en clases que representan grupos de instrucciones de hardware l√≥gicamente integradas (a menudo llamadas arquitectura de conjunto de instrucciones (ISA)).  Cada clase proporciona una propiedad <code>IsSupported</code> indica si el hardware en el que se ejecuta el c√≥digo admite este conjunto de instrucciones.  Adem√°s, cada clase contiene un conjunto de m√©todos asignados a un conjunto correspondiente de instrucciones.  A veces hay una subclase adicional que corresponde a una parte del mismo conjunto de instrucciones, que puede estar limitada (admitida) por hardware espec√≠fico.  Por ejemplo, la clase <code>Lzcnt</code> proporciona acceso a <em>instrucciones para contar los ceros a la izquierda</em> .  Tiene una subclase llamada <code>X64</code> , que contiene la forma de estas instrucciones utilizadas solo en m√°quinas con arquitectura de 64 bits. </p><br><p>  Algunas de estas clases son naturalmente de naturaleza jer√°rquica.  Por ejemplo, si <code>Lzcnt.X64.IsSupported</code> devuelve verdadero, entonces <code>Lzcnt.IsSupported</code> tambi√©n deber√≠a devolver verdadero, ya que esta es una subclase expl√≠cita.  O, por ejemplo, si <code>Sse2.IsSupported</code> devuelve verdadero, entonces <code>Sse.IsSupported</code> deber√≠a devolver verdadero, porque <code>Sse2</code> hereda expl√≠citamente de <code>Sse</code> .  Sin embargo, vale la pena se√±alar que la similitud de los nombres de clase no es un indicador de su pertenencia a la misma jerarqu√≠a de herencia.  Por ejemplo, <code>Bmi2</code> no se hereda de <code>Bmi1</code> , por lo que los valores devueltos por <code>IsSupported</code> para estos dos conjuntos de instrucciones ser√°n diferentes.  El principio fundamental en el desarrollo de estas clases fue la presentaci√≥n expl√≠cita de las especificaciones ISA.  SSE2 requiere soporte para SSE1, por lo que las clases que los representan est√°n relacionadas por herencia.  Al mismo tiempo, BMI2 no requiere soporte para BMI1, por lo que no utilizamos la herencia.  El siguiente es un ejemplo de la API anterior. </p><br><pre> <code class="plaintext hljs">namespace System.Runtime.Intrinsics.X86 { public abstract class Sse { public static bool IsSupported { get; } public static Vector128&lt;float&gt; Add(Vector128&lt;float&gt; left, Vector128&lt;float&gt; right); // Additional APIs public abstract class X64 { public static bool IsSupported { get; } public static long ConvertToInt64(Vector128&lt;float&gt; value); // Additional APIs } } public abstract class Sse2 : Sse { public static new bool IsSupported { get; } public static Vector128&lt;byte&gt; Add(Vector128&lt;byte&gt; left, Vector128&lt;byte&gt; right); // Additional APIs public new abstract class X64 : Sse.X64 { public static bool IsSupported { get; } public static long ConvertToInt64(Vector128&lt;double&gt; value); // Additional APIs } } }</code> </pre> <br><p>  Puede ver m√°s en el c√≥digo fuente en los siguientes enlaces <a href="">source.dot.net o dotnet / coreclr en GitHub</a> </p><br><p>  <code>IsSupported</code> compilador JIT procesa las comprobaciones <code>IsSupported</code> como constantes de tiempo de ejecuci√≥n (cuando la optimizaci√≥n est√° habilitada), por lo que no necesita compilaci√≥n cruzada para admitir m√∫ltiples ISA, plataformas o arquitecturas.  En cambio, solo necesita escribir el c√≥digo usando expresiones <code>if</code> , como resultado de las ramas de c√≥digo no utilizadas (es decir, aquellas ramas a las que no se puede acceder debido al valor de la variable en la declaraci√≥n condicional) se descartar√°n cuando se genere el c√≥digo nativo. </p><br><p>  Es importante que la verificaci√≥n del <code>IsSupported</code> correspondiente preceda al uso de los comandos de hardware integrados.  Si no hay tal verificaci√≥n, entonces el c√≥digo que usa comandos espec√≠ficos de plataforma que se ejecutan en plataformas / arquitecturas donde estos comandos no son compatibles generar√° una excepci√≥n de tiempo de ejecuci√≥n <code>PlatformNotSupportedException</code> . </p><br><h2 id="kakie-preimuschestva-oni-dayut">  ¬øQu√© beneficios brindan? </h2><br><p>  Por supuesto, <em>las funciones integradas espec√≠ficas del hardware</em> no <em>son</em> para todos, pero pueden usarse para mejorar el rendimiento en operaciones cargadas de c√°lculos.  <code>CoreFX</code> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>ML.NET</code></a> utilizan estos m√©todos para acelerar operaciones como copiar en la memoria, buscar el √≠ndice de un elemento en una matriz o cadena, cambiar el tama√±o de una imagen o trabajar con vectores / matrices / tensores.  La vectorizaci√≥n manual de alg√∫n c√≥digo que result√≥ ser un cuello de botella tambi√©n puede ser m√°s simple de lo que parece.  La vectorizaci√≥n del c√≥digo, de hecho, es realizar varias operaciones a la vez, en general, utilizando instrucciones SIMD (un flujo de instrucciones, flujo de datos m√∫ltiples). </p><br><p>  Antes de decidirse a vectorizar alg√∫n c√≥digo, debe llevar a cabo la creaci√≥n de perfiles para asegurarse de que este c√≥digo sea realmente parte del "punto caliente" (y, por lo tanto, su optimizaci√≥n dar√° un aumento significativo en el rendimiento).  Tambi√©n es importante llevar a cabo la creaci√≥n de perfiles en cada etapa de la vectorizaci√≥n, ya que la vectorizaci√≥n de no todo el c√≥digo conduce a una mayor productividad. </p><br><h2 id="vektorizaciya-prostogo-algoritma">  Vectorizaci√≥n de un algoritmo simple </h2><br><p>  Para ilustrar el uso de <em>funciones incorporadas,</em> tomamos el algoritmo para sumar todos los elementos de una matriz o rango.  Este tipo de c√≥digo es un candidato ideal para la vectorizaci√≥n, porque  en cada iteraci√≥n, se realiza la misma operaci√≥n trivial. </p><br><p>  Un ejemplo de implementaci√≥n de dicho algoritmo puede tener el siguiente aspecto: </p><br><pre> <code class="plaintext hljs">public int Sum(ReadOnlySpan&lt;int&gt; source) { int result = 0; for (int i = 0; i &lt; source.Length; i++) { result += source[i]; } return result; }</code> </pre> <br><p>  Este c√≥digo es bastante simple y directo, pero al mismo tiempo lo suficientemente lento para datos de entrada grandes, como  realiza solo una operaci√≥n trivial por iteraci√≥n. </p><br><pre> <code class="plaintext hljs">BenchmarkDotNet=v0.11.5, OS=Windows 10.0.18362 AMD Ryzen 7 1800X, 1 CPU, 16 logical and 8 physical cores .NET Core SDK=3.0.100-preview9-013775 [Host] : .NET Core 3.0.0-preview9-19410-10 (CoreCLR 4.700.19.40902, CoreFX 4.700.19.40917), 64bit RyuJIT [AttachedDebugger] DefaultJob : .NET Core 3.0.0-preview9-19410-10 (CoreCLR 4.700.19.40902, CoreFX 4.700.19.40917), 64bit RyuJIT</code> </pre> <br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Cuenta </th><th>  Media </th><th>  Error </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Suma </td><td>  1 </td><td>  2.477 ns </td><td>  0,0192 ns </td><td>  0,0179 ns </td></tr><tr><td>  Suma </td><td>  2 </td><td>  2.164 ns </td><td>  0.0265 ns </td><td>  0.0235 ns </td></tr><tr><td>  Suma </td><td>  4 4 </td><td>  3.224 ns </td><td>  0,0302 ns </td><td>  0,0267 ns </td></tr><tr><td>  Suma </td><td>  8 </td><td>  4.347 ns </td><td>  0.0665 ns </td><td>  0.0622 ns </td></tr><tr><td>  Suma </td><td>  16 </td><td>  8.444 ns </td><td>  0.2042 ns </td><td>  0.3734 ns </td></tr><tr><td>  Suma </td><td>  32 </td><td>  13.963 ns </td><td>  0.2182 ns </td><td>  0.2041 ns </td></tr><tr><td>  Suma </td><td>  64 </td><td>  50.374 ns </td><td>  0.2955 ns </td><td>  0.2620 ns </td></tr><tr><td>  Suma </td><td>  128 </td><td>  60,139 ns </td><td>  0.3890 ns </td><td>  0.3639 ns </td></tr><tr><td>  Suma </td><td>  256 </td><td>  106.416 ns </td><td>  0.6404 ns </td><td>  0.5990 ns </td></tr><tr><td>  Suma </td><td>  512 </td><td>  291.450 ns </td><td>  3.5148 ns </td><td>  3.2878 ns </td></tr><tr><td>  Suma </td><td>  1024 </td><td>  574.243 ns </td><td>  9.5851 ns </td><td>  8.4970 ns </td></tr><tr><td>  Suma </td><td>  2048 </td><td>  1 137.819 ns </td><td>  5.9363 ns </td><td>  5.5529 ns </td></tr><tr><td>  Suma </td><td>  4096 </td><td>  2 228.341 ns </td><td>  22.8882 ns </td><td>  21.4097 ns </td></tr><tr><td>  Suma </td><td>  8192 </td><td>  2 973.040 ns </td><td>  14.2863 ns </td><td>  12.6644 ns </td></tr><tr><td>  Suma </td><td>  16384 </td><td>  5 883.504 ns </td><td>  15.9619 ns </td><td>  14.9308 ns </td></tr><tr><td>  Suma </td><td>  32768 </td><td>  11 699,237 ns </td><td>  104.0970 ns </td><td>  97,3724 ns </td></tr></tbody></table></div><br><h2 id="povyshenie-proizvoditelnosti-za-schet-razvertyvaniya-ciklov">  Aumente la productividad a trav√©s de los ciclos de implementaci√≥n </h2><br><p>  Los procesadores modernos tienen varias opciones para mejorar el rendimiento del c√≥digo.  Para aplicaciones de subproceso √∫nico, una de esas opciones es realizar varias operaciones primitivas en un solo ciclo de procesador. </p><br><p>  La mayor√≠a de los procesadores modernos pueden realizar cuatro operaciones de adici√≥n en un ciclo de reloj (en condiciones √≥ptimas), como resultado de lo cual, con el "dise√±o" correcto del c√≥digo, a veces puede mejorar el rendimiento, incluso en una implementaci√≥n de subproceso √∫nico. </p><br><p>  Aunque JIT puede realizar el desenrollado de bucles por s√≠ solo, JIT es conservador al tomar este tipo de decisi√≥n, debido al tama√±o del c√≥digo generado.  Por lo tanto, puede ser ventajoso implementar un bucle, en c√≥digo, manualmente. </p><br><p>  Puede expandir el bucle en el c√≥digo anterior de la siguiente manera: </p><br><pre> <code class="plaintext hljs">public unsafe int SumUnrolled(ReadOnlySpan&lt;int&gt; source) { int result = 0; int i = 0; int lastBlockIndex = source.Length - (source.Length % 4); // Pin source so we can elide the bounds checks fixed (int* pSource = source) { while (i &lt; lastBlockIndex) { result += pSource[i + 0]; result += pSource[i + 1]; result += pSource[i + 2]; result += pSource[i + 3]; i += 4; } while (i &lt; source.Length) { result += pSource[i]; i += 1; } } return result; }</code> </pre> <br><p>  Este c√≥digo es un poco m√°s complicado, pero hace un mejor uso de las caracter√≠sticas del hardware. </p><br><p>  Para bucles realmente peque√±os, este c√≥digo se ejecuta un poco m√°s lento.  Pero esta tendencia ya est√° cambiando para los datos de entrada de ocho elementos, despu√©s de lo cual la velocidad de ejecuci√≥n comienza a aumentar (el tiempo de ejecuci√≥n del c√≥digo optimizado, para 32 mil elementos, es un 26% menor que el tiempo de la versi√≥n original).  Vale la pena se√±alar que dicha optimizaci√≥n no siempre aumenta la productividad.  Por ejemplo, cuando se trabaja con colecciones con elementos de tipo <code>float</code> versi√≥n "implementada" del algoritmo tiene casi la misma velocidad que la original.  Por lo tanto, es muy importante llevar a cabo la creaci√≥n de perfiles. </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Cuenta </th><th>  Media </th><th>  Error </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Sumunrolled </td><td>  1 </td><td>  2.922 ns </td><td>  0.0651 ns </td><td>  0,0609 ns </td></tr><tr><td>  Sumunrolled </td><td>  2 </td><td>  3.576 ns </td><td>  0,0116 ns </td><td>  0.0109 ns </td></tr><tr><td>  Sumunrolled </td><td>  4 4 </td><td>  3.708 ns </td><td>  0,0157 ns </td><td>  0,0139 ns </td></tr><tr><td>  Sumunrolled </td><td>  8 </td><td>  4.832 ns </td><td>  0,0486 ns </td><td>  0,0454 ns </td></tr><tr><td>  Sumunrolled </td><td>  16 </td><td>  7.490 ns </td><td>  0.1131 ns </td><td>  0.1058 ns </td></tr><tr><td>  Sumunrolled </td><td>  32 </td><td>  11.277 ns </td><td>  0.0910 ns </td><td>  0.0851 ns </td></tr><tr><td>  Sumunrolled </td><td>  64 </td><td>  19.761 ns </td><td>  0.2016 ns </td><td>  0.1885 ns </td></tr><tr><td>  Sumunrolled </td><td>  128 </td><td>  36,639 ns </td><td>  0.3043 ns </td><td>  0.2847 ns </td></tr><tr><td>  Sumunrolled </td><td>  256 </td><td>  77,969 ns </td><td>  0.8409 ns </td><td>  0.7866 ns </td></tr><tr><td>  Sumunrolled </td><td>  512 </td><td>  146.357 ns </td><td>  1.3209 ns </td><td>  1.2356 ns </td></tr><tr><td>  Sumunrolled </td><td>  1024 </td><td>  287.354 ns </td><td>  0.9223 ns </td><td>  0.8627 ns </td></tr><tr><td>  Sumunrolled </td><td>  2048 </td><td>  566,405 ns </td><td>  4.0155 ns </td><td>  3.5596 ns </td></tr><tr><td>  Sumunrolled </td><td>  4096 </td><td>  1 131.016 ns </td><td>  7.3601 ns </td><td>  6.5246 ns </td></tr><tr><td>  Sumunrolled </td><td>  8192 </td><td>  2 259.836 ns </td><td>  8.6539 ns </td><td>  8.0949 ns </td></tr><tr><td>  Sumunrolled </td><td>  16384 </td><td>  4 501.295 ns </td><td>  6.4186 ns </td><td>  6.0040 ns </td></tr><tr><td>  Sumunrolled </td><td>  32768 </td><td>  8 979.690 ns </td><td>  19.5265 ns </td><td>  18.2651 ns </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4b7/180/775/4b71807758bdae4be2fba1eb6af8360b.png"></p><br><h2 id="povyshenie-proizvoditelnosti-za-schet-vektorizacii-ciklov">  Aumente la productividad a trav√©s de la vectorizaci√≥n de bucle </h2><br><p>  Sea como fuere, pero a√∫n podemos optimizar ligeramente este c√≥digo.  Las instrucciones SIMD son otra opci√≥n proporcionada por los procesadores modernos para mejorar el rendimiento.  Usando una sola instrucci√≥n, le permiten realizar varias operaciones en un solo ciclo de reloj.  Esto puede ser mejor que el despliegue de bucle directo, porque, de hecho, se hace lo mismo, pero con una menor cantidad de c√≥digo generado. </p><br><p>  Para aclarar, cada operaci√≥n de adici√≥n, en un ciclo desplegado, toma 4 bytes.  Por lo tanto, necesitamos 16 bytes para 4 operaciones de suma en forma expandida.  Al mismo tiempo, la instrucci√≥n de adici√≥n SIMD tambi√©n realiza 4 operaciones de adici√≥n, pero solo toma 4 bytes.  Esto significa que tenemos menos instrucciones para la CPU.  Adem√°s de esto, en el caso de una instrucci√≥n SIMD, la CPU puede hacer <em>suposiciones</em> y realizar optimizaciones, pero esto est√° m√°s all√° del alcance de este art√≠culo.  Lo que es a√∫n mejor es que los procesadores modernos pueden ejecutar m√°s de una instrucci√≥n SIMD a la vez, es decir, en algunos casos, puede aplicar una estrategia mixta, al mismo tiempo realizar una exploraci√≥n de ciclo parcial y vectorizaci√≥n. </p><br><p>  En general, debe comenzar mirando la clase de prop√≥sito general de <code>Vector&lt;T&gt;</code> para sus tareas.  √âl, como los nuevos <em>WF</em> , incorporar√° instrucciones SIMD, pero al mismo tiempo, dada la versatilidad de esta clase, puede reducir la cantidad de codificaci√≥n "manual". </p><br><p>  El c√≥digo podr√≠a verse as√≠: </p><br><pre> <code class="plaintext hljs">public int SumVectorT(ReadOnlySpan&lt;int&gt; source) { int result = 0; Vector&lt;int&gt; vresult = Vector&lt;int&gt;.Zero; int i = 0; int lastBlockIndex = source.Length - (source.Length % Vector&lt;int&gt;.Count); while (i &lt; lastBlockIndex) { vresult += new Vector&lt;int&gt;(source.Slice(i)); i += Vector&lt;int&gt;.Count; } for (int n = 0; n &lt; Vector&lt;int&gt;.Count; n++) { result += vresult[n]; } while (i &lt; source.Length) { result += source[i]; i += 1; } return result; }</code> </pre> <br><p>  Este c√≥digo funciona m√°s r√°pido, pero nos vemos obligados a referirnos a cada elemento por separado al calcular la cantidad final.  Adem√°s, <code>Vector&lt;T&gt;</code> no tiene un tama√±o definido con precisi√≥n y puede variar, dependiendo del equipo en el que se ejecuta el c√≥digo.  <em>Las funciones integradas espec√≠ficas del hardware</em> proporcionan una funcionalidad adicional que puede mejorar ligeramente este c√≥digo y hacerlo un poco m√°s r√°pido (a costa de la complejidad del c√≥digo adicional y los requisitos de mantenimiento). </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Cuenta </th><th>  Media </th><th>  Error </th><th>  Stddev </th></tr></thead><tbody><tr><td>  SumVectorT </td><td>  1 </td><td>  4.517 ns </td><td>  0,0752 ns </td><td>  0,0703 ns </td></tr><tr><td>  SumVectorT </td><td>  2 </td><td>  4.853 ns </td><td>  0,0609 ns </td><td>  0.0570 ns </td></tr><tr><td>  SumVectorT </td><td>  4 4 </td><td>  5.047 ns </td><td>  0,0909 ns </td><td>  0.0850 ns </td></tr><tr><td>  SumVectorT </td><td>  8 </td><td>  5.671 ns </td><td>  0,0251 ns </td><td>  0,0223 ns </td></tr><tr><td>  SumVectorT </td><td>  16 </td><td>  6.579 ns </td><td>  0.0330 ns </td><td>  0,0276 ns </td></tr><tr><td>  SumVectorT </td><td>  32 </td><td>  10.460 ns </td><td>  0,0241 ns </td><td>  0,0226 ns </td></tr><tr><td>  SumVectorT </td><td>  64 </td><td>  17.148 ns </td><td>  0,0407 ns </td><td>  0,0381 ns </td></tr><tr><td>  SumVectorT </td><td>  128 </td><td>  23.239 ns </td><td>  0.0853 ns </td><td>  0,0756 ns </td></tr><tr><td>  SumVectorT </td><td>  256 </td><td>  62,146 ns </td><td>  0.8319 ns </td><td>  0.7782 ns </td></tr><tr><td>  SumVectorT </td><td>  512 </td><td>  114.863 ns </td><td>  0.4175 ns </td><td>  0.3906 ns </td></tr><tr><td>  SumVectorT </td><td>  1024 </td><td>  172.129 ns </td><td>  1.8673 ns </td><td>  1.7467 ns </td></tr><tr><td>  SumVectorT </td><td>  2048 </td><td>  429.722 ns </td><td>  1.0461 ns </td><td>  0.9786 ns </td></tr><tr><td>  SumVectorT </td><td>  4096 </td><td>  654.209 ns </td><td>  3.6215 ns </td><td>  3.0241 ns </td></tr><tr><td>  SumVectorT </td><td>  8192 </td><td>  1 675.046 ns </td><td>  14.5231 ns </td><td>  13.5849 ns </td></tr><tr><td>  SumVectorT </td><td>  16384 </td><td>  2 514.778 ns </td><td>  5.3369 ns </td><td>  4.9921 ns </td></tr><tr><td>  SumVectorT </td><td>  32768 </td><td>  6.689.829 ns </td><td>  13.9947 ns </td><td>  13.0906 ns </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/00e/0be/5d4/00e0be5d469067af095f34beccf8c45c.png"></p><br><p>  <em>NOTA</em> Para este art√≠culo, <code>COMPlus_SIMD16ByteOnly=1</code> tama√±o del <code>Vector&lt;T&gt;</code> igual a 16 bytes usando el par√°metro de configuraci√≥n interna ( <code>COMPlus_SIMD16ByteOnly=1</code> ).  Este ajuste normaliz√≥ los resultados al comparar <code>SumVectorT</code> con <code>SumVectorizedSse</code> , y nos permiti√≥ mantener el c√≥digo simple.  En particular, evit√≥ escribir un salto condicional <code>if (Avx2.IsSupported) { }</code> .  Este c√≥digo es casi id√©ntico al c√≥digo para <code>Sse2</code> , pero trata con <code>Vector256&lt;T&gt;</code> (32 bytes) y procesa a√∫n m√°s elementos en una iteraci√≥n del bucle. </p><br><p>  Por lo tanto, utilizando las nuevas <em>funciones integradas</em> , el c√≥digo puede reescribirse de la siguiente manera: </p><br><pre> <code class="plaintext hljs">public int SumVectorized(ReadOnlySpan&lt;int&gt; source) { if (Sse2.IsSupported) { return SumVectorizedSse2(source); } else { return SumVectorT(source); } } public unsafe int SumVectorizedSse2(ReadOnlySpan&lt;int&gt; source) { int result; fixed (int* pSource = source) { Vector128&lt;int&gt; vresult = Vector128&lt;int&gt;.Zero; int i = 0; int lastBlockIndex = source.Length - (source.Length % 4); while (i &lt; lastBlockIndex) { vresult = Sse2.Add(vresult, Sse2.LoadVector128(pSource + i)); i += 4; } if (Ssse3.IsSupported) { vresult = Ssse3.HorizontalAdd(vresult, vresult); vresult = Ssse3.HorizontalAdd(vresult, vresult); } else { vresult = Sse2.Add(vresult, Sse2.Shuffle(vresult, 0x4E)); vresult = Sse2.Add(vresult, Sse2.Shuffle(vresult, 0xB1)); } result = vresult.ToScalar(); while (i &lt; source.Length) { result += pSource[i]; i += 1; } } return result; }</code> </pre> <br><p>  Este c√≥digo, una vez m√°s, es un poco m√°s complicado, pero es significativamente m√°s r√°pido para todos, excepto para los conjuntos de entrada m√°s peque√±os.  Para 32 mil elementos, este c√≥digo se ejecuta un 75% m√°s r√°pido que el ciclo expandido y un 81% m√°s r√°pido que el c√≥digo fuente del ejemplo. </p><br><p>  Not√≥ que escribimos algunos controles <code>IsSupported</code> .  El primero verifica si el hardware actual es compatible con el conjunto requerido de <em>funciones incorporadas</em> ; de lo contrario, la optimizaci√≥n se realiza mediante una combinaci√≥n de barrido y <code>Vector&lt;T&gt;</code> .  La √∫ltima opci√≥n se seleccionar√° para plataformas como ARM / ARM64 que no admiten el conjunto de instrucciones requerido, o si el conjunto se ha deshabilitado para la plataforma.  La segunda prueba <code>IsSupported</code> , en el m√©todo <code>SumVectorizedSse2</code> , se utiliza para una optimizaci√≥n adicional si el hardware admite el <code>Ssse3</code> instrucciones <code>Ssse3</code> . </p><br><p>  De lo contrario, la mayor parte de la l√≥gica es esencialmente la misma que para el bucle expandido.  <code>Vector128&lt;T&gt;</code> es un tipo de 128 bits que contiene elementos <code>Vector128&lt;T&gt;.Count</code> .  En este caso, <code>uint</code> , que en s√≠ mismo es de 32 bits, puede tener 4 elementos (128/32), as√≠ es como lanzamos el bucle. </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Cuenta </th><th>  Media </th><th>  Error </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Sumvectorizado </td><td>  1 </td><td>  4.555 ns </td><td>  0,0192 ns </td><td>  0,0179 ns </td></tr><tr><td>  Sumvectorizado </td><td>  2 </td><td>  4.848 ns </td><td>  0,0147 ns </td><td>  0,0137 ns </td></tr><tr><td>  Sumvectorizado </td><td>  4 4 </td><td>  5.381 ns </td><td>  0.0210 ns </td><td>  0,0186 ns </td></tr><tr><td>  Sumvectorizado </td><td>  8 </td><td>  4.838 ns </td><td>  0.0209 ns </td><td>  0,0186 ns </td></tr><tr><td>  Sumvectorizado </td><td>  16 </td><td>  5.107 ns </td><td>  0,0175 ns </td><td>  0,0146 ns </td></tr><tr><td>  Sumvectorizado </td><td>  32 </td><td>  5.646 ns </td><td>  0.0230 ns </td><td>  0,0204 ns </td></tr><tr><td>  Sumvectorizado </td><td>  64 </td><td>  6.763 ns </td><td>  0,0338 ns </td><td>  0.0316 ns </td></tr><tr><td>  Sumvectorizado </td><td>  128 </td><td>  9.308 ns </td><td>  0.1041 ns </td><td>  0.0870 ns </td></tr><tr><td>  Sumvectorizado </td><td>  256 </td><td>  15.634 ns </td><td>  0.0927 ns </td><td>  0.0821 ns </td></tr><tr><td>  Sumvectorizado </td><td>  512 </td><td>  34,706 ns </td><td>  0.2851 ns </td><td>  0.2381 ns </td></tr><tr><td>  Sumvectorizado </td><td>  1024 </td><td>  68.110 ns </td><td>  0.4016 ns </td><td>  0.3756 ns </td></tr><tr><td>  Sumvectorizado </td><td>  2048 </td><td>  136.533 ns </td><td>  1.3104 ns </td><td>  1.2257 ns </td></tr><tr><td>  Sumvectorizado </td><td>  4096 </td><td>  277.930 ns </td><td>  0.5913 ns </td><td>  0.5531 ns </td></tr><tr><td>  Sumvectorizado </td><td>  8192 </td><td>  554.720 ns </td><td>  3.5133 ns </td><td>  3.2864 ns </td></tr><tr><td>  Sumvectorizado </td><td>  16384 </td><td>  1 110.730 ns </td><td>  3.3043 ns </td><td>  3.0909 ns </td></tr><tr><td>  Sumvectorizado </td><td>  32768 </td><td>  2 200.996 ns </td><td>  21.0538 ns </td><td>  19,6938 ns </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/311/e70/320/311e7032050337fe946103244e749076.png"></p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>  Las nuevas <em>funciones integradas le</em> brindan la oportunidad de aprovechar la funcionalidad espec√≠fica del hardware de la m√°quina en la que ejecuta el c√≥digo.  Hay aproximadamente 1,500 API para X86 y X64 distribuidas en 15 conjuntos, hay demasiadas para describir en un art√≠culo.  Al perfilar el c√≥digo para identificar cuellos de botella, puede determinar la parte del c√≥digo que se beneficia de la vectorizaci√≥n y observar un aumento de rendimiento bastante bueno.  Hay muchos escenarios en los que se puede aplicar la vectorizaci√≥n y el despliegue de bucles es solo el comienzo. </p><br><p>  Cualquiera que quiera ver m√°s ejemplos puede buscar el uso de <em>funciones integradas</em> en el marco (ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dotnet</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aspnet</a> ), o en otros art√≠culos de la comunidad.  Y aunque los <em>WF</em> actuales son vastos, todav√≠a hay mucha funcionalidad que debe introducirse.  Si tiene la funcionalidad que desea presentar, no dude en registrar su solicitud de API a trav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dotnet / corefx en GitHub</a> .  El proceso de revisi√≥n de API se describe <a href="">aqu√≠</a> y hay un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">buen ejemplo</a> de una plantilla de solicitud de API especificada en el paso 1. </p><br><h2 id="osobye-blagodarnosti">  Agradecimiento especial </h2><br><p>  Me gustar√≠a expresar un agradecimiento especial a los miembros de nuestra comunidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fei Peng (@fiigii)</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jacek Blaszczynski (@ 4creators)</a> por su ayuda en la implementaci√≥n del <em>WF</em> , as√≠ como a todos los miembros de la comunidad por sus valiosos comentarios sobre el desarrollo, implementaci√≥n y facilidad de uso de esta funcionalidad. </p><br><hr><br><h3 id="posleslovie-k-perevodu">  Ep√≠logo de la traducci√≥n </h3><br><p>  Me gusta observar el desarrollo de la plataforma .NET y, en particular, el lenguaje C #.  Viniendo del mundo de C ++, y con poca experiencia en desarrollo en Delphi y Java, me sent√≠ muy c√≥modo comenzando a escribir programas en C #.  En 2006, este lenguaje de programaci√≥n (el lenguaje en s√≠) me pareci√≥ m√°s conciso y pr√°ctico que Java en el mundo de la recolecci√≥n de basura administrada y multiplataforma.  Por lo tanto, mi elecci√≥n recay√≥ en C #, y no me arrepent√≠.  La primera etapa en la evoluci√≥n de un lenguaje fue simplemente su apariencia.  Para 2006, C # absorbi√≥ todo lo mejor que hab√≠a en ese momento en los mejores lenguajes y plataformas: C ++ / Java / Delphi.  En 2010, F # se hizo p√∫blico.  Era una plataforma experimental para estudiar el paradigma funcional con el objetivo de introducirlo en el mundo de .NET.  El resultado de los experimentos fue la siguiente etapa en la evoluci√≥n de C #: la expansi√≥n de sus capacidades hacia el FP, a trav√©s de la introducci√≥n de funciones an√≥nimas, expresiones lambda y, en √∫ltima instancia, LINQ.  Esta extensi√≥n del lenguaje convirti√≥ a C # en el lenguaje de prop√≥sito general m√°s avanzado, desde mi punto de vista.  El siguiente paso evolutivo se relacion√≥ con el apoyo a la concurrencia y la asincron√≠a.  Tarea / Tarea &lt;T&gt;, todo el concepto de TPL, el desarrollo de LINQ - PLINQ y, por √∫ltimo, as√≠ncrono / espera.  ,   - ,       .NET   C# ‚Äî      .    Span&lt;T&gt;  Memory&lt;T&gt;, ValueTask/ValueTask&lt;T&gt;, IAsyncDispose, ref readonly struct   in,  foreach, IO.Streams.         GC    .   ,       ‚Äî       .  ,     .NET   C#,  ,          .   (       )         . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467663/">https://habr.com/ru/post/467663/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467653/index.html">Habrastatistics: an√°lisis de comentarios de los lectores</a></li>
<li><a href="../467655/index.html">C√≥mo pas√© el verano con C # 8</a></li>
<li><a href="../467657/index.html">Inventario de la I a la Z. Contamos las licencias de software</a></li>
<li><a href="../467659/index.html">Acelere significativamente la ejecuci√≥n de tareas con el ejemplo de configuraci√≥n adicional de la memoria HyperX FURY DDR4 actualizada</a></li>
<li><a href="../467661/index.html">Dos√≠metro para Seryozha. Parte I. Polimaster - Nuclide Hunters</a></li>
<li><a href="../467665/index.html">Carro para camiones ROS. Parte 5. Trabajando en rviz y gazebo: xacro, nuevos sensores</a></li>
<li><a href="../467667/index.html">Planificaci√≥n de proyectos de organizaci√≥n (Parte 4)</a></li>
<li><a href="../467669/index.html">M√≠rame completo: aprovecha al m√°ximo el video en vivo en plataformas m√≥viles</a></li>
<li><a href="../467671/index.html">Computadora retro NLX</a></li>
<li><a href="../467673/index.html">Funciones Go integradas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>