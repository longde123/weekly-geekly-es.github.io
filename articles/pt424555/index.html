<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçß ‚õ≤Ô∏è üê¨ Manual do Node.js., Parte 7: Programa√ß√£o ass√≠ncrona üèÇüèº üë©üèª‚Äç‚úàÔ∏è ü¶ã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoje, na tradu√ß√£o da s√©tima parte do manual do Node.js., falaremos sobre programa√ß√£o ass√≠ncrona, consideraremos quest√µes como o uso de retornos de cha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manual do Node.js., Parte 7: Programa√ß√£o ass√≠ncrona</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424555/">  Hoje, na tradu√ß√£o da s√©tima parte do manual do Node.js., falaremos sobre programa√ß√£o ass√≠ncrona, consideraremos quest√µes como o uso de retornos de chamada, promessas e a constru√ß√£o ass√≠ncrona / aguardada, al√©m de discutir o trabalho com eventos. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Aconselhamos a ler] Outras partes do ciclo</b> <div class="spoiler_text">  Parte 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Informa√ß√µes gerais e introdu√ß√£o</a> <br>  Parte 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JavaScript, V8, alguns truques de desenvolvimento</a> <br>  Parte 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hospedagem, REPL, trabalho com o console, m√≥dulos</a> <br>  Parte 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">arquivos npm, package.json e package-lock.json</a> <br>  Parte 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">npm e npx</a> <br>  Parte 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">loop de eventos, pilha de chamadas, temporizadores</a> <br>  Parte 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Programa√ß√£o ass√≠ncrona</a> <br>  Parte 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia Node.js, Parte 8: Protocolos HTTP e WebSocket</a> <br>  Parte 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia Node.js, parte 9: trabalhando com o sistema de arquivos</a> <br>  Parte 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia do Node.js, Parte 10: M√≥dulos padr√£o, fluxos, bancos de dados, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PDF completo do Guia Node.js.</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Assincronia em linguagens de programa√ß√£o</font> </h2><br>  O pr√≥prio JavaScript √© uma linguagem de programa√ß√£o s√≠ncrona e de thread √∫nico.  Isso significa que voc√™ n√£o pode criar novos threads no c√≥digo que s√£o executados em paralelo.  No entanto, os computadores s√£o inerentemente ass√≠ncronos.  Ou seja, certas a√ß√µes podem ser executadas independentemente do fluxo de execu√ß√£o do programa principal.  Nos computadores modernos, cada programa recebe uma certa quantidade de tempo do processador; quando esse tempo acaba, o sistema fornece recursos para outro programa, tamb√©m por um tempo.  Tais comuta√ß√µes s√£o realizadas ciclicamente, s√£o feitas t√£o rapidamente que uma pessoa simplesmente n√£o consegue perceber, como resultado, pensamos que nossos computadores executam muitos programas simultaneamente.  Mas isso √© uma ilus√£o (para n√£o mencionar m√°quinas multiprocessadoras). <br><br>  Nas entranhas dos programas s√£o utilizadas interrup√ß√µes - sinais transmitidos ao processador e permitindo atrair a aten√ß√£o do sistema.  N√£o entraremos em detalhes, o mais importante √© lembrar que o comportamento ass√≠ncrono, quando o programa √© pausado at√© o momento em que precisa de recursos do processador, √© completamente normal.  No momento em que o programa n√£o carrega o sistema com trabalho, o computador pode resolver outros problemas.  Por exemplo, com essa abordagem, quando um programa est√° aguardando uma resposta a uma solicita√ß√£o de rede feita a ele, ele n√£o bloqueia o processador at√© que uma resposta seja recebida. <br><br>  Como regra, as linguagens de programa√ß√£o s√£o ass√≠ncronas, algumas delas d√£o ao programador a capacidade de controlar mecanismos ass√≠ncronos, usando as ferramentas de linguagem incorporadas ou as bibliotecas especializadas.  Estamos falando de linguagens como C, Java, C #, PHP, Go, Ruby, Swift, Python.  Alguns deles permitem programar em estilo ass√≠ncrono, usando threads, iniciando novos processos. <br><br><h2>  <font color="#3AC1EF">Assincronia do JavaScript</font> </h2><br>  Como j√° mencionado, o JavaScript √© uma linguagem s√≠ncrona de thread √∫nico.  As linhas de c√≥digo escritas em JS s√£o executadas na ordem em que aparecem no texto, uma ap√≥s a outra.  Por exemplo, aqui est√° um programa JS muito normal que demonstra esse comportamento: <br><br><pre><code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = a * b console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(c) doSomething()</code> </pre> <br>  Mas o JavaScript foi criado para uso em navegadores.  Sua principal tarefa, desde o in√≠cio, era organizar o processamento de eventos relacionados √†s atividades do usu√°rio.  Por exemplo, s√£o eventos como <code>onClick</code> , <code>onMouseOver</code> , <code>onChange</code> , <code>onSubmit</code> e assim por diante.  Como resolver esses problemas dentro da estrutura de um modelo de programa√ß√£o s√≠ncrona? <br><br>  A resposta est√° no ambiente em que o JavaScript √© executado.  Nomeadamente, o navegador permite resolver efetivamente esses problemas, fornecendo ao programador as APIs apropriadas. <br><br>  No ambiente do Node.js, existem ferramentas para executar opera√ß√µes de E / S sem bloqueio, como trabalhar com arquivos, organizar a troca de dados em uma rede e assim por diante. <br><br><h2>  <font color="#3AC1EF">Retornos de chamada</font> </h2><br>  Se falamos de JavaScript baseado em navegador, pode-se notar que √© imposs√≠vel saber com anteced√™ncia quando o usu√°rio clica em um bot√£o.  Para garantir que o sistema responda a esse evento, um manipulador √© criado para ele. <br><br>  O manipulador de eventos aceita uma fun√ß√£o que ser√° chamada quando o evento ocorrer.  √â assim: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    })</code> </pre> <br>  Essas fun√ß√µes tamb√©m s√£o chamadas de fun√ß√µes de retorno de chamada ou retornos de chamada. <br><br>  Um retorno de chamada √© uma fun√ß√£o regular que √© passada como um valor para outra fun√ß√£o.  Ele ser√° chamado apenas quando um determinado evento ocorrer.  JavaScript implementa o conceito de fun√ß√µes de primeira classe.  Tais fun√ß√µes podem ser atribu√≠das a vari√°veis ‚Äã‚Äãe passadas para outras fun√ß√µes (chamadas fun√ß√µes de ordem superior). <br><br>  No desenvolvimento JavaScript do lado do cliente, a abordagem √© difundida quando todo o c√≥digo do cliente √© agrupado em um ouvinte do evento <code>load</code> de um objeto de <code>window</code> , que chama o retorno de chamada passado para ele depois que a p√°gina est√° pronta para o trabalho: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     })</code> </pre> <br>  Os retornos de chamada s√£o usados ‚Äã‚Äãem todos os lugares, e n√£o apenas para manipular eventos DOM.  Por exemplo, j√° conhecemos seu uso em temporizadores: <br><br><pre> <code class="hljs javascript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   2  }, 2000)</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">As solicita√ß√µes XHR</a> tamb√©m usam retornos de chamada.  Nesse caso, parece atribuir uma fun√ß√£o √† propriedade correspondente.  Uma fun√ß√£o semelhante ser√° chamada quando um determinado evento ocorrer.  No exemplo a seguir, esse evento √© uma altera√ß√£o do estado da solicita√ß√£o: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest() xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.readyState === <span class="hljs-number"><span class="hljs-number">4</span></span>) {   xhr.status === <span class="hljs-number"><span class="hljs-number">200</span></span> ? <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(xhr.responseText) : <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">'error'</span></span>) } } xhr.open(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'https://yoursite.com'</span></span>) xhr.send()</code> </pre> <br><h3>  <font color="#3AC1EF">Handling Tratamento de erros em retornos de chamada</font> </h3><br>  Vamos falar sobre como lidar com erros nos retornos de chamada.  H√° uma estrat√©gia comum para lidar com esses erros, que tamb√©m √© usada no Node.js.  Consiste no fato de que o primeiro par√¢metro de qualquer fun√ß√£o de retorno de chamada √© um objeto de erro.  Se n√£o houver erros, <code>null</code> ser√° gravado neste par√¢metro.  Caso contr√°rio, haver√° um objeto de erro contendo sua descri√ß√£o e informa√ß√µes adicionais sobre ele.  Aqui est√° o que parece: <br><br><pre> <code class="hljs coffeescript">fs.readFile(<span class="hljs-string"><span class="hljs-string">'/file.json'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data) })</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Problema de retorno de chamada</font> </h3><br>  √â conveniente usar retornos de chamada em situa√ß√µes simples.  No entanto, cada retorno de chamada √© um n√≠vel adicional de aninhamento de c√≥digo.  Se v√°rios retornos de chamada aninhados s√£o usados, isso rapidamente leva a uma complica√ß√£o significativa da estrutura do c√≥digo: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {     items.forEach(item =&gt; {       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>,  -      })   }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) }) })</code> </pre> <br>  Neste exemplo, apenas 4 n√≠veis de c√≥digo s√£o mostrados, mas, na pr√°tica, √© poss√≠vel encontrar um grande n√∫mero de n√≠veis, geralmente chamado de "inferno de retorno de chamada".  Voc√™ pode lidar com esse problema usando outras constru√ß√µes de idioma. <br><br><h2>  <font color="#3AC1EF">Promessas e ass√≠ncronas / aguardam</font> </h2><br>  Come√ßando com o padr√£o ES6, o JavaScript apresenta novos recursos que facilitam a grava√ß√£o de c√≥digo ass√≠ncrono, eliminando a necessidade de retornos de chamada.  Estamos falando das promessas que apareceram no ES6 e da constru√ß√£o ass√≠ncrona / aguardada que apareceu no ES8. <br><br><h3>  <font color="#3AC1EF">‚ñç Promessas</font> </h3><br>  Promessas (objetos de promessa) s√£o uma das maneiras de trabalhar com constru√ß√µes de software ass√≠ncronas em JavaScript, o que, em geral, reduz o uso de retornos de chamada. <br><br><h4>  Familiaridade com promessas </h4><br>  As promessas s√£o geralmente definidas como objetos proxy para determinados valores, cuja apar√™ncia √© esperada no futuro.  As promessas tamb√©m s√£o chamadas de "promessas" ou "resultados prometidos".  Embora esse conceito exista h√° muitos anos, as promessas foram padronizadas e adicionadas ao idioma apenas no ES2015.  No ES2017, o design ass√≠ncrono / aguardado, baseado em promessas e que pode ser considerado como uma substitui√ß√£o conveniente, apareceu.  Portanto, mesmo se voc√™ n√£o planeja usar promessas regulares, √© importante entender como elas funcionam para o uso efetivo da constru√ß√£o ass√≠ncrona / aguardada. <br><br><h4>  Como as promessas funcionam </h4><br>  Depois que uma promessa √© chamada, ela entra em um estado pendente.  Isso significa que a fun√ß√£o que causou a promessa continua sendo executada, enquanto alguns c√°lculos s√£o realizados na promessa, ap√≥s o que a promessa informa sobre ela.  Se a opera√ß√£o executada pela promessa for conclu√≠da com √™xito, a promessa ser√° transferida para o estado cumprido.  Diz-se que essa promessa foi resolvida com sucesso.  Se a opera√ß√£o for conclu√≠da com um erro, a promessa ser√° colocada no estado rejeitado. <br><br>  Vamos falar sobre o trabalho com promessas. <br><br><h4>  Criar promessas </h4><br>  A API para trabalhar com promessas nos fornece o construtor correspondente, chamado por um comando no formato <code>new Promise()</code> .  Veja como as promessas s√£o criadas: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isItDoneYet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (done) {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> workDone = <span class="hljs-string"><span class="hljs-string">'Here is the thing I built'</span></span>     resolve(workDone)   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> why = <span class="hljs-string"><span class="hljs-string">'Still working on something else'</span></span>     reject(why)   } } )</code> </pre> <br>  O Promis verifica a constante global <code>done</code> e, se seu valor for <code>true</code> , √© resolvido com sucesso.  Caso contr√°rio, a promessa √© rejeitada.  Usando os par√¢metros de <code>resolve</code> e <code>reject</code> , que s√£o fun√ß√µes, podemos retornar valores da promessa.  Nesse caso, retornamos uma string, mas aqui um objeto pode ser usado. <br><br><h4>  Trabalhar com promessas </h4><br>  Criamos uma promessa acima, agora considere trabalhar com ela.  √â assim: <br><br><pre> <code class="hljs coffeescript">const isItDoneYet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise( <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... ) const checkIfItsDone = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { isItDoneYet   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ok)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ok)   })   .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   }) } checkIfItsDone()</code> </pre> <br>  Chamar <code>checkIfItsDone()</code> levar√° √† execu√ß√£o da <code>isItDoneYet()</code> isItDoneYet <code>isItDoneYet()</code> e √† organiza√ß√£o de aguardar sua resolu√ß√£o.  Se a promessa for resolvida com √™xito, o retorno de chamada passado para o m√©todo <code>.then()</code> funcionar√°.  Se ocorrer um erro, ou seja, a promessa ser√° rejeitada, ela poder√° ser processada na fun√ß√£o passada para o m√©todo <code>.catch()</code> . <br><br><h4>  Promessas de encadeamento </h4><br>  Os m√©todos Promise retornam promessas, o que permite combin√°-las em cadeias.  Um bom exemplo desse comportamento √© a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">busca de API</a> baseada no navegador, que √© uma camada de abstra√ß√£o sobre <code>XMLHttpRequest</code> .  Existe um pacote npm bastante popular para o Node.js que implementa a API de busca, que discutiremos mais adiante.  Essa API pode ser usada para carregar certos recursos de rede e, gra√ßas √† possibilidade de combinar promessas em cadeias, para organizar o processamento subsequente dos dados baixados.  De fato, quando voc√™ chama a API Fetch por meio de uma chamada para a fun√ß√£o <code>fetch()</code> , uma promessa √© criada. <br><br>  Considere o seguinte exemplo de promessas de encadeamento: <br><br><pre> <code class="hljs coffeescript">const fetch = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'node-fetch'</span></span>) const status = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.status &gt;= <span class="hljs-number"><span class="hljs-number">200</span></span> &amp;&amp; response.status &lt; <span class="hljs-number"><span class="hljs-number">300</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.resolve(response) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(response.statusText)) } const json = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span><span class="hljs-function"> =&gt;</span></span> response.json() fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos'</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(status) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(json) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Request succeeded with JSON response'</span></span>, data) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Request failed'</span></span>, error) })</code> </pre> <br>  Aqui, usamos o pacote npm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">node-fetch</a> e o recurso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jsonplaceholder.typicode.com</a> como uma fonte de dados JSON. <br><br>  Neste exemplo, a fun√ß√£o <code>fetch()</code> √© usada para carregar um item da lista TODO usando uma cadeia de promessas.  Ap√≥s executar <code>fetch()</code> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√©</a> retornada uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">resposta</a> que possui muitas propriedades, dentre as quais estamos interessados ‚Äã‚Äãno seguinte: <br><br><ul><li>  <code>status</code> √© um valor num√©rico que representa o c√≥digo de status HTTP. </li><li>  <code>statusText</code> - uma descri√ß√£o textual do c√≥digo de status HTTP, representado pela sequ√™ncia <code>OK</code> se a solicita√ß√£o foi bem-sucedida. </li></ul><br>  O objeto de <code>response</code> possui um m√©todo <code>json()</code> que retorna uma promessa, ap√≥s a resolu√ß√£o da qual o conte√∫do processado do corpo da solicita√ß√£o √© apresentado, apresentado no formato JSON. <br><br>  Dado o exposto, descrevemos o que est√° acontecendo neste c√≥digo.  A primeira promessa na cadeia √© representada pela fun√ß√£o <code>status()</code> que anunciamos, que verifica o status da resposta e, se indica que a solicita√ß√£o falhou (ou seja, o c√≥digo de status HTTP n√£o est√° no intervalo entre 200 e 299), a promessa √© rejeitada.  Essa opera√ß√£o leva ao fato de que outras express√µes <code>.then()</code> na cadeia de promessas n√£o s√£o executadas e chegamos imediatamente ao m√©todo <code>.catch()</code> , emitindo para o console, junto com a mensagem de erro, o texto <code>Request failed</code> . <br><br>  Se o c√≥digo de status HTTP nos conv√©m, a fun√ß√£o <code>json()</code> declarada por n√≥s √© chamada.  Como a promessa anterior, se resolvida com √™xito, retorna um objeto de <code>response</code> , n√≥s o usamos como um valor de entrada para a segunda promessa. <br><br>  Nesse caso, retornamos os dados JSON processados, para que a terceira promessa os receba, ap√≥s o que eles, precedidos de uma mensagem de que, como resultado da solicita√ß√£o, foi poss√≠vel obter os dados necess√°rios, s√£o exibidos no console. <br><br><h4>  Tratamento de erros </h4><br>  No exemplo anterior, t√≠nhamos um m√©todo <code>.catch()</code> anexado a uma cadeia de promessas.  Se algo na cadeia de promessas der errado e ocorrer um erro, ou se uma das promessas for rejeitada, o controle ser√° transferido para a express√£o mais pr√≥xima <code>.catch()</code> .  Aqui est√° a situa√ß√£o em que ocorre um erro em uma promessa: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Aqui est√° um exemplo de acionar <code>.catch()</code> ap√≥s rejeitar uma promessa: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br><h4>  Tratamento de erros em cascata </h4><br>  E se ocorrer um erro na express√£o <code>.catch()</code> ?  Para lidar com esse erro, voc√™ pode incluir outra express√£o <code>.catch()</code> na cadeia de promessas (e, em seguida, anexar tantas <code>.catch()</code> √† cadeia conforme necess√°rio): <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Agora, vamos ver alguns m√©todos √∫teis usados ‚Äã‚Äãpara gerenciar promessas. <br><br><h4>  Promise.all () </h4><br>  Se voc√™ precisar executar alguma a√ß√£o ap√≥s resolver v√°rias promessas, poder√° fazer isso usando o comando <code>Promise.all()</code> .  Considere um exemplo: <br><br><pre> <code class="hljs coffeescript">const f1 = fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos/1'</span></span>) const f2 = fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos/2'</span></span>) Promise.all([f1, f2]).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Array of results'</span></span>, res) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  No ES2015, a sintaxe da atribui√ß√£o destrutiva apareceu; usando-a, voc√™ pode criar constru√ß√µes da seguinte forma: <br><br><pre> <code class="hljs powershell">Promise.all([<span class="hljs-type"><span class="hljs-type">f1</span></span>, <span class="hljs-type"><span class="hljs-type">f2</span></span>]).then(([<span class="hljs-type"><span class="hljs-type">res1</span></span>, <span class="hljs-type"><span class="hljs-type">res2</span></span>]) =&gt; {   console.log(<span class="hljs-string"><span class="hljs-string">'Results'</span></span>, res1, res2) })</code> </pre> <br>  Aqui, como exemplo, consideramos a API Fetch, mas <code>Promise.all()</code> , √© claro, permite que voc√™ trabalhe com todas as promessas. <br><br><h4>  Promise.race () </h4><br>  O comando <code>Promise.race()</code> permite executar a a√ß√£o especificada depois que uma das promessas passadas a ela for resolvida.  O retorno de chamada correspondente que cont√©m os resultados desta primeira promessa √© chamado apenas uma vez.  Considere um exemplo: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-string"><span class="hljs-string">'first'</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-string"><span class="hljs-string">'second'</span></span>) }) <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race([first, second]).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) <span class="hljs-comment"><span class="hljs-comment">// second })</span></span></code> </pre> <br><h4>  Erro TypeError n√£o detectado que ocorre ao trabalhar com promessas </h4><br>  Se, ao trabalhar com promessas, voc√™ encontrar o <code>Uncaught TypeError: undefined is not a promise</code> erro de <code>Uncaught TypeError: undefined is not a promise</code> , verifique se a <code>new Promise()</code> constru√ß√£o <code>new Promise()</code> √© usada em vez de apenas <code>Promise()</code> ao criar promessas. <br><br><h3>  <font color="#3AC1EF">‚ñç design ass√≠ncrono / aguardado</font> </h3><br>  A constru√ß√£o ass√≠ncrona / espera √© uma abordagem moderna da programa√ß√£o ass√≠ncrona, simplificando-a.  As fun√ß√µes ass√≠ncronas podem ser representadas como uma combina√ß√£o de promessas e geradores e, em geral, essa constru√ß√£o √© uma abstra√ß√£o das promessas. <br><br>  O design ass√≠ncrono / espera reduz a quantidade de c√≥digo padr√£o que voc√™ precisa escrever ao trabalhar com promessas.  Quando as promessas apareceram no padr√£o ES2015, elas visavam solucionar o problema de criar c√≥digo ass√≠ncrono.  Eles lidaram com essa tarefa, mas em dois anos, compartilhando a sa√≠da dos padr√µes ES2015 e ES2017, ficou claro que eles n√£o podiam ser considerados a solu√ß√£o final para o problema. <br><br>  Um dos problemas prometidos foi o famoso "inferno de retornos de chamada", mas eles, resolvendo esse problema, criaram seus pr√≥prios problemas de natureza semelhante. <br><br>  Promessas eram constru√ß√µes simples em torno das quais se poderia construir algo com uma sintaxe mais simples.  Como resultado, quando chegou a hora, a constru√ß√£o ass√≠ncrona / aguardada apareceu.  Seu uso permite que voc√™ escreva um c√≥digo que pare√ßa s√≠ncrono, mas √© ass√≠ncrono, em particular, n√£o bloqueia o segmento principal. <br><br><h4>  Como a constru√ß√£o ass√≠ncrona / espera funciona </h4><br>  Uma fun√ß√£o ass√≠ncrona retorna uma promessa, como no exemplo a seguir: <br><br><pre> <code class="hljs coffeescript">const doSomethingAsync = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve)</span></span></span><span class="hljs-function"> =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>)   }) }</code> </pre> <br>  Quando voc√™ precisar chamar uma fun√ß√£o semelhante, dever√° colocar a palavra-chave <code>await</code> antes do comando para cham√°-la.  Isso far√° com que o c√≥digo que est√° aguardando a permiss√£o ou a rejei√ß√£o da promessa correspondente.  Deve-se observar que uma fun√ß√£o que usa a palavra-chave <code>await</code> deve ser declarada usando a <code>async</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) }</code> </pre> <br>  Combine os dois fragmentos de c√≥digo acima e examine seu comportamento: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomethingAsync = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>)   }) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Before'</span></span>) doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'After'</span></span>)</code> </pre> <br>  Este c√≥digo produzir√° o seguinte: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">After</span></span> I did something</code> </pre> <br>  O texto <code>I did something</code> entra no console com um atraso de 3 segundos. <br><br><h4>  Sobre promessas e fun√ß√µes ass√≠ncronas </h4><br>  Se voc√™ declarar uma determinada fun√ß√£o usando a <code>async</code> , isso significa que essa fun√ß√£o retornar√° uma promessa, mesmo que n√£o seja explicitamente feita.  √â por isso que, por exemplo, o exemplo a seguir √© um c√≥digo de trabalho: <br><br><pre> <code class="hljs powershell">const a<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span> } aFunction().then(console.log) //    <span class="hljs-string"><span class="hljs-string">'test'</span></span></code> </pre> <br>  Esse design √© semelhante a este: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aFunction = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'test'</span></span>) } aFunction().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-comment"><span class="hljs-comment">//    'test'</span></span></code> </pre> <br><h4>  Pontos fortes de ass√≠ncrono / aguardar </h4><br>  Analisando os exemplos acima, voc√™ pode ver que o c√≥digo que usa ass√≠ncrono / espera √© mais simples que o c√≥digo que usa o encadeamento de promessas ou c√≥digo baseado em fun√ß√µes de retorno de chamada.  Aqui, √© claro, vimos exemplos muito simples.  Voc√™ pode experimentar completamente os benef√≠cios acima, trabalhando com c√≥digo muito mais complexo.  Aqui, por exemplo, √© como carregar e analisar dados JSON usando promessas: <br><br><pre> <code class="hljs pgsql">const getFirstUserData = () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/users.json'</span></span>) //      .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(response =&gt; response.json()) //  <span class="hljs-type"><span class="hljs-type">JSON</span></span>   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(users =&gt; users[<span class="hljs-number"><span class="hljs-number">0</span></span>]) //      .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(`/users/${<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name}`)) //       .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(userResponse =&gt; userResponse.json()) //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> } getFirstUserData()</code> </pre> <br>  Aqui est√° a apar√™ncia da solu√ß√£o para o mesmo problema usando async / waitit: <br><br><pre> <code class="hljs pgsql">const getFirstUserData = async () =&gt; { const response = await <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/users.json'</span></span>) //    const users = await response.json() //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = users[<span class="hljs-number"><span class="hljs-number">0</span></span>] //    const userResponse = await <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(`/users/${<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name}`) //     const userData = await userResponse.json() //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userData } getFirstUserData()</code> </pre> <br><h4>  Usando sequ√™ncias de fun√ß√µes ass√≠ncronas </h4><br>  Fun√ß√µes ass√≠ncronas podem ser facilmente combinadas em projetos que se assemelham a cadeias Promise.  Os resultados dessa combina√ß√£o, no entanto, s√£o de melhor legibilidade: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promiseToDoSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">10000</span></span>)   }) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> watchOverSomeoneDoingSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> promiseToDoSomething()   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> watchOverSomeoneWatchingSomeoneDoingSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> watchOverSomeoneDoingSomething()   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched as well'</span></span> } watchOverSomeoneWatchingSomeoneDoingSomething().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res) })</code> </pre> <br>  Este c√≥digo produzir√° o seguinte texto: <br><br><pre> <code class="hljs pgsql">I did something <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> I watched <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> I watched <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> well</code> </pre> <br><h4>  Depura√ß√£o simplificada </h4><br>  √â dif√≠cil depurar as promessas, porque, ao us√°-las, voc√™ n√£o pode usar efetivamente as ferramentas usuais do depurador (como "ignorar etapa", ignorar).  O c√≥digo gravado usando async / waitit pode ser depurado usando os mesmos m√©todos que o c√≥digo s√≠ncrono comum. <br><br><h2>  <font color="#3AC1EF">Gera√ß√£o de Eventos no Node.js</font> </h2><br>  Se voc√™ trabalhou com JavaScript em um navegador, sabe que os eventos desempenham um papel importante no tratamento das intera√ß√µes do usu√°rio com as p√°ginas.  Trata-se de manipular eventos causados ‚Äã‚Äãpor cliques e movimentos do mouse, pressionamentos de teclas no teclado e assim por diante.  No Node.js, voc√™ pode trabalhar com eventos que o programador cria sozinho.  Aqui voc√™ pode criar seu pr√≥prio sistema de eventos usando o m√≥dulo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">eventos</a> .  Em particular, este m√≥dulo nos oferece a classe <code>EventEmitter</code> , <code>EventEmitter</code> recursos podem ser usados ‚Äã‚Äãpara organizar o trabalho com eventos.  Antes de usar esse mecanismo, voc√™ precisa conect√°-lo: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EventEmitter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>).EventEmitter</code> </pre> <br>  Ao trabalhar com ele, os m√©todos <code>on()</code> e <code>emit()</code> est√£o dispon√≠veis para n√≥s, entre outros.  O m√©todo de <code>emit</code> usado para chamar eventos.  O m√©todo <code>on</code> √© usado para configurar retornos de chamada, manipuladores de eventos que s√£o chamados quando um determinado evento √© chamado. <br><br>  Por exemplo, vamos criar um evento <code>start</code> .  Quando isso acontecer, produziremos algo no console: <br><br><pre> <code class="hljs coffeescript">eventEmitter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter(); eventEmitter.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'started'</span></span>) })</code> </pre> <br>  Para acionar esse evento, a seguinte constru√ß√£o √© usada: <br><br><pre> <code class="hljs mel">eventEmitter.<span class="hljs-keyword"><span class="hljs-keyword">emit</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>)</code> </pre> <br>  Como resultado da execu√ß√£o desse comando, o manipulador de eventos √© chamado e a sequ√™ncia <code>started</code> chega ao console. <br><br>  Voc√™ pode passar argumentos para o manipulador de eventos, representando-os como argumentos adicionais para o m√©todo <code>emit()</code> : <br><br><pre> <code class="hljs coffeescript">eventEmitter.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">started ${number}</span></span>`) }) eventEmitter.emit(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>)</code> </pre> <br>  O mesmo acontece nos casos em que o manipulador precisa passar v√°rios argumentos: <br><br><pre> <code class="hljs pgsql">eventEmitter.<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) =&gt; { console.log(`started <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ${<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ${<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>}`) }) eventEmitter.emit(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br>  <code>EventEmitter</code> classe <code>EventEmitter</code> t√™m alguns outros m√©todos √∫teis: <br><br><ul><li>  <code>once()</code> - permite registrar um manipulador de eventos que pode ser chamado apenas uma vez. </li><li>  <code>removeListener()</code> - permite remover o manipulador passado a ele da matriz de manipuladores do evento passado a ele. </li><li>  <code>removeAllListeners()</code> - permite remover todos os manipuladores do evento passado para ele. </li></ul><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  Hoje falamos sobre programa√ß√£o ass√≠ncrona em JavaScript, em particular, discutimos retornos de chamada, promessas e a constru√ß√£o ass√≠ncrona / aguardada.  Aqui abordamos a quest√£o de trabalhar com eventos descritos pelo desenvolvedor usando o m√≥dulo de <code>events</code> .  Nosso pr√≥ximo t√≥pico ser√£o os mecanismos de rede da plataforma Node.js. <br><br>  <b>Caros leitores!</b>  Ao programar para o Node.js, voc√™ usa a constru√ß√£o async / waitit? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt424555/">https://habr.com/ru/post/pt424555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt424539/index.html">Java 11: novo em String</a></li>
<li><a href="../pt424541/index.html">Hist√≥ria do fiasco do UGJ 2018: como fazer um jogo que ningu√©m gosta (n√£o fa√ßa isso!)</a></li>
<li><a href="../pt424543/index.html">Java 11 / JDK 11: Disponibilidade Geral</a></li>
<li><a href="../pt424551/index.html">Quente e tubo: cinco balalaikas sobre a tecnologia de √°udio magn√©tico</a></li>
<li><a href="../pt424553/index.html">Guia do Node.js, parte 6: loop de eventos, pilha de chamadas, temporizadores</a></li>
<li><a href="../pt424557/index.html">Guia do Node.js, parte 8: protocolos HTTP e WebSocket</a></li>
<li><a href="../pt424559/index.html">Resist√™ncia ao Big Data 1 ou Joe indescrit√≠vel. Anonimato na Internet, anti-detec√ß√£o, anti-rastreamento para anti-voc√™ e anti-n√≥s</a></li>
<li><a href="../pt424563/index.html">Beeline envia detalhes de conversas para estranhos</a></li>
<li><a href="../pt424565/index.html">Vis√£o geral: digitaliza√ß√£o 3D de instala√ß√µes imobili√°rias</a></li>
<li><a href="../pt424567/index.html">A experi√™ncia de bloquear a publicidade on-line na rede local da empresa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>