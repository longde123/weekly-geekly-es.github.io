<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÉè üëü ü§πüèª O estudo do sistema de arquivos HDD do modelo DVR QCM-08DL üôå üîò ‚ôìÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo √© dedicado ao estudo da estrutura de arquivos do disco r√≠gido de um gravador de v√≠deo de oito canais para fins de extra√ß√£o em massa de arq...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O estudo do sistema de arquivos HDD do modelo DVR QCM-08DL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421933/"><img src="https://habrastorage.org/webt/jl/fy/ud/jlfyudollyahkfmnnmsy0fa-8xu.jpeg"><br><br>  Este artigo √© dedicado ao estudo da estrutura de arquivos do disco r√≠gido de um gravador de v√≠deo de oito canais para fins de extra√ß√£o em massa de arquivos de v√≠deo.  No final do artigo, est√° a implementa√ß√£o do programa correspondente em C. <br><a name="habracut"></a><br>  Gravador de v√≠deo (DVR abreviado) O QCM-08DL √© usado em sistemas de vigil√¢ncia por v√≠deo e permite grava√ß√£o de √°udio e v√≠deo em oito canais.  Este modelo, na minha opini√£o, √© um dos mais baratos e ao mesmo tempo confi√°veis ‚Äã‚Äãem opera√ß√£o.  O formato de compacta√ß√£o de v√≠deo √© o popular formato H264.  Para √°udio, o formato de compacta√ß√£o √© ADPCM.  V√≠deo e √°udio s√£o gravados em um disco r√≠gido SATA (HDD) de computador padr√£o instalado dentro do DVR.  Usando o pr√≥prio DVR, √© poss√≠vel visualizar grava√ß√µes pesquisando-as por data e hora.  Al√©m disso, √© poss√≠vel extrair dados para um arquivo em uma m√≠dia externa.  Em primeiro lugar, a uma unidade USB conectada √† interface USB do DVR.  Em segundo lugar - para o computador atrav√©s da interface WEB do DVR.  O nome do arquivo resultante √© longo e inclui a data de grava√ß√£o, hora de in√≠cio e t√©rmino, canal de grava√ß√£o e outras informa√ß√µes adicionais.  A extens√£o do arquivo √© ".264".  Um exame do conte√∫do desse arquivo deixou claro para mim que o cont√™iner de m√≠dia no qual os fluxos de √°udio e v√≠deo s√£o compactados est√° longe de ser padr√£o.  Esse arquivo pode ser aberto usando o player que acompanha o DVR.  O jogador est√° muito desconfort√°vel.  Mas tamb√©m, voc√™ pode usar o programa repacker no cont√™iner AVI, que tamb√©m est√° inclu√≠do.  Este programa reembala novamente o fluxo de v√≠deo, deixando-o no formato H264.  E o fluxo de som √© convertido de ADMCM para PCM, aumentando em 4 vezes o tamanho.  O resultado √© um arquivo .avi que pode ser reproduzido por qualquer player padr√£o.  Percebo imediatamente que esse programa de reembalagem √© muito inconveniente.  Permite executar opera√ß√µes em apenas um arquivo.  Para reembalar um conjunto de arquivos, voc√™ deve abri-los por vez. <br><br>  As seguintes tarefas foram definidas. <br><br><ol><li>  Obtenha acesso a todos os arquivos .264 no disco r√≠gido do DVR, conectando o disco r√≠gido ao computador. </li><li>  Estudar o algoritmo pelo qual o programa repacker 264-avi padr√£o funciona e criar o mesmo programa que executaria as mesmas opera√ß√µes, mas n√£o em um, mas em um grupo inteiro de arquivos, com um clique. </li></ol><br>  A primeira tarefa, √† primeira vista, pode parecer muito simples: voc√™ s√≥ precisa conectar o disco r√≠gido ao computador e abrir as parti√ß√µes no Explorer.  No entanto, existem armadilhas.  Este artigo √© dedicado √† primeira tarefa. <br><br>  Eu j√° sabia de antem√£o que o shell do software do microcontrolador DVR √© baseado em um sistema operacional semelhante ao Linux.  Portanto, o particionamento do disco r√≠gido provavelmente tamb√©m ser√° semelhante ao Linux.  Portanto, voc√™ precisa de um computador Linux.  No meu caso, a capacidade do disco r√≠gido √© de 1 TB, um computador com OS Xubuntu.  Depois de conectar o disco r√≠gido ao computador, eu consegui ver apenas uma parti√ß√£o por v√°rios gigabytes.  Isso claramente n√£o √© o que voc√™ precisa.  Dentro da se√ß√£o, existem muitas pastas com o formato de nome ‚ÄúAAAA-MM-DD‚Äù correspondentes √†s datas dos registros.  Dentro de cada pasta, existem muitos arquivos correspondentes √†s entradas.  Arquivos com o mesmo nome daqueles obtidos ao extrair do DVR.  No entanto, seu tamanho √© muitas vezes menor e a extens√£o n√£o √© .264, mas .nvr.  Deve-se supor que esses mesmos arquivos nvr s√£o chaves para os 264 arquivos correspondentes (ou seus fluxos de m√≠dia), cujo conte√∫do est√° localizado no espa√ßo principal do disco r√≠gido.  Copiei os dados da pasta do arquivo para um meio separado para futuras pesquisas. <br><br>  Usei muitas ferramentas de software para pesquisa: um editor de disco (tamb√©m √© um editor de arquivos bin√°rios) DiskExplorer (usei o WinHex posteriormente), MS Excel para c√°lculos auxiliares e fixa√ß√£o de resultados, ambiente de programa√ß√£o Dev-C ++ para escrever programas de console auxiliares e finais, etc.  Neste artigo, tentarei falar sobre esse procedimento. <br><br>  Primeiro, observe o primeiro setor do disco r√≠gido (um setor (1 LBA) ocupa 512 bytes).  Este setor, como regra, cont√©m uma estrutura MBR.  Ele inclui um gerenciador de inicializa√ß√£o e uma se√ß√£o b√°sica do sum√°rio.  A estrutura deste setor, bem como a estrutura da descri√ß√£o da se√ß√£o, √© fornecida abaixo (retirada da Wikipedia). <br><br><img src="https://habrastorage.org/webt/yb/x9/iq/ybx9iqnwe7dx7ghojh7xnyfghbm.jpeg"><br><br><img src="https://habrastorage.org/webt/mz/w4/v1/mzw4v1rt6vrfmmrmbbrn2m-ggu0.jpeg"><br><br>  No caso do disco r√≠gido investigado, temos o seguinte.  Observando a figura abaixo e seguindo as tabelas acima, vemos que o carregador de inicializa√ß√£o est√° ausente.  Mas estamos mais interessados ‚Äã‚Äãna tabela de parti√ß√£o.  √â destacado em uma moldura vermelha.  Os √∫ltimos dois bytes (preenchimento azul) - assinatura MBR.  Voc√™ pode ver na tabela de parti√ß√£o que o disco est√° dividido em duas se√ß√µes.  O c√≥digo para o tipo da primeira se√ß√£o (preenchimento amarelo) √© 0x0B.  Esta √© uma parti√ß√£o FAT32.  O c√≥digo para o tipo do segundo (preenchimento laranja) √© 0x83.  Esta √© uma das parti√ß√µes Linux (no sentido de EXT).  Os bytes do c√≥digo do tipo de parti√ß√£o est√£o circulados em azul. <br><br><img src="https://habrastorage.org/webt/ua/2h/l6/ua2hl6viqijfm3qwziadcpf3myi.jpeg"><br><br>  Uma descriptografia completa do setor MBR com uma tabela de se√ß√µes e seus par√¢metros √© fornecida abaixo. <br><br><img src="https://habrastorage.org/webt/h2/mc/8j/h2mc8jovgedyxw1lcswaodx-xoa.jpeg"><br><br>  Prestando aten√ß√£o ao tamanho das parti√ß√µes (contando o n√∫mero de setores em gigabytes), √© f√°cil adivinhar que no computador com o sistema operacional Xubuntu foi a primeira parti√ß√£o que ocupou uma pequena parte do espa√ßo em disco.  A prop√≥sito, no Windows XP, apenas a primeira parti√ß√£o tamb√©m foi exibida, mas n√£o foi aberta no explorer.  E por que, ent√£o, a segunda parti√ß√£o Linux n√£o apareceu no sistema operacional Xubuntu? <br><br>  Tendo estudado anteriormente a estrutura e organiza√ß√£o do sistema de arquivos Linux usando EXT2 como exemplo, comecei a estudar a segunda se√ß√£o. <br><br>  Como voc√™ pode ver na tabela de se√ß√µes, a segunda se√ß√£o come√ßa com o setor 16016805. O manual do sistema de arquivos EXT2 indica a presen√ßa do chamado superbloco, localizado a 1024 bytes desde o in√≠cio da se√ß√£o (ou seja, dois setores desde o in√≠cio).  No entanto, o setor 16016805 + 2 = 16016807 estava vazio.  Mas o primeiro setor 16016805 em sua estrutura parecia um superbloco.  Mas seu conte√∫do n√£o correspondia totalmente √† descri√ß√£o do conte√∫do do superbloco do manual.  O superbloco √© o bloco principal, que cont√©m um tipo de tabela de v√°rias constantes e par√¢metros para o funcionamento do sistema de arquivos: endere√ßos de posi√ß√µes e tamanhos de outros blocos necess√°rios, em particular cabe√ßalhos de registros e diret√≥rios de arquivos.  Mais pesquisas nesta se√ß√£o me levaram a apenas uma conclus√£o: o DVR usa seu pr√≥prio sistema de arquivos. <br><br>  No futuro, decidi olhar para o primeiro setor da primeira se√ß√£o (setor 63) e rolar para baixo.  Foi encontrado no conte√∫do do setor 65 (dois setores abaixo) que √© completamente semelhante ao conte√∫do do superbloco FS EXT2, descrito no manual.  Mais pesquisas levaram √† conclus√£o de que a primeira parti√ß√£o do HDD DVR √© a parti√ß√£o EXT2, exibida no sistema operacional Xubuntu, independentemente da marca 0x08 (e n√£o EXT) no √≠ndice!  Assim, a primeira parti√ß√£o do disco r√≠gido do DVR √© a parti√ß√£o EXT2, na qual os arquivos nvr s√£o gravados, que s√£o as chaves para as grava√ß√µes de v√≠deo necess√°rias. <br><br>  Escreverei brevemente sobre a estrutura dos arquivos .264, que tamb√©m examinei anteriormente.  Esta informa√ß√£o ser√° necess√°ria no futuro para estudar a segunda se√ß√£o do HDD.  Como em qualquer cont√™iner de m√≠dia, em "264" h√° um cabe√ßalho com informa√ß√µes de servi√ßo e tags de m√≠dia, bem como fluxos de √°udio e v√≠deo que seguem em pequenos blocos um ap√≥s o outro.  Em um deslocamento de 0x84 bytes desde o in√≠cio do arquivo, a palavra-chave "MDVR96NT_2_R" √© registrada.  Antes desta palavra, existem bytes relacionados √† data e hora da grava√ß√£o.  Mas essa informa√ß√£o est√° contida no nome do arquivo, portanto, n√£o merece aten√ß√£o especial aqui.  Depois disso, v√™m muitos bytes de zeros.  As informa√ß√µes principais com fluxos de √°udio e v√≠deo s√£o originadas em um deslocamento de 65.536 bytes.  Os blocos de fluxo de v√≠deo come√ßam com um cabe√ßalho de 8 bytes "01dcH264" (tamb√©m encontrado "00dcH264").  Os 4 bytes a seguir descrevem o tamanho do bloco atual do fluxo de v√≠deo em bytes.  Ap√≥s 4 bytes de zeros (00 00 00 00), o pr√≥prio bloco de fluxo de v√≠deo √© iniciado.  Os blocos de fluxo de √°udio t√™m o t√≠tulo "03wb" (embora, de acordo com minhas observa√ß√µes, o primeiro caractere do cabe√ßalho em alguns casos n√£o tenha sido necessariamente "0").  Depois - 12 bytes de informa√ß√µes que ainda n√£o descobri.  E come√ßando com o 17¬∫ byte - um fluxo de √°udio com um comprimento fixo de 160 bytes.  N√£o h√° tags no final do arquivo. <br><br>  Continuamos estudando a estrutura dos arquivos e diret√≥rios localizados na primeira parti√ß√£o do disco r√≠gido.  Como mencionado acima, o conte√∫do da se√ß√£o foi copiado para uma m√≠dia separada por meio de um explorador regular no sistema operacional Xununtu.  Em cada diret√≥rio (diret√≥rio), al√©m dos arquivos nvr, h√° um arquivo bin√°rio chamado "lista_de_arquivo".  A julgar pelo nome, ele cont√©m informa√ß√µes sobre a lista de arquivos no diret√≥rio atual.  Abra este arquivo no editor bin√°rio (veja a figura abaixo).  Eu investiguei a estrutura desse arquivo, e basicamente n√£o h√° nada interessante aqui.  O arquivo n√£o possui nenhuma informa√ß√£o sobre o local dos fluxos de m√≠dia desejados.  No entanto, escreverei brevemente sobre essa estrutura.  Os primeiros 32 bytes s√£o um cabe√ßalho com algumas constantes.  Os pr√≥ximos 16 bytes est√£o relacionados √† data e hora e ao n√∫mero de arquivos no diret√≥rio atual.  Isto √© seguido por 48 bytes de constantes.  Pr√≥ximo - 8 bytes de constantes, indicando o in√≠cio do registro do arquivo.  Em seguida, 96 bytes indicando o caminho completo para o arquivo nvr, incluindo seu nome.  Pr√≥ximo - 24 bytes relacionados ao hor√°rio (o n√∫mero de segundos decorridos desde o in√≠cio do dia, o in√≠cio e o final do v√≠deo) e outros atributos do v√≠deo.  E assim por diante, por analogia, para todos os arquivos nvr no diret√≥rio atual.  O n√∫mero deles √© igual ao n√∫mero de v√≠deos do dia atual, indicado pelo nome do diret√≥rio atual.  Para que serve esse arquivo?  Aparentemente, para acelerar a pesquisa de v√≠deo na interface do DVR. <br><br><img src="https://habrastorage.org/webt/ey/tq/dh/eytqdh-oadafzwauaoh2fbogo9o.jpeg"><br><br>  Vamos continuar estudando a estrutura dos arquivos nvr.  A apar√™ncia de um desses arquivos em um editor bin√°rio (mais precisamente, em um hexadecimal) √© mostrada na figura abaixo.  Sem entrar em detalhes da descri√ß√£o da estrutura de conte√∫do (parte da qual permaneceu um mist√©rio para mim), destaquei os par√¢metros mais b√°sicos, que s√£o a chave a ser encontrada.  Esses s√£o valores de 32 bits (4 bytes), localizados a cada 32 bytes, iniciando no byte no deslocamento 40. Na figura, eles s√£o destacados em vermelho.  No futuro, fiquei convencido de que isso √© suficiente para a chave dos v√≠deos.  Lembro que 4 bytes do valor desse par√¢metro-chave est√£o localizados do menor para o maior, mas n√£o vice-versa!  Essa nota√ß√£o se deve √† arquitetura do processador do PC.  O exemplo na figura mostra o primeiro arquivo nvr do primeiro diret√≥rio.  Corresponde √† primeira grava√ß√£o de v√≠deo feita pelo DVR.  Obviamente, os valores dos par√¢metros, que chamei de chave, no exemplo acima, formam uma sequ√™ncia de n√∫meros inteiros, come√ßando do zero e indo em ordem crescente.  Examinando outros arquivos nvr e olhando exatamente para esses bytes especificados, tamb√©m foram vistos n√∫meros inteiros, ascendentes.  Mas essa sequ√™ncia naturalmente n√£o come√ßou mais do zero e, em alguns casos, lacunas em um ou dois n√∫meros foram observadas em alguns lugares.  Por exemplo (n√∫meros do trator): 435, 436, 438, 439, 442, ... (ou em hexadecimal: B3010000, B4010000, B6010000, B7010000, BA010000, ...). <br><br><img src="https://habrastorage.org/webt/nl/50/eo/nl50eo8cjnx0mnexkbcf-sqld20.jpeg"><br><br>  Essa sequ√™ncia com omiss√µes ocorreu nos arquivos nvr correspondentes aos v√≠deos que o DVR gravou simultaneamente de dois ou mais canais.  Ou seja, por exemplo, se a sequ√™ncia "435, 436, 438, 439, 442, ..." se refere ao v√≠deo de um canal, os valores ausentes (437, 440, 441) se relacionam ao v√≠deo de outro canal, realizado na mesma ponto no tempo.  Eu mesmo estava convencido disso vendo e comparando os arquivos nvr correspondentes, com base no nome deles.  N√£o h√° d√∫vida de que os n√∫meros acima formam os n√∫meros de algumas partes relacionadas aos v√≠deos.  Resta apenas desvendar o relacionamento entre esses n√∫meros e as coordenadas do espa√ßo em disco no qual os dados est√£o localizados. <br><br>  Al√©m disso, foi descobrir exatamente quais dados s√£o divididos nos segmentos numerados acima?  A primeira suposi√ß√£o - os dados s√£o fluxos de √°udio e v√≠deo, que no cont√™iner 264 s√£o representados por blocos curtos e, como foi dito, os blocos do fluxo de v√≠deo t√™m tamanhos diferentes.  Ao mesmo tempo, o DVR coleta esses fluxos e os empacota em um cont√™iner 264 no est√°gio de extra√ß√£o de grava√ß√µes de v√≠deo em m√≠dia externa. A segunda suposi√ß√£o √© que o DVR empacota fluxos de √°udio e v√≠deo em um cont√™iner 264 no in√≠cio e durante a captura de v√≠deo.  E, ao mesmo tempo, os dados do arquivo .264 j√° gerados s√£o gravados no HDD, o que resultaria da extra√ß√£o para um meio externo.  Explorando o espa√ßo do HDD em algum lugar no meio da segunda se√ß√£o, junto com bytes de fluxos de √°udio e v√≠deo e seus cabe√ßalhos do mesmo tipo que no cont√™iner 264, tamb√©m me deparei com os cabe√ßalhos do pr√≥prio cont√™iner: MDVR96NT_2_R.  Ap√≥s esse cabe√ßalho, havia tamb√©m muitos bytes de zeros.  Em geral, o estudo mostrou que existe uma segunda op√ß√£o das duas acima.  Portanto, para obter o arquivo .264 desejado, provavelmente, voc√™ s√≥ precisa conectar todos os segmentos cujos n√∫meros est√£o contidos no arquivo nvr correspondente. <br><br>  Vamos come√ßar a busca pela rela√ß√£o entre o n√∫mero do segmento e as coordenadas no disco r√≠gido. <br><br>  O in√≠cio dos dados do cont√™iner 264 correspondente √† primeira grava√ß√£o de v√≠deo (onde a numera√ß√£o dos segmentos come√ßa do zero) com as ferramentas de pesquisa que encontrei no setor 16046629 (29824 setores desde o in√≠cio da se√ß√£o).  Podemos fazer uma suposi√ß√£o sobre o chamado par√¢metro  vi√©s inicial, que participar√° da f√≥rmula que descreve a depend√™ncia desejada. <br><br>  Vamos pegar dois arquivos nvr correspondentes a v√≠deos de diferentes canais que o DVR capturou ao mesmo tempo.  Para fazer isso, d√™ uma olhada nos nomes dos arquivos.  Por exemplo, os v√≠deos apontados pelos arquivos "ch00000000000001-150330-160937-161035-02p101000000.nvr" e "ch00000000000004-150330-160000-163000-00p004000000.nvr" foram gravados simultaneamente.  O primeiro registro √© a grava√ß√£o do 1¬∫ canal, das 16:09:37 √†s 16:10:35.  O segundo registro √© um registro do 4¬∫ canal, das 16:00:00 √†s 16:30:00, hor√°rio.  Ambas as entradas foram feitas em 30 de mar√ßo de 2015. Na linha do tempo, obviamente, o intervalo de tempo do primeiro registro √© um subconjunto do intervalo de tempo do segundo registro.  Tamb√©m levo em conta o fato de que, em um intervalo de tempo menor (na interse√ß√£o de dois intervalos), o DVR n√£o realizou captura de v√≠deo em nenhum dos outros seis canais.  Navegue pelo conte√∫do desses arquivos nvr.  Garantiremos que os n√∫meros ausentes (n√∫meros de segmento) no segundo arquivo longo estejam necessariamente presentes no primeiro arquivo curto, completa e completamente.  Usando o DVR da maneira usual, voc√™ precisa extrair pelo menos um dos arquivos .264 mencionados pelos arquivos nvr investigados com anteced√™ncia.  Digamos que "ch00000000000001-150330-160937-161035-02p101000000.264" foi extra√≠do.  Abra-o no editor bin√°rio.  Como j√° mencionado, no in√≠cio deste arquivo, antes da palavra-chave ‚ÄúMDVR96NT_2_R‚Äù, ‚Äã‚Äãexistem bytes √∫nicos correspondentes √† data e hora da grava√ß√£o de v√≠deo contida neste arquivo.  Escrevemos todos esses bytes, come√ßando de diferente de zero e terminando com o cabe√ßalho (quanto menor a cadeia de bytes exclusiva para esta grava√ß√£o de v√≠deo, melhor).  Al√©m disso, escreva o deslocamento dessa cadeia de bytes desde o in√≠cio do arquivo.  Deve-se observar que no in√≠cio do arquivo .264 extra√≠do, existem 4 bytes de zeros extras.  Isso se tornou vis√≠vel ao comparar os primeiros 512 bytes do arquivo .264 e o setor de espa√ßo em disco a partir do qual o conte√∫do de um dos arquivos .264 come√ßa (um arquivo de quase qualquer sistema de arquivos sempre inicia no in√≠cio do setor, al√©m disso, um cluster).  Ou seja, as informa√ß√µes no arquivo .264 s√£o deslocadas antecipadamente em 4 bytes para a direita.  O tamanho (em bytes) de qualquer arquivo .264 √© um m√∫ltiplo de 512 somente ap√≥s subtrair primeiro o n√∫mero 4 do tamanho.  Vamos come√ßar a busca pelo setor no qual o arquivo .264 investigado come√ßa.  No editor de disco, inicie a fun√ß√£o de pesquisa.  No campo do valor desejado, insira uma sequ√™ncia exclusiva de bytes baixados antecipadamente.  Para acelerar a pesquisa, insira o valor do deslocamento no campo "pesquisar por deslocamento", subtraindo anteriormente 4. Inicie a pesquisa.  Poucas horas depois, a pesquisa foi bem-sucedida.  Anotamos o n√∫mero do setor em que o t√≠tulo exclusivo √© encontrado.  Seja este o valor de s.  Examinamos o conte√∫do do arquivo nvr para este v√≠deo.  Escrevemos o n√∫mero do primeiro segmento (4 bytes no deslocamento 40).  Seja esse o valor de b.  No total, enquanto sabemos o n√∫mero do setor de disco (16046629) para o n√∫mero de segmento zero (na primeira grava√ß√£o de v√≠deo) e o n√∫mero do setor encontrado do disco s para o n√∫mero de segmento b acabado de ser baixado.  Voc√™ pode calcular o tamanho estimado do segmento: (s-16046629) / (b-0).  Ap√≥s calcular, obtive o valor 128. Assim, o tamanho do segmento √© igual a 128 setores de disco (LBA), ou 128 * 512 = 65536 bytes! <br><br>  Conduzi outro experimento interessante adicional para finalmente dissipar todas as d√∫vidas.  √â descrito abaixo. <br><br>  Desde o in√≠cio do setor s, selecionamos uma √°rea no disco com um tamanho compar√°vel ao tamanho de um arquivo .264 que come√ßa com esse setor.  Se minhas suposi√ß√µes estiverem corretas, os segmentos de outro arquivo .264, que foi capturado no disco r√≠gido simultaneamente com o primeiro, cair√£o na √°rea selecionada.  Salve esta √°rea em um arquivo (crie uma imagem).  Recorte a imagem resultante em arquivos de 65.536 bytes (tamanho do segmento).  Isso pode ser feito usando a fun√ß√£o "arquivo dividido" no Total Commander.  Que sejam pe√ßas M1, M2, M3, ....  Da mesma forma, cortamos o arquivo .264 estudado (que foi extra√≠do de forma amig√°vel do DVR), mas primeiro removendo 4 bytes de zeros primeiro.  Que sejam pe√ßas K1, K2, K3, ....  Usando a fun√ß√£o "Comparar por conte√∫do" no Total Commander, comparamos as partes da imagem e as do arquivo .264.  (M1 com K1, M2 com K2, etc.), guiados pelos n√∫meros de segmento do arquivo nvr correspondente.  O resultado √© o seguinte.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponha (n√∫meros do bulldozer), a cadeia de n√∫meros no nvr √© a seguinte: 435, 436, 438, 439, 442, ... Nesta situa√ß√£o, M1 = K1, M2 = K2, M4 = K3, M5 = K4, M8 = K5, .... Ou seja, as partes nas quais o arquivo de imagem e o arquivo .264 foram divididos s√£o iguais, levando em considera√ß√£o o avan√ßo correspondente no n√∫mero de partes do arquivo de imagem, de acordo com as omiss√µes na sequ√™ncia. Aqui est√°! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No total, obtivemos a depend√™ncia estimada: S = 16046629 + 128 * d, onde d √© o n√∫mero do segmento no arquivo nvr e S √© o n√∫mero do setor no disco r√≠gido, come√ßando desde o in√≠cio do disco a partir do qual o conte√∫do do segmento come√ßa. Tamanho do segmento - 128 setores. A f√≥rmula acima n√£o leva em considera√ß√£o a exist√™ncia da segunda se√ß√£o. A depend√™ncia √© encontrada apenas para um exemplo espec√≠fico de HDD a 1 TB. Talvez se voc√™ colocar uma capacidade diferente no DVR HDD, as constantes ter√£o uma apar√™ncia diferente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para verificar a validade da f√≥rmula, calculamos a posi√ß√£o do primeiro segmento de algum outro arquivo .264 arbitr√°rio, guiado pelo arquivo nvr correspondente. Prestando aten√ß√£o √† data e hora no nome do arquivo, compare-os com os primeiros bytes no cabe√ßalho .264, localizado no setor calculado. Os bytes que codificam individualmente o n√∫mero, m√™s, ano, horas, minutos, segundos, correspondem a dados tempor√°rios no nome do arquivo. Portanto, "bata na unha"! Calculamos no arquivo nvr correspondente ao arquivo .264 extra√≠do antecipadamente, o n√∫mero de segmentos cs. Em geral, seu n√∫mero √© cs = sf / 32-1, em que sf √© o tamanho do arquivo nvr. Se o arquivo .264 consistir em segmentos cs, seu tamanho dever√° ser igual a cs * 65536 + 4 (o n√∫mero de segmentos vezes o tamanho do segmento em bytes, mais 4 dos mesmos bytes de zeros). E √© mesmo!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainda assim, tente explorar a segunda se√ß√£o. Como observado anteriormente, algo semelhante a um superbloco est√° localizado diretamente no primeiro setor da se√ß√£o (16016805). E sua c√≥pia exata foi descoberta por sete setores abaixo (16016812). Obviamente, informa√ß√µes b√°sicas diferentes de zero est√£o no primeiro setor do superbloco. Sua apar√™ncia no editor de disco √© mostrada na figura abaixo.</font></font><br><br><img src="https://habrastorage.org/webt/rg/gz/wc/rggzwchl6xsvzhuvbfzslhrhyho.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consegui descriptografar parte dos par√¢metros de 4 bytes. A data e hora da montagem da parti√ß√£o s√£o destacadas em azul. A data e a hora s√£o apresentadas na nota√ß√£o de hora especial do Unix (o n√∫mero de segundos decorridos desde a meia-noite de 1¬∫ de janeiro de 1970). No exemplo acima, "03 7E 74 54" (valor decimal 1416920579) corresponde a "Ter, 25 de novembro de 2014 13:02:59 GMT". Para traduzir os valores, usei uma calculadora online especial. O valor 65536 est√° circulado no quadro roxo.√â poss√≠vel que o int√©rprete do sistema de arquivos dentro do programa DVR se refira a essa posi√ß√£o do superbloco quando o tamanho do bloco for lido (no contexto anterior, chamei segmentos de blocos). Os valores 1 s√£o destacados no quadro verde e um deles provavelmente indica a posi√ß√£o do in√≠cio do chamado. bitmap (no n√∫mero de blocos desde o in√≠cio da se√ß√£o). De fatocom anteced√™ncia, foi encontrado o in√≠cio das informa√ß√µes, algo semelhante a um bitmap no setor 16016933 (16016805 + 128 * 1). O valor 233 √© destacado no quadro vermelho.Esta √© precisamente a posi√ß√£o do in√≠cio dessas .264 grava√ß√µes de v√≠deo desde o in√≠cio da se√ß√£o: 16016805 + 128 * 233 = 16046629.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou seja, a segunda se√ß√£o pode ser chamada de se√ß√£o truncada e ligeiramente modificada do EXT2. Tem um superbloco, uma c√≥pia dele, um bitmap. Mas n√£o h√° os chamados. n√≥s de informa√ß√µes correspondentes aos registros do arquivo. A se√ß√£o cont√©m dados de arquivos .264 (fluxos de √°udio e v√≠deo), mas os n√≥s de informa√ß√£o (digamos assim) para esses dados est√£o localizados nos arquivos nvr na primeira se√ß√£o. Talvez exista uma reda√ß√£o mais competente? Mas isso n√£o √© t√£o importante para mim.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos escrever um programa simples para extra√ß√£o em massa de arquivos .264. Devo dizer imediatamente que n√£o tenho muita experi√™ncia em programa√ß√£o no Windows. O programa verifica todos os arquivos nvr copiados com anteced√™ncia para a se√ß√£o de 1 TB do novo disco r√≠gido. Ao analis√°-los, o programa cria um arquivo .264 com o mesmo nome no mesmo diret√≥rio, usando o acesso aos setores do disco r√≠gido original. Anteriormente, uma pasta com o nome ‚ÄúDVR‚Äù era criada em uma se√ß√£o vazia do novo HDD, na qual as pastas por datas s√£o colocadas e copiadas da ‚Äúmaneira usual‚Äù no Linux. Foi poss√≠vel incluir neste programa um algoritmo para trabalhar com a primeira parti√ß√£o Linux para acessar arquivos nvr, de modo a n√£o ter que pr√©-copi√°-los. E voc√™ pode adicionar outros recursos convenientes. Sim, era poss√≠vel, mas naquele momento eu queria fazer tudo o mais r√°pido poss√≠vel.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o usei recurs√£o para verificar diret√≥rios, j√° que o formato dos diret√≥rios √© fixo e tem dois n√≠veis de anexo. </font><font style="vertical-align: inherit;">Consequentemente, apliquei dois ciclos: percorrer as pastas at√© que elas terminem e percorrer os arquivos em cada pasta com a mesma condi√ß√£o. </font><font style="vertical-align: inherit;">Para ler arquivos, usei a fun√ß√£o fopen. </font><font style="vertical-align: inherit;">Para trabalhar com setores de disco r√≠gido, usei a funcionalidade WinAPI semelhante ao trabalho com arquivos. </font><font style="vertical-align: inherit;">Vamos seguir para o c√≥digo do programa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bibliotecas precisam disso.</font></font><br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt;</span></span></span></span></code> </pre> <br>  E eu copiei completamente essas fun√ß√µes de algum f√≥rum. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">HANDLE </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openDevice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> device)</span></span></span><span class="hljs-function"> </span></span>{ HANDLE handle = INVALID_HANDLE_VALUE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (device &lt;<span class="hljs-number"><span class="hljs-number">0</span></span> || device &gt;<span class="hljs-number"><span class="hljs-number">99</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> INVALID_HANDLE_VALUE; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> _devicename[<span class="hljs-number"><span class="hljs-number">20</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(_devicename, <span class="hljs-string"><span class="hljs-string">"\\\\.\\PhysicalDrive%d"</span></span>, device); <span class="hljs-comment"><span class="hljs-comment">// Creating a handle to disk drive using CreateFile () function .. handle = CreateFile(_devicename, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL); return handle; } HANDLE openOutputFile(const char * filename) { return CreateFile ( filename, // Open Two.txt. GENERIC_WRITE, // Open for writing 0, // Do not share NULL, // No security OPEN_ALWAYS, // Open or create FILE_ATTRIBUTE_NORMAL, // Normal file NULL); // No template file }</span></span></code> </pre><br>  A fun√ß√£o de c√≥pia cont√©m uma f√≥rmula de depend√™ncia linear, que apareceu na teoria acima. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HANDLE device, HANDLE file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s)</span></span></span></span>{ LONG HPos; LONG LPos; __int64 sector; sector = <span class="hljs-number"><span class="hljs-number">16046629</span></span>+<span class="hljs-number"><span class="hljs-number">128</span></span>*s; HPos = (sector*<span class="hljs-number"><span class="hljs-number">512</span></span>)&gt;&gt;<span class="hljs-number"><span class="hljs-number">32</span></span>; LPos = (sector*<span class="hljs-number"><span class="hljs-number">512</span></span>); SetFilePointer (device, LPos, &amp;HPos, FILE_BEGIN); DWORD dwBytesRead; DWORD dwBytesWritten; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">65536</span></span>]; ReadFile(device, buf, <span class="hljs-number"><span class="hljs-number">65536</span></span>, &amp;dwBytesRead, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); WriteFile(file, buf, dwBytesRead, &amp;dwBytesWritten, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); }</code> </pre><br>  A fun√ß√£o principal tamb√©m √© bastante simples. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ HANDLE hdd = openDevice(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    HDD  DVR,    ; SetFilePointer (hdd, 0, NULL, FILE_BEGIN); DWORD dwBytesRead; char name[100]; unsigned int bl; //  ; unsigned int N; // ; unsigned long int pt; //  ; WIN32_FIND_DATA fld,fld1; //   nvr   ; HANDLE hf,hf1; hf=FindFirstFile("E:\\DVR\\*",&amp;fld); FindNextFile(hf,&amp;fld);// "."; FindNextFile(hf,&amp;fld);// ".."; do{ char *str = new char; sprintf(str,"%s%s%s","E:\\DVR\\",fld.cFileName,"\\*.nvr"); printf("\n\nFOLDER: %s\n\n",str); hf1=FindFirstFile(str,&amp;fld1); do{ FILE *nvr; sprintf(name,"%s%s%s%s","E:\\DVR\\",fld.cFileName,"\\",fld1.cFileName); nvr=fopen(name,"rb"); name[strlen(name)-3]='2'; //   ,  name[strlen(name)-2]='6'; // ; name[strlen(name)-1]='4'; HANDLE out = openOutputFile(name); SetFilePointer(out, 4, NULL, FILE_BEGIN); //  "",  4      (  ); bl=0; N=fld1.nFileSizeLow/32-1; //   (); printf("\t%s\n\t%i Blocks\n\n",fld1.cFileName,N); for(bl=0;bl&lt;N;bl++){ //  ; fseek(nvr,40+32*bl,SEEK_SET); //; fread(&amp;pt,1,4,nvr); // ; copy(hdd,out,pt); //  ; } CloseHandle(out); fclose(nvr); }while(FindNextFile(hf1,&amp;fld1)); FindClose(hf1); delete str; }while(FindNextFile(hf,&amp;fld)); FindClose(hf); CloseHandle(hdd); system("PAUSE"); return 0; }</span></span></code> </pre><br>  Em um computador antigo com um processador Pentium 4 e um controlador PCI SATA, o programa transferiu com √™xito at√© o final um disco r√≠gido completo com v√°rios milhares de arquivos .264 em uma m√©dia de 7 horas.  Em um novo computador - tr√™s vezes mais r√°pido.  Como j√° observei, o programa n√£o √© universal, todas as constantes e vari√°veis ‚Äã‚Äãs√£o ajustadas ao meu caso espec√≠fico de HDD a 1TB.  No entanto, voc√™ pode trabalhar um pouco mais e torn√°-lo universal, desenhar uma interface gr√°fica para ele. <br><br>  Na segunda parte do artigo, escreverei como "fazer voc√™ mesmo" para reembalar do cont√™iner "264" para o cont√™iner "avi" padr√£o. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt421933/">https://habr.com/ru/post/pt421933/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt421923/index.html">Entendemos profiss√µes de design</a></li>
<li><a href="../pt421925/index.html">Vis√£o geral da impressora 3D Raise 3D Pro 2 Plus</a></li>
<li><a href="../pt421927/index.html">Vis√£o geral do smartphone General Mobile GM8 Go: um funcion√°rio do or√ßamento turco com Android 8.1 Oreo Go Edition</a></li>
<li><a href="../pt421929/index.html">Um ano antes do Brexit: a Gr√£-Bretanha resolve o problema da falta de m√£o-de-obra atrav√©s da rob√≥tica</a></li>
<li><a href="../pt421931/index.html">Impacto da prote√ß√£o Spectre, Meltdown e Foreshadow no desempenho do Linux 4.19</a></li>
<li><a href="../pt421935/index.html">Primeiras impress√µes da transi√ß√£o do Ubuntu 16.04 LTS para o Ubuntu 18.04 LTS</a></li>
<li><a href="../pt421937/index.html">Cidade inteligente por dentro - um olhar da Huawei</a></li>
<li><a href="../pt421939/index.html">Usando SQL no Rails</a></li>
<li><a href="../pt421945/index.html">Google e Mastercard concluem um acordo secreto para rastrear compras nas lojas</a></li>
<li><a href="../pt421947/index.html">Bem-vindo ao Android Devs Meetup 8 de setembro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>