<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶ë üôéüèº üêπ Unity3D: √Ñndern Sie den iOS App Delegate ‚ô®Ô∏è üë©‚Äçüë©‚Äçüë¶‚Äçüë¶ üß£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich denke, dass viele bei der Entwicklung eines Spiels f√ºr iOS mit der Tatsache konfrontiert werden mussten, dass es notwendig wird, die eine oder and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity3D: √Ñndern Sie den iOS App Delegate</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430118/">  Ich denke, dass viele bei der Entwicklung eines Spiels f√ºr iOS mit der Tatsache konfrontiert werden mussten, dass es notwendig wird, die eine oder andere native Funktionalit√§t zu verwenden.  In Bezug auf Unity3D k√∂nnen in diesem Problem viele Probleme auftreten: Um eine Funktion zu implementieren, m√ºssen Sie sich auf native Plugins konzentrieren, die in Objective-C geschrieben wurden.  Jemand in diesem Moment verzweifelt sofort und gibt die Idee auf.  Jemand sucht im AssetStore oder in Foren nach vorgefertigten L√∂sungen, in der Hoffnung, dass es bereits eine vorgefertigte L√∂sung gibt.  Wenn es keine vorgefertigten L√∂sungen gibt, sehen die hartn√§ckigsten von uns keinen anderen Weg, als in den Abgrund der iOS-Programmierung und der Unity3D-Interaktion mit Objective-C-Code einzutauchen. <br><br>  Diejenigen, die den letzten Weg w√§hlen (obwohl sie, wie ich glaube, selbst wissen), werden auf diesem schwierigen und heiklen Weg mit vielen Problemen konfrontiert sein: <br><br><ul><li>  iOS ist ein absolut unbekanntes und isoliertes √ñkosystem, das sich auf seine eigene Weise entwickelt.  Zumindest m√ºssen Sie viel Zeit aufwenden, um zu verstehen, wie Sie zur Anwendung gelangen k√∂nnen und wo sich in den Tiefen des automatisch generierten Xcode-Projekts der Code f√ºr die Unity3D-Engine befindet, um mit der nativen Komponente der Anwendung zu interagieren. </li><li>  Objective-C ist eine ziemlich separate und wenig √§hnliche Programmiersprache.  Und wenn es um die Interaktion mit dem C ++ - Code der Unity3D-Anwendung geht, tritt der ‚ÄûDialekt‚Äú dieser Sprache, Objective-C ++ genannt, in die Szene ein.  Es gibt sehr wenig Informationen √ºber ihn, das meiste davon ist uralt und archiviert. </li><li>  Das Interaktionsprotokoll zwischen Unity3D und iOS-Anwendung ist schlecht beschrieben.  Sie sollten sich ausschlie√ülich auf die Tutorials von Netzwerkbegeisterten verlassen, die schreiben, wie das einfachste native Plugin entwickelt wird.  Gleichzeitig ber√ºhren nur wenige Menschen tiefere Probleme und Probleme, die sich aus der Notwendigkeit ergeben, etwas Kompliziertes zu tun. </li></ul><br>  Diejenigen, die mehr √ºber die Mechanismen der Interaktion von Unity3D mit einer iOS-Anwendung erfahren m√∂chten, finden Sie unter cat. <br><a name="habracut"></a><br>  In diesem Artikel werden die Interaktionsaspekte eines iOS-Anwendungsdelegierten mit Unity3D-Code beschrieben, mit welchen C ++ - und Objective-C-Tools er implementiert ist, und wie Sie den Anwendungsdelegierten selbst √§ndern k√∂nnen, um den d√ºsteren Engpass bei der Interaktion von Unity3D mit nativem Code zu kl√§ren.  Diese Informationen k√∂nnen sowohl zum besseren Verst√§ndnis der Unity3D + iOS-Verkn√ºpfungsmechanismen als auch f√ºr den praktischen Gebrauch hilfreich sein. <br><br><h3>  Interaktion zwischen iOS und Anwendung </h3><br>  Schauen wir uns als Einf√ºhrung an, wie die Interaktion der Anwendung mit dem System in iOS implementiert ist und umgekehrt.  Schematisch sieht der Start einer iOS-Anwendung folgenderma√üen aus: <br><br><img src="https://habrastorage.org/webt/jd/vm/oi/jdvmoimtygqdsc095abusfopdao.png" alt="Bild"><br><br>  Um diesen Mechanismus unter dem Gesichtspunkt des Codes zu untersuchen, ist eine neue Anwendung geeignet, die in Xcode mithilfe der Vorlage ‚ÄûSingle View App‚Äú erstellt wurde. <br><br><img src="https://habrastorage.org/webt/du/_z/75/du_z75efp4bdgv_fvb02x-mjfis.png"><br><br>  Wenn Sie diese Vorlage ausw√§hlen, erhalten Sie mit der Ausgabe die einfachste iOS-Anwendung, die auf einem Ger√§t oder Emulator ausgef√ºhrt werden kann und einen wei√üen Bildschirm anzeigt.  Xcode erstellt hilfreich ein Projekt, in dem es nur 5 Dateien mit Quellcode (von denen 2 Header-H-Dateien sind) und mehrere Hilfsdateien gibt, die f√ºr uns nicht interessant sind (Satz, Konfigurationen, Symbole). <br><br><img src="https://habrastorage.org/webt/jt/mz/ov/jtmzov95oshddmprhby9wkqigve.png"><br><br>  Mal sehen, wof√ºr die Quellcodedateien verantwortlich sind: <br><br><ul><li>  <i>ViewController.m</i> / <i>ViewController.h</i> - f√ºr uns nicht sehr interessante Quellcodes.  Da Ihre Anwendung √ºber eine Ansicht verf√ºgt (die nicht durch Code dargestellt wird, sondern das Storyboard verwendet), ben√∂tigen Sie die Controller-Klasse, die diese Ansicht steuert.  Auf diese Weise ermutigt uns Xcode im Allgemeinen, das MVC-Muster zu verwenden.  Das Projekt, das Unity3D generiert, verf√ºgt nicht √ºber diese Quelldateien. </li><li>  <i>AppDelegate.m</i> / <i>AppDelegate.h</i> ist der Delegat Ihrer Anwendung.  Der Punkt von Interesse in der Anwendung, an dem die Arbeit des benutzerdefinierten Anwendungscodes beginnt. </li><li>  <i>main.m</i> - der Startpunkt der Anwendung.  In der Art einer C / C ++ - Anwendung enth√§lt es die Hauptfunktion, mit der das Programm startet. </li></ul><br>  Lassen Sie uns nun den Code sehen, der mit der Datei <i>main.m beginnt</i> : <br><br><pre><code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * argv[]) { <span class="hljs-comment"><span class="hljs-comment">//1 @autoreleasepool { //2 return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); // 3 } }</span></span></code> </pre> <br>  Mit Zeile 1 ist alles klar und ohne Erkl√§rung fahren wir mit Zeile 2 fort. Dies zeigt an, dass der Anwendungslebenszyklus innerhalb des Autorelease-Pools stattfinden wird.  Die Verwendung des Autorelease-Pools teilt uns mit, dass wir die Speicherverwaltung der Anwendung diesem bestimmten Pool anvertrauen, dh Probleme behandeln, wenn Speicher f√ºr eine bestimmte Variable freigegeben werden muss.  Die Geschichte √ºber die Speicherverwaltung unter iOS geht √ºber den Rahmen dieser Geschichte hinaus, sodass es keinen Sinn macht, sich mit diesem Thema zu befassen.  F√ºr diejenigen, die sich f√ºr dieses Thema interessieren, finden Sie beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Artikel</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fahren</a> wir mit Zeile 3 fort. Sie ruft die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UIApplicationMain-</a> Funktion auf.  Die Programmstartparameter (argc, argv) werden an sie √ºbergeben.  In dieser Funktion wird dann angegeben, welche Klasse als Hauptklasse der Anwendung verwendet werden soll, deren Instanz erstellt wird.  Und schlie√ülich wird angegeben, welche Klasse als Anwendungsdelegat verwendet werden soll, ihre Instanz erstellt wird und die Verbindungen zwischen der Anwendungsklasseninstanz und ihrem Delegaten konfiguriert werden. <br><br>  In unserem Beispiel wird nil als die Klasse √ºbergeben, die die Anwendungsinstanz darstellt - grob gesagt ist das lokale Analogon null.  Zus√§tzlich zu nil k√∂nnen Sie dort eine bestimmte Klasse √ºbergeben, die von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UIApplication</a> geerbt wurde.  Wenn nil angegeben ist, wird UIApplication verwendet.  Diese Klasse ist ein zentraler Punkt f√ºr die Verwaltung und Koordination der Arbeit einer Anwendung unter iOS und ein Singleton.  Damit k√∂nnen Sie fast alles √ºber den aktuellen Status der Anwendung, Benachrichtigungen, Fenster, Ereignisse im System selbst, die sich auf diese Anwendung auswirken, und vieles mehr erfahren.  Diese Klasse erbt fast nie.  Wir werden uns eingehender mit der Erstellung der Application Delegate-Klasse befassen. <br><br><h3>  Anwendungsdelegierten erstellen </h3><br>  In einem Funktionsaufruf wird angegeben, welche Klasse als Anwendungsdelegat verwendet werden soll <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSStringFromClass</span></span>([AppDelegate <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>])</code> </pre> <br>  Lassen Sie uns diesen Aufruf in Teilen analysieren. <br><br><pre> <code class="objectivec hljs">[AppDelegate <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>]</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dieses Konstrukt</a> gibt ein Objekt der AppDelegate-Klasse zur√ºck (das in AppDelegate.h / .m deklariert ist), und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NSStringFromClass-</a> Funktion gibt den Klassennamen als Zeichenfolge zur√ºck.  Wir √ºbergeben einfach den Zeichenfolgennamen der Klasse, die erstellt und als Delegat an die UIApplicationMain-Funktion verwendet werden soll.  Zum besseren Verst√§ndnis k√∂nnte Zeile 3 in der Datei <i>main.m</i> durch Folgendes ersetzt werden: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">UIApplicationMain</span></span>(argc, argv, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">@"AppDelegate"</span></span>);</code> </pre> <br>  Und das Ergebnis seiner Implementierung w√§re identisch mit der Originalversion.  Anscheinend haben sich die Entwickler f√ºr diesen Ansatz entschieden, um keine String-Konstante zu verwenden.  Bei einem Standardansatz gibt der Parser beim Umbenennen einer Delegatenklasse sofort einen Fehler aus.  Bei Verwendung der √ºblichen Zeile wird der Code erfolgreich kompiliert und Sie erhalten nur beim Starten der Anwendung eine Fehlermeldung. <br><br>  Ein √§hnlicher Mechanismus zum Erstellen einer Klasse, bei dem nur der Zeichenfolgenname der Klasse verwendet wird, erinnert Sie m√∂glicherweise an die Reflexion von C #.  Objective-C und seine Laufzeit sind in C # viel leistungsf√§higer als Reflection.  Dies ist ein ziemlich wichtiger Punkt im Kontext dieses Artikels, aber es w√ºrde viel Zeit in Anspruch nehmen, alle Funktionen zu beschreiben.  Wir werden uns jedoch weiterhin mit ‚ÄûReflexion‚Äú in Ziel C unten treffen.  Es bleibt das Konzept des Anwendungsdelegierten und seine Funktionen zu verstehen. <br><br><h3>  Anwendungsdelegierter </h3><br>  Die gesamte Interaktion der Anwendung mit iOS erfolgt in der UIApplication-Klasse.  Diese Klasse √ºbernimmt viele Aufgaben - informiert √ºber den Ursprung von Ereignissen, den Status der Anwendung und vieles mehr.  Zum gr√∂√üten Teil ist seine Rolle die Benachrichtigung.  Aber wenn etwas im System passiert, sollten wir in der Lage sein, auf diese √Ñnderung irgendwie zu reagieren und eine Art benutzerdefinierte Funktionalit√§t auszuf√ºhren.  Wenn eine Instanz der UIApplication-Klasse dies tut, √§hnelt diese Praxis einem Ansatz, der als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">g√∂ttliches Objekt bezeichnet wird</a> .  Daher lohnt es sich, dar√ºber nachzudenken, diese Klasse von einem Teil ihrer Verantwortung zu befreien. <br><br>  Zu diesem Zweck verwendet das iOS-√ñkosystem so etwas wie einen Anwendungsdelegierten.  Aus dem Namen selbst k√∂nnen wir schlie√üen, dass es sich um ein Entwurfsmuster wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Delegation handelt</a> .  Kurz gesagt, wir √ºbertragen einfach die Verantwortung f√ºr die Verarbeitung der Antwort auf bestimmte Ereignisse der Anwendung auf den Anwendungsdelegierten.  Zu diesem Zweck wurde in unserem Beispiel die AppDelegate-Klasse erstellt, in die wir benutzerdefinierte Funktionen schreiben k√∂nnen, w√§hrend die UIApplication-Klasse im Black-Box-Modus arbeiten kann.  Dieser Ansatz mag jemandem in Bezug auf die Sch√∂nheit des Architekturdesigns kontrovers erscheinen, aber die iOS-Autoren selbst dr√§ngen uns zu diesem Ansatz, und die √ºberwiegende Mehrheit der Entwickler (wenn nicht alle) verwendet ihn. <br><br>  Sehen Sie sich das folgende Diagramm an, um visuell zu √ºberpr√ºfen, wie oft der Anwendungsdelegierte w√§hrend der Arbeit der Anwendung eine bestimmte Nachricht erh√§lt: <br><br><img src="https://habrastorage.org/webt/md/61/bc/md61bc9my4focy1suoy5qn9om2s.png" alt="Bild"><br><br>  Die gelben Rechtecke zeigen die Aufrufe der einen oder anderen Delegatenmethode als Reaktion auf bestimmte Ereignisse im Leben der Anwendung an (Anwendungslebenszyklus).  Dieses Diagramm zeigt nur Ereignisse im Zusammenhang mit √Ñnderungen im Status der Anwendung und spiegelt nicht viele andere Aspekte der Verantwortung des Delegierten wider, z. B. das Akzeptieren von Benachrichtigungen oder die Interaktion mit Frameworks. <br><br>  Hier einige Beispiele, bei denen wir m√∂glicherweise Zugriff auf einen Anwendungsdelegierten von Unity3D ben√∂tigen: <br><br><ol><li>  Umgang mit Push- und lokalen Benachrichtigungen </li><li>  Protokollieren von Anwendungsstartereignissen in Analytics </li><li>  Festlegen, wie die Anwendung gestartet werden soll - "bereinigen" oder Hintergrund beenden </li><li>  wie die Anwendung gestartet wurde - per Tach zur Benachrichtigung, mithilfe von Schnellaktionen auf dem Startbildschirm oder einfach per Tach bei Incon </li><li>  Interaktion mit WatchKit oder HealthKit </li><li>  √ñffnen und Verarbeiten von URLs aus einer anderen Anwendung.  Wenn diese URL f√ºr Ihre Anwendung gilt, k√∂nnen Sie sie in Ihrer Anwendung verarbeiten, anstatt das System diese URL in einem Browser √∂ffnen zu lassen </li></ol><br>  Dies ist nicht die gesamte Liste der Szenarien.  Dar√ºber hinaus ist anzumerken, dass der Delegierte viele Analyse- und Werbesysteme in seinen nativen Plugins modifiziert. <br><br><h3>  Wie Unity3D einen Anwendungsdelegierten implementiert </h3><br>  Schauen wir uns nun das von Unity3D generierte Xcode-Projekt an und finden Sie heraus, wie der Anwendungsdelegierte in Unity3D implementiert ist.  Beim Erstellen f√ºr die iOS-Plattform generiert Unity3D automatisch ein Xcode-Projekt f√ºr Sie, das viel Boilerplate-Code verwendet.  Dieser Vorlagencode enth√§lt auch den Anwendungsdelegiertencode.  In jedem generierten Projekt finden Sie die Dateien <i>UnityAppController.h</i> und <i>UnityAppController.mm</i> .  Diese Dateien enthalten den Code der UnityAppController-Klasse, der uns interessiert. <br><br>  Tats√§chlich verwendet Unity3D eine modifizierte Version der Vorlage "Single View Application".  Nur in dieser Vorlage verwendet Unity3D den Anwendungsdelegierten nicht nur zum Behandeln von iOS-Ereignissen, sondern auch zum Initialisieren der Engine selbst, zum Vorbereiten von Grafikkomponenten und vielem mehr.  Dies ist sehr leicht zu verstehen, wenn Sie sich die Methode ansehen. <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)application:(<span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span>*)application didFinishLaunchingWithOptions:(<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span>*)launchOptions</code> </pre><br>  im Code der UnityAppController-Klasse.  Diese Methode wird zum Zeitpunkt der Anwendungsinitialisierung aufgerufen, wenn Sie die Steuerung auf Ihren benutzerdefinierten Code √ºbertragen k√∂nnen.  In dieser Methode finden Sie beispielsweise die folgenden Zeilen: <br><br><pre> <code class="objectivec hljs">UnityInitApplicationNoGraphics([[[<span class="hljs-built_in"><span class="hljs-built_in">NSBundle</span></span> mainBundle] bundlePath] UTF8String]); [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> selectRenderingAPI]; [UnityRenderingView InitializeForAPI: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.renderingAPI]; _window = [[<span class="hljs-built_in"><span class="hljs-built_in">UIWindow</span></span> alloc] initWithFrame: [<span class="hljs-built_in"><span class="hljs-built_in">UIScreen</span></span> mainScreen].bounds]; _unityView = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> createUnityView]; [DisplayManager Initialize]; _mainDisplay = [DisplayManager Instance].mainDisplay; [_mainDisplay createWithWindow: _window andView: _unityView]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> createUI]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> preStartUnity];</code> </pre><br>  Ohne auf die Details dieser Herausforderungen einzugehen, k√∂nnen Sie davon ausgehen, dass sie mit der Vorbereitung von Unity3D auf die Arbeit zusammenh√§ngen.  Es stellt sich das folgende Szenario heraus: <br><br><ol><li>  Die Hauptfunktion wird von <i>main.mm aufgerufen</i> </li><li>  Instanzklassen der Anwendung und ihres Delegaten werden erstellt. </li><li>  Der Anwendungsdelegierte bereitet die Unity3D-Engine vor und startet sie </li><li>  Ihr benutzerdefinierter Code funktioniert.  Wenn Sie il2cpp verwenden, wird Ihr Code von C # nach IL und dann in C ++ - Code √ºbersetzt, der direkt in das Xcode-Projekt gelangt. </li></ol><br>  Dieses Skript klingt ziemlich einfach und logisch, bringt jedoch ein potenzielles Problem mit sich: Wie k√∂nnen wir den Anwendungsdelegierten √§ndern, wenn wir bei der Arbeit in Unity3D keinen Zugriff auf den Quellcode haben? <br><br><h3>  Betroffene Unity3D zum √Ñndern des Anwendungsdelegierten </h3><br>  Wir k√∂nnen uns die Dateien <i>AppDelegateListener.mm/.h ansehen</i> .  Sie enthalten Makros, mit denen Sie jede Klasse als Ereignis-Listener f√ºr den Anwendungsdelegierten registrieren k√∂nnen.  Dies ist ein guter Ansatz. Wir m√ºssen den vorhandenen Code nicht √§ndern, sondern nur einen neuen hinzuf√ºgen.  Dies hat jedoch einen erheblichen Nachteil: Es werden nicht alle Anwendungsereignisse unterst√ºtzt, und es gibt keine M√∂glichkeit, Informationen zum Anwendungsstart abzurufen. <br><br>  Der offensichtlichste, jedoch nicht akzeptable Ausweg besteht darin, den delegierten Quellcode von Hand zu √§ndern, nachdem Unity3D das Xcode-Projekt erstellt hat.  Das Problem bei diesem Ansatz liegt auf der Hand - die Option ist geeignet, wenn Sie Baugruppen mit Ihren H√§nden erstellen und Sie nicht durch die Notwendigkeit verwirrt sind, den Code nach jeder Baugruppe manuell zu √§ndern.  Bei Verwendung von Buildern (Unity Cloud Build oder einer anderen Build-Maschine) ist diese Option absolut nicht akzeptabel.  F√ºr diese Zwecke haben uns Unity3D-Entwickler eine L√ºcke hinterlassen. <br><br>  Die Datei <i>UnityAppController.h</i> enth√§lt neben der Deklaration von Variablen und Methoden auch eine Makrodefinition: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define IMPL_APP_CONTROLLER_SUBCLASS(ClassName) ...</span></span></code> </pre> <br>  Dieses Makro erm√∂glicht lediglich das √úberschreiben des Anwendungsdelegierten.  Dazu m√ºssen Sie einige einfache Schritte ausf√ºhren: <br><br><ol><li>  Schreiben Sie Ihren eigenen Anwendungsdelegierten in Objective-C </li><li>  F√ºgen Sie irgendwo im Quellcode die folgende Zeile hinzu <pre> <code class="objectivec hljs">IMPL_APP_CONTROLLER_SUBCLASS(___)</code> </pre> </li><li>  Legen Sie diese Quelle im Ordner Plugins / iOS Ihres Unity3D-Projekts ab </li></ol><br>  Jetzt erhalten Sie ein Projekt, in dem der Standard-Unity3D-Anwendungsdelegierte durch Ihren benutzerdefinierten ersetzt wird. <br><br><h3>  Wie funktioniert das Makro zum Ersetzen von Delegaten? </h3><br>  Schauen wir uns den vollst√§ndigen Quellcode des Makros an: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define IMPL_APP_CONTROLLER_SUBCLASS(ClassName) ... @interface ClassName(OverrideAppDelegate) \ { \ } \ +(void)load; \ @end \ @implementation ClassName(OverrideAppDelegate) \ +(void)load \ { \ extern const char* AppControllerClassName; \ AppControllerClassName = #ClassName; \ } \ @end</span></span></code> </pre> <br>  Wenn Sie dieses Makro in Ihrer Quelle verwenden, wird der im Makro beschriebene Code in der Kompilierungsphase zum Hauptteil Ihrer Quelle hinzugef√ºgt.  Dieses Makro f√ºhrt Folgendes aus.  Zun√§chst wird die Lademethode zur Schnittstelle Ihrer Klasse hinzugef√ºgt.  Eine Schnittstelle im Kontext von Objective-C kann als Sammlung √∂ffentlicher Felder und Methoden betrachtet werden.  In C # wird in Ihrer Klasse eine statische Lademethode angezeigt, die nichts zur√ºckgibt.  Als n√§chstes wird die Implementierung dieser Lademethode zum Code Ihrer Klasse hinzugef√ºgt.  Bei dieser Methode wird die Variable AppControllerClassName deklariert, bei der es sich um ein Array vom Typ char handelt, und dieser Variablen wird dann ein Wert zugewiesen.  Dieser Wert ist der Zeichenfolgenname Ihrer Klasse.  Offensichtlich reichen diese Informationen nicht aus, um den Funktionsmechanismus dieses Makros zu verstehen. Daher sollten wir verstehen, was diese Lademethode ist und warum eine Variable deklariert wird. <br><br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offizielle Dokumentation</a> besagt, dass load eine spezielle Methode ist, die f√ºr jede Klasse (insbesondere die Klasse, nicht ihre Instanzen) zu einem sehr fr√ºhen Zeitpunkt des Anwendungsstarts einmal aufgerufen wird, noch bevor die Hauptfunktion aufgerufen wird.  Die Objective-c-Laufzeitumgebung (Laufzeitumgebung) beim Start der Anwendung registriert alle Klassen, die w√§hrend des Anwendungsbetriebs verwendet werden, und ruft die Lademethode auf, falls implementiert.  Es stellt sich heraus, dass bereits vor dem Start eines Codes in unserer Anwendung die Variable AppControllerClassName zu Ihrer Klasse hinzugef√ºgt wird. <br><br>  Dann k√∂nnten Sie denken: "Und was bringt es, diese Variable zu haben, wenn sie innerhalb der Methode deklariert ist und beim Beenden dieser Methode aus dem Speicher gel√∂scht wird?"  Die Antwort auf diese Frage liegt etwas au√üerhalb der Grenzen von Ziel-C. <br><br><h3>  Und wo ist C ++? </h3><br>  Schauen wir uns die Deklaration dieser Variablen noch einmal an <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* AppControllerClassName;</code> </pre> <br>  Das einzige, was in dieser Deklaration m√∂glicherweise unverst√§ndlich ist, ist der externe Modifikator.  Wenn Sie versuchen, diesen Modifikator in reinem Objective-C zu verwenden, gibt Xcode einen Fehler aus.  Tatsache ist, dass dieser Modifikator nicht Teil von Objective-C ist, sondern in C ++ implementiert ist.  Objective-C l√§sst sich kurz und b√ºndig beschreiben, indem man sagt, es sei "C-Sprache mit Klassen".  Es ist eine Erweiterung der C-Sprache und erm√∂glicht die unbegrenzte Verwendung von C-Code, der mit Objective-C-Code durchsetzt ist. <br><br>  Um jedoch externe und andere C ++ - Funktionen verwenden zu k√∂nnen, m√ºssen Sie einen Trick ausf√ºhren - verwenden Sie Objective-C ++.  Es gibt praktisch keine Informationen zu dieser Sprache, da nur Objective-C-Code das Einf√ºgen von C ++ - Code erm√∂glicht.  Damit der Compiler ber√ºcksichtigt, dass einige Quelldateien als Objective-C ++ und nicht als Objective-C kompiliert werden sollten, m√ºssen Sie nur die Erweiterung dieser Datei von <i>.m</i> in <i>.mm √§ndern</i> . <br><br>  Der externe Modifikator selbst wird verwendet, um eine globale Variable zu deklarieren.  Genauer gesagt, um dem Compiler zu sagen: ‚ÄûGlauben Sie mir, eine solche Variable existiert, aber der Speicher daf√ºr wurde nicht hier, sondern in einer anderen Quelle zugewiesen.  Und sie hat auch einen Wert, das garantiere ich. ‚Äú  Daher erstellt unsere Codezeile einfach eine globale Variable und speichert den Namen unserer benutzerdefinierten Klasse darin.  Es bleibt nur zu verstehen, wo diese Variable verwendet werden kann. <br><br><h3>  Zur√ºck zum Haupt </h3><br>  Wir erinnern uns an das, was zuvor gesagt wurde - der Anwendungsdelegierte wird durch Angabe des Klassennamens erstellt.  Wenn der Delegat mit dem konstanten Wert [myClass-Klasse] in der regul√§ren Xcode-Projektvorlage erstellt wurde, haben die Mitarbeiter von Unity anscheinend entschieden, dass dieser Wert in eine Variable eingeschlossen werden soll.  Mit der wissenschaftlichen Poke-Methode nehmen wir das von Unity3D generierte Xcode-Projekt und gehen zur Datei <i>main.mm.</i> <br><br>  Darin sehen wir komplexeren Code als zuvor, ein Teil dieses Codes fehlt als unn√∂tig: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// WARNING: this MUST be c decl (NSString ctor will be called after +load, so we cant really change its value) const char* AppControllerClassName = "UnityAppController"; int main(int argc, char* argv[]) { ... UIApplicationMain(argc, argv, nil, [NSString stringWithUTF8String: AppControllerClassName]); } return 0; }</span></span></code> </pre> <br>  Hier sehen wir die Deklaration dieser Variablen und die Erstellung des Anwendungsdelegierten mit seiner Hilfe. <br>  Wenn wir einen benutzerdefinierten Delegaten erstellt haben, ist die erforderliche Variable vorhanden und bereits wichtig - der Name unserer Klasse.  Durch Deklarieren und Initialisieren der Variablen vor der Hauptfunktion wird sichergestellt, dass sie einen Standardwert hat - UnityAppController. <br><br>  Mit dieser Entscheidung sollte nun alles sehr klar sein. <br><br><h3>  Makroproblem </h3><br>  In den allermeisten Situationen ist die Verwendung dieses Makros nat√ºrlich eine gro√üartige L√∂sung.  Es ist jedoch erw√§hnenswert, dass dies eine gro√üe Gefahr darstellt: Sie k√∂nnen nicht mehr als einen benutzerdefinierten Delegaten haben.  Dies liegt daran, dass, wenn zwei oder mehr Klassen das Makro IMPL_APP_CONTROLLER_SUBCLASS (Klassenname) verwenden, f√ºr den ersten der Wert der von uns ben√∂tigten Variablen zugewiesen wird und weitere Zuweisungen ignoriert werden.  Und diese Variable ist eine Zeichenfolge, dh sie kann nicht mehr als einem Wert zugewiesen werden. <br><br>  Sie k√∂nnten denken, dass dieses Problem entartet und in der Praxis unwahrscheinlich ist.  Aber dieser Artikel w√§re nicht passiert, wenn ein solches Problem nicht wirklich aufgetreten w√§re, und selbst unter sehr seltsamen Umst√§nden.  Die Situation kann wie folgt sein.  Sie haben ein Projekt, in dem Sie viele Analyse- und Werbedienstleistungen nutzen.  Viele dieser Dienste verf√ºgen √ºber Objective-C-Komponenten.  Sie sind schon lange in Ihrem Projekt und Sie kennen die Probleme mit ihnen nicht.  Hier m√ºssen Sie einen benutzerdefinierten Delegaten schreiben.  Sie verwenden ein magisches Makro, um Probleme zu vermeiden, ein Projekt zu erstellen und einen Bericht √ºber den Erfolg der Montage zu erhalten.  F√ºhren Sie das Projekt auf dem Ger√§t aus, und Ihre Funktionalit√§t funktioniert nicht und Sie erhalten keinen einzigen Fehler. <br><br>  Und die Sache kann sein, dass eines der Werbe- oder Analyse-Plugins dasselbe Makro verwendet.  Im Plugin von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppsFlyer wird</a> dieses Makro beispielsweise verwendet. <br><br><h3>  Was ist der Wert der externen Variablen bei mehreren Deklarationen? </h3><br>  Es ist interessant herauszufinden, ob dieselbe externe Variable in mehreren Dateien deklariert und in der Art unseres Makros (in der Lademethode) initialisiert wird. Wie k√∂nnen wir dann verstehen, welchen Wert die Variable annehmen wird?  Um das Muster zu verstehen, wurde eine einfache Testanwendung erstellt, deren Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> zu finden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist</a> . <br><br>  Das Wesentliche der Anwendung ist einfach.  Es gibt 2 Klassen A und B, in beiden Klassen wird die externe Variable AexternVar deklariert, ihr wird ein bestimmter Wert zugewiesen.  Die Werte der Variablen in den Klassen werden unterschiedlich festgelegt.  In der Hauptfunktion wird der Wert dieser Variablen protokolliert.  Experimentell wurde festgestellt, dass der Wert der Variablen von der Reihenfolge abh√§ngt, in der die Quellen zum Projekt hinzugef√ºgt werden.  Die Reihenfolge, in der die Objective-C-Laufzeit Klassen w√§hrend der Anwendungsausf√ºhrung registriert, h√§ngt davon ab.  Wenn Sie das Experiment wiederholen m√∂chten, √∂ffnen Sie das Projekt und w√§hlen Sie in den Projekteinstellungen die Registerkarte Phasen erstellen.  Da das Projekt Test und klein ist, hat es nur 8 Quellcodes.  Alle von ihnen sind auf der Registerkarte Build-Phasen in der Liste Compile Sources vorhanden. <br><br><img src="https://habrastorage.org/webt/oi/ly/ln/oilylnhxdyjg3cvgcrj5nzhjvwy.png"><br><br>  Wenn in dieser Liste die Quelle der Klasse A h√∂her ist als die Quelle der Klasse B, nimmt die Variable einen Wert aus der Klasse B an. Andernfalls nimmt die Variable einen Wert aus der Klasse A an. <br><br>  Stellen Sie sich vor, wie viele Probleme dies theoretisch verursachen kann, ist eine kleine Nuance.  Insbesondere wenn das Projekt riesig ist, automatisch generiert wird und Sie nicht wissen, in welchen Klassen eine solche Variable deklariert ist. <br><br><h3>  L√∂sung </h3><br>  Zu Beginn des Artikels wurde gesagt, dass Objective-C der C # -Reflexion einen Vorsprung verschaffen wird.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Um</a> unser Problem zu l√∂sen, k√∂nnen Sie den Mechanismus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Method Swizzling verwenden</a> .  Das Wesentliche dieses Mechanismus ist, dass wir die M√∂glichkeit haben, die Implementierung einer Methode einer Klasse w√§hrend der Anwendung durch eine andere zu ersetzen.  Daher k√∂nnen wir die interessierende Methode in UnityAppController durch eine benutzerdefinierte ersetzen.  Wir √ºbernehmen die vorhandene Implementierung und erg√§nzen den Code, den wir ben√∂tigen.  Wir schreiben Code, der die vorhandene Implementierung der Methode durch die von uns ben√∂tigte ersetzt.  W√§hrend der Arbeit der Anwendung arbeitet der Delegat, der das Makro verwendet, wie zuvor und ruft die Basisimplementierung von UnityAppController auf. Dort kommt unsere benutzerdefinierte Methode ins Spiel und wir erzielen das gew√ºnschte Ergebnis.  Dieser Ansatz ist in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel</a> gut geschrieben und veranschaulicht.  Mit dieser Technik k√∂nnen wir eine Hilfsklasse erstellen - ein Analogon eines benutzerdefinierten Delegaten.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Klasse schreiben wir den gesamten benutzerdefinierten Code, wodurch die benutzerdefinierte Klasse zu einer Art Wrapper wird, mit dem die Funktionalit√§t anderer Klassen aufgerufen werden kann. </font><font style="vertical-align: inherit;">Dieser Ansatz wird funktionieren, ist jedoch √§u√üerst implizit, da es schwierig ist zu verfolgen, wo die Methode ersetzt wird und zu welchen Konsequenzen sie f√ºhren wird.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eine andere L√∂sung f√ºr das Problem </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Hauptaspekt des aufgetretenen Problems besteht darin, dass es viele benutzerdefinierte Delegaten gibt, oder Sie k√∂nnen nur einen haben oder ihn teilweise durch einen zweiten ersetzen. </font><font style="vertical-align: inherit;">Gleichzeitig kann nicht sichergestellt werden, dass sich der Code von benutzerdefinierten Delegaten nicht in verschiedene Quelldateien einschleicht. </font><font style="vertical-align: inherit;">Es stellt sich heraus, dass die Situation als Referenz betrachtet werden kann, wenn nur ein Delegat in der Anwendung vorhanden ist. Sie m√ºssen in der Lage sein, beliebig viele benutzerdefinierte Klassen zu erstellen, w√§hrend keine dieser Klassen das Makro verwendet, um Probleme zu vermeiden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Sache ist klein, es bleibt zu bestimmen, wie dies mit Unity3D gemacht werden kann, w√§hrend die M√∂glichkeit bleibt, ein Projekt mit einer Build-Maschine zu erstellen. </font><font style="vertical-align: inherit;">Der L√∂sungsalgorithmus lautet wie folgt:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir schreiben benutzerdefinierte Delegaten in der erforderlichen Menge, teilen die Logik der Plugins in verschiedene Klassen ein, beachten die Prinzipien von SOLID und greifen nicht auf Raffinesse zur√ºck. </font></font></li><li>       UnityAppController   XCode      .         UnityAppController   . </li><li>    UnityAppController     Unity . </li><li>     XCode     UnityAppController  ,       </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der schwierigste Punkt aus dieser Liste ist zweifellos der letzte. Diese Funktion kann jedoch in Unity3D mithilfe des Post-Process-Build-Skripts implementiert werden. Ein solches Skript wurde eines sch√∂nen Abends geschrieben, Sie k√∂nnen es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf GitHub sehen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Nachbearbeitungsprozess ist recht einfach zu verwenden. W√§hlen Sie ihn in einem Unity-Projekt aus. Schauen Sie im Inspektorfenster nach einem Feld mit dem Namen NewDelegateFile. Ziehen Sie Ihren ge√§nderten UnityAppController in dieses Feld und speichern Sie ihn.</font></font><br><br><img src="https://habrastorage.org/webt/zs/sb/l2/zssbl2ttito42xsbqwcpqzqfezs.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Erstellen eines iOS-Projekts wird der Standarddelegierte durch einen ge√§nderten ersetzt, und es ist kein manueller Eingriff erforderlich. </font><font style="vertical-align: inherit;">Wenn Sie dem Projekt neue benutzerdefinierte Delegaten hinzuf√ºgen, m√ºssen Sie nur noch die UnityAppController-Option √§ndern, die in Ihrem Unity-Projekt herumliegt.</font></font><br><br><h4>  PS </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielen Dank an alle, die am Ende angekommen sind. Der Artikel war wirklich sehr lang. </font><font style="vertical-align: inherit;">Ich hoffe die gemalten Informationen sind hilfreich.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430118/">https://habr.com/ru/post/de430118/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430106/index.html">Neu bei XYZprinting auf der IMTS 2018: 3D-Drucker und Roboter</a></li>
<li><a href="../de430108/index.html">Warum "Young Technician" keinen Laser bauen kann</a></li>
<li><a href="../de430112/index.html">Wie wir einem Auto beigebracht haben, mit Millionen von Menschen zu sprechen</a></li>
<li><a href="../de430114/index.html">So erstellen Sie zuverl√§ssige Spielmechaniken in Excel. Teil 2</a></li>
<li><a href="../de430116/index.html">Computer schreiben Prosa, sind aber den Menschen immer noch unterlegen. Warum?</a></li>
<li><a href="../de430120/index.html">Z√§hme das Biest. Was wir bei der Entwicklung einer pers√∂nlichen Tagebuchanwendung f√ºr React Native gesehen haben</a></li>
<li><a href="../de430122/index.html">Workaholism ist eine schmerzhafte Erkrankung, √ºber die nicht √ºblich gesprochen wird.</a></li>
<li><a href="../de430126/index.html">Eine weitere Liste von Projekten zum √úben</a></li>
<li><a href="../de430128/index.html">Entwicklung durch Testen: Verbesserung der F√§higkeiten</a></li>
<li><a href="../de430132/index.html">Was wir in den letzten Jahren √ºber die Sicherheit von Intel ME gelernt haben: 7 Fakten √ºber das mysteri√∂se Subsystem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>