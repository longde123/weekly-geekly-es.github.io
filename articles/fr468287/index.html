<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ùå üë©üèΩ‚Äç‚úàÔ∏è üè´ Attributs C #: √† propos de tous les aspects üöû ‚¨úÔ∏è ü§¶üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour lecteur. Cet article d√©crit les attributs de tous les c√¥t√©s - de la sp√©cification, de la signification et de la d√©finition des attributs, en c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Attributs C #: √† propos de tous les aspects</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468287/">  Bonjour lecteur.  Cet article d√©crit les attributs de tous les c√¥t√©s - de la sp√©cification, de la signification et de la d√©finition des attributs, en cr√©ant les v√¥tres et en travaillant avec eux, en terminant par l'ajout d'attributs lors de l'ex√©cution et les attributs existants les plus utiles et int√©ressants.  Si vous √™tes int√©ress√© par le sujet des attributs en C #, alors bienvenue dans cat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u4/uk/ee/u4ukeefozvzkxjtgw9i8zbap6ly.jpeg"></div><a name="habracut"></a><br><h2>  Table des mati√®res </h2><br><ol><li>  Pr√©sentation  D√©finition et attribution d'attributs </li><li>  Attributs int√©ressants avec support d'ex√©cution.  Ici, de br√®ves informations seront donn√©es sur divers attributs, dont peu de gens connaissent l'existence et encore moins qui les utilisent.  Puisqu'il s'agit d'informations absolument impraticables, il n'y aura pas beaucoup de diatribes (contrairement √† ma passion pour les connaissances inapplicables) </li><li> Certains des attributs peu connus qui sont utiles √† conna√Ætre. </li><li>  D√©finir votre attribut et le traiter.  Ajout d'attributs au moment de l'ex√©cution </li></ol><br><h2>  Pr√©sentation </h2><br>  Comme toujours, commencez par les d√©finitions et les sp√©cifications.  Cela aidera √† comprendre et √† r√©aliser les attributs √† tous les niveaux, ce qui, √† son tour, est tr√®s utile pour trouver les bonnes applications pour eux. <br><br>  Commencez par d√©finir les m√©tadonn√©es.  <b>Les m√©tadonn√©es</b> sont des donn√©es qui d√©crivent et font r√©f√©rence √† des types d√©finis par <abbr title="Syst√®me de type commun">CTS</abbr> .  Les m√©tadonn√©es sont stock√©es d'une mani√®re ind√©pendante de tout langage de programmation particulier.  Ainsi, les m√©tadonn√©es fournissent un m√©canisme g√©n√©ral d'√©change d'informations sur un programme √† utiliser entre les outils qui en ont besoin (compilateurs et d√©bogueurs, ainsi que le programme lui-m√™me), ainsi qu'entre <abbr title="Syst√®me d'ex√©cution virtuel">VES</abbr> .  Les m√©tadonn√©es sont incluses dans le manifeste d'assembly.  Ils peuvent √™tre stock√©s dans un fichier <abbr title="Ex√©cutable portable">PE</abbr> avec le code <abbr title="Langue interm√©diaire">IL</abbr> ou dans un fichier PE s√©par√©, o√π il n'y aura qu'un manifeste d'assembly. <br>  <b>Un attribut</b> est une caract√©ristique d'un type ou de ses membres (ou d'autres constructions de langage) qui contient des informations descriptives.  Bien que les attributs les plus courants soient pr√©d√©finis et aient un format sp√©cifique dans les m√©tadonn√©es, des attributs personnalis√©s peuvent √©galement √™tre ajout√©s aux m√©tadonn√©es.  Les attributs sont commutatifs, c'est-√†-dire  l'ordre de leur d√©claration sur l'√©l√©ment est sans importance <br><br>  <b>D'un point de vue syntaxique (dans les m√©tadonn√©es), il existe les attributs suivants</b> <br><br><ol><li>  Utilisation d'une syntaxe sp√©ciale dans IL.  Par exemple, les mots cl√©s sont des attributs.  Et pour eux, il existe une syntaxe sp√©ciale en IL.  Il y en a beaucoup; lister tout n'a pas de sens </li><li>  Utilisation d'une syntaxe g√©n√©ralis√©e.  Il s'agit notamment des attributs d'utilisateur et de biblioth√®que. </li><li>  Attributs de s√©curit√©.  Il s'agit notamment des attributs qui h√©ritent de SecurityAttribute (directement ou indirectement).  Ils sont trait√©s d'une mani√®re sp√©ciale.  Il existe une syntaxe sp√©ciale pour eux dans IL, qui vous permet de cr√©er du xml qui d√©crit ces attributs directement </li></ol><br><h4>  Exemple </h4><br><div class="spoiler">  <b class="spoiler_title">Code C # contenant tous les types d'attributs ci-dessus</b> <div class="spoiler_text"><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] [Serializable] [Obsolete] [SecurityPermission(SecurityAction.Assert)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Sample</span></span> { }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">IL r√©sultant</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.class public EXPLICIT ansi SERIALIZABLE beforefieldinit AttributeSamples.Sample extends [System.Runtime]System.Object { .custom instance void [System.Runtime]System.ObsoleteAttribute::.ctor() = (01 00 00 00 ) .permissionset assert = { class 'System.Security.Permissions.SecurityPermissionAttribute, System.Runtime.Extensions, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' = {}} .method public hidebysig specialname rtspecialname instance void .ctor() cil managed {/*constructor body*/} }</code> </pre><br></div></div><br>  Comme vous pouvez le voir, StructLayoutAttribute a une syntaxe sp√©ciale, car en IL, il est repr√©sent√© comme "explicite".  ObsoleteAttribute utilise une syntaxe commune - dans IL commence par ".custom".  SecurityPermissionAttribute en tant qu'attribut de s√©curit√© est devenu un ".permissionset assert". <br><br>  Les attributs utilisateur ajoutent des informations utilisateur aux m√©tadonn√©es.  Ce m√©canisme peut √™tre utilis√© pour stocker des informations sp√©cifiques √† l'application au moment de la compilation et pour y acc√©der au moment de l'ex√©cution ou pour la lecture et l'analyse par un autre outil.  Bien que tout type d√©fini par l'utilisateur puisse √™tre utilis√© comme attribut, la conformit√© <abbr title="Sp√©cification du langage commun">CLS</abbr> requiert que les attributs h√©ritent de System.Attribute.  <abbr title="Infrastructure linguistique commune">La CLI</abbr> pr√©d√©finit certains attributs et les utilise pour contr√¥ler le comportement d'ex√©cution.  Certaines langues d√©finissent des attributs pour repr√©senter des fonctionnalit√©s de langue non repr√©sent√©es directement dans CTS. <br><br>  Comme d√©j√† mentionn√©, les attributs sont stock√©s dans des m√©tadonn√©es, qui, √† leur tour, sont g√©n√©r√©es au stade de la compilation, c'est-√†-dire  saisies dans le fichier PE (g√©n√©ralement * .dll).  Ainsi, vous ne pouvez ajouter un attribut au moment de l'ex√©cution qu'en modifiant le fichier ex√©cutable au moment de l'ex√©cution (mais le temps des programmes √† changement automatique est r√©volu depuis longtemps).  Il s'ensuit qu'ils ne peuvent pas √™tre ajout√©s au stade de l'ex√©cution, mais ce n'est pas tout √† fait exact.  Si nous formons notre assemblage, y d√©finissons des types, nous pouvons cr√©er un nouveau type au stade de l'ex√©cution et y accrocher des attributs.  Donc, formellement, nous pouvons toujours ajouter des attributs au moment de l'ex√©cution (l'exemple sera tout en bas). <br><br><h4>  Maintenant un peu sur les limites </h4><br>  Si pour une raison quelconque, il y a 2 attributs dans le m√™me assembly avec les noms Name et NameAtribute, il devient impossible de mettre le premier d'entre eux.  Lors de l'utilisation de [Nom] (c'est-√†-dire sans suffixe), le compilateur indique qu'il voit de l'incertitude.  Lorsque vous utilisez [NameAttribute], nous mettrons NameAttribute, ce qui est logique.  Il existe une syntaxe sp√©ciale pour une telle situation mystique avec un manque d'imagination lors de la d√©nomination.  Pour mettre la premi√®re version sans suffixe, vous pouvez sp√©cifier le signe du chien (c'est-√†-dire que [Nom] est une blague, ce n'est pas n√©cessaire) avant le nom d'attribut [@Name]. <br><br>  Les attributs personnalis√©s peuvent √™tre ajout√©s √† tout sauf aux attributs personnalis√©s.  Cela fait r√©f√©rence aux m√©tadonn√©es, c'est-√†-dire  si nous mettons un attribut en C # au-dessus de la classe d'attribut, alors dans les m√©tadonn√©es, il se r√©f√©rera √† la classe.  Mais vous ne pouvez pas ajouter d'attribut √† "public".  Mais vous pouvez le faire avec des assemblys, modules, classes, types de valeur, √©num√©rations, constructeurs, m√©thodes, propri√©t√©s, champs, √©v√©nements, interfaces, param√®tres, d√©l√©gu√©s, valeurs de retour ou param√®tres g√©n√©ralis√©s.  L'exemple ci-dessous montre des exemples √©vidents et peu nombreux de la fa√ßon dont vous pouvez mettre un attribut sur une construction particuli√®re. <br><br><div class="spoiler">  <b class="spoiler_title">Syntaxe de d√©claration d'attribut</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Runtime.InteropServices; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Security.Permissions; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> AttributeSamples; [assembly:All] [module:All] <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">AttributeSamples</span></span> { [AttributeUsage(AttributeTargets.All)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AllAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { } [All] <span class="hljs-comment"><span class="hljs-comment">//   public class Usage { [All] //   [return:All] //     public int GiveMeInt&lt;[All]T&gt;([All]int param) { return 5 + param; } [All] //   [field:All] //        public event Action Event; [All] //   [field: All] //       public int Action { get; set; } } }</span></span></code> </pre><br></div></div><br>  Les attributs ont 2 types de param√®tres - nomm√©s et positionnels.  Les param√®tres de position incluent les param√®tres du constructeur.  To named - propri√©t√©s publiques avec un setter accessible.  De plus, ce ne sont pas seulement des noms formels; tous les param√®tres peuvent √™tre indiqu√©s lors de la d√©claration d'un attribut entre crochets apr√®s son nom.  Les noms sont facultatifs. <br><br><div class="spoiler">  <b class="spoiler_title">Types de param√®tres</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AttributeUsage(AttributeTargets.All, AllowMultiple = true)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AttrParamsAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AttrParamsAttribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> positional</span></span></span><span class="hljs-function">) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//  { } public int Named { get; set; } //  } [AttrParams(1)] [AttrParams(1, Named = 2)] public class AttrParams { }</span></span></span></span></code> </pre><br></div></div><br>  Les param√®tres valides (des deux types) pour l'attribut doivent √™tre l'un des types suivants: <br><br><ol><li>  bool, byte, char, double, float, int, long, short, string et plus loin primitive, except decimal </li><li>  objet </li><li>  System.Type </li><li>  √©num√©rer </li><li>  Un tableau unidimensionnel de l'un des types ci-dessus </li></ol><br>  Cela est d√ª en grande partie au fait qu'il devrait s'agir d'une constante au moment de la compilation, et les types ci-dessus peuvent accepter cette constante (en acceptant un objet, nous pouvons passer int).  Mais pour une raison quelconque, l'argument ne peut pas √™tre de type ValueType, bien que cela soit possible d'un point de vue logique. <br><br>  Il existe deux types d'attributs utilisateur: les attributs personnalis√©s authentiques et les <b>pseudo-personnalis√©s</b> . <br>  Dans le code, ils se ressemblent (ils sont indiqu√©s au-dessus de la structure du langage entre crochets), mais ils sont trait√©s diff√©remment: <br><br><ol><li>  L'attribut utilisateur d'origine est stock√© directement dans les m√©tadonn√©es;  les param√®tres d'attribut sont stock√©s tels quels.  Ils sont disponibles au moment de l'ex√©cution et sont enregistr√©s sous forme d'un ensemble d'octets (je m'empresse de vous rappeler qu'ils sont connus au moment de la compilation) </li><li>  Un attribut pseudo-utilisateur est reconnu car son nom fait partie d'une liste sp√©ciale.  Au lieu de stocker ses donn√©es directement dans les m√©tadonn√©es, il est analys√© et utilis√© pour d√©finir des bits ou des champs dans les tables de m√©tadonn√©es, puis les donn√©es sont supprim√©es et ne peuvent plus √™tre re√ßues.  Les tables de m√©tadonn√©es sont v√©rifi√©es lors de l'ex√©cution plus rapidement que les attributs utilisateur authentiques, et moins de stockage est requis pour stocker les informations. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Les attributs pseudo-utilisateurs ne sont pas une r√©flexion visible</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] [StructLayout(LayoutKind.Explicit)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomPseudoCustom</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onlyCustom = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CustomPseudoCustom).GetCustomAttributes(); <span class="hljs-comment"><span class="hljs-comment">// SerializableAttribute } }</span></span></code> </pre><br></div></div><br>  La plupart des attributs utilisateur sont introduits au niveau de la langue.  Ils sont stock√©s et renvoy√©s par le runtime, tandis que le runtime ne sait rien de la signification de ces attributs.  Mais tous les attributs pseudo-utilisateur ainsi que certains attributs utilisateur pr√©sentent un int√©r√™t particulier pour les compilateurs et la CLI.  Nous passons donc √† la section suivante. <br><br><h2>  Attributs activ√©s pour l'ex√©cution </h2><br>  Cette section est purement informative, s'il n'y a aucun int√©r√™t √† utiliser le runtime, vous pouvez passer √† la section suivante. <br><br>  Le tableau ci-dessous r√©pertorie les attributs pseudo-utilisateur et les attributs utilisateur sp√©ciaux (les CLI ou les compilateurs les traitent de mani√®re sp√©ciale). <br><br>  Attributs pseudo-utilisateurs (ils ne peuvent pas √™tre obtenus par r√©flexion). <br>  Attributs CLI: <br><div class="scrollable-table"><table><tbody><tr><th>  Attribut </th><th>  La description </th></tr><tr><td>  AssemblyAlgorithmIDAttribute </td><td>  √âcrit l'identifiant de l'algorithme de hachage utilis√©.  D√©finit le champ Assembly.HashAlgId </td></tr><tr><td>  AssemblyFlagsAttribute </td><td>  √âcrit des drapeaux pour l'assembly correspondant.  D√©finit le champ Assembly.Flags </td></tr><tr><td>  DllImportAttribute </td><td>  Fournit des informations sur le code impl√©ment√© dans une biblioth√®que non g√©r√©e.  D√©finit le bit Method.Flags.PinvokeImpl de la m√©thode correspondante;  ajoute une nouvelle entr√©e √† ImplMap (en d√©finissant les valeurs de MappingFlags, MemberForwarded, ImportName et ImportScope) </td></tr><tr><td>  StructLayoutAttribute </td><td>  Vous permet de d√©finir explicitement la m√©thode de placement des champs de r√©f√©rence ou de type significatif.  D√©finit le champ TypeDef.Flags.LayoutMask pour le type.  Il peut √©galement d√©finir les champs TypeDef.Flags.StringFormatMask, ClassLayout.PackingSize et ClassLayout.ClassSize </td></tr><tr><td>  FieldOffsetAttribute </td><td>  D√©finit le d√©calage d'octet des champs dans une r√©f√©rence ou un type significatif.  D√©finit la valeur de FieldLayout.OffSet pour la m√©thode correspondante. </td></tr><tr><td>  Inattribuer </td><td>  Indique que le param√®tre est transmis en tant qu'argument [in].  D√©finit le bit Param.Flags.In pour le param√®tre correspondant. </td></tr><tr><td>  Outattribute </td><td>  Indique que le param√®tre est pass√© en tant qu'argument [out].  D√©finit le bit Param.Flags.Out pour le param√®tre correspondant. </td></tr><tr><td>  Marshalasattribute </td><td>  D√©finit comment les donn√©es sont marshal√©es entre le code manag√© et non manag√©.  D√©finit le bit Field.Flags.HasFieldMarshal pour le champ (ou le bit Param.Flags.HasFieldMarshal pour le param√®tre);  Ajoute une entr√©e √† la table FieldMarshal (en d√©finissant les valeurs de Parent et NativeType) </td></tr><tr><td>  MethodImplAttribute </td><td>  D√©finit les d√©tails d'impl√©mentation d'une m√©thode.  D√©finit la valeur de Method.ImplFlags pour la m√©thode correspondante </td></tr></tbody></table></div><br><br>  Attributs CLS - Les langues doivent les prendre en charge: <br><div class="scrollable-table"><table><tbody><tr><th>  Attribut </th><th>  La description </th></tr><tr><td>  AttributeUsageAttribute </td><td>  Utilis√© pour indiquer comment un attribut peut √™tre utilis√©. </td></tr><tr><td>  ObsoleteAttribute </td><td>  Indique que l'√©l√©ment ne doit pas √™tre utilis√©. </td></tr><tr><td>  CLSCompliantAttribute </td><td>  Indique si un √©l√©ment est d√©clar√© conforme CLS. </td></tr></tbody></table></div><br>  Divers int√©ressant <br><div class="scrollable-table"><table><tbody><tr><th>  Attribut </th><th>  La description </th></tr><tr><td>  ThreadStaticAttribute </td><td>  Fournit des champs de type li√©s au flux </td></tr><tr><td>  ConditionnelAttribut </td><td>  Marque la m√©thode comme invoqu√©e en fonction d'une condition de compilation (sp√©cifi√©e dans / define).  Si la condition n'est pas remplie, la m√©thode ne sera pas appel√©e (et ne sera pas compil√©e dans IL).  Seule la m√©thode void peut √™tre balis√©e.  Sinon, une erreur de compilation se produira. </td></tr><tr><td>  DecimalConstantAttribute </td><td>  Stocke la valeur constante d√©cimale dans les m√©tadonn√©es </td></tr><tr><td>  DefaultMemberAttribute </td><td>  D√©finit le membre de la classe √† utiliser par d√©faut avec la m√©thode InvokeMember. </td></tr><tr><td>  CompilationRelaxationsAttribut </td><td>  Indique si les exceptions aux v√©rifications d'instructions sont strictes ou assouplies.  Actuellement, vous ne pouvez transmettre que le param√®tre NoStringInterning, qui marque l'assembly comme ne n√©cessitant pas d'internement litt√©ral de cha√Æne.  Mais ce m√©canisme peut toujours √™tre utilis√©. </td></tr><tr><td>  DrapeauxAttribut </td><td>  Attribut indiquant si l'√©num√©ration doit √™tre trait√©e comme des indicateurs de bit </td></tr><tr><td>  IndexerNameAttribute </td><td>  Sp√©cifie le nom sous lequel l'indexeur sera connu dans les langages de programmation qui ne prennent pas directement en charge cette fonctionnalit√©. </td></tr><tr><td>  ParamArrayAttribute </td><td>  Indique que la m√©thode accepte un nombre variable de param√®tres. </td></tr></tbody></table></div><br><h2>  Attributs utiles </h2><br>  Le d√©bogage fait partie int√©grante du d√©veloppement de produits logiciels.  Et souvent, dans un syst√®me vaste et complexe, il faut des dizaines et des centaines de fois pour ex√©cuter la m√™me m√©thode et surveiller l'√©tat des objets.  Dans le m√™me temps, √† un moment de 20, il commence d√©j√† √† exasp√©rer sp√©cifiquement la n√©cessit√© d'√©tendre un objet en profondeur 400 fois pour voir la valeur d'une variable et red√©marrer la m√©thode √† nouveau. <br>  Pour un d√©bogage plus silencieux et plus rapide, vous pouvez utiliser des attributs qui modifient le comportement du d√©bogueur. <br><br>  <b>DebuggerDisplayAttribute</b> indique comment le type ou son membre est affich√© dans la fen√™tre des variables du d√©bogueur (et pas seulement). <br><br>  Le seul argument du constructeur est une cha√Æne avec un format d'affichage.  Ce qui sera entre les accolades sera calcul√©.  Le format est comme une cha√Æne interpol√©e, mais sans dollar.  Vous ne pouvez pas utiliser de pointeurs dans une valeur calcul√©e.  Soit dit en passant, si vous avez une ToString remplac√©e, sa valeur sera affich√©e comme si elle se trouvait dans cet attribut.  S'il existe √† la fois une ToString et un attribut, la valeur est extraite de l'attribut. <br><img src="https://habrastorage.org/webt/eg/l9/mp/egl9mpyoppftcevpckbs4qznh-c.png"><br><br>  <b>DebuggerBrowsableAttribute</b> d√©finit la fa√ßon dont un champ ou une propri√©t√© est affich√© dans la fen√™tre des variables du d√©bogueur.  Accepte un DebuggerBrowsableState, qui a 3 options: <br><br><ul><li>  Jamais - le champ ne s'affiche pas du tout pendant le d√©bogage.  Lorsque vous d√©veloppez la hi√©rarchie des objets, ce champ ne sera pas affich√© </li><li>  R√©duit - le champ n'est pas r√©solu, mais il peut √™tre d√©velopp√©.  Il s'agit du comportement par d√©faut. </li><li>  RootHidden - le champ lui-m√™me n'est pas affich√©, mais les objets qui le composent sont affich√©s (pour les tableaux et les collections) </li></ul><br><img src="https://habrastorage.org/webt/6m/a5/gf/6ma5gf06sqj0eryekzparfrzq0i.png"><br><br>  <b>DebuggerTypeProxy</b> - si l'objet est affich√© dans le d√©bogueur des centaines de fois par jour, vous pouvez √™tre confus et passer 3 minutes √† cr√©er un objet proxy qui affiche l'objet d'origine comme il se doit.  En r√®gle g√©n√©rale, l'objet proxy √† afficher est la classe interne.  En fait, il sera affich√© √† la place de l'objet cible. <br><br><img src="https://habrastorage.org/webt/np/bg/zd/npbgzdwf_ontlgkwcr3adapeink.png"><br><br>  Autres attributs utiles <br><br>  <b>ThreadStatic</b> - un attribut qui vous permet de cr√©er une variable statique pour chaque thread.  Pour ce faire, placez l'attribut au-dessus du champ statique.  Il convient de rappeler une nuance importante - l'initialisation par un constructeur statique ne sera effectu√©e qu'une seule fois, et la variable changera dans le thread que le constructeur statique ex√©cutera.  Dans le reste, il restera par d√©faut.  (PS. Si vous avez besoin de ce comportement, je vous conseille de regarder vers la classe ThreadLocal). <br><br>  Un peu sur les nuances du compartiment moteur.  Sous Linux et Windows, il existe une zone de m√©moire locale au flux ( <abbr title="Thread stockage local">TLS</abbr> et <abbr title="Donn√©es sp√©cifiques au thread">TSD,</abbr> respectivement).  Cependant, ces zones elles-m√™mes sont tr√®s petites.  Par cons√©quent, une structure ThreadLocalInfo est cr√©√©e, un pointeur vers lequel est plac√© dans TLS.  Par cons√©quent, un seul emplacement est utilis√©.  La structure elle-m√™me contient 3 champs - Thread, AppDomain, ClrTlsInfo.  Nous nous int√©ressons au premier.  C'est lui qui organise le stockage des statiques de flux en m√©moire, en utilisant pour cela ThreadLocalBlock et ThreadLocalModule. <br><br>  De cette fa√ßon: <br><br><ul><li>  Types de r√©f√©rence - situ√©s sur le tas, ThreadStaticHandleTable, qui est pris en charge par la classe ThreadLocalBlock, conserve des liens vers eux. </li><li>  Structures - Emball√©es et stock√©es dans un tas g√©r√© ainsi que des types de r√©f√©rence </li><li>  Les types significatifs primitifs sont stock√©s dans des zones de m√©moire non g√©r√©e qui font partie de ThreadLocalModule </li></ul><br>  Eh bien, puisque nous en parlons, il convient de mentionner les m√©thodes asynchrones.  Comme un lecteur attentif le remarquera, si nous utilisons l'asynchronie, la suite ne sera pas n√©cessairement ex√©cut√©e dans le m√™me thread (nous pouvons influencer le contexte d'ex√©cution, mais pas le thread).  En cons√©quence, nous obtenons une merde si nous utilisons ThreadLocal.  Dans ce cas, il est recommand√© d'utiliser AsyncLocal.  Mais l'article ne traite pas de cela, nous sommes donc all√©s plus loin. <br><br>  <b>InternalsVisibleTo</b> - vous permet de sp√©cifier l'assemblage, qui sera visible pour les √©l√©ments marqu√©s <i>internes</i> .  Il peut sembler que si une assembl√©e a besoin de certains types et de leurs membres, vous pouvez simplement les marquer comme <i>publics</i> et non pas steam.  Mais une bonne architecture implique de cacher les d√©tails de l'impl√©mentation.  N√©anmoins, ils peuvent √™tre n√©cessaires pour certaines choses d'infrastructure, par exemple, des projets de test.  En utilisant cet attribut, vous pouvez prendre en charge √† la fois l'encapsulation et le pourcentage requis de couverture de test. <br><br>  <b>HandleProcessCorruptedStateExceptions</b> - vous permet d'effrayer les programmeurs timides et de <b>d√©tecter</b> les exceptions d'un √©tat endommag√©.  Par d√©faut, pour de telles exceptions, le CLR n'est pas intercept√©.  En g√©n√©ral, la meilleure solution serait de laisser l'application se bloquer.  Ce sont des exceptions dangereuses qui indiquent que la m√©moire du processus est corrompue, donc l'utilisation de cet attribut est une tr√®s mauvaise id√©e.  Mais il est possible dans certains cas, pour le d√©veloppement local, il sera utile de d√©finir cet attribut pendant un certain temps.  Pour intercepter l'exception d'un √©tat endommag√©, placez simplement cet attribut au-dessus de la m√©thode.  Et s'il a d√©j√† atteint l'utilisation de cet attribut, il est recommand√© (cependant, comme toujours) d'attraper une exception sp√©cifique. <br><br>  <b>DisablePrivateReflection</b> - rend tous les membres priv√©s de l'assembly inaccessibles √† la r√©flexion.  L'attribut est plac√© sur l'assemblage. <br><br><h2>  D√©finition de votre attribut </h2><br>  Pas seulement parce que cette section est la derni√®re.  Apr√®s tout, la meilleure fa√ßon de comprendre dans quels cas il sera avantageux d'utiliser l'attribut est de regarder ceux d√©j√† utilis√©s.  Il est difficile de dire une r√®gle formalis√©e quand vous devez penser √† votre propre attribut.  Ils sont souvent utilis√©s comme informations suppl√©mentaires sur un type / son membre ou une autre construction de langage commune √† des entit√©s compl√®tement diff√©rentes.  A titre d'exemple, tous les attributs utilis√©s pour la s√©rialisation / ORM / formatage, etc.  En raison de l'application √©tendue de ces m√©canismes √† des types compl√®tement diff√©rents, souvent inconnus des d√©veloppeurs du m√©canisme correspondant, l'utilisation d'attributs est un excellent moyen pour permettre √† l'utilisateur de fournir des informations d√©claratives pour ce m√©canisme. <br><br>  L'utilisation de vos attributs peut √™tre divis√©e en 2 parties: <br><br><ol><li>  Cr√©er un attribut et l'utiliser </li><li>  Obtenir un attribut et le traiter </li></ol><br><h4>  Cr√©er un attribut et l'utiliser </h4><br>  Pour cr√©er votre attribut, il suffit d'h√©riter de <i>System.Attribute</i> .  Dans ce cas, il est conseill√© de respecter le style de nommage mentionn√© - terminez le nom de la classe sur Attribut.  Cependant, il n'y aura pas d'erreur si vous omettez ce suffixe.  Comme mentionn√© pr√©c√©demment, les attributs peuvent avoir 2 types de param√®tres - positionnels et nomm√©s.  La logique de leur application est la m√™me que pour les propri√©t√©s et les param√®tres du constructeur de la classe - les valeurs n√©cessaires pour cr√©er l'objet pour lequel il n'y a pas de "valeur par d√©faut" raisonnable sont plac√©es en position (c'est-√†-dire, constructeur).  Ce qui peut √™tre raisonnablement par d√©faut, qui sera souvent utilis√©, est mieux distingu√© en un nom (c'est-√†-dire une propri√©t√©). <br><br>  La limitation de ses lieux d'application n'est pas d'une importance minime dans la cr√©ation d'un attribut.  AttributeUsageAttribute est utilis√© pour cela.  Le param√®tre requis (positionnel) est le AttributeTarget, qui d√©termine o√π l'attribut est utilis√© (m√©thode, assemblage, etc.).  Les param√®tres facultatifs (nomm√©s) sont: <br><br><ol><li>  AllowMultiple - indique s'il est possible de placer plus d'un attribut √† la place de son application ou non.  Faux par d√©faut </li><li>  H√©rit√© - d√©termine si cet attribut appartiendra aux h√©ritiers des classes (en cas de placement sur la classe de base) et aux m√©thodes remplac√©es (en cas de placement sur la m√©thode).  La valeur par d√©faut est vraie. </li></ol><br>  Apr√®s cela, vous pouvez charger les attributs avec une charge utile.  Un attribut est une information d√©clarative, ce qui signifie que tout ce qui y est d√©fini doit d√©crire la construction √† laquelle il se rapporte.  L'attribut ne doit contenir aucune logique profonde.  Pour le traitement des attributs que vous d√©finissez, des services sp√©ciaux devraient √™tre charg√©s de les traiter.  Mais le fait que l'attribut ne devrait pas avoir de logique ne signifie pas qu'il ne devrait pas avoir de m√©thodes. <br><br>  Une m√©thode (fonction) est √©galement une information et peut √©galement d√©crire une conception.  Et en utilisant le polymorphisme dans les attributs, vous pouvez fournir un outil tr√®s puissant et pratique o√π l'utilisateur peut influencer √† la fois les informations utilis√©es par votre outil et certaines √©tapes d'ex√©cution et de traitement.        ,  ,     ,     .     -,        ,    . ,  ,   ¬´¬ª    . <br><br><h4>     </h4><br>             -.        . <br><br>         .         . <br><br>       <a href="">ICustomAttributeProvider</a> .      Assembly, MemberInfo, Module, ParameterInfo.     MemberInfo  Type, EventInfo, FieldInfo, MethodBase, PropertyInfo. <br><br>    3 ,     .     (   ,      )     ( object).          (  ,      ).      <a href="">CustomAttributeExtensions</a> ,         ,      ,      ,       .         Attribute      inherit ( ). <br><br>     .  ,     ,  .  ,    <i>bool inherit</i>     (    <i>true</i> ).   ,             (    ).  ,    <i>inherit = flase</i> ,      true       <br><div class="scrollable-table"><table><tbody><tr><th>   </th><th>  La description </th></tr><tr><td> GetCustomAttributes&lt;LogAttribute&gt;(bool inherit) </td><td>     .   ,    1  </td></tr><tr><td> GetCustomAttribute&lt;LogAttribute&gt;(bool inherit) </td><td>     .   ,   <i>System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found</i> </td></tr><tr><td> GetCustomAttributes() </td><td>      </td></tr><tr><td> GetCustomAttributesData() </td><td>   CustomAttributeData,       ,  (  ),   </td></tr><tr><td> IsDefined(Type attrType, bool inherit) </td><td>  true,     , false   </td></tr></tbody></table></div><br>           . <br><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AttributeUsage(AttributeTargets.All, AllowMultiple = true)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LogAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> LogName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } [AttributeUsage(AttributeTargets.All, AllowMultiple = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, Inherited = <span class="hljs-literal"><span class="hljs-literal">false</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SerializeAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SerializeName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogBase1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogBase2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeBase1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeBase2"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RandomDomainEntityBase</span></span> { [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogMethod1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogMethod2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeMethod1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeMethod2"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); } } [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogDerived1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogDerived2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeDerived1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeDerived2"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RandomDomainEntityDerived</span></span> : <span class="hljs-title"><span class="hljs-title">RandomDomainEntityBase</span></span> { [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogOverride1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogOverride2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeOverride1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeOverride2"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type derivedType = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(RandomDomainEntityDerived); MemberInfo overrideMethod = derivedType.GetMethod(<span class="hljs-string"><span class="hljs-string">"VirtualMethod"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// overrideMethod.GetCustomAttribute(typeof(LogAttribute)); //System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found. // overrideMethod.GetCustomAttribute&lt;LogAttribute&gt;(false); // System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found. // Attribute.GetCustomAttribute(derivedType, typeof(SerializeAttribute)); // System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found. IEnumerable&lt;Attribute&gt; allCustom = overrideMethod.GetCustomAttributes(); //LogOverride1 LogOverride2 SerializeOverride1 SerializeOverride2 LogMethod1 LogMethod2 IList&lt;CustomAttributeData&gt; allCustomInfo = overrideMethod.GetCustomAttributesData(); //  ,     IEnumerable&lt;LogAttribute&gt; typedCustom1 = overrideMethod.GetCustomAttributes&lt;LogAttribute&gt;(inherit:false); //LogOverride1 LogOverride2 IEnumerable&lt;LogAttribute&gt; typedInheritedCustom1 = overrideMethod.GetCustomAttributes&lt;LogAttribute&gt;(inherit:true); //LogOverride1 LogOverride2 LogMethod1 LogMethod2 IEnumerable&lt;SerializeAttribute&gt; typedCustom2 = overrideMethod.GetCustomAttributes&lt;SerializeAttribute&gt;(inherit:false); //SerializeOverride1 SerializeOverride2 IEnumerable&lt;SerializeAttribute&gt; typedInheritedCustom2 = overrideMethod.GetCustomAttributes&lt;SerializeAttribute&gt;(inherit:true); //SerializeOverride1 SerializeOverride2 Attribute[] customFromStaticClass = Attribute.GetCustomAttributes(overrideMethod, typeof(SerializeAttribute), inherit:true); //SerializeOverride1 SerializeOverride2 IEnumerable&lt;Attribute&gt; classCustom = derivedType.GetCustomAttributes(); //LogDerived1 LogDerived2 SerializeDerived1 SerializeDerived2 LogBase1 LogBase2 IList&lt;CustomAttributeData&gt; classCustomInfo = derivedType.GetCustomAttributesData(); //  ,     IEnumerable&lt;LogAttribute&gt; typedClassCustom1 = derivedType.GetCustomAttributes&lt;LogAttribute&gt;(false); //LogDerived1 LogDerived2 IEnumerable&lt;LogAttribute&gt; typedInheritedClassCustom1 = derivedType.GetCustomAttributes&lt;LogAttribute&gt;(true); //LogDerived1 LogDerived2 LogBase1 LogBase2 IEnumerable&lt;SerializeAttribute&gt; typedClassCustom2 = derivedType.GetCustomAttributes&lt;SerializeAttribute&gt;(false); //SerializeDerived1 SerializeDerived2 IEnumerable&lt;SerializeAttribute&gt; typedInheritedClassCustom2 = derivedType.GetCustomAttributes&lt;SerializeAttribute&gt;(true); //SerializeDerived1 SerializeDerived2 } }</span></span></code> </pre><br></div></div><br>            .          . <br><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TypeCreator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> TypeSignature = <span class="hljs-string"><span class="hljs-string">"DynamicType"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ModuleName = <span class="hljs-string"><span class="hljs-string">"DynamicModule"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> AssemblyName = <span class="hljs-string"><span class="hljs-string">"DynamicModule"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> TypeBuilder _typeBuilder = GetTypeBuilder(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateTypeInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _typeBuilder.DefineNestedType(<span class="hljs-string"><span class="hljs-string">"ClassName"</span></span>); CreatePropertyWithAttribute&lt;SerializeAttribute&gt;(<span class="hljs-string"><span class="hljs-string">"PropWithAttr"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Type[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]); Type newType = _typeBuilder.CreateType(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Activator.CreateInstance(newType); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CreatePropertyWithAttribute&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName, Type propertyType, Type[] ctorTypes, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] ctorArgs) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : Attribute { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attributeCtor = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T).GetConstructor(ctorTypes); CustomAttributeBuilder caBuilder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomAttributeBuilder(attributeCtor, ctorArgs); PropertyBuilder newProperty = CreateProperty(propertyName, propertyType); newProperty.SetCustomAttribute(caBuilder); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> PropertyBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> propertyName, Type propertyType</span></span></span><span class="hljs-function">)</span></span> { FieldBuilder fieldBuilder = _typeBuilder.DefineField(propertyName, propertyType, FieldAttributes.Private); PropertyBuilder propertyBuilder = _typeBuilder.DefineProperty(propertyName, PropertyAttributes.HasDefault, propertyType, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); MethodAttributes getSetAttr = MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig; MethodBuilder getter = GenerateGetter(); MethodBuilder setter = GenerateSetter(); propertyBuilder.SetGetMethod(getter); propertyBuilder.SetSetMethod(setter); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> propertyBuilder; <span class="hljs-function"><span class="hljs-function">MethodBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateGetter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { MethodBuilder getMethodBuilder = _typeBuilder.DefineMethod(<span class="hljs-string"><span class="hljs-string">$"get_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{propertyName}</span></span></span><span class="hljs-string">"</span></span>, getSetAttr, propertyType, Type.EmptyTypes); ILGenerator getterIl = getMethodBuilder.GetILGenerator(); getterIl.Emit(OpCodes.Ldarg_0); getterIl.Emit(OpCodes.Ldfld, fieldBuilder); getterIl.Emit(OpCodes.Ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getMethodBuilder; } <span class="hljs-function"><span class="hljs-function">MethodBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateSetter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { MethodBuilder setMethodBuilder = _typeBuilder.DefineMethod(<span class="hljs-string"><span class="hljs-string">$"set_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{propertyName}</span></span></span><span class="hljs-string">"</span></span>, getSetAttr, <span class="hljs-literal"><span class="hljs-literal">null</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { propertyType }); ILGenerator setterIl = setMethodBuilder.GetILGenerator(); setterIl.Emit(OpCodes.Ldarg_0); setterIl.Emit(OpCodes.Ldarg_1); setterIl.Emit(OpCodes.Stfld, fieldBuilder); setterIl.Emit(OpCodes.Ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> setMethodBuilder; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTypeBuilder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AssemblyName(AssemblyName), AssemblyBuilderAccess.Run); ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule(ModuleName); TypeBuilder typeBuilder = moduleBuilder.DefineType(TypeSignature, TypeAttributes.Public | TypeAttributes.Class | TypeAttributes.AutoClass | TypeAttributes.AnsiClass | TypeAttributes.BeforeFieldInit | TypeAttributes.AutoLayout,<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> typeBuilder; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TypeCreator().CreateTypeInstance(); IEnumerable&lt;Attribute&gt; attrs = instance.GetType().GetProperty(<span class="hljs-string"><span class="hljs-string">"PropWithAttr"</span></span>).GetCustomAttributes(); <span class="hljs-comment"><span class="hljs-comment">// Serializable } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468287/">https://habr.com/ru/post/fr468287/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468265/index.html">Faire des bonbons avec Vim</a></li>
<li><a href="../fr468267/index.html">Renforcement de la m√©thodologie UseCase donn√©e dans le livre d'Alistair Coburn</a></li>
<li><a href="../fr468271/index.html">Tests vs Types - Version rouille</a></li>
<li><a href="../fr468277/index.html">Le travail du programmeur est-il difficile - une vue du point de vue de la psychophysiologie</a></li>
<li><a href="../fr468285/index.html">Meilleures soci√©t√©s de d√©veloppement de logiciels pour les entreprises et les startups</a></li>
<li><a href="../fr468289/index.html">AM</a></li>
<li><a href="../fr468291/index.html">Synopsis du livre de Mark Gaulston ¬´Je peux vous entendre¬ª</a></li>
<li><a href="../fr468293/index.html">Vive Cosmos - examen du nouvel ensemble VR de HTC</a></li>
<li><a href="../fr468295/index.html">50 nuances de matplotlib - The Master Plots (avec le code Python complet)</a></li>
<li><a href="../fr468299/index.html">Que d√©velopper Oracle pour un d√©veloppeur en 2019 (et apr√®s)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>