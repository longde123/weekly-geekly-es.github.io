<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëå üë®üèø‚Äçüè´ üßöüèΩ Swift: ARC- und Speicherverwaltung üí∞ üç° üîê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als moderne Hochsprache k√ºmmert sich Swift im Wesentlichen um die Speicherverwaltung in Ihren Anwendungen, um Speicher zuzuweisen und freizugeben. Die...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Swift: ARC- und Speicherverwaltung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451130/">  Als moderne Hochsprache k√ºmmert sich <b>Swift im</b> Wesentlichen um die Speicherverwaltung in Ihren Anwendungen, um Speicher zuzuweisen und freizugeben.  Dies ist auf einen Mechanismus zur√ºckzuf√ºhren, der als <b>automatische Referenzz√§hlung</b> , kurz <b>ARC, bezeichnet wird</b> .  In diesem Handbuch erfahren Sie, wie ARC funktioniert und wie Sie den Speicher in Swift ordnungsgem√§√ü verwalten.  Wenn Sie diesen Mechanismus verstehen, k√∂nnen Sie die Lebensdauer von Objekten auf dem Heap ( <b>Heap</b> ) beeinflussen. <br><br>  In diesem Handbuch lernen Sie Swift und ARC kennen, indem Sie Folgendes lernen: <br><br><ul><li>  wie ARC funktioniert </li><li>  Was sind <b>Referenzzyklen</b> und wie werden sie richtig behoben? </li><li>  So erstellen Sie eine Beispiel-Link-Schleife </li><li>  So finden Sie Link-Loops mit den von Xcode angebotenen visuellen Tools </li><li>  Umgang mit Referenztypen und Werttypen </li></ul><a name="habracut"></a><br><h2>  Erste Schritte </h2><br>  Laden Sie die <a href="" rel="nofollow">Quellmaterialien</a> herunter <a href="" rel="nofollow">.</a>  √ñffnen Sie das Projekt im Ordner <b>Cycles / Starter</b> .  Im ersten Teil unseres Handbuchs werden wir uns mit den wichtigsten Konzepten befassen und uns ausschlie√ülich mit der Datei <b>MainViewController.swif</b> t befassen. <br><br>  F√ºgen Sie diese Klasse am Ende von MainViewController.swift hinzu: <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(name: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"User \(name) was initialized"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Deallocating user named: \(name)"</span></span>) } }</code> </pre> <br>  Hier wird die <b>User-</b> Klasse definiert, die uns mit Hilfe von <b>print-</b> Anweisungen √ºber die Initialisierung und Freigabe der Klasseninstanz informiert. <br><br>  Erstellen Sie nun eine Instanz der User-Klasse oben im MainViewController. <br><br>  Platzieren Sie diesen Code vor der <b>viewDidLoad ()</b> -Methode: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = <span class="hljs-type"><span class="hljs-type">User</span></span>(name: <span class="hljs-string"><span class="hljs-string">"John"</span></span>)</code> </pre> <br>  Starten Sie die App.  Machen Sie die Xcode-Konsole mit <b>Command-Shift-Y</b> sichtbar, um die Ausgabe der print-Anweisungen anzuzeigen. <br><br>  Beachten Sie, dass <b>Benutzer John initialisiert wurde</b> und auf der Konsole <b>angezeigt wurde</b> , die print-Anweisung in <b>deinit jedoch</b> nicht ausgef√ºhrt wurde.  Dies bedeutet, dass dieses Objekt nicht freigegeben wurde, da es nicht au√üerhalb des <b>G√ºltigkeitsbereichs lag</b> . <br><br>  Mit anderen Worten, bis der Ansichtscontroller, der dieses Objekt enth√§lt, den G√ºltigkeitsbereich verl√§sst, wird das Objekt niemals freigegeben. <br><br><h2>  Ist er im Umfang? </h2><br>  Indem wir eine Instanz der User-Klasse in eine Methode einbinden, wird sie au√üerhalb des G√ºltigkeitsbereichs liegen, sodass ARC sie freigeben kann. <br><br>  Lassen Sie uns die <b>runScenario ()</b> -Methode in der MainViewController-Klasse erstellen und die Initialisierung der User-Klasseninstanz darin verschieben. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runScenario</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = <span class="hljs-type"><span class="hljs-type">User</span></span>(name: <span class="hljs-string"><span class="hljs-string">"John"</span></span>) }</code> </pre><br>  runScenario () definiert den Bereich der Benutzerinstanz.  Beim Verlassen dieser Zone muss der <b>Benutzer</b> freigegeben werden. <br><br>  Rufen Sie nun runScenario () auf und f√ºgen Sie dies am Ende von viewDidLoad () hinzu: <br><br><pre> <code class="swift hljs">runScenario()</code> </pre> <br>  Starten Sie die App.  Die Konsolenausgabe sieht nun folgenderma√üen aus: <br><br>  Benutzer John wurde initialisiert <br>  Freigabe des Benutzers mit dem Namen: John <br><br>  Dies bedeutet, dass Sie ein Objekt freigegeben haben, das das Sichtfeld verlassen hat. <br><br><h2>  Objektlebensdauer </h2><br><br>  Die Existenz des Objekts ist in f√ºnf Stufen unterteilt: <br><br><ul><li>  Speicherzuordnung: vom Stapel oder vom Heap </li><li>  Initialisierung: Code wird in init ausgef√ºhrt </li><li>  Verwendung von </li><li>  Deinitialisierung: Code wird innerhalb von Deinit ausgef√ºhrt </li><li>  Freier Speicher: Der zugewiesene Speicher wird an den Stapel oder Heap zur√ºckgegeben </li></ul><br>  Es gibt keine direkte M√∂glichkeit, die Schritte zum Zuweisen und Freigeben von Speicher zu verfolgen, aber Sie k√∂nnen den Code in init und deinit verwenden. <br><br>  <b>Referenzz√§hlungen</b> , auch als <b>Nutzungsz√§hlungen bezeichnet</b> , bestimmen, wann ein Objekt nicht mehr ben√∂tigt wird.  Dieser Z√§hler zeigt die Anzahl derer an, die dieses Objekt "verwenden".  Ein Objekt wird unn√∂tig, wenn der Nutzungsz√§hler Null ist.  Dann wird das Objekt de-initialisiert und freigegeben. <br><br><img src="https://habrastorage.org/webt/b5/oo/78/b5oo78ealf173ey0ayz7rngnszk.png"><br><br>  Wenn das Benutzerobjekt initialisiert wird, betr√§gt sein Referenzz√§hler 1, da die <b>Benutzerkonstante</b> auf dieses Objekt verweist. <br><br>  Am Ende von runScenario () verl√§sst der Benutzer den G√ºltigkeitsbereich und der Referenzz√§hler wird auf 0 reduziert. Infolgedessen wird der Benutzer nicht initialisiert und dann freigegeben. <br><br><h2>  Referenzzyklen </h2><br>  In den meisten F√§llen funktioniert ARC wie es sollte.  Der Entwickler muss sich normalerweise nicht um Speicherverluste k√ºmmern, wenn nicht verwendete Objekte auf unbestimmte Zeit nicht zugewiesen werden. <br><br>  Aber nicht immer!  M√∂gliche Speicherlecks. <br><br>  Wie kann das passieren?  Stellen Sie sich eine Situation vor, in der zwei Objekte nicht mehr verwendet werden, sich aber jeweils auf das andere beziehen.  Da jeder Referenzz√§hler nicht 0 ist, wird keiner von ihnen freigegeben. <br><br><img src="https://habrastorage.org/webt/hd/zp/ff/hdzpffk1eh3rug0fgmgnlghnb3q.png"><br><br>  Dies ist ein <b>starker Referenzzyklus</b> .  Diese Situation verwirrt den ARC und erlaubt ihm nicht, den Speicher zu l√∂schen. <br><br>  Wie Sie sehen k√∂nnen, ist der Referenzz√§hler am Ende nicht 0, und obwohl keine Objekte mehr ben√∂tigt werden, werden Objekt1 und Objekt2 nicht freigegeben. <br><br><h2>  Schauen Sie sich unsere Links an </h2><br>  Um dies alles in Aktion zu testen, f√ºgen Sie diesen Code nach der User-Klasse in MainViewController.swift hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phone</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> model: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> owner: <span class="hljs-type"><span class="hljs-type">User?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(model: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.model = model <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Phone \(model) was initialized"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Deallocating phone named: \(model)"</span></span>) } }</code> </pre> <br>  Dieser Code f√ºgt eine neue <b>Telefonklasse</b> mit zwei Eigenschaften hinzu, eine f√ºr das Modell und eine f√ºr den Eigent√ºmer sowie die Methoden init und deinit.  Das Eigentum des Eigent√ºmers ist optional, da das Telefon m√∂glicherweise keinen Eigent√ºmer hat. <br><br>  F√ºgen Sie nun diese Zeile zu runScenario () hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iPhone = <span class="hljs-type"><span class="hljs-type">Phone</span></span>(model: <span class="hljs-string"><span class="hljs-string">"iPhone Xs"</span></span>)</code> </pre><br>  Dadurch wird eine Instanz der Phone-Klasse erstellt. <br><br><h2>  Halten Sie das Handy </h2><br>  F√ºgen Sie diesen Code nun unmittelbar nach der Eigenschaft name zur Benutzerklasse hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> phones: [<span class="hljs-type"><span class="hljs-type">Phone</span></span>] = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(phone: Phone)</span></span></span></span> { phones.append(phone) phone.owner = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> }</code> </pre><br>  F√ºgen Sie eine Reihe von Telefonen hinzu, die dem Benutzer geh√∂ren.  Der Setter ist als privat markiert, daher muss add (phone :) verwendet werden. <br><br>  Starten Sie die App.  Wie Sie sehen k√∂nnen, werden Instanzen der Telefon- und Benutzerobjektklassen nach Bedarf freigegeben. <br><br>  Benutzer John wurde initialisiert <br>  Telefon iPhone XS wurde initialisiert <br>  Freigabe des Telefons mit dem Namen: iPhone Xs <br>  Freigabe des Benutzers mit dem Namen: John <br><br>  F√ºgen Sie dies nun am Ende von runScenario () hinzu: <br><pre> <code class="swift hljs">user.add(phone: iPhone)</code> </pre> <br><br>  Hier f√ºgen wir unser iPhone zur Liste der Telefone hinzu, die dem <b>Benutzer geh√∂ren</b> , und setzen die <b>Besitzereigenschaft</b> des Telefons auf " <b>Benutzer</b> ". <br><br>  F√ºhren Sie die Anwendung erneut aus.  Sie werden sehen, dass Benutzer- und iPhone-Objekte nicht freigegeben werden.  Der Zyklus starker Verbindungen zwischen ihnen verhindert, dass der ARC sie freigibt. <br><br><img src="https://habrastorage.org/webt/lo/az/mu/loazmuamyoww2ttr7wnwcd8_n4w.png"><br><br><h2>  Links schwach </h2><br>  Um den Kreislauf starker Verbindungen zu durchbrechen, k√∂nnen Sie die Beziehung zwischen Objekten als schwach festlegen. <br><br>  Standardm√§√üig sind alle Links stark und die Zuweisung f√ºhrt zu einer Erh√∂hung der Referenzanzahl.  Bei Verwendung schwacher Referenzen erh√∂ht sich die Referenzanzahl nicht. <br><br>  Mit anderen Worten, <b>schwache Glieder wirken sich nicht auf das Lebensmanagement eines Objekts aus</b> .  Schwache Links werden immer als <b>optional</b> deklariert.  Auf diese Weise kann die Verbindung auf Null gesetzt werden, wenn die Anzahl der Verbindungen 0 wird. <br><br><img src="https://habrastorage.org/webt/ti/qd/kc/tiqdkcyfstrndd8xswpf8zfebfo.png"><br><br>  In dieser Abbildung zeigen gestrichelte Linien schwache Glieder an.  Beachten Sie, dass der Referenzz√§hler von Objekt1 1 ist, da Variable1 darauf verweist.  Der Referenzz√§hler von Objekt2 ist 2, da er von Variable2 und Objekt1 referenziert wird. <br><br>  Objekt2 verweist auch auf Objekt1, aber <b>SCHWACH</b> , was bedeutet, dass es die Referenzanzahl von <b>Objekt1</b> nicht beeinflusst. <br><br>  Wenn Variable1 und Variable2 freigegeben werden, hat Objekt1 einen Referenzz√§hler von 0, wodurch es freigegeben wird.  Dies wiederum gibt einen starken Verweis auf object2 frei, was bereits zu seiner Freigabe f√ºhrt. <br><br>  √Ñndern Sie in der Phone-Klasse die Eigent√ºmerdeklaration wie folgt: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> owner: <span class="hljs-type"><span class="hljs-type">User?</span></span></code> </pre> <br>  Indem wir die Eigent√ºmer-Eigenschaftsreferenz als "schwach" deklarieren, unterbrechen wir die Schleife der starken Verbindungen zwischen den Klassen "Benutzer" und "Telefon". <br><br><img src="https://habrastorage.org/webt/ym/ax/_m/ymax_mv9cvlpi8xqwnxmb14vr2g.png"><br><br>  Starten Sie die App.  Jetzt werden Benutzer und Telefon korrekt freigegeben. <br><br><h2>  Nicht besessene Links </h2><br>  Es gibt auch einen anderen Link-Modifikator, der die Referenzanzahl nicht erh√∂ht: nicht <b>besessen</b> . <br><br>  Was ist der Unterschied zwischen nicht <b>besessen</b> und <b>schwach</b> ?  Eine schwache Referenz ist immer optional und wird automatisch null, wenn das referenzierte Objekt freigegeben wird. <br><br>  Aus diesem Grund sollten wir schwache Eigenschaften als optionale Variable vom Typ deklarieren: Diese Eigenschaft muss sich √§ndern. <br><br>  Nicht besessene Links sind dagegen niemals optional.  Wenn Sie versuchen, auf eine nicht besessene Eigenschaft zuzugreifen, die auf ein freigegebenes Objekt verweist, wird ein Fehler angezeigt, der wie ein Force-Unwrap mit einer Null-Variablen aussieht (Force-Unwrapping). <br><br><img src="https://habrastorage.org/webt/i9/hf/bc/i9hfbcizzk2eg38s_hidjq3evju.png"><br><br>  Lassen Sie uns versuchen, nicht <b>besessen zu</b> bewerben. <br><br>  F√ºgen <b>Sie</b> am Ende von MainViewController.swift eine neue <b>CarrierSubscription-</b> Klasse hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CarrierSubscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> countryCode: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> number: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user: <span class="hljs-type"><span class="hljs-type">User</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(name: <span class="hljs-type"><span class="hljs-type">String</span></span>, countryCode: <span class="hljs-type"><span class="hljs-type">String</span></span>, number: <span class="hljs-type"><span class="hljs-type">String</span></span>, user: <span class="hljs-type"><span class="hljs-type">User</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.countryCode = countryCode <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.number = number <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.user = user <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"CarrierSubscription \(name) is initialized"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Deallocating CarrierSubscription named: \(name)"</span></span>) } }</code> </pre> <br>  CarrierSubscription hat vier Eigenschaften: <br><br>  Name: Anbietername. <br>  CountryCode: L√§ndercode. <br>  Nummer: Telefonnummer. <br>  Benutzer: Link zum Benutzer. <br><br><h2>  Wer ist Ihr Provider? </h2><br>  F√ºgen Sie dies nun der Benutzerklasse nach der Eigenschaft name hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subscriptions: [<span class="hljs-type"><span class="hljs-type">CarrierSubscription</span></span>] = []</code> </pre> <br>  Hier halten wir eine Reihe von Benutzeranbietern. <br><br>  F√ºgen Sie dies nun der Phone-Klasse nach der Eigent√ºmer-Eigenschaft hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> carrierSubscription: <span class="hljs-type"><span class="hljs-type">CarrierSubscription?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(carrierSubscription: CarrierSubscription)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.carrierSubscription = carrierSubscription } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decommission</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { carrierSubscription = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Dadurch werden die optionale CarrierSubscription-Eigenschaft und zwei Methoden zum Registrieren und Aufheben der Registrierung des Telefons beim Anbieter hinzugef√ºgt. <br><br>  F√ºgen Sie nun die CarrierSubscription-Klasse direkt vor der print-Anweisung in die init-Methode ein: <br><br><pre> <code class="swift hljs">user.subscriptions.append(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)</code> </pre> <br>  Wir f√ºgen CarrierSubscription dem Array der Benutzeranbieter hinzu. <br><br>  F√ºgen Sie dies schlie√ülich am Ende der runScenario () -Methode hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subscription = <span class="hljs-type"><span class="hljs-type">CarrierSubscription</span></span>( name: <span class="hljs-string"><span class="hljs-string">"TelBel"</span></span>, countryCode: <span class="hljs-string"><span class="hljs-string">"0032"</span></span>, number: <span class="hljs-string"><span class="hljs-string">"31415926"</span></span>, user: user) iPhone.provision(carrierSubscription: subscription)</code> </pre> <br>  Wir erstellen f√ºr den Benutzer ein Abonnement f√ºr den Anbieter und verbinden das Telefon damit. <br><br>  Starten Sie die App.  In der Konsole sehen Sie: <br><br>  Benutzer John wurde initialisiert <br>  Telefon iPhone Xs wurde initialisiert <br>  CarrierSubscription TelBel wird initialisiert <br><br>  Und wieder ein Linkzyklus!  Benutzer, iPhone und Abonnement waren am Ende nicht kostenlos. <br><br>  Kannst du ein Problem finden? <br><br><img src="https://habrastorage.org/webt/uu/fg/eq/uufgeqkvqa31jwwlsnlikc-iob8.png"><br><br><h2>  Die Kette brechen </h2><br>  Entweder muss der Link vom Benutzer zum Abonnement oder der Link vom Abonnement zum Benutzer nicht besessen sein, um die Schleife zu durchbrechen.  Die Frage ist, welche Option zu w√§hlen ist.  Schauen wir uns die Strukturen an. <br><br>  Ein Benutzer besitzt ein Abonnement f√ºr einen Anbieter, aber umgekehrt - nein, ein Abonnement f√ºr einen Anbieter besitzt keinen Benutzer. <br><br>  Dar√ºber hinaus macht es keinen Sinn, CarrierSubscription ohne Bezugnahme auf den Benutzer zu besitzen, dem es geh√∂rt. <br><br>  Daher muss der Benutzerlink nicht besessen sein. <br><br>  √Ñndern Sie die Benutzerdeklaration in CarrierSubscription: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user: <span class="hljs-type"><span class="hljs-type">User</span></span></code> </pre><br>  Jetzt Benutzer nicht besessen, wodurch die Schleife der Links unterbrochen wird und Sie alle Objekte freigeben k√∂nnen. <br><br><img src="https://habrastorage.org/webt/en/vx/cu/envxcuihbevfcfqv1cyg-kc3lo4.png"><br><br><h2>  Loop-Links in Verschl√ºssen </h2><br>  Verkn√ºpfungszyklen f√ºr Objekte treten auf, wenn Objekte Eigenschaften haben, die aufeinander verweisen.  Verschl√ºsse sind wie Objekte ein Referenztyp und k√∂nnen zu Referenzschleifen f√ºhren.  Verschl√ºsse erfassen Objekte, die sie verwenden. <br><br>  Wenn Sie beispielsweise einer Eigenschaft einer Klasse einen Abschluss zuweisen und dieser Abschluss Eigenschaften derselben Klasse verwendet, erhalten wir eine Verkn√ºpfungsschleife.  Mit anderen Worten, das Objekt enth√§lt eine Verkn√ºpfung zum Abschluss √ºber die Eigenschaft.  Der Verschluss enth√§lt einen Verweis auf das Objekt durch den erfassten Wert des Selbst. <br><br><img src="https://habrastorage.org/webt/z-/lh/ow/z-lhowlkfyvy4ycusafxhygjisw.png"><br><br>  F√ºgen Sie diesen Code unmittelbar nach der Benutzereigenschaft zu CarrierSubscription hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completePhoneNumber: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.countryCode + <span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.number }</code> </pre><br>  Dieser Abschluss berechnet und gibt die vollst√§ndige Telefonnummer zur√ºck.  Die Eigenschaft wird als <b>faul</b> deklariert, sie wird bei der ersten Nutzung zugewiesen. <br><br>  Dies ist erforderlich, da self.countryCode und self.number verwendet werden, die erst verf√ºgbar sind, wenn der Initialisierungscode ausgef√ºhrt wird. <br><br>  F√ºgen Sie am Ende runScenario () hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(subscription.completePhoneNumber())</code> </pre> <br>  Durch Aufrufen von completePhoneNumber () wird der Abschluss ausgef√ºhrt. <br><br>  Starten Sie die Anwendung und Sie werden sehen, dass Benutzer und iPhone freigegeben sind, CarrierSubscription jedoch nicht, da starke Verkn√ºpfungen zwischen dem Objekt und dem Abschluss bestehen. <br><br><img src="https://habrastorage.org/webt/7t/rb/ax/7trbaxtrrhtadtm29-dvqwehzo4.png"><br><br><h2>  Erfassungslisten </h2><br>  Swift bietet eine einfache und elegante M√∂glichkeit, die Schleife starker Glieder in Verschl√ºssen zu durchbrechen.  Sie deklarieren eine Erfassungsliste, in der Sie die Beziehung zwischen dem Abschluss und den erfassten Objekten definieren. <br><br>  Beachten Sie den folgenden Code, um die Erfassungsliste zu demonstrieren: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> someClosure = { [x] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(x), \(y)"</span></span>) } x = <span class="hljs-number"><span class="hljs-number">6</span></span> y = <span class="hljs-number"><span class="hljs-number">6</span></span> someClosure() <span class="hljs-comment"><span class="hljs-comment">// Prints 5, 6 print("\(x), \(y)") // Prints 6, 6</span></span></code> </pre> <br>  x befindet sich in der Abschlusserfassungsliste, daher wird der Wert von x in die Abschlussdefinition kopiert.  Es wird nach Wert erfasst. <br><br>  y ist nicht in der Erfassungsliste enthalten, sondern wird als Referenz erfasst.  Dies bedeutet, dass der Wert von y so ist, wie er zum Zeitpunkt des Aufrufs der Schaltung war. <br><br>  Sperrlisten helfen dabei, schwache oder nicht besessene Interaktionen in Bezug auf Objekte zu identifizieren, die in der Schleife erfasst wurden.  In unserem Fall ist die entsprechende Auswahl nicht im Besitz, da ein Abschluss nicht vorhanden sein kann, wenn die CarrierSubscription-Instanz freigegeben wird. <br><br><h2>  Ergreifen Sie sich </h2><br>  Ersetzen Sie die vollst√§ndige Telefonnummer-Definition durch CarrierSubscription :: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completePhoneNumber: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.countryCode + <span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.number }</code> </pre> <br>  Wir f√ºgen der Liste der Abschlusserfassungen <b>[nicht besessenes Selbst] hinzu</b> .  Dies bedeutet, dass wir uns <b>selbst</b> als nicht <b>besessenes</b> Glied anstatt als starkes gefangen genommen haben. <br><br>  Starten Sie die Anwendung und Sie werden sehen, dass CarrierSubscription jetzt freigegeben ist. <br><br>  Tats√§chlich ist die obige Syntax eine Kurzform einer l√§ngeren und vollst√§ndigeren, in der eine neue Variable erscheint: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> closure = { [<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> newID = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">// Use unowned newID here... }</span></span></code> </pre> <br>  Hier ist newID eine nicht im Besitz befindliche Kopie von self.  √úber die Schlie√üung hinaus bleibt das Selbst sich selbst.  In der zuvor angegebenen Kurzform <b>erstellen</b> wir <b>eine neue Selbstvariable</b> , die das vorhandene Selbst innerhalb des Verschlusses verdeckt. <br><br><h2>  Unbesessen vorsichtig verwenden </h2><br>  In Ihrem Code wird die Beziehung zwischen self und completePhoneNumber als nicht besessen festgelegt. <br><br>  Wenn Sie sicher sind, dass das im Abschluss verwendete Objekt nicht freigegeben wird, k√∂nnen Sie unbesessen verwenden.  Wenn er es tut, sind Sie in Schwierigkeiten! <br><br>  F√ºgen Sie diesen Code am Ende von MainViewController.swift hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WWDCGreeting</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> who: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(who: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.who = who } <span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greetingMaker: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello \(self.who)."</span></span> } }</code> </pre><br>  Hier ist das Ende von runScenario (): <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> greetingMaker: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mermaid = <span class="hljs-type"><span class="hljs-type">WWDCGreeting</span></span>(who: <span class="hljs-string"><span class="hljs-string">"caffeinated mermaid"</span></span>) greetingMaker = mermaid.greetingMaker } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(greetingMaker()) <span class="hljs-comment"><span class="hljs-comment">// !</span></span></code> </pre> <br>  Starten Sie die Anwendung und Sie werden einen Absturz und √§hnliches in der Konsole sehen: <br><br>  Benutzer John wurde initialisiert <br>  Telefon iPhone XS wurde initialisiert <br>  CarrierSubscription TelBel wird initialisiert <br>  0032 31415926 <br>  Schwerwiegender Fehler: Es wurde versucht, eine nicht besessene Referenz zu lesen, das Objekt 0x600000f0de30 wurde jedoch bereits freigegeben <br><br>  Eine Ausnahme trat auf, weil die Schlie√üung darauf wartet, dass self.who existiert, aber sie wurde freigegeben, sobald die Meerjungfrau am Ende des do-Blocks den G√ºltigkeitsbereich verlassen hat. <br><br>  Dieses Beispiel mag von einem Finger gesaugt aussehen, aber solche Dinge passieren.  Wenn wir beispielsweise Schlie√üungen verwenden, um etwas viel sp√§ter zu starten, beispielsweise nachdem der asynchrone Anruf im Netzwerk beendet wurde. <br><br><h2>  Entsch√§rfe die Falle </h2><br>  Ersetzen Sie greetingMaker in der WWDCGreeting-Klasse durch Folgendes: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greetingMaker: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello \(self?.who)."</span></span> }</code> </pre> <br>  Wir haben zwei Dinge getan: Erstens haben wir unbesessen durch schwach ersetzt.  Zweitens, da das Selbst schwach geworden ist, greifen wir √ºber das Selbst auf das Wer-Eigentum zu. Wer.  Ignorieren Sie die Xcode-Warnung, wir werden sie bald beheben. <br><br>  Die Anwendung st√ºrzt nicht mehr ab, aber wenn Sie sie ausf√ºhren, erhalten wir ein lustiges Ergebnis: "Hallo Null." <br><br>  Vielleicht ist das Ergebnis durchaus akzeptabel, aber oft m√ºssen wir etwas tun, wenn das Objekt freigegeben wurde.  Dies kann mithilfe der Guard-Anweisung erfolgen. <br><br>  Ersetzen Sie den Schlie√üungstext durch: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greetingMaker: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"No greeting available."</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello \(self.who)."</span></span> }</code> </pre><br>  Die Wachaussage weist das Selbst dem schwachen Selbst zu.  Wenn self null ist, gibt der Abschluss "Keine Begr√º√üung verf√ºgbar" zur√ºck.  Andernfalls wird das Selbst zu einer starken Referenz, sodass das Objekt garantiert bis zum Ende des Verschlusses lebt. <br><br><h2>  Suche nach Link-Loops in Xcode 10 </h2><br>  Nachdem Sie nun verstanden haben, wie ARC funktioniert, was Verbindungsschleifen sind und wie sie unterbrochen werden, ist es Zeit, ein Beispiel f√ºr eine echte Anwendung zu sehen. <br><br>  √ñffnen Sie das Starter-Projekt im Ordner "Kontakte". <br><br>  Starten Sie die App. <br><br><img src="https://habrastorage.org/webt/a8/ce/l1/a8cel1rgbdkm_fel_d880f2swf4.png"><br><br>  Dies ist der einfachste Kontaktmanager.  Klicken Sie auf einen Kontakt und f√ºgen Sie einige neue hinzu. <br><br>  Dateizuordnung: <br><br>  ContactsTableViewController: Zeigt alle Kontakte an. <br>  DetailViewController: Zeigt die detaillierten Informationen des ausgew√§hlten Kontakts an. <br>  NewContactViewController: Erm√∂glicht das Hinzuf√ºgen eines neuen Kontakts. <br>  ContactTableViewCell: Tabellenzelle mit Kontaktdetails. <br>  Kontakt: Kontaktmodell. <br>  Nummer: Telefonnummer Modell. <br><br>  Bei diesem Projekt ist jedoch alles schlecht: Es gibt einen Zyklus von Links.  Zun√§chst werden Benutzer aufgrund der geringen Gr√∂√üe des undichten Speichers keine Probleme bemerken. Aus dem gleichen Grund ist es schwierig, das Leck zu finden. <br><br>  Gl√ºcklicherweise verf√ºgt Xcode 10 √ºber integrierte Tools, um den kleinsten Speicherverlust zu finden. <br><br>  Starten Sie die Anwendung erneut.  L√∂schen Sie 3-4 Kontakte mit dem Wischen nach links und der Schaltfl√§che L√∂schen.  Es scheint, als ob sie vollst√§ndig verschwinden, oder? <br><br><img src="https://habrastorage.org/webt/xu/d9/qf/xud9qf3rcyaf5ot_08l8vauizto.png"><br><br><h2>  Wo flie√üt es? </h2><br>  Wenn die Anwendung ausgef√ºhrt wird, klicken Sie auf die Schaltfl√§che Debug Memory Graph: <br><br><img src="https://habrastorage.org/webt/la/na/km/lanakmzc0d2ousrcf5jwkpu-ova.png"><br><br>  Beachten Sie die Laufzeitprobleme im Debug-Navigator.  Sie sind mit lila Quadraten mit einem wei√üen Ausrufezeichen gekennzeichnet: <br><br><img src="https://habrastorage.org/webt/uc/ko/vj/uckovjp_eqoplopih79xuz1jl7e.png"><br><br>  W√§hlen Sie im Navigator eines der problematischen Kontaktobjekte aus.  Der Zyklus ist deutlich sichtbar: Die aufeinander bezogenen Objekte Contact und Number halten. <br><br><img src="https://habrastorage.org/webt/7f/wi/os/7fwios8n7zdk4ww7bj81p4kvgle.png"><br><br>  Sieht so aus, als sollten Sie sich den Code ansehen.  Denken Sie daran, dass ein Kontakt ohne Nummer existieren kann, aber nicht umgekehrt. <br><br>  Wie w√ºrden Sie diese Schleife l√∂sen?  Link von Kontakt zu Nummer oder von Nummer zu Kontakt?  schwach oder nicht besessen?  Probieren Sie es zuerst selbst aus! <br><br><div class="spoiler">  <b class="spoiler_title">Wenn Sie Hilfe brauchten ...</b> <div class="spoiler_text">  Es gibt zwei m√∂gliche L√∂sungen: entweder einen Link von Kontakt zu Nummer schwach machen oder von Nummer zu Kontakt nicht besitzen. <br><br>  In der Dokumentation von Apple wird empfohlen, dass das √ºbergeordnete Objekt einen starken Verweis auf "untergeordnetes Objekt" enth√§lt - nicht umgekehrt.  Dies bedeutet, dass wir Contact einen starken Verweis auf Number und Number geben - einen nicht besessenen Link zu Contact: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contact: <span class="hljs-type"><span class="hljs-type">Contact</span></span> <span class="hljs-comment"><span class="hljs-comment">// Other code... } class Contact { var number: Number? // Other code... }</span></span></code> </pre> <br></div></div><br><h2>  Bonus: Schleifen mit Referenztypen und Werttypen. </h2><br>  Swift verf√ºgt √ºber Referenztypen (Klassen und Abschl√ºsse) und Werttypen (Strukturen, Aufz√§hlungen).  Der Werttyp wird kopiert, wenn er √ºbergeben wird, und Referenztypen haben √ºber den Link denselben Wert. <br><br>  Dies bedeutet, dass es bei Werttypen keine Zyklen geben kann.  Damit eine Schleife auftritt, ben√∂tigen wir mindestens 2 Referenztypen. <br><br>  Kehren wir zum Cycles-Projekt zur√ºck und f√ºgen diesen Code am Ende von MainViewController.swift hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Error var payload = 0 var next: Node? }</span></span></code> </pre><br>  Wird nicht funktionieren!  Struktur ist ein Werttyp und kann keine Rekursion f√ºr eine Instanz von sich selbst haben.  Andernfalls h√§tte eine solche Struktur eine unendliche Gr√∂√üe. <br><br>  √Ñndern Sie die Struktur in eine Klasse. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> payload = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> next: <span class="hljs-type"><span class="hljs-type">Node?</span></span> }</code> </pre> <br>  Der Verweis auf sich selbst ist f√ºr Klassen (Referenztyp) durchaus akzeptabel, sodass der Compiler keine Probleme hat. <br><br>  F√ºgen Sie dies nun am Ende von MainViewController.swift hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> friends: [<span class="hljs-type"><span class="hljs-type">Person</span></span>] = [] <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(name: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"New person instance: \(name)"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Person instance \(name) is being deallocated"</span></span>) } }</code> </pre> <br>  Und das ist am Ende von runScenario (): <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ernie = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Ernie"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bert = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Bert"</span></span>) ernie.friends.append(bert) <span class="hljs-comment"><span class="hljs-comment">// Not deallocated bert.friends.append(ernie) // Not deallocated }</span></span></code> </pre><br>  Starten Sie die App.  Bitte beachten Sie: Weder ernie noch bert werden ver√∂ffentlicht. <br><br><h2>  Link und Bedeutung </h2><br>  Dies ist ein Beispiel f√ºr eine Kombination aus einem Referenztyp und einem Werttyp, die zu einer Verbindungsschleife gef√ºhrt hat. <br><br>  ernie und bert bleiben unver√∂ffentlicht und halten sich gegenseitig in den Arrays ihrer Freunde, obwohl die Arrays selbst Werttypen sind. <br><br>  Versuchen Sie, das Archiv der Freunde als nicht besessen zu machen, und Xcode zeigt einen Fehler an: nicht besessen gilt nur f√ºr Klassen. <br><br>  Um diese Schleife zu beheben, m√ºssen wir ein Wrapper-Objekt erstellen und damit dem Array Instanzen hinzuf√ºgen. <br><br>  F√ºgen Sie vor der Person-Klasse die folgende Definition hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Unowned</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyObject</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> (<span class="hljs-number"><span class="hljs-number">_</span></span> value: <span class="hljs-type"><span class="hljs-type">T</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value = value } }</code> </pre><br>  √Ñndern Sie dann die Definition von Freunden in der Person-Klasse: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> friends: [<span class="hljs-type"><span class="hljs-type">Unowned</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Person</span></span>&gt;] = []</code> </pre> <br>  Ersetzen Sie abschlie√üend den Inhalt des do-Blocks in runScenario (): <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ernie = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Ernie"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bert = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Bert"</span></span>) ernie.friends.append(<span class="hljs-type"><span class="hljs-type">Unowned</span></span>(bert)) bert.friends.append(<span class="hljs-type"><span class="hljs-type">Unowned</span></span>(ernie)) }</code> </pre> <br>  Starten Sie die Anwendung, jetzt sind ernie und bert korrekt freigegeben! <br><br>  Das Friends-Array ist keine Sammlung von Personenobjekten mehr.  Dies ist jetzt eine <b>Sammlung von nicht besessenen Objekten</b> , die als Wrapper f√ºr Personeninstanzen dienen. <br><br>  Verwenden Sie die value-Eigenschaft, um Personenobjekte von Unowners abzurufen: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstFriend = bert.friends.first?.value <span class="hljs-comment"><span class="hljs-comment">// get ernie</span></span></code> </pre> <br><h2>  Fazit </h2><br>  Sie haben jetzt ein gutes Verst√§ndnis der Speicherverwaltung in Swift und wissen, wie ARC funktioniert.  Ich hoffe, die Ver√∂ffentlichung hat Ihnen geholfen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Apple: Automatische Referenzz√§hlung</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451130/">https://habr.com/ru/post/de451130/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451116/index.html">Wie ich mit dem Shared Element Transition k√§mpfte und meine erste OpenSource-Bibliothek schrieb</a></li>
<li><a href="../de451118/index.html">Testen ist nichts f√ºr Anf√§nger</a></li>
<li><a href="../de451120/index.html">√úber die Herausforderungen bei der Portierung von Dead Cells auf mobile Plattformen</a></li>
<li><a href="../de451124/index.html">Entwicklung von Proteinen in der Cloud mit Python und Transcriptic oder Wie man ein Protein f√ºr 360 US-Dollar erstellt</a></li>
<li><a href="../de451126/index.html">Toolbox f√ºr Forscher - Ausgabe 1: Selbstorganisation und Datenvisualisierung</a></li>
<li><a href="../de451132/index.html">Consumer Driven Contracts oder Gitlab CI-eyed QA-Testautomatisierung</a></li>
<li><a href="../de451136/index.html">Eingef√ºhrt von .NET 5</a></li>
<li><a href="../de451138/index.html">Symfony CLI - Neues lokales Entwicklungstool</a></li>
<li><a href="../de451144/index.html">Antiquit√§ten: Technik in der Fernsehwerbung</a></li>
<li><a href="../de451146/index.html">Beschleunigung der Erstellung von Webanwendungen mit Webpack</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>