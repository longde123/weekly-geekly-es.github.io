<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👌 👨🏿‍🏫 🧚🏽 Swift: ARC- und Speicherverwaltung 💰 🍡 🔐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als moderne Hochsprache kümmert sich Swift im Wesentlichen um die Speicherverwaltung in Ihren Anwendungen, um Speicher zuzuweisen und freizugeben. Die...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Swift: ARC- und Speicherverwaltung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451130/">  Als moderne Hochsprache kümmert sich <b>Swift im</b> Wesentlichen um die Speicherverwaltung in Ihren Anwendungen, um Speicher zuzuweisen und freizugeben.  Dies ist auf einen Mechanismus zurückzuführen, der als <b>automatische Referenzzählung</b> , kurz <b>ARC, bezeichnet wird</b> .  In diesem Handbuch erfahren Sie, wie ARC funktioniert und wie Sie den Speicher in Swift ordnungsgemäß verwalten.  Wenn Sie diesen Mechanismus verstehen, können Sie die Lebensdauer von Objekten auf dem Heap ( <b>Heap</b> ) beeinflussen. <br><br>  In diesem Handbuch lernen Sie Swift und ARC kennen, indem Sie Folgendes lernen: <br><br><ul><li>  wie ARC funktioniert </li><li>  Was sind <b>Referenzzyklen</b> und wie werden sie richtig behoben? </li><li>  So erstellen Sie eine Beispiel-Link-Schleife </li><li>  So finden Sie Link-Loops mit den von Xcode angebotenen visuellen Tools </li><li>  Umgang mit Referenztypen und Werttypen </li></ul><a name="habracut"></a><br><h2>  Erste Schritte </h2><br>  Laden Sie die <a href="" rel="nofollow">Quellmaterialien</a> herunter <a href="" rel="nofollow">.</a>  Öffnen Sie das Projekt im Ordner <b>Cycles / Starter</b> .  Im ersten Teil unseres Handbuchs werden wir uns mit den wichtigsten Konzepten befassen und uns ausschließlich mit der Datei <b>MainViewController.swif</b> t befassen. <br><br>  Fügen Sie diese Klasse am Ende von MainViewController.swift hinzu: <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(name: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"User \(name) was initialized"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Deallocating user named: \(name)"</span></span>) } }</code> </pre> <br>  Hier wird die <b>User-</b> Klasse definiert, die uns mit Hilfe von <b>print-</b> Anweisungen über die Initialisierung und Freigabe der Klasseninstanz informiert. <br><br>  Erstellen Sie nun eine Instanz der User-Klasse oben im MainViewController. <br><br>  Platzieren Sie diesen Code vor der <b>viewDidLoad ()</b> -Methode: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = <span class="hljs-type"><span class="hljs-type">User</span></span>(name: <span class="hljs-string"><span class="hljs-string">"John"</span></span>)</code> </pre> <br>  Starten Sie die App.  Machen Sie die Xcode-Konsole mit <b>Command-Shift-Y</b> sichtbar, um die Ausgabe der print-Anweisungen anzuzeigen. <br><br>  Beachten Sie, dass <b>Benutzer John initialisiert wurde</b> und auf der Konsole <b>angezeigt wurde</b> , die print-Anweisung in <b>deinit jedoch</b> nicht ausgeführt wurde.  Dies bedeutet, dass dieses Objekt nicht freigegeben wurde, da es nicht außerhalb des <b>Gültigkeitsbereichs lag</b> . <br><br>  Mit anderen Worten, bis der Ansichtscontroller, der dieses Objekt enthält, den Gültigkeitsbereich verlässt, wird das Objekt niemals freigegeben. <br><br><h2>  Ist er im Umfang? </h2><br>  Indem wir eine Instanz der User-Klasse in eine Methode einbinden, wird sie außerhalb des Gültigkeitsbereichs liegen, sodass ARC sie freigeben kann. <br><br>  Lassen Sie uns die <b>runScenario ()</b> -Methode in der MainViewController-Klasse erstellen und die Initialisierung der User-Klasseninstanz darin verschieben. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runScenario</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = <span class="hljs-type"><span class="hljs-type">User</span></span>(name: <span class="hljs-string"><span class="hljs-string">"John"</span></span>) }</code> </pre><br>  runScenario () definiert den Bereich der Benutzerinstanz.  Beim Verlassen dieser Zone muss der <b>Benutzer</b> freigegeben werden. <br><br>  Rufen Sie nun runScenario () auf und fügen Sie dies am Ende von viewDidLoad () hinzu: <br><br><pre> <code class="swift hljs">runScenario()</code> </pre> <br>  Starten Sie die App.  Die Konsolenausgabe sieht nun folgendermaßen aus: <br><br>  Benutzer John wurde initialisiert <br>  Freigabe des Benutzers mit dem Namen: John <br><br>  Dies bedeutet, dass Sie ein Objekt freigegeben haben, das das Sichtfeld verlassen hat. <br><br><h2>  Objektlebensdauer </h2><br><br>  Die Existenz des Objekts ist in fünf Stufen unterteilt: <br><br><ul><li>  Speicherzuordnung: vom Stapel oder vom Heap </li><li>  Initialisierung: Code wird in init ausgeführt </li><li>  Verwendung von </li><li>  Deinitialisierung: Code wird innerhalb von Deinit ausgeführt </li><li>  Freier Speicher: Der zugewiesene Speicher wird an den Stapel oder Heap zurückgegeben </li></ul><br>  Es gibt keine direkte Möglichkeit, die Schritte zum Zuweisen und Freigeben von Speicher zu verfolgen, aber Sie können den Code in init und deinit verwenden. <br><br>  <b>Referenzzählungen</b> , auch als <b>Nutzungszählungen bezeichnet</b> , bestimmen, wann ein Objekt nicht mehr benötigt wird.  Dieser Zähler zeigt die Anzahl derer an, die dieses Objekt "verwenden".  Ein Objekt wird unnötig, wenn der Nutzungszähler Null ist.  Dann wird das Objekt de-initialisiert und freigegeben. <br><br><img src="https://habrastorage.org/webt/b5/oo/78/b5oo78ealf173ey0ayz7rngnszk.png"><br><br>  Wenn das Benutzerobjekt initialisiert wird, beträgt sein Referenzzähler 1, da die <b>Benutzerkonstante</b> auf dieses Objekt verweist. <br><br>  Am Ende von runScenario () verlässt der Benutzer den Gültigkeitsbereich und der Referenzzähler wird auf 0 reduziert. Infolgedessen wird der Benutzer nicht initialisiert und dann freigegeben. <br><br><h2>  Referenzzyklen </h2><br>  In den meisten Fällen funktioniert ARC wie es sollte.  Der Entwickler muss sich normalerweise nicht um Speicherverluste kümmern, wenn nicht verwendete Objekte auf unbestimmte Zeit nicht zugewiesen werden. <br><br>  Aber nicht immer!  Mögliche Speicherlecks. <br><br>  Wie kann das passieren?  Stellen Sie sich eine Situation vor, in der zwei Objekte nicht mehr verwendet werden, sich aber jeweils auf das andere beziehen.  Da jeder Referenzzähler nicht 0 ist, wird keiner von ihnen freigegeben. <br><br><img src="https://habrastorage.org/webt/hd/zp/ff/hdzpffk1eh3rug0fgmgnlghnb3q.png"><br><br>  Dies ist ein <b>starker Referenzzyklus</b> .  Diese Situation verwirrt den ARC und erlaubt ihm nicht, den Speicher zu löschen. <br><br>  Wie Sie sehen können, ist der Referenzzähler am Ende nicht 0, und obwohl keine Objekte mehr benötigt werden, werden Objekt1 und Objekt2 nicht freigegeben. <br><br><h2>  Schauen Sie sich unsere Links an </h2><br>  Um dies alles in Aktion zu testen, fügen Sie diesen Code nach der User-Klasse in MainViewController.swift hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phone</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> model: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> owner: <span class="hljs-type"><span class="hljs-type">User?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(model: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.model = model <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Phone \(model) was initialized"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Deallocating phone named: \(model)"</span></span>) } }</code> </pre> <br>  Dieser Code fügt eine neue <b>Telefonklasse</b> mit zwei Eigenschaften hinzu, eine für das Modell und eine für den Eigentümer sowie die Methoden init und deinit.  Das Eigentum des Eigentümers ist optional, da das Telefon möglicherweise keinen Eigentümer hat. <br><br>  Fügen Sie nun diese Zeile zu runScenario () hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iPhone = <span class="hljs-type"><span class="hljs-type">Phone</span></span>(model: <span class="hljs-string"><span class="hljs-string">"iPhone Xs"</span></span>)</code> </pre><br>  Dadurch wird eine Instanz der Phone-Klasse erstellt. <br><br><h2>  Halten Sie das Handy </h2><br>  Fügen Sie diesen Code nun unmittelbar nach der Eigenschaft name zur Benutzerklasse hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> phones: [<span class="hljs-type"><span class="hljs-type">Phone</span></span>] = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(phone: Phone)</span></span></span></span> { phones.append(phone) phone.owner = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> }</code> </pre><br>  Fügen Sie eine Reihe von Telefonen hinzu, die dem Benutzer gehören.  Der Setter ist als privat markiert, daher muss add (phone :) verwendet werden. <br><br>  Starten Sie die App.  Wie Sie sehen können, werden Instanzen der Telefon- und Benutzerobjektklassen nach Bedarf freigegeben. <br><br>  Benutzer John wurde initialisiert <br>  Telefon iPhone XS wurde initialisiert <br>  Freigabe des Telefons mit dem Namen: iPhone Xs <br>  Freigabe des Benutzers mit dem Namen: John <br><br>  Fügen Sie dies nun am Ende von runScenario () hinzu: <br><pre> <code class="swift hljs">user.add(phone: iPhone)</code> </pre> <br><br>  Hier fügen wir unser iPhone zur Liste der Telefone hinzu, die dem <b>Benutzer gehören</b> , und setzen die <b>Besitzereigenschaft</b> des Telefons auf " <b>Benutzer</b> ". <br><br>  Führen Sie die Anwendung erneut aus.  Sie werden sehen, dass Benutzer- und iPhone-Objekte nicht freigegeben werden.  Der Zyklus starker Verbindungen zwischen ihnen verhindert, dass der ARC sie freigibt. <br><br><img src="https://habrastorage.org/webt/lo/az/mu/loazmuamyoww2ttr7wnwcd8_n4w.png"><br><br><h2>  Links schwach </h2><br>  Um den Kreislauf starker Verbindungen zu durchbrechen, können Sie die Beziehung zwischen Objekten als schwach festlegen. <br><br>  Standardmäßig sind alle Links stark und die Zuweisung führt zu einer Erhöhung der Referenzanzahl.  Bei Verwendung schwacher Referenzen erhöht sich die Referenzanzahl nicht. <br><br>  Mit anderen Worten, <b>schwache Glieder wirken sich nicht auf das Lebensmanagement eines Objekts aus</b> .  Schwache Links werden immer als <b>optional</b> deklariert.  Auf diese Weise kann die Verbindung auf Null gesetzt werden, wenn die Anzahl der Verbindungen 0 wird. <br><br><img src="https://habrastorage.org/webt/ti/qd/kc/tiqdkcyfstrndd8xswpf8zfebfo.png"><br><br>  In dieser Abbildung zeigen gestrichelte Linien schwache Glieder an.  Beachten Sie, dass der Referenzzähler von Objekt1 1 ist, da Variable1 darauf verweist.  Der Referenzzähler von Objekt2 ist 2, da er von Variable2 und Objekt1 referenziert wird. <br><br>  Objekt2 verweist auch auf Objekt1, aber <b>SCHWACH</b> , was bedeutet, dass es die Referenzanzahl von <b>Objekt1</b> nicht beeinflusst. <br><br>  Wenn Variable1 und Variable2 freigegeben werden, hat Objekt1 einen Referenzzähler von 0, wodurch es freigegeben wird.  Dies wiederum gibt einen starken Verweis auf object2 frei, was bereits zu seiner Freigabe führt. <br><br>  Ändern Sie in der Phone-Klasse die Eigentümerdeklaration wie folgt: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> owner: <span class="hljs-type"><span class="hljs-type">User?</span></span></code> </pre> <br>  Indem wir die Eigentümer-Eigenschaftsreferenz als "schwach" deklarieren, unterbrechen wir die Schleife der starken Verbindungen zwischen den Klassen "Benutzer" und "Telefon". <br><br><img src="https://habrastorage.org/webt/ym/ax/_m/ymax_mv9cvlpi8xqwnxmb14vr2g.png"><br><br>  Starten Sie die App.  Jetzt werden Benutzer und Telefon korrekt freigegeben. <br><br><h2>  Nicht besessene Links </h2><br>  Es gibt auch einen anderen Link-Modifikator, der die Referenzanzahl nicht erhöht: nicht <b>besessen</b> . <br><br>  Was ist der Unterschied zwischen nicht <b>besessen</b> und <b>schwach</b> ?  Eine schwache Referenz ist immer optional und wird automatisch null, wenn das referenzierte Objekt freigegeben wird. <br><br>  Aus diesem Grund sollten wir schwache Eigenschaften als optionale Variable vom Typ deklarieren: Diese Eigenschaft muss sich ändern. <br><br>  Nicht besessene Links sind dagegen niemals optional.  Wenn Sie versuchen, auf eine nicht besessene Eigenschaft zuzugreifen, die auf ein freigegebenes Objekt verweist, wird ein Fehler angezeigt, der wie ein Force-Unwrap mit einer Null-Variablen aussieht (Force-Unwrapping). <br><br><img src="https://habrastorage.org/webt/i9/hf/bc/i9hfbcizzk2eg38s_hidjq3evju.png"><br><br>  Lassen Sie uns versuchen, nicht <b>besessen zu</b> bewerben. <br><br>  Fügen <b>Sie</b> am Ende von MainViewController.swift eine neue <b>CarrierSubscription-</b> Klasse hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CarrierSubscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> countryCode: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> number: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user: <span class="hljs-type"><span class="hljs-type">User</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(name: <span class="hljs-type"><span class="hljs-type">String</span></span>, countryCode: <span class="hljs-type"><span class="hljs-type">String</span></span>, number: <span class="hljs-type"><span class="hljs-type">String</span></span>, user: <span class="hljs-type"><span class="hljs-type">User</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.countryCode = countryCode <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.number = number <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.user = user <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"CarrierSubscription \(name) is initialized"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Deallocating CarrierSubscription named: \(name)"</span></span>) } }</code> </pre> <br>  CarrierSubscription hat vier Eigenschaften: <br><br>  Name: Anbietername. <br>  CountryCode: Ländercode. <br>  Nummer: Telefonnummer. <br>  Benutzer: Link zum Benutzer. <br><br><h2>  Wer ist Ihr Provider? </h2><br>  Fügen Sie dies nun der Benutzerklasse nach der Eigenschaft name hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subscriptions: [<span class="hljs-type"><span class="hljs-type">CarrierSubscription</span></span>] = []</code> </pre> <br>  Hier halten wir eine Reihe von Benutzeranbietern. <br><br>  Fügen Sie dies nun der Phone-Klasse nach der Eigentümer-Eigenschaft hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> carrierSubscription: <span class="hljs-type"><span class="hljs-type">CarrierSubscription?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(carrierSubscription: CarrierSubscription)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.carrierSubscription = carrierSubscription } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decommission</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { carrierSubscription = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Dadurch werden die optionale CarrierSubscription-Eigenschaft und zwei Methoden zum Registrieren und Aufheben der Registrierung des Telefons beim Anbieter hinzugefügt. <br><br>  Fügen Sie nun die CarrierSubscription-Klasse direkt vor der print-Anweisung in die init-Methode ein: <br><br><pre> <code class="swift hljs">user.subscriptions.append(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)</code> </pre> <br>  Wir fügen CarrierSubscription dem Array der Benutzeranbieter hinzu. <br><br>  Fügen Sie dies schließlich am Ende der runScenario () -Methode hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subscription = <span class="hljs-type"><span class="hljs-type">CarrierSubscription</span></span>( name: <span class="hljs-string"><span class="hljs-string">"TelBel"</span></span>, countryCode: <span class="hljs-string"><span class="hljs-string">"0032"</span></span>, number: <span class="hljs-string"><span class="hljs-string">"31415926"</span></span>, user: user) iPhone.provision(carrierSubscription: subscription)</code> </pre> <br>  Wir erstellen für den Benutzer ein Abonnement für den Anbieter und verbinden das Telefon damit. <br><br>  Starten Sie die App.  In der Konsole sehen Sie: <br><br>  Benutzer John wurde initialisiert <br>  Telefon iPhone Xs wurde initialisiert <br>  CarrierSubscription TelBel wird initialisiert <br><br>  Und wieder ein Linkzyklus!  Benutzer, iPhone und Abonnement waren am Ende nicht kostenlos. <br><br>  Kannst du ein Problem finden? <br><br><img src="https://habrastorage.org/webt/uu/fg/eq/uufgeqkvqa31jwwlsnlikc-iob8.png"><br><br><h2>  Die Kette brechen </h2><br>  Entweder muss der Link vom Benutzer zum Abonnement oder der Link vom Abonnement zum Benutzer nicht besessen sein, um die Schleife zu durchbrechen.  Die Frage ist, welche Option zu wählen ist.  Schauen wir uns die Strukturen an. <br><br>  Ein Benutzer besitzt ein Abonnement für einen Anbieter, aber umgekehrt - nein, ein Abonnement für einen Anbieter besitzt keinen Benutzer. <br><br>  Darüber hinaus macht es keinen Sinn, CarrierSubscription ohne Bezugnahme auf den Benutzer zu besitzen, dem es gehört. <br><br>  Daher muss der Benutzerlink nicht besessen sein. <br><br>  Ändern Sie die Benutzerdeklaration in CarrierSubscription: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user: <span class="hljs-type"><span class="hljs-type">User</span></span></code> </pre><br>  Jetzt Benutzer nicht besessen, wodurch die Schleife der Links unterbrochen wird und Sie alle Objekte freigeben können. <br><br><img src="https://habrastorage.org/webt/en/vx/cu/envxcuihbevfcfqv1cyg-kc3lo4.png"><br><br><h2>  Loop-Links in Verschlüssen </h2><br>  Verknüpfungszyklen für Objekte treten auf, wenn Objekte Eigenschaften haben, die aufeinander verweisen.  Verschlüsse sind wie Objekte ein Referenztyp und können zu Referenzschleifen führen.  Verschlüsse erfassen Objekte, die sie verwenden. <br><br>  Wenn Sie beispielsweise einer Eigenschaft einer Klasse einen Abschluss zuweisen und dieser Abschluss Eigenschaften derselben Klasse verwendet, erhalten wir eine Verknüpfungsschleife.  Mit anderen Worten, das Objekt enthält eine Verknüpfung zum Abschluss über die Eigenschaft.  Der Verschluss enthält einen Verweis auf das Objekt durch den erfassten Wert des Selbst. <br><br><img src="https://habrastorage.org/webt/z-/lh/ow/z-lhowlkfyvy4ycusafxhygjisw.png"><br><br>  Fügen Sie diesen Code unmittelbar nach der Benutzereigenschaft zu CarrierSubscription hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completePhoneNumber: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.countryCode + <span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.number }</code> </pre><br>  Dieser Abschluss berechnet und gibt die vollständige Telefonnummer zurück.  Die Eigenschaft wird als <b>faul</b> deklariert, sie wird bei der ersten Nutzung zugewiesen. <br><br>  Dies ist erforderlich, da self.countryCode und self.number verwendet werden, die erst verfügbar sind, wenn der Initialisierungscode ausgeführt wird. <br><br>  Fügen Sie am Ende runScenario () hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(subscription.completePhoneNumber())</code> </pre> <br>  Durch Aufrufen von completePhoneNumber () wird der Abschluss ausgeführt. <br><br>  Starten Sie die Anwendung und Sie werden sehen, dass Benutzer und iPhone freigegeben sind, CarrierSubscription jedoch nicht, da starke Verknüpfungen zwischen dem Objekt und dem Abschluss bestehen. <br><br><img src="https://habrastorage.org/webt/7t/rb/ax/7trbaxtrrhtadtm29-dvqwehzo4.png"><br><br><h2>  Erfassungslisten </h2><br>  Swift bietet eine einfache und elegante Möglichkeit, die Schleife starker Glieder in Verschlüssen zu durchbrechen.  Sie deklarieren eine Erfassungsliste, in der Sie die Beziehung zwischen dem Abschluss und den erfassten Objekten definieren. <br><br>  Beachten Sie den folgenden Code, um die Erfassungsliste zu demonstrieren: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> someClosure = { [x] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(x), \(y)"</span></span>) } x = <span class="hljs-number"><span class="hljs-number">6</span></span> y = <span class="hljs-number"><span class="hljs-number">6</span></span> someClosure() <span class="hljs-comment"><span class="hljs-comment">// Prints 5, 6 print("\(x), \(y)") // Prints 6, 6</span></span></code> </pre> <br>  x befindet sich in der Abschlusserfassungsliste, daher wird der Wert von x in die Abschlussdefinition kopiert.  Es wird nach Wert erfasst. <br><br>  y ist nicht in der Erfassungsliste enthalten, sondern wird als Referenz erfasst.  Dies bedeutet, dass der Wert von y so ist, wie er zum Zeitpunkt des Aufrufs der Schaltung war. <br><br>  Sperrlisten helfen dabei, schwache oder nicht besessene Interaktionen in Bezug auf Objekte zu identifizieren, die in der Schleife erfasst wurden.  In unserem Fall ist die entsprechende Auswahl nicht im Besitz, da ein Abschluss nicht vorhanden sein kann, wenn die CarrierSubscription-Instanz freigegeben wird. <br><br><h2>  Ergreifen Sie sich </h2><br>  Ersetzen Sie die vollständige Telefonnummer-Definition durch CarrierSubscription :: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completePhoneNumber: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.countryCode + <span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.number }</code> </pre> <br>  Wir fügen der Liste der Abschlusserfassungen <b>[nicht besessenes Selbst] hinzu</b> .  Dies bedeutet, dass wir uns <b>selbst</b> als nicht <b>besessenes</b> Glied anstatt als starkes gefangen genommen haben. <br><br>  Starten Sie die Anwendung und Sie werden sehen, dass CarrierSubscription jetzt freigegeben ist. <br><br>  Tatsächlich ist die obige Syntax eine Kurzform einer längeren und vollständigeren, in der eine neue Variable erscheint: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> closure = { [<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> newID = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">// Use unowned newID here... }</span></span></code> </pre> <br>  Hier ist newID eine nicht im Besitz befindliche Kopie von self.  Über die Schließung hinaus bleibt das Selbst sich selbst.  In der zuvor angegebenen Kurzform <b>erstellen</b> wir <b>eine neue Selbstvariable</b> , die das vorhandene Selbst innerhalb des Verschlusses verdeckt. <br><br><h2>  Unbesessen vorsichtig verwenden </h2><br>  In Ihrem Code wird die Beziehung zwischen self und completePhoneNumber als nicht besessen festgelegt. <br><br>  Wenn Sie sicher sind, dass das im Abschluss verwendete Objekt nicht freigegeben wird, können Sie unbesessen verwenden.  Wenn er es tut, sind Sie in Schwierigkeiten! <br><br>  Fügen Sie diesen Code am Ende von MainViewController.swift hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WWDCGreeting</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> who: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(who: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.who = who } <span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greetingMaker: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello \(self.who)."</span></span> } }</code> </pre><br>  Hier ist das Ende von runScenario (): <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> greetingMaker: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mermaid = <span class="hljs-type"><span class="hljs-type">WWDCGreeting</span></span>(who: <span class="hljs-string"><span class="hljs-string">"caffeinated mermaid"</span></span>) greetingMaker = mermaid.greetingMaker } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(greetingMaker()) <span class="hljs-comment"><span class="hljs-comment">// !</span></span></code> </pre> <br>  Starten Sie die Anwendung und Sie werden einen Absturz und ähnliches in der Konsole sehen: <br><br>  Benutzer John wurde initialisiert <br>  Telefon iPhone XS wurde initialisiert <br>  CarrierSubscription TelBel wird initialisiert <br>  0032 31415926 <br>  Schwerwiegender Fehler: Es wurde versucht, eine nicht besessene Referenz zu lesen, das Objekt 0x600000f0de30 wurde jedoch bereits freigegeben <br><br>  Eine Ausnahme trat auf, weil die Schließung darauf wartet, dass self.who existiert, aber sie wurde freigegeben, sobald die Meerjungfrau am Ende des do-Blocks den Gültigkeitsbereich verlassen hat. <br><br>  Dieses Beispiel mag von einem Finger gesaugt aussehen, aber solche Dinge passieren.  Wenn wir beispielsweise Schließungen verwenden, um etwas viel später zu starten, beispielsweise nachdem der asynchrone Anruf im Netzwerk beendet wurde. <br><br><h2>  Entschärfe die Falle </h2><br>  Ersetzen Sie greetingMaker in der WWDCGreeting-Klasse durch Folgendes: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greetingMaker: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello \(self?.who)."</span></span> }</code> </pre> <br>  Wir haben zwei Dinge getan: Erstens haben wir unbesessen durch schwach ersetzt.  Zweitens, da das Selbst schwach geworden ist, greifen wir über das Selbst auf das Wer-Eigentum zu. Wer.  Ignorieren Sie die Xcode-Warnung, wir werden sie bald beheben. <br><br>  Die Anwendung stürzt nicht mehr ab, aber wenn Sie sie ausführen, erhalten wir ein lustiges Ergebnis: "Hallo Null." <br><br>  Vielleicht ist das Ergebnis durchaus akzeptabel, aber oft müssen wir etwas tun, wenn das Objekt freigegeben wurde.  Dies kann mithilfe der Guard-Anweisung erfolgen. <br><br>  Ersetzen Sie den Schließungstext durch: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greetingMaker: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"No greeting available."</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello \(self.who)."</span></span> }</code> </pre><br>  Die Wachaussage weist das Selbst dem schwachen Selbst zu.  Wenn self null ist, gibt der Abschluss "Keine Begrüßung verfügbar" zurück.  Andernfalls wird das Selbst zu einer starken Referenz, sodass das Objekt garantiert bis zum Ende des Verschlusses lebt. <br><br><h2>  Suche nach Link-Loops in Xcode 10 </h2><br>  Nachdem Sie nun verstanden haben, wie ARC funktioniert, was Verbindungsschleifen sind und wie sie unterbrochen werden, ist es Zeit, ein Beispiel für eine echte Anwendung zu sehen. <br><br>  Öffnen Sie das Starter-Projekt im Ordner "Kontakte". <br><br>  Starten Sie die App. <br><br><img src="https://habrastorage.org/webt/a8/ce/l1/a8cel1rgbdkm_fel_d880f2swf4.png"><br><br>  Dies ist der einfachste Kontaktmanager.  Klicken Sie auf einen Kontakt und fügen Sie einige neue hinzu. <br><br>  Dateizuordnung: <br><br>  ContactsTableViewController: Zeigt alle Kontakte an. <br>  DetailViewController: Zeigt die detaillierten Informationen des ausgewählten Kontakts an. <br>  NewContactViewController: Ermöglicht das Hinzufügen eines neuen Kontakts. <br>  ContactTableViewCell: Tabellenzelle mit Kontaktdetails. <br>  Kontakt: Kontaktmodell. <br>  Nummer: Telefonnummer Modell. <br><br>  Bei diesem Projekt ist jedoch alles schlecht: Es gibt einen Zyklus von Links.  Zunächst werden Benutzer aufgrund der geringen Größe des undichten Speichers keine Probleme bemerken. Aus dem gleichen Grund ist es schwierig, das Leck zu finden. <br><br>  Glücklicherweise verfügt Xcode 10 über integrierte Tools, um den kleinsten Speicherverlust zu finden. <br><br>  Starten Sie die Anwendung erneut.  Löschen Sie 3-4 Kontakte mit dem Wischen nach links und der Schaltfläche Löschen.  Es scheint, als ob sie vollständig verschwinden, oder? <br><br><img src="https://habrastorage.org/webt/xu/d9/qf/xud9qf3rcyaf5ot_08l8vauizto.png"><br><br><h2>  Wo fließt es? </h2><br>  Wenn die Anwendung ausgeführt wird, klicken Sie auf die Schaltfläche Debug Memory Graph: <br><br><img src="https://habrastorage.org/webt/la/na/km/lanakmzc0d2ousrcf5jwkpu-ova.png"><br><br>  Beachten Sie die Laufzeitprobleme im Debug-Navigator.  Sie sind mit lila Quadraten mit einem weißen Ausrufezeichen gekennzeichnet: <br><br><img src="https://habrastorage.org/webt/uc/ko/vj/uckovjp_eqoplopih79xuz1jl7e.png"><br><br>  Wählen Sie im Navigator eines der problematischen Kontaktobjekte aus.  Der Zyklus ist deutlich sichtbar: Die aufeinander bezogenen Objekte Contact und Number halten. <br><br><img src="https://habrastorage.org/webt/7f/wi/os/7fwios8n7zdk4ww7bj81p4kvgle.png"><br><br>  Sieht so aus, als sollten Sie sich den Code ansehen.  Denken Sie daran, dass ein Kontakt ohne Nummer existieren kann, aber nicht umgekehrt. <br><br>  Wie würden Sie diese Schleife lösen?  Link von Kontakt zu Nummer oder von Nummer zu Kontakt?  schwach oder nicht besessen?  Probieren Sie es zuerst selbst aus! <br><br><div class="spoiler">  <b class="spoiler_title">Wenn Sie Hilfe brauchten ...</b> <div class="spoiler_text">  Es gibt zwei mögliche Lösungen: entweder einen Link von Kontakt zu Nummer schwach machen oder von Nummer zu Kontakt nicht besitzen. <br><br>  In der Dokumentation von Apple wird empfohlen, dass das übergeordnete Objekt einen starken Verweis auf "untergeordnetes Objekt" enthält - nicht umgekehrt.  Dies bedeutet, dass wir Contact einen starken Verweis auf Number und Number geben - einen nicht besessenen Link zu Contact: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contact: <span class="hljs-type"><span class="hljs-type">Contact</span></span> <span class="hljs-comment"><span class="hljs-comment">// Other code... } class Contact { var number: Number? // Other code... }</span></span></code> </pre> <br></div></div><br><h2>  Bonus: Schleifen mit Referenztypen und Werttypen. </h2><br>  Swift verfügt über Referenztypen (Klassen und Abschlüsse) und Werttypen (Strukturen, Aufzählungen).  Der Werttyp wird kopiert, wenn er übergeben wird, und Referenztypen haben über den Link denselben Wert. <br><br>  Dies bedeutet, dass es bei Werttypen keine Zyklen geben kann.  Damit eine Schleife auftritt, benötigen wir mindestens 2 Referenztypen. <br><br>  Kehren wir zum Cycles-Projekt zurück und fügen diesen Code am Ende von MainViewController.swift hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Error var payload = 0 var next: Node? }</span></span></code> </pre><br>  Wird nicht funktionieren!  Struktur ist ein Werttyp und kann keine Rekursion für eine Instanz von sich selbst haben.  Andernfalls hätte eine solche Struktur eine unendliche Größe. <br><br>  Ändern Sie die Struktur in eine Klasse. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> payload = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> next: <span class="hljs-type"><span class="hljs-type">Node?</span></span> }</code> </pre> <br>  Der Verweis auf sich selbst ist für Klassen (Referenztyp) durchaus akzeptabel, sodass der Compiler keine Probleme hat. <br><br>  Fügen Sie dies nun am Ende von MainViewController.swift hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> friends: [<span class="hljs-type"><span class="hljs-type">Person</span></span>] = [] <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(name: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"New person instance: \(name)"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Person instance \(name) is being deallocated"</span></span>) } }</code> </pre> <br>  Und das ist am Ende von runScenario (): <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ernie = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Ernie"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bert = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Bert"</span></span>) ernie.friends.append(bert) <span class="hljs-comment"><span class="hljs-comment">// Not deallocated bert.friends.append(ernie) // Not deallocated }</span></span></code> </pre><br>  Starten Sie die App.  Bitte beachten Sie: Weder ernie noch bert werden veröffentlicht. <br><br><h2>  Link und Bedeutung </h2><br>  Dies ist ein Beispiel für eine Kombination aus einem Referenztyp und einem Werttyp, die zu einer Verbindungsschleife geführt hat. <br><br>  ernie und bert bleiben unveröffentlicht und halten sich gegenseitig in den Arrays ihrer Freunde, obwohl die Arrays selbst Werttypen sind. <br><br>  Versuchen Sie, das Archiv der Freunde als nicht besessen zu machen, und Xcode zeigt einen Fehler an: nicht besessen gilt nur für Klassen. <br><br>  Um diese Schleife zu beheben, müssen wir ein Wrapper-Objekt erstellen und damit dem Array Instanzen hinzufügen. <br><br>  Fügen Sie vor der Person-Klasse die folgende Definition hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Unowned</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyObject</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> (<span class="hljs-number"><span class="hljs-number">_</span></span> value: <span class="hljs-type"><span class="hljs-type">T</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value = value } }</code> </pre><br>  Ändern Sie dann die Definition von Freunden in der Person-Klasse: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> friends: [<span class="hljs-type"><span class="hljs-type">Unowned</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Person</span></span>&gt;] = []</code> </pre> <br>  Ersetzen Sie abschließend den Inhalt des do-Blocks in runScenario (): <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ernie = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Ernie"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bert = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Bert"</span></span>) ernie.friends.append(<span class="hljs-type"><span class="hljs-type">Unowned</span></span>(bert)) bert.friends.append(<span class="hljs-type"><span class="hljs-type">Unowned</span></span>(ernie)) }</code> </pre> <br>  Starten Sie die Anwendung, jetzt sind ernie und bert korrekt freigegeben! <br><br>  Das Friends-Array ist keine Sammlung von Personenobjekten mehr.  Dies ist jetzt eine <b>Sammlung von nicht besessenen Objekten</b> , die als Wrapper für Personeninstanzen dienen. <br><br>  Verwenden Sie die value-Eigenschaft, um Personenobjekte von Unowners abzurufen: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstFriend = bert.friends.first?.value <span class="hljs-comment"><span class="hljs-comment">// get ernie</span></span></code> </pre> <br><h2>  Fazit </h2><br>  Sie haben jetzt ein gutes Verständnis der Speicherverwaltung in Swift und wissen, wie ARC funktioniert.  Ich hoffe, die Veröffentlichung hat Ihnen geholfen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Apple: Automatische Referenzzählung</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451130/">https://habr.com/ru/post/de451130/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451116/index.html">Wie ich mit dem Shared Element Transition kämpfte und meine erste OpenSource-Bibliothek schrieb</a></li>
<li><a href="../de451118/index.html">Testen ist nichts für Anfänger</a></li>
<li><a href="../de451120/index.html">Über die Herausforderungen bei der Portierung von Dead Cells auf mobile Plattformen</a></li>
<li><a href="../de451124/index.html">Entwicklung von Proteinen in der Cloud mit Python und Transcriptic oder Wie man ein Protein für 360 US-Dollar erstellt</a></li>
<li><a href="../de451126/index.html">Toolbox für Forscher - Ausgabe 1: Selbstorganisation und Datenvisualisierung</a></li>
<li><a href="../de451132/index.html">Consumer Driven Contracts oder Gitlab CI-eyed QA-Testautomatisierung</a></li>
<li><a href="../de451136/index.html">Eingeführt von .NET 5</a></li>
<li><a href="../de451138/index.html">Symfony CLI - Neues lokales Entwicklungstool</a></li>
<li><a href="../de451144/index.html">Antiquitäten: Technik in der Fernsehwerbung</a></li>
<li><a href="../de451146/index.html">Beschleunigung der Erstellung von Webanwendungen mit Webpack</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>