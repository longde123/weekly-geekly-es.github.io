<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≤üèø üõåüèæ üåº Ce que vous devez attendre pour cr√©er des strat√©gies de trading sur la bourse: l'efficacit√© de l'apprentissage automatique üßùüèº üê∂ üèâ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans notre blog sur Habr√©, nous avons publi√© des traductions adapt√©es de documents du blog The Financial Hacker, consacr√©s aux questions de cr√©ation d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ce que vous devez attendre pour cr√©er des strat√©gies de trading sur la bourse: l'efficacit√© de l'apprentissage automatique</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/iticapital/blog/412639/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/pq/lc/zm/pqlczmojlxuisfxberyvpnismeu.png"></a> <br><br>  Dans notre blog sur Habr√©, nous avons publi√© des traductions adapt√©es de documents du blog The Financial Hacker, consacr√©s aux questions de cr√©ation de strat√©gies de trading en bourse.  Plus t√¥t, nous avons discut√© de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">recherche des inefficiences du march√©</a> , de la cr√©ation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mod√®les de strat√©gies de trading</a> et des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">principes de leur programmation</a> .  Aujourd'hui, nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nous concentrerons</a> sur l'utilisation d'approches d'apprentissage automatique pour am√©liorer l'efficacit√© des syst√®mes de n√©gociation. <br><br>  Deep Blue est le premier ordinateur √† avoir remport√© le Championnat du monde d'√©checs.  C'√©tait en 1996, et vingt autres ann√©es se sont √©coul√©es avant qu'un autre programme, Alpha Go, ne parvienne √† vaincre le meilleur joueur de Go.  Deep Blue √©tait un syst√®me orient√© mod√®le avec des r√®gles d'√©checs int√©gr√©es.  AplhaGo est un syst√®me d'exploration de donn√©es, un r√©seau neuronal profond, form√© √† l'aide de milliers de jeux dans Go.  Autrement dit, pour faire un pas des victoires sur les gens qui sont champions d'√©checs, pour dominer les meilleurs joueurs de Go, il fallait non pas un morceau de fer am√©lior√©, mais une perc√©e dans le domaine du logiciel. <br><br>  Dans le pr√©sent article, nous envisagerons d'appliquer l'approche d'exploration de donn√©es pour cr√©er des strat√©gies de trading.  Cette m√©thode ne prend pas en compte les m√©canismes du march√©; elle analyse simplement les courbes de prix et d'autres sources de donn√©es pour rechercher des mod√®les pr√©dictifs.  L'apprentissage automatique ou ¬´intelligence artificielle¬ª n'est pas toujours n√©cessaire pour cela.  Au contraire, tr√®s souvent, les m√©thodes d'exploration de donn√©es les plus populaires et les plus rentables fonctionnent sans fioritures sous la forme de r√©seaux de neurones ou de support de m√©thodes vectorielles. <a name="habracut"></a><br><br><h2>  Principes d'apprentissage automatique </h2><br>  L'algorithme entra√Æn√© est aliment√© d'√©chantillons de donn√©es, g√©n√©ralement extraites d'une mani√®re ou d'une autre des prix de change historiques.  Chaque √©chantillon se compose de n variables x1 ... xn, qui sont g√©n√©ralement appel√©es pr√©dicteurs, fonctions, signaux ou, plus simplement, donn√©es d'entr√©e.  Ces pr√©dicteurs peuvent √™tre les prix des n derni√®res barres du graphique des prix ou un ensemble de valeurs d'indicateurs classiques, ou toute autre fonction de la courbe des prix (il y a m√™me des cas o√π des pixels individuels du graphique des prix sont utilis√©s comme pr√©dicteurs pour un r√©seau neuronal!).  Chaque √©chantillon contient √©galement g√©n√©ralement une certaine variable cible y, par exemple, le r√©sultat de la transaction suivante apr√®s analyse de l'√©chantillon ou du prochain mouvement de prix. <br><br>  Dans la litt√©rature, y est souvent appel√© √©tiquette ou objectif.  Dans le processus d'apprentissage, l'algorithme apprend √† pr√©dire la cible y sur la base des pr√©dicteurs x1 ... xn.  Ce que le syst√®me ¬´se souvient¬ª du processus est stock√© dans une structure de donn√©es appel√©e mod√®le sp√©cifique √† un algorithme particulier (il est important de ne pas confondre ce concept avec un mod√®le financier ou une strat√©gie orient√©e mod√®le).  Un mod√®le d'apprentissage automatique peut √™tre des fonctions avec des r√®gles de pr√©diction √©crites √† l'aide du code C g√©n√©r√© par le processus d'apprentissage.  Ou cela pourrait √™tre un ensemble de poids li√©s au r√©seau neuronal: <br><br><blockquote>  Entra√Ænement: x1 ... xn, y =&gt; mod√®le <br><br>  Pr√©diction: x1 ... xn, mod√®le =&gt; y <br></blockquote><br>  Les pr√©dicteurs, les fonctions ou tout autre nom que vous souhaitez utiliser doivent contenir des informations suffisantes pour g√©n√©rer des pr√©dictions sur la valeur de la cible y avec une certaine pr√©cision.  Ils doivent √©galement r√©pondre √† deux crit√®res formels.  Tout d'abord, toutes les valeurs de pr√©dicteur doivent √™tre dans la m√™me plage, par exemple, -1 ... +1 (pour la plupart des algorithmes sur R) ou -100 ... +100 (pour les algorithmes dans les langages de script Zorro ou TSSB).  Donc, avant d'envoyer des donn√©es au syst√®me, vous devez les normaliser.  Deuxi√®mement, les √©chantillons doivent √™tre √©quilibr√©s, c'est-√†-dire r√©partis uniform√©ment sur les valeurs de la variable cible.  Autrement dit, vous devriez avoir le m√™me nombre d'√©chantillons conduisant √† un r√©sultat positif et perdant des ensembles.  Si ces deux exigences ne sont pas respect√©es, de bons r√©sultats ne r√©ussiront pas. <br><br>  Les algorithmes de r√©gression g√©n√®rent des pr√©dictions sur les valeurs num√©riques, telles que la magnitude ou le signe du prochain mouvement de prix.  Les algorithmes de classification pr√©disent des classes quantitatives d'√©chantillons, par exemple, si elles pr√©c√®dent le profit ou la perte de fonds.  Certains algorithmes, tels que les r√©seaux de neurones, les arbres de d√©cision ou les m√©thodes vectorielles de support, peuvent √™tre ex√©cut√©s dans les deux modes. <br><br>  Il existe √©galement des algorithmes qui peuvent apprendre √† extraire des √©chantillons de classe sans avoir besoin d'un y cible.  C'est ce qu'on appelle l'apprentissage non supervis√©, par opposition √† l'apprentissage supervis√©.  Quelque part entre ces deux m√©thodes se trouve ¬´l'apprentissage par renforcement¬ª, dans lequel le syst√®me s'entra√Æne en ex√©cutant des simulations avec des fonctions sp√©cifi√©es et utilise le r√©sultat comme objectif.  Un adepte d'AlphaGo, un syst√®me appel√© AlphaZero, a utilis√© un apprentissage renforc√©, jouant √† un million de jeux de Go avec lui-m√™me.  En finance, ces syst√®mes ou produits qui utilisent un apprentissage non supervis√© sont extr√™mement rares.  99% des syst√®mes utilisent l'apprentissage supervis√©. <br><br>  Quels que soient les signaux que nous utilisons pour les pr√©dicteurs en finance, dans la plupart des cas, ils contiendront beaucoup de bruit et peu d'informations, et en plus ils seront instables.  La pr√©vision financi√®re est donc l'une des t√¢ches les plus difficiles de l'apprentissage automatique.  Des algorithmes plus complexes obtiennent ici de meilleurs r√©sultats.  La s√©lection des pr√©dicteurs est essentielle au succ√®s.  Pas n√©cessairement, il devrait y en avoir beaucoup, car cela conduit √† un recyclage et √† des dysfonctionnements.  Par cons√©quent, les strat√©gies d'exploration de donn√©es utilisent souvent un algorithme pr√©s√©lectionn√© qui extrait un petit nombre de pr√©dicteurs d'un pool plus large.  Une telle s√©lection pr√©liminaire peut √™tre bas√©e sur la corr√©lation entre les pr√©dicteurs, leur importance, la richesse de l'information ou simplement le succ√®s / l'√©chec de l'utilisation de la suite de tests.  Des exp√©riences pratiques avec la s√©lection de cibles peuvent √™tre trouv√©es, par exemple, sur le blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Robot Wealth</a> . <br><br>  Vous trouverez ci-dessous une liste des m√©thodes d'exploration de donn√©es les plus utilis√©es dans le domaine financier. <br><br><h2>  1. Soupe d'indicateurs </h2><br>  La plupart des syst√®mes de n√©gociation ne sont pas bas√©s sur des mod√®les financiers.  Souvent, les traders n'ont besoin que de signaux de trading g√©n√©r√©s par certains indicateurs techniques, qui sont filtr√©s par d'autres indicateurs en combinaison avec des indicateurs techniques suppl√©mentaires.  Quand il demande √† un commer√ßant comment un tel m√©li-m√©lo d'indicateurs peut conduire √† une sorte de profit, il r√©pond g√©n√©ralement √† quelque chose comme: "Croyez-moi, je troque mes mains et tout fonctionne." <br><br>  Et c'est vrai.  Au moins parfois.  Bien que la plupart de ces syst√®mes ne passeront pas le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">test WFA</a> (et certains testent simplement sur des donn√©es historiques), un nombre √©tonnamment √©lev√© de ces syst√®mes fonctionnent et g√©n√®rent des b√©n√©fices.  L'auteur du blog Financial Hacker est engag√© dans le d√©veloppement de syst√®mes de trading personnalis√©s et raconte l'histoire de l'un des clients qui a syst√©matiquement exp√©riment√© des indicateurs techniques jusqu'√† ce qu'il trouve une combinaison qui fonctionne pour certains types d'actifs.  Cette m√©thode d'essai et d'erreur est une approche classique de l'exploration de donn√©es, pour r√©ussir, vous n'en avez besoin que de chance et de beaucoup d'argent pour les tests.  Par cons√©quent, vous pouvez parfois compter sur l'obtention d'un syst√®me rentable. <br><br><h2>  2. Mod√®les de chandelier </h2><br>  √Ä ne pas confondre avec les motifs de bougeoirs qui existent depuis des centaines d'ann√©es.  L'√©quivalent moderne de cette approche est le commerce bas√© sur les mouvements de prix.  Vous analysez √©galement les indicateurs d'ouverture, de haut, de bas et de fermeture pour chaque bougie du graphique.  Mais maintenant, vous utilisez l'exploration de donn√©es pour analyser les bougies de la courbe des prix pour mettre en √©vidence des mod√®les qui peuvent √™tre utilis√©s pour g√©n√©rer des pr√©dictions sur la direction du mouvement des prix √† l'avenir. <br><br>  Il existe des packages logiciels complets √† cet effet.  Ils recherchent des mod√®les rentables en termes de crit√®res d√©finis par l'utilisateur et les utilisent pour cr√©er une fonction de d√©tection de mod√®le.  Tout cela peut ressembler √† ceci: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">* sig)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">0</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">7</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">8</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">2</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">3</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">4</span></span>] &amp;&amp; eqF(sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]-sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]) &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">2</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">3</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">7</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">8</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">4</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">2</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">0</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">3</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">7</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">8</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Cette fonction C renvoie 1 lorsque le signal correspond √† l'un des mod√®les, sinon elle renvoie 0. Le code long semble indiquer que ce n'est pas le moyen le plus rapide pour rechercher des mod√®les.  Il est pr√©f√©rable d'utiliser une approche dans laquelle la fonction de d√©tection n'a pas besoin d'√™tre export√©e, mais peut trier les signaux par leur importance et les trier.  Un exemple d'un tel syst√®me peut √™tre trouv√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur le lien</a> . <br><br>  Le commerce √† un prix peut-il fonctionner?  Comme dans le cas pr√©c√©dent, cette m√©thode n'est bas√©e sur aucun mod√®le financier rationnel.  Dans le m√™me temps, tout le monde comprend que certains √©v√©nements sur le march√© peuvent affecter ses participants, ce qui entra√Æne des sch√©mas pr√©dictifs √† court terme.  Mais le nombre de ces mod√®les ne peut pas √™tre important si vous √©tudiez uniquement la s√©quence de plusieurs bougies cons√©cutives sur le graphique.  Ensuite, vous devrez comparer le r√©sultat avec les donn√©es des bougies, qui ne sont pas √† proximit√©, mais, au contraire, sont s√©lectionn√©es au hasard sur une p√©riode plus longue.  Dans ce cas, vous obtiendrez un nombre presque illimit√© de mod√®les - et r√©ussirez √† vous d√©tacher des concepts de r√©alit√© et de rationalit√©.  Il est difficile d'imaginer comment le prix futur peut √™tre pr√©dit sur la base de certaines de ses valeurs la semaine derni√®re.  Malgr√© cela, de nombreux commer√ßants travaillent dans ce sens. <br><br><h2>  3. R√©gression lin√©aire </h2><br>  Une base simple pour de nombreux algorithmes complexes d'apprentissage automatique: pour pr√©dire la variable cible y √† l'aide d'une combinaison lin√©aire de pr√©dicteurs x1 ... xn. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d0/230/0e1/3d02300e11bdf79ba483a647d5089421.png" alt="image"><br><br>  Cotes - c'est le mod√®le.  Ils sont calcul√©s pour minimiser la somme des √©carts quadratiques entre les valeurs r√©elles y, les valeurs d'apprentissage et les pr√©visions y selon la formule: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc7/06c/d46/bc706cd46620a7d8682eb18e16daeeda.png" alt="image"><br><br>  Pour les √©chantillons normalement distribu√©s, la minimisation est possible √† l'aide d'op√©rations matricielles, donc les it√©rations ne sont pas n√©cessaires.  Dans le cas o√π n = 1 - avec un seul pr√©dicteur x, la formule de r√©gression est r√©duite √†: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/adc/a79/e98/adca79e98f1193be9b631dbfe51dbc96.png" alt="image"><br><br>  - c'est-√†-dire, avant une r√©gression lin√©aire simple, et lorsque n&gt; 1, la r√©gression lin√©aire sera multivariante.  Une r√©gression lin√©aire simple est disponible sur la plupart des plateformes de trading, par exemple, l'indicateur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LinReg</a> dans TA-Lib.  Lorsque y = prix et x = temps, il peut √™tre utilis√© comme alternative aux moyennes mobiles.  Dans la plate-forme R, une telle r√©gression est impl√©ment√©e par la fonction de livraison standard lm (..).  Il peut √©galement √™tre repr√©sent√© par r√©gression polynomiale.  Comme dans le cas le plus simple, nous utilisons ici une variable pr√©dictive x, mais aussi son carr√© et les degr√©s suivants, donc xn == xn: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/248/b3c/bd4/248b3cbd40c637b1a15376d227432e81.png" alt="image"><br><br>  Si n = 2 ou n = 3, la r√©gression polynomiale est souvent utilis√©e pour pr√©dire le prochain prix moyen √† partir des prix liss√©s des derni√®res barres.  Pour la r√©gression polynomiale, la fonction polyfit du MatLab, R, Zorro et de nombreuses autres plates-formes peut √™tre utilis√©e. <br><br><h2>  4. Perceptron </h2><br>  On l'appelle souvent un r√©seau de neurones avec un seul neurone.  En fait, le perceptron est une fonction de r√©gression, comme d√©crit ci-dessus, mais avec un r√©sultat binaire, √† la suite de quoi il est appel√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©gression logistique</a> .  Bien que, en g√©n√©ral, ce ne soit pas une r√©gression, mais un algorithme de classification.  Par exemple, la fonction de conseil (PERCEPTRON, ...) du framework Zorro g√©n√®re du code C qui retourne 100 ou -100 selon que le r√©sultat pr√©vu est seuil ou non: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">predict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">* sig)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">-27.99</span></span>*sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-number"><span class="hljs-number">1.24</span></span>*sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">3.54</span></span>*sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">-21.50</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-100</span></span>; }</code> </pre> <br>  Comme vous pouvez le voir, le tableau sig est √©quivalent aux fonctions xn dans la formule de r√©gression, et les coefficients an sont les facteurs num√©riques. <br><br><h2>  5. R√©seaux de neurones </h2><br>  La r√©gression lin√©aire ou logistique ne peut r√©soudre que des probl√®mes lin√©aires.  Dans le m√™me temps, les t√¢ches de trading ne rentrent souvent pas dans cette cat√©gorie.  Un exemple c√©l√®bre est la pr√©diction de la sortie d'une fonction XOR simple.  Cela inclut √©galement la pr√©vision du profit des transactions.  Un r√©seau de neurones artificiels (ANN) peut r√©soudre des probl√®mes non lin√©aires.  Il s'agit d'un ensemble de perceptrons qui sont connect√©s dans un tableau de diff√©rents niveaux.  Chaque perceptron est un neurone de r√©seau.  Sa sortie devient entr√©e vers d'autres neurones du niveau suivant: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/050/d12/c5d/050d12c5da82f4f97fdd942d7777b8e4.png" alt="image"><br><br>  Comme le perceptron, le r√©seau neuronal est entra√Æn√© en d√©terminant des coefficients qui minimisent l'erreur entre la pr√©diction et la cible dans l'√©chantillon.  Cela n√©cessite un processus d'approximation, g√©n√©ralement avec la propagation inverse de l'erreur de la sortie √† l'entr√©e avec l'optimisation des poids en cours de route.  Ce processus a deux limites.  Premi√®rement, la sortie des neurones devrait √™tre une fonction diff√©renciable en continu au lieu d'un simple seuil pour le perceptron.  Deuxi√®mement, le r√©seau ne doit pas √™tre tr√®s profond - la pr√©sence d'un grand nombre de niveaux cach√©s de neurones entre les donn√©es d'entr√©e et de sortie ne fait que nuire.  Cette deuxi√®me limitation limite la complexit√© des probl√®mes qu'un r√©seau neuronal standard peut r√©soudre. <br><br>  Lorsque vous utilisez des r√©seaux de neurones pour pr√©dire les transactions, vous aurez beaucoup de param√®tres qui peuvent √™tre manipul√©s, ce qui, s'il est mal effectu√©, peut entra√Æner un biais de s√©lection (biais de s√©lection): <br><br><ul><li>  nombre de niveaux cach√©s; </li><li>  le nombre de neurones dans chaque niveau cach√©; </li><li>  nombre de cycles de r√©tropropagation - √©poques; </li><li>  degr√© de formation, largeur de pas de l'√©poque; </li><li>  momentum, facteur d'inertie pour l'adaptation des poids; </li><li>  fonction d'activation. </li></ul><br>  La fonction d'activation √©mule le seuil du perceptron.  Pour la r√©tropropagation, vous avez besoin d'une fonction constamment diff√©rentiable qui g√©n√®re un pas progressif pour une certaine valeur de x.  En r√®gle g√©n√©rale, les fonctions sigmo√Øde, tanh ou softmax sont utilis√©es √† cet effet.  Parfois, une fonction lin√©aire est utilis√©e qui renvoie la somme pond√©r√©e de toutes les donn√©es d'entr√©e.  Dans ce cas, le r√©seau peut √™tre utilis√© pour la r√©gression, la pr√©diction de valeurs num√©riques au lieu de la sortie binaire. <br><br>  Les r√©seaux de neurones sont inclus dans la livraison standard du package de R (par exemple, nnet est un r√©seau avec un niveau masqu√©), ainsi que dans de nombreux autres packages (tels que RSNNS et FCNN4R). <br><br><h2>  6. Apprentissage profond </h2><br>  Les m√©thodes d'apprentissage en profondeur utilisent des r√©seaux de neurones avec de nombreux niveaux cach√©s et des milliers de neurones qui ne peuvent pas √™tre efficacement form√©s √† l'aide d'une simple r√©tropropagation.  Ces derni√®res ann√©es, plusieurs m√©thodes sont devenues populaires pour la formation de tels grands r√©seaux.  Ils impliquent g√©n√©ralement une pr√©-formation de niveaux cach√©s de neurones pour augmenter l'efficacit√© de l'apprentissage de base. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La</a> machine Boltzmann restreinte (RBM) est un algorithme de classification non contr√¥l√© avec une structure de r√©seau sp√©ciale dans laquelle il n'y a pas de connexions entre les neurones cach√©s.  Sparse Auto Encoder (SAE) utilise la structure de r√©seau habituelle, mais pr√©-entra√Æne les couches cach√©es d'une mani√®re sp√©cifique, reproduisant les signaux d'entr√©e aux niveaux de sortie avec le moins de connexions actives possible.  Ces m√©thodes vous permettent de mettre en ≈ìuvre des r√©seaux tr√®s complexes pour r√©soudre des probl√®mes d'apprentissage tr√®s complexes.  Par exemple, la t√¢che de vaincre la meilleure personne qui joue au Go. <br><br>  Les r√©seaux d'apprentissage en profondeur sont inclus dans les packages deepnet et darch pour R. Deepnet comprend l'auto-encodeur et darch inclut la machine Boltzmann.  Voici un exemple de code qui utilise deepnet avec trois niveaux cach√©s pour traiter les signaux de trading via la fonction neor () du framework Zorro: <br><br><pre> <code class="cpp hljs">library(<span class="hljs-string"><span class="hljs-string">'deepnet'</span></span>, quietly = T) library(<span class="hljs-string"><span class="hljs-string">'caret'</span></span>, quietly = T) <span class="hljs-meta"><span class="hljs-meta"># called by Zorro for training neural.train = function(model,XY) { XY </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;- as.matrix(XY) X &lt;- XY[,-ncol(XY)] # predictors Y &lt;- XY[,ncol(XY)] # target Y &lt;- ifelse(Y &gt; 0,1,0) # convert -1..1 to 0..1 Models[[model]] &lt;&lt;- sae.dnn.train(X,Y, hidden = c(50,100,50), activationfun = "tanh", learningrate = 0.5, momentum = 0.5, learningrate_scale = 1.0, output = "sigm", sae_output = "linear", numepochs = 100, batchsize = 100, hidden_dropout = 0, visible_dropout = 0) } # called by Zorro for prediction neural.predict = function(model,X) { if(is.vector(X)) X &lt;- t(X) # transpose horizontal vector return(nn.predict(Models[[model]],X)) } # called by Zorro for saving the models neural.save = function(name) { save(Models,file=name) # save trained models } # called by Zorro for initialization neural.init = function() { set.seed(365) Models &lt;&lt;- vector("list") } # quick OOS test for experimenting with the settings Test = function() { neural.init() XY &lt;&lt;- read.csv('C:/Project/Zorro/Data/signals0.csv',header = F) splits &lt;- nrow(XY)*0.8 XY.tr &lt;&lt;- head(XY,splits) # training set XY.ts &lt;&lt;- tail(XY,-splits) # test set neural.train(1,XY.tr) X &lt;&lt;- XY.ts[,-ncol(XY.ts)] Y &lt;&lt;- XY.ts[,ncol(XY.ts)] Y.ob &lt;&lt;- ifelse(Y &gt; 0,1,0) Y &lt;&lt;- neural.predict(1,X) Y.pr &lt;&lt;- ifelse(Y &gt; 0.5,1,0) confusionMatrix(Y.pr,Y.ob) # display prediction accuracy }</span></span></span></span></code> </pre> <br><h2>  7. Vecteurs de support </h2><br>  Comme pour les r√©seaux de neurones, la m√©thode des vecteurs de support est une autre extension de la r√©gression lin√©aire.  Si vous regardez √† nouveau la formule de r√©gression: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d0/230/0e1/3d02300e11bdf79ba483a647d5089421.png" alt="image"><br><br>  On peut alors interpr√©ter les fonctions xn comme les coordonn√©es d'un espace √† n dimensions.  D√©finir la variable cible y sur une valeur fixe d√©terminera le plan dans cet espace - il sera appel√© un hyperplan, car en fait il aura deux tailles (m√™me n-1).  L'hyperplan s√©pare les √©chantillons avec y&gt; 0 de ceux o√π y &lt;0. Les coefficients an peuvent √™tre calcul√©s comme le chemin s√©parant l'avion des √©chantillons les plus proches - ses vecteurs de support, d'o√π le nom de l'algorithme.  Ainsi, nous obtenons un classificateur binaire avec la s√©paration optimale des √©chantillons gagnants et perdants. <br><br>  Probl√®me: g√©n√©ralement, ces √©chantillons ne peuvent pas √™tre divis√©s lin√©airement - ils sont regroup√©s au hasard dans un espace de fonction.  Il est impossible de tracer un plan lisse entre les options gagnantes et perdantes; si cela pouvait √™tre fait, alors pour son calcul, on pourrait utiliser des m√©thodes plus simples telles que l'analyse discriminante lin√©aire.  Mais dans le cas g√©n√©ral, vous pouvez utiliser l'astuce: ajouter plus de tailles √† l'espace.  Dans ce cas, l'algorithme de vecteur de support sera capable de g√©n√©rer plus de param√®tres avec une fonction nucl√©aire qui combine deux pr√©dicteurs quelconques - similaire √† la transition de la r√©gression simple au polyn√¥me.  Plus vous ajoutez de tailles, plus il est facile de diviser les √©chantillons avec un hyperplan.  Il peut ensuite √™tre reconverti dans l'espace √† n dimensions d'origine. <br><br>  Comme les r√©seaux de neurones, les vecteurs de r√©f√©rence peuvent √™tre utilis√©s non seulement pour la classification, mais aussi pour la r√©gression.  Ils offrent √©galement un certain nombre d'options d'optimisation et de recyclage possible: <br><br><ul><li>  Fonction noyau - le noyau RBF (fonction de base radiale, noyau sym√©trique) est g√©n√©ralement utilis√©, mais d'autres noyaux peuvent √™tre s√©lectionn√©s, par exemple sigmo√Øde, polynomial et lin√©aire. </li><li>  Gamma - largeur de noyau RBF. </li><li>  Param√®tre de co√ªt C, ¬´p√©nalit√©¬ª pour les classifications incorrectes des √©chantillons d'apprentissage. </li></ul><br>  La biblioth√®que libsvm est souvent utilis√©e, qui est disponible dans le package e1071 pour R. <br><br><h2>  8. Algorithme des k voisins les plus proches </h2><br>  Compar√© aux lourds ANN et SVM, il s'agit d'un algorithme simple et agr√©able avec une propri√©t√© unique: il n'a pas besoin d'√™tre entra√Æn√©.  Les √©chantillons seront le mod√®le.  Cet algorithme peut √™tre utilis√© pour un syst√®me de trading qui est constamment form√© en ajoutant de nouveaux √©chantillons.  Cet algorithme calcule les distances dans l'espace des fonctions de la valeur actuelle aux k √©chantillons les plus proches.  La distance dans l'espace √† n dimensions entre les deux ensembles (x1 ... xn) et (y1 ... yn) est calcul√©e par la formule: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66e/322/2bc/66e3222bce4b5e79d460e20b612eadcb.png" alt="image"><br><br>  L'algorithme pr√©dit simplement la cible √† partir de la moyenne de k variables cibles des √©chantillons les plus proches, pond√©r√©es par leurs distances de retour.  Il peut √™tre utilis√© √† la fois pour la classification et la r√©gression.  Pour pr√©dire les voisins les plus proches, vous pouvez appeler la fonction knn dans R ou √©crire le code C vous-m√™me √† cet effet. <br><br><h2>  9. K-means </h2><br>  Il s'agit d'un algorithme d'approximation pour une classification non contr√¥l√©e.  Il est quelque peu similaire √† l'algorithme pr√©c√©dent.  Pour classer les √©chantillons, l'algorithme place d'abord k points al√©atoires dans l'espace de fonction.  Il assigne ensuite √† l'un de ces points tous les √©chantillons avec la plus petite distance.  Ensuite, le point se d√©place au milieu de ces valeurs les plus proches.  Cela g√©n√®re de nouveaux exemples de liaisons, car certains d'entre eux seront d√©sormais plus proches d'autres points.  Le processus est r√©p√©t√© jusqu'√† ce que le re-r√©f√©rencement r√©sultant du d√©calage des points s'arr√™te, c'est-√†-dire jusqu'√† ce que chaque point soit moyen pour les √©chantillons les plus proches.  Nous avons maintenant k exemples de classes, chacune situ√©e √† c√¥t√© d'un k-point. <br><br>  Cet algorithme simple peut produire des r√©sultats √©tonnamment bons.  Dans R, la fonction kmeans est utilis√©e pour l'impl√©menter; un exemple de l'algorithme peut √™tre trouv√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur le lien</a> . <br><br><h2>  10. Naive Bayes </h2><br>  Cet algorithme utilise le th√©or√®me bay√©sien pour classer des √©chantillons de fonctions non num√©riques (√©v√©nements), comme les mod√®les de bougies mentionn√©s ci-dessus.  Supposons que l'√©v√©nement X (par exemple, le param√®tre Open de la barre pr√©c√©dente sous le param√®tre Open de la barre actuelle) apparaisse dans 80% des √©chantillons gagnants.  Quelle sera alors la probabilit√© de gagner l'√©chantillon en pr√©sence de l'√©v√©nement X?  Ce n'est pas 0,8 comme vous pourriez le penser.  Cette probabilit√© est calcul√©e par la formule: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/727/e4e/7ab/727e4e7abb69e9b8ef5334558a753a70.png" alt="image"><br><br>  P (Y | X) est la probabilit√© que l'√©v√©nement Y (profit) se produise dans tous les √©chantillons contenant l'√©v√©nement X (dans notre exemple, Open (1) &lt;Open (0)).  Conform√©ment √† la formule, elle est √©gale √† la probabilit√© d'occurrence de l'√©v√©nement X dans tous les √©chantillons gagnants (dans notre cas, 0,8), multipli√©e par la probabilit√© Y dans tous les √©chantillons (environ 0,5 si vous suivez les conseils pour √©quilibrer les √©chantillons) et divis√©e par la probabilit√© d'occurrence de X dans tous les √©chantillons. <br><br>  Si nous sommes na√Øfs et supposons que tous les √©v√©nements de X sont ind√©pendants les uns des autres, alors nous pouvons calculer la probabilit√© totale que l'√©chantillon va gagner en multipliant simplement les probabilit√©s P (X | gagnant) pour chaque √©v√©nement X. Ensuite, nous arrivons √† la formule suivante: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b0/c54/d51/7b0c54d515098b06b54e7446d9097954.png" alt="image"><br><br>  Avec le facteur d'√©chelle s.  Pour qu'une formule fonctionne, les fonctions doivent √™tre choisies de mani√®re √† √™tre aussi ind√©pendantes que possible.  Ce sera un obstacle √† l'utilisation de Bayes na√Øfs pour le commerce.  Par exemple, deux √©v√©nements Close (1) &lt;Close (0) et Open (1) &lt;Open (0) ne sont probablement pas ind√©pendants l'un de l'autre.  Les pr√©dicteurs num√©riques peuvent √™tre convertis en √©v√©nements en divisant le nombre en plages distinctes.  Naive Bayes est disponible dans le package e1071 pour R. <br><br><h2>  11. Arbres de d√©cision et de r√©gression </h2><br>  De tels arbres pr√©disent le r√©sultat de valeurs num√©riques bas√©es sur une cha√Æne de d√©cision au format oui / non dans la structure des branches d'arbre.  Chaque d√©cision repr√©sente la pr√©sence ou l'absence d'√©v√©nements (dans le cas de valeurs non num√©riques) ou la comparaison de valeurs avec un seuil fixe.  Une fonction d'arbre typique, g√©n√©r√©e, par exemple, par le framework Zorro, ressemble √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">* sig)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">12.938</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">0.953</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-70</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">43</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">0.962</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-67</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">0.732</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-71</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">30.61</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">27</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">46</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-62</span></span>; } } } }</code> </pre> <br>  Comment un tel arbre est-il obtenu √† partir d'un ensemble d'√©chantillons?  Il peut y avoir plusieurs m√©thodes pour cela, y compris <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'entropie informationnelle de Shannon</a> . <br><br>  Les arbres de d√©cision peuvent √™tre assez largement utilis√©s.  Par exemple, ils conviennent pour g√©n√©rer des pr√©dictions plus pr√©cises que celles qui peuvent √™tre obtenues en utilisant des r√©seaux de neurones ou des vecteurs de r√©f√©rence.  Cependant, ce n'est pas une solution universelle.  L'algorithme le plus connu de ce type est C5.0, disponible dans le package C50 pour R. <br><br>  Pour am√©liorer encore la qualit√© des pr√©visions, vous pouvez utiliser des ensembles d'arbres - ils sont appel√©s une for√™t al√©atoire.  Cet algorithme est disponible dans des packages R appel√©s randomForest, ranger et Rborist. <br><br><h2>  Conclusion </h2><br>  Il existe de nombreuses m√©thodes d'exploration de donn√©es et d'apprentissage automatique.  La question critique ici est la suivante: quelles sont les meilleures strat√©gies, bas√©es sur des mod√®les ou d'apprentissage automatique?  Il ne fait aucun doute que l'apprentissage automatique pr√©sente un certain nombre d'avantages.  Par exemple, vous n'avez pas besoin de vous soucier de la microstructure du march√©, de l'√©conomie, de prendre en compte la philosophie des acteurs du march√© ou d'autres choses similaires.  Vous pouvez vous concentrer sur les math√©matiques pures.  L'apprentissage automatique est un moyen beaucoup plus √©l√©gant et attrayant de cr√©er des syst√®mes de trading.  De son c√¥t√©, tous les avantages, sauf un - en plus des histoires sur les forums de traders, le succ√®s de cette m√©thode dans le trading r√©el est difficile √† suivre. <br><br>  Presque chaque semaine, de nouveaux articles sont publi√©s sur le trading √† l'aide du machine learning.  Ces documents doivent √™tre pris avec beaucoup de scepticisme.  Certains auteurs revendiquent des taux de gains fantastiques de 70%, 80%, voire 85%.  Cependant, peu de gens disent que vous pouvez perdre de l'argent m√™me si les pronostics sont gagnants.  Une pr√©cision de 85% se traduit g√©n√©ralement par un indicateur de rentabilit√© sup√©rieur √† 5 - si tout √©tait si simple, alors les cr√©ateurs d'un tel syst√®me deviendraient d√©j√† milliardaires.  Cependant, pour une raison quelconque, reproduire les m√™mes r√©sultats simplement en r√©p√©tant les m√©thodes d√©crites dans les articles √©choue. <br><br>  Par rapport aux syst√®mes bas√©s sur des mod√®les, il existe tr√®s peu de v√©ritables syst√®mes d'apprentissage automatique r√©ussis.  Par exemple, ils sont rarement utilis√©s par les hedge funds performants.  Peut-√™tre qu'√† l'avenir, lorsque la puissance de calcul deviendra encore plus accessible, quelque chose changera, mais pour l'instant, les algorithmes d'apprentissage en profondeur restent plus un passe-temps int√©ressant pour les geeks qu'un v√©ritable outil de gagner de l'argent sur l'√©change. <br><br><h2>  Autres documents financiers et boursiers d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ITI Capital</a> : </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Analyses et analyses de march√©</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Retour vers le futur: v√©rifier les performances d'un robot de trading √† l'aide de donn√©es historiques</a> </li><li>  Backtesting Python √©v√©nementiel √©tape par √©tape ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 4</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 5</a> ) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr412639/">https://habr.com/ru/post/fr412639/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr412625/index.html">Comment trouver rapidement et ne pas perdre des sp√©cialistes de l'IA et de la science des donn√©es</a></li>
<li><a href="../fr412627/index.html">Exposition internationale CMEF & ICMD 2018 Spring in Shanghai (Part 2)</a></li>
<li><a href="../fr412629/index.html">Forme d'onde adaptative pour votre service audio</a></li>
<li><a href="../fr412633/index.html">Exp√©rience de la configuration et de l'utilisation de WSL (sous-syst√®me Linux dans Windows 10)</a></li>
<li><a href="../fr412637/index.html">Faire ou ne pas repenser les logos? Telle est la question</a></li>
<li><a href="../fr412641/index.html">Qu'ont en commun l'exploitation mini√®re, la G√©orgie et Irkoutsk?</a></li>
<li><a href="../fr412643/index.html">Comment nous avons int√©gr√© le syst√®me de paiement dans le projet russe</a></li>
<li><a href="../fr412645/index.html">Objet, propri√©t√©, activit√©: mod√®les et m√©thodes de construction</a></li>
<li><a href="../fr412647/index.html">De nouvelles preuves de l'existence de la neuvi√®me plan√®te</a></li>
<li><a href="../fr412649/index.html">Comment constituer une √©quipe et des processus ax√©s sur une croissance rapide</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>