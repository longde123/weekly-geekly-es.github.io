<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌃 🙌🏽 👩🏼‍🤝‍👨🏻 Suivre la trace des calculatrices: Qalculate ➿ 👩🏾‍🤝‍👨🏼 🗿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Plus tôt, nous avons effectué des révisions de code de grands packages mathématiques, par exemple, Scilab et Octave, et les calculatrices sont restées...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Suivre la trace des calculatrices: Qalculate</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/443654/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/8-/gy/xn/8-gyxngfcuknt6ufomhpg4kpjry.png"></div><br>  Plus tôt, nous avons effectué des révisions de code de grands packages mathématiques, par exemple, Scilab et Octave, et les calculatrices sont restées de côté en tant que petits utilitaires dans lesquels il est difficile de faire des erreurs en raison de leur petite taille de code.  Nous nous sommes trompés en ne leur prêtant pas attention.  Le cas de la publication du code source de la calculatrice Windows a montré que tout le monde est intéressé à discuter des erreurs qui y sont cachées, et il y a plus qu'assez d'erreurs pour écrire un article à ce sujet.  Mes collègues et moi avons décidé d'examiner le code d'un certain nombre de calculatrices populaires, et il s'est avéré que le code de la calculatrice Windows n'était pas si mauvais (spoiler). <br><a name="habracut"></a><br><h2>  Présentation </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Calculez!</a>  - calculatrice multi-plateforme universelle.  Il est facile à utiliser, mais offre la puissance et la polyvalence généralement présentes dans les packages mathématiques complexes, ainsi que des outils utiles pour les besoins quotidiens (tels que la conversion de devises et le calcul des intérêts).  Le projet se compose de deux composants: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libqalculate</a> (bibliothèque et CLI) et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qalculate-gtk</a> (GTK + UI).  Seul le code libqalculate est impliqué dans l'étude. <br><br>  Pour comparer plus facilement le projet avec la même calculatrice Windows que nous avons récemment examinée, je donne la sortie de l'utilitaire Cloc pour libqalculate: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/214/1f7/e35/2141f7e35bc5af14579e61f9bf4d907a.png" alt="Image 4"></div><br>  Subjectivement, il y a plus d'erreurs, et elles sont plus critiques que dans le code de la calculatrice Windows.  Mais je vous recommande de tirer des conclusions vous-même en lisant cette revue de code. <br><br>  À propos, voici un lien vers un article sur la vérification d'une calculatrice de Microsoft: « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Compter les bogues dans une calculatrice Windows</a> » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">.</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PVS-Studio a été</a> utilisé comme outil d'analyse statique.  Il s'agit d'un ensemble de solutions pour le contrôle de la qualité du code, la recherche d'erreurs et les vulnérabilités potentielles.  Les langages pris en charge incluent: C, C ++, C # et Java.  L'analyseur peut être lancé sur Windows, Linux et macOS. <br><br><h2>  Copiez et collez à nouveau! </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V523</a> L' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instruction</a> 'then' est équivalente à l'instruction 'else'.  Number.cc 4018 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Number::square() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mpfr_cmpabs(i_value-&gt;internalLowerFloat(), i_value-&gt;internalUpperFloat()) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { mpfr_sqr(f_tmp, i_value-&gt;internalLowerFloat(), MPFR_RNDU); mpfr_sub(f_rl, f_rl, f_tmp, MPFR_RNDD); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { mpfr_sqr(f_tmp, i_value-&gt;internalLowerFloat(), MPFR_RNDU); mpfr_sub(f_rl, f_rl, f_tmp, MPFR_RNDD); } .... }</code> </pre> <br>  Le code de l' <i>instruction</i> <i>if</i> et <i>else est</i> exactement le même.  Les fragments de code voisins sont très similaires à cela, mais ils utilisent différentes fonctions: <i>internalLowerFloat ()</i> et <i>internalUpperFloat ()</i> .  Il est sûr de supposer qu'ici le programmeur a copié le code et oublié de corriger le nom de la fonction. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V501</a> Il existe des sous-expressions identiques '! Mtr2.number (). IsReal ()' à gauche et à droite de '||'  opérateur.  BuiltinFunctions.cc 6274 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IntegrateFunction::calculate(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!mtr2.isNumber() || !mtr2.number().isReal() || !mtr.isNumber() || !mtr2.number().isReal()) b_unknown_precision = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... }</code> </pre> <br>  Ici, des expressions en double sont apparues car à un endroit au lieu du nom <i>mtr, elles ont</i> écrit <i>mtr2</i> .  Ainsi, dans la condition, il n'y a aucun appel à la fonction <i>mtr.number (). IsReal ()</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V501</a> Il existe des sous-expressions identiques «vargs [1] .representNonPositive ()» à gauche et à droite de «||»  opérateur.  BuiltinFunctions.cc 5785 <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9fe/18d/e5c/9fe18de5c88498e1cc8e56e2c91ddcd7.png" alt="Image 6"></p><br><br>  Trouver des anomalies dans ce code manuellement est irréel!  Mais ils le sont.  De plus, dans le fichier d'origine, ces fragments sont écrits sur une seule ligne.  L'analyseur a détecté une expression en double <i>vargs [1] .representNonPositive ()</i> , qui peut indiquer une faute de frappe et, par conséquent, une erreur potentielle. <br><br>  Voici toute la liste des endroits suspects que vous pouvez à peine comprendre: <br><br><ul><li>  V501 Il existe des sous-expressions identiques «vargs [1] .representNonPositive ()» à gauche et à droite de «||»  opérateur.  BuiltinFunctions.cc 5788 </li><li>  V501 Il existe des sous-expressions identiques «ajouter» à gauche et à droite de l'opérateur «&amp;&amp;».  MathStructure.cc 1780 </li><li>  V501 Il existe des sous-expressions identiques «ajouter» à gauche et à droite de l'opérateur «&amp;&amp;».  MathStructure.cc 2043 </li><li>  V501 Il existe des sous-expressions identiques '(* v_subs [v_order [1]]). ReprésenteNégatif (vrai)' à gauche et à droite de l'opérateur '&amp;&amp;'.  MathStructure.cc 5569 </li></ul><br><h2>  Boucle non valide </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V534</a> Il est probable qu'une mauvaise variable soit comparée à l'intérieur de l'opérateur 'for'.  Pensez à revoir «i».  MathStructure.cc 28741 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> MathStructure::isolate_x_sub(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mvar-&gt;size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((*mvar)[i].contains(x_var)) { mvar2 = &amp;(*mvar)[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mvar-&gt;isMultiplication()) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mvar2-&gt;size(); i2++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((*mvar2)[i2].contains(x_var)) {mvar2 = &amp;(*mvar2)[i2]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} } } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... }</code> </pre> <br>  Dans la boucle interne, le compteur est la variable <i>i2</i> , mais en raison d'une faute de frappe, une erreur a été commise - à condition d'arrêter la boucle, la variable <i>i</i> de la boucle externe est utilisée. <br><br><h2>  Redondance ou erreur? </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V590</a> Envisagez d'inspecter cette expression.  L'expression est excessive ou contient une erreur d'impression.  Number.cc 6564 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Number::add(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Number &amp;o, MathOperation op) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i1 &gt;= COMPARISON_RESULT_UNKNOWN &amp;&amp; (i2 == COMPARISON_RESULT_UNKNOWN || i2 != COMPARISON_RESULT_LESS)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... }</code> </pre> <br>  Après avoir examiné un tel code, il y a 3 ans, j'ai écrit une note pour m'aider moi-même et d'autres programmeurs: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Expressions logiques en C / C ++. Comment les professionnels se trompent</a> ."  En rencontrant un tel code, je suis convaincu que la note n'est pas du tout devenue moins pertinente.  Vous pouvez regarder dans l'article, trouver le modèle d'erreur correspondant au code et découvrir toutes les nuances. <br><br>  Dans le cas de cet exemple, allez dans la section "Expression == ||  ! = ”Et nous apprenons que l'expression <i>i2 == COMPARISON_RESULT_UNKNOWN</i> n'affecte rien. <br><br><h2>  Déréférencer des pointeurs non vérifiés </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V595</a> Le pointeur 'o_data' a été utilisé avant d'être vérifié par rapport à nullptr.  Vérifiez les lignes: 1108, 1112. DataSet.cc 1108 <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> DataObjectArgument::subprintlong() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> str = _(<span class="hljs-string"><span class="hljs-string">"an object from"</span></span>); str += <span class="hljs-string"><span class="hljs-string">" \""</span></span>; str += o_data-&gt;title(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= str += "\""; DataPropertyIter it; DataProperty *o = NULL; if(o_data) { // &lt;= o = o_data-&gt;getFirstProperty(&amp;it); } .... }</span></span></code> </pre> <br>  Le pointeur <i>o_data</i> dans une fonction est déréférencé sans vérification et avec vérification.  Il peut s'agir d'un code redondant ou d'une erreur potentielle.  Je suis enclin à la dernière option. <br><br>  Il y a deux autres endroits similaires: <br><br><ul><li>  V595 Le pointeur 'o_assumption' a été utilisé avant d'être vérifié par rapport à nullptr.  Vérifiez les lignes: 229, 230. Variable.cc 229 </li><li>  V595 Le pointeur 'i_value' a été utilisé avant d'être vérifié par rapport à nullptr.  Vérifiez les lignes: 3412, 3427. Number.cc 3412 </li></ul><br><h2>  gratuit () ou supprimer []? </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V611</a> La mémoire a été allouée à l'aide de l'opérateur "nouveau" mais a été libérée à l'aide de la fonction "libre".  Pensez à inspecter les logiques d'opération derrière la variable «remcopy».  Number.cc 8123 <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Number::print(....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!exact &amp;&amp; precision2 &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(try_infinite_series) { remcopy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mpz_t</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// &lt;= mpz_init_set(*remcopy, remainder); } mpz_mul_si(remainder, remainder, base); mpz_tdiv_qr(remainder, remainder2, remainder, d); exact = (mpz_sgn(remainder2) == 0); if(!started) { started = (mpz_sgn(remainder) != 0); } if(started) { mpz_mul_si(num, num, base); mpz_add(num, num, remainder); } if(try_infinite_series) { if(started &amp;&amp; first_rem_check == 0) { remainders.push_back(remcopy); } else { if(started) first_rem_check--; mpz_clear(*remcopy); free(remcopy); // &lt;= } } .... } .... }</span></span></code> </pre> <br>  La mémoire du tableau <i>remcopy est</i> allouée et libérée de diverses manières, ce qui est une grave erreur. <br><br><h2>  Changements perdus </h2><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expand_partial_fractions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MathStructure &amp;m, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(b_poly &amp;&amp; !mquo.isZero()) { MathStructure m = mquo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!mrem.isZero()) { m += mrem; m.last() *= mtest[i]; m.childrenUpdated(); } expand_partial_fractions(m, eo, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } .... }</code> </pre> <br>  La variable <i>m est</i> acceptée dans la fonction par référence, ce qui implique sa modification.  Mais l'analyseur a constaté que le code contient la variable locale du même nom, qui chevauche la portée du paramètre de fonction, permettant la perte de modifications. <br><br><h2>  Pointeurs étranges </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V774</a> Le pointeur «cu» a été utilisé après la libération de la mémoire.  Calculator.cc 3595 <br><br><pre> <code class="cpp hljs">MathStructure Calculator::convertToBestUnit(....) { .... CompositeUnit *cu = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompositeUnit(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"...."</span></span>); cu-&gt;add(....); Unit *u = getBestUnit(cu, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, eo.local_currency_conversion); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(u == cu) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> cu; <span class="hljs-comment"><span class="hljs-comment">// &lt;= return mstruct_new; } delete cu; // &lt;= if(eo.approximation == APPROXIMATION_EXACT &amp;&amp; cu-&gt;hasApproximateRelationTo(u, true)) { // &lt;= if(!u-&gt;isRegistered()) delete u; return mstruct_new; } .... }</span></span></code> </pre> <br>  L'analyseur avertit que le code contient un appel à la méthode de l'objet <i>cu</i> après avoir libéré de la mémoire.  Mais si vous essayez de comprendre le code, ce sera encore plus étrange.  Premièrement, l'appel à <i>supprimer cu</i> se produit toujours - dans l'état et après.  Deuxièmement, le code après la condition suppose que les pointeurs <i>u</i> et <i>cu</i> ne <i>sont</i> pas égaux, donc après avoir effacé l'objet <i>cu</i> , il est logique d'utiliser l'objet <i>u</i> .  Très probablement, une faute de frappe a été faite dans le code et il était prévu d'utiliser uniquement la variable <i>u</i> . <br><br><h2>  Utilisation de la fonction de recherche </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V797</a> La fonction 'find' est utilisée comme si elle retournait un type booléen.  La valeur de retour de la fonction doit probablement être comparée à std :: string :: npos.  Unit.cc 404 <br><br><pre> <code class="cpp hljs">MathStructure &amp;AliasUnit::convertFromFirstBaseUnit(....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i_exp != <span class="hljs-number"><span class="hljs-number">1</span></span>) mexp /= i_exp; ParseOptions po; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isApproximate() &amp;&amp; suncertainty.empty() &amp;&amp; precision() == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sinverse.find(DOT) || svalue.find(DOT)) po.read_precision = READ_PRECISION_WHEN_DECIMALS; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> po.read_precision = ALWAYS_READ_PRECISION; } .... }</code> </pre> <br>  Bien que le code se compile correctement, il semble suspect car la fonction <i>find</i> renvoie un certain nombre de type <i>std :: string :: size_type</i> .  La condition sera vraie si le point se trouve n'importe où sur la ligne, sauf si le point est au début.  Ceci est un test étrange.  Je ne suis pas sûr, mais peut-être que le code devrait être réécrit comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( sinverse.find(DOT) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos || svalue.find(DOT) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { po.read_precision = READ_PRECISION_WHEN_DECIMALS; }</code> </pre> <br><h2>  Fuite potentielle de mémoire </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V701</a> realloc () fuite possible: lorsque realloc () échoue dans l'allocation de mémoire, le «tampon» du pointeur d'origine est perdu.  Pensez à affecter realloc () à un pointeur temporaire.  util.cc 703 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">utf8_strdown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> HAVE_ICU .... outlength = length + 4; buffer = (char*) realloc(buffer, outlength * sizeof(char)); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;= .... #else return NULL; #endif }</span></span></span></span></code> </pre> <br>  Lorsque vous travaillez avec la fonction <i>realloc ()</i> , il est recommandé d'utiliser un tampon intermédiaire, car s'il est impossible d'allouer de la mémoire, le pointeur vers l'ancienne mémoire sera irrémédiablement perdu. <br><br><h2>  Conclusion </h2><br>  Projet Qalculate!  en tête de liste des meilleures calculatrices gratuites, alors qu'il contient de nombreuses erreurs graves.  Mais nous n'avons pas vu ses concurrents.  Nous allons essayer de parcourir toutes les calculatrices populaires. <br><br>  Quant à la comparaison avec la qualité de la calculatrice du monde Windows, alors que l'utilitaire de Microsoft semble plus fiable et de haute qualité. <br><br>  Vérifiez votre «calculatrice» en téléchargeant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PVS-Studio</a> et en l'essayant sur votre projet.  :-) <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Si vous souhaitez partager cet article avec un public anglophone, veuillez utiliser le lien vers la traduction: Svyatoslav Razmyslov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sur les traces des calculatrices: calculez!</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443654/">https://habr.com/ru/post/fr443654/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443642/index.html">Un administrateur de la NASA estime qu'il est possible d'envoyer Orion pour le premier voyage autour de la lune sur une fusée commerciale</a></li>
<li><a href="../fr443644/index.html">Rouler les œufs avec Unity</a></li>
<li><a href="../fr443648/index.html">Documentation utilisateur: qu'est-ce qui la rend mauvaise et comment y remédier</a></li>
<li><a href="../fr443650/index.html">Pas du tout et pas de tic. Quelle est la différence entre les processeurs Intel Core de différentes générations basés sur une architecture</a></li>
<li><a href="../fr443652/index.html">Chaque jour sur Outlook j'ai juste de la farine ...</a></li>
<li><a href="../fr443656/index.html">Sur les traces des calculatrices: Qalculate</a></li>
<li><a href="../fr443658/index.html">Configuration du cluster Kubernetes HA sur du métal nu, surveillance, journaux et exemples d'utilisation. Partie 3/3</a></li>
<li><a href="../fr443660/index.html">Experts: «Un scanner 3D coûtera 10 fois moins cher qu'une erreur avec un contrôle qualité traditionnel»</a></li>
<li><a href="../fr443662/index.html">Comprendre le code propre sur Android</a></li>
<li><a href="../fr443664/index.html">Station météo Arduino</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>