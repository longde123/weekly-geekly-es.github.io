<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø üï∫üèª üåÑ Kotlin: menggali lebih dalam. Konstruktor dan Inisialisasi üëå üé° üìñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kembali pada Mei 2017, Google mengumumkan bahwa Kotlin telah menjadi bahasa pengembangan resmi untuk Android. Seseorang kemudian mendengar nama bahasa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin: menggali lebih dalam. Konstruktor dan Inisialisasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/425943/"><img src="https://habrastorage.org/webt/fy/cu/i6/fycui6wsj3p54nc1y7v5ga_hfdq.jpeg"><br><br>  Kembali pada Mei 2017, Google mengumumkan bahwa Kotlin telah menjadi bahasa pengembangan resmi untuk Android.  Seseorang kemudian mendengar nama bahasa ini untuk pertama kalinya, seseorang menulisnya untuk waktu yang lama, tetapi sejak saat itu menjadi jelas bahwa setiap orang yang dekat dengan pengembangan Android sekarang berkewajiban untuk mengetahuinya.  Ini diikuti oleh tanggapan antusias "Akhirnya!" Dan kemarahan yang mengerikan "Mengapa kita membutuhkan bahasa baru?"  Apa yang tidak disukai Java? "  dll.  dll. <br><br>  Sudah cukup waktu berlalu sejak itu, dan meskipun perdebatan tentang apakah Kotlin baik atau buruk masih belum surut, semakin banyak kode untuk Android yang tertulis di sana.  Dan bahkan pengembang yang cukup konservatif juga beralih ke sana.  Selain itu, pada jaringan Anda dapat menemukan informasi bahwa kecepatan pengembangan setelah menguasai bahasa ini meningkat 30% dibandingkan dengan Jawa. <br><br>  Hari ini, Kotlin telah berhasil pulih dari beberapa penyakit masa kanak-kanak, ditumbuhi banyak pertanyaan dan jawaban tentang Stack Overflow.  Dengan mata telanjang, baik kelebihan maupun kelemahannya menjadi terlihat. <br><br>  Dan pada gelombang ini, saya terpikir untuk menganalisis secara rinci elemen-elemen individual dari bahasa yang muda namun populer.  Perhatikan poin-poin kompleks dan bandingkan dengan Java untuk kejelasan dan pemahaman yang lebih baik.  Untuk memahami pertanyaan sedikit lebih dalam dari ini bisa dilakukan dengan membaca dokumentasi.  Jika artikel ini membangkitkan minat, maka kemungkinan besar itu akan meletakkan dasar untuk seluruh rangkaian artikel.  Sementara itu, saya akan mulai dengan hal-hal yang cukup mendasar, yang, bagaimanapun, menyembunyikan banyak jebakan.  Mari kita bicara tentang konstruktor dan inisialisasi di Kotlin. <a name="habracut"></a><br><br>  Seperti di Jawa, di Kotlin, penciptaan objek baru - entitas dari tipe tertentu - terjadi dengan memanggil konstruktor kelas.  Anda juga bisa meneruskan argumen ke konstruktor, dan mungkin ada beberapa konstruktor.  Jika Anda melihat proses ini dari luar, maka satu-satunya perbedaan dari Jawa adalah kurangnya kata kunci baru saat memanggil konstruktor.  Sekarang perhatikan lebih dalam dan lihat apa yang terjadi di dalam kelas. <br><br>  Kelas dapat memiliki konstruktor primer dan sekunder. <br>  Konstruktor dinyatakan menggunakan kata kunci konstruktor.  Jika konstruktor utama tidak memiliki pengubah akses dan anotasi, kata kunci dapat dihilangkan. <br>  Kelas mungkin tidak memiliki konstruktor yang dinyatakan secara eksplisit.  Dalam hal ini, setelah deklarasi kelas tidak ada konstruksi, kami segera melanjutkan ke tubuh kelas.  Jika kita menggambar analogi dengan Java, ini setara dengan tidak adanya deklarasi konstruktor yang eksplisit, sebagai akibatnya konstruktor default (tanpa parameter) akan dihasilkan secara otomatis pada tahap kompilasi.  Tampak seperti yang diharapkan: <br><br><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span></span></code> </pre> <br>  Ini sama dengan entri berikut: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre> <br>  Tetapi jika Anda menulis dengan cara ini, maka Anda akan dengan sopan diminta untuk menghapus konstruktor utama tanpa parameter. <br><br>  Konstruktor utama adalah salah satu yang selalu dipanggil ketika suatu objek dibuat jika ada.  Sementara kami mempertimbangkan ini, dan kami akan menganalisisnya secara lebih rinci nanti, ketika kami beralih ke konstruktor sekunder.  Dengan demikian, kita ingat bahwa jika tidak ada konstruktor sama sekali, maka sebenarnya ada satu (primer) satu, tetapi kita tidak melihatnya. <br><br>  Jika, misalnya, kami ingin konstruktor utama tanpa parameter tidak memiliki akses publik, maka bersama dengan modifikasi <code>private</code> kita perlu mendeklarasikannya secara eksplisit dengan kata kunci <code>constructor</code> . <br><br>  Fitur utama dari konstruktor utama adalah bahwa ia tidak memiliki tubuh, mis.  tidak dapat berisi kode yang dapat dieksekusi.  Ini hanya mengambil parameter ke dalam dirinya sendiri dan meneruskannya jauh ke kelas untuk digunakan di masa depan.  Pada level sintaks, tampilannya seperti ini: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(param1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, param2: Int, param3: Boolean)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ // some code }</span></span></span></span></code> </pre><br>  Parameter yang diteruskan dengan cara ini dapat digunakan untuk berbagai inisialisasi, tetapi tidak lebih.  Dalam bentuknya yang murni, kita tidak bisa menggunakan argumen ini dalam kode kerja kelas.  Namun, kita dapat menginisialisasi bidang kelas di sini.  Ini terlihat seperti ini: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val param1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> param2: Int, param3: Boolean)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ // some code }</span></span></span></span></code> </pre><br>  Di sini, <code>param1</code> dan <code>param2</code> dapat digunakan dalam kode sebagai bidang kelas, yang setara dengan yang berikut: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int, param3: Boolean)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ val param1 = p1 var param2 = p2 // some code }</span></span></span></span></code> </pre><br>  Nah, jika Anda membandingkan dengan Java, maka akan terlihat seperti ini (dan omong-omong, dalam contoh ini Anda dapat mengevaluasi seberapa banyak Kotlin dapat mengurangi jumlah kode): <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String param1; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer param2; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyClassAJava(String p1, Integer p2, <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> param3) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param1 = p1; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param2 = p2; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String getParam1() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> param1; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Integer getParam2() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> param2; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> void setParam2(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Integer param2) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param2 = param2; } <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Mari kita bicara tentang desainer tambahan.  Mereka lebih mengingatkan pada konstruktor biasa di Jawa: mereka menerima parameter, dan mungkin memiliki blok yang dapat dieksekusi.  Saat mendeklarasikan konstruktor tambahan, kata kunci konstruktor diperlukan.  Seperti disebutkan sebelumnya, terlepas dari kemungkinan membuat objek dengan memanggil konstruktor tambahan, konstruktor utama (jika ada) juga harus dipanggil dengan bantuan <code>this</code> .  Pada level sintaks, ini disusun sebagai berikut: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> p1: String) { <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1) { <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Yaitu  konstruktor tambahan adalah, seolah-olah, pewaris utama. <br>  Sekarang, jika kita membuat objek dengan memanggil konstruktor tambahan, hal berikut akan terjadi: <br><br>  memanggil konstruktor tambahan; <br>  memanggil konstruktor utama; <br>  inisialisasi bidang <code>p1</code> kelas di konstruktor utama; <br>  eksekusi kode di tubuh konstruktor tambahan. <br><br>  Ini mirip dengan konstruksi di Jawa: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String param1; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1)</span></span></span><span class="hljs-function"> </span></span>{ param1 = p1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, Boolean param3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1); <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Ingatlah bahwa di Jawa kita dapat memanggil satu konstruktor dari yang lain menggunakan <code>this</code> hanya di awal badan konstruktor.  Di Kotlin, masalah ini secara mendasar diselesaikan - mereka menjadikan panggilan semacam itu sebagai bagian dari tanda tangan konstruktor.  Untuk jaga-jaga, saya perhatikan bahwa dilarang memanggil konstruktor (primer atau tambahan) langsung dari badan yang tambahan. <br><br>  Konstruktor tambahan harus selalu merujuk ke konstruktor utama (jika ada), tetapi dapat melakukannya secara tidak langsung, merujuk pada konstruktor tambahan lainnya.  Intinya adalah bahwa pada akhir rantai kita masih sampai pada hal utama.  Pemicu konstruktor jelas akan terjadi dalam urutan terbalik dari perancang yang berpaling satu sama lain: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA(p1: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>) <span class="hljs-comment"><span class="hljs-comment">{ constructor(p1: String, p2: Int, p3: Boolean) : this(p1) { // some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int, p3: Boolean, p4: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> :</span></span> this(p1, p2, p3) <span class="hljs-comment"><span class="hljs-comment">{ // some code }</span></span> <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Sekarang urutannya adalah: <br><br><ul><li>  memanggil konstruktor tambahan dengan 4 parameter; </li><li>  memanggil konstruktor tambahan dengan 3 parameter; </li><li>  memanggil konstruktor utama; </li><li>  inisialisasi bidang p1 kelas di konstruktor utama; </li><li>  eksekusi kode di tubuh konstruktor dengan 3 parameter; </li><li>  eksekusi kode dalam tubuh konstruktor dengan 4 parameter. </li></ul><br>  Bagaimanapun, kompiler tidak akan pernah membiarkan kita lupa untuk sampai ke konstruktor utama. <br><br>  Itu terjadi bahwa kelas tidak memiliki konstruktor utama, sementara itu mungkin memiliki satu atau lebih tambahan.  Kemudian konstruktor tambahan tidak diperlukan untuk merujuk ke seseorang, tetapi mereka juga dapat merujuk ke konstruktor tambahan lain dari kelas ini.  Sebelumnya, kami menemukan bahwa konstruktor utama, tidak ditentukan secara eksplisit, secara otomatis dihasilkan, tetapi ini berlaku untuk kasus ketika tidak ada konstruktor sama sekali di dalam kelas.  Jika ada setidaknya satu konstruktor tambahan, konstruktor utama tanpa parameter tidak dibuat: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Kita dapat membuat objek kelas dengan memanggil: <br><br><pre> <code class="hljs lisp">val myClassA = MyClassA()</code> </pre> <br>  Dalam hal ini: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Kami hanya dapat membuat objek dengan panggilan ini: <br><br><pre> <code class="hljs pgsql">val myClassA = MyClassA(‚Äú<span class="hljs-keyword"><span class="hljs-keyword">some</span></span> string‚Äù, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br>  Tidak ada yang baru di Kotlin dibandingkan dengan Jawa. <br><br>  Omong-omong, seperti konstruktor utama, konstruktor tambahan mungkin tidak memiliki badan jika tugasnya hanya meneruskan parameter ke konstruktor lain. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1, p2, p3, <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>, p4: String) { <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Penting juga memperhatikan fakta bahwa, tidak seperti konstruktor utama, inisialisasi bidang kelas dalam daftar argumen konstruktor tambahan dilarang. <br>  Yaitu  catatan seperti itu tidak valid: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> p1: String, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>){ <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Secara terpisah, perlu dicatat bahwa konstruktor tambahan, seperti yang primer, mungkin tanpa parameter: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Berbicara tentang konstruktor, orang tidak bisa tidak menyebutkan salah satu fitur nyaman Kotlin - kemampuan untuk menetapkan nilai default untuk argumen. <br><br>  Sekarang anggaplah kita memiliki kelas dengan beberapa konstruktor yang memiliki jumlah argumen yang berbeda.  Saya akan memberikan contoh di Jawa: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String param1; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer param2; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> param3; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> param4; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> (p1, <span class="hljs-number"><span class="hljs-number">5</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> (p1, p2, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1, p2, p3, <span class="hljs-number"><span class="hljs-number">20</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param1 = p1; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param2 = p2; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param3 = p3; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param4 = p4; } <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Seperti yang ditunjukkan dalam praktik, desain semacam itu sangat umum.  Mari kita lihat bagaimana hal yang sama dapat ditulis di Kotlin: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p1: String, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p4: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">20</span></span>){ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Sekarang, mari kita menepuk-nepuk Kotlin untuk berapa banyak dia memotong kode.  Omong-omong, selain mengurangi jumlah garis, kami mendapat lebih banyak pesanan.  Ingat, Anda harus melihat sesuatu seperti ini lebih dari sekali: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p3, p1, p2, <span class="hljs-number"><span class="hljs-number">20</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p1, String p2, Integer p3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Ketika Anda melihat ini, Anda ingin menemukan orang yang menulisnya, mengambilnya dengan tombol, membawanya ke layar dan bertanya dengan suara sedih: "Mengapa?" <br>  Meskipun Anda dapat mengulangi prestasi ini di Kotlin, tetapi tidak perlu. <br><br>  Namun, ada satu detail yang, dalam kasus notasi singkat tentang Kotlin, perlu dipertimbangkan: jika kita ingin memanggil konstruktor dengan nilai default dari Java, maka kita harus menambahkan anotasi <b><code>@JvmOverloads</code></b> ke dalamnya: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA @JvmOverloads <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p2: Int = 5, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3: Boolean = true, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p4: Int = 20)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ // some code }</span></span></span></span></code> </pre><br>  Kalau tidak, kami mendapatkan kesalahan. <br><br>  Sekarang mari kita bicara <b>tentang inisialisasi</b> . <br><br>  Inisialisasi adalah blok kode yang ditandai dengan kata kunci <code>init</code> .  Di blok ini, Anda bisa melakukan beberapa logika untuk menginisialisasi elemen-elemen kelas, termasuk menggunakan nilai-nilai argumen yang datang di konstruktor utama.  Kami juga dapat memanggil fungsi dari blok ini. <br><br>  Java juga memiliki blok inisialisasi, tetapi ini bukan hal yang sama.  Di dalamnya, kita tidak bisa, seperti di Kotlin, memberikan nilai dari luar (argumen konstruktor utama).  Penginisialisasi sangat mirip dengan badan konstruktor utama, diambil dalam blok terpisah.  Tapi itu pada pandangan pertama.  Sebenarnya, ini tidak sepenuhnya benar.  Mari kita perbaiki. <br><br>  Inisialisasi juga dapat ada ketika tidak ada konstruktor utama.  Jika demikian, maka kodenya, seperti semua proses inisialisasi, dijalankan sebelum kode konstruktor tambahan.  Mungkin ada lebih dari satu penginisialisasi.  Dalam hal ini, urutan panggilan mereka akan sesuai dengan urutan lokasi mereka dalam kode.  Perhatikan juga bahwa inisialisasi bidang kelas dapat terjadi di luar blok <code>init</code> .  Dalam hal ini, inisialisasi juga terjadi sesuai dengan susunan elemen dalam kode, dan ini harus diperhitungkan ketika memanggil metode dari blok initializer.  Jika Anda menerimanya dengan sembarangan, maka ada kemungkinan terjadi kesalahan. <br><br>  Saya akan memberi Anda beberapa kasus menarik bekerja dengan inisialisasi. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"some string"</span></span> showTestParam() } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"new string"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> testParam: String = <span class="hljs-string"><span class="hljs-string">"after"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in constructor testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showTestParam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in showTestParam testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } }</code> </pre><br>  Kode ini cukup valid, meskipun tidak terlalu jelas.  Jika Anda melihat, Anda bisa melihat bahwa penetapan nilai ke bidang <code>testParam</code> di blok initializer terjadi sebelum parameter dideklarasikan.  Omong-omong, ini hanya berfungsi jika kita memiliki konstruktor tambahan di kelas, tetapi tidak memiliki yang utama (jika kita menaikkan deklarasi bidang <code>testParam</code> atas blok <code>init</code> , ia akan bekerja tanpa konstruktor).  Jika kami mendekompilasi kode byte kelas ini di Java, kami mendapatkan yang berikut: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String testParam = <span class="hljs-string"><span class="hljs-string">"some string"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String getTestParam() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> void setTestParam(<span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> String var1) { Intrinsics.checkParameterIsNotNull(var1, <span class="hljs-string"><span class="hljs-string">"&lt;set-?&gt;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam = var1; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> void showTestParam() { Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in showTestParam testParam = "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyClassB() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showTestParam(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam = <span class="hljs-string"><span class="hljs-string">"new string"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam = <span class="hljs-string"><span class="hljs-string">"after"</span></span>; Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in constructor testParam = "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam); } }</code> </pre><br>  Di sini kita melihat bahwa panggilan pertama ke lapangan selama inisialisasi (di blok <code>init</code> atau di luarnya) setara dengan inisialisasi biasa di Jawa.  Semua tindakan lain yang terkait dengan penugasan nilai selama proses inisialisasi, kecuali untuk yang pertama (penugasan pertama nilai dikombinasikan dengan deklarasi lapangan), ditransfer ke konstruktor. <br>  Jika kita melakukan percobaan dengan dekompilasi, ternyata jika tidak ada konstruktor, maka konstruktor utama dihasilkan, dan semua keajaiban terjadi di dalamnya.  Jika ada beberapa konstruktor tambahan yang tidak saling merujuk, dan tidak ada yang utama, maka dalam kode Java kelas ini semua penugasan selanjutnya dari nilai ke bidang <code>testParam</code> diduplikasi di semua konstruktor tambahan.  Jika ada konstruktor utama, maka hanya di primer.  Fuf ... <br><br>  Dan hal yang paling menarik sebagai <code>testParam</code> : <code>testParam</code> ubah tanda tangan <code>testParam</code> dari <code>var</code> ke <code>val</code> : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"some string"</span></span> showTestParam() } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"new string"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testParam: String = <span class="hljs-string"><span class="hljs-string">"after"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in constructor testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showTestParam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in showTestParam testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } }</code> </pre><br>  Dan di suatu tempat dalam kode yang kita sebut: <br><br><pre> <code class="hljs cs">MyClassB myClassB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyClassB();</code> </pre><br>  Semuanya dikompilasi tanpa kesalahan, dimulai, dan sekarang kita melihat output dari log: <br><br>  di showTestParam testParam = beberapa string <br>  dalam konstruktor testParam = setelah <br><br>  Ternyata bidang yang dinyatakan sebagai <code>val</code> mengubah nilai selama eksekusi kode.  Kenapa begitu  Saya pikir ini adalah cacat pada kompiler Kotlin, dan di masa depan, mungkin ini tidak akan dikompilasi, tetapi hari ini semuanya seperti itu. <br><br>  Menarik kesimpulan dari kasus-kasus di atas, seseorang hanya dapat menyarankan untuk tidak menghasilkan blok inisialisasi dan tidak menyebarkan mereka di seluruh kelas, untuk menghindari penugasan nilai yang berulang selama proses inisialisasi, untuk memanggil hanya fungsi murni dari blok init.  Semua ini dilakukan untuk menghindari kemungkinan kebingungan. <br><br>  Jadi  <b>Inisialisasi adalah blok kode tertentu yang harus dijalankan ketika membuat objek, terlepas dari konstruktor mana objek ini dibuat.</b> <br><br>  Tampaknya beres.  Pertimbangkan interaksi konstruktor dan inisialisasi.  Dalam satu kelas, semuanya cukup sederhana, tetapi Anda harus ingat: <br><br><ul><li>  memanggil konstruktor tambahan; </li><li>  memanggil konstruktor utama; </li><li>  inisialisasi bidang kelas dan blok penginisialisasi dalam urutan lokasi mereka dalam kode; </li><li>  eksekusi kode di tubuh konstruktor tambahan. </li></ul><br>  Kasing dengan pewarisan terlihat lebih menarik. <br><br>  Perlu dicatat bahwa Object adalah basis untuk semua kelas di Jawa, jadi Any ada di Kotlin.  Namun, Any dan Object bukan hal yang sama. <br><br>  Untuk memulai tentang cara kerja warisan.  Kelas turunan, seperti kelas induk, mungkin atau mungkin tidak memiliki konstruktor utama, tetapi harus merujuk ke konstruktor spesifik dari kelas induk. <br><br>  Jika kelas turunan memiliki konstruktor utama, maka konstruktor ini harus menunjuk ke konstruktor spesifik dari kelas dasar.  Dalam hal ini, semua konstruktor tambahan dari kelas penerus harus merujuk ke konstruktor utama kelas mereka. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyClassC</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyClassA</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">) { constructor(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p2</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">): this(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">) { //some code } //some code }</span></span></code> </pre><br>  Jika kelas turunan tidak memiliki konstruktor utama, masing-masing konstruktor tambahan harus mengakses konstruktor dari kelas induk menggunakan kata kunci <code>super</code> .  Dalam hal ini, konstruktor tambahan yang berbeda dari kelas penerus dapat mengakses konstruktor yang berbeda dari kelas induk: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassC : MyClassA <span class="hljs-comment"><span class="hljs-comment">{ constructor(p1: String): super(p1) { //some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int)</span></span></span><span class="hljs-function">:</span></span> super(p1, p2) <span class="hljs-comment"><span class="hljs-comment">{ //some code }</span></span> <span class="hljs-comment"><span class="hljs-comment">//some code }</span></span></code> </pre><br>  Juga, jangan lupa tentang kemungkinan memanggil konstruktor kelas induk secara tidak langsung melalui konstruktor lain dari kelas turunan: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassC : MyClassA<span class="hljs-comment"><span class="hljs-comment">{ constructor(p1: String): super(p1){ //some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int)</span></span></span><span class="hljs-function">:</span></span> this (p1)<span class="hljs-comment"><span class="hljs-comment">{ //some code }</span></span> <span class="hljs-comment"><span class="hljs-comment">//some code }</span></span></code> </pre><br>  Jika kelas turunan tidak memiliki konstruktor, maka kita cukup menambahkan panggilan konstruktor dari kelas induk setelah nama kelas turunan: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassC</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyClassA</span></span></span></span>(‚Äúsome string‚Äù) { <span class="hljs-comment"><span class="hljs-comment">//some code }</span></span></code> </pre><br>  Namun, masih ada opsi dengan pewarisan, di mana referensi ke konstruktor dari kelas induk tidak diperlukan.  Catatan seperti itu valid: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassC : MyClassB <span class="hljs-comment"><span class="hljs-comment">{ constructor(){ //some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ }</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//some code }</span></span></span></span></code> </pre><br>  Tetapi hanya jika kelas induk memiliki konstruktor tanpa parameter, yang merupakan konstruktor default (primer atau opsional - tidak masalah). <br><br>  Sekarang pertimbangkan urutan permohonan inisialisasi dan konstruktor selama pewarisan: <br><br><ul><li>  panggil konstruktor tambahan ahli waris; </li><li>  sebut konstruktor utama pewaris; </li><li>  memanggil konstruktor tambahan dari induk; </li><li>  hubungi konstruktor utama orang tua; </li><li>  <code>init</code> blok <code>init</code> induk </li><li>  pelaksanaan kode tubuh dari konstruktor tambahan dari induk; </li><li>  eksekusi blok ahli waris; </li><li>  pelaksanaan kode tubuh dari konstruktor tambahan ahli waris </li></ul><br>  Mari kita bicara tentang perbandingan dengan Java, di mana, pada kenyataannya, tidak ada analog dari konstruktor utama dari Kotlin.  Di Jawa, semua konstruktor adalah rekan dan dapat dipanggil atau tidak dipanggil dari satu sama lain.  Di Jawa dan Kotlin ada konstruktor default, itu adalah konstruktor tanpa parameter, tetapi memperoleh status khusus hanya ketika mewarisi.  Di sini perlu diperhatikan hal-hal berikut: ketika mewarisi di Kotlin, kita harus secara eksplisit memberi tahu kelas penerus yang mana konstruktor dari kelas induk untuk digunakan - kompilator tidak akan membiarkan kita melupakannya.  Di Jawa, kami tidak dapat menunjukkan ini secara eksplisit.  Hati-hati: dalam hal ini, konstruktor default dari kelas induk akan dipanggil (jika ada). <br><br>  Pada tahap ini, kita akan mengasumsikan bahwa kita mempelajari desainer dan inisialisasi dengan cukup dalam dan sekarang kita tahu hampir semua tentang mereka.  Kami akan beristirahat sedikit dan menggali ke arah lain! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425943/">https://habr.com/ru/post/id425943/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425931/index.html">"Saya ingin meninggalkan pabrik di web" - 10 pertanyaan kepada programmer, edisi ke-8</a></li>
<li><a href="../id425933/index.html">Kelembaban di pusat data: mengapa itu penting</a></li>
<li><a href="../id425935/index.html">Penangguhan unit sistem di bawah tabel berdiri</a></li>
<li><a href="../id425937/index.html">CoreBluetooth dalam praktiknya</a></li>
<li><a href="../id425939/index.html">DataIncrement - tambahan untuk fitur phpMyAdmin</a></li>
<li><a href="../id425945/index.html">Kiat untuk penggunaan profesional RecyclerView. Bagian 1</a></li>
<li><a href="../id425947/index.html">Corporate Ratatouille</a></li>
<li><a href="../id425951/index.html">Cara meretas blockchain dan cryptocurrency: 6 serangan sukses ‚Äú51 persen‚Äù</a></li>
<li><a href="../id425953/index.html">Stasiun cuaca di Arduino dari A hingga Z. Bagian 3</a></li>
<li><a href="../id425955/index.html">8 bug iOS 12 beta yang menarik dan bagaimana kami mencarinya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>