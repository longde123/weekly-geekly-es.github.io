<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì¢ üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø ü§® N√≥s programamos o interruptor atrav√©s da passagem. MicroPython em esp8266 (sonoff) com OTA. Parte 1 ü§ò üíà üë©üèº‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal. 


 No processo de reparo, surgiu a tarefa de fazer uma troca de passagem. Obviamente, eu queria faz√™-lo da maneira mais simples e conven...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>N√≥s programamos o interruptor atrav√©s da passagem. MicroPython em esp8266 (sonoff) com OTA. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438624/"><p>  Ol√° pessoal. </p><br><p>  No processo de reparo, surgiu a tarefa de fazer uma troca de passagem.  Obviamente, eu queria faz√™-lo da maneira mais simples e conveniente, adicionando fun√ß√µes b√°sicas de controle do telefone.  Eu escolhi a tecnologia mais simples e conveniente para isso (√© claro, na minha opini√£o) - MicroPython, e comecei a faz√™-lo.  Peguei a placa final no esp8266 e aloquei uma hora de tempo livre para isso.  Mas, como acontece com projetos n√£o muito populares e n√£o executados, a tarefa se arrastou um pouco. </p><br><p>  Como se viu, o design que achei mais conveniente, n√£o funciona.  Eu tive que gastar algum tempo analisando isso, al√©m disso, decidi descrever todo o processo com detalhes suficientes.  O volume do artigo come√ßou a aumentar rapidamente, ent√£o decidi dividi-lo em partes e jogar fora todos os detalhes desnecess√°rios na minha opini√£o. </p><a name="habracut"></a><br><p>  A primeira parte consiste em tr√™s partes: </p><br><ol><li>  Considera√ß√µes te√≥ricas sobre a sele√ß√£o do meio mais simples para o desenvolvimento de uma chave de passagem, </li><li>  Lan√ßamento pr√°tico do firmware b√°sico selecionado no equipamento selecionado, armadilhas, </li><li>  Desenvolvimento de Firmware </li></ol><br><h1>  Escolhendo o ambiente de desenvolvimento mais f√°cil </h1><br><p>  Para uma casa inteligente como ‚Äúfa√ßa voc√™ mesmo se tiver um minuto de tempo livre‚Äù, al√©m dos itens cl√°ssicos (por exemplo, estabilidade), a lista de requisitos obrigat√≥rios de equipamentos tamb√©m adiciona facilidade de desenvolvimento, instala√ß√£o e suporte.  Os dispositivos s√£o necess√°rios para conectar facilmente os sensores ou dispositivos de controle necess√°rios a eles.  Que havia maneiras f√°ceis e convenientes de se comunicar com todo o sistema.  √â necess√°rio garantir a facilidade de escrever firmware neste dispositivo, levando em considera√ß√£o que o dispositivo pode estar localizado onde ser√° dif√≠cil acess√°-lo.  E, claro, a facilidade de desenvolvimento, isso √© especialmente cr√≠tico para DIY, quando, por exemplo, 2 anos depois de trabalhar sem falhas de todo o sistema <br>  de repente, quero adicionar alguns ajustes ao firmware.  Para fazer essas corre√ß√µes, voc√™ precisa se lembrar de como esse sistema funciona, que √†s vezes pode levar mais tempo que o pr√≥prio ajuste. </p><br><p>  Considere um exemplo banal: voc√™ precisa fazer uma troca simples com a capacidade de control√°-la, inclusive de um PC.  Nos √∫ltimos tempos, essa tarefa era bastante complicada, era necess√°rio usar algum tipo de microcontrolador (os mais populares eram avr ou pic) e escrever firmware, como regra, √© necess√°rio ler a documenta√ß√£o.  Se voc√™ quiser fazer tudo imediatamente, precisar√° criar uma placa onde colocar AC / DC, um microcontrolador e uma interface de comunica√ß√£o.  Ap√≥s LUT (ou pedir placas de circuito impresso), solde tudo, compre um programador e firmware flash.  Depois de 2-3 anos, se necess√°rio, para consertar alguma coisa, procure todo o equipamento e aprenda tudo do zero ... </p><br><p>  Para simplificar esse processo, solu√ß√µes prontas come√ßaram a aparecer no mercado.  A solu√ß√£o mais bem-sucedida √© o Arduino.  Esta solu√ß√£o √© fornecida pelo IDE, o gerenciador de inicializa√ß√£o com a fun√ß√£o de atualiza√ß√£o, que permite trabalhar com o dispositivo exclusivamente atrav√©s da interface padr√£o sem o uso de programadores.  Torna poss√≠vel fazer firmware, tendo apenas <br>  uma compreens√£o muito superficial de como tudo est√° organizado l√°.  Um conjunto de m√≥dulos externos permite conectar dispositivos sem um ferro de soldar.  De qualquer maneira, para fazer edi√ß√µes, voc√™ precisa instalar o software Arduino, armazenar o firmware em algum lugar. </p><br><p>  Nosso comutador passar√° a ser grande o suficiente, conter√° uma placa Arduino + m√≥dulo de rel√© AC / DC +.  E se voc√™ precisar fazer ajustes, precisar√° se lembrar dolorosamente de onde est√° o c√≥digo e instalar novamente o software Arduino. </p><br><p>  Para poupar a necessidade de compilar o c√≥digo fonte (ou seja, instalar software adicional e armazen√°-lo), a solu√ß√£o mais l√≥gica parece ser usar int√©rpretes ou compilar diretamente o c√≥digo no pr√≥prio microcontrolador.  Felizmente, surgiram projetos que permitem que isso seja feito.  Por exemplo, NodeMCU, o interpretador de idioma lua para o microcontrolador esp8266: o pr√≥prio firmware possui suporte interno para o sistema de arquivos, o que permite carregar / ler scripts para / do dispositivo.  Outro projeto bastante s√©rio √© o Micropython, uma vers√£o simplificada do python que √© especificamente projetada para microcontroladores.  Ser√° discutido. </p><br><p>  O MicroPython √© uma implementa√ß√£o de uma das linguagens de programa√ß√£o python mais populares da atualidade.  Ele suporta um grande n√∫mero de arquiteturas e SoC (bare-arm, CC3200, esp8266, esp32, nRF, pic16bit, stm32).  O projeto est√° em desenvolvimento ativo e possui um grande n√∫mero de m√≥dulos adicionais. </p><br><p>  O microprocessador esp8266 √© muito adequado como pe√ßa de hardware, devido ao fato de os m√≥dulos de switch wifi or√ßamento constru√≠dos nele serem vendidos no mercado.  Eles cont√™m tudo o que precisamos: AC / DC, um microcontrolador com uma interface de comunica√ß√£o interna (wifi).  Dispon√≠vel sob a marca Sonoff.  Os microprocessadores esp8266 n√£o cont√™m mem√≥ria, s√£o soldados separadamente e podem ter um tamanho diferente.  Para o Sonoff Basic, eles colocam m√≥dulos de 1Mb. </p><br><h1>  Iniciando o firmware b√°sico no esp8266.  Sonoff Basic. </h1><br><p>  Na aus√™ncia de armadilhas, seria poss√≠vel prosseguir imediatamente para a programa√ß√£o em python.  Infelizmente, por√©m, h√° v√°rios problemas que precisam ser resolvidos. Para programar e modificar o firmware, era muito f√°cil e simples.  Obviamente, estamos interessados ‚Äã‚Äãem fazer isso via wifi, sem usar dispositivos adicionais, exceto um laptop. </p><br><p>  A primeira armadilha, √© claro, √© o firmware b√°sico que est√° registrado em sua placa.  Se voc√™ comprou uma placa de depura√ß√£o, provavelmente encontrar√° o NodeMCU nela, se Sonoff Basic, em seguida, firmware propriet√°rio.  Para preparar esta placa para si mesmo, voc√™ precisa anotar o firmware necess√°rio l√°.  Em alguns microcontroladores, √© necess√°rio comprar <br>  um programador especial, no nosso caso, tivemos sorte, voc√™ s√≥ precisa obter um conversor USB &lt;-&gt; UART.  Se voc√™ trabalha com microcontroladores, ele ser√° √∫til mais de uma vez, e o pre√ßo geralmente est√° na faixa de US $ 3. </p><br><p>  N√£o existe um pente para o Sonoff Basic que permita a conex√£o via UART, e precisamos disso para programar o dispositivo.  Para programar simplesmente o dispositivo, n√£o √© necess√°rio pegar o ferro de soldar nas m√£os, basta inclinar os contatos e anotar o firmware.  Considerando que o trabalho adicional ser√° via wifi, n√£o precisaremos mais desses contatos.  Mas implementamos um interruptor na passagem, o que significa que precisamos de solda, <br>  pelo menos tr√™s pernas. </p><br><p>  Para o Sonoff Basic, h√° apenas 1 conector GPIO gratuito e 2 conectores RX, TX.  Considerando que precisamos do RX, TX uma vez (para atualizar o firmware), no futuro eles poder√£o ser reprogramados para GPIO, gra√ßas ao esp8266 isso pode ser feito.  Mas, neste caso, precisamos abandonar a depura√ß√£o via UART, felizmente j√° planejamos fazer isso, pois a depura√ß√£o via wifi, do ponto de vista da conveni√™ncia, √© muito mais simples. </p><br><p>  Como a vers√£o do MicroPython pode mudar no processo, estamos interessados ‚Äã‚Äãem depurar o m√©todo de atualiza√ß√£o via wifi.  OTA vem em socorro.  OTA √© um firmware que permite reprogramar um dispositivo.  Funciona simplesmente.  Depois de ligar o dispositivo, o firmware determina se ele precisa ser reprogramado, se necess√°rio, inicia um <br>  O atualizador wifi, se n√£o, inicia o firmware do usu√°rio.  A implementa√ß√£o pode ser diferente, o firmware pode sobrescrever-se ou gravar em uma √°rea livre de mem√≥ria.  Voc√™ tamb√©m pode determinar se deseja executar o programa de c√≥pia de maneiras diferentes.  Por exemplo, considere o cxumma do firmware personalizado se ele n√£o convergir, <br>  ent√£o for√ßosamente v√° para o piscar.  Voc√™ pode ler dados do GPIO ou gravar informa√ß√µes sobre a necessidade de iniciar a atualiza√ß√£o em outro lugar. </p><br><p>  Como um atualizador, o projeto MicroPython refere-se ao projeto yaota8266.  Yaota8266 afirma estar piscando o dispositivo e assinando cada pacote.  Deve-se notar que a chave p√∫blica est√° incorporada no pr√≥prio firmware, e √© por isso que n√£o faz sentido fazer o upload do firmware j√° montado, pois √© necess√°rio costurar sua chave l√°. <br>  N√£o h√° fun√ß√£o para modificar a chave privada na imagem montada; portanto, no nosso caso, √© mais f√°cil montar o firmware voc√™ mesmo.  Uma caracter√≠stica interessante √© que a fun√ß√£o de verifica√ß√£o de assinatura √©, mas √© comentada no c√≥digo, ou seja,  de fato, temos dificuldades sem ganhos de seguran√ßa.  A vers√£o b√°sica do yaota8266 n√£o vai, <br>  Felizmente, existem garfos no github que resolvem esse problema, al√©m de adicionar a capacidade de determinar se o flash deve ser feito com base na grava√ß√£o na √°rea RTC, o que torna poss√≠vel alternar o MicroPython para o modo de carregador de inicializa√ß√£o. </p><br><p>  Mesmo depois de incluir todas as corre√ß√µes, nosso firmware OTA gravar√° com erros, mas funcionar√° com √™xito nas placas de depura√ß√£o do NodeMCU.  Isso ocorre devido a tempos limite.  Ao atualizar a partir da m√°quina host, os pacotes UDP s√£o enviados e √© esperada uma resposta se a grava√ß√£o no flash demorar mais que o normal, ocorrer o tempo limite e o pacote for enviado novamente.  O benef√≠cio √© f√°cil de corrigir, <br>  apenas aumentando os tempos limite no c√≥digo ota-client. </p><br><p>  O pacote OTA + MicroPython no Sonoff tamb√©m tem curiosidades interessantes.  Uma delas est√° relacionada ao fato de que as fun√ß√µes padr√£o para trabalhar com o SPI Flash no esp-sdk operam em blocos de 4k e esse tamanho de bloco foi escolhido para implementar o sistema de arquivos FAT.  Por sua vez, devido ao fato de o SPI Flash ser de apenas 1Mb, dos quais ~ 300Kb √© firmware OTA, ~ 500Kb √© firmware MicroPython, menos de 200Kb permanecem no sistema de arquivos, ou seja,  menos de 50 blocos.  No entanto, a biblioteca selecionada que implementa o fatfs n√£o pode criar FS onde h√° menos de 50 blocos.Existem v√°rias maneiras de resolver o problema: reduza o tamanho do bloco (o FAT permite definir 512), corrija a biblioteca FatFs, use o SPI FS (esperando que n√£o exista essa esquisitice).  Peguei o caminho de reduzir o bloco para 512. </p><br><p>  Microcontroladores usam SPI Flash - essa √© a mem√≥ria NOR e / ou NAND.  A notabilidade dessa mem√≥ria √© que n√£o h√° conceito de "escrever dados".  Voc√™ s√≥ pode redefinir o valor (em 0xff) ou definir os bits desejados para "0".  O SPI Flash geralmente √© uma mem√≥ria NOR, tem a fun√ß√£o de redefinir qualquer byte para 0xff, enquanto o NAND pode ser redefinido apenas por blocos.  I.e.  se o tamanho m√≠nimo do bloco de redefini√ß√£o for 4k, para escrever <br>  1 byte de mem√≥ria, √© necess√°rio ler o bloco inteiro, redefini-lo para 0xFF e depois gravar o bloco, definindo o byte desejado no valor desejado.  Os fabricantes do SPI Flash t√™m aproximadamente o mesmo conjunto de APIs para o trabalho, mas, como a pr√°tica demonstrou, o comando para gravar um byte do SPI Flash pode ser diferente.  Em algum lugar, ele ser√° redefinido automaticamente antes de gravar em 0xFF, em outro lugar. </p><br><p>  Se voc√™ alterar a se√ß√£o FAT para 512 bytes, h√° uma chance de obter um sistema danificado se um SPI Flash espec√≠fico n√£o suportar redefini√ß√£o autom√°tica de bytes durante a grava√ß√£o.  E foi exatamente essa lembran√ßa que me deparei no Sonoff Basic.  H√° rumores de que eles costumavam instalar o Winbond 25q80bv l√°, mas agora o PUYA 25q80h, que possui um bloco de limpeza m√≠nimo de 256 bytes.  Solu√ß√£o parece <br>  simples, voc√™ s√≥ precisa apagar duas p√°ginas onde ser√° gravado antes de escrever o bloco FAT, mas a implementa√ß√£o √© complicada pelo fato de o sdk-esp suportar apenas a exclus√£o em blocos de 4k.  Como escrever para o FAT ser√° muito raro para nossa troca, <br>  somente ao atualizar os scripts de firmware, voc√™ pode seguir o caminho errado e atualizar o bloco de 512 bytes em blocos de 4k.  A documenta√ß√£o desta mem√≥ria diz que a mem√≥ria pode suportar 100.000 ciclos de reescrita, ou seja,  uma evas√£o semelhante do problema nos reduzir√° esse valor em 4 vezes, ou seja,  at√© 25.000. </p><br><p>  O MicroPython possui um console por padr√£o, √© chamado REPL e funciona atrav√©s da porta COM.  N√£o estamos muito felizes com esse estado de coisas, pois queremos nos comunicar com o dispositivo via wifi.  Felizmente no MicroPython, o WebRepl tamb√©m √© padr√£o, mas n√£o √© iniciado automaticamente.  Voc√™ pode registrar a execu√ß√£o autom√°tica no boot.py, mas decidi execut√°-lo diretamente do _boot.py, o arquivo do sistema, que √© costurado no pr√≥prio arquivo de firmware. </p><br><p>  Ap√≥s a primeira inicializa√ß√£o, nosso firmware criar√° um sistema de arquivos, iniciar√° o webrepl e criar√° um ponto de acesso.  Voc√™ pode conectar-se a ele e prescrever os par√¢metros para conectar-se √† sua rede local ou, como eu fiz, configurar a rede usando a porta com, ap√≥s a qual somente o wifi deve ser usado. </p><br><p>  Para trabalhos de avalia√ß√£o, voc√™ pode usar o cliente webrepl escrito em javascript.  O cliente pode ser iniciado em um navegador na p√°gina correspondente do projeto.  Outra op√ß√£o √© usar o projeto mpfshell, pois fornece fun√ß√µes mais convenientes para trabalhar com o dispositivo. </p><br><p>  Portanto, depois de superar todas essas armadilhas, voc√™ pode ir diretamente para a programa√ß√£o do switch. </p><br><h1>  Desenvolvimento de Firmware </h1><br><p>  Para desenvolver o firmware, precisamos ter uma id√©ia aproximada de como o GPIO funciona.  Em geral, isso pode ser entendido puramente intuitivamente: </p><br><ol><li>  Se definirmos o modo de sa√≠da (OUT), a perna produzir√° GND ou Vcc. </li><li>  Se definirmos o modo de entrada (IN), a perna "oscila no ar"; nesse caso, o microcontrolador pode emitir qualquer coisa </li><li>  Para que o microcontrolador n√£o produza nada, a perna pode ser puxada para o valor desejado usando o microcontrolador embutido <br>  resistores de pull-up PULL_UP ou PULL_DOWN. </li></ol><br><p>  Voc√™ tamb√©m precisa ter uma id√©ia do que s√£o interrup√ß√µes: no nosso caso, este √© o c√≥digo que precisa ser executado se ocorrer algum tipo de evento: um bot√£o foi pressionado / liberado ou uma mensagem veio da rede local de que o dispositivo deve ser desligado / ligado. </p><br><p>  Para come√ßar, vamos escrever um programa simples de switch (n√£o de passagem) em Python. </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> machine <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Pin <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SW</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, portin, portout)</span></span></span><span class="hljs-function">:</span></span> self.pin = Pin(portin , Pin.PULL_UP) <span class="hljs-comment"><span class="hljs-comment">#  self.pout = Pin(portout, Pin.OUT) #  #  self._auto(),       self.pin.irq(trigger=Pin.IRQ_RISING|Pin.IRQ_FALLING, handler=self._auto) self.value = 0 def _auto(self, _=0): if self.value: res = self.pin.value() else: res = not self.pin.value() self.pout.value(res) def change(self, val=2): """   0, ,  1, ,  2  """ if val == 2: self.value = not self.value else: self.value = val self._auto() sw = SW(14, 12)</span></span></code> </pre> <br><p>  Eu nomeei esse arquivo switch.py ‚Äã‚Äãe pedi que ele fosse executado no boot.py: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> switch <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sw</code> </pre> <br><p>  Ap√≥s iniciar o firmware, obtive um objeto sw; se eu executar sw.change (), ocorrer√° uma troca de programa. <br>  mudar para outra posi√ß√£o.  Quando um pino livre est√° em curto para Vcc no microcontrolador <br>  o rel√© liga ou desliga, respectivamente. </p><br><p>  O pr√≥ximo passo ser√° o lan√ßamento do cliente MQTT e a capacidade de alternar o comutador do telefone. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt438624/">https://habr.com/ru/post/pt438624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt438610/index.html">Templates Figma responsivos: Criando um componente de design flex√≠vel para navega√ß√£o m√≥vel iOS</a></li>
<li><a href="../pt438614/index.html">O que √© uma anima√ß√£o ociosa de qualidade? Os desenvolvedores compartilham seus exemplos favoritos.</a></li>
<li><a href="../pt438618/index.html">Fazendo um projetor a laser de texto DIY</a></li>
<li><a href="../pt438620/index.html">Meu caminho como desenvolvedor de jogos iniciante</a></li>
<li><a href="../pt438622/index.html">Bonsai: mecanismo wiki da fam√≠lia</a></li>
<li><a href="../pt438626/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel # 284 (28 de janeiro a 3 de fevereiro)</a></li>
<li><a href="../pt438628/index.html">Notifica√ß√£o de status de altera√ß√£o do componente SharedState</a></li>
<li><a href="../pt438630/index.html">Google+ Sic tr√¢nsito gloria mundi ...</a></li>
<li><a href="../pt438632/index.html">Hardcore 2D RPG Gamedev Diaries, vol.0 - INTRO, ou "Como eu cheguei aqui"</a></li>
<li><a href="../pt438634/index.html">Nos escrit√≥rios, √© muito quente ou muito frio: existe uma maneira melhor de ajustar a temperatura?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>