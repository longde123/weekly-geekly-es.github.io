<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üà¥ üê≠ üôèüèº EFORTH f√ºr MK-161: Datenstrukturen üèΩ üë®üèø‚Äçü§ù‚Äçüë®üèª üéÖüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel ist das Ende einer Reihe von eForth-Artikeln auf einem programmierbaren Taschenrechner. Beginnen Sie hier . 

 Befehle der Eingabesprac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EFORTH f√ºr MK-161: Datenstrukturen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452572/">  <i>Dieser Artikel ist das Ende einer Reihe von eForth-Artikeln auf einem programmierbaren Taschenrechner.</i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beginnen Sie hier</a> .</i> <br><br>  Befehle der Eingabesprache "Electronics MK-161" belegen nur die H√§lfte der Datei eForth0.mkl.  Die zweite H√§lfte ist mit Tabellen besetzt, deren Entwicklung nicht weniger schwierig war als das Schreiben des algorithmischen Teils des √úbersetzers.  Versuchen wir herauszufinden, wie diese Tabellen verwendet werden. <br><img src="https://habrastorage.org/webt/02/fk/fj/02fkfjzcgzqhki9p-xj7mwfmftw.jpeg"><br><a name="habracut"></a><br>  Professor Wirth lehrt, dass ‚ÄûProgrammieren im Kleinen‚Äú aus der Entwicklung von zwei gleich wichtigen Komponenten besteht - Algorithmen und Datenstrukturen. <br><br>  Wir haben bereits eine eForth-Datenstruktur gefunden.  Dies ist der K√∂rper von VCA (High-Level-W√∂rtern), der sich im Byte-Speicher befindet.  Vier Handler interpretieren die Parameterfelder ‚Äûihres eigenen‚Äú VCA unterschiedlich: <br><br><pre><code class="plaintext hljs">.DB DOVAR ;      .DB ‚Ä¶ ;      .DB DOCON ;    .DW _ ;   .DB DOCONM ;     .DW _ ;   .DB DOLST ;     .DW 1, 2,‚Ä¶ EXITT ;  </code> </pre> <br>  Die folgende relativ einfache Datenstruktur ist mit TYPE "Standardnachrichten" verkn√ºpft.  <b>Alle eForth-Nachrichten werden nummeriert und in den billigen Programmspeicher √ºbertragen.</b>  Wenn das Wort TYPE einen einzelnen Buchstaben druckt, kann sein Code die Nummer einer solchen Nachricht von 0 bis 7 sein. <br><br><pre> <code class="plaintext hljs">;   TYPE .BASE tblTYPE: .DBB str7,str6, str5, str4, str3, str2, str1, str0</code> </pre> <br>  In der erweiterten MK-Sprache legt der Pseudobefehl .BASE die "Basis" f√ºr den Befehl .DBB fest, der die Zeilenvers√§tze str7, str6 nacheinander in Bytes platziert  relativ zum Basislabel tblTYPE.  Durch Hinzuf√ºgen von Zahlen von 0 bis 7 zur Tabellenadresse kann dieser Offset daraus gelesen werden.  Wenn wir den gefundenen Offset zu tblTYPE hinzuf√ºgen, erhalten wir die Adresse der gew√ºnschten Zeile. <br><br>  Das erste Byte der Zeichenfolge enth√§lt seine L√§nge.  eForth nutzt solche Z√§hllinien in gro√üem Umfang. <br><br>  Wir sind auch auf die Tabelle tblTokens gesto√üen, in der die Code-Adressen aller 208 eingebetteten W√∂rter aufgelistet sind.  Wenn das Wort nicht primitiv ist, enth√§lt die Tabelle 0. Wenn Sie zur Adresse 0 wechseln, wird eForth mit einem Quietschen neu gestartet. <br><br>  Die Tabelle tblNames wurde ebenfalls erw√§hnt und bezog sich auf die Namen derselben 208 W√∂rter.  Diese Namen in Form von Z√§hlzeilen werden im gleichen "Gummi" -Programmspeicher gespeichert.  Die Tabelle tblNames selbst ist nicht verf√ºgbar, w√§hrend eForth ausgef√ºhrt wird, aber die darin enthaltenen Informationen gehen nicht verloren.  Zur Kompilierungszeit √ºbertr√§gt eForth.f die Adresse der Namen an eine bequemere Datenstruktur, die im Dezimalspeicher gespeichert ist (siehe 2). <br><br>  Ich sprach auch √ºber tblCHPUT, eine assoziative Tabelle von Steuercodes, wenn ein Buchstabe auf dem Bildschirm eines Taschenrechners angezeigt wird.  Weitere sieben Tabellen, von tblKeyNum bis tblKeyRusF, √ºbersetzen den Code einer in verschiedenen Tastaturmodi gedr√ºckten Taste in einen 8-Bit-Buchstabencode.  Die Adresse des f√ºr den aktiven Tastaturmodus verantwortlichen Unterprogramms befindet sich im Dezimalregister ptrKbdInt. <br><br>  Insgesamt blieb nur eine Datenstruktur in der Datei eForth0.mkl nicht zusammengesetzt. Dies sind Namenserkennungstabellen.  Lassen wir sie nach dem Hauptgericht zum Nachtisch (siehe 5) - zwei √úberschriften-Tabellen, die im Dezimalspeicher gespeichert sind.  Zuerst werden wir uns mit Werkzeugen ausr√ºsten, um diese √úberschriften zu ‚Äûstopfen‚Äú. <br><br><h3>  1. Arbeiten Sie mit √úberschriften: HEAD!  und HEAD @ </h3><br><pre> <code class="plaintext hljs">HEAD! ( xt nfa r -- )     r,  xt  nfa. HEAD@ ( r -- xt nfa lex )     r,  xt, nfa  .</code> </pre><br>  Ein Dezimalregister MK-161 kann 12 Dezimalstellen speichern.  eForth verwendet dieses Register, um drei kleine Zahlen von jeweils 0 bis 9999 zu speichern. Die <b>drei ‚ÄûFelder‚Äú zum Speichern dieser Zahlen hei√üen A, B und C: AAAABBBBCCCC.</b>  Das Dezimalzeichen bezieht sich nur auf Feld A. <br><br>  Das HEAD @ -Primitiv erh√§lt die Registernummer und teilt die Nummer von dort in Felder auf, und HEAD!  sammelt Felder in einer langen Anzahl und schreibt das resultierende "Monster" in das angegebene Register.  Aber es gibt Nuancen. <br><br>  Die ‚ÄûDezimal√ºberschrift‚Äú des Wortes enth√§lt im Feld A die Adresse seines Namens (nfa).  Wenn diese Adresse negativ ist, wird der Name im Programmspeicher gespeichert.  Feld B enth√§lt das Wort Token (xt).  Feld C wird als Lexikon bezeichnet.  Es speichert das IMMEDIATE-Bit und ein Zeichen daf√ºr, dass das Wort nur zur Kompilierung bestimmt ist. <br><br>  HEAD @ teilt den Header in Teile.  Am oberen Rand des Stapels befindet sich das Lexikonfeld C, darunter das Namensfeld A. Das Feld B, in dem das Token normalerweise gespeichert ist, befindet sich ganz unten. <br><br>  KOPF!  setzt Feld C zur√ºck. <br><br><h3>  2. Inline-√úberschriften </h3><br><img src="https://habrastorage.org/webt/ny/_t/g7/ny_tg7mxwoqm9h65nlq4ybfcazu.png"><br><br>  Die √úberschriften der 208 integrierten W√∂rter (0 bis 207) sind in der richtigen Reihenfolge angeordnet, beginnend mit R44.  Feld A enth√§lt immer eine negative Zahl, da die Namen dieser W√∂rter im Programmspeicher fest codiert sind. <br><br>  Die Felder B und C k√∂nnen bearbeitet werden.  Daher kann der Benutzer die integrierten W√∂rter neu definieren und daraus das SOFORTIGE machen, das er ben√∂tigt (siehe 4). <br><br><h3>  3. Benutzer√ºberschriften </h3><br><img src="https://habrastorage.org/webt/gh/lw/3v/ghlw3v8ajgu1dhgfiyoughzpngm.png"><br><br>  Das Arbeiten mit nur 208 vordefinierten Namen spart Byte-Speicher, ist jedoch ungew√∂hnlich langweilig.  Aus diesem Grund habe ich eine andere Datenstruktur entwickelt, bei der die Fantasie bei der Auswahl eines Namens auf nur 32 Buchstaben beschr√§nkt ist.  Diese Struktur besteht aus 32 <i>Listen</i> , von denen jede f√ºr Benutzerw√∂rter einer bestimmten L√§nge verantwortlich ist.  Jede dieser 32 Listen hat eine pers√∂nliche √úberschrift.  Die Listen selbst springen √ºber den Dezimalspeicher, aber ihre Header werden immer in R301 ... R332 gespeichert. <br><br>  <b>Das Sortieren von W√∂rtern nach Namensl√§nge ist ein wichtiges Highlight von 161eForth.</b>  Durch das Sortieren wird die Anzahl der Vergleiche bei der Suche nach einem Wort anhand seines Namens erheblich reduziert, wodurch die Kompilierung beschleunigt wird.  Wer braucht Hash-Funktionen, wenn jeder Name eine bekannte L√§nge hat? <br><br>  Der Einfachheit halber hat die <i>√úberschrift der Liste</i> dieselbe Struktur mit den Feldern A, B und C wie die √úberschrift des Wortes.  Der Zweck dieser Felder ist unterschiedlich.  Feld A enth√§lt die Nummer des ersten Registers in der Liste.  Feld B enth√§lt die Anzahl der Register, die der Liste zur Verf√ºgung gestellt werden.  Feld C speichert die Anzahl der W√∂rter, deren √úberschriften bereits in der Liste enthalten sind. <br><br>  Zu Beginn der Arbeit sind die Felder C gleich Null, W√∂rter fehlen in allen Listen.  Die Felder B sind 2, jede Liste erh√§lt zun√§chst ein paar Register.  Felder A geben Bl√∂cke von 2 Registern an, die mit R333 beginnen. <br><br>  Jede Liste enth√§lt √úberschriften von W√∂rtern.  Wir haben sie bereits zerlegt (siehe 1).  Hier ist die Adresse des Namens (nfa) m√∂glicherweise positiv und zeigt auf die Z√§hllinie, die traditionell vor dem K√∂rper des VCA gespeichert ist.  Das Token in Feld B ist auch die Adresse des Codefelds (cfa), das unmittelbar nach diesem Namen in den Bin√§rspeicher gelangt.  Es gibt eine Ausnahme: <b>Wenn das Wort bereits ermittelt wurde, zeigt Feld A auf den alten Namen.</b>  Warum die Zeichenfolge erneut speichern?  Bin√§rer Speicher ist teuer. <br><br>  Wenn alle Register der Liste voll sind (B = C), bietet das Wort PUBLISH 5 weitere freie Stellen, wobei diese Datenstruktur an die richtige Stelle verschoben und die Links (A) in den Listen√ºberschriften angepasst werden. <br><br><h3>  4. Ver√∂ffentlichung eines neuen Wortes: WORK and PUBLISH </h3><br><pre> <code class="plaintext hljs">LAST ( -- a )      . WORK ( -- a )     . PUBLISH ( -- )     . $,n ( nfa -- )     ,    nfa. ?UNIQUE ( a -- a )  ,    .</code> </pre><br>  Die f√ºr den MK-161 entwickelte Datenstruktur zum Speichern von Worttiteln erwies sich als praktisch und einfach in eForth zu integrieren.  Wenn CREATE, CONSTANT oder: ein neues Wort erstellt, greifen sie auf das Systemwort $, n zu, um einen Titel f√ºr das Wort mit dem angegebenen Namen zu erstellen.  $, n bezieht sich auf? EINZIGARTIG zur Verifizierung - erstellen wir ein neues Wort oder definieren wir das alte neu? <br><br>  Wenn bereits ein gleichnamiges Wort vorhanden ist, warnt UNIQUE den Benutzer davor.  Gleichzeitig wird die Adresse des neu definierten Headers in die LAST-Systemvariable eingetragen.  F√ºr ein neues Wort wird LAST auf Null zur√ºckgesetzt. <br><br>  In jedem Fall erstellt $, n einen neuen Header in der WORK-Variablen - es ist ein Dezimalregister, das 12 Bits des Headers speichern kann.  Wenn der Name nicht gefunden wurde, wird er vor dem Codefeld in das W√∂rterbuch aufgenommen, wie dies in 86eForth und vielen anderen Forts der Fall ist.  <b>Der MK-161 konnte auf ein ‚ÄûKommunikationsfeld‚Äú verzichten</b> , dies spart auch Bin√§rspeicher. <br><br>  Das PUBLISH-Grundelement vervollst√§ndigt die Definition eines Wortes.  Beim Kompilieren von Doppelpunktw√∂rtern wird PUBLISH von; aufgerufen. Daher war das SMUDGE-Bit nicht erforderlich.  Die Stelle, an der der Header von WORK kopiert wird, wird durch die Variable LAST bestimmt.  Wenn LAST Null ist, wird in der entsprechenden Liste ein neuer Header erstellt (siehe 3).  Ist die Liste vollst√§ndig?  Dann wird PUBLISH 5 weitere Register hinzuf√ºgen, vier davon f√ºr die Zukunft. <br><br>  Nach dem Ausf√ºhren von PUBLISH zeigt die Variable LAST immer auf den Titel des letzten Wortes.  Dies hilft IMMEDIATE, seine Arbeit zu erledigen, indem das Lexikonfeld ge√§ndert wird. <br><br><h3>  5. (FIND) und Namenserkennungstabellen </h3><br><pre> <code class="plaintext hljs">(FIND) ( a -- r T | a F )    r,        a. FIND ( a -- a F | xt 1 | xt -1)    .  1,  IMMEDIATE.</code> </pre><br>  Ein Grundelement (FIND) verwaltet die Suche nach einem Wort anhand seines Namens.  Zuerst sucht er nach einem Namen unter den eingebauten W√∂rtern mit zuvor bekannten Namen und √ºberpr√ºft dann die Liste der Benutzerw√∂rter mit der gew√ºnschten Namensl√§nge (siehe 3).  Namenserkennungstabellen beschleunigen dieses ‚ÄûErste‚Äú erheblich.  So funktionieren sie. <br><br>  Zu Beginn (FIND) findet es im Array tblLen die Adresse der assoziativen Haupttabelle, in der bekannte Namen der erforderlichen L√§nge "vorbereitet" werden.  In dieser Tabelle (FIND) wird nach dem ersten Zeichen des Namens gesucht.  In den meisten F√§llen k√∂nnen Sie so sofort die <i>Titelregisternummer des</i> gesuchten Wortes ermitteln - anhand des ersten Buchstabens und der L√§nge. <br><br>  Es kommt vor, dass mehrere W√∂rter gleicher L√§nge dieselben Anfangsbuchstaben haben.  Anstelle der Registernummer (FIND) st√∂√üt es dann auf die Adresse der n√§chsten assoziativen Tabelle (die gelesene Nummer ist 300 oder mehr) und die Suche wird mit dem zweiten Buchstaben fortgesetzt.  Und so weiter, bis das Wort gefunden ist oder festgestellt wird, dass es kein solches Wort gibt. <br><br>  Nat√ºrlich wird nach einer √úbereinstimmung mit den ersten Buchstaben (FIND) der gesamte Name √ºberpr√ºft.  Aber <b>Erkennungstabellen machten eForth schnell</b> .  In diesem Fr√ºhjahr habe ich viel Zeit in sie investiert, und jetzt sparen sie Suchzeit.  Die "Schl√ºssel" in ihnen sind sogar alphabetisch sortiert.  Entschuldigung, die Firmware des MK-161 hat darauf gespuckt. <br><br>  Aus Kompatibilit√§tsgr√ºnden habe ich das Wort FIND aus Fort ANS [4] implementiert, das dem Grundelement ‚ÄûBlack Work‚Äú (FIND) vertraut.  Das bereits betrachtete Wort? UNIQUE sucht auch nach seiner Argumentation durch (FIND). <br><br><h3>  6. Externer Dolmetscher </h3><br>  Buch [1] enth√§lt eine ausf√ºhrliche Beschreibung von eForth, einschlie√ülich eines externen ‚ÄûText‚Äú -Dolmetschers.  Er ist es, der den Quelltext in der Fort-Sprache ausf√ºhrt oder kompiliert.  In den letzten Jahrzehnten sind Unterschiede zu Textinterpreten anderer Fort-Dialekte ([2], [3]) aufgetreten, von denen es jedoch nur wenige gibt. <br><br>  Unten sehen Sie ein Blockdiagramm eines Textinterpreters aus [1].  Seien Sie vorsichtig - dieser "Interpreter" hat einen Kompilierungsmodus!  Das Wort $ COMPILE ist f√ºr das Kompilieren von Forte-Text in ‚Äûgen√§hten Code‚Äú verantwortlich, dessen Ausf√ºhrung wir im ersten Artikel ausf√ºhrlich untersucht haben.  Wenn stattdessen $ INTERPRET ausgef√ºhrt wird, werden die eingegebenen W√∂rter sofort ausgef√ºhrt - Interpretationsmodus.  EVAL "berechnet" die gesamte eingegebene Zeichenfolge und ruft f√ºr jedes eingegebene Wort eines dieser beiden W√∂rter auf. <br><br><img src="https://habrastorage.org/webt/fw/p0/lh/fwp0lhb3kpioz07jrwbrpz4-md8.jpeg"><br><br>  Nach dem Blockdiagramm entschl√ºsselt der Autor, welcher der Bl√∂cke dies tut.  Hier ist ihre √úbersetzung.  Blocknamen stimmen normalerweise mit eForth-Wortnamen √ºberein.  Das Wort NAME?  fehlt in meiner Implementierung, wird es erfolgreich durch fast (FIND) ersetzt (siehe. 5). <br><br><div class="scrollable-table"><table><tbody><tr><td>  MAIN </td><td>  Richten Sie eine virtuelle Fort-Engine ein </td></tr><tr><td>  KALT </td><td>  Systemvariablen initialisieren </td></tr><tr><td>  Abbruch </td><td>  Datenstapel leeren.  Fehlerbehandlungsroutine </td></tr><tr><td>  BEENDEN </td><td>  Setzen Sie den R√ºckgabestapel zur√ºck und betreten Sie die Interpreter-Schleife </td></tr><tr><td>  FRAGE </td><td>  Akzeptieren Sie die Texteingabe vom Terminal </td></tr><tr><td>  EVAL </td><td>  Berechnen oder interpretieren Sie eine Textzeichenfolge </td></tr><tr><td>  PARSE </td><td>  W√§hlen Sie ein Wort aus dem eingegebenen Text </td></tr><tr><td>  $ INTERPRET </td><td>  Interpretiere das Wort </td></tr><tr><td>  $ COMPILE </td><td>  Wort zusammenstellen </td></tr><tr><td>  NAME? </td><td>  Suchen Sie ein Wort in einem W√∂rterbuch </td></tr><tr><td>  NUMMER? </td><td>  Konvertieren Sie eine Textzeichenfolge in eine Ganzzahl </td></tr><tr><td>  AUSF√úHREN </td><td>  Wort ausf√ºhren </td></tr><tr><td>  IMMED? </td><td>  Ist dieses Wort ein sofortiger Befehl? </td></tr><tr><td>  W√∂rtlich </td><td>  Kompilieren Sie ein ganzes Literal </td></tr><tr><td>  KOMPILIEREN </td><td>  Token kompilieren </td></tr></tbody></table></div><br><br>  Das Buch enth√§lt auch den Quellcode f√ºr jedes eForth-Wort in der Windows-Version mit kurzen Erl√§uterungen.  Was ist die Version f√ºr MK-161 anders, habe ich dir schon gesagt.  Der Quellcode f√ºr meine Implementierung befindet sich im Archiv: <a href="">the-hacker.ru/2019/161eforth0.5b.zip</a> <br><br>  Abschlie√üend <b>m√∂chte</b> ich die Implementierung des Wortes <b>(PARSE) in der Sprache MK-161</b> erw√§hnen - unter Windows ist es VCA.  Das Debuggen dauerte eine Woche, <b>beschleunigte jedoch die Kompilierung um die H√§lfte</b> .  Das Wort (PARSE) erledigt die gesamte ‚ÄûDrecksarbeit‚Äú f√ºr PARSE, um einzelne W√∂rter vom eingegebenen Textstrom zu isolieren. <br><br>  Meine Erg√§nzungen zum externen Interpreter bestehen neben dem √ºblichen QUIT-Zyklus aus zwei W√∂rtern: dem bereits erw√§hnten TLOAD, der aus √§lteren Versionen von FILE stammt.  Das Wort FILE √ºbersetzt E / A in die Konsole, liest jedoch Zeilen zur Interpretation vom RS-232-Port.  Nach erfolgreicher Verarbeitung jeder Zeile wird ein Buchstabe mit dem Code 11 an den Port ausgegeben. Die vom Computer heruntergeladene Datei sollte mit dem Wort QUIT enden. <br><br>  Ich habe das Wort DATEI noch nicht getestet.  Wenn jemand es braucht, teilen Sie Ihre Eindr√ºcke. <br><br>  Die √úberpr√ºfung der engen Stellen durch 161eForth ist beendet, aber das Fort ist ein unglaublich flexibles Werkzeug, das jeder Besitzer anpassen kann.  Selbst wenn Sie alles gr√ºndlich herausgefunden haben, wird jemand irgendwo auf dem Planeten einen anderen Trick finden, der Sie √ºberraschen kann. <br><br>  Hier sind die letzten Worte des Autors eForth aus [1]: <br><br><blockquote>  Seit 26 Jahren habe ich eForth viele, viele Male umgeschrieben.  Bei jedem √úberspielen habe ich versucht, es einfacher und klarer zu machen.  Jetzt in 86eForth v5.2 denke ich, dass ich die Richtigkeit erreicht habe und bin daher sehr gl√ºcklich. <br><br>  Wie Einstein sagte: <br>  <b>Alles sollte so einfach wie m√∂glich gemacht werden, aber nicht einfacher.</b> <br><br>  86eForth v5.2 noch einfacher machen, vielleicht kaputt machen oder als Programmierwerkzeug nicht n√ºtzlich sein. </blockquote><h3>  Literatur </h3><br><ol><li>  Dr.  Chen-Hanson Ting.  eForth und Zen - 3. Ausgabe, 2017. Verf√ºgbar auf Amazon Kindle. </li><li>  Baranov S.N., Nozdrunov N.R.  Fort Sprache und ihre Umsetzung.  - L.: Maschinenbau.  Leningrad  Abteilung, 1988. </li><li>  Semenov Yu.A.  Programmierung in der FORT-Sprache.  - M.: Radio und Kommunikation, 1991. </li><li>  ANS Vierter Standard.  X3.215-1994.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SP-Forth-Dokumentation</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offete Enterprises (Dr. Chen-Hanson Ting)</a> , Autor von 86eForth v5.2, ist in englischer Sprache. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Geschichte von Mikhail Pukhov "True Truth"</a> mit dem Programm "Moonwalker-1", wo ich KDPV bekam und die sowjetischen Taschenrechner liebte. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452572/">https://habr.com/ru/post/de452572/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452562/index.html">Schreiben von sauberem und skalierbarem JavaScript-Code: 12 Tipps</a></li>
<li><a href="../de452564/index.html">Python 3-Funktionen, die es wert sind, verwendet zu werden</a></li>
<li><a href="../de452566/index.html">Node.js f√ºr Anf√§nger: Grundlagen der Arbeit mit Dateien</a></li>
<li><a href="../de452568/index.html">Eine detaillierte Analyse der neuen Funktionen von React 16+, Teil 1: Allgemeine Informationen</a></li>
<li><a href="../de452570/index.html">Linux Install Fest - Seitenansicht</a></li>
<li><a href="../de452576/index.html">√úber Introvertierte in der IT</a></li>
<li><a href="../de452580/index.html">20 Projekte, 20 Sprachen, Frist gestern. Teil 3</a></li>
<li><a href="../de452584/index.html">Programmierer haben falsche Vorstellungen √ºber die Unix-Zeit</a></li>
<li><a href="../de452586/index.html">So starten Sie die Programmierung in Adobe Illustrator. Teil eins</a></li>
<li><a href="../de452590/index.html">Der Amerikaner schuf ein mobiles Klassenzimmer f√ºr den Unterricht von Kindern in Low-Budget-3D-Druckschulen. Das Projekt hat bereits mehr als 100.000 gesammelt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>