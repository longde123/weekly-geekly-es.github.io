<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈴 🐭 🙏🏼 EFORTH für MK-161: Datenstrukturen 🏽 👨🏿‍🤝‍👨🏻 🎅🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel ist das Ende einer Reihe von eForth-Artikeln auf einem programmierbaren Taschenrechner. Beginnen Sie hier . 

 Befehle der Eingabesprac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EFORTH für MK-161: Datenstrukturen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452572/">  <i>Dieser Artikel ist das Ende einer Reihe von eForth-Artikeln auf einem programmierbaren Taschenrechner.</i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beginnen Sie hier</a> .</i> <br><br>  Befehle der Eingabesprache "Electronics MK-161" belegen nur die Hälfte der Datei eForth0.mkl.  Die zweite Hälfte ist mit Tabellen besetzt, deren Entwicklung nicht weniger schwierig war als das Schreiben des algorithmischen Teils des Übersetzers.  Versuchen wir herauszufinden, wie diese Tabellen verwendet werden. <br><img src="https://habrastorage.org/webt/02/fk/fj/02fkfjzcgzqhki9p-xj7mwfmftw.jpeg"><br><a name="habracut"></a><br>  Professor Wirth lehrt, dass „Programmieren im Kleinen“ aus der Entwicklung von zwei gleich wichtigen Komponenten besteht - Algorithmen und Datenstrukturen. <br><br>  Wir haben bereits eine eForth-Datenstruktur gefunden.  Dies ist der Körper von VCA (High-Level-Wörtern), der sich im Byte-Speicher befindet.  Vier Handler interpretieren die Parameterfelder „ihres eigenen“ VCA unterschiedlich: <br><br><pre><code class="plaintext hljs">.DB DOVAR ;      .DB … ;      .DB DOCON ;    .DW _ ;   .DB DOCONM ;     .DW _ ;   .DB DOLST ;     .DW 1, 2,… EXITT ;  </code> </pre> <br>  Die folgende relativ einfache Datenstruktur ist mit TYPE "Standardnachrichten" verknüpft.  <b>Alle eForth-Nachrichten werden nummeriert und in den billigen Programmspeicher übertragen.</b>  Wenn das Wort TYPE einen einzelnen Buchstaben druckt, kann sein Code die Nummer einer solchen Nachricht von 0 bis 7 sein. <br><br><pre> <code class="plaintext hljs">;   TYPE .BASE tblTYPE: .DBB str7,str6, str5, str4, str3, str2, str1, str0</code> </pre> <br>  In der erweiterten MK-Sprache legt der Pseudobefehl .BASE die "Basis" für den Befehl .DBB fest, der die Zeilenversätze str7, str6 nacheinander in Bytes platziert  relativ zum Basislabel tblTYPE.  Durch Hinzufügen von Zahlen von 0 bis 7 zur Tabellenadresse kann dieser Offset daraus gelesen werden.  Wenn wir den gefundenen Offset zu tblTYPE hinzufügen, erhalten wir die Adresse der gewünschten Zeile. <br><br>  Das erste Byte der Zeichenfolge enthält seine Länge.  eForth nutzt solche Zähllinien in großem Umfang. <br><br>  Wir sind auch auf die Tabelle tblTokens gestoßen, in der die Code-Adressen aller 208 eingebetteten Wörter aufgelistet sind.  Wenn das Wort nicht primitiv ist, enthält die Tabelle 0. Wenn Sie zur Adresse 0 wechseln, wird eForth mit einem Quietschen neu gestartet. <br><br>  Die Tabelle tblNames wurde ebenfalls erwähnt und bezog sich auf die Namen derselben 208 Wörter.  Diese Namen in Form von Zählzeilen werden im gleichen "Gummi" -Programmspeicher gespeichert.  Die Tabelle tblNames selbst ist nicht verfügbar, während eForth ausgeführt wird, aber die darin enthaltenen Informationen gehen nicht verloren.  Zur Kompilierungszeit überträgt eForth.f die Adresse der Namen an eine bequemere Datenstruktur, die im Dezimalspeicher gespeichert ist (siehe 2). <br><br>  Ich sprach auch über tblCHPUT, eine assoziative Tabelle von Steuercodes, wenn ein Buchstabe auf dem Bildschirm eines Taschenrechners angezeigt wird.  Weitere sieben Tabellen, von tblKeyNum bis tblKeyRusF, übersetzen den Code einer in verschiedenen Tastaturmodi gedrückten Taste in einen 8-Bit-Buchstabencode.  Die Adresse des für den aktiven Tastaturmodus verantwortlichen Unterprogramms befindet sich im Dezimalregister ptrKbdInt. <br><br>  Insgesamt blieb nur eine Datenstruktur in der Datei eForth0.mkl nicht zusammengesetzt. Dies sind Namenserkennungstabellen.  Lassen wir sie nach dem Hauptgericht zum Nachtisch (siehe 5) - zwei Überschriften-Tabellen, die im Dezimalspeicher gespeichert sind.  Zuerst werden wir uns mit Werkzeugen ausrüsten, um diese Überschriften zu „stopfen“. <br><br><h3>  1. Arbeiten Sie mit Überschriften: HEAD!  und HEAD @ </h3><br><pre> <code class="plaintext hljs">HEAD! ( xt nfa r -- )     r,  xt  nfa. HEAD@ ( r -- xt nfa lex )     r,  xt, nfa  .</code> </pre><br>  Ein Dezimalregister MK-161 kann 12 Dezimalstellen speichern.  eForth verwendet dieses Register, um drei kleine Zahlen von jeweils 0 bis 9999 zu speichern. Die <b>drei „Felder“ zum Speichern dieser Zahlen heißen A, B und C: AAAABBBBCCCC.</b>  Das Dezimalzeichen bezieht sich nur auf Feld A. <br><br>  Das HEAD @ -Primitiv erhält die Registernummer und teilt die Nummer von dort in Felder auf, und HEAD!  sammelt Felder in einer langen Anzahl und schreibt das resultierende "Monster" in das angegebene Register.  Aber es gibt Nuancen. <br><br>  Die „Dezimalüberschrift“ des Wortes enthält im Feld A die Adresse seines Namens (nfa).  Wenn diese Adresse negativ ist, wird der Name im Programmspeicher gespeichert.  Feld B enthält das Wort Token (xt).  Feld C wird als Lexikon bezeichnet.  Es speichert das IMMEDIATE-Bit und ein Zeichen dafür, dass das Wort nur zur Kompilierung bestimmt ist. <br><br>  HEAD @ teilt den Header in Teile.  Am oberen Rand des Stapels befindet sich das Lexikonfeld C, darunter das Namensfeld A. Das Feld B, in dem das Token normalerweise gespeichert ist, befindet sich ganz unten. <br><br>  KOPF!  setzt Feld C zurück. <br><br><h3>  2. Inline-Überschriften </h3><br><img src="https://habrastorage.org/webt/ny/_t/g7/ny_tg7mxwoqm9h65nlq4ybfcazu.png"><br><br>  Die Überschriften der 208 integrierten Wörter (0 bis 207) sind in der richtigen Reihenfolge angeordnet, beginnend mit R44.  Feld A enthält immer eine negative Zahl, da die Namen dieser Wörter im Programmspeicher fest codiert sind. <br><br>  Die Felder B und C können bearbeitet werden.  Daher kann der Benutzer die integrierten Wörter neu definieren und daraus das SOFORTIGE machen, das er benötigt (siehe 4). <br><br><h3>  3. Benutzerüberschriften </h3><br><img src="https://habrastorage.org/webt/gh/lw/3v/ghlw3v8ajgu1dhgfiyoughzpngm.png"><br><br>  Das Arbeiten mit nur 208 vordefinierten Namen spart Byte-Speicher, ist jedoch ungewöhnlich langweilig.  Aus diesem Grund habe ich eine andere Datenstruktur entwickelt, bei der die Fantasie bei der Auswahl eines Namens auf nur 32 Buchstaben beschränkt ist.  Diese Struktur besteht aus 32 <i>Listen</i> , von denen jede für Benutzerwörter einer bestimmten Länge verantwortlich ist.  Jede dieser 32 Listen hat eine persönliche Überschrift.  Die Listen selbst springen über den Dezimalspeicher, aber ihre Header werden immer in R301 ... R332 gespeichert. <br><br>  <b>Das Sortieren von Wörtern nach Namenslänge ist ein wichtiges Highlight von 161eForth.</b>  Durch das Sortieren wird die Anzahl der Vergleiche bei der Suche nach einem Wort anhand seines Namens erheblich reduziert, wodurch die Kompilierung beschleunigt wird.  Wer braucht Hash-Funktionen, wenn jeder Name eine bekannte Länge hat? <br><br>  Der Einfachheit halber hat die <i>Überschrift der Liste</i> dieselbe Struktur mit den Feldern A, B und C wie die Überschrift des Wortes.  Der Zweck dieser Felder ist unterschiedlich.  Feld A enthält die Nummer des ersten Registers in der Liste.  Feld B enthält die Anzahl der Register, die der Liste zur Verfügung gestellt werden.  Feld C speichert die Anzahl der Wörter, deren Überschriften bereits in der Liste enthalten sind. <br><br>  Zu Beginn der Arbeit sind die Felder C gleich Null, Wörter fehlen in allen Listen.  Die Felder B sind 2, jede Liste erhält zunächst ein paar Register.  Felder A geben Blöcke von 2 Registern an, die mit R333 beginnen. <br><br>  Jede Liste enthält Überschriften von Wörtern.  Wir haben sie bereits zerlegt (siehe 1).  Hier ist die Adresse des Namens (nfa) möglicherweise positiv und zeigt auf die Zähllinie, die traditionell vor dem Körper des VCA gespeichert ist.  Das Token in Feld B ist auch die Adresse des Codefelds (cfa), das unmittelbar nach diesem Namen in den Binärspeicher gelangt.  Es gibt eine Ausnahme: <b>Wenn das Wort bereits ermittelt wurde, zeigt Feld A auf den alten Namen.</b>  Warum die Zeichenfolge erneut speichern?  Binärer Speicher ist teuer. <br><br>  Wenn alle Register der Liste voll sind (B = C), bietet das Wort PUBLISH 5 weitere freie Stellen, wobei diese Datenstruktur an die richtige Stelle verschoben und die Links (A) in den Listenüberschriften angepasst werden. <br><br><h3>  4. Veröffentlichung eines neuen Wortes: WORK and PUBLISH </h3><br><pre> <code class="plaintext hljs">LAST ( -- a )      . WORK ( -- a )     . PUBLISH ( -- )     . $,n ( nfa -- )     ,    nfa. ?UNIQUE ( a -- a )  ,    .</code> </pre><br>  Die für den MK-161 entwickelte Datenstruktur zum Speichern von Worttiteln erwies sich als praktisch und einfach in eForth zu integrieren.  Wenn CREATE, CONSTANT oder: ein neues Wort erstellt, greifen sie auf das Systemwort $, n zu, um einen Titel für das Wort mit dem angegebenen Namen zu erstellen.  $, n bezieht sich auf? EINZIGARTIG zur Verifizierung - erstellen wir ein neues Wort oder definieren wir das alte neu? <br><br>  Wenn bereits ein gleichnamiges Wort vorhanden ist, warnt UNIQUE den Benutzer davor.  Gleichzeitig wird die Adresse des neu definierten Headers in die LAST-Systemvariable eingetragen.  Für ein neues Wort wird LAST auf Null zurückgesetzt. <br><br>  In jedem Fall erstellt $, n einen neuen Header in der WORK-Variablen - es ist ein Dezimalregister, das 12 Bits des Headers speichern kann.  Wenn der Name nicht gefunden wurde, wird er vor dem Codefeld in das Wörterbuch aufgenommen, wie dies in 86eForth und vielen anderen Forts der Fall ist.  <b>Der MK-161 konnte auf ein „Kommunikationsfeld“ verzichten</b> , dies spart auch Binärspeicher. <br><br>  Das PUBLISH-Grundelement vervollständigt die Definition eines Wortes.  Beim Kompilieren von Doppelpunktwörtern wird PUBLISH von; aufgerufen. Daher war das SMUDGE-Bit nicht erforderlich.  Die Stelle, an der der Header von WORK kopiert wird, wird durch die Variable LAST bestimmt.  Wenn LAST Null ist, wird in der entsprechenden Liste ein neuer Header erstellt (siehe 3).  Ist die Liste vollständig?  Dann wird PUBLISH 5 weitere Register hinzufügen, vier davon für die Zukunft. <br><br>  Nach dem Ausführen von PUBLISH zeigt die Variable LAST immer auf den Titel des letzten Wortes.  Dies hilft IMMEDIATE, seine Arbeit zu erledigen, indem das Lexikonfeld geändert wird. <br><br><h3>  5. (FIND) und Namenserkennungstabellen </h3><br><pre> <code class="plaintext hljs">(FIND) ( a -- r T | a F )    r,        a. FIND ( a -- a F | xt 1 | xt -1)    .  1,  IMMEDIATE.</code> </pre><br>  Ein Grundelement (FIND) verwaltet die Suche nach einem Wort anhand seines Namens.  Zuerst sucht er nach einem Namen unter den eingebauten Wörtern mit zuvor bekannten Namen und überprüft dann die Liste der Benutzerwörter mit der gewünschten Namenslänge (siehe 3).  Namenserkennungstabellen beschleunigen dieses „Erste“ erheblich.  So funktionieren sie. <br><br>  Zu Beginn (FIND) findet es im Array tblLen die Adresse der assoziativen Haupttabelle, in der bekannte Namen der erforderlichen Länge "vorbereitet" werden.  In dieser Tabelle (FIND) wird nach dem ersten Zeichen des Namens gesucht.  In den meisten Fällen können Sie so sofort die <i>Titelregisternummer des</i> gesuchten Wortes ermitteln - anhand des ersten Buchstabens und der Länge. <br><br>  Es kommt vor, dass mehrere Wörter gleicher Länge dieselben Anfangsbuchstaben haben.  Anstelle der Registernummer (FIND) stößt es dann auf die Adresse der nächsten assoziativen Tabelle (die gelesene Nummer ist 300 oder mehr) und die Suche wird mit dem zweiten Buchstaben fortgesetzt.  Und so weiter, bis das Wort gefunden ist oder festgestellt wird, dass es kein solches Wort gibt. <br><br>  Natürlich wird nach einer Übereinstimmung mit den ersten Buchstaben (FIND) der gesamte Name überprüft.  Aber <b>Erkennungstabellen machten eForth schnell</b> .  In diesem Frühjahr habe ich viel Zeit in sie investiert, und jetzt sparen sie Suchzeit.  Die "Schlüssel" in ihnen sind sogar alphabetisch sortiert.  Entschuldigung, die Firmware des MK-161 hat darauf gespuckt. <br><br>  Aus Kompatibilitätsgründen habe ich das Wort FIND aus Fort ANS [4] implementiert, das dem Grundelement „Black Work“ (FIND) vertraut.  Das bereits betrachtete Wort? UNIQUE sucht auch nach seiner Argumentation durch (FIND). <br><br><h3>  6. Externer Dolmetscher </h3><br>  Buch [1] enthält eine ausführliche Beschreibung von eForth, einschließlich eines externen „Text“ -Dolmetschers.  Er ist es, der den Quelltext in der Fort-Sprache ausführt oder kompiliert.  In den letzten Jahrzehnten sind Unterschiede zu Textinterpreten anderer Fort-Dialekte ([2], [3]) aufgetreten, von denen es jedoch nur wenige gibt. <br><br>  Unten sehen Sie ein Blockdiagramm eines Textinterpreters aus [1].  Seien Sie vorsichtig - dieser "Interpreter" hat einen Kompilierungsmodus!  Das Wort $ COMPILE ist für das Kompilieren von Forte-Text in „genähten Code“ verantwortlich, dessen Ausführung wir im ersten Artikel ausführlich untersucht haben.  Wenn stattdessen $ INTERPRET ausgeführt wird, werden die eingegebenen Wörter sofort ausgeführt - Interpretationsmodus.  EVAL "berechnet" die gesamte eingegebene Zeichenfolge und ruft für jedes eingegebene Wort eines dieser beiden Wörter auf. <br><br><img src="https://habrastorage.org/webt/fw/p0/lh/fwp0lhb3kpioz07jrwbrpz4-md8.jpeg"><br><br>  Nach dem Blockdiagramm entschlüsselt der Autor, welcher der Blöcke dies tut.  Hier ist ihre Übersetzung.  Blocknamen stimmen normalerweise mit eForth-Wortnamen überein.  Das Wort NAME?  fehlt in meiner Implementierung, wird es erfolgreich durch fast (FIND) ersetzt (siehe. 5). <br><br><div class="scrollable-table"><table><tbody><tr><td>  MAIN </td><td>  Richten Sie eine virtuelle Fort-Engine ein </td></tr><tr><td>  KALT </td><td>  Systemvariablen initialisieren </td></tr><tr><td>  Abbruch </td><td>  Datenstapel leeren.  Fehlerbehandlungsroutine </td></tr><tr><td>  BEENDEN </td><td>  Setzen Sie den Rückgabestapel zurück und betreten Sie die Interpreter-Schleife </td></tr><tr><td>  FRAGE </td><td>  Akzeptieren Sie die Texteingabe vom Terminal </td></tr><tr><td>  EVAL </td><td>  Berechnen oder interpretieren Sie eine Textzeichenfolge </td></tr><tr><td>  PARSE </td><td>  Wählen Sie ein Wort aus dem eingegebenen Text </td></tr><tr><td>  $ INTERPRET </td><td>  Interpretiere das Wort </td></tr><tr><td>  $ COMPILE </td><td>  Wort zusammenstellen </td></tr><tr><td>  NAME? </td><td>  Suchen Sie ein Wort in einem Wörterbuch </td></tr><tr><td>  NUMMER? </td><td>  Konvertieren Sie eine Textzeichenfolge in eine Ganzzahl </td></tr><tr><td>  AUSFÜHREN </td><td>  Wort ausführen </td></tr><tr><td>  IMMED? </td><td>  Ist dieses Wort ein sofortiger Befehl? </td></tr><tr><td>  Wörtlich </td><td>  Kompilieren Sie ein ganzes Literal </td></tr><tr><td>  KOMPILIEREN </td><td>  Token kompilieren </td></tr></tbody></table></div><br><br>  Das Buch enthält auch den Quellcode für jedes eForth-Wort in der Windows-Version mit kurzen Erläuterungen.  Was ist die Version für MK-161 anders, habe ich dir schon gesagt.  Der Quellcode für meine Implementierung befindet sich im Archiv: <a href="">the-hacker.ru/2019/161eforth0.5b.zip</a> <br><br>  Abschließend <b>möchte</b> ich die Implementierung des Wortes <b>(PARSE) in der Sprache MK-161</b> erwähnen - unter Windows ist es VCA.  Das Debuggen dauerte eine Woche, <b>beschleunigte jedoch die Kompilierung um die Hälfte</b> .  Das Wort (PARSE) erledigt die gesamte „Drecksarbeit“ für PARSE, um einzelne Wörter vom eingegebenen Textstrom zu isolieren. <br><br>  Meine Ergänzungen zum externen Interpreter bestehen neben dem üblichen QUIT-Zyklus aus zwei Wörtern: dem bereits erwähnten TLOAD, der aus älteren Versionen von FILE stammt.  Das Wort FILE übersetzt E / A in die Konsole, liest jedoch Zeilen zur Interpretation vom RS-232-Port.  Nach erfolgreicher Verarbeitung jeder Zeile wird ein Buchstabe mit dem Code 11 an den Port ausgegeben. Die vom Computer heruntergeladene Datei sollte mit dem Wort QUIT enden. <br><br>  Ich habe das Wort DATEI noch nicht getestet.  Wenn jemand es braucht, teilen Sie Ihre Eindrücke. <br><br>  Die Überprüfung der engen Stellen durch 161eForth ist beendet, aber das Fort ist ein unglaublich flexibles Werkzeug, das jeder Besitzer anpassen kann.  Selbst wenn Sie alles gründlich herausgefunden haben, wird jemand irgendwo auf dem Planeten einen anderen Trick finden, der Sie überraschen kann. <br><br>  Hier sind die letzten Worte des Autors eForth aus [1]: <br><br><blockquote>  Seit 26 Jahren habe ich eForth viele, viele Male umgeschrieben.  Bei jedem Überspielen habe ich versucht, es einfacher und klarer zu machen.  Jetzt in 86eForth v5.2 denke ich, dass ich die Richtigkeit erreicht habe und bin daher sehr glücklich. <br><br>  Wie Einstein sagte: <br>  <b>Alles sollte so einfach wie möglich gemacht werden, aber nicht einfacher.</b> <br><br>  86eForth v5.2 noch einfacher machen, vielleicht kaputt machen oder als Programmierwerkzeug nicht nützlich sein. </blockquote><h3>  Literatur </h3><br><ol><li>  Dr.  Chen-Hanson Ting.  eForth und Zen - 3. Ausgabe, 2017. Verfügbar auf Amazon Kindle. </li><li>  Baranov S.N., Nozdrunov N.R.  Fort Sprache und ihre Umsetzung.  - L.: Maschinenbau.  Leningrad  Abteilung, 1988. </li><li>  Semenov Yu.A.  Programmierung in der FORT-Sprache.  - M.: Radio und Kommunikation, 1991. </li><li>  ANS Vierter Standard.  X3.215-1994.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SP-Forth-Dokumentation</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offete Enterprises (Dr. Chen-Hanson Ting)</a> , Autor von 86eForth v5.2, ist in englischer Sprache. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Geschichte von Mikhail Pukhov "True Truth"</a> mit dem Programm "Moonwalker-1", wo ich KDPV bekam und die sowjetischen Taschenrechner liebte. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452572/">https://habr.com/ru/post/de452572/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452562/index.html">Schreiben von sauberem und skalierbarem JavaScript-Code: 12 Tipps</a></li>
<li><a href="../de452564/index.html">Python 3-Funktionen, die es wert sind, verwendet zu werden</a></li>
<li><a href="../de452566/index.html">Node.js für Anfänger: Grundlagen der Arbeit mit Dateien</a></li>
<li><a href="../de452568/index.html">Eine detaillierte Analyse der neuen Funktionen von React 16+, Teil 1: Allgemeine Informationen</a></li>
<li><a href="../de452570/index.html">Linux Install Fest - Seitenansicht</a></li>
<li><a href="../de452576/index.html">Über Introvertierte in der IT</a></li>
<li><a href="../de452580/index.html">20 Projekte, 20 Sprachen, Frist gestern. Teil 3</a></li>
<li><a href="../de452584/index.html">Programmierer haben falsche Vorstellungen über die Unix-Zeit</a></li>
<li><a href="../de452586/index.html">So starten Sie die Programmierung in Adobe Illustrator. Teil eins</a></li>
<li><a href="../de452590/index.html">Der Amerikaner schuf ein mobiles Klassenzimmer für den Unterricht von Kindern in Low-Budget-3D-Druckschulen. Das Projekt hat bereits mehr als 100.000 gesammelt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>