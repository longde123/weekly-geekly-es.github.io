<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧣 🧓🏿 👕 Ikhtisar kecil SIMD di .NET / C # 🚘 🥙 🥝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Perhatian Anda diundang ke ikhtisar kecil tentang kapabilitas vektorisasi algoritma di .NET Framework dan .NETCORE. Tujuan artikel ini adalah untuk me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ikhtisar kecil SIMD di .NET / C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435840/"><p> Perhatian Anda diundang ke ikhtisar kecil tentang kapabilitas vektorisasi algoritma di .NET Framework dan .NETCORE.  Tujuan artikel ini adalah untuk memperkenalkan teknik-teknik ini kepada mereka yang tidak mengetahuinya sama sekali dan untuk menunjukkan bahwa .NET tidak ketinggalan jauh di belakang bahasa "nyata, dikompilasi" untuk penduduk asli <br>  pengembangan. </p><a name="habracut"></a><br><p>  Saya baru mulai mempelajari teknik-teknik vektorisasi, jadi jika seseorang dari komunitas mengarahkan saya ke cant eksplisit, atau menawarkan versi peningkatan dari algoritma yang dijelaskan di bawah ini, saya akan sangat senang. </p><br><h2 id="nemnogo-istorii">  Sedikit sejarah </h2><br><p>  Di .NET, SIMD pertama kali muncul pada 2015 dengan dirilisnya .NET Framework 4.6.  Kemudian jenis Matrix3x2, Matrix4x4, Plane, Quaternion, Vector2, Vector3, dan Vector4 ditambahkan, yang memungkinkan pembangunan perhitungan vektor.  Kemudian, tipe Vector &lt;T&gt; ditambahkan, yang memberikan lebih banyak peluang untuk algoritma vektorisasi.  Tetapi banyak programmer masih tidak senang karena  tipe-tipe di atas membatasi aliran pikiran programmer dan tidak memungkinkan kekuatan penuh dari instruksi SIMD dari prosesor modern untuk digunakan.  Sudah saat ini, dalam .NET Core 3.0 Preview, System.Runtime.Names intrinsik telah muncul, yang memberikan kebebasan yang jauh lebih besar dalam memilih instruksi.  Untuk mendapatkan hasil terbaik dalam kecepatan, Anda harus menggunakan RyuJit dan Anda harus membangun di bawah x64 atau menonaktifkan Prefer 32-bit dan membangun di bawah AnyCPU.  Semua tolok ukur yang saya jalankan di komputer dengan prosesor Intel Core i7-6700 3.40GHz (Skylake). </p><br><h2 id="summiruem-elementy-massiva">  Ringkas elemen-elemen dari array </h2><br><p>  Saya memutuskan untuk memulai dengan masalah klasik, yang sering ditulis pertama kali tentang vektorisasi.  Ini adalah tugas untuk menemukan jumlah elemen array.  Kami akan menulis empat implementasi dari tugas ini, kami akan merangkum elemen-elemen dari array Array: </p><br><p>  Paling jelas </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Array) { result += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Menggunakan LINQ </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Array.Aggregate&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, (current, i) =&gt; current + i);</code> </pre> <br><p>  Menggunakan vektor dari System.Numerics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); accVector = Vector.Add(accVector, v); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = Vector.Dot(accVector, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Menggunakan kode dari ruang System.Runtime.Intrinsics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector256&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = array) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = Avx2.LoadVector256(ptr + i); accVector = Avx2.Add(accVector, v); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[vectorSize]; Avx2.Store(temp, accVector); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { result += temp[j]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Saya meluncurkan patokan pada 4 metode ini di komputer saya dan mendapatkan hasil ini: </p><br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  ItemCount </th><th>  Median </th></tr></thead><tbody><tr><td>  Naif </td><td>  10 </td><td>  75,12 ns </td></tr><tr><td>  LINQ </td><td>  10 </td><td>  1 186,85 ns </td></tr><tr><td>  Vektor </td><td>  10 </td><td>  60,09 ns </td></tr><tr><td>  Intrinsik </td><td>  10 </td><td>  255.40 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naif </td><td>  100 </td><td>  360,56 ns </td></tr><tr><td>  LINQ </td><td>  100 </td><td>  2 719.24 ns </td></tr><tr><td>  Vektor </td><td>  100 </td><td>  60,09 ns </td></tr><tr><td>  Intrinsik </td><td>  100 </td><td>  345,54 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naif </td><td>  1000 </td><td>  1 847,88 ns </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  12 033.78 ns </td></tr><tr><td>  Vektor </td><td>  1000 </td><td>  240,38 ns </td></tr><tr><td>  Intrinsik </td><td>  1000 </td><td>  630,98 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naif </td><td>  10.000 </td><td>  18 403,72 ns </td></tr><tr><td>  LINQ </td><td>  10.000 </td><td>  102 489,96 ns </td></tr><tr><td>  Vektor </td><td>  10.000 </td><td>  7 316.42 ns </td></tr><tr><td>  Intrinsik </td><td>  10.000 </td><td>  3 365.25 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naif </td><td>  100.000 </td><td>  176 630,67 ns </td></tr><tr><td>  LINQ </td><td>  100.000 </td><td>  975 998,24 ns </td></tr><tr><td>  Vektor </td><td>  100.000 </td><td>  78 828.03 ns </td></tr><tr><td>  Intrinsik </td><td>  100.000 </td><td>  41 269,41 ns </td></tr></tbody></table></div><br><p>  Dapat dilihat bahwa solusi dengan Vektor dan Intrinsik jauh lebih cepat daripada solusi yang jelas dan dengan LINQ.  Sekarang kita perlu mencari tahu apa yang terjadi dalam kedua metode ini. </p><br><p>  Pertimbangkan metode Vektor secara lebih rinci: </p><br><div class="spoiler">  <b class="spoiler_title">Vektor</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); accVector = Vector.Add(accVector, v); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = Vector.Dot(accVector, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><ul><li>  int vectorSize = Vektor &lt;int&gt; .Count;  - ini adalah berapa banyak angka 4 byte yang dapat kita masukkan ke dalam vektor.  Jika akselerasi perangkat keras digunakan, nilai ini menunjukkan berapa banyak angka 4-byte dapat ditempatkan dalam satu register SIMD.  Bahkan, ini menunjukkan berapa banyak elemen jenis ini dapat dioperasikan secara paralel; </li><li>  accVector - vektor di mana hasil fungsi akan terakumulasi; <br>  var v = Vector baru &lt;int&gt; (array, i);  - data dimuat ke dalam vektor v baru, dari array, mulai dari indeks i.  Data vectorSize akan memuat. </li><li>  accVector = Vector.Add (accVector, v);  - dua vektor ditambahkan. <br>  Misalnya, 8 angka disimpan dalam Array: {0, 1, 2, 3, 4, 5, 6, 7} dan vectorSize == 4, lalu: <br>  Dalam iterasi pertama dari loop accVector = {0, 0, 0, 0}, v = {0, 1, 2, 3}, setelah penambahan dalam accVector akan menjadi: {0, 0, 0, 0} + {0, 1, 2 , 3} = {0, 1, 2, 3}. <br>  Dalam iterasi kedua, v = {4, 5, 6, 7} dan setelah penambahan accVector = {0, 1, 2, 3} + {4, 5, 6, 7} = {4, 6, 8, 10}. </li><li>  Tetap hanya untuk entah bagaimana mendapatkan jumlah semua elemen vektor, untuk ini kita dapat menerapkan perkalian skalar dengan vektor yang diisi dengan unit: int result = Vector.Dot (accVector, Vector &lt;int&gt; .One); <br>  Kemudian hasilnya: {4, 6, 8, 10} <em>{1, 1, 1, 1} = 4</em> 1 + 6 <em>1 + 8</em> 1 + 10 * 1 = 28. </li><li>  Pada akhirnya, jika diperlukan, maka angka ditambahkan yang tidak sesuai dengan vektor terakhir. </li></ul><br><p>  Jika Anda melihat kode metode Intrinsics: </p><br><div class="spoiler">  <b class="spoiler_title">Intrinsik</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector256&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = array) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = Avx2.LoadVector256(ptr + i); accVector = Avx2.Add(accVector, v); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[vectorSize]; Avx2.Store(temp, accVector); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { result += temp[j]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><p>  Anda dapat melihat bahwa ini sangat mirip dengan Vektor dengan beberapa pengecualian: </p><br><ul><li>  vectorSize diberikan oleh konstanta.  Ini karena instruksi Avx2 yang beroperasi pada register 256 bit secara eksplisit digunakan dalam metode ini.  Dalam aplikasi nyata, harus ada pemeriksaan untuk melihat apakah prosesor Avx2 saat ini mendukung instruksi dan, jika tidak, panggil kode lain.  Itu terlihat seperti ini: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.IsSupported) { DoThingsForAvx2(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx.IsSupported) { DoThingsForAvx(); } ... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Sse2.IsSupported) { DoThingsForSse2(); } ...</code> </pre> </li><li>  var accVector = Vector256 &lt;int&gt; .Zero;  accVector dinyatakan sebagai vektor 256 bit yang diisi dengan nol. </li><li>  fixed (int * ptr = Array) - pointer ke array dimasukkan dalam ptr. </li><li>  Kemudian operasi yang sama seperti di Vektor: memuat data ke dalam vektor dan menambahkan dua vektor. </li><li>  Untuk meringkas elemen-elemen vektor, metode berikut ini diterapkan: <br><ul><li>  sebuah array dibuat di stack: var temp = stackalloc int [vectorSize]; </li><li>  vektor dimuat ke dalam array ini: Avx2.Store (temp, accVector); </li><li>  dalam satu lingkaran elemen-elemen array dijumlahkan. </li></ul></li><li>  lalu elemen-elemen array yang tidak ditempatkan di vektor terakhir ditambahkan </li></ul><br><h2 id="sravnivaem-dva-massiva">  Bandingkan dua array </h2><br><p>  Perlu untuk membandingkan dua array byte.  Sebenarnya ini adalah masalah karena itu saya mulai belajar SIMD di .NET.  Sekali lagi, kami akan menulis beberapa metode untuk benchmark, kami akan membandingkan dua array: ArrayA dan ArrayB: </p><br><p>  Solusi paling jelas: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  Solusi melalui LINQ: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; ArrayA.SequenceEqual(ArrayB);</code> </pre> <br><p>  Solusi melalui fungsi MemCmp: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"msvcrt.dll"</span></span></span><span class="hljs-meta">, CallingConvention = CallingConvention.Cdecl)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memcmp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] b1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] b2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MemCmp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; memcmp(ArrayA, ArrayB, ArrayA.Length) == <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Menggunakan vektor dari System.Numerics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> va = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(ArrayA, i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(ArrayB, i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Vector.EqualsAll(va, vb)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  Menggunakan Intrinsik: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> equalsMask = <span class="hljs-keyword"><span class="hljs-keyword">unchecked</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (<span class="hljs-number"><span class="hljs-number">0b1111</span></span>_1111_1111_1111_1111_1111_1111_1111)); <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptrA = ArrayA) <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptrB = ArrayB) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> va = Avx2.LoadVector256(ptrA + i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vb = Avx2.LoadVector256(ptrB + i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Avx2.CompareEqual(va, vb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.MoveMask(areEqual) != equalsMask) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Hasil patokan di komputer saya: </p><br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  ItemCount </th><th>  Median </th></tr></thead><tbody><tr><td>  Naif </td><td>  10.000 </td><td>  66 719.1 ns </td></tr><tr><td>  LINQ </td><td>  10.000 </td><td>  71 211.1 ns </td></tr><tr><td>  Vektor </td><td>  10.000 </td><td>  3 695.8 ns </td></tr><tr><td>  Memcmp </td><td>  10.000 </td><td>  600,9 ns </td></tr><tr><td>  Intrinsik </td><td>  10.000 </td><td>  1 607,5 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naif </td><td>  100.000 </td><td>  588 633,7 ns </td></tr><tr><td>  LINQ </td><td>  100.000 </td><td>  651 191,3 ns </td></tr><tr><td>  Vektor </td><td>  100.000 </td><td>  34 659.1 ns </td></tr><tr><td>  Memcmp </td><td>  100.000 </td><td>  5 513,6 ns </td></tr><tr><td>  Intrinsik </td><td>  100.000 </td><td>  12,078.9 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naif </td><td>  1.000.000 </td><td>  5 637 293.1 ns </td></tr><tr><td>  LINQ </td><td>  1.000.000 </td><td>  6 622 666.0 ns </td></tr><tr><td>  Vektor </td><td>  1.000.000 </td><td>  777 974.2 ns </td></tr><tr><td>  Memcmp </td><td>  1.000.000 </td><td>  361 704,5 ns </td></tr><tr><td>  Intrinsik </td><td>  1.000.000 </td><td>  434 252,7 ns </td></tr></tbody></table></div><br><p>  Semua kode untuk metode ini, saya pikir, jelas, dengan pengecualian dua baris dalam Intrinsics: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Avx2.CompareEqual(va, vb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.MoveMask(areEqual) != equalsMask) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  Dalam yang pertama, dua vektor dibandingkan untuk kesetaraan dan hasilnya disimpan dalam vektor areEqual, di mana semua bit diatur ke 1 dalam elemen pada posisi tertentu jika elemen yang sesuai dalam va dan vb sama.  Ternyata jika vektor dari byte va dan vb benar-benar sama, maka dalam areEquals semua elemen harus sama dengan 255 (11111111b).  Karena  Avx2.CompareEqual adalah pembungkus di atas _mm256_cmpeq_epi8, maka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di situs web Intel</a> Anda dapat melihat kode semu dari operasi ini: <br>  Metode MoveMask dari vektor menghasilkan angka 32-bit.  Nilai bit adalah bit tinggi dari masing-masing 32 elemen byte tunggal dari vektor.  Kodesemu dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Jadi, jika beberapa byte dalam va dan vb tidak cocok, maka dalam areEqual byte yang sesuai akan menjadi 0, oleh karena itu bit yang paling signifikan dari byte ini juga akan 0, yang berarti bahwa bit yang sesuai dalam respons Avx2.MoveMask juga akan 0 dan perbandingan dengan equalsMask tidak akan berfungsi. </p><br><p>  Mari kita menganalisis contoh kecil, dengan asumsi bahwa panjang vektor adalah 8 byte (untuk menulis itu kurang): </p><br><ul><li>  Misalkan va = {100, 10, 20, 30, 100, 40, 50, 100}, dan vb = {100, 20, 10, 30, 100, 40, 80, 90}; </li><li>  Maka areEqual akan sama dengan {255, 0, 0, 255, 255, 255, 0, 0}; </li><li>  Metode MoveMask akan mengembalikan 10011100b, yang perlu dibandingkan dengan mask 11111111b, karena  Karena topeng ini tidak sama, ternyata vektor va dan vb tidak sama. </li></ul><br><h2 id="podschityvaem-skolko-raz-element-vstrechaetsya-v-kollekcii">  Hitung berapa kali suatu elemen muncul dalam koleksi </h2><br><p>  Terkadang perlu untuk menghitung berapa kali elemen tertentu ditemukan dalam koleksi, misalnya int, algoritma ini juga dapat dipercepat.  Mari kita menulis beberapa metode untuk perbandingan, kita akan mencari elemen Item dalam array Array. </p><br><p>  Yang paling jelas: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Array) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == Item) { result++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  menggunakan LINQ: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Array.Count(i =&gt; i == Item);</code> </pre> <br><p>  menggunakan vektor dari System.Numerics.Vectors: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mask = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(Item); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accResult = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Vector.Equals(v, mask); accResult = Vector.Subtract(accResult, areEqual); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array[i] == Item) { result++; } } result += Vector.Dot(accResult, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Menggunakan Intrinsik: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">//var mask = Avx2.SetAllVector256(Item); //var mask = Avx2.SetVector256(Item, Item, Item, Item, Item, Item, Item, Item); var temp = stackalloc int[vectorSize]; for (int j = 0; j &lt; vectorSize; j++) { temp[j] = Item; } var mask = Avx2.LoadVector256(temp); var accVector = Vector256&lt;int&gt;.Zero; int i; var array = Array; fixed (int* ptr = array) { for (i = 0; i &lt; array.Length - vectorSize; i += vectorSize) { var v = Avx2.LoadVector256(ptr + i); var areEqual = Avx2.CompareEqual(v, mask); accVector = Avx2.Subtract(accVector, areEqual); } } int result = 0; Avx2.Store(temp, accVector); for(int j = 0; j &lt; vectorSize; j++) { result += temp[j]; } for(; i &lt; array.Length; i++) { if (array[i] == Item) { result++; } } return result; }</span></span></code> </pre> <br><p>  Hasil patokan di komputer saya: </p><br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  ItemCount </th><th>  Median </th></tr></thead><tbody><tr><td>  Naif </td><td>  1000 </td><td>  2 824.41 ns </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  12 138,95 ns </td></tr><tr><td>  Vektor </td><td>  1000 </td><td>  961,50 ns </td></tr><tr><td>  Intrinsik </td><td>  1000 </td><td>  691.08 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naif </td><td>  10.000 </td><td>  27 072.25 ns </td></tr><tr><td>  LINQ </td><td>  10.000 </td><td>  113 967.87 ns </td></tr><tr><td>  Vektor </td><td>  10.000 </td><td>  7 571,82 ns </td></tr><tr><td>  Intrinsik </td><td>  10.000 </td><td>  4,296.71 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naif </td><td>  100.000 </td><td>  361 028.46 ns </td></tr><tr><td>  LINQ </td><td>  100.000 </td><td>  1.091.994,28 ns </td></tr><tr><td>  Vektor </td><td>  100.000 </td><td>  82 839.29 ns </td></tr><tr><td>  Intrinsik </td><td>  100.000 </td><td>  40 307,91 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naif </td><td>  1.000.000 </td><td>  1 634 175,46 ns </td></tr><tr><td>  LINQ </td><td>  1.000.000 </td><td>  6 194 257,38 ns </td></tr><tr><td>  Vektor </td><td>  1.000.000 </td><td>  583 901,29 ns </td></tr><tr><td>  Intrinsik </td><td>  1.000.000 </td><td>  413 520,38 ns </td></tr></tbody></table></div><br><p>  Metode Vektor dan Intrinsik sepenuhnya identik dalam logika, perbedaannya hanya dalam pelaksanaan operasi tertentu.  Idenya secara keseluruhan adalah: </p><br><ul><li>  vektor topeng dibuat di mana nomor yang diperlukan disimpan di setiap elemen; </li><li>  Bagian array dimasukkan ke dalam vektor v dan dibandingkan dengan mask, maka semua bit akan diatur dalam elemen yang sama di areEqual, karena  areEqual adalah vektor dari ints, maka jika Anda mengatur semua bit dari satu elemen, kita mendapatkan -1 pada elemen ini ((int) (1111_1111_1111_1111_1111_1111_1111_1111b) == -1); </li><li>  vektor areEqual dikurangi dari accVector dan kemudian accVector akan menjadi jumlah berapa kali elemen item terjadi di semua vektor v untuk setiap posisi (minus min memberi nilai tambah). </li></ul><br><p>  Semua kode dari artikel dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Saya memeriksa hanya sebagian kecil dari kemungkinan yang disediakan oleh .NET untuk perhitungan vektorisasi.  Untuk daftar intrinsik yang lengkap dan terkini di .NETCORE di bawah x86, Anda dapat merujuk ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode sumber</a> .  Sangat nyaman bahwa dalam file C # dalam ringkasan masing-masing intrinsik ada namanya sendiri dari dunia C, yang menyederhanakan pemahaman tentang tujuan intrinsik ini dan terjemahan dari algoritma C ++ / C yang ada ke .NET.  Dokumentasi System.Numerics.Vector tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">msdn</a> . </p><br><p>  Menurut pendapat saya, .NET memiliki keunggulan besar dibandingkan C ++, karena .NET  Kompilasi JIT sudah terjadi pada mesin klien, kompiler dapat mengoptimalkan kode untuk prosesor klien tertentu, memberikan kinerja maksimum.  Pada saat yang sama, seorang programmer untuk menulis kode cepat dapat tetap berada dalam kerangka satu bahasa dan teknologi. </p><br><p>  UPD (15/9/2019): </p><br><div class="spoiler">  <b class="spoiler_title">Ada patokan di tolok ukur</b> <div class="spoiler_text"><p>  Dalam benchmark, saya menggunakan IterationSetup, yang, ternyata, dapat sangat mempengaruhi kinerja benchmark yang bekerja dalam waktu kurang dari 100 ms.  Jika Anda mengulanginya di GlobalSetup, maka hasilnya akan seperti ini. </p><br><p>  Jumlah elemen array: </p><br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  ItemCount </th><th>  Berarti </th><th>  Kesalahan </th><th>  Stddev </th><th>  Rasio </th></tr></thead><tbody><tr><td>  Naif </td><td>  10 </td><td>  3,531 ns </td><td>  0,0336 ns </td><td>  0,0314 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10 </td><td>  76.925 ns </td><td>  0,4166 ns </td><td>  0,3897 ns </td><td>  21.79 </td></tr><tr><td>  Vektor </td><td>  10 </td><td>  2,750 ns </td><td>  0,0210 ns </td><td>  0,0196 ns </td><td>  0,78 </td></tr><tr><td>  Intrinsik </td><td>  10 </td><td>  6.513 ns </td><td>  0,0623 ns </td><td>  0,0582 ns </td><td>  1,84 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  100 </td><td>  47.982 ns </td><td>  0,3975 ns </td><td>  0,3524 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100 </td><td>  590.414 ns </td><td>  3,8808 ns </td><td>  3.4402 ns </td><td>  12.31 </td></tr><tr><td>  Vektor </td><td>  100 </td><td>  10.122 ns </td><td>  0,0747 ns </td><td>  0,0699 ns </td><td>  0,21 </td></tr><tr><td>  Intrinsik </td><td>  100 </td><td>  14.277 ns </td><td>  0,0566 ns </td><td>  0,0529 ns </td><td>  0,30 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  1000 </td><td>  569.910 ns </td><td>  2,8297 ns </td><td>  2.6469 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  5,658.570 ns </td><td>  31,7465 ns </td><td>  29.6957 ns </td><td>  9,93 </td></tr><tr><td>  Vektor </td><td>  1000 </td><td>  79.598 ns </td><td>  0,3498 ns </td><td>  0,3272 ns </td><td>  0,14 </td></tr><tr><td>  Intrinsik </td><td>  1000 </td><td>  66.970 ns </td><td>  0,3937 ns </td><td>  0,3682 ns </td><td>  0,12 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  10.000 </td><td>  5,637.571 ns </td><td>  37.5050 ns </td><td>  29.2814 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10.000 </td><td>  56.498.987 ns </td><td>  294.8776 ns </td><td>  275.8287 ns </td><td>  10.02 </td></tr><tr><td>  Vektor </td><td>  10.000 </td><td>  772.900 ns </td><td>  2,6802 ns </td><td>  2,5070 ns </td><td>  0,14 </td></tr><tr><td>  Intrinsik </td><td>  10.000 </td><td>  579.152 ns </td><td>  2,8371 ns </td><td>  2,6538 ns </td><td>  0,10 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  100.000 </td><td>  56.352.865 ns </td><td>  230.7916 ns </td><td>  215.8826 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100.000 </td><td>  562.610.571 ns </td><td>  3,775.7631 ns </td><td>  3,152.9332 ns </td><td>  9,98 </td></tr><tr><td>  Vektor </td><td>  100.000 </td><td>  8,389.647 ns </td><td>  165,9590 ns </td><td>  227.1666 ns </td><td>  0,15 </td></tr><tr><td>  Intrinsik </td><td>  100.000 </td><td>  7,261.334 ns </td><td>  89.6468 ns </td><td>  69,9903 ns </td><td>  0,13 </td></tr></tbody></table></div><br><p>  Membandingkan dua array: </p><br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  ItemCount </th><th>  Berarti </th><th>  Kesalahan </th><th>  Stddev </th><th>  Rasio </th></tr></thead><tbody><tr><td>  Naif </td><td>  10.000 </td><td>  7.033.8 ns </td><td>  50,636 ns </td><td>  47.365 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10.000 </td><td>  64.841,4 ns </td><td>  289.157 ns </td><td>  270.478 ns </td><td>  9.22 </td></tr><tr><td>  Vektor </td><td>  10.000 </td><td>  504.0 ns </td><td>  2,406 ns </td><td>  2,251 ns </td><td>  0,07 </td></tr><tr><td>  Memcmp </td><td>  10.000 </td><td>  368.1 ns </td><td>  2,637 ns </td><td>  2,466 ns </td><td>  0,05 </td></tr><tr><td>  Intrinsik </td><td>  10.000 </td><td>  283,6 ns </td><td>  1,135 ns </td><td>  1,061 ns </td><td>  0,04 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  100.000 </td><td>  85.214,4 ns </td><td>  903.868 ns </td><td>  845.478 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100.000 </td><td>  702.279,4 ns </td><td>  2,846.609 ns </td><td>  2,662.720 ns </td><td>  8.24 </td></tr><tr><td>  Vektor </td><td>  100.000 </td><td>  5,179.2 ns </td><td>  45.337 ns </td><td>  42.409 ns </td><td>  0,06 </td></tr><tr><td>  Memcmp </td><td>  100.000 </td><td>  4,510,5 ns </td><td>  24.292 ns </td><td>  22.723 ns </td><td>  0,05 </td></tr><tr><td>  Intrinsik </td><td>  100.000 </td><td>  2,957,0 ns </td><td>  11.452 ns </td><td>  10.712 ns </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  1.000.000 </td><td>  844,006,1 ns </td><td>  3,552.478 ns </td><td>  3,322.990 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  1.000.000 </td><td>  6,483.079,3 ns </td><td>  42.641.040 ns </td><td>  39.886.455 ns </td><td>  7.68 </td></tr><tr><td>  Vektor </td><td>  1.000.000 </td><td>  54.180.1 ns </td><td>  357.258 ns </td><td>  334.180 ns </td><td>  0,06 </td></tr><tr><td>  Memcmp </td><td>  1.000.000 </td><td>  49,480.1 ns </td><td>  515.675 ns </td><td>  457.133 ns </td><td>  0,06 </td></tr><tr><td>  Intrinsik </td><td>  1.000.000 </td><td>  36.633.9 ns </td><td>  680.525 ns </td><td>  636.564 ns </td><td>  0,04 </td></tr></tbody></table></div><br><p>  Jumlah kemunculan elemen dalam array: </p><br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  ItemCount </th><th>  Berarti </th><th>  Kesalahan </th><th>  Stddev </th><th>  Rasio </th></tr></thead><tbody><tr><td>  Naif </td><td>  10 </td><td>  8,844 ns </td><td>  0,0772 ns </td><td>  0,0603 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10 </td><td>  87.456 ns </td><td>  0,9496 ns </td><td>  0,8883 ns </td><td>  9,89 </td></tr><tr><td>  Vektor </td><td>  10 </td><td>  3,140 ns </td><td>  0,0406 ns </td><td>  0,0380 ns </td><td>  0,36 </td></tr><tr><td>  Intrinsik </td><td>  10 </td><td>  13.813 ns </td><td>  0,0825 ns </td><td>  0,0772 ns </td><td>  1.56 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  100 </td><td>  107.310 ns </td><td>  0,6975 ns </td><td>  0,6183 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100 </td><td>  626.285 ns </td><td>  5.7677 ns </td><td>  5.3951 ns </td><td>  5.83 </td></tr><tr><td>  Vektor </td><td>  100 </td><td>  11.844 ns </td><td>  0,2113 ns </td><td>  0,1873 ns </td><td>  0,11 </td></tr><tr><td>  Intrinsik </td><td>  100 </td><td>  19.616 ns </td><td>  0,1018 ns </td><td>  0,0903 ns </td><td>  0,18 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  1000 </td><td>  1.032.466 ns </td><td>  6.3799 ns </td><td>  5.6556 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  6,266.605 ns </td><td>  42,6585 ns </td><td>  39,9028 ns </td><td>  6.07 </td></tr><tr><td>  Vektor </td><td>  1000 </td><td>  83,417 ns </td><td>  0,5393 ns </td><td>  0,4780 ns </td><td>  0,08 </td></tr><tr><td>  Intrinsik </td><td>  1000 </td><td>  88,358 ns </td><td>  0,4921 ns </td><td>  0,4603 ns </td><td>  0,09 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  10.000 </td><td>  9,942.503 ns </td><td>  47.9732 ns </td><td>  40.0598 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10.000 </td><td>  62.305.598 ns </td><td>  643.8775 ns </td><td>  502.6972 ns </td><td>  6.27 </td></tr><tr><td>  Vektor </td><td>  10.000 </td><td>  914.967 ns </td><td>  7.2959 ns </td><td>  6.8246 ns </td><td>  0,09 </td></tr><tr><td>  Intrinsik </td><td>  10.000 </td><td>  931.698 ns </td><td>  6.3444 ns </td><td>  5.9346 ns </td><td>  0,09 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  100.000 </td><td>  94.834.804 ns </td><td>  793.8585 ns </td><td>  703.7349 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100.000 </td><td>  626.620.968 ns </td><td>  4,696.9221 ns </td><td>  4,393.5038 ns </td><td>  6.61 </td></tr><tr><td>  Vektor </td><td>  100.000 </td><td>  9,000.827 ns </td><td>  179.5351 ns </td><td>  192.1005 ns </td><td>  0,09 </td></tr><tr><td>  Intrinsik </td><td>  100.000 </td><td>  8,690.771 ns </td><td>  101.7078 ns </td><td>  95.1376 ns </td><td>  0,09 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naif </td><td>  1.000.000 </td><td>  959.302.249 ns </td><td>  4,268.2488 ns </td><td>  3,783.6914 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  1.000.000 </td><td>  6.218.681.888 ns </td><td>  31.321.9277 ns </td><td>  29.298.5506 ns </td><td>  6.48 </td></tr><tr><td>  Vektor </td><td>  1.000.000 </td><td>  99.778.488 ns </td><td>  1,975.6001 ns </td><td>  4,252.6877 ns </td><td>  0,10 </td></tr><tr><td>  Intrinsik </td><td>  1.000.000 </td><td>  96.449.350 ns </td><td>  1,171.8067 ns </td><td>  978.5116 ns </td><td>  0,10 </td></tr></tbody></table></div></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435840/">https://habr.com/ru/post/id435840/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435828/index.html">Matematika di Gamedev sederhana. Kurva dan riak kesatuan untuk efek hujan</a></li>
<li><a href="../id435830/index.html">OMEGA - Otomasi waktu acara olahraga</a></li>
<li><a href="../id435834/index.html">UJIAN - Metode klasifikasi teks tercanggih</a></li>
<li><a href="../id435836/index.html">Perusahaan-perusahaan terbesar di Wall Street setuju untuk meluncurkan pertukaran baru untuk bersaing dengan Nasdaq dan NYSE</a></li>
<li><a href="../id435838/index.html">Fungsi malas JavaScript</a></li>
<li><a href="../id435842/index.html">Membuat model game 3D untuk kaum miskin: Indie Way</a></li>
<li><a href="../id435846/index.html">Konferensi dan hackathon untuk anak sekolah dan siswa: 11 acara tematik</a></li>
<li><a href="../id435848/index.html">Perangkat dan teknologi baru dengan CES 2019 dari Microsoft dan mitra</a></li>
<li><a href="../id435854/index.html">Catatan seorang phytochemist. Radio pisang</a></li>
<li><a href="../id435856/index.html">Antivirus apa yang digunakan di firewall modern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>