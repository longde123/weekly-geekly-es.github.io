<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õé ‚úçüèº üì§ Spielen mit Threads in Node.JS 10.5.0 üë®üèΩ‚ÄçüöÄ üè© üìÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag 
  
 Bei meiner Arbeit kam es zu einem Streit zwischen mir und den verbundenen Unternehmen √ºber die Threads in der neuen Version von Node.JS...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spielen mit Threads in Node.JS 10.5.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416015/"><h3>  Guten Tag </h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/3m/zt/sb/3mztsbwdikwbzsiwvboih0n979s.jpeg"></a> <br>  Bei meiner Arbeit kam es zu einem Streit zwischen mir und den verbundenen Unternehmen √ºber die Threads in der neuen Version von Node.JS und die Notwendigkeit, sie zu synchronisieren.  Zun√§chst haben wir uns entschieden, parallel Zeilen in die Datei zu schreiben.  Das Thema mit worker_threads ist hei√ü, bitte unter cat. <br><a name="habracut"></a><br>  Ein wenig √ºber die B√§che selbst.  Es handelt sich um experimentelle Technologie in Node.JS 10.5.0. Um auf das Modul "worker_threads" zugreifen zu k√∂nnen, m√ºssen Sie unsere Node.JS-Anwendung mit dem Flag "--experimental-worker" ausf√ºhren.  Ich habe dieses Flag im Startskript in der Datei package.json registriert: <br><pre><code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"worker-test"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"app.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node --max-old-space-size=4096 --experimental-worker app.js "</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ISC"</span></span> }</code> </pre> <br>  Nun zur Logik selbst.  Der Hauptthread erzeugt N Arbeitsthreads, die alle in einem bestimmten Intervall in die Datei schreiben.  Im Gegensatz zu allen Beispielen, bei denen der Haupt- und der untergeordnete Stream von einer Datei ausgehen, habe ich die Streams in einen separaten getrennt. Dies scheint mir sauberer und eleganter zu sein. <br><br>  Eigentlich der Code. <br><br>  Die Hauptdatei app.js ist der Einstiegspunkt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Worker } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WORKERS_NUMBER = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello from main!'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= WORKERS_NUMBER ; i++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> w = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker(path.join(__dirname, <span class="hljs-string"><span class="hljs-string">'./writer-worker-app/app.js'</span></span>), { <span class="hljs-attr"><span class="hljs-attr">workerData</span></span>: { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: i } }); }</code> </pre> <br>  Hier erstellen wir einfach untergeordnete Streams mit der Worker-Klasse und geben den Pfad zur Startdatei f√ºr den Stream './writer-worker-app/app.js' an.  Beim Erstellen des Streams √ºbertragen wir den selbstgeschriebenen Bezeichner als WorkerData-Daten. <br><br>  Datei f√ºr Stream starten ./writer-worker-app/app.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { workerData, parentPort } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> logger = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./logger'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> id = workerData.id; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Worker </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${id}</span></span></span><span class="hljs-string"> initializad.`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { sendMessage(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ logger.log(<span class="hljs-string"><span class="hljs-string">`Hello from worker number </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${workerData.id}</span></span></span><span class="hljs-string">\r\n`</span></span>); }</code> </pre><br><br>  Nun, die einfachste Logger-Klasse: ./writer-worker-app/logger.js <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fs.appendFileSync(<span class="hljs-string"><span class="hljs-string">'./my-file.txt'</span></span>, message); } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { log };</code> </pre><br>  Als wir diese Anwendung starteten, hofften wir alle, dass wir am Ende etwas Unordnung in der Datei bekommen w√ºrden und die Spender schreien w√ºrden, wie wichtig Sperren mit Semaphoren und anderen Freuden der parallelen Ausf√ºhrung sind.  Aber nein!  In der Datei werden alle Zeilen ohne Unterbrechung angezeigt, au√üer in zuf√§lliger Reihenfolge: <br><br> <code>Hello from worker number 14 <br> Hello from worker number 3 <br> Hello from worker number 9 <br> Hello from worker number 15 <br> Hello from worker number 2 <br> Hello from worker number 4 <br> Hello from worker number 7 <br> Hello from worker number 6 <br> Hello from worker number 1 <br> Hello from worker number 11 <br></code> <br>  Ein wunderbares Experiment, ein weiterer kleiner Sieg f√ºr Noda :-) Ich gehe davon aus, dass die gesamte Synchronisation auf der E / A-Ebene der Noda-Flows erfolgt, aber ich bin froh, die richtige Option in den Kommentaren zu kennen.  Nur f√ºr den Fall, dass wir die Arbeit nicht mit <b>fs.appendFileSync</b> , sondern mit <b>fs.createWriteStream</b> und der <b>stream.write-</b> Methode <b>√ºberpr√ºft haben</b> . <br><br>  Das Ergebnis war das gleiche. <br><br><h3>  Aber wir haben hier nicht aufgeh√∂rt. </h3><br>  Ein Kollege schlug die Aufgabe vor, Threads zu synchronisieren.  In unserem speziellen Beispiel ist es die Aufgabe, nacheinander in aufsteigender Reihenfolge der Bezeichner in eine Datei zu schreiben.  Schreibt zuerst den ersten Stream, dann den zweiten, dann den dritten und so weiter. <br><br>  Zu diesem Zweck habe ich einen weiteren Thread-Manager eingef√ºhrt.  Es war m√∂glich, mit der Hauptsache auszukommen, aber ich freue mich sehr, diese isolierten Arbeiter zu schaffen und die Kommunikation durch Botschaften aufzubauen.  Bevor Sie mit der Implementierung des Stream-Managers beginnen, m√ºssen Sie einen Kommunikationskanal zwischen ihm und den Autoren erstellen.  <b>Hierf√ºr</b> wurde die <b>MessageChannel-</b> Klasse verwendet.  Die Instanzen dieser Klasse haben zwei Felder: <b>port1</b> und <b>port2</b> , von denen jedes mit den <b>Methoden .on ('message')</b> und <b>.postMessage ()</b> Nachrichten abh√∂ren und an den anderen senden <b>kann</b> .  Diese Klasse wurde als Teil des Moduls "worker_threads" f√ºr die Kommunikation zwischen Threads erstellt, da ein √ºbertragenes Objekt normalerweise einfach geklont wird und in einer isolierten Thread-Ausf√ºhrungsumgebung unbrauchbar ist. <br><br>  F√ºr die Kommunikation zwischen zwei Flows m√ºssen wir jedem einen Port geben. <br><br>  <b>Eine interessante Tatsache</b> : Bei 10.5.0 ist <u>es unm√∂glich, den Port durch den Konstruktor des Workers zu √ºbergeben</u> . Sie m√ºssen dies nur √ºber worker.postMessage () tun und den Port im Parameter transferList angeben! <br><br>  Der Thread-Manager selbst sendet Befehle in aufsteigender Reihenfolge ihrer Bezeichner an die Writer-Threads und sendet den n√§chsten Befehl erst, nachdem er vom Writer eine Antwort √ºber den erfolgreichen Vorgang erhalten hat. <br><br>  Under-UML-Anwendungsdiagramm: <br><img src="https://habrastorage.org/webt/os/rq/nl/osrqnlydmppapio9ubdba_0yrea.jpeg"><br><br>  Unsere mutierte Hauptdatei ./app.js: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Worker, MessageChannel } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WORKERS_NUMBER = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Main app initialized and started.'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> workersMeta = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= WORKERS_NUMBER; i++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> channel = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessageChannel(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> worker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker(path.join(__dirname, <span class="hljs-string"><span class="hljs-string">'./writer-worker-app/app.js'</span></span>), { <span class="hljs-attr"><span class="hljs-attr">workerData</span></span>: { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: i } }); workersMeta.push({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: i, worker, channel }); } workersMeta.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ worker, channel }</span></span></span><span class="hljs-function">) =&gt;</span></span> { worker.postMessage({ <span class="hljs-attr"><span class="hljs-attr">orchestratorPort</span></span>: channel.port1 }, [channel.port1]); }) setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> orchestrator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker(path.join(__dirname, <span class="hljs-string"><span class="hljs-string">'./orchestrator-worker-app/app.js'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> orchestratorData = workersMeta.map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">meta</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: meta.id, <span class="hljs-attr"><span class="hljs-attr">port</span></span>: meta.channel.port2 })); orchestrator.postMessage({ <span class="hljs-attr"><span class="hljs-attr">workerPorts</span></span>: orchestratorData }, orchestratorData.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">w</span></span></span><span class="hljs-function"> =&gt;</span></span> w.port)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'All worker threads have been initialized'</span></span>); }, WORKERS_NUMBER * <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><br>  Hier erstellen wir zuerst Worker, dann senden wir jedem Port einen Port f√ºr die Kommunikation mit dem Manager (und nur so ist es √ºber den Konstruktor unm√∂glich, dies zu tun). <br><br>  Dann erstellen wir einen Thread-Manager und senden ihm eine Liste von Ports f√ºr die Kommunikation mit Writer-Flows. <br>  <b>Aktualisiert</b> : empirisch habe ich herausgefunden, dass es bei der Arbeit mit Streams besser ist, sie zuerst brauen zu lassen (nach Bedarf initialisieren).  F√ºr immer war es notwendig, einige Antworten aus den Fl√ºssen im Stil von ‚ÄûIch bin bereit!‚Äú Zu h√∂ren, aber ich entschied mich f√ºr den einfacheren Weg. <br><br>  Wir werden auch das Verhalten des Writer-Threads so √§ndern, dass er nur dann eine Nachricht sendet, wenn er dazu aufgefordert wird, und das Ergebnis auch zur√ºckgibt, wenn der Schreibvorgang abgeschlossen ist: <br>  ./writer-worer-app/app.js <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { workerData, parentPort } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> logger = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./logger'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> id = workerData.id; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Worker </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${id}</span></span></span><span class="hljs-string"> initializad.`</span></span>); parentPort.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, value =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> orchestratorPort = value.orchestratorPort; orchestratorPort.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, data =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.command == <span class="hljs-string"><span class="hljs-string">'write'</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Worker </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${id}</span></span></span><span class="hljs-string"> received write command`</span></span>); sendMessage(); sendResult(orchestratorPort); } }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Worker </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${id}</span></span></span><span class="hljs-string"> started.`</span></span>); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ logger.log(<span class="hljs-string"><span class="hljs-string">`Hello from worker number </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${workerData.id}</span></span></span><span class="hljs-string">\r\n`</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">port</span></span></span><span class="hljs-function">) </span></span>{ port.postMessage({ id, <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'completed'</span></span> }); }</code> </pre><br>  Wir haben aus der Nachricht des √ºbergeordneten Streams korrekt initialisiert und den Kanal des Stream-Managers gestartet. Wenn wir den Befehl erhalten, schreiben wir zuerst in die Datei und senden dann das Ergebnis.  Es ist zu beachten, dass die Datei synchron geschrieben wird, sodass sendResult () unmittelbar nach sendMessage () aufgerufen wird. <br><br>  Alles was bleibt ist, die Implementierung unseres intelligenten Managers zu schreiben <br>  ./orchestrator-worker-app/app.js: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { parentPort } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Orchestrator initialized.'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> workerPorts; parentPort.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, (value) =&gt; { workerPorts = value.workerPorts; workerPorts.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">wp</span></span></span><span class="hljs-function"> =&gt;</span></span> wp.port.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, handleResponse)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Orchestrator started.'</span></span>); sendCommand(workerPorts[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleResponse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">status</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responseWorkerId = status.id; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nextWorker = workerPorts.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">wp</span></span></span><span class="hljs-function"> =&gt;</span></span> wp.id == responseWorkerId + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!nextWorker) { nextWorker = workerPorts[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } sendCommand(nextWorker); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendCommand</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">worker</span></span></span><span class="hljs-function">) </span></span>{ worker.port.postMessage({ <span class="hljs-attr"><span class="hljs-attr">command</span></span>: <span class="hljs-string"><span class="hljs-string">'write'</span></span> }); }</code> </pre><br>  Wir haben eine Liste der geordneten Ports erhalten, f√ºr jeden Port einen R√ºckruf auf die Antwort gesetzt und den Befehl an den ersten gesendet.  Im R√ºckruf selbst suchen wir den n√§chsten Schreiber und senden ihm einen Befehl.  Um das System nicht zu stark zu belasten, wurde das Intervall zwischen den Teams festgelegt. <br><br>  Das war's, unsere Multithread-Thread-Management-Anwendung ist fertig.  Wir haben gelernt, in Node.JS nicht nur Worker-Flows zu generieren, sondern auch effektive Kommunikationswege zwischen ihnen zu schaffen.  Meiner pers√∂nlichen Meinung nach ist die Architektur isolierter Threads in Node.JS mit Warten und Senden von Nachrichten mehr als praktisch und vielversprechend.  Vielen Dank f√ºr Ihre Aufmerksamkeit. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Den gesamten Quellcode finden Sie hier</a> . <br><br><h3>  UPDATE </h3><br>  Um die Leser nicht irrezuf√ºhren und auch keine unn√∂tigen Gr√ºnde f√ºr das Schreiben anzugeben, dass ich mit Timeouts betr√ºge, habe ich den Artikel und das Repository aktualisiert. <br>  √Ñnderungen: <br>  1) Die Intervalle in den urspr√ºnglichen Autoren werden entfernt, w√§hrend (true) den Hardcore durchl√§uft <br>  2) --max-old-space-size = 4096 Flag hinzugef√ºgt, nur f√ºr den Fall, weil  Die aktuelle Implementierung der Streams ist nicht sehr stabil und ich hoffe das hilft irgendwie. <br>  3) Die Intervalle zum Senden von Nachrichten vom Thread-Manager wurden gel√∂scht.  Jetzt ist die Aufnahme ohne Unterbrechung. <br>  4) Bei der Initialisierung des Managers wurde ein Timeout hinzugef√ºgt, warum - es ist oben beschrieben. <br><br>  ZU TUN: <br>  1) Nachrichten mit variabler L√§nge hinzuf√ºgen oder den Anruf des Loggers z√§hlen - danke FANAT1242 <br>  2) F√ºgen Sie einen Benchmark hinzu, vergleichen Sie die Arbeit der ersten und zweiten Version (wie viele Zeilen werden beispielsweise in 10 Sekunden geschrieben) <br><br><h3>  UPDATE 2 </h3><br>  1) Der Protokollierungscode wurde ge√§ndert: Jetzt hat jede Nachricht eine andere L√§nge. <br>  2) Writer-worker-app / app.old.js wurde ge√§ndert: Jeder Thread schreibt 1000 Mal und wird dann beendet. <br><br>  Dies wurde durchgef√ºhrt, um die Ideen des FANAT1242-Benutzers zu testen.  Nachrichten schreiben sich trotzdem nicht neu, die Zeilen in der Datei sind genau 1000 * N Threads. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416015/">https://habr.com/ru/post/de416015/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416005/index.html">16 Reaktionstools f√ºr Schnittstellenentwickler</a></li>
<li><a href="../de416007/index.html">Fast kompliziert. Der Beginn der Schaffung eines drahtlosen "Smart Home". Basierend auf Linux-Technologie, Z-Wave- und MajorDoMo-Software</a></li>
<li><a href="../de416009/index.html">Probieren Sie Kaninchenkot, er ist kr√§ftig und f√§ngt - Extrakte in der Pharmakologie</a></li>
<li><a href="../de416011/index.html">BIF-Muster: Sauberer Front-End-Code und bequemes Arbeiten mit Serverdaten</a></li>
<li><a href="../de416013/index.html">So fangen Sie an zu investieren und Geld zu sparen: Die Experten von Dow Jones nannten die f√ºnf Hauptfehler von Anf√§ngern</a></li>
<li><a href="../de416017/index.html">Wir sammeln Kohortenanalyse / Analyse von Fl√ºssen am Beispiel von Excel</a></li>
<li><a href="../de416019/index.html">Wie gut ist das Open-Source-√ñkosystem von R f√ºr die L√∂sung von Gesch√§ftsproblemen?</a></li>
<li><a href="../de416021/index.html">Entwickeln Sie Ihr eigenes Framework und das berufliche Wachstum eines JS-Programmierers</a></li>
<li><a href="../de416023/index.html">Wie iOS 'Spitzname Telegram Bot schrieb, auf Swift</a></li>
<li><a href="../de416025/index.html">Implementieren der Navigation in Android-Anwendungen mithilfe der Navigationsarchitekturkomponente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>