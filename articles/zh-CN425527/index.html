<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💋 👻 💰 在Kotlin列出。 Haskell方法 👨‍👦 ☮️ ♑️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haskell是功能齐全且非常简洁的语言。 任何曾经尝试用Haskell编写代码的人都会注意到，与用命令式语言编写相同的东西相比，它简洁而优雅。 在我看来，在Java中实现相同目标是不可能的，但是Kotlin允许您朝这个方向发展，并尝试使用功能齐全的样式。 我们可以从3个最著名的函数的开始基础上得出...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Kotlin列出。 Haskell方法</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425527/">  Haskell是功能齐全且非常简洁的语言。 任何曾经尝试用Haskell编写代码的人都会注意到，与用命令式语言编写相同的东西相比，它简洁而优雅。 在我看来，在Java中实现相同目标是不可能的，但是Kotlin允许您朝这个方向发展，并尝试使用功能齐全的样式。 我们可以从3个最著名的函数的开始基础上得出我们可能需要的所有复杂函数：map，filter，reduce。 另外，我创建了一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">存储库</a> ，您可以研究和查看测试。 <br><a name="habracut"></a><br> 在开始之前，我想提一下一个事实，那就是不值得以这种方式来实现功能性方法，因为代码将严重缓慢并且不应在生产应用程序中使用。 当然有改进它的选项，但是本文的目的不是公开这些选项，而是考虑一种替代的编写代码的方法。 无论如何，了解这种方法将有助于您使用递归数据结构，并且您可能会欣赏到代码的读取方式和理解的容易程度。 <br><br><h3> 基本功能 </h3><br> 列表在该语言中起着非常重要的作用，并且为此实现了许多有用的功能。 让我们看看其中的一些，以及如何在Kotlin上实现它们。 <br><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">head</span></span> (x:_) = x head [] = badHead</code> </pre> <br> 如果列表中有元素，则将返回第一个，否则将返回错误。 <br> 我们没有机会编写这样的代码，但是总的来说，如果仔细观察，它与模板时非常相似。 我们还将使用扩展功能，以便以后能够在列表上使用此方法，并且有一种更简洁的获取值的方法，而不是像方法调用一样，在末尾没有方括号。 <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> &lt;T&gt; List&lt;T&gt;.head: T <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> NoSuchElementException(<span class="hljs-string"><span class="hljs-string">"List is empty."</span></span>) <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] }</code> </pre><br> 为了方便使用递归，我们还希望将列表拆分为第一个元素+所有其他元素。 让我们尝试为此实现tail函数。 <br><br> 这是haskell上的样子： <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">tail</span></span> (_:xs) = xs tail [] = errorEmptyList <span class="hljs-string"><span class="hljs-string">"tail"</span></span></code> </pre><br> 不幸的是，Kotlin没有提供开发人员可以用相同样式描述的这种模式匹配级别，因此在这里我们不得不写点时间。 <br><br><pre> <code class="hljs xml">val <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>.tail: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> get() = drop(1)</code> </pre><br> 使用语言库中的函数有点不诚实，但另一方面，无论如何，我们都必须为此方法编写代码，因此最好使用已经可以使用的方法。 <br><br> 现在我们可以将列表划分为第一个元素+列表的其余部分。 我们还需要将列表和一个元素连接在一起的功能，稍后将在列表中进行转换和其他操作时使用这些元素。 <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: List&lt;T&gt; = ArrayList(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).also { it.add(x) }</code> </pre><br> 现在，我们可以在元素的末尾添加一个列表，并且我们的map函数实现可以正常使用了。 不幸的是，再也没有办法以任何更方便的方式将对象添加到列表中，因此我们使用<b>add</b>方法。 <br><br> 目前，我们几乎拥有所需的一切。 现在我们唯一需要的是能够描述退出递归的边界条件。 为此，我们将使用标准的<b>isEmpty（）</b>方法。 让我们停下来看看现在我们有什么： <br><br><ul><li>  isEmpty（）-列表中是否有任何元素 </li><li>  head-列表的第一个元素 </li><li>  tail-没有第一个元素的列表 </li><li>  list +元素-我们可以将列表与对象连接 </li></ul><br> 实际上，这就是我们需要的所有方法所需要的。 <br> 以我的口味，在<b>when</b>语句中使用列表长度比较会更方便。  Kotlin已经为我们提供了<b>尺寸</b> ，以获取此列表的长度。 但是，假设我们要自己实现它。 使用我们的功能，将非常简单： <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> &lt;T&gt; List&lt;T&gt;.size: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tail.size }</code> </pre><br><h3> 基本功能的应用 </h3><br> 考虑最常见的例子。 假设我们有一个整数列表，我们想将它们加起来，而忽略循环的存在。 我们所拥有的就是上面派生的方法和递归。 为此，我们将使用与计算列表大小时相同的方法： <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; xs.head + sum(xs.tail) }</code> </pre><br> 这个想法很简单：如果列表中没有元素，则总和为0；否则为0。 否则，它是第一个元素的和与尾部的和的递归调用。 <br><br> 尽管我们并不关心此代码中的速度和优化，但我们不禁会想起该语言使用尾部递归的功能。 尾递归是递归的一种特殊情况，其中递归调用是从函数返回之前的最后一个操作。 这种递归是值得注意的，因为可以保证允许您重建代码以进行迭代。 如您所知，递归的主要问题是在执行函数期间必须存储调用堆栈，以便在达到边界条件时可以返回并重新计算最终结果。 <br><br> 似乎我们描述的金额的函数就是这样，因为最后一次调用是<b>sum（xs.tail）</b> 。 但是，事实并非如此。 如果您对代码进行一些不同的描述，它将变得显而易见： <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> head = xs.head <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tailSum = sum(xs.tail) head + tailSum } }</code> </pre><br> 现在我们看到，实际上最后一次调用是第一个元素与尾部其余部分的和。 <br><br> 好消息是，如果将<b>tailrec</b>修饰符添加到函数中，IDE会告诉您该函数不是。 但是，解决此问题非常简单。 纠正函数的常见技巧是使用辅助变量来存储结果。 看起来像这样： <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">tailrec</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, acum: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; acum <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; sum(xs.tail, xs.head + acum) }</code> </pre><br> 为了计算元素的总和，只需将0作为第二个参数传递，并且要使其完全惯用，我们将重做一些功能，将主要计算隐藏在内部函数中，而外部世界无需访问该参数即可不需要。 <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>:<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">tailrec</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumInner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, acum: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; acum <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; sumInner(xs.tail, xs.head + acum) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sumInner(xs, <span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre><br> 有了这些知识，您可以看到我们上面实现的size函数不满足尾递归的必要条件。 <br><br> 现在我们已经准备好使用Kotlin来实现地图，过滤，精简。 稍后我们将看到仅实现后者就足够了，其余的通常是后者的派生。 但是首先是第一件事。 <br><br><h3> 主要功能 </h3><br><h4> 地图 </h4><br> 此函数的迭代实现涉及使用转换函数在列表中进行顺序移动，并将所有接收到的元素添加到新集合中。 我们将使用边界条件为空列表的递归调用。 然后，实现将如下所示： <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; R): List&lt;R&gt; = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; listOf() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; f(head) + tail.map(f) }</code> </pre><br> 如果原始列表中没有元素，则返回一个空列表，否则，将转换应用于第一个元素，并在列表的其余部分末尾添加一个递归调用。 <br><br> 但是，我们仍然没有连接元素和列表的功能。 但是我们已经意识到了。 首先，我们得出了连接一对列表的更一般的情况，然后使用它为元素添加另一个列表。 <br><br><pre> <code class="hljs xml">operator fun <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>.plus(xs: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>): List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> = when (xs.size) { 0 -&gt; ArrayList(this) else -&gt; (this + xs.head) + xs.tail } operator fun <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> T.plus(xs: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>): List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> = listOf(this) + xs</code> </pre><br><h4> 筛选条件 </h4><br> 实现将非常类似于map。 唯一的区别是您需要了解是否需要将当前元素添加到结果中。 为此，我们将调用作为参数接收的lambda。 该实现将如下所示： <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>): List&lt;T&gt; = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; listOf() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f(head)) head + tail.filter(f) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> tail.filter(f) }</code> </pre><br> 如果当前元素满足过滤条件，则将其递归添加到列表的尾部；否则，我们将继续仅使用列表的尾部。 <br><br><h4> 减少 </h4><br> 最难理解的功能，同时也是最强大的功能（在功能世界中，它被称为<b>fold</b> ）。 通常，它用于将列表折叠为单个项目。 您有一个确定的起始值<b>s0</b> ，还有一个元素列表<b>a []</b>和一个函数<b>f</b> ，该函数为该列表的起始值和下一个元素返回一个新值。  <b>f（s0，a [0]）= s1</b> 。 因此，我们依次浏览了整个元素列表，并在输出中获得了某种单一值。 一个相当常见的示例是数组元素的总和。 在这种情况下，起始值为0，该函数返回两个元素的和： <b>f（s，a [i]）= s + a [i]</b> 。 考虑一下我们如何递归实现此功能。 <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; T): T = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; s <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; reduce(f(s, xs.head), xs.tail, f) }</code> </pre><br> 原则上，实现与我们上面回顾的完全相同。 如果列表中没有元素，则返回当前值，否则，我们计算新的第一个元素，然后再次为其调用reduce函数以及列表的尾部。 <br><br> 请注意，我们也可以对此功能进行修改。 例如，不要传递起始值，而是为此使用列表的第一个元素。 要了解reduce并不止于此，请想象我们使用其他列表作为起始值。 在这种情况下，每次迭代时，我们将不存储一个值，而是存储一个列表，因此，我们的功能将大大增加。 例如，让我们尝试以某种方式应用reduce函数，使输出为原始列表： <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduceSame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = reduce(listOf&lt;T&gt;(), xs) { ys, s -&gt; ys + s }</code> </pre><br> 现在，我想，您猜想我们可以使用reduce作为map的替代实现filter。 由于我们学会了使用reduce返回完全相同的列表，因此我们只需进行很少的更改即可转换每个元素。 对于过滤器，一切都非常相似。 <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; R): List&lt;R&gt; = reduce(mutableListOf(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { xs, s -&gt; (xs + f(s)).toMutableList() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>): List&lt;T&gt; = reduce(mutableListOf(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { ys, s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f(s)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span><span class="hljs-symbol"><span class="hljs-symbol">@reduce</span></span> (ys + s).toMutableList() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ys }</code> </pre><br> 另外，他们经常忘记我们也可以不从列表的开头而是从结尾使用reduce。 当然，我们可以扩展列表，然后应用reduce，但这并不有趣。 让我们尝试编写和理解reduce如何以相反的顺序折叠列表。 <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduceRight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; T): T = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; s <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; f(reduceRight(s, xs.tail, f), xs.head) }</code> </pre><br> 如果列表不为空，则将函数f应用于折叠列表尾部和列表首部的结果。 因此，第一个元素将最后处理； 倒数第二-第二等。 对于此选项，您还可以添加将列表的最后一个元素用作起始值等的修改。 <br><br> 几乎总是，在使用列表时，可以结合使用这3个功能来获得您感兴趣的结果。 <br><br> 我们还实现<b>zip</b>功能，该功能将允许我们组合2个列表。 <br> 在入口处，我们得到2张清单。 我们想返回一个长度等于原始列表的最小对的列表。 <br><br> 和往常一样，您需要考虑退出递归并编写一个函数。 <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, ys: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: List&lt;Pair&lt;T, R&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.isEmpty() || ys.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; listOf() <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; Pair(xs.head, ys.head) + zip(xs.tail, ys.tail) } }</code> </pre><br> 您可以添加自己的修改，这将使您不必将一对元素应用于两个元素，而无需返回一对元素。 在Haskell中，此函数称为<b>zipWith</b> 。 它是通过我们非常简单地编写的功能实现的： <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R, C&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, ys: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; C): List&lt;C&gt; = zip(xs, ys).map { f(it.first, it.second) }</code> </pre><br> 通常，在使用功能方法时，当您需要不基于列表中的对象而是基于索引执行操作时，会出现问题。 例如，我们需要对列表的所有偶数元素求和。 您可以尝试通过reduce来实现这一点，将当前值保持为Pair &lt;Int，Boolean&gt;并在flag == true时添加该值，并在每次执行下一步时取负标志。 但是，这看起来不太漂亮，读者必须弄清楚您要用此代码表达的内容。  Kotlin具有无限的序列，对于解决此问题非常有用。 如果我们分析我们想做的事情，结果是我们想过滤掉所有具有奇数索引的元素，并对其余元素求和。 并且为了能够获取索引，只需为列表和<b>序列</b> [0,1,2 ..]调用<b>zip</b>就足够了。 <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumWithEvenIndexes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = zip(xs, generateSequence(<span class="hljs-number"><span class="hljs-number">0</span></span>) { it + <span class="hljs-number"><span class="hljs-number">1</span></span> }.take(xs.size).toList()) .filter { it.second % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> } .map { it.first } .sum()</code> </pre><br> 在Kotlin标准库中，您可以找到序列对的zip函数。 <br><br> 现在，让我们看一个简单的难题，它启发了我编写本指南，以及在Kotlin中以及在Haskell的末尾用命令式语言实现的实现方式。 <br><br> 必须计算整数数组中成对的相邻数字之间的最大数量。 数组的长度大于1，您不必担心求和元素时会溢出。 <br><br> 命令式Java方法： <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maxSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Integer&gt; array)</span></span></span><span class="hljs-function"> </span></span>{ Integer max = array.get(<span class="hljs-number"><span class="hljs-number">0</span></span>) + array.get(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; array.size(); i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array.get(i) + array.get(i-<span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; max) max = array.get(i) + array.get(i-<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max; }</code> </pre><br> 使用书面函数在Kotlin上的一种函数方法（我建议自己实施max函数作为培训）： <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maxSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = zipWith(xs, xs.tail, {a, b -&gt; a + b}).max()</code> </pre><br>  Haskell的实现： <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">maxSum</span></span> xs = maximum $ zipWith (+) xs (tail xs)</code> </pre><br> 如我们所见，我们在Kotlin上实现的功能（顺便说一句，我们可以使用reduce来解决此问题）与Haskell可以编写的内容非常相似。 <br><br><h3> 结论 </h3><br> 无疑，这不应在开发中使用，因为所有操作都是非最优地执行，只是为了演示一种功能方法。 另外，几乎所有编写的内容都在Kotlin标准库中，因此，也许在将来，您将使用Kotlin为我们提供的功能样式，而不是编写另一个for循环。 <br><br> 功能样式中最困难的可能是可以用不同的方法解决问题。 最明显的内容将来可能很麻烦且难以理解，撰写最容易理解的内容可能需要花费时间和认真的思考。 唯一可以帮助您掌握的是不断的练习和训练。 <br><br>  PS：如上所述，您可以看到包含本文中所有示例的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">存储库</a> 。 运行测试，看看它如何工作！ <br><br>  PPS：您还可以查看实现类似<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">功能</a>的替代方法。 <br><br> 并确保稍后查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://arrow-kt.io/</a> 。 在我看来，您不应马上就去那里，因为一切看起来都非常可怕，但是以后，当函子和单子函数不会吓到您时，请务必进行研究。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN425527/">https://habr.com/ru/post/zh-CN425527/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN425511/index.html">Rotativa应用程序的非显而易见的功能，用于在ASP.NET MVC应用程序中生成PDF</a></li>
<li><a href="../zh-CN425515/index.html">Apple阻止对新MacBook型号进行独立维修</a></li>
<li><a href="../zh-CN425517/index.html">Yandex如何使用雷达和卫星创建全球降水预报</a></li>
<li><a href="../zh-CN425521/index.html">JavaScript ES5中的受保护方法</a></li>
<li><a href="../zh-CN425525/index.html">蒂姆·伯纳斯·李（Tim Berners-Lee）走上了战争的道路：“网络的第一步...”</a></li>
<li><a href="../zh-CN425529/index.html">Sans Forgetica：一种字体，可以让您更好地记住阅读的内容</a></li>
<li><a href="../zh-CN425531/index.html">液制动冷却。 系统开发选项</a></li>
<li><a href="../zh-CN425533/index.html">如何在云中工作：从检查数据中心的可靠性到管理虚拟基础架构</a></li>
<li><a href="../zh-CN425537/index.html">如何将Java，Js和图形与艺术结合起来，或如何创建交互式剧院的故事</a></li>
<li><a href="../zh-CN425541/index.html">如何快速且没有不必要的芯片来规避HTU21传感器的地址不变性</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>