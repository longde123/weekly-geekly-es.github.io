<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>➰ 🙏🏻 🚸 Kami menulis pemuat FPGA di LabVIEW. Bagian 2 👴🏼 💜 🎑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unduh konfigurasi ke FPGA melalui USB atau bongkar FTDI MPSSE 
 Kami menulis pemuat FPGA di LabVIEW. Bagian 1 


 Pada artikel pertama, kami menguji a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menulis pemuat FPGA di LabVIEW. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429448/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unduh konfigurasi ke FPGA melalui USB atau bongkar FTDI MPSSE</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kami menulis pemuat FPGA di LabVIEW.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> </p><br><img src="https://habrastorage.org/webt/2m/nu/6l/2mnu6ljkhtj-pydr_chsebgpp_i.jpeg"><br><br>  Pada artikel pertama, kami menguji algoritma pemuatan pada C lama yang baik, di artikel kedua, kami menemukan cara mengatur program di LabVIEW dan mengimplementasikan antarmuka pengguna yang sederhana.  Kali ini kami akan berkenalan dengan metode kerja baru di LabVIEW, menganalisis fitur-fitur penanganan kesalahan dan menyelesaikan proyek: kami menerapkan protokol untuk memuat file konfigurasi ke dalam FPGA. <a name="habracut"></a><br><br><h2 id="obrabotka-oshibok">  Menangani kesalahan </h2><br><p> Buka kode sumber, analisis fungsi MPSSE_open.  Terlepas dari kesederhanaan algoritmik (fungsinya disebut satu demi satu), beberapa elemen D2XX API harus diimpor: <code>FT_OpenEx</code> , <code>FT_ResetDevice</code> , <code>FT_Purge</code> , <code>FT_SetUSBParameters</code> , <code>FT_SetChars</code> , <code>FT_SetTimeouts</code> , <code>FT_SetLatencyTimer</code> , <code>FT_SetFlowControl</code> , <code>FT_SetBitMode</code>  Seperti yang ditunjukkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> , impor fungsi dilakukan menggunakan simpul <code>Call library Function</code> .  Node ini memiliki terminal khusus untuk kontrol kesalahan.  LabVIEW memiliki satu aturan sederhana: semua <abbr title="Alat virtual">VI</abbr> harus melacak kesalahan dan melaporkan kesalahan yang dikembalikan oleh terminal kesalahan.  Sebagian besar built-in VIs sangat mengikutinya.  Saya harap semua orang mengerti betapa pentingnya mengendalikan dan menangani kesalahan, terutama pada tahap debugging, tetapi ada alasan lain mengapa ini sangat penting sehingga tidak jelas bagi programmer "klasik".  LabVIEW tidak memiliki urutan perangkat yang ketat dalam diagram blok: perangkat dieksekusi ketika data siap pada inputnya.  Jika data dari output satu VI ditransfer ke input VI lain, maka jelas bahwa pada awalnya VI pertama akan berfungsi, hanya setelah itu yang kedua.  Tetapi bagaimana jika tidak ada transfer data, dan VI melakukan tindakan independen?  Tentu saja, Anda dapat menggunakan "Struktur Urutan Datar" yang rumit, tetapi jauh lebih nyaman untuk menghubungkan perangkat satu sama lain dengan sejumlah kesalahan. </p><br><p>  Saat mengimpor fungsi D2XX, kami menemukan dua jenis kesalahan.  Yang pertama - ini adalah kesalahan impor langsung - mengembalikan blok <code>Call library Function</code> itu sendiri.  Yang kedua adalah kesalahan dari perpustakaan itu sendiri, itu dikembalikan oleh hampir setiap fungsi melalui <code>FT_STATUS</code> .  Semua nilai yang mungkin dijelaskan sebagai enum di file header ftd2xx.h.  Meskipun cukup untuk mengetahui bahwa nilai <code>FT_OK</code> adalah tidak adanya kesalahan, dan semua nilai lainnya adalah kode kesalahan, saya ingin melacak tidak hanya fakta kesalahan itu sendiri, tetapi juga kesalahan apa yang terjadi dan di mana tepatnya itu terjadi. </p><br><p>  Di LabVIEW, data kesalahan disebarkan melalui cluster <code>error</code> .  Ini adalah tipe data khusus yang didedikasikan; LabVIEW memiliki banyak VI dan fungsi untuk bekerja dengannya.  Cluster kesalahan terdiri dari tiga elemen: variabel logis - menampilkan status, angka bertanda integer - kode kesalahan, string - sumber kesalahan.  Status menunjukkan apakah kesalahan telah terjadi, kode kesalahan menentukan jenisnya dan digunakan oleh VI khusus untuk menghasilkan laporan.  Baris ini memberikan gagasan yang lebih terperinci tentang di mana tepatnya kesalahan terjadi.  LabVIEW menerima bahwa jika statusnya <code>TRUE</code> , maka ini adalah kesalahan, jika statusnya <code>FALSE</code> , tetapi kodenya bukan nol dan baris uraian tidak kosong, maka ini <em>peringatan</em> , jika statusnya <code>FALSE</code> , kodenya nol dan garisnya kosong - tidak ada kesalahan. </p><br><img src="https://habrastorage.org/webt/pm/ku/gv/pmkugvhr1yzt6uarss9lfnmthuc.png"><br><br><p>  LabVIEW berisi basis data internal di mana setiap kode kesalahan dikaitkan dengan deskripsinya.  Untuk setiap jenis kesalahan, rentang nilai kode khusus dialokasikan.  Misalnya, untuk kesalahan yang terkait dengan pengoperasian jaringan, beberapa rentang dialokasikan: dari –2147467263 hingga –1967390460, dari 61 hingga 65, dari 116 menjadi 118 dan 122, 1101, 1114, 1115, 1132 hingga 1134, dari 1139 hingga 1143 dan dari 1178 hingga 1185 Untuk kesalahan yang ditentukan pengguna, dua rentang dicadangkan dari –8999 hingga –8000 dan dari 5000 hingga 9999. Dari rentang ini, kita dapat memilih nilai untuk kode kesalahan pustaka D2XX. </p><br><p>  Mari kita membuat VI yang menerima status fungsi D2XX sebagai input dan mengubah status ini menjadi cluster kesalahan LabVIEW.  Sebagian besar fungsi dan VI di LabVIEW, setelah menerima status <code>TRUE</code> pada input <code>Error In</code> , tidak menjalankan kode mereka, tetapi mengirimkan informasi kesalahan ke terminal <code>Error Out</code> .  Ini memungkinkan Anda untuk secara efektif mentransfer informasi tentang sumber melalui seluruh rantai ke penangan kesalahan, menghilangkan eksekusi kode dalam mode darurat.  Sangat diharapkan bahwa VI kita berperilaku sama. </p><br><p>  Mari kita mengatur daftar status D2XX dalam bentuk <code>enum</code> dan menempatkannya dalam tipe yang terpisah (dalam artikel sebelumnya kita melakukan ini dengan tipe FTDI). </p><br><div class="spoiler">  <b class="spoiler_title">enum FT_Status</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/mb/bp/kp/mbbpkpzguefjrdg2p4l2n7-rpg0.png"></div></div><br><p>  Kami menyimpan VI baru dengan nama FT_error.vi.  Kami menambahkan dua klaster <code>Error In</code> dan <code>Error Out</code> panel depan, Anda dapat menemukannya di panel "Array, Matrix &amp; Cluster".  Kami menghubungkan mereka ke terminal pada panel koneksi di sudut kiri bawah dan kanan bawah, masing-masing, sebagaimana telah disebutkan dalam artikel sebelumnya, ini adalah lokasi terminal aliran kesalahan yang diadopsi oleh LabVIEW.  Kami menambahkan struktur <code>Case</code> ke diagram blok, mengirimkan cluster <code>Error In</code> ke input <code>Case selector</code> , setelah itu struktur <code>Case</code> berubah warna dan membagi dua sub-diagram: "No Error" - warna hijau, dan "Error" - warna merah.  Di dalam kasus Error, kami mentransfer cluster kesalahan dari terminal pemilih langsung ke terowongan output di perbatasan kanan.  Dan dalam kasus hijau, kami menambahkan <code>Case</code> lain, tergantung pada statusnya, ia akan menentukan apakah akan membuat kesalahan (status tidak sama dengan FT_OK), atau membiarkannya apa adanya: lewati cluster kesalahan input untuk keluar tanpa mengubah. </p><br><p>  Untuk mengubah secara teknis kode kesalahan menjadi sebuah cluster, Anda dapat menggunakan VI <code>Error Cluster From Error Code VI</code> .  <abbr title="Sub Instrumen Virtual. Dia adalah Subpribor">SubVI</abbr> ini menambahkan rantai panggilan ke deskripsi kesalahan, sehingga kami dapat menentukan tidak hanya <strong>apa yang</strong> terjadi, tetapi juga di <strong>mana</strong> itu terjadi. </p><br><p>  Untuk memilih teks yang sesuai dengan status input (FT_Status), gunakan blok properti: pilih "RingText.Text".  Teks kesalahan dikirim ke input <code>error message</code> dari <code>Error Cluster From Error Code VI</code> . <br>  Jangan lupa menggambar ikon "berbicara". </p><br><div class="spoiler">  <b class="spoiler_title">FT_error.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xx/xw/ub/xxxwubdzodjs1jfaywcbjamsrtg.png"><br>  <em>Panel sub-instrumen depan (depan)</em> </p><br><p><img src="https://habrastorage.org/webt/ja/wu/te/jawuteahiriyixrjpcgbm91esjo.png"><br>  <em>Diagram blok.</em>  <em>Kesalahan input</em> </p><br><p><img src="https://habrastorage.org/webt/yd/qf/lp/ydqflp1m-zexy_zvvdx8drixu9e.png"><br>  <em>Diagram blok.</em>  <em>Tidak ada kesalahan pada input dan statusnya adalah FT_OK</em> </p><br><p><img src="https://habrastorage.org/webt/1h/wp/7m/1hwp7mcprzgv3mf9oz3jenbco4q.png"><br>  <em>Diagram blok.</em>  <em>Tidak ada kesalahan pada input, tetapi statusnya berbeda dari FT_OK</em> </p><br></div></div><br><p>  Untuk menguji FT_error, Anda dapat membuat VI kosong, tambahkan VI yang dibuat di sana, dan lihat bagaimana nilainya akan berubah saat startup jika berbagai status diterapkan. </p><br><div class="spoiler">  <b class="spoiler_title">Tes FT_error.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/rn/_r/be/rn_rbewvlb--au_hi3nosghkjmk.png"><br>  <em>Panel depan (depan) perangkat</em> </p><br><p><img src="https://habrastorage.org/webt/ju/44/fz/ju44fzmyx2aly2-fraydjrkyffg.png"><br>  <em>Diagram blok</em> </p></div></div><br><p>  Sekarang, setelah panggilan fungsi apa pun dari API D2XX, kami akan menggunakan SubVI FT_error.vi.  Sekelompok kesalahan akan melewati semua VI di seluruh hierarki panggilan. </p><br><p>  Di VI tingkat atas, kita harus memutuskan apa yang harus dilakukan dengan kesalahan yang terdeteksi: Anda dapat menampilkan pesan di kotak dialog, menulisnya ke file laporan, mengabaikannya, atau cukup "diam-diam" mengakhiri aplikasi.  Kotak dialog adalah cara termudah dan terpopuler untuk melaporkan kesalahan.  Ini juga nyaman untuk programmer pemula, karena tidak ada yang bisa dilakukan.  Di setiap VI, mode <strong>penanganan kesalahan otomatis</strong> diaktifkan secara default ( <strong>Mengaktifkan penanganan kesalahan otomatis</strong> , terletak di kategori Eksekusi di menu VI Properties).  Ia bekerja seperti ini: jika di beberapa node terminal keluaran <code>Error Out</code> tidak terhubung di mana saja, dan kesalahan terjadi di node ini, maka LabVIEW menjeda aplikasi dan menampilkan kotak dialog.  Jika terminal <code>Error Out</code> node terhubung, maka aliran kesalahan merambat seperti yang diprogram, dan tidak ada tindakan tambahan terjadi.  Namun, jendela pesan dapat dipanggil secara terprogram, untuk ini Anda perlu menggunakan <code>General Error Handler</code> dan <code>Simple Error Handler</code> VIs (terletak di panel Dialog &amp; Antarmuka Pengguna).  Dalam hal ini, kita dapat menggunakan informasi kesalahan untuk menyelesaikan program.  Dalam diagram blok, terlihat seperti ini: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/u9/8y/_p/u98y_paluq1jtgm2gylcaceydgs.png"></a> <br>  <em>Gambar yang dapat diklik</em> </p><br><p>  Ketika kesalahan terjadi, program akan ditangguhkan, jendela laporan akan muncul, setelah menutup jendela, program akan keluar dengan benar. </p><br><div class="spoiler">  <b class="spoiler_title">Jendela laporan</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/9g/mh/lc/9gmhlc7e8mf-2uqzheifbdtgdek.png"></p></div></div><br><h2 id="otkryt-i-zakryt-ftdi">  Buka dan tutup FTDI </h2><br><p>  Jadi, kembali ke fungsi <code>MPSSE_open</code> .  Buat <abbr title="Instrumen virtual">VI</abbr> baru.  Pertama-tama, tambahkan terminal untuk aliran kesalahan.  Tambahkan struktur pilihan dan pilih input <code>Error In</code> pada pemilih.  Dalam kasus hijau, kita mengimpor fungsi dalam urutan dan dengan parameter seperti pada prototipe Sishny.  Semua node dari <code>Call Library Function Node</code> terhubung dalam rantai oleh aliran kesalahan.  Dalam kasus merah melalui terowongan kita menghubungkan <code>Error In</code> dengan terminal output dari kesalahan. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/4p/qq/zx/4pqqzxgwcgsbb-jcvepvyaj6jam.png"></a> <br>  <em>Gambar yang dapat diklik</em> </p><br><p><img src="https://habrastorage.org/webt/5z/uq/k6/5zuqk6hmya20zgu9ddnciwgj5a0.png"><br>  <em>VI MPSSE_open.vi</em> </p><br><p>  Baris dengan deskripsi FTDI ( <code>Description</code> ) dikirim ke input SubVI, pada output - <code>Handle</code> dan chip FTDI yang diinisialisasi dalam mode MPSSE. </p><br><p>  Mari kita membuat VP yang selesai bekerja dengan FTDI dan Anda sudah dapat memeriksa kinerja pada perangkat keras. </p><br><div class="spoiler">  <b class="spoiler_title">FT_Close.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/1e/te/g3/1eteg3uh0t2t16y9yho_kxjbufe.png"><br>  <em>Diagram blok</em> </p><br><p><img src="https://habrastorage.org/webt/ki/ez/tt/kiezttogb-2n4zl1qe893hfc55w.png"><br>  <em>Panel depan</em> </p></div></div><br><p>  Pada artikel sebelumnya, untuk debugging antarmuka, kami membuat rintisan VI SP_FT_MPSSE_FPGA.vi, sekarang saatnya untuk mengisinya.  Tambahkan MPSSE_open.vi dan FT_Close.vi ke diagram bloknya.  Pada tahap ini, agak sulit untuk menilai apakah inisialisasi itu benar, namun, nilai <code>Handle</code> bukan nol pada output MPSSE_open.vi dan tidak adanya kesalahan akan memberi tahu kami banyak. </p><br><p><img src="https://habrastorage.org/webt/ci/rn/q5/cirnq5ik2_g5p-wbz3cmfcxzquo.png"><br>  <em>Diagram Alir SP_FT_MPSSE_FPGA.vi</em> </p><br><p>  Untuk melihat nilai <code>Handle</code> Anda dapat menggunakan "Jendela Probe Watch".  Ini adalah alat debugging yang nyaman yang memungkinkan Anda untuk menampilkan nilai data pada setiap (hampir semua) kawat selama eksekusi perangkat.  Untuk mengatur sampel pada baris, Anda harus memilih "Probe" di menu konteks dari baris ini.  Jendela "Probe Watch Window" akan terbuka, dan nomor dengan nomor sampel akan muncul di telepon.  Pada gambar di atas adalah "3". </p><br><div class="spoiler">  <b class="spoiler_title">Jendela tontonan pemeriksaan</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/yq/qv/u_/yqqvu_pkihohde2in-uy7sttt-i.png"><br>  <em>Pada garis Handle, nilainya 698389336</em> </p></div></div><br><p>  Hebat!  Kami mulai VI tingkat atas, hubungkan papan debug ke komputer.  Deskripsi chip FTDI yang terhubung muncul di daftar "Select a device", klik tombol "Program" dan ... tidak ada yang terjadi.  Hanya di jendela "Probe Watch" nilai <code>Handle</code> muncul.  Dan itu bagus. </p><br><p>  Kami mematikan papan, daftar perangkat dihapus.  Klik "Program."  Di sinilah jendela laporan kesalahan muncul. </p><br><div class="spoiler">  <b class="spoiler_title">Jendela laporan</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/9g/mh/lc/9gmhlc7e8mf-2uqzheifbdtgdek.png"></p></div></div><br><p>  Setelah mengklik tombol "Lanjutkan", VI menyelesaikan tugasnya. </p><br><p>  Dilarang menekan tombol jika tidak ada perangkat yang ditemukan.  Kami memodifikasi penangan acara case "Timeout".  Biarkan saya mengingatkan Anda bahwa chip FTDI yang terhubung ke PC dipindai dua kali per detik, jika terdeteksi dan dapat digunakan untuk memprogram FPGA, maka deskriptornya akan ditambahkan ke <code>Devices list</code> melalui properti <code>Strings[]</code> .  Kami membuat properti <code>Disabled</code> untuk "Pemrograman", dan jika tidak ada perangkat yang cocok ditemukan, maka matikan dan gelap tombol. </p><br><div class="spoiler">  <b class="spoiler_title">Batas waktu kasus</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/wx/nf/5n/wxnf5n-ttwqqrsmbtydmttzcghw.png"></a> <br>  <em>Gambar yang dapat diklik</em> </p></div></div><br><h2 id="osvaivaem-gpio">  Menguasai GPIO </h2><br><p>  Setelah MPSSE diaktifkan, bekerja dengannya dilakukan melalui apa yang disebut "op-code", dan hanya <code>FT_Write</code> , <code>FT_Read</code> , dan <code>FT_Queue</code> yang digunakan dari fungsi <code>FT_Write</code> API (untuk mengetahui status buffer penerima).  Kami membuat VI yang sesuai di sepanjang jalur yang kami buat: FT_Write.vi, FT_Read.vi, FT_Queue.vi. </p><br><div class="spoiler">  <b class="spoiler_title">Sedikit rutin</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/tw/or/ku/tworkua4o2qj3bntqoer1jb4o0u.png"><br>  <em>FT_Write.vi</em> </p><br><p><img src="https://habrastorage.org/webt/8k/pm/4s/8kpm4sdeaqgzlsctp-106wvtdz0.png"><br>  <em>Diagram blok.</em>  <em>FT_Write.vi</em> </p><br><p><img src="https://habrastorage.org/webt/i0/px/18/i0px189plvqpokb3sijjuxtxbei.png"><br>  <em>FT_Read.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ku/hm/xw/kuhmxw1j66symp05f0ergjkriag.png"><br>  <em>Diagram blok.</em>  <em>FT_Read.vi</em> </p><br><p><img src="https://habrastorage.org/webt/bf/2s/q_/bf2sq_t4uinirm94vmh-ugkzqzy.png"><br>  <em>FT_Queue.vi</em> </p><br><p><img src="https://habrastorage.org/webt/5p/zm/dv/5pzmdvtnhtdq0ivxzfs0t32nfjk.png"><br>  <em>Diagram blok.</em>  <em>FT_Queue.vi</em> </p></div></div><br><p>  Sekarang dari tiga batu bata ini kita mengeluarkan VI untuk membaca port paralel dan menulis untuk itu.  Nilai tersebut direpresentasikan sebagai array variabel Boolean. </p><br><div class="spoiler">  <b class="spoiler_title">MPSSE_Set_LByte.vi dan MPSSE_Get_LByte.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/oy/uh/8l/oyuh8lrdyniwp6ub2pvgwrxtlvw.png"><br>  <em>MPSSE_Set_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/g4/ab/u-/g4abu-lurodnce0udnamj1ftsjm.png"><br>  <em>Diagram blok.</em>  <em>MPSSE_Set_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/7g/s9/5d/7gs95ddkb8pg9fjzt-s0vflzes4.png"><br>  <em>MPSSE_Get_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ki/dm/n_/kidmn_ewfihbrokreabs90538p0.png"><br>  <em>Diagram blok.</em>  <em>MPSSE_Get_LByte.vi</em> </p><br><p>  Saya akui saya malas membuat daftar nama untuk semua kode-op, jadi saya meninggalkannya dalam bentuk Angka Ajaib. </p></div></div><br><p>  Sebagaimana dinyatakan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> pertama, protokol boot Pasif Serial FPGA tidak lebih dari SPI dengan manipulasi flag tambahan.  Total lima kaki digunakan: garis <em>DCLK</em> , <em>DATA [0]</em> , <em>nCONFIG</em> harus dikonfigurasi sebagai keluaran, garis <em>nSTATUS</em> , <em>CONF_DONE</em> sebagai input. </p><br><div class="spoiler">  <b class="spoiler_title">Tata letak meja pinout</b> <div class="spoiler_text"><table><thead><tr><th>  Pin FPGA </th><th>  Nama pin </th><th>  Pin </th><th>  MPSSE </th><th>  Arahan </th><th>  standar </th></tr></thead><tbody><tr><td>  DCLK </td><td>  BDBUS0 </td><td>  38 </td><td>  TCK / SK </td><td>  Keluar </td><td>  0 </td></tr><tr><td>  DATA [0] </td><td>  BDBUS1 </td><td>  39 </td><td>  TDI / DO </td><td>  Keluar </td><td>  1 </td></tr><tr><td>  nCONFIG </td><td>  BDBUS2 </td><td>  40 </td><td>  TDO / DI </td><td>  Keluar </td><td>  1 </td></tr><tr><td>  nSTATUS </td><td>  BDBUS3 </td><td>  41 </td><td>  TMS / CS </td><td>  Masuk </td><td>  1 </td></tr><tr><td>  CONF_DONE </td><td>  BDBUS4 </td><td>  43 </td><td>  GPIOL0 </td><td>  Masuk </td><td>  1 </td></tr></tbody></table></div></div><br><p>  Kami membutuhkan VP yang dapat mengubah nilai pada leg yang dipilih tanpa memengaruhi yang lainnya.  Pertama-tama, buat <code>Enum</code> dengan nomor seri dari kaki di port, simpan sebagai "Ketik Jenis Def" ke file SP_LBYTE_BITS.ctl.  Kami membuat VI baru, tambahkan terminal aliran kesalahan yang sudah dikenal.  Kami membaca nilai saat ini dari port paralel menggunakan MPSSE_Get_LByte.vi, gunakan fungsi <code>Replace Array Subset</code> untuk memodifikasi bit yang diinginkan dan menulis nilai kembali ke port (MPSSE_Set_LByte.vi). </p><br><div class="spoiler">  <b class="spoiler_title">SP_Set_Flag.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/y7/d3/ap/y7d3aps-9ima93quyatag0ggkui.png"><br>  <em>SP_Set_Flag.vi</em> </p><br><p><img src="https://habrastorage.org/webt/jn/ae/h4/jnaeh4ewehebgcba9fstkxnxa4o.png"><br>  <em>Diagram blok.</em>  <em>SP_Set_Flag.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ud/mt/jx/udmtjxpekkcskrmisie8t2h4hfw.png"><br>  <em>Enum SP_LBYTE_BITS.ctl</em> </p></div></div><br><p>  Untuk memulai konfigurasi, MPSSE harus menghasilkan transisi rendah ke tinggi pada baris <em>nCONFIG</em> .  Segera setelah FPGA siap menerima data, FPGA itu akan membentuk level tinggi di jalur <em>nSTATUS</em> .  Pada tahap ini, semuanya siap untuk percobaan dengan besi.  Pada diagram blok SP_FT_MPSSE_FPGA.v kita menambahkan baris kontrol <em>nCONFIG</em> - setelah inisialisasi MPSSE kita memberikan level rendah, dan kemudian tinggi.  Setelah setiap operasi (untuk debugging) kami membaca status kaki porta. </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/5q/8g/u1/5q8gu1k9oezxomhdblxqyjbxxas.png"><br>  <em>Saat startup</em> </p><br><p><img src="https://habrastorage.org/webt/nj/qv/bv/njqvbvi3dibaezauuqh4t2thdo8.png"><br>  <em>Diagram blok</em> </p></div></div><br><p>  Secara umum, selama peluncuran VI, jelas bahwa FPGA merespons transisi pada garis <em>nCONFIG</em> - nol diatur pada kaki <em>nSTATUS</em> , dan kemudian satu.  Tetapi tidak akan berlebihan untuk memonitor ini dengan osiloskop.  Hampir semua osiloskop dua saluran dengan pemicu pemicu (siaga) cocok.  Saluran <strong>A</strong> (jalur biru) saya letakkan di titik kontrol sirkuit <em>nCONFIG</em> , saluran <strong>B</strong> (jalur merah) - rantai <em>nSTATUS</em> .  Pemicu diatur ke tepi jatuh saluran <strong>A.</strong> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ca/b9/ti/cab9tizq5kpbnbguzew2avmi_je.png"></a> <br>  <em>Gambar bisa diklik.</em>  <em>Dengan detail!</em> </p><br><h2 id="rabota-s-faylom">  Bekerja dengan file </h2><br><p>  FPGA siap menerima file konfigurasi.  Apakah kami siap mentransfer file ke FPGA? </p><br><p>  LabVIEW berisi seperangkat alat yang luas untuk bekerja dengan file.  Saya tidak bisa mengatakan bahwa fungsinya cukup untuk semua tugas, tetapi operasi dasar seperti <em>membaca</em> dan <em>menulis</em> dilakukan dengan mudah dan menyenangkan.  Perangkat dasar VI untuk bekerja dengan file dapat ditemukan di panel "File I / O".  Untuk menyelesaikan masalah, Anda perlu membuka file konfigurasi, mengevaluasi ukurannya (kita perlu tahu berapa byte untuk mengirim FPGA), membacanya dan menutupnya.  Semuanya sederhana dan satu demi satu.  Kami menggunakan <code>Open/Create/Replace File</code> , <code>Get File Size</code> , <code>Read from Binary File</code> , <code>Close File</code> <code>refnum</code> , gabungkan dengan rantai aliran kesalahan dan <code>refnum</code> - nomor, seperti deskriptor file, dibuat ketika file dibuka dan harus ditransfer ke input dari VI lain yang bekerja dengan file ini. </p><br><p>  Sejauh ini, kita tidak punya tempat untuk membuang data yang dibaca, tetapi jika Anda benar-benar ingin memeriksa operabilitas rantai, Anda dapat membuat indikator tipe <code>String</code> dan mengaturnya sedikit.  Dalam menu konteks, aktifkan opsi "Tampilan Hex", nyalakan bilah gulir vertikal (Item Terlihat -&gt; Bilah Gulir Vertikal) dan setelah peluncuran kami mengamati konten file konfigurasi biner. </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/7w/r8/dy/7wr8dyzaxomkxwmqioien0rn2om.png"><br>  <em>Panel depan</em>  <em>Kami melihat isi file</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/qf/8l/vv/qf8lvvjj6xtwo_be0aiu-3aa2co.png"></a> <br>  <em>Diagram blok.</em>  <em>Karinka dapat diklik</em> </p></div></div><br><p>  Dua garis paralel independen dari kode yang dibentuk pada diagram blok VI, oleh karena itu, rantai kesalahan terpisah digunakan untuk mereka.  Untuk mengurangi aliran paralel menjadi satu terminal <code>Error Out</code> , fungsi <code>Merge Errors</code> digunakan.  Fungsi ini mencari kesalahan input dari atas ke bawah (ya, mungkin ada lebih dari dua terminal input, itu diregangkan oleh mouse) dan mengembalikan yang pertama ditemukannya.  Jika tidak ada kesalahan, itu mengembalikan pesan peringatan pertama.  Jika tidak ada peringatan, maka tidak ada kesalahan pada output.  Penting untuk dicatat bahwa urutan koneksi input <code>Merge Errors</code> menentukan prioritas kesalahan, dan jika kesalahan terjadi segera dalam dua rantai, kesalahan yang lebih rendah akan diabaikan.  Ini harus diperlakukan dengan hati-hati. </p><br><p>  Jika kita mencoba menekan tombol "Program" di VI tingkat atas tanpa memilih file, maka input SP_FT_MPSSE_FPGA.vi akan menerima jalur kosong, yang akan menyebabkan kesalahan "Kesalahan 1430. LabVIEW: (Hex 0x596) Path kosong atau relatif. Anda harus menggunakan jalan absolut. "  Seperti yang dikatakan teman masa kecil saya: "Trifles, ini adalah sesuatu yang duniawi!"  Dan kesalahan ini sama sekali bukan kesalahan, tapi ketidaktahuan pengguna.  Kami tidak akan menghentikan program dan bersumpah dengan jendela dengan palang merah, kami cukup menghapus kesalahan dengan kode ini dari aliran dan di kotak dialog kami menyarankan pengguna untuk memutuskan file.  Untuk memfilter kesalahan, gunakan VI "Hapus Kesalahan" dari palet "Dialog &amp; Antarmuka Pengguna".  Untuk menampilkan pesan - "Dialog Satu Tombol". </p><br><p><img src="https://habrastorage.org/webt/o2/nf/bm/o2nfbmdreh3hdppvxsabj7hsgt4.png"></p><br><div class="spoiler">  <b class="spoiler_title">Diagram blok</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/-6/ik/cp/-6ikcptiqxx7uloza1v2g5y6wdo.png"></a> <br>  <em>Gambar yang dapat diklik</em> </p></div></div><br><h2 id="zagruzka-konfiguracii">  Konfigurasi unduhan </h2><br><p>  Untuk transfer data serial, prosesor MPSSE perlu mengirim kode-kode 0x18, argumen perintah akan menjadi panjang dari urutan yang ditransmisikan (dua byte, dimulai dengan yang terendah), dan urutan data itu sendiri.  Panjangnya dikodekan minus satu.  Mari kita kirim blok data sebagai VI MPSSE_send. </p><br><div class="spoiler">  <b class="spoiler_title">MPSSE_Send.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/my/du/hi/myduhilu9cbsm8f3j_ceduagppq.png"><br>  <em>MPSSE_Send.vi</em> </p><br><p><img src="https://habrastorage.org/webt/fv/13/9m/fv139mrjy-t8l8cz-u82btswts8.png"><br>  <em>Diagram blok</em> </p></div></div><br><p>  Ukuran buffer input ( <code>Array Size</code> ) dikonversi menjadi tipe byte ganda <code>U16</code> , kami kurangi satu, swap byte rendah dan tinggi ( <code>Swap Bytes</code> ) - Anda perlu mengirim panjang mulai dari yang terendah, dan mengonversi nomor byte ganda ke array byte tunggal ( <code>Type Cast</code> ). </p><br><p>  Fungsi <code>Type Cast</code> perlu mendapat perhatian khusus.  Ini adalah konverter tipe universal, kecerdikannya terkadang sangat mengejutkan.  Singkatnya, lalu: </p><br><p><img src="https://habrastorage.org/webt/k9/qp/0t/k9qp0tiyjs2ajjgisnhbfuaonpe.png"><br>  <em>Secara visual untuk programmer</em> </p><br><p>  Namun, ini bukan hanya menuang data ke tipe yang berbeda, tetapi juga interpretasi heuristik.  Fungsi ini memungkinkan Anda untuk melakukan konversi antara tipe data yang tidak kompatibel, sementara fungsi tersebut tidak ragu untuk menyelaraskan data input dan bahkan menghapus bagian "ekstra".  Jika tipe data yang diminta membutuhkan lebih banyak memori daripada data input, maka fungsi akan mengalokasikan jumlah yang hilang.  Untuk pengembang pemula, LabVIEW <code>Type Cast</code> dapat menjadi penyelamat, tetapi dengan tumbuh dewasa, lebih baik untuk menolak konverter seperti itu - sangat banyak tersembunyi dari mata dan dapat menjadi sumber kesalahan yang tidak terduga.  Lebih baik menggunakan metode konversi yang lebih eksplisit, seperti <code>Coerce To Type</code> . </p><br><p>  Saat menginisialisasi prosesor MPSSE, kami menetapkan ukuran buffer maksimum yang diijinkan untuk transfer data ke 65536 byte, oleh karena itu, kami harus membagi file konfigurasi menjadi fragmen yang ukurannya tidak melebihi ukuran yang ditentukan.  Kami akan menggunakan fungsi <code>Array Subset</code> , fungsi ini memilih subarray dari array yang dimulai dengan elemen <code>index</code> dan <code>length</code> .  Kami akan memecahnya dalam loop <code>While</code> , kami akan meningkatkan setiap iterasi indeks dengan 65536, antara iterasi kami akan melewati nilai melalui register geser.  Segera setelah tidak mungkin untuk mencubit 65536 byte dari array utama, kami mengambil semua yang tersisa, mengirimnya dan menghentikan siklus. </p><br><p>  Menurut protokol pengunduhan, setelah semua data ditransfer, dua pulsa clock lagi harus diterapkan untuk memulai inisialisasi FPGA.  Untuk melakukan ini, setelah loop, kami mengirim byte "kosong". </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/vp/y4/wr/vpy4wrsts1szqayvnquvjtb2nzw.png"></a> <br>  <em>Gambar yang dapat diklik</em> </p></div></div><br><p>  Untuk memahami keberhasilan firmware, kami mempertimbangkan bendera, dan jika <em>CONF_DONE</em> disetel ke satu, kami <em>melaporkan</em> tingkat atas VI bahwa semuanya baik-baik saja. </p><br><p>  Program selesai.  Tetap memastikan bahwa FPGA berhasil di-flash, dan board berkedip bahagia dengan LED. </p><br><h2 id="pro-imenovanie-vp">  Tentang Penamaan VP </h2><br><p>     ,             ,       LabVIEW, ,      SubVI.              .        : </p><br><ul><li>    —  ,     FTDI,           API D2XX.            "FT",  FT_Close.vi  FT_Read.vi. </li><li>   —     MPSSE.        "MPSSE". : MPSSE_open.vi, MPSSE_Set_LByte.vi, MPSSE_Get_LByte.vi. </li><li>   —    "Passive Serial"  MPSSE.     "S". , SP_FT_MPSSE_FPGA.vi ( ,   )  SP_LBYTE_BITS.ctl. </li><li>  .   .    , . </li></ul><br><p>     ( ),             .          <em>subVI</em> . </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  ,     ,           . </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ff/i0/fq/ffi0fqqs7gbi3aczbucvusrw2qi.jpeg"></p></div></div><br><p>         ,        LabVIEW,        .    ,     ,        ,         (    ).         . </p><br><h2 id="materialy-po-teme">    </h2><br><ol><li>  . LabVIEW:  .  Per.  .  .  .– .: <br>  , 2008 – 400 .: . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">labview_mpsse</a> .   . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   </a> .    </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Software Application Development D2XX Programmer's Guide</a> .   API D2XX. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429448/">https://habr.com/ru/post/id429448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../hi434978/index.html">पेश है HealthKit</a></li>
<li><a href="../id429420/index.html">PlayStation Classic menggunakan emulator PCSX ReARMed untuk operasi, tidak ada solusi eksklusif</a></li>
<li><a href="../id429422/index.html">UHCI, atau USB pertama</a></li>
<li><a href="../id429424/index.html">Robotaxi dari Daimler dan Bosch akan muncul di California</a></li>
<li><a href="../id429426/index.html">QGIS dan ekspor ubin</a></li>
<li><a href="../id429450/index.html">Teknik pemrograman umum di Rust: bagaimana kami menerjemahkan Exonum dari Iron ke actix-web</a></li>
<li><a href="../id429452/index.html">Pentagon mulai mendeklasifikasi malware orang lain</a></li>
<li><a href="../id429456/index.html">Sudah cerita: di mana budaya startup dimulai pada 1930-an</a></li>
<li><a href="../id429458/index.html">Bagaimana saya melakukan animasi Tata Surya untuk anak kelas dua</a></li>
<li><a href="../id429460/index.html">Ringkasan laporan “Apa yang kita ketahui tentang layanan mikro” (HL2018, Avito, Vadim Madison)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>