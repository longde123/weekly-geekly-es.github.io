<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè¥ üéÆ üö´ Bin√§rkompatibilit√§t: jetzt oder nie üöé üßñüèª üÜë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√úbersetzung der Ver√∂ffentlichung von Titus Winters in der Arbeitsgruppe 21 (WG21) - C ++ Language Standardization Committee. Der Autor diskutiert ein ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bin√§rkompatibilit√§t: jetzt oder nie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474294/"><p>  <i>√úbersetzung der Ver√∂ffentlichung von Titus Winters in der Arbeitsgruppe 21 (WG21) - C ++ Language Standardization Committee.</i>  <i>Der Autor diskutiert ein wichtiges Thema: Unterst√ºtzung f√ºr Abw√§rtsbin√§rkompatibilit√§t oder ABI (Application Binary Interface).</i> <br><br></p><p>  In den letzten Jahren habe ich bei WG21 aktiv daf√ºr geworben, dass Fortschritt wichtiger ist als Abw√§rtskompatibilit√§t.  Aber ich selbst glaube nicht mehr daran, insbesondere im Hinblick auf die Aufrechterhaltung der Bin√§rkompatibilit√§t (ABI). <a name="habracut"></a>  In den letzten drei Releases (C ++ 14, C ++ 17 und C ++ 20) war ABI so stabil wie m√∂glich.  Selbst wenn WG21 beschlie√üt, die ABI-Abw√§rtskompatibilit√§t in C ++ 23 zu unterbrechen, bieten wir seit mehr als 10 Jahren Bin√§rkompatibilit√§t auf vielen Plattformen.  Meiner Meinung nach dominiert das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gesetz von Hyrum</a> bei umfangreichen √Ñnderungen von Softwaresystemen.  Jetzt k√∂nnen Sie nicht sagen, wie viele Benutzer davon ausgehen, dass die Stabilit√§t der ABI-Standardbibliothek (egal wie weise oder explizit oder implizit) fest in den Subkortex eingen√§ht ist, vielleicht die H√§lfte der C ++ - Entwickler weltweit. </p><br><p> Ich f√ºhre eine Liste dar√ºber, was WG21 in der Sprache beheben k√∂nnte, wenn wir uns entscheiden, den ABI zu ‚Äûbrechen‚Äú.  Und ich kann nicht mit Sicherheit sagen, dass die Gesamtkosten f√ºr Nacharbeiten, die nur die Implementierung dieser Liste erfordern, mit den Kosten f√ºr die Verletzung von ABI im gesamten √ñkosystem vergleichbar sind.  Wir haben viele kleine Verbesserungen in der Konsistenz der API, der Qualit√§t des Standardbibliothekscodes usw. gesehen, aber ohne Zweifel gibt es keine einzige "Durchbruch" -√Ñnderung, die diese Kosten f√ºr den durchschnittlichen Entwickler rechtfertigen w√ºrde.  Vielleicht w√ºrden wir bessere Implementierungen des Standards erhalten und die M√∂glichkeit geben, Probleme f√ºr Implementierungen zu l√∂sen, die heute nicht den Standardspezifikationen entsprechen.  Aber keine einzige Verbesserung auf meiner Liste ist eindeutig die Kosten wert. </p><br><p>  Noch wichtiger ist, dass wir aufgrund von ABI-Einschr√§nkungen keine signifikanten Leistungsverluste beseitigen k√∂nnen.  Wir k√∂nnen die erheblichen Kosten f√ºr die √úbergabe von unique_ptr nach Wert nicht loswerden [Chandlers Vortrag auf CppCon 2019 wird sp√§ter ver√∂ffentlicht], wir k√∂nnen std :: hash oder die Platzierung der Klasse im Speicher f√ºr unorder__ap nicht √§ndern, ohne dass jeder gezwungen ist, alles √ºberall neu zu kompilieren.  Die Leistung von Hashes wurde im Laufe der Jahre eingehend untersucht. Unter Ber√ºcksichtigung der Optimierung der Suchvorg√§nge in der Tabelle und des eigentlichen Hashings sind wir zuversichtlich, dass wir eine unordered_map / std :: hash-Implementierung bereitstellen k√∂nnen, die API-kompatibel ist und eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leistungssteigerung von</a> 200-300% bietet.  ABI-Einschr√§nkungen erlauben dies jedoch nicht.  Zus√§tzliche Studien zur Optimierung und Optimierung von SSO f√ºr std :: string deuten auf eine nicht triviale Leistungssteigerung hin (1% bei Mikrobenchmarks und Skalierung) - die API ist nicht betroffen, ABI-Einschr√§nkungen lassen dies jedoch nicht zu. <br><br>  Der ausschlie√ülich von ABI blockierte Gesamtproduktivit√§tsverlust erreicht mehrere Prozentpunkte - m√∂glicherweise bis zu 5-10%.  Dies ist nicht etwas, worauf das gesamte √ñkosystem nicht verzichten kann, aber es kann f√ºr einige Organisationen (darunter auch Google) nicht akzeptabel sein.  Dies ist nat√ºrlich ein gro√üer Leistungsverlust, der f√ºr C ++ akzeptabel ist: Denken Sie daran, dass dies eine Sprache ist, die behauptet, dass sie keinen Raum f√ºr einen produktiveren Konkurrenten l√§sst.  Die meisten Benutzer scheinen √ºber diesen Leistungsabfall nicht besorgt zu sein: Es gibt andere Hash-Tabellen-Implementierungen f√ºr diejenigen, die √ºber die absolute Leistung besorgt sind.  Die allgemeine Ineffizienz, die mit der √úbergabe von unique_ptr an Wert und anderen Problemen der ABI-Sprache verbunden ist, tritt bei einer sehr geringen Anzahl von Aufgaben in den Vordergrund.  Unternehmen, die maximale Produktivit√§t ben√∂tigen, k√∂nnen ihren eigenen Weg gehen (und dies tun), indem sie nicht standardm√§√üige Bibliotheken und nicht standardm√§√üige Konfigurationstools verwenden.  Dies ist nat√ºrlich und muss klar verstanden werden. </p><br><br>  Eine √Ñnderung des ABI wirkt sich auf eine relativ gr√∂√üere Anzahl von Benutzern aus.  Ich vermute, dass ein erheblicher Teil dieser Benutzer nicht ahnt, wie stark ihre Abh√§ngigkeit von ABI ist.  Im √ñkosystem der Google-Server wird fast alles von der Quelle gesammelt, es gibt nur wenige externe Abh√§ngigkeiten und es gibt eine √ºberdurchschnittliche M√∂glichkeit, ein umfangreiches Refactoring durchzuf√ºhren.  Aber selbst f√ºr uns kosteten die j√ºngsten ABI-√Ñnderungen an der Standardbibliothek 5-10 Entwicklungsjahre. <br><p>  Die Gesamtkosten f√ºr die Unterbrechung der ABI-Abw√§rtskompatibilit√§t f√ºr das gesamte C ++ - √ñkosystem k√∂nnen im ‚Äû <b>Millennium Engineer</b> ‚Äú konservativ gesch√§tzt werden: Die Koordination des Wiederaufbaus f√ºr jeden Anbieter von Plug-Ins, .so oder DLL in der Welt erfordert enorme Humanressourcen.  Zusammen mit der Trennung des √ñkosystems aufgrund von C ++ 20-Modulen kann eine √Ñnderung des ABI in der Entwicklungs- und Implementierungszeitleiste von C ++ 23 zu einer harten Trennung des √ñkosystems f√ºhren. </p><br><br><p>  Es gibt viele Fragen, die mit dieser Diskussion nicht beantwortet werden k√∂nnen.  Wie lange k√∂nnen wir bis zu dem Punkt fortfahren, an dem die √Ñnderung des ABI von "nur n√ºtzlich" zu einer kritischen Notwendigkeit wird?  Wenn wir uns ausdr√ºcklich f√ºr die Unterst√ºtzung der ABI-Stabilit√§t entscheiden, wie teuer wird die √Ñnderung sein, wenn und wann ein derart kritischer Bedarf entsteht?  Wenn Sicherheitsprobleme wie Spectre und Meltdown eine √Ñnderung der Aufrufkonvention erfordern, wie viel kostet C ++, um diesen Meilenstein zu √ºberwinden?  Welcher Anteil der Entwickler verwendet C ++, weil wir behaupten, die Leistung √ºber alles zu stellen?  Schlimmer noch: Wie lange kann C ++ behaupten, die schnellste Sprache zu sein und muss solche Optimierungen nicht vornehmen? </p><br><p>  Wenn wir den ABI bewusst nicht zulassen k√∂nnen oder wollen, muss diese Entscheidung lautstark ge√§u√üert werden.  Wir m√ºssen klar sagen, dass dies eine Sprache ist, mit der die ABI-Stabilit√§t √ºber den letzten Prozent der Produktivit√§t liegt.  Ich bin bereit zu argumentieren, dass dies in der Praxis in den letzten Jahren der Fall war.  Wir m√ºssen die Benutzer wissen lassen, was sie von uns erwarten k√∂nnen, und sie m√ºssen wissen lassen, dass Bibliotheken wie Boost, Folly oder Absail die richtige Wahl treffen m√ºssen, wenn Leistung ben√∂tigt wird.  Dies hilft jedoch nicht bei solchen ABI-bezogenen Einschr√§nkungen in der Sprache selbst wie den Kosten f√ºr die √úbertragung von unique_ptr.  Die Standardbibliothek beh√§lt ihre Bedeutung in diesem Entwicklungsmodell: Die Standardbibliothek wird f√ºr Kompatibilit√§t und Stabilit√§t verwendet.  Dies erfordert m√∂glicherweise eine √Ñnderung des Fokus und der Entwicklungsrichtung: Wir m√∂chten m√∂glicherweise mehr Flexibilit√§t bei sich √§ndernden Bedingungen und keine ‚Äûsaubere‚Äú Leistung erzielen. </p><br><p>  Wenn wir argumentieren, dass Produktivit√§t wichtiger ist als ABI-Stabilit√§t, m√ºssen wir sofort entscheiden, wann genau wir die Abw√§rtskompatibilit√§t ‚Äûbrechen‚Äú und alles M√∂gliche tun, damit das √ñkosystem solche √Ñnderungen akzeptiert.  Und klar und laut erkl√§ren, dass wir diesen Weg gehen.  Sie m√ºssen verstehen, dass je mehr Zeit zwischen solchen √Ñnderungen vergeht, desto teurer werden sie - denn im Laufe der Zeit wird es immer mehr eine nicht unterst√ºtzte Abh√§ngigkeit von ABI geben.  Unsere ‚ÄûImplementierer‚Äú haben sehr deutlich gemacht, dass kompatible C ++ 11-√Ñnderungen schmerzhaft und teuer sind.  Der Wunsch, die Wiederholung solcher Kosten zu vermeiden, ist nat√ºrlich, aber Sie m√ºssen w√§hlen: Entweder wiederholen wir sie nicht, weil wir den ABI nicht √§ndern, oder wir senken die Kosten. </p><br><p>  Im Wesentlichen gibt es drei M√∂glichkeiten f√ºr WG21: <br><br></p><ol><li>  Die Entscheidung, in welcher Version das ABI ge√§ndert wird, spielt in C ++ 23 oder C ++ 26 keine Rolle.  Warnen Sie Personen und entwickeln Sie sofort Tools und Diagnosen, um Orte zu identifizieren, die kaputt gehen.  Konzentriert sich auf konsistentere Praktiken und Tools zur Unterst√ºtzung zuk√ºnftiger ABI-√Ñnderungen.  Es liegt nicht im Interesse eines bestimmten Implementierers, seine Benutzer den Folgen einer √Ñnderung des ABI auszusetzen. Wenn dies bei anderen Implementierungen nicht der Fall ist, sollte die √Ñnderung des ABI eine koordinierte Aktivit√§t zum Nutzen k√ºnftiger Benutzer sein.  Im Idealfall m√ºssen Sie alles kaputt machen, um zu verdeutlichen, dass im C ++ 23-Modus kompilierter Code nicht mit dem in fr√ºheren Modi kompilierten Code kompatibel ist.  Wenn jemand auf eine Neuerstellung verzichten kann und andere Fehler im Layout oder zur Laufzeit haben, erh√∂ht dies nur das Missverst√§ndnis und die Entt√§uschung. </li><li>  Entscheiden Sie, dass wir uns um ABI-Stabilit√§t bem√ºhen, indem Sie die heutige Praxis formalisieren.  Dies ist seit vielen Jahren der Fall, als Standardimplementierer das Recht hatten, gegen ABI-√Ñnderungen ein Veto einzulegen. Wir haben die Abw√§rtskompatibilit√§t von ABI bereits √ºber die Reinheit und Leistung des Designs gestellt.  Wenn wir dies erkennen und den Benutzern klar sagen, wird das √ñkosystem besser.  Der Wert zus√§tzlicher Bibliotheken steigt f√ºr diejenigen, die die letzten Leistungseinbu√üen hinnehmen m√ºssen, aber nicht die vom Standard bereitgestellte Stabilit√§t ben√∂tigen.  Andere leistungsorientierte Sprachen k√∂nnten unsere Position in Zukunft in Frage stellen. </li><li>  Nicht in der Lage sein, eine Richtung zu w√§hlen und den Status Quo zu speichern.  Dies ist f√ºr mich das Worst-Case-Szenario: Wir achten weiterhin implizit verst√§rkt auf die Abw√§rtskompatibilit√§t von ABI.  Wir sagen "Leistung" und stimmen f√ºr "Bin√§rkompatibilit√§t".  Eine solche Dissonanz schadet dem √ñkosystem und impliziert eine mangelnde √úbereinstimmung √ºber die Priorit√§ten der Sprache.  Ich hoffe aufrichtig, dass wir durch die Bem√ºhungen der Umsetzer und der GD den notwendigen Konsens erreichen. </li></ol><br><p>  Ich glaube, dass Option Nr. 1 besser f√ºr Benutzer geeignet ist, die maximale Leistung ben√∂tigen, aber sie hat unglaubliche Kosten f√ºr das √ñkosystem und kann in Zukunft zu einer Fragmentierung der Sprache f√ºhren.  Option 2 ist eine langweilige, verantwortungsbewusste und w√ºrdige Wahl: Es ist traurig zuzugeben, dass wir uns in die Ecke des Raums gemalt haben und versuchen, die damit verbundenen Verluste zu minimieren.  Die Wahl von Option Nr. 3 bedeutet, nicht zu verwalten, und ich bete, dass dies vermieden wird: Jede explizite Wahl ist besser als die derzeitige Dissonanz und Unf√§higkeit, eine Einigung √ºber die Wahl langfristiger Ziele zu erzielen. <br><br>  Ich verstehe, dass wir unsere gegenw√§rtige Position durch viele kleine Handlungen scheinbar vern√ºnftiger Unt√§tigkeit erreicht haben.  In den letzten 10 Jahren wurde keine einzige √Ñnderung vorgenommen, die eine Verletzung der Bin√§rkompatibilit√§t rechtfertigen k√∂nnte, aber die implizite Politik der Aufrechterhaltung der Abw√§rtskompatibilit√§t ist f√ºr das √ñkosystem destruktiv geworden.  Durch die explizite √úbernahme einer solchen Richtlinie er√∂ffnen wir C ++ jedoch eine weitere M√∂glichkeit, die B√ºhne schrittweise zu verlassen: Sie k√∂nnen keine systemorientierte Sprache sein, die auf Produktivit√§t ausgerichtet ist, und so viel Platz f√ºr eine produktivere Sprache lassen.  Theoretisch kann jeder Anbieter entscheiden, ABI in einer zuk√ºnftigen Version zu ‚Äûbrechen‚Äú, aber die allgemeine Denkrichtung scheint anders zu sein.  Ich bin sicher, dass eine Diskussion und ein Konsens zwischen den Implementierern des Standards und der WG21 erforderlich sind: Welche Priorit√§ten sollte ich w√§hlen? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474294/">https://habr.com/ru/post/de474294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474280/index.html">M√∂chten Sie ein DBMS aus erster Hand? Ein offenes Treffen in Nischni Nowgorod - zu sein</a></li>
<li><a href="../de474282/index.html">Datacenter TCP erkl√§rt</a></li>
<li><a href="../de474284/index.html">Nicht nur Futures und Optionen: Welche anderen sekund√§ren Finanzinstrumente gibt es an B√∂rsen und nicht nur</a></li>
<li><a href="../de474286/index.html">Detaillierte Analyse der Simplex-Methode</a></li>
<li><a href="../de474292/index.html">JavaFX-Tutorial: Erste Schritte</a></li>
<li><a href="../de474298/index.html">Implementieren eines P2P-Gateways von Karte zu Karte</a></li>
<li><a href="../de474300/index.html">Zuverl√§ssiges, sicheres und vielseitiges Backup f√ºr U2F</a></li>
<li><a href="../de474302/index.html">So schreiben Sie ein effektives Anwendungsbenutzbarkeitstestskript</a></li>
<li><a href="../de474306/index.html">√Ñndern Sie die Stile f√ºr Zeigen, Fokussieren und aktiven Status.</a></li>
<li><a href="../de474308/index.html">In Python geschriebene Typen f√ºr HTTP-APIs: Instagram-Erfahrung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>