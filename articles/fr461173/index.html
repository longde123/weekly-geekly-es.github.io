<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëåüèæ üò¨ üëè Quelle est l'utilit√© de l'analyse dynamique lorsque vous avez une analyse statique? üçÜ üë∞üèª üö±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Afin de v√©rifier la qualit√© du logiciel, vous devez utiliser de nombreux outils diff√©rents, y compris des analyseurs statiques et dynamiques. Dans cet...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quelle est l'utilit√© de l'analyse dynamique lorsque vous avez une analyse statique?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/461173/">  Afin de v√©rifier la qualit√© du logiciel, vous devez utiliser de nombreux outils diff√©rents, y compris des analyseurs statiques et dynamiques.  Dans cet article, nous allons essayer de comprendre pourquoi un seul type d'analyse, statique ou dynamique, peut ne pas √™tre suffisant pour une analyse logicielle compl√®te et pourquoi il est pr√©f√©rable d'utiliser les deux. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff6/72e/d2b/ff672ed2bf84a53f4170fef43c54a861.png" alt="Figure 1"></div><br><a name="habracut"></a><br>  Notre √©quipe √©crit beaucoup sur l'utilit√© de l'analyse statique et les avantages qu'elle apporte √† vos projets.  Nous aimons ex√©cuter notre outil sur divers projets open-source pour trouver d'√©ventuels bogues, ce qui est notre fa√ßon de vulgariser la m√©thode d'analyse de code statique.  √Ä son tour, l'analyse statique contribue √† rendre les programmes de meilleure qualit√© et plus fiables et √† r√©duire le nombre de vuln√©rabilit√©s potentielles.  Peut-√™tre que tous ceux qui sont directement impliqu√©s dans le travail sur le code source ont ce sentiment de satisfaction d'avoir corrig√© des bogues.  Mais m√™me si le processus de d√©tection (et de correction) des bogues ne d√©clenche pas vos endorphines, vous appr√©ciez certainement l'id√©e de r√©duire les d√©penses de d√©veloppement gr√¢ce √† l'analyseur statique, qui a aid√© vos programmeurs √† utiliser leur temps plus efficacement et plus efficacement.  Pour en savoir plus sur les avantages de l'utilisation de l'analyse statique en termes d'argent, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> .  Il donne une estimation approximative pour PVS-Studio, mais ces r√©sultats peuvent √™tre extrapol√©s √† d'autres outils d'analyse statique disponibles sur le march√©. <br><br>  Tout ce qui pr√©c√®de semble sugg√©rer que le but de l'analyse statique est de trouver les bogues dans le code source le plus t√¥t possible, r√©duisant ainsi les d√©penses de correction des bogues.  Mais pourquoi avons-nous alors besoin d'une analyse dynamique, et pourquoi s'en tenir √† l'une des deux techniques peut √™tre insuffisant?  Donnons des d√©finitions plus formelles et plus claires des analyses statiques et dynamiques et essayons de r√©pondre √† ces questions. <br><br>  L'analyse de code statique est le processus de d√©tection des erreurs et des odeurs de code dans le code source du logiciel.  Pour analyser un programme, vous n'avez pas besoin de l'ex√©cuter;  l'analyse sera effectu√©e sur la base de code disponible.  L'analogie la plus proche de l'analyse statique est ce qu'on appelle la r√©vision de code, sauf que l'analyse statique est une version automatis√©e de la r√©vision de code (c'est-√†-dire effectu√©e par un programme de bot). <br><br>  Les principaux avantages de l'analyse statique: <br><br><ol><li>  D√©tection de bogues aux premiers stades de d√©veloppement.  Cela aide √† rendre la correction de bogues beaucoup moins ch√®re, car plus t√¥t un d√©faut est d√©tect√©, plus il est facile - et, par cons√©quent, moins cher - de le corriger. </li><li>  Il vous permet de localiser pr√©cis√©ment le bogue potentiel dans le code source. </li><li>  Couverture compl√®te du code.  Quelle que soit la fr√©quence √† laquelle un bloc de code ou un autre prend le contr√¥le lors de l'ex√©cution, l'analyse statique v√©rifie la base de code enti√®re. </li><li>  Facile √† utiliser.  Vous n'avez pas besoin de pr√©parer d'ensembles de donn√©es d'entr√©e pour effectuer une v√©rification. </li><li>  Les analyseurs statiques d√©tectent les fautes de frappe et les erreurs li√©es au copier-coller assez rapidement et facilement. </li></ol><br>  Les inconv√©nients objectifs de l'analyse statique: <br><br><ol><li>  Faux positifs in√©vitables.  Un analyseur statique peut se mettre en col√®re contre les fragments de code qui ne contiennent en fait aucun bogue.  Seul le programmeur peut r√©soudre ce probl√®me et marquer un avertissement comme un faux positif, ce qui signifie que cela prendra une partie de son temps de travail. </li><li>  L'analyse statique est g√©n√©ralement mauvaise pour d√©tecter les fuites de m√©moire et les erreurs li√©es √† la concurrence.  Pour d√©tecter de telles erreurs, vous devez en fait ex√©cuter une partie du programme en mode virtuel, ce qui est une t√¢che extr√™mement difficile.  En outre, de tels algorithmes n√©cessiteraient trop de m√©moire et de temps CPU.  Les analyseurs statiques ne vont g√©n√©ralement pas plus loin que l'analyse de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cas</a> simples.  Les analyseurs dynamiques sont plus aptes √† diagnostiquer les fuites de m√©moire et les erreurs li√©es √† la concurrence. </li></ol><br>  Il convient de noter que les analyseurs statiques ne se concentrent pas exclusivement sur la capture de bogues.  Par exemple, ils peuvent fournir des recommandations sur la mise en forme du code.  Certains outils vous permettent de v√©rifier la conformit√© de votre code avec la norme de codage √† laquelle votre entreprise se conforme.  Cela inclut l'indentation de diverses constructions, l'utilisation de caract√®res d'espace / tabulation, etc.  De plus, l'analyse statique peut √™tre utile pour mesurer les m√©triques.  Une m√©trique logicielle est une mesure quantitative du degr√© de propri√©t√© d'un programme ou de ses sp√©cifications.  Consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> pour en savoir plus sur les autres utilisations de l'analyse statique. <br><br>  L'analyse de code dynamique est l'analyse effectu√©e sur un programme au moment de l'ex√©cution.  Cela signifie que vous devez d'abord convertir votre code source en un fichier ex√©cutable.  En d'autres termes, le code contenant des erreurs de compilation ou de g√©n√©ration ne peut pas √™tre v√©rifi√© par ce type d'analyse.  La v√©rification est effectu√©e avec un ensemble de donn√©es d'entr√©e alimentant le programme en cours d'analyse.  C'est pourquoi l'efficacit√© de l'analyse dynamique d√©pend directement de la qualit√© et de la quantit√© des donn√©es d'entr√©e de test.  Ce sont ces donn√©es qui d√©terminent l'√©tendue de la couverture du code √† la fin du test. <br><br>  Gr√¢ce aux tests dynamiques, vous pouvez obtenir les m√©triques et avertissements suivants: <br><br><ol><li>  Ressources utilis√©es: temps d'ex√©cution de l'ensemble du programme ou de ses parties individuelles, nombre de requ√™tes externes (par exemple, vers une base de donn√©es), quantit√© de RAM et autres ressources utilis√©es par le programme. </li><li>  L'√©tendue de la couverture du code par les tests et autres mesures. </li><li>  Bogues logiciels: division par z√©ro, d√©r√©f√©rence nulle, fuites de m√©moire, conditions de concurrence. </li><li>  Quelques failles de s√©curit√©. </li></ol><br>  Les principaux avantages de l'analyse dynamique: <br><br><ol><li> Vous n'avez pas besoin d'avoir acc√®s au code source du programme pour l'analyser.  Il convient de noter, cependant, que les outils d'analyse dynamique se diff√©rencient par la fa√ßon dont ils interagissent avec le programme analys√© (ceci est discut√© plus en d√©tail <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ).  Par exemple, une technique d'analyse dynamique assez courante implique l'instrumentation du code avant la v√©rification, c'est-√†-dire l'ajout de fragments de code sp√©ciaux au code source de l'application pour que l'analyseur puisse diagnostiquer les erreurs.  Dans ce cas, vous devez disposer du code source du programme. </li><li>  Il peut d√©tecter des erreurs complexes de gestion de la m√©moire telles que l'indexation au-del√† des limites du tableau et les fuites de m√©moire. </li><li>  Il peut analyser le code multithread au moment de l'ex√©cution, d√©tectant ainsi les probl√®mes potentiels li√©s √† l'acc√®s aux ressources partag√©es ou √† d'√©ventuels blocages. </li><li>  La plupart des impl√©mentations d'analyseurs dynamiques ne g√©n√®rent pas de faux positifs car les erreurs sont d√©tect√©es lorsqu'elles se produisent.  Par cons√©quent, un avertissement √©mis par un analyseur dynamique n'est pas une pr√©diction faite par l'outil sur la base de l'analyse du mod√®le de programme mais une simple d√©claration du fait qu'une erreur s'est produite. </li></ol><br>  Les inconv√©nients de l'analyse dynamique: <br><br><ol><li>  La couverture compl√®te du code n'est pas garantie.  Autrement dit, il est tr√®s peu probable que vous obteniez une couverture √† 100% par des tests dynamiques. </li><li>  Les analyseurs dynamiques sont mauvais pour d√©tecter les erreurs logiques.  Par exemple, une condition toujours vraie n'est pas un bogue du point de vue d'un analyseur dynamique car une telle v√©rification incorrecte dispara√Æt tout simplement plus t√¥t √† l'√©tape de compilation. </li><li>  Il est plus difficile de localiser pr√©cis√©ment l'erreur dans le code. </li><li>  L'analyse dynamique est plus difficile √† utiliser que l'analyse statique, car vous devez fournir suffisamment de donn√©es au programme pour obtenir de meilleurs r√©sultats et obtenir une couverture de code aussi compl√®te que possible. </li></ol><br>  L'analyse dynamique est particuli√®rement utile dans les domaines o√π la fiabilit√© du programme, le temps de r√©ponse ou les ressources consomm√©es sont la principale pr√©occupation.  Un syst√®me en temps r√©el g√©rant un secteur de production critique ou un serveur de base de donn√©es sont quelques exemples de tels syst√®mes.  Toute erreur dans ces domaines peut √™tre critique. <br><br>  Revenant √† la question de savoir pourquoi s'en tenir √† l'un des deux types d'analyse peut ne pas √™tre suffisant, jetons un coup d'≈ìil √† quelques exemples assez triviaux de bogues qu'une m√©thode d'analyse n'a aucun probl√®me √† diagnostiquer tandis que l'autre n'est pas apte √† d√©tecter et vice versa. <br><br>  L'exemple suivant est tir√© du projet Clang: <br><br><pre><code class="cpp hljs">MapTy PerPtrTopDown; MapTy PerPtrBottomUp; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearBottomUpPointers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ PerPtrTopDown.clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearTopDownPointers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ PerPtrTopDown.clear(); }</code> </pre> <br>  Un analyseur statique indiquerait que les corps des deux fonctions sont identiques.  Bien s√ªr, deux fonctions ayant des corps identiques ne sont pas n√©cessairement un signe d√©finitif de bogue, mais il est tr√®s probable qu'elles r√©sultent de l'utilisation de la technique du copier-coller combin√©e √† une n√©gligence du c√¥t√© du programmeur - et cela conduit √† un comportement inattendu.  Dans ce cas, la m√©thode <i>clearBottomUpPointers</i> doit appeler la m√©thode <i>PerPtrBottomUp.clear</i> .  L'analyse dynamique ne remarquerait rien de mal dans cet exemple car c'est un morceau de code absolument l√©gitime de son point de vue. <br><br>  Un autre exemple.  Supposons que nous ayons la fonction suivante: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OutstandingIssue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *strCount)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> nCount; sscanf_s(strCount, <span class="hljs-string"><span class="hljs-string">"%u"</span></span>, &amp;nCount); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, nCount * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); }</code> </pre> <br>  En th√©orie, un analyseur statique pourrait soup√ßonner qu'il y a quelque chose de mal avec ce code, mais l'impl√©mentation d'un tel diagnostic est une t√¢che tr√®s difficile et inutile.  L'exemple est tir√© de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> , qui explique √©galement pourquoi c'est une mauvaise id√©e d'enseigner aux analyseurs statiques comment diagnostiquer des erreurs comme √ßa.  En bref, les analyseurs statiques sont tr√®s mal √† comprendre qu'un appel de la fonction <i>memset</i> peut entra√Æner une indexation au-del√† des limites du tableau car ils ne peuvent pas pr√©voir le nombre qui sera lu √† partir de la cha√Æne <i>strCount</i> ;  et si la valeur de <i>strCount</i> est lue dans un fichier, cela devient une t√¢che impossible pour l'analyse statique.  D'un autre c√¥t√©, un analyseur dynamique n'aurait aucun probl√®me √† remarquer et √† signaler l'erreur de gestion de la m√©moire dans ce code (√©tant donn√© que le programme re√ßoit les bonnes donn√©es). <br><br>  Cet article ne vise pas √† comparer les analyses statiques et dynamiques.  Il n'existe pas de technique unique permettant de diagnostiquer toute la vari√©t√© des d√©fauts logiciels.  Aucun type d'analyse ne peut remplacer compl√®tement l'autre.  Pour am√©liorer la qualit√© de vos programmes, vous devrez utiliser diff√©rents types d'outils pour qu'ils se compl√®tent.  J'esp√®re que les exemples ci-dessus sont suffisamment convaincants. <br><br>  Je ne souhaite pas avoir l'air trop partisan de l'analyse statique, mais c'est cette technique dont on parle le plus et, plus important encore, que les entreprises ont r√©cemment int√©gr√© dans leurs processus CI.  L'analyse statique agit comme l'une des √©tapes des soi-disant portes de qualit√© pour construire un produit logiciel fiable et de haute qualit√©.  Nous pensons que l'analyse statique va devenir une pratique de d√©veloppement de logiciels standard dans quelques ann√©es, tout comme les tests unitaires l'ont fait autrefois. <br><br>  Pour conclure, je voudrais souligner une fois de plus que l'analyse dynamique et l'analyse statique ne sont que deux m√©thodes diff√©rentes, qui se compl√®tent.  Au final, toutes ces techniques ont pour seul objectif d'augmenter la qualit√© des logiciels et de r√©duire les d√©penses de d√©veloppement. <br><br>  <b>R√©f√©rences:</b> <br><br><ol><li>  Terminologie.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Analyse de code statique</a> . </li><li>  Terminologie.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Analyse de code dynamique</a> . </li><li>  Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Analyse de code statique et dynamique</a> . </li><li>  Andrey Karpov.  Mythes sur l'analyse statique.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le troisi√®me mythe - l'analyse dynamique est meilleure que l'analyse statique</a> . </li><li>  Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PVS-Studio ROI</a> . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461173/">https://habr.com/ru/post/fr461173/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461159/index.html">Ivideon Bridge: comment connecter les anciens syst√®mes de vid√©osurveillance au cloud</a></li>
<li><a href="../fr461161/index.html">D√©l√©gu√© aux pr√©f√©rences Android</a></li>
<li><a href="../fr461163/index.html">Qu'est-ce qui relie le paradoxe de l'anniversaire et la vuln√©rabilit√© des signatures √©lectroniques?</a></li>
<li><a href="../fr461165/index.html">La biom√©trie se rapproche</a></li>
<li><a href="../fr461171/index.html">Telegram a appris √† se d√©guiser en HTTPS</a></li>
<li><a href="../fr461175/index.html">27 choses que j'aimerais savoir √† l'avance avant de commencer la programmation</a></li>
<li><a href="../fr461177/index.html">Historique Internet: ARPANET - Sous-r√©seau</a></li>
<li><a href="../fr461179/index.html">Pourquoi la preuve du grand th√©or√®me de Fermat n'a pas besoin d'√™tre am√©lior√©e</a></li>
<li><a href="../fr461181/index.html">Nous introduisons IdM. Vue de l'ing√©nieur d'impl√©mentation</a></li>
<li><a href="../fr461185/index.html">JsonDiscovery: Changer l'exp√©rience de visualisation de JSON dans un navigateur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>