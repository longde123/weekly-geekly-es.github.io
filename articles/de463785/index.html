<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🤝‍👨🏼 💦 🛅 Übersicht der Terminalemulatoren 💇🏻 ▪️ 👏🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein paar Worte von unserem Übersetzungsbüro: Normalerweise möchte jeder die neuesten Materialien und Veröffentlichungen übersetzen, und wir sind keine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Übersicht der Terminalemulatoren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/463785/"> <i>Ein paar Worte von unserem Übersetzungsbüro: Normalerweise möchte jeder die neuesten Materialien und Veröffentlichungen übersetzen, und wir sind keine Ausnahme.</i>  <i>Terminals werden jedoch nicht einmal pro Woche aktualisiert.</i>  <i>Deshalb haben wir für Sie einen im Frühjahr 2018 veröffentlichten Artikel von Antoine Bopre übersetzt: Trotz des nach modernen Maßstäben soliden „Zeitalters“ hat das Material unserer Meinung nach seine Relevanz nicht vollständig verloren.</i>  <i>Darüber hinaus besteht das Original aus einer Reihe von zwei Artikeln, die wir jedoch zu einem großen Beitrag zusammengefasst haben.</i> <br><br><img src="https://habrastorage.org/webt/_4/qm/3j/_4qm3jhmwxnoyxqc6jblinmiuoa.jpeg"><br><br>  Terminals nehmen einen besonderen Platz in der Computergeschichte ein, aber in den letzten Jahrzehnten wurden sie "gezwungen", zusammen mit der Befehlszeile vor dem Hintergrund allgegenwärtiger grafischer Oberflächen buchstäblich zu überleben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Terminalemulatoren</a> ersetzten ihre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hardware-Gegenstücke</a> , die wiederum eine Modifikation von Systemen auf Lochkarten und Kippschaltern waren.  Moderne Distributionen verfügen über eine Vielzahl von Terminalemulatoren in allen Formen und Farben.  Und während viele mit dem Standardterminal ihrer Arbeitsumgebung zufrieden sind, sind einige stolz darauf, offen exotische Software zu verwenden, um ihre Lieblings-Shell oder ihren Lieblings-Texteditor zu starten.  Wie wir in diesem Artikel sehen werden, wurden jedoch nicht alle Terminals in einem Bild und einer Abbildung erstellt: Sie unterscheiden sich stark in Funktionalität, Größe und Leistung. <br><a name="habracut"></a><br><br>  Einige Terminals weisen erstaunliche Sicherheitslücken auf, und die meisten verfügen über völlig andere Funktionen, von der Unterstützung der Benutzeroberfläche mit Registerkarten bis hin zur Skripterstellung.  Obwohl wir uns <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der fernen Vergangenheit mit Terminalemulatoren befasst haben</a> , handelt es sich bei diesem Artikel um ein Update des vorherigen Materials, mit dessen Hilfe die Leser bestimmen können, welches Terminal 2018 verwendet werden soll.  In der ersten Hälfte des Artikels werden Funktionen verglichen und in der zweiten Hälfte die Leistung bewertet. <br><br>  Hier sind die Terminals, die ich überprüft habe: <br><br><img src="https://habrastorage.org/webt/c4/3l/gy/c43lgydftmr0spxf35oq3vgyozy.jpeg"><br><br>  Vielleicht sind dies nicht die neuesten Versionen, da ich mich zum Zeitpunkt des Schreibens auf stabile Builds beschränkt habe, die ich auf Debian 9 oder Fedora 27 einführen konnte. Die einzige Ausnahme ist Alacritty.  Er ist ein Nachkomme von Terminals mit GPU-Beschleunigung und wurde für diese Aufgabe in einer ungewöhnlichen und neuen Sprache geschrieben - Rust.  Ich habe Web-Terminals von meiner Überprüfung ausgeschlossen (auch für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Electron</a> ), da vorläufige Tests ihre extrem schlechte Leistung zeigten. <br><br><h4>  Unicode-Unterstützung </h4><br>  Ich habe meine Tests mit Unicode-Unterstützung gestartet.  Der erste Terminaltest bestand darin, die Unicode-Zeichenfolge aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem Wikipedia-Artikel</a> anzuzeigen: "é, Δ ,,, ק, م, ๗, あ, 叶, 葉 und 말".  Dieser einfache Test zeigt, ob das Terminal weltweit ordnungsgemäß funktioniert.  Das xterm-Terminal zeigt das arabische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mem-</a> Symbol in der Standardkonfiguration nicht an: <br><br><img src="https://habrastorage.org/webt/gv/no/zm/gvnozm-mh17i-33qam74-r2i8n0.png"><br><br>  Standardmäßig verwendet xterm die klassische "feste" Schriftart, die laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiki</a> seit 1997 "eine signifikante Unicode-Abdeckung" aufweist.  In dieser Schriftart passiert etwas, das dazu führt, dass das Zeichen als leerer Rahmen angezeigt wird. Erst wenn die Textschrift auf über 20 Punkte erhöht wird, wird das Zeichen endlich korrekt angezeigt.  Ein solcher „Fix“ unterbricht jedoch die Anzeige anderer Unicode-Zeichen: <br><br><img src="https://habrastorage.org/webt/ke/lt/oe/keltoepwoz-dt_388rrmzaw7xy0.png"><br><br>  Diese Screenshots wurden in Fedora 27 aufgenommen, da sie bessere Ergebnisse lieferte als Debian 9, wo einige ältere Versionen von Terminals (insbesondere mlterm) mit Schriftarten nicht richtig funktionieren konnten.  Glücklicherweise wurde dies in späteren Versionen behoben. <br><br>  Achten Sie nun auf die Zeichenfolgenzuordnung in xterm.  Es stellt sich heraus, dass das Mem-Symbol und das nachfolgende semitische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Qoph</a> zu RTL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-</a> Skripten (von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rechts nach links</a> ) gehören, daher sollten sie technisch von rechts nach links angezeigt werden.  Webbrowser wie Firefox 57 verarbeiten die obige Zeile korrekt.  Eine einfachere Version des RTL-Textes ist das hebräische Wort " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sarah</a> " ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">שרה</a> ).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die bidirektionale Wiki-Seite</a> sagt Folgendes: <br><blockquote>  „Viele Computerprogramme können bidirektionalen Text nicht korrekt anzeigen.  Zum Beispiel besteht der hebräische Name „Sarah“ aus den Symbolen sin (ש) (rechts), resh (ר) und schließlich heh (ה) (links). “ </blockquote><br>  Viele Terminals bestehen diesen Test nicht: Alacritty, die von VTE abgeleiteten Terminals Gnome und XFCE, urxvt, st und xterm zeigen "Sarah" in umgekehrter Reihenfolge an, als hätten wir diesen Namen als "Aras" geschrieben. <br><br><img src="https://habrastorage.org/webt/z4/yw/gi/z4ywgic4drs6yom_j1xxlnvgh5e.png"><br><br>  Ein weiteres Problem bei bidirektionalen Texten besteht darin, dass sie irgendwie ausgerichtet werden müssen, insbesondere beim Mischen von RTL- und LTR-Texten.  RTL-Skripte sollten auf der rechten Seite des Terminalfensters ausgeführt werden. Was sollte jedoch bei Terminals geschehen, die standardmäßig LTR-Englisch verwenden?  Die meisten von ihnen haben keine speziellen Mechanismen und richten den gesamten Text links aus (einschließlich Konsole).  Die Ausnahmen sind pterm und mlterm, die sich an Standards halten und solche Linien rechts ausrichten. <br><br><img src="https://habrastorage.org/webt/ji/9b/xx/ji9bxx3oy7oqjavtph7zjajxwhq.png"><br><br><h4>  Einsteckschutz </h4><br>  Das nächste wichtige Merkmal, das ich für mich selbst festgelegt habe, ist der Schutz vor dem Einsetzen.  Obwohl allgemein bekannt ist, dass Zaubersprüche wie: <br><br><pre><code class="plaintext hljs">$ curl http://example.com/ | sh</code> </pre> <br>  Es handelt sich um Push-Code-Ausführungsbefehle. Nur wenige Menschen wissen, dass versteckte Befehle beim Kopieren und Einfügen aus einem Webbrowser in die Konsole eindringen können, selbst nach einer gründlichen Überprüfung.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Teststelle von Gianna Horne</a> zeigt auf brillante Weise, wie harmlos das Team aussieht: <br><br><pre> <code class="plaintext hljs">git clone git: //git.kernel.org/pub/scm/utils/kup/kup.git</code> </pre> <br>  Beim Einfügen von der Horn-Website in das Terminal wird dies zu einem solchen Ärgernis: <br><br><pre> <code class="plaintext hljs">git clone /dev/null; clear; echo -n "Hello "; whoami|tr -d '\n'; echo -e '!\nThat was a bad idea. Don'"'"'t copy code from websites you don'"'"'t trust! \ Here'"'"'s the first line of your /etc/passwd: '; head -n1 /etc/passwd git clone git://git.kernel.org/pub/scm/utils/kup/kup.git</code> </pre> <br>  Wie funktioniert es  Schädlicher Code wird in den <b>&lt;span&gt;</b> -Block eingefügt, der mithilfe von CSS aus dem Sichtfeld des Benutzers verschoben wird. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Einfügemodus in Klammern ist</a> eindeutig darauf ausgelegt, solche Angriffe zu neutralisieren.  In diesem Modus schließen die Terminals den eingefügten Text in ein Paar spezieller Escape-Sequenzen ein, um die Shell über die Herkunft dieses Textes zu informieren.  Die Shell erhält also ein Signal, dass sie Sonderzeichen, die der eingefügte Text enthalten kann, ignorieren kann.  Alle Terminals bis zum ehrwürdigen xterm unterstützen diese Funktion, aber das Einfügen im Klammermodus erfordert die Unterstützung einer Shell oder Anwendung, die auf dem Terminal ausgeführt wird.  Beispielsweise benötigt Software, die die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GNU Readline</a> (denselben Bash) verwendet, eine <b>~ / .inputrc-Datei</b> : <br><br><pre> <code class="plaintext hljs">set enable-bracketed-paste on</code> </pre> <br>  Leider zeigt die Horn-Testseite auch, wie Sie diesen Schutz umgehen können, indem Sie den Text selbst formatieren und die Anwendung des Klammermodus vorzeitig beenden.  Dies funktioniert, weil einige Terminals Escape-Sequenzen nicht korrekt filtern, bevor sie ihre eigenen hinzufügen.  Zum Beispiel konnte ich in meinem Fall die Konsolentests nicht erfolgreich abschließen, selbst wenn die korrekte Konfiguration der <b>.inputrc-</b> Datei berücksichtigt wurde.  Dies bedeutet, dass Sie aufgrund einer nicht unterstützten Anwendung oder einer nicht ordnungsgemäß konfigurierten Shell leicht Systemkonfigurationsschäden erleiden können.  Dies ist besonders gefährlich, wenn Sie Remote-Server betreten, bei denen ein sorgfältiges Studium der Konfiguration weniger häufig ist, insbesondere wenn Sie über viele solcher Remote-Computer verfügen. <br><br>  Eine gute Lösung für dieses Problem ist das Plugin zur Bestätigung des Einfügens für das <b>urxvt-</b> Terminal, das lediglich um Erlaubnis zum Einfügen von Text mit neuen Zeilen bittet.  Ich habe keine sicherere Option für den von Horn beschriebenen Textangriff gefunden. <br><br><h4>  Registerkarten und Profile </h4><br>  Eine beliebte Funktion ist jetzt die Unterstützung einer Oberfläche mit Registerkarten, die wir als ein Terminalfenster definieren, das einige weitere Terminals enthält.  Für verschiedene Terminals ist diese Funktion unterschiedlich, und obwohl herkömmliche Terminals wie xterm überhaupt keine Registerkarten unterstützen, verfügen modernere Terminal-Inkarnationen, die durch Xfce Terminal, GNOME Terminal und Konsole dargestellt werden, über diese Funktion.  Urxvt unterstützt auch Registerkarten, allerdings nur, wenn das Plugin verwendet wird.  In Bezug auf die Unterstützung von Registerkarten als solche ist Terminator der unbestrittene Marktführer: Es unterstützt nicht nur Registerkarten, sondern kann Terminals auch in beliebiger Reihenfolge anordnen (siehe Abbildung unten). <br><br><img src="https://habrastorage.org/webt/eq/2s/_f/eq2s_fad0t8_7v6uymzkg7xndvs.png"><br><br>  Ein weiteres Merkmal von Terminator ist die Möglichkeit, diese Registerkarten zu "gruppieren" und dieselben Tastenanschläge gleichzeitig an mehrere Terminals zu senden. Dies bietet ein grobes Tool für die gleichzeitige Ausführung von Massenoperationen auf mehreren Servern.  Eine ähnliche Funktion ist auch in Konsole implementiert.  Um diese Funktion in anderen Terminals verwenden zu können, müssen Sie Software von Drittanbietern wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cluster SSH</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">xlax</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tmux verwenden</a> . <br><br>  Registerkarten funktionieren besonders gut mit Profilen: Sie können beispielsweise eine Registerkarte für E-Mail, eine andere für Chat usw. verwenden.  Dies wird von Konsole und GNOME Terminal gut unterstützt.  In beiden Fällen kann jede Registerkarte ihr Profil automatisch starten.  Terminator unterstützt auch Profile, aber ich konnte keine Möglichkeit finden, bestimmte Programme automatisch zu starten, wenn ich eine bestimmte Registerkarte öffne.  Andere Terminals haben überhaupt nicht das Konzept eines Profils. <br><br><h4>  Ryushechki </h4><br>  Das Letzte, was ich im ersten Teil dieses Artikels betrachten werde, ist das Erscheinungsbild der Terminals.  Beispielsweise unterstützen GNOME, Xfce und urxvt die Transparenz, haben jedoch kürzlich die Unterstützung für Hintergrundbilder eingestellt und einige Benutzer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gezwungen</a> , zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tilix-</a> Terminal zu wechseln.  Persönlich bin ich nur mit <b>Xresources zufrieden</b> , das die grundlegenden Hintergrundfarben für urxvt festlegt.  Benutzerdefinierte Farbthemen können jedoch Probleme verursachen.  Beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">funktioniert Solarized</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht</a> mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">htop-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IPTraf-Anwendungen</a> , da diese bereits ihre eigenen Farben verwenden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das ursprüngliche VT100-Terminal</a> unterstützte keine Farben, und die neuen waren häufig auf eine Palette mit 256 Farben beschränkt.  Für fortgeschrittene Benutzer, die ihre Terminals formatieren, können Shell-Anforderungen oder Statusleisten auf komplexe Weise eine unangenehme Einschränkung darstellen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gist</a> verfolgt, welche Terminals True Color-Unterstützung bieten.  Meine Tests bestätigen, dass st-, Alacritty- und VTE-basierte Terminals True Color perfekt unterstützen.  Andere Terminals fühlen sich in dieser Hinsicht nicht sehr gut an und zeigen nicht einmal 256 Farben an.  Unten sehen Sie den Unterschied zwischen der True Color-Unterstützung in GNOME-, st- und xterm-Terminals, die mit ihrer 256-Farben-Palette gute Arbeit leisten, und urxvt, das den Test nicht nur nicht besteht, sondern stattdessen sogar einige blinkende Zeichen anzeigt sie. <br><br><img src="https://habrastorage.org/webt/3u/go/mq/3ugomq0evrr7ql1h9xsapwjp_om.png"><br><br>  Einige Terminals analysieren auch Text auf URL-Muster, um Links anklickbar zu machen.  Dies gilt für alle von VTE abgeleiteten Terminals, während urxvt ein spezielles Plug-In benötigt, das URLs mit einem Klick oder einer Tastenkombination transformiert.  Andere Terminals, die ich getestet habe, zeigen URLs auf andere Weise an. <br><br>  Ein neuer Trend für Terminals ist schließlich die Option Bildlaufpuffer.  Zum Beispiel gibt es in st keinen Bildlaufpuffer;  Es wird davon ausgegangen, dass der Benutzer einen Terminal-Multiplexer wie tmux und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GNU Screen verwendet</a> . <br><br>  Alacritty fehlen auch Reverse-Scroll-Puffer, aber die Unterstützung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wird in Kürze</a> aufgrund des "umfassenden Feedbacks" der Benutzer zu diesem Thema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hinzugefügt</a> .  Zusätzlich zu diesen Upstarts unterstützt jedes Terminal, das ich getestet habe und das ich finden konnte, das Rückwärts-Scrollen. <br><br><h4>  Zwischensummen </h4><br>  Im zweiten Teil des Materials ( <i>im Original waren dies zwei verschiedene Artikel - ca. Per.</i> ) Wir werden Leistung, Speichernutzung und Verzögerung vergleichen.  Wir sehen jedoch bereits, dass einige der fraglichen Terminals schwerwiegende Mängel aufweisen.  Beispielsweise können Benutzer, die regelmäßig mit RTL-Skripten arbeiten, auf mlterm und pterm achten, da sie solche Aufgaben besser bewältigen als andere.  Konsole schnitt ebenfalls gut ab.  Benutzer, die nicht mit RTL-Skripten arbeiten, können etwas anderes auswählen. <br><br>  Unter dem Gesichtspunkt der Sicherheit gegen das Einfügen von Schadcode zeichnet sich urxvt durch die besondere Implementierung des Schutzes gegen diese Art von Angriff aus, was mir auf jeden Fall zweckmäßig erscheint.  Wer auf der Suche nach Schnickschnack ist, sollte sich Konsole ansehen.  Schließlich ist anzumerken, dass VTE eine hervorragende Basis für Terminals ist, die Farbunterstützung, URL-Erkennung usw. garantiert.  Auf den ersten Blick kann das Standardterminal, das mit Ihrer bevorzugten Umgebung geliefert wird, alle Anforderungen erfüllen. Lassen Sie diese Frage jedoch offen, bis wir die Leistung herausgefunden haben. <br><br><h4>  <i>Setzen Sie das Gespräch fort</i> </h4><br>  Im Allgemeinen scheint die Terminalleistung an sich ein weit hergeholtes Problem zu sein. Wie sich jedoch herausstellte, weisen einige von ihnen eine überraschend große Verzögerung für Software dieses grundlegenden Typs auf.  Wir werden uns auch genauer mit der sogenannten "Geschwindigkeit" (tatsächlich der Bildlaufgeschwindigkeit) und dem Speicherverbrauch des Terminals befassen (wenn man bedenkt, dass dies heute nicht mehr so ​​kritisch ist wie vor Jahrzehnten). <br><br><h4>  Verzögerung </h4><br>  Nach einer gründlichen Untersuchung der Terminalleistung kam ich zu dem Schluss, dass der wichtigste Parameter in dieser Hinsicht die Verzögerungsgröße (Ping) ist.  In seinem Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Wir drucken gerne“</a> untersuchte Pavel Fatin die Verzögerung verschiedener Texteditoren und deutete an, dass Terminals in dieser Hinsicht langsamer arbeiten können als die schnellsten Texteditoren.  Es war dieser Hinweis, der mich letztendlich dazu brachte, meine eigenen Tests zu starten und diesen Artikel zu schreiben. <br><br>  Aber was ist eine Verzögerung und warum ist sie so wichtig?  In seinem Artikel definierte Fatin es als "die Verzögerung zwischen dem Drücken einer Taste und der entsprechenden Bildschirmaktualisierung" und zitierte das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Handbuch zur Mensch-Computer-Interaktion"</a> mit den Worten: "Die Verzögerung der visuellen Rückmeldung auf dem Computerbildschirm hat einen wichtigen Einfluss auf das Verhalten der Schreibkraft und ihre Zufriedenheit ". <br><br>  Fatin erklärt, dass ein solcher Ping tiefere Konsequenzen hat als nur die Zufriedenheit: „Das Tippen wird langsamer, es treten mehr Fehler auf, die Augen- und Muskelverspannungen nehmen zu.“  Mit anderen Worten, eine große Verzögerung kann zu Tippfehlern sowie zu einer Verschlechterung der Codequalität führen, da dies zu einer zusätzlichen kognitiven Belastung des Gehirns führt.  Aber noch schlimmer, Ping "erhöht die Spannung der Augen und Muskeln", was anscheinend die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung von Berufsverletzungen</a> in der Zukunft impliziert ( <i>anscheinend meint der Autor Probleme mit den Muskeln der Augen, des Rückens, der Arme und natürlich des Sehvermögens, - ca. Per.</i> ) Aufgrund wiederholter Beanspruchung. <br><br>  Einige dieser Effekte sind seit langem bekannt, und die Ergebnisse einer 1976 in der Zeitschrift Ergonomics veröffentlichten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Studie</a> besagen, dass eine Verzögerung von 100 Millisekunden "die Wählgeschwindigkeit erheblich verschlechtert".  In jüngerer <a href="">Zeit</a> wurde im GNOME-Benutzerhandbuch <a href="">eine akzeptable Antwortzeit</a> von 10 Millisekunden eingeführt. Wenn wir weiter gehen, zeigt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Microsoft Research</a> , dass 1 Millisekunde ideal ist. <br><br>  Fatin führte seine Tests an Texteditoren durch;  Er hat ein tragbares Tool namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typometer erstellt</a> , mit dem ich Ping in Terminalemulatoren getestet habe.  Beachten Sie, dass der Test im Simulationsmodus durchgeführt wurde: In der Realität müssen wir auch die Eingangsverzögerung (Tastatur, USB-Controller usw.) und die Ausgabe (Grafikkartenpuffer, Monitor) berücksichtigen.  Laut Fatin sind es in typischen Konfigurationen etwa 20 ms.  Wenn Sie über Spielgeräte verfügen, können Sie einen Indikator von nur 3 Millisekunden erreichen.  Da wir bereits über so schnelle Geräte verfügen, sollte die Anwendung auch keine Verzögerung einführen.  Das Ziel von Fatin ist es, die Anwendung um bis zu 1 Millisekunde zu verzögern oder das Wählen ohne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">messbare Verzögerung</a> zu erreichen, wie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IntelliJ IDEA 15</a> . <br><br>  Und hier sind die Ergebnisse meiner Messungen sowie einige Ergebnisse von Fatin, um zu zeigen, dass mein Experiment mit seinen Tests übereinstimmt: <br><br><img src="https://habrastorage.org/webt/4s/u-/vn/4su-vnzyvqb35-uwp0ywpq2g76e.jpeg"><br><br>  Das erste, was mir auffiel, war die beste Reaktionszeit für ältere Programme wie xterm und mlterm.  Mit der schlechtesten Registerlatenz (2,4 ms) zeigten sie bessere Ergebnisse als das schnellste moderne Terminal (10,6 ms für st).  Kein einziges modernes Terminal unterschreitet einen Schwellenwert von 10 Millisekunden.  Insbesondere erfüllt Alacritty nicht die Anforderungen für den „schnellsten vorhandenen Terminalemulator“, obwohl sich seine Ergebnisse seit der ersten Überprüfung im Jahr 2017 verbessert haben.  In der Tat sind sich die Autoren des Projekts <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Situation bewusst</a> und arbeiten daran, die Anzeige zu verbessern.  Es sollte auch beachtet werden, dass Vim, das GTK3 verwendet, eine Größenordnung langsamer ist als sein GTK2-Gegenstück.  Daraus können wir schließen, dass GTK3 eine zusätzliche Verzögerung erzeugt, was sich in allen anderen Terminals widerspiegelt, die es verwenden (Terminator, Xfce4-Terminal und GNOME-Terminal). <br><br>  Unterschiede sind jedoch möglicherweise für das Auge nicht sichtbar.  Wie Fatin erklärt: "Es ist nicht notwendig, sich der Verzögerung bewusst zu sein, damit sie sich auf Sie auswirkt."  Fatin warnt auch vor einer Standardabweichung: "Unregelmäßigkeiten in der Länge der Verzögerung (Jitter) verursachen aufgrund ihrer Unvorhersehbarkeit eine zusätzliche Belastung." <br><br><img src="https://habrastorage.org/webt/dq/a4/0v/dqa40vpdfz4k9uctottd6h9j2we.png"><br><br>  Die obige Grafik wurde auf reinem Debian 9 (Stretch) mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">i3-Fenstermanager aufgenommen</a> .  Diese Umgebung liefert die besten Ergebnisse bei Verzögerungstests.  Wie sich herausstellte, erzeugt GNOME einen zusätzlichen Ping von 20 ms für alle Dimensionen.  Eine mögliche Erklärung hierfür ist das Vorhandensein von Programmen mit synchroner Verarbeitung von Eingabeereignissen.  Fatin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">führt</a> für diesen Fall ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Workrave-</a> Beispiel an, das eine Verzögerung hinzufügt, indem alle Eingabeereignisse synchron verarbeitet werden.  Standardmäßig verfügt GNOME auch über einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mutter-</a> Fenstermanager, der eine zusätzliche Pufferstufe erstellt, die sich auf den Ping auswirkt und eine Verzögerung von mindestens 8 Millisekunden hinzufügt. <br><br><img src="https://habrastorage.org/webt/ec/t9/ap/ect9apxhg0v5l0_q04qujn5xu4k.png"><br><br><h4>  Bildlaufgeschwindigkeit </h4><br>  Der nächste Test ist der herkömmliche Geschwindigkeits- oder Bandbreitentest, bei dem gemessen wird, wie schnell das Terminal durch eine Seite scrollen kann und eine große Textmenge auf dem Bildschirm anzeigt.  Die Mechanik des Tests variiert;  Der ursprüngliche Test bestand darin, mit dem Befehl seq dieselbe Textzeichenfolge zu generieren.  Andere Tests umfassen einen Test von Thomas E. Dickey (dem xterm-Betreuer), der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Datei terminfo.src</a> wiederholt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">herunterlädt</a> .  In einer anderen Überprüfung der Terminalleistung verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Den Luu</a> eine Base32-codierte Zeichenfolge aus zufälligen Bytes, die mit cat an das Terminal ausgegeben wird.  Luu hält einen solchen Test für „so nutzlos, wie man es sich vorstellen kann“ und schlägt vor, stattdessen die Reaktion des Terminals als Hauptindikator zu verwenden.  Dickey nennt seinen Test auch irreführend.  Beide Autoren erkennen jedoch an, dass die Bandbreite des Terminalfensters ein Problem sein kann.  Luu stellte fest, dass Emacs Eshell beim Anzeigen großer Dateien einfrierte, und Dickie optimierte das Terminal, um die visuelle Langsamkeit von xtrerm zu beseitigen.  Daher gibt es immer noch einen Grund für diesen Test, aber da der Renderprozess von Terminal zu Terminal sehr unterschiedlich ist, kann er auch als Testkomponente zum Überprüfen anderer Parameter verwendet werden. <br><br><img src="https://habrastorage.org/webt/4z/ov/rx/4zovrxmlnbnwpbzhnebcp412yf0.png"><br><br>  Hier sehen wir, dass rxvt und st der Konkurrenz voraus sind, gefolgt von der viel neueren Alacritty, die mit Fokus auf Geschwindigkeit entwickelt wird.  Als nächstes kommen Xfce (die VTE-Familie) und Konsole, die fast doppelt so schnell arbeiten.  Der letzte ist xterm mit einem Index, der fünfmal langsamer als rxvt ist.  Während des Tests, xterm auch wellig, war es schwierig, den übergebenen Text zu sehen, selbst wenn es die gleiche Zeile war.  Konsole stellte sich als schnell heraus, aber manchmal war es „schwierig“: Das Display hing von Zeit zu Zeit und zeigte den Text teilweise oder gar nicht an.  Andere Terminals zeigten deutlich Zeichenfolgen an, einschließlich st, Alacritty und rxvt. <br><br>  Dickie erklärt, dass Leistungsunterschiede mit dem Design von Bildlaufpuffern in verschiedenen Terminals zusammenhängen.  Insbesondere beschuldigt er rxvt und andere Terminals, „die allgemeinen Regeln nicht zu befolgen“: <br><blockquote>  „Im Gegensatz zu xterm hat rxvt nicht versucht, alle Updates anzuzeigen.  Wenn er zurückfällt, wird er einige Updates verwerfen, um aufzuholen.  Dies hatte einen größeren Einfluss auf die imaginäre Bildlaufgeschwindigkeit als auf die Organisation des internen Speichers.  Ein Nachteil war, dass die ASCII-Animation etwas ungenau war. “ </blockquote><br>  Um diese scheinbare Langsamkeit von xterm zu korrigieren, schlägt Dickey vor, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fastScroll-</a> Ressource zu verwenden, mit der xterm einige Bildschirmaktualisierungen verwerfen kann, um mit dem Stream Schritt zu halten.  Meine Tests bestätigen, dass fastScroll die Leistung verbessert und xterm auf das gleiche Niveau wie rxvt bringt.  Dies ist jedoch eine ziemlich grobe Krücke, wie Dickey selbst erklärt: "Manchmal scheint xterm - wie die Konsole - anzuhalten, da es eine Reihe neuer Bildschirmaktualisierungen erwartet, nachdem einige von ihnen gelöscht wurden."  In diesem Sinne scheinen andere Terminals den besten Kompromiss zwischen Geschwindigkeit und Anzeigeintegrität gefunden zu haben. <br><br><h4>  Ressourcenverbrauch </h4><br>  Unabhängig von der Angemessenheit, die Bildlaufgeschwindigkeit als Leistungsindikator zu betrachten, können Sie mit diesem Test die Belastung der Terminals simulieren, wodurch wir wiederum andere Parameter wie den Speicher oder die Festplattennutzung messen können.  Metriken wurden erhalten, indem der angegebene <b>seq-</b> Test unter der Überwachung des Python-Prozesses ausgeführt wurde.  Er sammelte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">getrusage ()</a> <b>-Zählerdaten</b> für <b>ru_maxrss</b> , die Summe von <b>ru_oublock</b> und <b>ru_inblock</b> sowie einen einfachen Timer. <br><br><img src="https://habrastorage.org/webt/e7/ay/fm/e7ayfmzkluchtlybqvqjwmijobs.png"><br><br>  In diesem Test belegt ST den ersten Platz mit dem geringsten durchschnittlichen Speicherverbrauch von 8 MB, was nicht verwunderlich ist, wenn man bedenkt, dass die Hauptidee des Projekts die Einfachheit ist.  Mlterm, xterm und rxvt verbrauchen etwas mehr - ungefähr 12 MB.  Alacritty hat ein weiteres bemerkenswertes Ergebnis, für dessen Arbeit 30 MB erforderlich sind.  Dann gibt es Terminals der VTE-Familie mit Indikatoren von 40 bis 60 MB, was ziemlich viel ist.  Ein solcher Verbrauch kann durch die Tatsache erklärt werden, dass diese Terminals übergeordnete Bibliotheken verwenden, beispielsweise GTK.  Konsole hat zuletzt einen enormen Speicherverbrauch von 65 MB bei Tests, obwohl dies durch seinen sehr breiten Funktionsumfang gerechtfertigt werden kann. <br><br>  Im Vergleich zu früheren Ergebnissen vor zehn Jahren verbrauchten alle Programme deutlich mehr Speicher.  Früher benötigte Xterm 4 MB, jetzt jedoch 15 MB, um ausgeführt zu werden.  Rxvt hat einen ähnlichen Anstieg des Verbrauchs, der jetzt sofort 16 MB benötigt.  Das Xfce-Terminal belegt 34 ​​MB, was dreimal so viel ist wie zuvor, aber das GNOME-Terminal benötigt nur 20 MB.  Natürlich wurden alle vorherigen Tests auf einer 32-Bit-Architektur durchgeführt.  Bei der Ökobilanz 2012 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sagte</a> Rusty Russell <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> dass es viele subtilere Gründe gibt, die den Anstieg des Speicherverbrauchs erklären können.  Mit all dem leben wir jetzt in einer Zeit, in der wir ganze Gigabyte Speicher haben, also können wir irgendwie damit umgehen. <br><br>  Trotzdem kann ich nicht anders, als das Gefühl zu haben, dass das Zuweisen von mehr Speicher zu solch grundlegender Software wie einem Terminal eine Verschwendung von Ressourcen ist.        ,       «»,  ,   -   ,      Linux- (  ,     ).                 ,          .   , GNOME Terminal, Konsole, urxvt, Terminator  Xfce Terminal  Daemon-,        ,     . <br><br><img src="https://habrastorage.org/webt/bx/h6/dc/bxh6dcm-ahulyqaioo5vhmuwmea.png"><br><br>              -:       ,  ,         . ,  VTE       (  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    2010 </a> ,      ).      , ,   ,      AES256 GCM ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  0.39.2</a> ).    ,       VTE,        … <br><br><h4>  </h4><br>      ,     VTE    ,    ,          .     ,    VTE-    Daemon-,    .   ,  ,          ,  -      ,       .   VTE         (),             GNOME. ,  VTE   .     ,      Linux    ,          .                         -   .  ,   xterm  mlterm        10 ,    . <br><br>    ,  -    Linux      .        ,       .  ,  Wayland    :  Typometer,   ,    ,  Wayland   —    .  ,   Wayland   ,  X.org,      ,    -        . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463785/">https://habr.com/ru/post/de463785/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463771/index.html">[Peter] Treffen von JUG.ru mit Sebastian Dashner - Machen Sie das Schreiben von Unternehmenstests angenehmer</a></li>
<li><a href="../de463773/index.html">Wie der Schutz von Kindern vor Informationen geregelt ist - und die bezaubernde Geschichte darüber, woher sie zuerst kamen (18+)</a></li>
<li><a href="../de463775/index.html">Wer verwendet das SAML 2.0-Authentifizierungsprotokoll?</a></li>
<li><a href="../de463777/index.html">Powershell Host-Verfügbarkeitsüberwachung</a></li>
<li><a href="../de463781/index.html">Zen-isolierte Komponenten in der Android-Architektur</a></li>
<li><a href="../de463787/index.html">Die große alte Überraschung von HP</a></li>
<li><a href="../de463789/index.html">Die Kraft der Generika in Swift. Teil 2</a></li>
<li><a href="../de463791/index.html">Eisengriff: Kinematik von Vogellandungen in Abhängigkeit von Geometrie und Oberflächentextur</a></li>
<li><a href="../de463795/index.html">Bedeutungsschattierungen in Englisch: Verwendung der Verben Empfehlen, Empfehlen, Vorschlagen</a></li>
<li><a href="../de463799/index.html">Was ich an Windows 10 nicht mag</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>