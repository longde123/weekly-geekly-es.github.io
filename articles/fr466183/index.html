<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò© üÜò üòæ Algorithmes de traitement de cha√Æne intelligents dans ClickHouse üßïüèΩ üóùÔ∏è üôèüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ClickHouse rencontre constamment des t√¢ches de traitement de cha√Æne. Par exemple, rechercher, calculer les propri√©t√©s des cha√Ænes UTF-8, ou quelque ch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algorithmes de traitement de cha√Æne intelligents dans ClickHouse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/466183/"><p>  ClickHouse rencontre constamment des t√¢ches de traitement de cha√Æne.  Par exemple, rechercher, calculer les propri√©t√©s des cha√Ænes UTF-8, ou quelque chose de plus exotique, qu'il s'agisse d'une recherche sensible √† la casse ou d'une recherche de donn√©es compress√©es. </p><br><p> Tout a commenc√© avec le fait que la responsable du d√©veloppement de ClickHouse, Lesha Milovidov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">o6CuFl2Q,</a> est venue nous voir √† la Facult√© d'informatique de la Higher School of Economics et a propos√© un grand nombre de sujets pour des articles et des dipl√¥mes.  Quand j'ai vu ¬´Smart String Processing Algorithms in ClickHouse¬ª (moi, une personne qui s'int√©resse √† divers algorithmes, y compris exp√©rimentaux), j'ai imm√©diatement mis en place des plans sur la fa√ßon de faire le dipl√¥me le plus cool.  Ma joie et mon expression peuvent √™tre d√©crites comme suit: </p><br><p><img src="https://habrastorage.org/webt/av/4d/2g/av4d2gj_pplevfljaomiqsnccda.jpeg"></p><br><a name="habracut"></a><br><h2 id="clickhouse">  Clickhouse </h2><br><p>  ClickHouse a soigneusement r√©fl√©chi √† l'organisation du stockage des donn√©es en m√©moire - en colonnes.  √Ä la fin de chaque colonne, il y a un remplissage de 15 octets pour une lecture s√ªre d'un registre de 16 octets.  Par exemple, ColumnString stocke des cha√Ænes termin√©es nulles avec des d√©calages.  Il est tr√®s pratique de travailler avec de tels tableaux. </p><br><p><img src="https://habrastorage.org/webt/w4/go/yp/w4goypgrxiigdp5tpdy3eyao2bu.png"><br></p><br><p>  Il existe √©galement ColumnFixedString, ColumnConst et LowCardinality, mais nous n'en parlerons pas en d√©tail aujourd'hui.  Le point principal √† ce stade est que la conception de la lecture s√ªre des queues est tr√®s bien, et la localit√© des donn√©es joue √©galement un r√¥le dans le traitement. </p><br><h2 id="poisk-po-podstrokam">  Recherche de sous-cha√Æne </h2><br><p>  Tr√®s probablement, vous connaissez de nombreux algorithmes diff√©rents pour trouver une sous-cha√Æne dans une cha√Æne.  Nous parlerons de ceux qui sont utilis√©s dans ClickHouse.  Nous introduisons d'abord quelques d√©finitions: </p><br><ol><li>  meule de foin - la ligne dans laquelle nous regardons;  g√©n√©ralement, la longueur est d√©sign√©e par <em>n</em> . </li><li>  aiguille - la cha√Æne ou l'expression r√©guli√®re que nous recherchons;  la longueur sera not√©e <em>m</em> . </li></ol><br><p>  Apr√®s avoir √©tudi√© un grand nombre d'algorithmes, je peux dire qu'il existe 2 (maximum 3) types d'algorithmes de recherche de sous-cha√Æne.  Le premier est la cr√©ation sous une forme ou une autre de structures de suffixes.  Le deuxi√®me type est constitu√© d'algorithmes bas√©s sur la comparaison de m√©moire.  Il existe √©galement l'algorithme Rabin-Karp, qui utilise des hachages, mais il est assez unique en son genre.  L'algorithme le plus rapide n'existe pas, tout d√©pend de la taille de l'alphabet, de la longueur de l'aiguille, de la botte de foin et de la fr√©quence d'occurrence. </p><br><p>  D√©couvrez les diff√©rents algorithmes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Et voici les algorithmes les plus populaires: </p><br><ol><li>  Knut - Morris - Pratt, </li><li>  Boyer - Moore, </li><li>  Boyer - Moore - Horspool, </li><li>  Rabin - Carpe, </li><li>  Double face (utilis√© dans la glibc appel√©e ¬´memmem¬ª), </li><li>  BNDM </li></ol><br><p>  La liste continue.  Chez ClickHouse, nous avons honn√™tement tout essay√©, mais nous avons finalement opt√© pour une version plus extraordinaire. </p><br><h4 id="algoritm-volnickogo">  Algorithme de Volnitsky </h4><br><p>  L'algorithme a √©t√© publi√© sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blog du</a> programmeur Leonid Volnitsky fin 2010.  Il rappelle quelque peu l'algorithme de Boyer-Moore-Horspool, seulement une version am√©lior√©e. </p><br><p>  Si <em>m &lt;4</em> , alors l'algorithme de recherche standard est utilis√©.  Enregistrer toutes les aiguilles bigrammes (2 octets cons√©cutifs) de la fin dans une table de hachage avec un adressage ouvert de taille <em>| Sigma |</em>  <em><sup>2</sup></em> √©l√©ments (en pratique, ce sont 2 <sup>16</sup> √©l√©ments), o√π les d√©calages de ce bigramme seront les valeurs, et le bigramme lui-m√™me sera le hachage et l'index en m√™me temps.  La position initiale sera √† la position <em>m - 2</em> depuis le d√©but de la meule de foin.  Nous suivons la meule de foin √† l'√©tape <em>m - 1</em> , regardons le prochain bigramme de cette position dans la meule de foin et consid√©rons toutes les valeurs du bigramme dans la table de hachage.  Ensuite, nous comparerons deux morceaux de m√©moire avec l'algorithme de comparaison habituel.  La queue qui reste sera trait√©e par le m√™me algorithme. </p><br><p>  L'√©tape <em>m-1 est</em> choisie de telle mani√®re que s'il y a une occurrence d'aiguille dans une botte de foin, alors nous consid√©rerons certainement le bigramme de cette entr√©e - garantissant ainsi que nous retournons la position de l'entr√©e dans la botte de foin.  La premi√®re occurrence est garantie par le fait que nous ajoutons des index de la fin √† la table de hachage par bigram.  Cela signifie que lorsque nous allons de gauche √† droite, nous consid√©rerons d'abord les bigrammes √† partir de la fin de la ligne (peut-√™tre en consid√©rant initialement des bigrammes compl√®tement inutiles), puis plus pr√®s du d√©but. </p><br><p> Prenons un exemple.  Que la botte de foin en ficelle soit <code>abacabaac</code> et aiguille √©gale √† <code>aaca</code> .  La table de hachage sera <code>{aa : 0, ac : 1, ca : 2}</code> . </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca ^ -   </code> </pre> <br><p>  Nous voyons le bigram <code>ac</code> .  En aiguille c'est, on substitue en √©galit√©: </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca aaca</code> </pre> <br><p>  Ne correspondait pas.  Apr√®s <code>ac</code> il n'y a pas d'entr√©es dans la table de hachage, nous passons √† l'√©tape 3: </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca ^ -   </code> </pre> <br><p>  Il n'y a pas de bigrammes <code>ba</code> dans la table de hachage, allez-y: </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca ^ -   </code> </pre> <br><p>  Il y a un bigramme dans l'aiguille, on regarde le d√©calage et on trouve l'entr√©e: </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca aaca</code> </pre> <br><p>  L'algorithme pr√©sente de nombreux avantages.  Tout d'abord, vous n'avez pas besoin d'allouer de m√©moire sur le tas, et 64 Ko sur la pile ne sont pas quelque chose de transcendantal maintenant.  Deuxi√®mement, 2 <sup>16</sup> est un excellent nombre pour prendre le modulo pour le processeur;  ce ne sont que des instructions movzwl (ou, comme nous plaisantons, ¬´movsvl¬ª) et la famille. </p><br><p>  En moyenne, cet algorithme s'est av√©r√© le meilleur.  Nous avons pris les donn√©es de Yandex.Metrica, les demandes sont presque r√©elles.  Une vitesse de flux, plus c'est mieux, KMP: algorithme Knut - Morris - Pratt, BM: Boyer - Moore, BMH: Boyer - Moore - Horspool. </p><br><p><img src="https://habrastorage.org/webt/wp/vn/v2/wpvnv2eqrbhhvqvryaqmdjc9igy.png"><br></p><br><p>  Pour ne pas √™tre infond√©, l'algorithme peut travailler le temps quadratique: </p><br><p><img src="https://habrastorage.org/webt/oi/3x/dh/oi3xdhxe7awdlsqxxui2lyqvxjc.png"><br></p><br><p>  Il est utilis√© dans la fonction de <code>position(Column, ConstNeedle)</code> et agit √©galement comme une optimisation pour les recherches d'expressions r√©guli√®res. </p><br><h2 id="poisk-po-regulyarnym-vyrazheniyam">  Recherche d'expression r√©guli√®re </h2><br><p>  Nous vous expliquerons comment ClickHouse optimise les recherches d'expressions r√©guli√®res.  De nombreuses expressions r√©guli√®res contiennent une sous-cha√Æne √† l'int√©rieur, qui doit √™tre √† l'int√©rieur d'une botte de foin.  Afin de ne pas construire une machine √† √©tats finis et de la comparer, nous isolerons de telles sous-cha√Ænes. </p><br><p>  Pour ce faire, c'est assez simple: tout crochet ouvrant augmente le niveau d'imbrication, tout crochet fermant diminue;  il existe √©galement des caract√®res sp√©cifiques aux expressions r√©guli√®res (par exemple, '.', '*', '?', '\ w', etc.).  Nous devons obtenir toutes les sous-cha√Ænes au niveau 0. Prenons un exemple: <br><img src="https://habrastorage.org/webt/2x/uk/uo/2xukuompabpmnrjpk-muwg1yydi.png"><br></p><br><p>  Nous le d√©composons en ces sous-cha√Ænes qui doivent √™tre dans la botte de foin de l'expression r√©guli√®re, apr√®s quoi nous s√©lectionnons la longueur maximale, recherchons des candidats dessus, puis v√©rifions avec le moteur d'expression r√©guli√®re habituel RE2.  Dans l'image ci-dessus, il y a une expression r√©guli√®re, elle est trait√©e par le moteur RE2 habituel √† 736 Mo / s, Hyperscan (√† ce sujet un peu plus tard) g√®re √† 1,6 Go / s, et nous g√©rons 1,69 Go / s par c≈ìur avec d√©compression LZ4.  En g√©n√©ral, une telle optimisation est en surface et acc√©l√®re consid√©rablement la recherche d'expressions r√©guli√®res, mais souvent elle n'est pas impl√©ment√©e dans les outils, ce qui m'√©tonne beaucoup. </p><br><p>  Le mot cl√© LIKE est √©galement optimis√© √† l'aide de cet algorithme, seulement apr√®s que LIKE peut qu'une expression r√©guli√®re tr√®s simplifi√©e passe par %%%%% (sous-cha√Æne arbitraire) et <code>_</code> (caract√®re arbitraire). </p><br><p>  Malheureusement, toutes les expressions r√©guli√®res ne sont pas soumises √† de telles optimisations, par exemple, √† partir de <code>yandex|google</code> il est impossible d'extraire explicitement des sous-cha√Ænes qui doivent appara√Ætre dans une botte de foin.  Par cons√©quent, nous avons trouv√© une solution compl√®tement diff√©rente. </p><br><h2 id="poisk-po-mnogim-podstrokam">  Rechercher de nombreuses sous-cha√Ænes </h2><br><p>  Le probl√®me est qu'il y a beaucoup d'aiguilles, et je veux comprendre si au moins l'une d'entre elles est incluse dans la botte de foin.  Il existe des m√©thodes assez classiques pour une telle recherche, par exemple l'algorithme Aho-Korasik.  Mais il n'a pas √©t√© trop rapide pour notre t√¢che.  Nous en reparlerons un peu plus tard. </p><br><p><del>  Lesha </del>  ClickHouse aime les solutions non standard, nous avons donc d√©cid√© d'essayer quelque chose de diff√©rent et, peut-√™tre, de cr√©er nous-m√™mes un nouvel algorithme de recherche.  Et ils l'ont fait. </p><br><p>  Nous avons examin√© l'algorithme de Volnitsky et l'avons modifi√© pour qu'il commence √† rechercher de nombreuses sous-cha√Ænes √† la fois.  Pour ce faire, il vous suffit d'ajouter les bigrammes de toutes les lignes et de stocker en plus un index de ligne dans la table de hachage.  L'√©tape sera s√©lectionn√©e parmi au moins toutes les longueurs d'aiguille moins 1 pour garantir √† nouveau la propri√©t√© que s'il y a une occurrence, nous verrons son bigramme.  La table de hachage passera √† 128 Ko (les lignes de plus de 255 sont trait√©es par l'algorithme standard, nous ne consid√©rerons pas plus de 256 aiguilles).  Je suis tr√®s paresseux, alors voici un exemple de la pr√©sentation (lu de gauche √† droite de haut en bas): </p><br><p><img src="https://habrastorage.org/webt/ak/no/hq/aknohqtvebtx-c_ijmza8af0emm.png"><br></p><br><p><img src="https://habrastorage.org/webt/x6/cm/z4/x6cmz4d3i5qy5i3tfj1ngbssewc.png"><br></p><br><p>  Nous avons commenc√© √† regarder comment un tel algorithme se comporte par rapport aux autres (les lignes sont tir√©es de donn√©es r√©elles).  Et pour un petit nombre de lignes, il fait tout (la vitesse avec d√©chargement est indiqu√©e - environ 2,5 Go / s). </p><br><p><img src="https://habrastorage.org/webt/nl/t_/pt/nlt_pt077xl7n-cya0qb6eh67re.png"><br></p><br><p>  Puis c'est devenu int√©ressant.  Par exemple, avec un grand nombre de bigrammes similaires, nous perdons face √† certains concurrents.  C'est compr√©hensible - nous commen√ßons √† comparer de nombreux morceaux de m√©moire et √† nous d√©grader. </p><br><p><img src="https://habrastorage.org/webt/n8/wm/uz/n8wmuzm_vcepo4olqcse1e7gwqy.png"><br></p><br><p>  Vous ne pouvez pas acc√©l√©rer beaucoup si la longueur minimale de l'aiguille est suffisamment grande.  De toute √©vidence, nous avons plus d'occasions de sauter des morceaux entiers de meule de foin sans rien payer pour cela. </p><br><p><img src="https://habrastorage.org/webt/zg/z1/ej/zgz1ejecxev4-j-oz3m6egxydt0.png"><br></p><br><p>  Le point de basculement commence quelque part sur les lignes 13 √† 15.  Environ 97% des demandes que j'ai vues sur le cluster √©taient inf√©rieures √† 15 lignes: </p><br><p><img src="https://habrastorage.org/webt/x-/6j/od/x-6jodqalhriam_byxewdzoxzhs.png"><br></p><br><p>  Eh bien, une image tr√®s effrayante - 41 lignes, de nombreux bigrammes r√©p√©titifs: </p><br><p><img src="https://habrastorage.org/webt/yx/ez/da/yxezdam_2poycdgttd9nnsyjjqy.png"><br></p><br><p>  En cons√©quence, dans ClickHouse (19.5), nous avons impl√©ment√© les fonctions suivantes via cet algorithme: </p><br><p>  - <code>multiSearchAny(h, [n_1, ..., n_k])</code> - 1, si au moins une des aiguilles se trouve dans la botte de foin. <br>  - <code>multiSearchFirstPosition(h, [n_1, ..., n_k])</code> - la position la plus √† gauche de l'entr√©e dans la botte de foin (√† partir d'une) ou 0 si elle n'est pas trouv√©e. <br>  - <code>multiSearchFirstIndex(h, [n_1, ..., n_k])</code> - l'index d'aiguille le plus √† gauche, qui a √©t√© trouv√© dans la botte de foin;  0 s'il n'est pas trouv√©. <br>  - <code>multiSearchAllPositions(h, [n_1, ..., n_k])</code> - toutes les premi√®res positions de toutes les aiguilles, renvoie un tableau. </p><br><p>  Les suffixes sont -UTF8 (nous ne normalisons pas), -CaseInsensitive (ajoutez 4 bigrammes avec une casse diff√©rente), -CaseInsensitiveUTF8 (il y a une condition que les majuscules et les minuscules doivent avoir le m√™me nombre d'octets).  Voir l'impl√©mentation <a href="">ici</a> . </p><br><p>  Apr√®s cela, nous nous sommes demand√© si nous pouvions faire quelque chose de similaire avec de nombreuses expressions r√©guli√®res.  Et ils ont trouv√© une solution qui √©tait d√©j√† g√¢t√©e dans les benchmarks. </p><br><h2 id="poisk-po-mnogim-regulyarnym-vyrazheniyam">  Recherche par de nombreuses expressions r√©guli√®res </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hyperscan</a> est une biblioth√®que d'Intel qui recherche imm√©diatement de nombreuses expressions r√©guli√®res.  Il utilise l'heuristique pour isoler les sous-mots des expressions r√©guli√®res sur lesquelles nous avons √©crit et beaucoup de SIMD pour rechercher l'automate Glushkov (l'algorithme semble s'appeler Teddy). </p><br><p>  En g√©n√©ral, tout est dans les meilleures traditions pour tirer le maximum de la recherche d'expressions r√©guli√®res.  La biblioth√®que fait vraiment ce qui est d√©clar√© dans ses fonctions. </p><br><p><img src="https://habrastorage.org/webt/of/xl/dd/ofxlddsnj92zghvsducv9e9jktu.png"><br></p><br><p>  Heureusement, au cours de mon mois de d√©veloppement chez ClickHouse, j'ai pu d√©passer le d√©veloppement de 12 ans sur une classe de requ√™tes d√©cente et j'en suis tr√®s satisfait. </p><br><p>  Dans Yandex, la biblioth√®que Hyperscan est √©galement utilis√©e dans l'antispam.  √Ä en juger par les critiques, elle traite calmement des milliers d'expressions r√©guli√®res et les recherche rapidement. </p><br><p>  La biblioth√®que pr√©sente plusieurs inconv√©nients.  Le premier est la quantit√© de m√©moire non document√©e consomm√©e et une caract√©ristique √©trange que la botte de foin doit √™tre inf√©rieure √† 2 <sup>32</sup> octets.  Le deuxi√®me - vous ne pouvez pas renvoyer les premi√®res positions gratuitement, les indices d'aiguille les plus √† gauche, etc. Et le troisi√®me moins - il y a quelques <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bugs</a> √† l'improviste.  Par cons√©quent, chez ClickHouse, nous avons impl√©ment√© les fonctions suivantes √† l'aide d'Hyperscan: </p><br><p>  - <code>multiMatchAny(h, [n_1, ..., n_k])</code> - 1, si au moins une des aiguilles est venue avec une botte de foin. <br>  - <code>multiMatchAnyIndex(h, [n_1, ..., n_k])</code> - tout index d'aiguille qui <code>multiMatchAnyIndex(h, [n_1, ..., n_k])</code> botte de foin. </p><br><p>  Nous sommes int√©ress√©s, mais comment rechercher pas exactement, mais approximativement?  Et est venu avec plusieurs solutions. </p><br><h2 id="priblizhyonnyy-poisk">  Recherche approximative </h2><br><p>  La norme dans la recherche approximative est la distance Levenshtein - le nombre minimum de caract√®res qui peuvent √™tre remplac√©s, ajout√©s et supprim√©s pour obtenir une cha√Æne b de longueur n √† partir d'une cha√Æne a de longueur m.  Malheureusement, l'algorithme de programmation dynamique na√Øf fonctionne pour <em>O (mn)</em> ;  les meilleurs esprits de ShAD peuvent le faire en <em>O (mn / log max (n, m))</em> ;  il est facile de penser √† <em>O ((n + m) ‚ãÖ alpha)</em> , o√π <em>alpha</em> est la r√©ponse;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la science</a> peut le faire pour <em>O ((alpha - | n - m |) min (m, n, alpha) + m + n)</em> (l'algorithme est simple, lu au moins dans le ShAD) ou, si un peu plus clair, pour <em>O (alpha ^ 2 + m + n)</em> .  Il y a encore un inconv√©nient: il est tr√®s probablement impossible de se d√©barrasser du temps quadratique dans le pire des cas polynomialement - Peter Indik a √©crit un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> tr√®s puissant √† ce sujet. </p><br><p>  Il y a un exercice: imaginez que pour remplacer un personnage dans la distance Levenshtein, vous payez une amende non pas deux, mais deux;  puis trouver un algorithme pour <em>O ((n + m) log (n + m))</em> . </p><br><p>  Cela ne fonctionne toujours pas, trop long et trop cher.  Mais √† l'aide d'une telle distance, nous avons fait la d√©tection de fautes de frappe dans les requ√™tes. </p><br><p><img src="https://habrastorage.org/webt/ok/b8/gg/okb8ggb8vwkzft3ggzdipy29pja.png"><br></p><br><p>  En plus de la distance de Levenshtein, il y a une distance de Hamming.  Avec lui aussi, tout va plut√¥t mal, mais un peu mieux qu'avec la distance de Levenshtein.  Il ne prend pas en compte la suppression des caract√®res, mais ne consid√®re que pour deux lignes de m√™me longueur le nombre de caract√®res dans lesquels elles diff√®rent.  Par cons√©quent, si nous utilisons la distance pour les cha√Ænes de longueur m &lt;n, alors seulement dans la recherche des sous-cha√Ænes les plus proches. </p><br><p>  Comment calculer un tel tableau de divergences (un tableau d de n - m + 1 √©l√©ments, o√π d [i] est le nombre de caract√®res diff√©rents dans le i-√®me depuis le d√©but de la superposition) pour <em>O (| Sigma | (n + m) log (n + m) )</em> ?  Tout d'abord, faites <em>| Sigma |</em>  masques de bits indiquant si ce symbole est √©gal √† celui consid√©r√©.  Ensuite, nous calculons la r√©ponse pour chacun des masques Sigma et ajoutons - nous obtenons la r√©ponse d'origine. </p><br><p>  Prenons un exemple.  <code>abba</code> , sous-cha√Æne <code>ba</code> , alphabet binaire.  Nous obtenons 2 masques <code>1001, 01</code> et <code>0110, 10</code> . </p><br><pre> <code class="plaintext hljs">   a 1001 01 - 0  01 - 0  01 - 1 </code> </pre> <br><pre> <code class="plaintext hljs">   b 0110 10 - 0  10 - 1  10 - 1 </code> </pre> <br><p>  Nous obtenons le tableau [0, 1, 2] - c'est presque la bonne r√©ponse.  Mais notez que pour chaque lettre, le nombre de correspondances n'est que le produit scalaire d'une aiguille binaire fixe et de toutes les sous-cha√Ænes de meules de foin.  Et pour cela, bien s√ªr, il y a une transform√©e de Fourier rapide! </p><br><p>  Pour ceux qui ne connaissent pas: la FFT peut multiplier deux polyn√¥mes de degr√©s <em>m &lt;n</em> en un temps <em>O (n log n)</em> , √† condition que le travail avec les coefficients soit effectu√© par unit√© de temps.  Les convolutions sont tr√®s similaires aux produits scalaires.  Il suffit de dupliquer les coefficients du premier polyn√¥me, de d√©velopper et de compl√©ter le second avec le nombre de z√©ros requis, puis nous obtenons tous les produits scalaires d'une cha√Æne binaire et toutes les sous-cha√Ænes de l'autre en <em>O (n log n)</em> - une sorte de magie!  Mais croyez-moi, c'est absolument r√©el, et parfois les gens le font. </p><br><p>  Mais pas dans ClickHouse.  Pour nous, travailler avec | Sigma |  = 30 est d√©j√† grand, et la FFT n'est pas l'algorithme pratique le plus agr√©able pour le processeur ou, comme on dit chez les gens du commun, "la constante est grande". </p><br><p>  Par cons√©quent, nous avons d√©cid√© d'examiner d'autres mesures.  Nous sommes arriv√©s √† la bioinformatique, o√π les gens utilisent la distance de n grammes.  En fait, nous prenons tous les n-grammes de botte de foin et d'aiguille, consid√©rons 2 multisets avec ces n-grammes.  Ensuite, nous prenons la diff√©rence sym√©trique et divisons par la somme des cardinalit√©s de deux multisets avec n-grammes.  Nous obtenons un nombre de 0 √† 1 - plus proche de 0, plus les lignes sont similaires.  Prenons un exemple o√π <em>n = 4</em> : </p><br><pre> <code class="plaintext hljs">abcda ‚Üí {abcd, bcda}; Size = 2 bcdab ‚Üí {bcda, cdab}; Size = 2         . |{abcd, cdab}| / (2 + 2) = 0.5</code> </pre> <br><p>  En cons√©quence, nous avons fait une distance de 4 grammes et y avons coll√© un tas d'id√©es de SSE, et nous avons √©galement l√©g√®rement affaibli la mise en ≈ìuvre en hachages crc32 √† deux octets. </p><br><p><img src="https://habrastorage.org/webt/ad/36/uk/ad36ukzmrspftbjxxwbc3djljv4.png"><br></p><br><p>  D√©couvrez l' <a href="">impl√©mentation</a> .  Attention: code tr√®s convaincant et optimis√© pour les compilateurs. </p><br><p>  Je vous conseille particuli√®rement de faire attention au <a href="">hack sale</a> pour la casse des minuscules pour les points de code ASCII et russe. </p><br><p>  - <code>ngramDistance(haystack, needle)</code> - renvoie un nombre de 0 √† 1;  plus pr√®s de 0, plus les lignes se ressemblent. <br>  - -UTF8, -CaseInsensitive, -CaseInsensitiveUTF8 (hack sale pour les Russes et ASCII). </p><br><p>  Hyperscan ne s'arr√™te pas non plus - il a des fonctionnalit√©s de recherche approximative: vous pouvez rechercher des lignes qui ressemblent √† des expressions r√©guli√®res par la distance constante de Levenshtein.  Un automate <em>distance + 1</em> est cr√©√©, qui est interconnect√© en supprimant, en rempla√ßant ou en ins√©rant un caract√®re, ce qui signifie ¬´bien¬ª, apr√®s quoi l'algorithme habituel pour v√©rifier si un automate accepte une ligne particuli√®re est appliqu√©.  Dans ClickHouse, nous les avons impl√©ment√©s sous les noms suivants: </p><br><p>  - <code>multiFuzzyMatchAny(haystack, distance, [n_1, ..., n_k])</code> - similaire √† multiMatchAny, uniquement avec la distance. <br>  - <code>multiFuzzyMatchAnyIndex(haystack, distance, [n_1, ..., n_k])</code> - similaire √† multiMatchAnyIndex, uniquement avec la distance. </p><br><p>  Avec l'augmentation de la <em>distance, la</em> vitesse commence √† se d√©grader consid√©rablement, mais reste toujours √† un niveau assez d√©cent. </p><br><p>  Terminez la recherche et passez au traitement des cha√Ænes UTF-8.  Il y avait aussi beaucoup de choses int√©ressantes. </p><br><h2 id="obrabotka-utf-8-strok">  Traitement de ligne UTF-8 </h2><br><p>  J'admets qu'il √©tait difficile de franchir le plafond des impl√©mentations na√Øves dans les cha√Ænes cod√©es UTF-8.  Il √©tait particuli√®rement difficile de visser SIMD.  Je partagerai quelques id√©es sur la fa√ßon de proc√©der. </p><br><p>  Rappelez-vous √† quoi ressemble une s√©quence UTF-8 valide: </p><br><p><img src="https://habrastorage.org/webt/iu/xn/zu/iuxnzucrcetohvgsxb7ozohxwws.png"><br></p><br><p>  Essayons de calculer la longueur du point de code par le premier octet.  C'est l√† que commence la magie un peu.  Encore une fois, nous √©crivons quelques propri√©t√©s: </p><br><p>  - √Ä partir de 0xC <em>et de 0xD,</em> 2 octets <br>  - 0xC2 = 11 <u>0</u> 00010 <br>  - 0xDF = 11 <u>0</u> 11111 <br>  - 0xE0 = 111 <u>0</u> 0000 <br>  - 0xF4 = 1111 0100, il n'y a rien de plus que 0xF4, mais s'il y avait 0xF8, il y aurait une histoire diff√©rente <br>  - R√©pondez 7 moins la position du premier z√©ro depuis la fin, s'il ne s'agit pas d'un caract√®re ASCII </p><br><p>  Nous calculons la longueur: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seqLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> UInt8 first_octet)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_octet &lt; <span class="hljs-number"><span class="hljs-number">0x80</span></span>u) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> first_zero = bitScanReverse(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;UInt8&gt;(~first_octet)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> - first_zero; }</code> </pre> <br><p>  Heureusement, nous avons en stock des instructions qui peuvent calculer le nombre de bits z√©ro, en commen√ßant par les plus significatifs. </p><br><pre> <code class="cpp hljs">f = __builtin_clz(val) <span class="hljs-comment"><span class="hljs-comment">// (bsrl,     ) f(2) = 30, f(8) = 28, f(7) = 29</span></span></code> </pre> <br><p>  Calculer bitScanReverse: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitScanReverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span> - __builtin_clz(x); }</code> </pre> <br><p>  Essayons de calculer la longueur d'une cha√Æne UTF-8 par points de code via SIMD.  Pour ce faire, examinez chaque octet comme un num√©ro sign√© et notez les propri√©t√©s suivantes: </p><br><p>  - 0xBF = -65 <br>  - 0x80 = -128 <br>  - 0xC2 = -62 <br>  - 0x7F = 127 <br>  - tous les premiers octets sont dans [0xC2, 0x7F] <br>  - tous les non-premiers octets sont dans [0x80, 0xBF] </p><br><p>  L'algorithme est assez simple.  Comparez chaque octet avec -65 et, s'il est sup√©rieur √† ce nombre, ajoutez-en un.  Si nous voulons utiliser SIMD, c'est la charge habituelle de 16 octets du flux d'entr√©e.  Ensuite, il y a une comparaison d'octets, qui en cas de r√©sultat positif donnera l'octet 0xFF, et dans le cas d'un n√©gatif - 0x00.  Puis l'instruction <code>pmovmskb</code> , qui collectera les bits hauts de chaque octet du registre.  Ensuite, le nombre de soulignements augmente, nous utilisons l'intrins√®que pour l'instruction <code>popcnt</code> SSE4.  Le sch√©ma de cet algorithme peut √™tre illustr√© par un exemple: </p><br><p><img src="https://habrastorage.org/webt/gn/mh/q5/gnmhq5lwynwpkdmqe2k3xsowxfs.png"><br></p><br><p>  Il s'av√®re qu'avec la d√©compression, le traitement par c≈ìur sera d'environ 1,5 Go / s. </p><br><p>  Les fonctions sont appel√©es: </p><br><p>  - <code>lengthUTF8(string)</code> - renvoie la longueur d'une cha√Æne UTF-8 correctement encod√©e, quelque chose est consid√©r√© comme invalide, aucune exception n'est lev√©e. </p><br><p>  Nous sommes all√©s plus loin car nous voulions encore plus de fonctions avec le traitement de cha√Æne UTF-8.  Par exemple, v√©rifier la validit√© et transtyper en une expression UTF-8 valide. </p><br><p>  Pour v√©rifier la validit√©, j'ai pris <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/cyb70289/utf8/</a> , adapt√© pour ClickHouse (en fait juste chang√© le traitement des queues) et j'ai obtenu une vitesse de 1,22 Go / s contre 900 Mo / s pour l'algorithme na√Øf .  Je ne d√©crirai pas l'algorithme lui-m√™me, il est assez compliqu√© pour la perception. </p><br><p>  - <code>isValidUTF8(string)</code> - renvoie 1 si la cha√Æne est correctement encod√©e avec UTF-8, sinon 0. <br>  - <code>toValidUTF8(string)</code> - remplace les caract√®res UTF-8 non valides par le caract√®re   (U + FFFD).  Tous les caract√®res invalides cons√©cutifs se r√©duisent en un seul caract√®re de remplacement.  Pas de science fus√©e. </p><br><p>  En g√©n√©ral, dans les lignes UTF-8, en raison du sch√©ma statique moins agr√©able, il est toujours difficile de trouver quelque chose de bien optimis√©. </p><br><h2 id="chto-dalshe">  Et ensuite? </h2><br><p>  Permettez-moi de vous rappeler que c'√©tait ma th√®se.  Bien s√ªr, je l'ai d√©fendue 10/10.  Nous l'avons d√©j√† accompagn√©e √† Highload ++ Siberia (bien qu'il me semble qu'elle n'int√©ressait gu√®re personne).  Regardez la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pr√©sentation</a> .  J'ai aim√© que la partie pratique de la th√®se ait donn√© lieu √† de nombreuses recherches int√©ressantes.  Et voici le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dipl√¥me</a> lui-m√™me.  Il contient beaucoup de fautes de frappe, car personne ne l'a lu.  :) </p><br><p>  Dans le cadre de la pr√©paration du dipl√¥me, j'ai effectu√© un tas d'autres travaux similaires (les liens conduisent √† des demandes de pool): </p><br><p>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonction de concaturation optimis√©e 2 fois</a> ; <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cr√©ation du format python le plus simple pour les requ√™tes</a> ; <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LZ4 acc√©l√©r√© de 4%</a> ; <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">J'ai fait un excellent travail sur SIMD pour ARM et PPC64LE</a> ; <br>  - Et il a conseill√© quelques √©tudiants du FCS dipl√¥m√©s de ClickHouse. </p><br><p>  En fin de compte, il s'est av√©r√© que, selon mon exp√©rience, <del>  chaque mois, Lesha a essay√© de me chanter </del>  ClickHouse est le syst√®me le plus agr√©able pour √©crire du code haute performance, o√π il y a de la documentation, des commentaires, un excellent support d√©veloppeur et devops.  ClickHouse est vraiment g√©nial.  Fatigu√© de changer les formats JSON?  Venez √† Lesha et demandez une t√¢che de n'importe quel niveau - il la fournira pour vous, et au cours du week-end, vous aurez un grand plaisir √† √©crire du code. </p><br><p>  Mais avec toutes les r√©alisations de ClickHouse et sa conception, il ne s'agit probablement pas d'eux.  Pas principalement en eux. </p><br><p>  J'ai suivi 4 ans d'√©tudes de premier cycle √† la FCS, en juin j'ai obtenu un dipl√¥me du HSE avec mention, travaill√© pendant un an et demi dans une √©quipe g√©niale √† Yandex, apr√®s avoir bien pomp√©.  Sans exp√©rience totale tout ce temps <del>  et le fer </del>  Rien d'√©crit dans le post n'aurait fonctionn√©.  FCN est tr√®s cool, si vous en tirez le maximum.  Merci √† Vana Puzyrevsky <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">ivan_puzyrevskiy</a> , Ignat Kolesnichenko, Gleb Evstropov, Max Babenko <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">maxim_babenko</a> pour leur rencontre dans ma dr√¥le d'aventure sur FCN.  Et aussi merci √† tous les professeurs qui m'ont appris quelque chose. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466183/">https://habr.com/ru/post/fr466183/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466165/index.html">Comment l'intelligence artificielle aide √† g√©rer les projets</a></li>
<li><a href="../fr466169/index.html">Offre sp√©ciale pour les √©tudiants actifs de JetBrains</a></li>
<li><a href="../fr466171/index.html">Cinq raisons d'opter pour JUG.EKB</a></li>
<li><a href="../fr466179/index.html">fform: React & JSONSchema - flexibilit√© maximale</a></li>
<li><a href="../fr466181/index.html">Python de C (API C)</a></li>
<li><a href="../fr466187/index.html">√âditeur de logique visuelle pour Unity3d. 2e partie</a></li>
<li><a href="../fr466191/index.html">L'essentiel de la bataille pour la neutralit√© du r√©seau aux √âtats-Unis est la chronologie des √©v√©nements et l'√©tat actuel des choses</a></li>
<li><a href="../fr466193/index.html">Alimentation automatique MailChimp personnalis√©e √† partir du flux RSS</a></li>
<li><a href="../fr466195/index.html">PVS-Studio 7.04</a></li>
<li><a href="../fr466197/index.html">PVS-Studio 7.04</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>