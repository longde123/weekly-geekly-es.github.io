<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç∫ #‚É£ üçò Recarregando texturas do OpenGLESv2 via DMABUF üë®üèº‚Äçüîß ü¶í üë¶üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, quero falar sobre como √© f√°cil atualizar as texturas do OpenGLES por meio do DMABUF. Procurei em Habr e, para minha surpresa, n√£o encont...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Recarregando texturas do OpenGLESv2 via DMABUF</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481540/"><iframe width="560" height="315" src="https://www.youtube.com/embed/Cz2cywrC1ls" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Neste artigo, quero falar sobre como √© f√°cil atualizar as texturas do OpenGLES por meio do DMABUF.  Procurei em Habr e, para minha surpresa, n√£o encontrei um √∫nico artigo sobre esse assunto.  Em Habr, as perguntas e respostas tamb√©m n√£o encontraram nada disso.  E isso √© um pouco estranho para mim.  A tecnologia apareceu h√° algum tempo, embora realmente n√£o exista muita informa√ß√£o sobre ela na rede, tudo √© vago e contradit√≥rio. <br><br>  Eu coletei todas essas informa√ß√µes pouco a pouco de diferentes fontes antes de poder escrever um player de v√≠deo como na demonstra√ß√£o acima.  Aqui, em uma demonstra√ß√£o, meu reprodutor de v√≠deo criado com base na biblioteca gstreamer carrega quadros de v√≠deo na textura OpenGLESv2 todas as vezes antes da renderiza√ß√£o.  Alimentado por Raspberry Pi4.  Os quadros s√£o simplesmente copiados para uma mem√≥ria alocada especialmente - e o DMA os transfere para a mem√≥ria da GPU, para a textura.  Em seguida, vou lhe contar como fiz. <br><a name="habracut"></a><br>  Normalmente, um programador usando o OpenGLESv2 cria uma textura apenas uma vez e, em seguida, simplesmente a renderiza em objetos de cena.  Isso acontece, porque as roupas dos personagens raramente mudam e, √†s vezes, recarregar a textura com glTexSubImage2D () n√£o √© dif√≠cil.  No entanto, os problemas reais come√ßam quando a textura √© din√¢mica, quando voc√™ precisa atualiz√°-la quase todos os quadros durante a renderiza√ß√£o.  A fun√ß√£o glTexSubImage2D () est√° muito lenta.  Bem, qu√£o lento - √© claro, tudo depende do computador e da placa gr√°fica.  Eu queria encontrar uma solu√ß√£o que funcionasse mesmo em cart√µes de placa √∫nica fracos como Raspberry. <br><br>  A arquitetura de muitos computadores modernos, incluindo os de placa √∫nica SoC, √© tal que a mem√≥ria do processador √© separada da mem√≥ria da GPU.  Normalmente, os programas do usu√°rio n√£o t√™m acesso direto √† mem√≥ria da GPU e voc√™ precisa usar v√°rias fun√ß√µes da API como a mesma glTexSubImage2D ().  Al√©m disso, li em algum lugar que a representa√ß√£o interna da textura pode diferir da representa√ß√£o tradicional de imagens como uma sequ√™ncia de pixels.  N√£o sei como isso √© verdade.  Possivelmente. <br><br>  Ent√£o, o que a tecnologia DMABUF me fornece?  A mem√≥ria √© especialmente alocada e um processo a partir de qualquer thread pode simplesmente escrever pixels l√° sempre que quiser.  O pr√≥prio DMA transferir√° todas as altera√ß√µes para a textura na mem√≥ria da GPU.  Isso n√£o √© bonito? <br><br>  Devo dizer imediatamente que eu sei sobre o PBO - Pixel Buffer Object, geralmente com a ajuda da atualiza√ß√£o din√¢mica da textura do PBO, o DMA parece ser usado tamb√©m, mas o PBO apareceu apenas no OpenGLESv3 e n√£o em todas as implementa√ß√µes.  Ent√£o n√£o - infelizmente, este n√£o √© o meu caminho. <br><br>  O artigo pode ser de interesse tanto para programadores de Raspberry quanto para desenvolvedores de jogos, e provavelmente para programadores de Android, j√° que o OpenGLES tamb√©m √© usado l√° e tenho certeza de que essa tecnologia DMABUF tamb√©m est√° presente l√° (pelo menos, tenho certeza de que voc√™ pode us√°-la no Android NDK). <br><br>  Vou escrever um programa usando DMABUF em um Raspberry Pi4.  O programa tamb√©m deve (e funcionar√°) em computadores Intel x86 / x86_64 comuns, digamos no ubuntu. <br><br>  Neste artigo, presumo que voc√™ j√° saiba como programar gr√°ficos com a API OpenGLESv2.  Embora, n√£o haver√° muitos desses desafios.  Principalmente teremos magia ioctl. <br><br>  Portanto, a primeira coisa a fazer √© garantir que a API dispon√≠vel na plataforma tenha suporte ao DMABUF.  Para fazer isso, verifique a lista de extens√µes EGL: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* EglExtString = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)eglQueryString( esContext-&gt;eglDisplay, EGL_EXTENSIONS ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>( EglExtString, <span class="hljs-string"><span class="hljs-string">"EGL_EXT_image_dma_buf_import"</span></span>) ) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF feature must be supported!!!\n"</span></span>; }</code> </pre> <br>  Portanto, entenderemos imediatamente se h√° alguma esperan√ßa de usar o DMABUF ou se n√£o h√° esperan√ßa.  Por exemplo, no Raspberry Pi3 e em todas as placas anteriores, n√£o h√° esperan√ßa.  Em geral, mesmo o OpenGLESv2 √© desmembrado, atrav√©s de bibliotecas especiais com o broche BRCM.  E agora no Raspberry Pi4 existe um OpenGLES real, a extens√£o EGL_EXT_image_dma_buf_import √©, hooray. <br><br>  Anotarei imediatamente o SO que tenho em um Pi4 de placa √∫nica; caso contr√°rio, tamb√©m poder√° haver problemas com isso: <br><br><pre> <code class="plaintext hljs">pi@raspberrypi:~ $ lsb_release -a No LSB modules are available. Distributor ID: Raspbian Description: Raspbian GNU/Linux 10 (buster) Release: 10 Codename: buster pi@raspberrypi:~ $ uname -a Linux raspberrypi 4.19.75-v7l+ #1270 SMP Tue Sep 24 18:51:41 BST 2019 armv7l GNU/Linux</code> </pre><br>  Tamb√©m observo que a extens√£o EGL_EXT_image_dma_buf_import est√° no Orange Pi PC (Mali-400) / PC2 (Mali-450), a menos que voc√™ possa executar a GPU do Mali nessas placas (em assembl√©ias oficiais n√£o existe, instalei-a no Armbian, mais eu fiz isso sozinho conjunto do driver do kernel).  Ou seja, o DMABUF est√° em quase todo lugar.  S√≥ √© necess√°rio levar e usar. <br><br>  Em seguida, voc√™ precisa abrir o arquivo / dev / dri / card0 ou / dev / dri / card1 - um deles, depende da plataforma, acontece de forma diferente, √© necess√°rio procurar o arquivo que suporta DRM_CAP_DUMB_BUFFER: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenDrm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd = open(<span class="hljs-string"><span class="hljs-string">"/dev/dri/card0"</span></span>, O_RDWR | O_CLOEXEC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fd &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"cannot open /dev/dri/card0\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> hasDumb = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( drmGetCap(fd, DRM_CAP_DUMB_BUFFER, &amp;hasDumb) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { close( fd ); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"/dev/dri/card0 has no support for DUMB_BUFFER\n"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//maybe Raspberry Pi4 or other platform fd = open("/dev/dri/card1", O_RDWR | O_CLOEXEC); if( fd &lt; 0 ) { cout &lt;&lt; "cannot open /dev/dri/card1\n"; return -1; } hasDumb = 0; if( drmGetCap(fd, DRM_CAP_DUMB_BUFFER, &amp;hasDumb) &lt; 0 ) { close( fd ); cout &lt;&lt; "/dev/dri/card1 has no support for DUMB_BUFFER\n"; return -1; } } if( !hasDumb ) { close( fd ); cout &lt;&lt; "no support for DUMB_BUFFER\n"; return -1; } //Get DRM authorization drm_magic_t magic; if( drmGetMagic(fd, &amp;magic) ) { cout &lt;&lt; "no DRM magic\n"; close( fd ); return -1; } Window root = DefaultRootWindow( x_display ); if( !DRI2Authenticate( x_display, root, magic ) ) { close( fd ); cout &lt;&lt; "Failed DRI2Authenticate\n"; return -1; } cout &lt;&lt; "DRM fd "&lt;&lt; fd &lt;&lt;"\n"; return fd; }</span></span></code> </pre><br>  Aqui, a prop√≥sito, h√° uma sutileza inexplic√°vel para mim.  Algumas plataformas n√£o possuem bibliotecas que fornecem a fun√ß√£o DRI2Authenticate ().  Por exemplo, n√£o est√° no crack e na vers√£o de 32 bits para o Orange Pi PC.  Tudo isso √© estranho.  Mas eu encontrei um reposit√≥rio no GITHUB: <a href="https://github.com/robclark/libdri2">github.com/robclark/libdri2,</a> ele pode ser usado, montado e instalado, e tudo est√° bem.  √â estranho que no meu Ubuntu 18 (64 bits) em um laptop n√£o haja problema. <br><br>  Se voc√™ pudesse encontrar e abrir / dev / dri / cardX, poder√° seguir em frente.  Voc√™ precisa acessar as tr√™s fun√ß√µes muito necess√°rias do KHR (Khronos): <br><br><pre> <code class="cpp hljs">PFNEGLCREATEIMAGEKHRPROC funcEglCreateImageKHR = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; PFNEGLDESTROYIMAGEKHRPROC funcEglDestroyImageKHR = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; PFNGLEGLIMAGETARGETTEXTURE2DOESPROC funcGlEGLImageTargetTexture2DOES = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; ... funcEglCreateImageKHR = (PFNEGLCREATEIMAGEKHRPROC) eglGetProcAddress(<span class="hljs-string"><span class="hljs-string">"eglCreateImageKHR"</span></span>); funcEglDestroyImageKHR = (PFNEGLDESTROYIMAGEKHRPROC) eglGetProcAddress(<span class="hljs-string"><span class="hljs-string">"eglDestroyImageKHR"</span></span>); funcGlEGLImageTargetTexture2DOES = (PFNGLEGLIMAGETARGETTEXTURE2DOESPROC)eglGetProcAddress(<span class="hljs-string"><span class="hljs-string">"glEGLImageTargetTexture2DOES"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( funcEglCreateImageKHR &amp;&amp; funcEglDestroyImageKHR &amp;&amp; funcGlEGLImageTargetTexture2DOES ) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF feature supported!!!\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CloseDrm(); }</code> </pre><br>  Agora precisamos de uma fun√ß√£o que crie uma √°rea de mem√≥ria para DMABUF.  A fun√ß√£o usa par√¢metros como largura, altura e bitmap de bitmap, para os quais ser√° retornado o manipulador do descritor de arquivo DmaFd e um ponteiro para a mem√≥ria de bitmap Plane. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">nt </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDmaBuf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* DmaFd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">** Plane )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dmaFd = *DmaFd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pplane = *Plane = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create dumb buffer drm_mode_create_dumb buffer = { 0 }; buffer.width = Width; buffer.height = Height; buffer.handle = 0; buffer.bpp = 32; //Bits per pixel buffer.flags = 0; int ret = drmIoctl( DriCardFd, DRM_IOCTL_MODE_CREATE_DUMB, &amp;buffer); cout &lt;&lt; "DRM_IOCTL_MODE_CREATE_DUMB " &lt;&lt; buffer.handle &lt;&lt; " " &lt;&lt; ret &lt;&lt; "\n"; if (ret &lt; 0) { cout &lt;&lt; "Error cannot DRM_IOCTL_MODE_CREATE_DUMB\n"; return -1; } // Get the dmabuf for the buffer drm_prime_handle prime; memset(&amp;prime, 0, sizeof prime); prime.handle = buffer.handle; prime.flags = /*DRM_CLOEXEC |*/ DRM_RDWR; ret = drmIoctl( DriCardFd, DRM_IOCTL_PRIME_HANDLE_TO_FD, &amp;prime); if (ret &lt; 0) { cout &lt;&lt; "Error cannot DRM_IOCTL_PRIME_HANDLE_TO_FD " &lt;&lt; errno &lt;&lt; " " &lt;&lt; ret &lt;&lt;"\n"; return -1; } dmaFd = prime.fd; // Map the buffer to userspace int Bpp = 32; pplane = mmap(NULL, Width*Height*Bpp/8, PROT_READ | PROT_WRITE, MAP_SHARED, dmaFd, 0); if( pplane == MAP_FAILED ) { cout &lt;&lt; "Error cannot mmap\n"; return -1; } //return valid values *DmaFd = dmaFd; *Plane = pplane; cout &lt;&lt; "DMABUF created "&lt;&lt; dmaFd &lt;&lt; " " &lt;&lt; (void*)Plane &lt;&lt;"\n"; return 0; }</span></span></code> </pre><br>  Agora, precisamos criar uma imagem EGL associada ao manipulador DmaFd: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDmaBufferImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ESContext* esContext, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* DmaFd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">** Plane, EGLImageKHR* Image )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dmaFd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* planePtr = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Bpp = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret0 = CreateDmaBuf( Width, Height, &amp;dmaFd, &amp;planePtr ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ret0&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; EGLint img_attrs[] = { EGL_WIDTH, Width, EGL_HEIGHT, Height, EGL_LINUX_DRM_FOURCC_EXT, DRM_FORMAT_ABGR8888, EGL_DMA_BUF_PLANE0_FD_EXT, dmaFd, EGL_DMA_BUF_PLANE0_OFFSET_EXT, <span class="hljs-number"><span class="hljs-number">0</span></span>, EGL_DMA_BUF_PLANE0_PITCH_EXT, Width * Bpp / <span class="hljs-number"><span class="hljs-number">8</span></span>, EGL_NONE }; EGLImageKHR image = funcEglCreateImageKHR( esContext-&gt;eglDisplay, EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;img_attrs[<span class="hljs-number"><span class="hljs-number">0</span></span>] ); *Plane = planePtr; *DmaFd = dmaFd; *Image = image; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF pointer "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)planePtr &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF fd "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)dmaFd &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"EGLImageKHR "</span></span> &lt;&lt; image &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  E, finalmente, nossas prova√ß√µes est√£o quase no fim e precisamos vincular a imagem do EGL e a imagem do OpenGLESv2.  A fun√ß√£o retorna um ponteiro para a mem√≥ria no espa√ßo de endere√ßo do processo.  L√° voc√™ pode simplesmente escrever a partir de qualquer segmento do processador e todas as altera√ß√µes ao longo do tempo aparecem automaticamente na textura da GPU atrav√©s do DMABUF. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateVideoTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ESContext* esContext, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Height )</span></span></span><span class="hljs-function"> </span></span>{ CreateDmaBufferImage( esContext, Width, Height, &amp;esContext-&gt;DmaFd, &amp;esContext-&gt;Plane, &amp;esContext-&gt;ImageKHR ); GLuint texId; glGenTextures ( <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;texId ); glBindTexture ( GL_TEXTURE_2D, texId ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE ); funcGlEGLImageTargetTexture2DOES(GL_TEXTURE_2D, esContext-&gt;ImageKHR ); checkGlError( __LINE__ ); UserData *userData = (UserData*)esContext-&gt;userData; userData-&gt;textureV = texId; userData-&gt;textureV_ready = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> esContext-&gt;Plane; }</code> </pre><br>  A fun√ß√£o GlEGLImageTargetTexture2DOES (..) faz essa liga√ß√£o.  Ele usa a cria√ß√£o normal de ID de textura glGenTextures (..) e o associa √† imagem esContext-&gt; ImageKHR EGL criada anteriormente.  Depois disso, a textura userData-&gt; textureV pode ser usada em shaders regulares.  E o ponteiro esContext-&gt; Plane √© um ponteiro para a √°rea na mem√≥ria onde voc√™ precisa escrever para atualizar a textura. <br><br>  Aqui est√° um trecho de c√≥digo que copia um quadro de v√≠deo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GstFlowReturn </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_new_sample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( GstAppSink *pAppsink, gpointer pParam )</span></span></span><span class="hljs-function"> </span></span>{ GstFlowReturn ret = GST_FLOW_OK; GstSample *Sample = gst_app_sink_pull_sample(pAppsink); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Sample ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( VideoWidth==<span class="hljs-number"><span class="hljs-number">0</span></span> || VideoHeight==<span class="hljs-number"><span class="hljs-number">0</span></span> ) { GstCaps* caps = gst_sample_get_caps( Sample ); GstStructure* structure = gst_caps_get_structure (caps, <span class="hljs-number"><span class="hljs-number">0</span></span>); gst_structure_get_int (structure, <span class="hljs-string"><span class="hljs-string">"width"</span></span>, &amp;VideoWidth); gst_structure_get_int (structure, <span class="hljs-string"><span class="hljs-string">"height"</span></span>, &amp;VideoHeight); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Stream Resolution "</span></span> &lt;&lt; VideoWidth &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; VideoHeight &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } GstBuffer *Buffer = gst_sample_get_buffer( Sample ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Buffer ) { GstMapInfo MapInfo; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;MapInfo, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(MapInfo)); gboolean Mapped = gst_buffer_map( Buffer, &amp;MapInfo, GST_MAP_READ ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Mapped ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( dmabuf_ptr ) <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>( dmabuf_ptr, MapInfo.data, MapInfo.size ); gst_buffer_unmap( Buffer, &amp;MapInfo); frame_ready = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; update_cv.notify_one(); } } gst_sample_unref( Sample ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>  Essa fun√ß√£o √© chamada pelo pr√≥prio gstreamer toda vez que um novo quadro de v√≠deo aparece.  N√≥s o recuperamos usando gst_app_sink_pull_sample ().  Esta fun√ß√£o possui memcpy (), que copia o quadro na mem√≥ria DMABUF.  Em seguida, o sinalizador frame_ready √© definido e, por meio de std :: condition_variable update_cv.notify_one (), o fluxo processado √© ativado. <br><br>  Provavelmente √© tudo ... <br><br>  Embora n√£o, eu estou mentindo.  Ainda existem problemas de sincroniza√ß√£o. <br><br>  A primeira √© que o processador grava na mem√≥ria, mas esses registros podem acabar no cache do processador e permanecer l√°, √© necess√°rio fazer um cache ap√≥s a grava√ß√£o.  A segunda - n√£o seria ruim saber exatamente quando o DMA j√° funcionou e voc√™ pode come√ßar a renderizar.  Honestamente, se o primeiro eu ainda imagino como fazer, ent√£o o segundo - n√£o.  Se voc√™ tiver id√©ias, escreva nos coment√°rios. <br><br>  E mais uma coisa.  Estou usando o gstreamer, que reproduz um arquivo de v√≠deo.  Adicionei um appsink gen√©rico ao pipeline, que recebe os quadros de v√≠deo.  Pego os pixels dos quadros de v√≠deo e simplesmente os copio memcpy () para a √°rea de mem√≥ria DMABUF.  A renderiza√ß√£o est√° em um encadeamento separado, main ().  Mas eu gostaria de me livrar dessa c√≥pia.  Toda c√≥pia √© m√°.  Existe at√© esse termo c√≥pia zero.  E, a julgar pela documenta√ß√£o, parece que o pr√≥prio gstreamer pode renderizar quadros imediatamente no DMABUF.  Infelizmente, n√£o encontrei um √∫nico exemplo real.  Eu olhei para as fontes do gstreamer - h√° algo sobre isso, mas como us√°-lo exatamente n√£o est√° claro.  Se voc√™ sabe como criar quadros reais de c√≥pia zero com o gstreamer na textura OpenGLESv2 - escreva. <br><br>  Talvez o √∫ltimo ponto: no meu projeto eu uso bitmaps de 32 bits, o que n√£o √© bom no meu caso.  Seria muito mais razo√°vel tirar YUV do gstreamer, ent√£o o tamanho do quadro de v√≠deo √© significativamente menor, mas a l√≥gica √© complicada - eu precisaria fazer 3 DMABUF para tr√™s texturas separadamente Y, U, V. Bem, o shader tamb√©m √© complicado, voc√™ precisa converter YUV para ARGB bem no shader. <br><br>  Voc√™ pode ver o projeto inteiro <a href="https://github.com/random-prj/video-cube">no github</a> .  No entanto, pe√ßo desculpas antecipadamente aos amantes de c√≥digos / estilos limpos e corretos.  Admito que foi escrito de forma descuidada com a ajuda do Google-mine-paste. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt481540/">https://habr.com/ru/post/pt481540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt481530/index.html">Nevanger: alimenta√ß√£o para velocidade</a></li>
<li><a href="../pt481532/index.html">Forensics de mem√≥ria, senhas Rubber Duck e GPO. Solu√ß√£o de problemas com r0ot-mi. Parte 2</a></li>
<li><a href="../pt481534/index.html">Delphi est√° morrendo - falso</a></li>
<li><a href="../pt481536/index.html">A hist√≥ria do sistema de nomes de dom√≠nio: protocolos de "guerra"</a></li>
<li><a href="../pt481538/index.html">20 mitos do SEO para morrer em 2020</a></li>
<li><a href="../pt481542/index.html">Verifica√ß√£o de circuitos digitais. Revis√£o</a></li>
<li><a href="../pt481544/index.html">Usando uma rede neural convolucional para jogar Life (on Keras)</a></li>
<li><a href="../pt481546/index.html">A hist√≥ria do microprocessador e computador pessoal: 1947-1974</a></li>
<li><a href="../pt481548/index.html">Symbol.iterator em Javascript</a></li>
<li><a href="../pt481550/index.html">Inmarsat: recebe e decodifica um sinal de sat√©lite em casa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>