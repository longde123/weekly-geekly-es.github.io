<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≤ üï∫ üíÆ Consultas paralelas no PostgreSQL üíé üë®üèº‚Äçüé® üî™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Existem muitos n√∫cleos nas CPUs modernas. Durante anos, os aplicativos enviaram consultas aos bancos de dados em paralelo. Se esta √© uma consulta de r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Consultas paralelas no PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/446706/"><p><img src="https://habrastorage.org/webt/kx/ht/dl/kxhtdlsry_f8p1jv2ve_1ziks7e.jpeg"></p><br><p>  Existem muitos n√∫cleos nas CPUs modernas.  Durante anos, os aplicativos enviaram consultas aos bancos de dados em paralelo.  Se esta √© uma consulta de relat√≥rio para v√°rias linhas em uma tabela, ela √© executada mais rapidamente quando usa v√°rias CPUs, e no PostgreSQL √© poss√≠vel a partir da vers√£o 9.6. </p><br><p>  Foram necess√°rios tr√™s anos para implementar a fun√ß√£o de consulta paralela - tive que reescrever o c√≥digo em diferentes est√°gios da execu√ß√£o da consulta.  O PostgreSQL 9.6 introduziu uma infraestrutura para melhorar ainda mais o c√≥digo.  Nas vers√µes subseq√ºentes, outros tipos de consultas s√£o executados em paralelo. </p><a name="habracut"></a><br><h3 id="ogranicheniya">  Limita√ß√µes </h3><br><ul><li>  N√£o ative a execu√ß√£o paralela se todos os n√∫cleos j√° estiverem ocupados, caso contr√°rio, outras solicita√ß√µes ficar√£o mais lentas. </li><li>  Mais importante, o processamento paralelo com altos valores WORK_MEM consome muita mem√≥ria - cada jun√ß√£o ou classifica√ß√£o de hash ocupa mem√≥ria na quantidade de work_mem. </li><li>  Solicita√ß√µes OLTP de baixa lat√™ncia n√£o podem ser aceleradas por execu√ß√£o paralela.  E se a consulta retornar uma linha, o processamento paralelo apenas diminuir√° a velocidade. </li><li>  Os desenvolvedores gostam de usar o benchmark TPC-H.  Talvez voc√™ tenha consultas semelhantes para uma execu√ß√£o paralela perfeita. </li><li>  Somente consultas SELECT sem bloqueios de predicado s√£o executadas em paralelo. </li><li>  √Äs vezes, a indexa√ß√£o correta √© melhor do que as varreduras seq√ºenciais da tabela em paralelo. </li><li>  Suspender consultas e cursores n√£o s√£o suportados. </li><li>  Fun√ß√µes de janela e fun√ß√µes agregadas de conjuntos ordenados n√£o s√£o paralelas. </li><li>  Voc√™ n√£o ganha nada na carga de trabalho de E / S. </li><li>  N√£o h√° algoritmos de classifica√ß√£o paralela.  Mas as consultas classificadas podem ser executadas em paralelo em alguns aspectos. </li><li>  Substitua CTE (WITH ...) por um SELECT aninhado para ativar o processamento paralelo. </li><li>  Os inv√≥lucros de dados de terceiros ainda n√£o oferecem suporte ao processamento paralelo (mas poderiam!) </li><li>  JOIN EXTERNO CHEIO n√£o √© suportado. </li><li>  max_rows desativa o processamento paralelo. </li><li>  Se a solicita√ß√£o tiver uma fun√ß√£o que n√£o esteja marcada como PARALLEL SAFE, ela ser√° de thread √∫nico. </li><li>  O n√≠vel de isolamento de transa√ß√£o SERIALIZABLE desabilita o processamento paralelo. </li></ul><br><h3 id="testovaya-sreda">  Ambiente de teste </h3><br><p>  Os desenvolvedores do PostgreSQL tentaram reduzir o tempo de resposta das consultas de benchmark TPC-H.  Fa√ßa o download do benchmark e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">adapte-o ao PostgreSQL</a> .  Esse √© um uso n√£o oficial do benchmark TPC-H - n√£o para comparar bancos de dados ou hardware. </p><br><ol><li>  Fa√ßa o download do TPC-H_Tools_v2.17.3.zip (ou uma vers√£o mais recente) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do TPC externo</a> . </li><li>  Renomeie o makefile.suite para Makefile e altere conforme descrito aqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/tvondra/pg_tpch</a> .  Compile o c√≥digo com o comando make. </li><li> Gerar dados: <code>./dbgen -s 10</code> cria um banco de dados de 23 GB.  Isso √© suficiente para ver a diferen√ßa no desempenho de consultas paralelas e n√£o paralelas. </li><li>  Converta arquivos <code>tbl</code> para <code>csv  for</code> e <code>sed</code> . </li><li>  Clone o reposit√≥rio pg_tpch e copie os <code>csv</code> para <code>pg_tpch/dss/data</code> . </li><li>  Crie consultas com o comando <code>qgen</code> . </li><li>  Fa√ßa o upload dos dados no banco de dados com o comando <code>./tpch.sh</code> . </li></ol><br><h3 id="parallelnoe-posledovatelnoe-skanirovanie">  Varredura sequencial paralela </h3><br><p>  Pode ser mais r√°pido, n√£o por causa da leitura paralela, mas porque os dados est√£o espalhados por muitos n√∫cleos da CPU.  Nos sistemas operacionais modernos, os arquivos de dados do PostgreSQL s√£o bem armazenados em cache.  Com a leitura antecipada, voc√™ pode obter mais do armazenamento do que o daemon PG solicita.  Portanto, o desempenho da consulta n√£o √© limitado pela E / S do disco.  Consome ciclos da CPU para: </p><br><ul><li>  leia as linhas uma a uma das p√°ginas da tabela; </li><li>  Compare valores de sequ√™ncia e cl√°usulas <code>WHERE</code> . </li></ul><br><p>  Vamos executar uma consulta de <code>select</code> simples: </p><br><pre> <code class="plaintext hljs">tpch=# explain analyze select l_quantity as sum_qty from lineitem where l_shipdate &lt;= date '1998-12-01' - interval '105' day; QUERY PLAN -------------------------------------------------------------------------------------------------------------------------- Seq Scan on lineitem (cost=0.00..1964772.00 rows=58856235 width=5) (actual time=0.014..16951.669 rows=58839715 loops=1) Filter: (l_shipdate &lt;= '1998-08-18 00:00:00'::timestamp without time zone) Rows Removed by Filter: 1146337 Planning Time: 0.203 ms Execution Time: 19035.100 ms</code> </pre> <br><p>  Uma varredura seq√ºencial gera muitas linhas sem agrega√ß√£o; portanto, a solicita√ß√£o √© executada por um √∫nico n√∫cleo da CPU. </p><br><p>  Se voc√™ adicionar <code>SUM()</code> , poder√° ver que dois fluxos de trabalho ajudar√£o a acelerar a solicita√ß√£o: </p><br><pre> <code class="plaintext hljs">explain analyze select sum(l_quantity) as sum_qty from lineitem where l_shipdate &lt;= date '1998-12-01' - interval '105' day; QUERY PLAN ---------------------------------------------------------------------------------------------------------------------------------------------------- Finalize Aggregate (cost=1589702.14..1589702.15 rows=1 width=32) (actual time=8553.365..8553.365 rows=1 loops=1) -&gt; Gather (cost=1589701.91..1589702.12 rows=2 width=32) (actual time=8553.241..8555.067 rows=3 loops=1) Workers Planned: 2 Workers Launched: 2 -&gt; Partial Aggregate (cost=1588701.91..1588701.92 rows=1 width=32) (actual time=8547.546..8547.546 rows=1 loops=3) -&gt; Parallel Seq Scan on lineitem (cost=0.00..1527393.33 rows=24523431 width=5) (actual time=0.038..5998.417 rows=19613238 loops=3) Filter: (l_shipdate &lt;= '1998-08-18 00:00:00'::timestamp without time zone) Rows Removed by Filter: 382112 Planning Time: 0.241 ms Execution Time: 8555.131 ms</code> </pre> <br><h3 id="parallelnaya-agregaciya">  Agrega√ß√£o paralela </h3><br><p>  O n√≥ Parallel Seq Scan produz seq√º√™ncias de caracteres para agrega√ß√£o parcial.  O n√≥ Agregado Parcial trunca essas linhas usando <code>SUM()</code> .  No final, o contador SUM de cada fluxo de trabalho √© coletado pelo n√≥ Gather. </p><br><p>  O resultado final √© calculado pelo n√≥ "Finalizar agregado".  Se voc√™ possui suas pr√≥prias fun√ß√µes de agrega√ß√£o, marque-as como "paralelas seguras". </p><br><h3 id="kolichestvo-rabochih-processov">  N√∫mero de fluxos de trabalho </h3><br><p>  O n√∫mero de fluxos de trabalho pode ser aumentado sem reiniciar o servidor: </p><br><pre> <code class="plaintext hljs">alter system set max_parallel_workers_per_gather=4; select * from pg_reload_conf();</code> </pre> <br><p>  Agora vemos 4 trabalhadores na sa√≠da de explica√ß√£o: </p><br><pre> <code class="plaintext hljs">tpch=# explain analyze select sum(l_quantity) as sum_qty from lineitem where l_shipdate &lt;= date '1998-12-01' - interval '105' day; QUERY PLAN ---------------------------------------------------------------------------------------------------------------------------------------------------- Finalize Aggregate (cost=1440213.58..1440213.59 rows=1 width=32) (actual time=5152.072..5152.072 rows=1 loops=1) -&gt; Gather (cost=1440213.15..1440213.56 rows=4 width=32) (actual time=5151.807..5153.900 rows=5 loops=1) Workers Planned: 4 Workers Launched: 4 -&gt; Partial Aggregate (cost=1439213.15..1439213.16 rows=1 width=32) (actual time=5147.238..5147.239 rows=1 loops=5) -&gt; Parallel Seq Scan on lineitem (cost=0.00..1402428.00 rows=14714059 width=5) (actual time=0.037..3601.882 rows=11767943 loops=5) Filter: (l_shipdate &lt;= '1998-08-18 00:00:00'::timestamp without time zone) Rows Removed by Filter: 229267 Planning Time: 0.218 ms Execution Time: 5153.967 ms</code> </pre> <br><p>  O que est√° acontecendo aqui?  Havia 2 vezes mais fluxos de trabalho, e a solicita√ß√£o era apenas 1,6599 vezes mais r√°pida.  Os c√°lculos s√£o interessantes.  Tivemos 2 processos de trabalho e 1 l√≠der.  Ap√≥s a mudan√ßa, tornou-se 4 + 1. </p><br><p>  Nossa acelera√ß√£o m√°xima do processamento paralelo: 5/3 = 1,66 (6) vezes. </p><br><h2 id="kak-eto-rabotaet">  Como isso funciona? </h2><br><h3 id="processy">  Os processos </h3><br><p>  A execu√ß√£o de uma solicita√ß√£o sempre come√ßa com um processo inicial.  O l√≠der faz tudo de forma n√£o paralela e faz parte do processamento paralelo.  Outros processos que executam as mesmas solicita√ß√µes s√£o chamados de fluxos de trabalho.  O processamento paralelo usa uma infraestrutura de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fluxos de trabalho din√¢micos em segundo plano</a> (desde a vers√£o 9.4).  Como outras partes do PostgreSQL usam processos em vez de threads, uma consulta com 3 fluxos de trabalho pode ser 4 vezes mais r√°pida que o processamento tradicional. </p><br><h3 id="vzaimodeystvie">  Intera√ß√£o </h3><br><p>  Os fluxos de trabalho se comunicam com o l√≠der por meio de uma fila de mensagens (com base na mem√≥ria compartilhada).  Cada processo possui 2 filas: para erros e para tuplas. </p><br><h3 id="skolko-nuzhno-rabochih-processov">  Quantos processos de trabalho voc√™ precisa? </h3><br><p>  O limite m√≠nimo √© definido pelo par√¢metro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>max_parallel_workers_per_gather</code></a> .  Em seguida, o executor de consulta obt√©m fluxos de trabalho do pool limitados pelo par√¢metro de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>max_parallel_workers size</code></a> .  A √∫ltima limita√ß√£o √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>max_worker_processes</code></a> , ou seja, o n√∫mero total de processos em segundo plano. </p><br><p>  Se n√£o foi poss√≠vel alocar um fluxo de trabalho, o processamento ser√° de processo √∫nico. </p><br><p>  O planejador de consultas pode reduzir os fluxos de trabalho, dependendo do tamanho da tabela ou do √≠ndice.  Existem par√¢metros <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>min_parallel_index_scan_size</code></a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>min_parallel_index_scan_size</code></a> para isso. </p><br><pre> <code class="plaintext hljs">set min_parallel_table_scan_size='8MB' 8MB table =&gt; 1 worker 24MB table =&gt; 2 workers 72MB table =&gt; 3 workers x =&gt; log(x / min_parallel_table_scan_size) / log(3) + 1 worker</code> </pre> <br><p>  Cada vez que uma tabela √© 3 vezes maior que <code>min_parallel_(index|table)_scan_size</code> , o Postgres adiciona um fluxo de trabalho.  O n√∫mero de processos de trabalho n√£o √© baseado em custos.  A depend√™ncia circular complica implementa√ß√µes complexas.  Em vez disso, o planejador usa regras simples. </p><br><p>  Na pr√°tica, essas regras nem sempre s√£o adequadas para produ√ß√£o, portanto, voc√™ pode alterar o n√∫mero de fluxos de trabalho para uma tabela espec√≠fica: ALTER TABLE ... SET ( <code>parallel_workers = N</code> ). </p><br><h3 id="pochemu-parallelnaya-obrabotka-ne-ispolzuetsya">  Por que o processamento paralelo n√£o √© usado? </h3><br><p>  Al√©m de uma longa lista de restri√ß√µes, tamb√©m existem verifica√ß√µes de custos: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>parallel_setup_cost</code></a> - para fazer sem processamento paralelo de solicita√ß√µes curtas.  Este par√¢metro calcula o tempo para preparar a mem√≥ria, iniciar o processo e trocar dados inicial. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>parallel_tuple_cost</code></a> : a comunica√ß√£o entre um l√≠der e os trabalhadores pode ser atrasada na propor√ß√£o do n√∫mero de tuplas dos processos de trabalho.  Este par√¢metro calcula os custos de troca de dados. </p><br><h3 id="soedineniya-vlozhennyh-ciklov--nested-loop-join">  Jun√ß√£o de loop aninhado </h3><br><pre> <code class="plaintext hljs">PostgreSQL 9.6+      ‚Äî   . explain (costs off) select c_custkey, count(o_orderkey) from customer left outer join orders on c_custkey = o_custkey and o_comment not like '%special%deposits%' group by c_custkey; QUERY PLAN -------------------------------------------------------------------------------------- Finalize GroupAggregate Group Key: customer.c_custkey -&gt; Gather Merge Workers Planned: 4 -&gt; Partial GroupAggregate Group Key: customer.c_custkey -&gt; Nested Loop Left Join -&gt; Parallel Index Only Scan using customer_pkey on customer -&gt; Index Scan using idx_orders_custkey on orders Index Cond: (customer.c_custkey = o_custkey) Filter: ((o_comment)::text !~~ '%special%deposits%'::text)</code> </pre> <br><p>  A cole√ß√£o ocorre no √∫ltimo est√°gio, portanto, a Junta esquerda do loop aninhado √© uma opera√ß√£o paralela.  A Varredura Paralela Somente para √çndice apareceu apenas na vers√£o 10. Funciona de maneira semelhante √† varredura serial paralela.  A condi√ß√£o <code>c_custkey = o_custkey</code> l√™ um pedido para cada linha do cliente.  Portanto, n√£o √© paralelo. </p><br><h3 id="hesh-soedinenie--hash-join">  Hash Join - Hash Join </h3><br><p>  Cada fluxo de trabalho cria sua pr√≥pria tabela de hash antes do PostgreSQL 11. E se houver mais de quatro desses processos, o desempenho n√£o melhorar√°.  Na nova vers√£o, a tabela de hash √© compartilhada.  Cada fluxo de trabalho pode usar WORK_MEM para criar uma tabela de hash. </p><br><pre> <code class="plaintext hljs">select l_shipmode, sum(case when o_orderpriority = '1-URGENT' or o_orderpriority = '2-HIGH' then 1 else 0 end) as high_line_count, sum(case when o_orderpriority &lt;&gt; '1-URGENT' and o_orderpriority &lt;&gt; '2-HIGH' then 1 else 0 end) as low_line_count from orders, lineitem where o_orderkey = l_orderkey and l_shipmode in ('MAIL', 'AIR') and l_commitdate &lt; l_receiptdate and l_shipdate &lt; l_commitdate and l_receiptdate &gt;= date '1996-01-01' and l_receiptdate &lt; date '1996-01-01' + interval '1' year group by l_shipmode order by l_shipmode LIMIT 1; QUERY PLAN ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Limit (cost=1964755.66..1964961.44 rows=1 width=27) (actual time=7579.592..7922.997 rows=1 loops=1) -&gt; Finalize GroupAggregate (cost=1964755.66..1966196.11 rows=7 width=27) (actual time=7579.590..7579.591 rows=1 loops=1) Group Key: lineitem.l_shipmode -&gt; Gather Merge (cost=1964755.66..1966195.83 rows=28 width=27) (actual time=7559.593..7922.319 rows=6 loops=1) Workers Planned: 4 Workers Launched: 4 -&gt; Partial GroupAggregate (cost=1963755.61..1965192.44 rows=7 width=27) (actual time=7548.103..7564.592 rows=2 loops=5) Group Key: lineitem.l_shipmode -&gt; Sort (cost=1963755.61..1963935.20 rows=71838 width=27) (actual time=7530.280..7539.688 rows=62519 loops=5) Sort Key: lineitem.l_shipmode Sort Method: external merge Disk: 2304kB Worker 0: Sort Method: external merge Disk: 2064kB Worker 1: Sort Method: external merge Disk: 2384kB Worker 2: Sort Method: external merge Disk: 2264kB Worker 3: Sort Method: external merge Disk: 2336kB -&gt; Parallel Hash Join (cost=382571.01..1957960.99 rows=71838 width=27) (actual time=7036.917..7499.692 rows=62519 loops=5) Hash Cond: (lineitem.l_orderkey = orders.o_orderkey) -&gt; Parallel Seq Scan on lineitem (cost=0.00..1552386.40 rows=71838 width=19) (actual time=0.583..4901.063 rows=62519 loops=5) Filter: ((l_shipmode = ANY ('{MAIL,AIR}'::bpchar[])) AND (l_commitdate &lt; l_receiptdate) AND (l_shipdate &lt; l_commitdate) AND (l_receiptdate &gt;= '1996-01-01'::date) AND (l_receiptdate &lt; '1997-01-01 00:00:00'::timestamp without time zone)) Rows Removed by Filter: 11934691 -&gt; Parallel Hash (cost=313722.45..313722.45 rows=3750045 width=20) (actual time=2011.518..2011.518 rows=3000000 loops=5) Buckets: 65536 Batches: 256 Memory Usage: 3840kB -&gt; Parallel Seq Scan on orders (cost=0.00..313722.45 rows=3750045 width=20) (actual time=0.029..995.948 rows=3000000 loops=5) Planning Time: 0.977 ms Execution Time: 7923.770 ms</code> </pre> <br><p>  A solicita√ß√£o 12 do TPC-H ilustra uma conex√£o hash paralela.  Cada fluxo de trabalho est√° envolvido na cria√ß√£o de uma tabela de hash compartilhada. </p><br><h3 id="soedinenie-sliyaniem--merge-join">  Mesclar jun√ß√£o </h3><br><p>  Uma jun√ß√£o de mesclagem n√£o √© paralela por natureza.  N√£o se preocupe se esse for o √∫ltimo est√°gio da solicita√ß√£o - ele ainda pode ser executado em paralelo. </p><br><pre> <code class="plaintext hljs">-- Query 2 from TPC-H explain (costs off) select s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment from part, supplier, partsupp, nation, region where p_partkey = ps_partkey and s_suppkey = ps_suppkey and p_size = 36 and p_type like '%BRASS' and s_nationkey = n_nationkey and n_regionkey = r_regionkey and r_name = 'AMERICA' and ps_supplycost = ( select min(ps_supplycost) from partsupp, supplier, nation, region where p_partkey = ps_partkey and s_suppkey = ps_suppkey and s_nationkey = n_nationkey and n_regionkey = r_regionkey and r_name = 'AMERICA' ) order by s_acctbal desc, n_name, s_name, p_partkey LIMIT 100; QUERY PLAN ---------------------------------------------------------------------------------------------------------- Limit -&gt; Sort Sort Key: supplier.s_acctbal DESC, nation.n_name, supplier.s_name, part.p_partkey -&gt; Merge Join Merge Cond: (part.p_partkey = partsupp.ps_partkey) Join Filter: (partsupp.ps_supplycost = (SubPlan 1)) -&gt; Gather Merge Workers Planned: 4 -&gt; Parallel Index Scan using &lt;strong&gt;part_pkey&lt;/strong&gt; on part Filter: (((p_type)::text ~~ '%BRASS'::text) AND (p_size = 36)) -&gt; Materialize -&gt; Sort Sort Key: partsupp.ps_partkey -&gt; Nested Loop -&gt; Nested Loop Join Filter: (nation.n_regionkey = region.r_regionkey) -&gt; Seq Scan on region Filter: (r_name = 'AMERICA'::bpchar) -&gt; Hash Join Hash Cond: (supplier.s_nationkey = nation.n_nationkey) -&gt; Seq Scan on supplier -&gt; Hash -&gt; Seq Scan on nation -&gt; Index Scan using idx_partsupp_suppkey on partsupp Index Cond: (ps_suppkey = supplier.s_suppkey) SubPlan 1 -&gt; Aggregate -&gt; Nested Loop Join Filter: (nation_1.n_regionkey = region_1.r_regionkey) -&gt; Seq Scan on region region_1 Filter: (r_name = 'AMERICA'::bpchar) -&gt; Nested Loop -&gt; Nested Loop -&gt; Index Scan using idx_partsupp_partkey on partsupp partsupp_1 Index Cond: (part.p_partkey = ps_partkey) -&gt; Index Scan using supplier_pkey on supplier supplier_1 Index Cond: (s_suppkey = partsupp_1.ps_suppkey) -&gt; Index Scan using nation_pkey on nation nation_1 Index Cond: (n_nationkey = supplier_1.s_nationkey)</code> </pre> <br><p>  O n√≥ Merge Join est√° localizado acima da Gather Merge.  Portanto, a mesclagem n√£o usa processamento paralelo.  Mas o n√≥ Parallel Index Scan ainda ajuda no segmento <code>part_pkey</code> . </p><br><h3 id="soedinenie-po-sekciyam">  Se√ß√£o Conex√£o </h3><br><p>  No PostgreSQL 11, o particionamento √© desativado por padr√£o: possui um agendamento muito caro.  Tabelas com particionamento semelhante podem ser unidas se√ß√£o por se√ß√£o.  Portanto, o Postgres usar√° tabelas de hash menores.  Cada conex√£o de se√ß√£o pode ser paralela. </p><br><pre> <code class="plaintext hljs">tpch=# set enable_partitionwise_join=t; tpch=# explain (costs off) select * from prt1 t1, prt2 t2 where t1.a = t2.b and t1.b = 0 and t2.b between 0 and 10000; QUERY PLAN --------------------------------------------------- Append -&gt; Hash Join Hash Cond: (t2.b = t1.a) -&gt; Seq Scan on prt2_p1 t2 Filter: ((b &gt;= 0) AND (b &lt;= 10000)) -&gt; Hash -&gt; Seq Scan on prt1_p1 t1 Filter: (b = 0) -&gt; Hash Join Hash Cond: (t2_1.b = t1_1.a) -&gt; Seq Scan on prt2_p2 t2_1 Filter: ((b &gt;= 0) AND (b &lt;= 10000)) -&gt; Hash -&gt; Seq Scan on prt1_p2 t1_1 Filter: (b = 0) tpch=# set parallel_setup_cost = 1; tpch=# set parallel_tuple_cost = 0.01; tpch=# explain (costs off) select * from prt1 t1, prt2 t2 where t1.a = t2.b and t1.b = 0 and t2.b between 0 and 10000; QUERY PLAN ----------------------------------------------------------- Gather Workers Planned: 4 -&gt; Parallel Append -&gt; Parallel Hash Join Hash Cond: (t2_1.b = t1_1.a) -&gt; Parallel Seq Scan on prt2_p2 t2_1 Filter: ((b &gt;= 0) AND (b &lt;= 10000)) -&gt; Parallel Hash -&gt; Parallel Seq Scan on prt1_p2 t1_1 Filter: (b = 0) -&gt; Parallel Hash Join Hash Cond: (t2.b = t1.a) -&gt; Parallel Seq Scan on prt2_p1 t2 Filter: ((b &gt;= 0) AND (b &lt;= 10000)) -&gt; Parallel Hash -&gt; Parallel Seq Scan on prt1_p1 t1 Filter: (b = 0)</code> </pre> <br><p>  O principal √© que a conex√£o nas se√ß√µes seja paralela apenas se essas se√ß√µes forem grandes o suficiente. </p><br><h3 id="parallelnoe-dopolnenie--parallel-append">  Anexo Paralelo - Anexo Paralelo </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Anexar paralelo</a> pode ser usado em vez de diferentes blocos em diferentes fluxos de trabalho.  Isso geralmente acontece com as consultas UNION ALL.  A desvantagem √© menos paralelismo, porque cada fluxo de trabalho processa apenas 1 solicita√ß√£o. </p><br><p>  Dois fluxos de trabalho est√£o em execu√ß√£o aqui, embora quatro estejam inclu√≠dos. </p><br><pre> <code class="plaintext hljs">tpch=# explain (costs off) select sum(l_quantity) as sum_qty from lineitem where l_shipdate &lt;= date '1998-12-01' - interval '105' day union all select sum(l_quantity) as sum_qty from lineitem where l_shipdate &lt;= date '2000-12-01' - interval '105' day; QUERY PLAN ------------------------------------------------------------------------------------------------ Gather Workers Planned: 2 -&gt; Parallel Append -&gt; Aggregate -&gt; Seq Scan on lineitem Filter: (l_shipdate &lt;= '2000-08-18 00:00:00'::timestamp without time zone) -&gt; Aggregate -&gt; Seq Scan on lineitem lineitem_1 Filter: (l_shipdate &lt;= '1998-08-18 00:00:00'::timestamp without time zone)</code> </pre> <br><h3 id="samye-vazhnye-peremennye">  As vari√°veis ‚Äã‚Äãmais importantes </h3><br><ul><li>  WORK_MEM limita a quantidade de mem√≥ria para cada processo, n√£o apenas para solicita√ß√µes: <em>processos de</em> conex√£o work_mem = muita mem√≥ria. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>max_parallel_workers_per_gather</code></a> - quantos processos de trabalho o programa em execu√ß√£o usar√° para processamento paralelo do plano. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>max_worker_processes</code></a> - ajusta o n√∫mero total de processos de trabalho ao n√∫mero de n√∫cleos da CPU no servidor. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>max_parallel_workers</code></a> √© o mesmo, mas para fluxos de trabalho paralelos. </li></ul><br><h3 id="itogi">  Sum√°rio </h3><br><p>  A partir da vers√£o 9.6, o processamento paralelo pode melhorar seriamente o desempenho de consultas complexas que varrem muitas linhas ou √≠ndices.  No PostgreSQL 10, o processamento paralelo √© ativado por padr√£o.  Lembre-se de desativ√°-lo em servidores com uma grande carga de trabalho OLTP.  As verifica√ß√µes sequenciais ou de √≠ndice consomem muitos recursos.  Se voc√™ n√£o estiver relatando todo o conjunto de dados, as consultas poder√£o ser mais eficientes simplesmente adicionando os √≠ndices ausentes ou usando o particionamento correto. </p><br><h3 id="ssylki">  Refer√™ncias </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.postgresql.org/docs/11/how-parallel-query-works.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.postgresql.org/docs/11/parallel-plans.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://ashutoshpg.blogspot.com/2017/12/partition-wise-joins-divide-and-conquer.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://rhaas.blogspot.com/2016/04/postgresql-96-with-parallel-query-vs.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://amitkapila16.blogspot.com/2015/11/parallel-sequential-scans-in-play.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://write-skew.blogspot.com/2018/01/parallel-hash-for-postgresql.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://rhaas.blogspot.com/2017/03/parallel-query-v2.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://blog.2ndquadrant.com/parallel-monster-benchmark/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://blog.2ndquadrant.com/parallel-aggregate/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.depesz.com/2018/02/12/waiting-for-postgresql-11-support-parallel-btree-index-builds/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Concorr√™ncia no PostgreSQL 11</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt446706/">https://habr.com/ru/post/pt446706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt446690/index.html">Electrolux lan√ßa purificador de ar inteligente para as cidades mais polu√≠das</a></li>
<li><a href="../pt446694/index.html">Armazenamento modular JBOD e graus de liberdade</a></li>
<li><a href="../pt446696/index.html">Mitos sobre 152-FZ, que podem ser caros para o operador de dados pessoais</a></li>
<li><a href="../pt446700/index.html">Lazydocker - GUI do Docker diretamente no terminal</a></li>
<li><a href="../pt446702/index.html">E outro fone de ouvido estranho - para dormir</a></li>
<li><a href="../pt446708/index.html">Compara√ß√£o de sistemas de comunica√ß√£o espacial</a></li>
<li><a href="../pt446710/index.html">Quatro hist√≥rias reais de trabalho com arquitetura de microsservi√ßos - relat√≥rio da mitap do Backend United 3: Kholodets</a></li>
<li><a href="../pt446712/index.html">O HTTPS nem sempre √© t√£o seguro quanto parece. Vulnerabilidades encontradas em 5,5% dos sites HTTPS</a></li>
<li><a href="../pt446714/index.html">Pervers√µes curiosas do mundo da TI - 4</a></li>
<li><a href="../pt446716/index.html">Consci√™ncia e Argumento do Ju√≠zo Final</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>