<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎃 🧑🏼 🕣 浏览器中的元胞自动机 🧜 🎱 👩🏿‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="元胞自动机是一个系统，它由网格中具有数值的单元以及确定这些单元行为的规则组成。 与规则的可视化并行地将规则重复应用于每个网格单元，即使规则相对简单，也常常可以得到具有复杂复杂行为的某种进化生物的影响。 

 细胞自动机具有各种形状，类型和尺寸。 也许最著名的细胞自动机是康威的生命游戏（GOL）。 它...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>浏览器中的元胞自动机</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481672/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/028/8da/3c1/0288da3c139cf936f21eccce5342a6d6.jpg" alt="图片"></div><br> 元胞自动机是一个系统，它由网格中具有数值的单元以及确定这些单元行为的规则组成。 与规则的可视化并行地将规则重复应用于每个网格单元，即使规则相对简单，也常常可以得到具有复杂复杂行为的某种进化生物的影响。 <br><br> 细胞自动机具有各种形状，类型和尺寸。 也许最著名的细胞自动机是康威的生命游戏（GOL）。 它由一个二维网格组成，其中每个单元格都包含一个二进制值（有效或无效）。 附带的规则基于相邻单元格的状态来确定该单元格是死亡还是存活。 规则说，如果周围有少于两个活细胞，则活细胞会死于孤独。 如果三个以上的相邻细胞还活着，她将因人口过剩而死亡。 换句话说，如果某个细胞周围有2或3个存活的相邻细胞，则该细胞“存活”。 要使一个<em>死</em>细胞<em>复活</em> ，它必须恰好有3个活着的相邻细胞，否则它将保持死状态。 下面显示了GoL机器迭代几个状态的示例。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/562/8d3/d06/5628d3d06c87bcf93b7949f8ea5eec7a.gif" alt="生活游戏"></div><br> 元胞自动机的另一个著名版本是一维的。 它被称为基本元胞自动机（ECA）。 这就是我们在本文中实现的。 <br><a name="habracut"></a><br> 此自动机的每个状态都存储为一维布尔值数组，并且需要两个维来可视化GOL状态，但一个自动值足以满足该自动机的需要。 因此，我们可以使用二维（而不是动画）来可视化此自动机状态的整个历史记录。 与GOL情况一样，本机中单元的状态为0或1，但与GOL单元不同，该单元根据其8个邻居进行更新，而ECA单元则根据左邻居，右邻居及其自身的状态进行更新！ <br><br> 规则示例如下所示：顶部的三个单元格是规则的输入，底部的一个单元格是输出，黑色是1，白色是0。此外，我们可以看到当初始状态均为0时，它们各自生成的模式在中间的单元格中。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ad/c6d/69a/7adc6d69a6e6f302850bc9227ea8bdb1.jpg"></div><br> 您可能想知道：为什么上面给出的规则用数字表示？ 因为从0到255范围内的每个数字都直接对应于ECA规则，因此这些数字将用作规则的名称。 该对应关系如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a41/65e/13b/a4165e13bf83463bbf66a155ba8441fd.png"></div><br>  <i>从数字到规则</i> <br><br>  0到255之间的任何数字都可以用仅8位的二进制形式表示（上面的第一个箭头）。 此外，我们可以根据其位置（第二箭头）为每个数字提供索引。 自然地，这些索引在0到7的范围内，也就是说，它们只能用3位数字（第三个箭头）以二进制形式表示。 解释这3位数字作为输入，并将原始数字中的相应数字作为输出，我们得到了所需的三进制函数（第四个箭头）。 <br><br><h2> 规则生成 </h2><br> 让我们将上述解释实现为一个高阶函数<code>get_rule</code> ，该函数接收从0到255之间的数字作为输入，并返回与该数字相对应的ECA规则。 <br><br> 我们需要创建如下内容： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rule30 = get_rule(<span class="hljs-number"><span class="hljs-number">30</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> output110 = rule30(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br> 在上面的示例中，起始<code>rule30(1,1,0)</code>所有三个二进制值组合为一个数字（110 = 6），并将在二进制表示形式30中的那个位置（6）返回一位。二进制表示形式的数字30为00011110，因此，该函数将返回0（我们从右边开始计数，并从0开始计数）。 <br><br> 知道三个二进制输入变量将被组合为一个数字，让我们从实现这样的<code>combine</code>函数开始。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> combine = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">b1, b2, b3</span></span></span><span class="hljs-function">) =&gt;</span></span> (b1 &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) + (b2 &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) + (b3 &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br> 将参数左移到相应的位置，然后将三个移位的数字相加，即可得到所需的组合。 <br><br>  <code>get_rule</code>函数的第二个重要部分是确定数字中特定位置的位值。 因此，让我们创建一个函数<code>get_bit(num, pos)</code> ，该函数可以在给定位置<code>pos</code>上以给定数字<code>num</code>返回位值。 例如，二进制数141为10001101，因此<code>get_bit(2, 141)</code>应该返回<code>1</code> ，而<code>get_bit(5, 141)</code>应该返回<code>0</code> 。 <br><br> 可以通过首先将数字右移<code>pos</code> ，然后对数字1执行按位运算“ AND”，来实现<code>get_bit(num,pos)</code>函数。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> get_bit = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num, pos</span></span></span><span class="hljs-function">) =&gt;</span></span> (num &gt;&gt; pos) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br> 现在我们只需要结合这两个功能： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> get_rule = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function"> =&gt;</span></span> (b1, b2, b3) =&gt; get_bit(num, combine(b1, b2, b3));</code> </pre> <br> 太好了！ 因此，我们有一个函数，可以为间隔内的每个数字提供唯一的ECA规则，使我们可以执行任何操作。 下一步是在浏览器中呈现它们。 <br><br><h2> 规则可视化 </h2><br> 为了在浏览器中呈现自动机，我们将使用<code>canvas</code>元素。 可以如下创建<code>canvas</code>并将其添加到html主体中： <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canvas = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'canvas'</span></span>); canvas.width = <span class="hljs-number"><span class="hljs-number">800</span></span>; canvas.height = <span class="hljs-number"><span class="hljs-number">800</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild(canvas); };</code> </pre> <br> 为了能够与<code>canvas</code>交互，我们需要<em>上下文</em> 。 上下文允许我们绘制形状和线条，为对象着色以及通常在<code>canvas</code>导航。 它是通过<code>canvas</code>的<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext" rel="nofollow"><code>getContext</code></a>方法提供给我们的。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> context = canvas.getContext(<span class="hljs-string"><span class="hljs-string">'2d'</span></span>);</code> </pre> <br> 参数<code>'2d'</code>是指在此示例中将使用的上下文类型。 <br><br> 接下来，我们将创建一个函数，该函数具有上下文，ECA规则以及有关像元大小和数量的一些信息，可在<code>canvas</code>上绘制该规则。 这个想法是逐行生成和绘制一个网格。 代码的主要部分如下所示： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_rule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, rule, scale, width, height</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> row = initial_row(width); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; height; i++) { draw_row(ctx, row, scale); row = next_row(row, rule); } }</code> </pre> <br> 我们从某种初始的单元格集开始，即当前行。 如上例所示，此行通常包含全零，中间单元格中只有一个单位，但它也可以包含完全随机的1和0行。我们绘制此行单元格，然后使用该规则根据当前行。 然后，我们只需重复绘图并计算新步骤，直到发现网格足够高。 <br><br> 对于以上代码段，我们需要实现三个函数： <code>initial_row</code> ， <code>draw_row</code>和<code>next_row</code> 。 <br><br>  <code>initial_row</code>是一个简单的函数。 它创建一个零数组，并将数组中心的元素更改为一。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initial_row</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initial_row = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length).fill(<span class="hljs-number"><span class="hljs-number">0</span></span>); initial_row[<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(length / <span class="hljs-number"><span class="hljs-number">2</span></span>)] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> initial_row; }</code> </pre> <br> 由于我们已经有一个规则函数，因此<code>next_row</code>函数可以由一行组成。 新行中每个单元格的值是将规则与最近的单元格的值一起应用的结果，而旧行用作输入。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> next_row = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row, rule</span></span></span><span class="hljs-function">) =&gt;</span></span> row.map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_, i</span></span></span><span class="hljs-function">) =&gt;</span></span> rule(row[i - <span class="hljs-number"><span class="hljs-number">1</span></span>], row[i], row[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]));</code> </pre> <br> 您是否注意到我们在这条线上作弊了？ 新行中的每个单元都需要来自其他三个单元的输入，但是该行边缘的两个单元仅从两个单元接收数据。 例如， <code>next_row[0]</code>试图从<code>row[-1]</code>获取<code>next_row[0]</code>值。 这仍然有效，因为当试图通过不在数组中的索引访问值时，javascript返回<code>undefined</code> ，并且碰巧<code>(undefined &gt;&gt; [ ])</code> （来自<code>combine</code>函数）总是返回0。这意味着实际上，我们将数组外部的每个值都处理为0。 <br><br> 我知道这很丑陋，但是很快我们将在屏幕上创建一些漂亮的东西，以便我们可以原谅。 <br><br> 接下来是<code>draw_row</code>函数； 是她执行渲染！ <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_row</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, row, scale</span></span></span><span class="hljs-function">) </span></span>{ ctx.save(); row.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cell</span></span></span><span class="hljs-function"> =&gt;</span></span> { ctx.fillStyle = cell === <span class="hljs-number"><span class="hljs-number">1</span></span> ? <span class="hljs-string"><span class="hljs-string">'#000'</span></span> : <span class="hljs-string"><span class="hljs-string">'#fff'</span></span>; ctx.fillRect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, scale, scale); ctx.translate(scale, <span class="hljs-number"><span class="hljs-number">0</span></span>); }); ctx.restore(); ctx.translate(<span class="hljs-number"><span class="hljs-number">0</span></span>, scale); }</code> </pre> <br> 在这里，我们非常依赖于上下文对象，使用至少5种不同的方法。 这里是一个简短的清单以及如何使用它们。 <br><br><ul><li>  <code>fillStyle</code>指示我们要如何填充形状。 它可以是颜色，例如<code>"#f55"</code> ，也可以是渐变或图案。 我们使用这种方法在视觉上将单元格0与单元格1分开。 </li><li>  <code>fillRect(x, y, w, h)</code>从点（x，y <code>fillRect(x, y, w, h)</code>绘制一个矩形，其宽度为w且高度为h，并根据<code>fillStyle</code>填充。 我们的矩形是简单的正方形，但是您可能会惊讶于所有矩形的起点都是原点。 之所以发生这种情况，是因为我们将此方法与<code>translate</code>结合使用。 </li><li>  <code>translate(x, y)</code>允许您移动整个坐标系。 位置已保存，因此该方法是跟踪元素的不同位置的绝佳替代方法。 例如，我们可以简单地绘制一个单元格，向右移动，绘制一个新的单元格，而不是计算每个单独的网格单元格的位置。 </li><li>  <code>save()</code>和<code>restore()</code>与<code>translate</code>和其他坐标转换方法结合使用。 我们使用它们在特定点<em>保存</em>当前坐标系，以便稍后我们可以返回到它（使用<em>restore</em> ）。 在这种情况下，我们在绘制直线之前先保存坐标系，然后将其向右移动。 然后，当我们完成绘制线并一直向右移动时，坐标将恢复并返回到原始状态。 然后我们向下移动以准备绘制下一行。 </li></ul><br> 现在我们有了<code>draw_rule</code>函数所需的所有部分。 在准备<code>canvas</code>之后，我们在<code>window.onload</code>使用此功能。 我们还将确定所需的参数。 <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> width = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Width of the canvas const height = 500; // Height of the canvas const cells_across = 200; // Number of cells horizontally in the grid const cell_scale = width / cells_across; // Size of each cell const cells_down = height / cell_scale; // Number of cells vertically in the grid const rule = get_rule(30); // The rule to display const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height; document.body.appendChild(canvas); const context = canvas.getContext('2d'); draw_rule(context, rule, cell_scale, cells_across, cells_down); };</span></span></code> </pre> <br> 我们提取<code>canvas</code>尺寸作为单独的变量以及水平单元格的数量。 然后我们计算<code>cell_scale</code>和'cells_down'，以便网格填充整个<code>canvas</code> ，而单元格保持正方形。 因此，我们可以轻松地更改<code>canvas</code>剩余的网格的“分辨率”。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d98/566/33e/d9856633e69f731e69a8ae40a79591c2.png"></div><br> 仅此而已！ 完整的代码示例在<a href="" rel="nofollow">github</a>和<a href="https://codepen.io/kgolid/pen/oNgZKqV" rel="nofollow">codepen上</a> ： <br><br><h2> 继续前进 </h2><br> 借助这一系统，我们将能够依次检查所有256条规则，这些规则可以迭代，更改代码或在每次页面加载时随机选择一个规则号。 尽管如此，在我们受控的环境中研究所有这些不可预测的结果非常令人兴奋。 <br><br> 您还可以使自动机的像元的初始状态随机，而不是使静态“实零和一个单位”成为随机状态。 因此，我们得到了更加不可预测的结果。 此版本的<code>initial_row</code>函数可以这样编写： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">random_initial_row</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">width</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(width), _ =&gt; <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * <span class="hljs-number"><span class="hljs-number">2</span></span>)); }</code> </pre> <br> 在下面，您可以看到输出线变化对输出有很大的影响。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a6/023/75e/6a602375ecbe522ad75829547ee92b5f.png"></div><br>  <i>随机源字符串</i> <br><br> 这只是您可以更改的一个方面！ 为什么只将自己限制在两个条件下？  （从2个状态转换为3个状态会将规则数量从256个增加到7 625 597 484 987个！）为什么限于正方形？ 为什么只有二维？ 为什么一次只有一条规则？ <br><br> 下面显示了基于ECA的可视化示例，但具有另一个<code>draw_rule</code>函数，该函数<code>draw_rule</code>线条不是等角线而是等距图案，然后用颜色填充这些线定义的区域。 您甚至不必显示分隔线，而只需显示颜色。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/028/8da/3c1/0288da3c139cf936f21eccce5342a6d6.jpg"></div><br> 如果走得更远，则可以添加轴向（中间行）和镜像（底部行）的对称性。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f71/cad/adc/f71cadadc23b156366f5bb93669d8b06.jpg"></div><br> 如果这些可视化对您来说很有趣，但是研究<a href="https://generated.space/sketch/hatch-automata-full/" rel="nofollow">此交互式沙箱</a> ，或者甚至更好，请从我们创建的代码开始，并尝试提出自己的蜂窝自动机！ <br><br> 祝你好运 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN481672/">https://habr.com/ru/post/zh-CN481672/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN481662/index.html">尝试在Kubernetes中构建和自动化部署的新工具</a></li>
<li><a href="../zh-CN481664/index.html">无服务器定价和成本：AWS Lambda</a></li>
<li><a href="../zh-CN481666/index.html">自定义SwiftLint规则</a></li>
<li><a href="../zh-CN481668/index.html">第一个观众问题，或将WebRTC视频流转换为HLS的困难</a></li>
<li><a href="../zh-CN481670/index.html">使用AWS Cloud Adoption Framework创建行动计划</a></li>
<li><a href="../zh-CN481674/index.html">汽车销售渠道还是如何不合并客户，甚至与拒绝您服务的客户合作？</a></li>
<li><a href="../zh-CN481676/index.html">安全周52：智能扬声器和IP摄像机的安全性</a></li>
<li><a href="../zh-CN481678/index.html">假日前回顾：N6IIT01播放器和YB04电枢耳机-来自华南的Hi-Fi</a></li>
<li><a href="../zh-CN481680/index.html">在dap上编写TodoMVC。 第二部分</a></li>
<li><a href="../zh-CN481684/index.html">来自Powerbank的笔记本电脑？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>