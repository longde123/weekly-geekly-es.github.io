<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘µğŸ» ğŸŒ— ğŸ‘¹ Layanan Mikro: ukuran penting meskipun Anda memiliki Kubernet ğŸ¤›ğŸ½ ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ ğŸ•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada 19 September, metap tematik pertama HUG (Highload ++ User Group) diadakan di Moskow, yang didedikasikan untuk layanan microser. Laporan "Pengoper...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Layanan Mikro: ukuran penting meskipun Anda memiliki Kubernet</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/424531/">  Pada 19 September, metap tematik pertama HUG (Highload ++ User Group) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diadakan</a> di Moskow, yang didedikasikan untuk layanan microser.  Laporan "Pengoperasian layanan microser: ukuran sangat penting bahkan jika Anda memiliki Kubernet" disampaikan di mana kami berbagi pengalaman luas Flant dalam proyek pengoperasian dengan arsitektur layanan microser.  Pertama-tama, ini akan bermanfaat bagi semua pengembang yang berpikir untuk menerapkan pendekatan ini dalam proyek mereka saat ini atau masa depan. <br><br><img src="https://habrastorage.org/webt/jb/ka/cp/jbkacpew1yyus4jx9l5rbdpc3iq.jpeg"><br><br>  Kami menyajikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>video dengan laporan</b></a> (50 menit, jauh lebih informatif daripada artikel), serta ekstrak utama dari itu dalam bentuk teks. <br><br>  <i>NB: Video dan presentasi juga tersedia di akhir publikasi ini.</i> <a name="habracut"></a><br><br><h2>  Pendahuluan </h2><br>  Biasanya cerita yang bagus memiliki plot, plot utama dan denouement.  Laporan ini lebih seperti plot, dan tragis.  Penting juga untuk dicatat bahwa ini menyediakan tampilan pada <i>operasi layanan</i> microser. <br><br>  Saya akan mulai dengan jadwal seperti itu, yang penulisnya (pada 2015) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">adalah</a> Martin Fowler: <br><br><img src="https://habrastorage.org/webt/lj/fo/rz/ljforzqes2fsafgqo6gvhxfrpue.png"><br><br>  Ini menunjukkan bagaimana dalam kasus aplikasi monolitik yang telah mencapai nilai tertentu, produktivitas pekerjaan mulai menurun.  Layanan Microsoft berbeda karena produktivitas awal dengan mereka lebih rendah, namun, seiring dengan meningkatnya kompleksitas, penurunan efisiensi bagi mereka tidak begitu terlihat. <br><br>  Saya akan melengkapi grafik ini untuk kasus menggunakan Kubernetes: <br><br><img src="https://habrastorage.org/webt/b1/co/v-/b1cov-wky66lpvijeu0cgf72u9y.png"><br><br>  Mengapa aplikasi microservice menjadi lebih baik?  Karena arsitektur seperti itu mengedepankan persyaratan arsitektur yang serius, yang pada gilirannya tercakup dengan sempurna oleh kemampuan Kubernetes.  Di sisi lain, bagian dari fungsi ini juga akan berguna untuk monolit, terutama karena alasan bahwa monolit yang khas saat ini bukanlah monolit (detail akan lebih jauh dalam laporan). <br><br>  Seperti yang Anda lihat, jadwal akhir (ketika aplikasi monolitik dan microservice dalam infrastruktur dengan Kubernetes) tidak jauh berbeda dari aslinya.  Selanjutnya, kita akan berbicara tentang aplikasi yang berjalan menggunakan Kubernetes. <br><br><h2>  Layanan microser yang berguna dan berbahaya </h2><br>  Dan inilah ide utamanya: <br><br><img src="https://habrastorage.org/webt/fa/ks/uz/faksuzabviitaowg8rxaaxz3hgi.jpeg"><br><br>  Apa itu arsitektur microservice <b>normal</b> ?  Seharusnya memberi Anda manfaat nyata, meningkatkan efisiensi kerja.  Jika Anda kembali ke grafik, ini dia: <br><br><img src="https://habrastorage.org/webt/az/mn/jv/azmnjv4kc7fnk36mxvhodoirsk8.png"><br><br>  Jika Anda menyebutnya <b>bermanfaat</b> , maka di sisi lain dari grafik akan ada microservice <b>berbahaya</b> (mengganggu pekerjaan): <br><br><img src="https://habrastorage.org/webt/fh/nt/y4/fhnty40ebkuydrbdwacgmxmnghk.png"><br><br>  Kembali ke "ide utama": apakah layak untuk memercayai pengalaman saya sama sekali?  Sejak awal tahun ini, saya telah melihat <b>85 proyek</b> .  Tidak semua dari mereka adalah layanan mikro (sekitar sepertiga hingga setengah dari mereka memiliki arsitektur seperti itu), tetapi ini masih banyak.  Kami (perusahaan Flant) sebagai agen outsourcing mengelola untuk melihat berbagai aplikasi yang dikembangkan baik di perusahaan kecil (dengan 5 pengembang) dan yang besar (~ 500 pengembang).  Kelebihan lainnya adalah kita melihat bagaimana aplikasi ini hidup dan berkembang selama bertahun-tahun. <br><br><h2>  Mengapa layanan microser? </h2><br>  Untuk pertanyaan tentang manfaat layanan mikro, Martin Fowler yang telah disebutkan memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jawaban yang sangat spesifik</a> : <br><br><ol><li>  batas modularitas yang jelas; </li><li>  penyebaran independen; </li><li>  kebebasan memilih teknologi. </li></ol><br>  Saya banyak berbicara dengan arsitek dan pengembang perangkat lunak dan bertanya mengapa mereka membutuhkan layanan microser.  Dan menyusun daftar harapan mereka.  Inilah yang terjadi: <br><br><img src="https://habrastorage.org/webt/su/g3/nb/sug3nbuvq8arpcszp9eprf0swto.png"><br><br>  Jika Anda menggambarkan "dalam sensasi" beberapa poin, maka: <br><br><ul><li>  batas-batas modul yang jelas: di sini kita memiliki monolit yang mengerikan, dan sekarang semuanya akan ditata dengan rapi di repositori Git, di mana semuanya berada "di rak", tidak dicampur dengan hangat dan lunak; </li><li>  Kemandirian penerapan: kami akan dapat meluncurkan layanan secara mandiri, sehingga pengembangan berjalan lebih cepat (mempublikasikan fitur baru secara paralel); </li><li>  independensi pengembangan: kami dapat memberikan layanan mikro ini kepada tim / pengembang tersebut, dan yang lainnya, sehingga kami dapat berkembang lebih cepat; </li><li>  keandalan yang lebih besar: jika terjadi degradasi parsial (satu microservice dari 20 jatuh), maka hanya satu tombol yang akan berhenti bekerja, dan sistem secara keseluruhan akan terus berfungsi. </li></ul><br><h2>  Arsitektur layanan mikro yang khas (berbahaya) </h2><br>  Untuk menjelaskan mengapa pada kenyataannya semuanya tidak seperti yang kita harapkan, saya akan menyajikan gambar <i>kolektif</i> arsitektur layanan mikro berdasarkan pengalaman dari banyak proyek yang berbeda. <br><br>  Contohnya adalah toko online abstrak yang akan bersaing dengan Amazon atau setidaknya OZON.  Arsitektur microservice-nya terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/ly/sl/7-/lysl7-cb72eaj8wnhes4bgina84.gif"><br><br>  Untuk kombinasi alasan, layanan microser ini ditulis pada platform berbeda: <br><br><img src="https://habrastorage.org/webt/x6/hu/rt/x6hurt6jnp-cdugf_mcopvhaqu8.png"><br><br>  Karena setiap layanan mikro harus memiliki otonomi, banyak dari mereka memerlukan basis data dan cache mereka sendiri.  Arsitektur terakhir adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/ee/dr/_x/eedr_xp3mh22lyb9b04ewqzm1ek.png"><br><br><h2>  Apa konsekuensinya? </h2><br>  Fowler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memiliki artikel</a> tentang hal ini - tentang "pengembalian" untuk menggunakan layanan Microsoft: <br><br><img src="https://habrastorage.org/webt/v8/9l/0j/v89l0j0ucc2icw34ojowadgf4w0.jpeg"><br><br>  Dan kita akan melihat apakah harapan kita terpenuhi. <br><br><h3>  Hapus batas modul ... </h3><br>  Tetapi <b>berapa banyak layanan microser yang benar-benar perlu kita perbaiki</b> untuk meluncurkan perubahan?  Bisakah kita mencari tahu bagaimana semuanya bekerja tanpa pelacak terdistribusi (setelah semua, setiap permintaan diproses oleh setengah dari layanan microser)? <br><br>  Ada pola â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">benjolan besar lumpur</a> â€, tetapi di sini kita mendapatkan benjolan lumpur yang didistribusikan.  Untuk mendukung ini, berikut adalah contoh ilustrasi tentang bagaimana pertanyaan berjalan: <br><br><img src="https://habrastorage.org/webt/9x/p4/dg/9xp4dgwekrlygkemlygsisl6nxm.jpeg"><br><br><h3>  Penerapan Kemerdekaan ... </h3><br>  Secara teknis, ini telah dicapai: kita dapat menggulung masing-masing layanan microser secara terpisah.  Namun dalam praktiknya, Anda perlu mempertimbangkan bahwa <b>banyak layanan microsoft</b> selalu diluncurkan, dan kami harus memperhitungkan <b>urutan peluncurannya</b> .  Dengan cara yang baik, kita umumnya perlu menguji di sirkuit terpisah apakah kita meluncurkan rilis dalam urutan yang benar. <br><br><h3>  Kebebasan untuk memilih teknologi ... </h3><br>  Dia disana.  Patut diingat bahwa seringkali kebebasan berbatasan dengan pelanggaran hukum.  Sangat penting di sini untuk tidak memilih teknologi hanya untuk "bermain" dengan mereka. <br><br><h3>  Kemerdekaan Pembangunan ... </h3><br>  Bagaimana cara membuat rangkaian uji untuk seluruh aplikasi (dari begitu banyak komponen)?  Tetapi Anda masih harus mempertahankannya tetap terbaru.  Semua ini mengarah pada fakta bahwa <b>jumlah sebenarnya dari loop tes</b> , yang kita, pada prinsipnya, dapat mengandung, <b>adalah minimal</b> . <br><br>  Tetapi untuk menyebarkan semua ini secara lokal? .. Ternyata sering pengembang melakukan pekerjaannya secara independen, tetapi secara acak, karena ia harus menunggu sampai sirkuit untuk pengujian dirilis. <br><br><h3>  Penskalaan terpisah ... </h3><br>  Ya, tetapi terbatas pada area DBMS yang digunakan.  Dalam contoh arsitektur yang diberikan, Cassandra tidak akan memiliki masalah, tetapi MySQL dan PostgreSQL akan memilikinya. <br><br><h3>  Keandalan lebih ... </h3><br>  Tidak hanya itu, pada kenyataannya, kegagalan satu microservice sering merusak fungsi yang benar dari seluruh sistem, ada juga masalah baru: <b>sangat sulit untuk membuat setiap kesalahan microservice toleran</b> .  Karena layanan microser menggunakan teknologi yang berbeda (memcache, Redis, dll.), Semua orang perlu memikirkan dan mengimplementasikan segalanya, yang tentu saja mungkin, tetapi membutuhkan sumber daya yang besar. <br><br><h3>  Pengukuran beban ... </h3><br>  Semuanya sangat baik dengan ini. <br><br><h3>  Ringannya layanan ... </h3><br>  Kami tidak hanya memiliki <b>overhead jaringan yang</b> besar (kueri DNS, dll.), Tetapi juga karena banyaknya subkueri, kami mulai <b>mereplikasi data</b> (cache penyimpanan), yang menyebabkan sejumlah besar penyimpanan. <br><br>  Dan inilah hasil dari memenuhi harapan kita: <br><br><img src="https://habrastorage.org/webt/hg/oe/35/hgoe35hkyfy3kfkmhxguoqq5rne.png"><br><br><h3>  Tapi bukan itu saja! </h3><br>  Karena: <br><br><ul><li>  Kemungkinan besar kita membutuhkan bus pesan. </li><li>  Bagaimana cara membuat cadangan yang konsisten pada waktu yang tepat?  Satu-satunya pilihan <i>nyata</i> adalah mematikan lalu lintas untuk ini.  Tetapi bagaimana melakukannya pada produksi? </li><li>  Jika kita berbicara tentang mendukung beberapa daerah, maka mengatur keberlanjutan di masing-masing daerah adalah tugas yang sangat memakan waktu. </li><li>  Ada masalah membuat perubahan terpusat.  Sebagai contoh, jika kita perlu memperbarui versi PHP, maka kita perlu komit ke setiap repositori (dan ada puluhan). </li><li>  Peningkatan kompleksitas operasional begitu saja eksponensial. </li></ul><br><h2>  Apa yang harus dilakukan dengan semua ini? </h2><br>  <b>Mulai dengan aplikasi monolitik</b> .  Pengalaman Fowler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menunjukkan</a> bahwa hampir semua aplikasi microservice yang sukses dimulai dengan monolith, yang menjadi terlalu besar, setelah itu rusak.  Pada saat yang sama, hampir semua sistem yang dibangun sebagai microservice dari awal mengalami masalah serius cepat atau lambat. <br><br>  Pemikiran lain yang berharga adalah agar proyek dengan arsitektur microservice berhasil, Anda harus tahu betul <b>bidang subjek dan cara membuat layanan microser</b> .  Dan cara terbaik untuk mengetahui bidang subjek adalah membuat monolit. <br><br><h2>  Tetapi bagaimana jika kita sudah berada dalam situasi ini? </h2><br>  Langkah pertama untuk menyelesaikan masalah adalah dengan menyetujuinya dan memahami bahwa itu adalah masalah, bahwa kita tidak lagi ingin menderita. <br><br>  Jika dalam kasus monolit yang terlalu banyak (ketika kita kehabisan kesempatan untuk membeli sumber daya untuk itu), kita memotongnya, maka dalam kasus ini kita mendapatkan cerita yang berlawanan: ketika layanan mikro yang berlebihan tidak membantu lagi, tetapi mengganggu - <b>memotong kelebihan dan memperbesar</b> ! <br><br>  Misalnya, untuk gambar kolektif yang dibahas di atas ... <br><br>  Singkirkan microservices yang paling meragukan: <br><br><img src="https://habrastorage.org/webt/tf/-s/su/tf-ssueuj8be3jxrwhqfqwocqjo.png"><br><br>  Gabungkan semua layanan microser yang bertanggung jawab untuk menghasilkan frontend: <br><br><img src="https://habrastorage.org/webt/ii/sw/gs/iiswgsg4bjx69wpgn8vk3_xxp70.png"><br><br>  ... dalam satu microservice, ditulis dalam satu bahasa / kerangka kerja (modern dan normal, seperti yang Anda pikirkan): <br><br><img src="https://habrastorage.org/webt/vy/yk/hi/vyykhitrn3crjfplovw_acdoicu.png"><br><br>  Ini akan memiliki satu ORM (satu DBMS) dan beberapa aplikasi pertama: <br><br><img src="https://habrastorage.org/webt/4x/pe/7s/4xpe7siw54omsbrabwatzggsp1c.png"><br><br>  ... secara umum, lebih banyak yang dapat ditransfer di sana, setelah memperoleh hasil sebagai berikut: <br><br><img src="https://habrastorage.org/webt/gv/cc/mz/gvccmzms2zvyzzg1kfttpyih2bk.png"><br><br>  Selain itu, di Kubernetes kami menjalankan semua ini dalam contoh terpisah, yang berarti bahwa kami masih dapat mengukur beban dan skala secara terpisah. <br><br><h2>  Meringkas </h2><br>  Lihatlah gambar yang lebih luas.  Sangat sering, semua masalah dengan layanan microser ini muncul karena fakta bahwa seseorang mengambil tugas mereka, tetapi ingin "memainkan layanan microser." <br><br>  <b>Dalam kata "microservices" bagian "mikro" tidak perlu</b> .  Mereka "mikro" hanya karena mereka lebih kecil dari monolit besar.  Tetapi jangan menganggap mereka sebagai sesuatu yang kecil. <br><br>  Dan untuk pemikiran terakhir, kembali ke jadwal semula: <br><br><img src="https://habrastorage.org/webt/w8/t5/lg/w8t5lgftdcf1zjri4aekoipk1p0.png"><br><br>  Catatan yang ditulis kepadanya <i>(kanan atas)</i> bermuara pada kenyataan bahwa <b>keterampilan tim yang membuat proyek Anda selalu utama</b> - mereka akan memainkan peran kunci dalam pilihan Anda antara layanan mikro dan monolit.  Jika tim tidak memiliki keterampilan yang cukup, tetapi mulai membuat layanan mikro, ceritanya pasti akan berakibat fatal. <br><br><h2>  Video dan slide </h2><br>  Video dari pidato (~ 50 menit; sayangnya, tidak menyampaikan banyak emosi pengunjung, yang sebagian besar menentukan suasana hati laporan, tetapi sebagaimana adanya): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/g9cgppj0gKQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Penyajian laporan: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  PS </h2><br>  Laporan lain di blog kami: <br><br><ul><li>  â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Monitoring and Kubernetes</a> â€ <i>(Dmitry Stolyarov; 28 Mei 2018 di RootConf)</i> ; </li><li>  â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Praktek CI / CD terbaik dengan Kubernetes dan GitLab</a> â€ <i>(Dmitry Stolyarov; 7 November 2017 di HighLoad ++)</i> ; </li><li>  â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengalaman kami dengan Kubernetes dalam proyek-proyek kecil</a> â€ <i>(Dmitry Stolyarov; 6 Juni 2017 di RootConf)</i> ; </li><li>  â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kami mengumpulkan gambar Docker untuk CI / CD dengan cepat dan nyaman dengan dapp</a> â€ <i>(Dmitry Stolyarov; 8 November 2016 di HighLoad ++)</i> ; </li><li>  â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Praktik Pengiriman Berkelanjutan dengan Docker</a> â€ <i>(Dmitry Stolyarov; 31 Mei 2016 di RootConf)</i> . </li></ul><br>  Anda mungkin juga tertarik dengan publikasi berikut: <br><br><ul><li>  "The <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Death of Microservice Madness pada tahun 2018</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">7 praktik terbaik untuk pengoperasian kontainer menurut Google</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Statistik Stack Baru tentang Kesulitan Implementasi Kubernetes</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424531/">https://habr.com/ru/post/id424531/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424511/index.html">Alat untuk menemukan kelas beranotasi di Jawa</a></li>
<li><a href="../id424513/index.html">Tentang pusat data murah, perlindungan ILV dan DDoS</a></li>
<li><a href="../id424517/index.html">Implementasi minimalisasi fungsi logis oleh metode Quine \ McCluskey dengan set input yang tidak lengkap</a></li>
<li><a href="../id424519/index.html">Bisakah Beethoven mengirim permintaan penghapusan?</a></li>
<li><a href="../id424525/index.html">Kontrol kecepatan bor mini</a></li>
<li><a href="../id424533/index.html">"Setiap orang IT yang menghargai diri sendiri terlibat dalam teknologi di waktu luangnya" - 10 pertanyaan untuk programmer, edisi 6</a></li>
<li><a href="../id424537/index.html">Sberbank meluncurkan operator sendiri SberMobile</a></li>
<li><a href="../id424539/index.html">Java 11: baru dalam String</a></li>
<li><a href="../id424541/index.html">Kisah kegagalan UGJ 2018: cara membuat game yang tidak disukai siapa pun (jangan lakukan itu!)</a></li>
<li><a href="../id424543/index.html">Java 11 / JDK 11: Ketersediaan Umum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>