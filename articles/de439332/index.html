<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¥üèø üìó üë®üèΩ‚Äçüé§ Funktionsweise von PageRank: Implementierung in R √ºber lineare Algebra und die Potenzmethode ü§ö üõ£Ô∏è ü§∂üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habrowsk-B√ºrger! 

 Ich hei√üe Alex Diesmal habe ich in ITAR-TASS vom Arbeitsplatz aus gesendet. 

 In diesem kurzen Text werde ich Ihnen die Met...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionsweise von PageRank: Implementierung in R √ºber lineare Algebra und die Potenzmethode</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439332/">  Hallo Habrowsk-B√ºrger! <br><br>  Ich hei√üe Alex  Diesmal habe ich in ITAR-TASS vom Arbeitsplatz aus gesendet. <br><br>  In diesem kurzen Text werde ich Ihnen die Methode zur Berechnung des PageRank ¬© (im Folgenden als PR bezeichnet) anhand einfacher, verst√§ndlicher Beispiele in der Sprache R vorstellen. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Algorithmus</a> ist ein geistiges Eigentum von Google, wird jedoch aufgrund seiner N√ºtzlichkeit f√ºr Datenanalyseaufgaben viele Aufgaben verwendet Dies kann darauf reduziert werden, nach gro√üen Knoten im Diagramm zu suchen und diese nach Wichtigkeit zu ordnen. <br><br>  Die Erw√§hnung eines gro√üen Unternehmens in einem Beitrag ist keine Werbung. <br><a name="habracut"></a><br>  Da ich kein professioneller Mathematiker bin, verwende und empfehle ich diesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> und dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tutorial</a> als Leitfaden. <br><br><h3>  Intuitives Verst√§ndnis von PR </h3><br>  Es ist nicht schwer zu verstehen, wie das funktioniert.  Es gibt eine Reihe von Elementen, die miteinander verbunden sind.  Hier erfahren Sie, wie genau sie miteinander verbunden sind - dies ist eine umfassende Frage: M√∂glicherweise k√∂nnen durch Links (wie Google), m√∂glicherweise durch Verweise aufeinander (fast dieselben Links) die Wahrscheinlichkeiten von √úberg√§ngen zwischen Elementen (Matrix des Markov-Prozesses) a priori angegeben werden, ohne die physikalische Angabe zu machen Bedeutung der Kommunikation.  Ich m√∂chte diesen Elementen ein bestimmtes Kriterium von Bedeutung zuweisen, das Informationen √ºber die <b>Wahrscheinlichkeit enth√§lt,</b> dass dieses Element von einem abstrakten Teilchen besucht wird, das sich w√§hrend des Diffusionsprozesses durch den Graphen bewegt. <br><br>  √Ñhm, das klingt nicht sehr klar.  Es ist einfacher, sich vorzustellen, wie ein Mann einen Laptop mit einer <s>Mohnblume benutzt</s> , auf den Seiten der Suchergebnisse surft, eine Wasserpfeife raucht, Links von einer Seite zur anderen folgt und immer h√§ufiger auf derselben Seite (oder mehreren Seiten) erscheint. <br><br>  Dies liegt an der Tatsache, dass einige Seiten, die er besucht, so interessante Informationen in der Originalquelle enthalten, dass andere Seiten gezwungen sind, diese mit einem Hinweis auf den Link erneut zu drucken. <br><br>  Ein solcher Typ in Google wurde Random Surfer genannt.  Er ist ein Teilchen im Diffusionsprozess: eine diskrete √Ñnderung der Position auf dem Graphen im Laufe der Zeit.  Und die Wahrscheinlichkeit, mit der er die Seite mit einer Diffusionszeit besucht, die gegen unendlich tendiert, ist PR. <br><br><h3>  Einfache Implementierung der PR-Berechnung </h3><br>  Lassen Sie uns zustimmen - wir arbeiten mit 10 Elementen in einem so kleinen, gem√ºtlichen kleinen Diagramm. <br><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># clear environment rm(list = ls()); gc() ## load libs library(data.table) library(magrittr) library(markovchain) ## dummy data number_nodes &lt;- 10 node_names &lt;- letters[seq_len(number_nodes)] set.seed(1) nodes &lt;- sapply( seq_len(number_nodes), function(x) { paste( c( node_names[-x] , sample(node_names[-x], sample(1:5, 1), replace = T) ) , collapse = ' ' ) } ) names(nodes) &lt;- node_names print( paste(nodes, collapse = '; ') ) ## make long dt dt &lt;- data.table( citing_node = node_names , cited_node = nodes ) %&gt;% .[, .(cited_node = unlist(strsplit(cited_node, ' '))), by = citing_node] %&gt;% dcast( . , cited_node ~ citing_node , fun.aggregate = length ) dt apply(dt[,-1,with=F], 2, sum) ## affinity matrix A &lt;- as.matrix(dt[, 2:dim(dt)[2]]) A &lt;- sweep(A, 2, colSums(A), `/`) A[is.nan(A)] &lt;- 0 rowSums(A) colSums(A) mark &lt;- new("markovchain", transitionMatrix = t(A), states = node_names, name = "mark") plot(mark)</span></span></code> </pre> <br>  Jedes der 10 Elemente (Knoten) enth√§lt 10 bis 14 Verweise auf andere Knoten in zuf√§lliger Reihenfolge, ausgenommen sich selbst.  Im Moment entscheiden wir nur, dass die genannten Daten ein Weblink sind. <br><br>  Es ist klar, dass es vorkommen kann, dass ein Element h√§ufiger erw√§hnt wird als andere.  √úberpr√ºfen Sie dies heraus. <br><blockquote>  Ich empfehle √ºbrigens, das Paket data.table f√ºr Experimente zu verwenden.  In Verbindung mit den Prinzipien von tidyverse l√§uft alles effizient und schnell ab. </blockquote><img src="https://habrastorage.org/webt/jl/qc/jm/jlqcjm-czf_eyevyiz1uxlssav0.png"><br><br>  So sieht unsere Linkmatrix aus (im Englischen meistens Adjazenzmatrix genannt). <br><br>  Die Summe in jeder Spalte ist gr√∂√üer als Null, was bedeutet, dass von jedem Element eine Verbindung mit einem anderen Element besteht (dies ist wichtig f√ºr die weitere Analyse). <br><blockquote>  &gt; anwenden (dt [, - 1, mit = F], 2, Summe) <br>  abcdefghij <br>  11 14 10 10 11 13 11 11 11 12 <br></blockquote><br>  Basierend auf dieser Tabelle k√∂nnen wir die sogenannte Affinit√§tsmatrix oder unserer Meinung nach die Proximity-Matrix (und sie wird auch als √úbergangsmatrix bezeichnet) erstellen, die Mathematiker die stochastische Matrix (spaltenstochastische Matrix) nennen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hauptquelle</a> <br><br>  Weisen Sie es einer Variablen mit dem Namen A zu. <br><br><img src="https://habrastorage.org/webt/xv/x-/f0/xvx-f0z6eow64ngtc4tkofqolj8.png"><br><br>  Das Wichtigste ist jetzt, dass die Summe in allen Spalten gleich eins ist. <br><blockquote>  &gt; Spalten (A) <br>  abcdefghij <br>  1 1 1 1 1 1 1 1 1 1 <br></blockquote><br>  Hier ist es - eine Matrix von √úberg√§ngen, es ist Markov, es sind √Ñhnlichkeiten.  Abbildungen sind die Wahrscheinlichkeiten von √úberg√§ngen von einem Element in einer Spalte zu einem Element in einer Zeile. <br><br>  Dies sind nat√ºrlich keine wirklichen "√Ñhnlichkeiten".  Die Gegenwart w√§re zum Beispiel, wenn wir den Kosinus des Winkels zwischen der Pr√§sentation von Dokumenten berechnen w√ºrden.  Es ist jedoch wichtig, dass die √úbergangsmatrix auf (Pseudo-) Wahrscheinlichkeiten reduziert wird, damit die Summe √ºber jede Spalte gleich eins ist. <br><br>  Schauen wir uns das Markov-√úbergangsdiagramm (unser A) an: <br><br><img src="https://habrastorage.org/webt/s9/yv/br/s9yvbr-kaqvsyfqs0wokofkojpk.png"><br><br>  Alles ist ungef√§hr gleichm√§√üig verwirrt).  Dies liegt daran, dass wir gleichwahrscheinliche √úberg√§nge angegeben haben. <br><br>  <b>Und jetzt ist die Zeit f√ºr Magie!</b> <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">## calculate pagerank ei &lt;- eigen(A) as.numeric(ei$values[1]) pr &lt;- as.numeric(ei$vectors[,1] / sum(ei$vectors[,1])) sum(pr) names(pr) &lt;- node_names print(round(pr, 2))</span></span></code> </pre><br>  F√ºr eine stochastische Matrix A sollte der erste Eigenwert gleich Eins sein, und der entsprechende Eigenvektor ist der PageRank-Vektor. <br><blockquote>  &gt; drucken (rund (pr, 2)) <br>  abcdefghij <br>  0,09 0,11 0,09 0,10 0,10 0,11 0,10 0,11 0,08 0,11 <br></blockquote><br>  Dies ist der Vektor der PR-Werte - dies ist der normalisierte Eigenvektor der √úbergangsmatrix A, der dem Eigenwert dieser Matrix entspricht, der gleich Eins ist - der dominante Eigenvektor. <br><br>  Jetzt k√∂nnen Sie die Elemente ordnen.  Aufgrund der Besonderheiten des Experiments haben sie jedoch ein sehr √§hnliches Gewicht. <br><br><h3>  Probleme und ihre L√∂sungen mit der Power-Methode </h3><br>  Die √úbergangsmatrix A erf√ºllt m√∂glicherweise nicht die Stochastizit√§tsbedingungen. <br><br>  <b>Erstens kann es Elemente geben, die sich nirgendwo beziehen, dh ohne Feedback (sie k√∂nnen sich selbst auf sie beziehen).</b>  <b>Bei gro√üen realen Graphen ist dies ein wahrscheinliches Problem.</b>  <b>Dies bedeutet, dass eine der Spalten der Matrix nur Nullen enth√§lt.</b>  <b>In diesem Fall funktioniert die L√∂sung durch Eigenvektoren nicht.</b> <br><br>  Google hat dieses Problem gel√∂st, indem eine Spalte mit einer gleichm√§√üigen Wahrscheinlichkeitsverteilung p = 1 / N ausgef√ºllt wurde.  Wobei N die Anzahl aller Elemente ist. <br><br><pre> <code class="python hljs">dim<span class="hljs-number"><span class="hljs-number">.1</span></span> &lt;- dim(A)[<span class="hljs-number"><span class="hljs-number">1</span></span>] A &lt;- <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.data.table(A) nul_cols &lt;- apply(A, <span class="hljs-number"><span class="hljs-number">2</span></span>, function(x) sum(x) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( sum(nul_cols) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { A[ , (colnames(A)[nul_cols]) := lapply(.SD, function(x) <span class="hljs-number"><span class="hljs-number">1</span></span> / dim<span class="hljs-number"><span class="hljs-number">.1</span></span>) , .SDcols = colnames(A)[nul_cols] ] } A &lt;- <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.matrix(A)</code> </pre><br>  <b>Zweitens kann das Diagramm Elemente mit gegenseitiger R√ºckkopplung enthalten, jedoch nicht die verbleibenden Elemente des Diagramms.</b>  <b>Dies ist auch ein un√ºberwindbares Problem f√ºr die lineare Algebra aufgrund von Verst√∂√üen gegen Annahmen.</b> <br><br>  Es wird gel√∂st, indem eine Konstante eingef√ºhrt wird, die als D√§mpfungsfaktor bezeichnet wird und die a priori Wahrscheinlichkeit eines √úbergangs von einem Element zu einem anderen angibt, selbst wenn keine physischen Verbindungen bestehen.  Mit anderen Worten ist eine Diffusion in jedem Zustand m√∂glich. <br><br><pre> <code class="python hljs">d = <span class="hljs-number"><span class="hljs-number">0.15</span></span> <span class="hljs-comment"><span class="hljs-comment">#damping factor (to ensure algorithm convergence) M &lt;- (1 - d) * A + d * (1 / dim.1 * matrix(1, nrow = dim.1, ncol = dim.1)) # google matrix</span></span></code> </pre><br>  Wenn wir diese Transformationen auf unsere Matrix anwenden, kann sie wieder durch Eigenvektoren gel√∂st werden! <br><br>  <b>Drittens ist die abgedroschene Matrix m√∂glicherweise nicht quadratisch, aber dies ist kritisch!</b>  <b>Ich werde auf diesen Moment nicht n√§her eingehen, weil ich glaube, dass Sie selbst herausfinden werden, wie Sie ihn beheben k√∂nnen.</b> <br><br>  Es gibt jedoch eine schnellere und genauere Methode, die auch im Speicher wirtschaftlicher ist (was f√ºr gro√üe Diagramme relevant sein kann): die Leistungsmethode. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">## pagerank function (tested on example from tutorial) rm(pagerank_func) pagerank_func &lt;- function( A #transition matrix , eps = 0.00001 #sufficiently small error , d = 0.15 #damping factor (to ensure algorithm convergence) ) { dim.1 &lt;- dim(A)[1] A &lt;- as.data.table(A) nul_cols &lt;- apply(A, 2, function(x) sum(x) == 0) if( sum(nul_cols) &gt; 0 ) { A[ , (colnames(A)[nul_cols]) := lapply(.SD, function(x) 1 / dim.1) , .SDcols = colnames(A)[nul_cols] ] } A &lt;- as.matrix(A) M &lt;- (1 - d) * A + d * (1 / dim.1 * matrix(1, nrow = dim.1, ncol = dim.1)) # google matrix rank = as.numeric(rep(1 / dim.1, dim.1)) ## iterate until convergence while( sum( (rank - M %*% rank) ^ 2 ) &gt; eps ) { rank &lt;- M %*% rank } return(rank) } pr2 &lt;- pagerank_func(A) pr2=as.vector(pr2) names(pr2)=node_names</span></span></code> </pre><br>  Voila! <br><blockquote>  &gt; drucken (rund (pr, 2)) <br>  abcdefghij <br>  0,09 0,11 0,09 0,10 0,10 0,11 0,10 0,11 0,08 0,11 <br>  &gt; drucken (rund (pr2, 2)) <br>  abcdefghij <br>  0,09 0,11 0,09 0,10 0,10 0,11 0,10 0,11 0,08 0,11 <br></blockquote><br>  Dazu werde ich das Tutorial beenden.  Ich hoffe, Sie finden es n√ºtzlich. <br><br>  Ich habe vergessen zu sagen, dass Sie zum Erstellen einer Matrix von √úberg√§ngen (Wahrscheinlichkeiten) die √Ñhnlichkeit von Texten, die Anzahl der Referenzen, die Tatsache eines Links und andere Metriken verwenden k√∂nnen, die zu Pseudowahrscheinlichkeiten f√ºhren oder Wahrscheinlichkeiten sind.  Ein ziemlich interessantes Beispiel ist die Rangfolge der S√§tze im Text in der √Ñhnlichkeitsmatrix der Wortbeutel tf-idf, um den Satz hervorzuheben, der den gesamten Text zusammenfasst.  Es kann andere kreative Verwendungen von PR geben. <br><br>  Ich empfehle, alleine zu versuchen, mit der √úbergangsmatrix zu spielen und sicherzustellen, dass Sie coole PR-Werte erhalten, die auch recht einfach zu interpretieren sind. <br><br>  Wenn Sie Ungenauigkeiten oder Fehler bei mir sehen - geben Sie dies in den Kommentaren oder in der Nachricht an, und ich werde alles korrigieren. <br><br>  Der gesamte Code wird hier kompiliert: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># clear environment rm(list = ls()); gc() ## load libs library(data.table) library(magrittr) library(markovchain) ## dummy data number_nodes &lt;- 10 node_names &lt;- letters[seq_len(number_nodes)] set.seed(1) nodes &lt;- sapply( seq_len(number_nodes), function(x) { paste( c( node_names[-x] , sample(node_names[-x], sample(1:5, 1), replace = T) ) , collapse = ' ' ) } ) names(nodes) &lt;- node_names print( paste(nodes, collapse = '; ') ) ## make long dt dt &lt;- data.table( citing_node = node_names , cited_node = nodes ) %&gt;% .[, .(cited_node = unlist(strsplit(cited_node, ' '))), by = citing_node] %&gt;% dcast( . , cited_node ~ citing_node , fun.aggregate = length ) dt apply(dt[,-1,with=F], 2, sum) ## affinity matrix A &lt;- as.matrix(dt[, 2:dim(dt)[2]]) A &lt;- sweep(A, 2, colSums(A), `/`) A[is.nan(A)] &lt;- 0 rowSums(A) colSums(A) mark &lt;- new("markovchain", transitionMatrix = t(A), states = node_names, name = "mark") plot(mark) ## calculate pagerank ei &lt;- eigen(A) as.numeric(ei$values[1]) pr &lt;- as.numeric(ei$vectors[,1] / sum(ei$vectors[,1])) sum(pr) names(pr) &lt;- node_names print(round(pr, 2)) ## pagerank function (tested on example from tutorial) rm(pagerank_func) pagerank_func &lt;- function( A #transition matrix , eps = 0.00001 #sufficiently small error , d = 0.15 #damping factor (to ensure algorithm convergence) ) { dim.1 &lt;- dim(A)[1] A &lt;- as.data.table(A) nul_cols &lt;- apply(A, 2, function(x) sum(x) == 0) if( sum(nul_cols) &gt; 0 ) { A[ , (colnames(A)[nul_cols]) := lapply(.SD, function(x) 1 / dim.1) , .SDcols = colnames(A)[nul_cols] ] } A &lt;- as.matrix(A) M &lt;- (1 - d) * A + d * (1 / dim.1 * matrix(1, nrow = dim.1, ncol = dim.1)) # google matrix rank = as.numeric(rep(1 / dim.1, dim.1)) ## iterate until convergence while( sum( (rank - M %*% rank) ^ 2 ) &gt; eps ) { rank &lt;- M %*% rank } return(rank) } pr2 &lt;- pagerank_func(A) pr2=as.vector(pr2) names(pr2)=node_names print(round(pr, 2)) print(round(pr2, 2))</span></span></code> </pre><br></div></div><br>  PS: Diese ganze Idee l√§sst sich auch leicht in anderen Sprachen umsetzen, zumindest in Python, ich habe alles ohne Schwierigkeiten gemacht. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439332/">https://habr.com/ru/post/de439332/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439320/index.html">So diversifizieren Sie den Programmierunterricht f√ºr Kinder unterschiedlichen Alters</a></li>
<li><a href="../de439324/index.html">Verwenden eines Bin√§rbaums in Swift mit Enum am Beispiel von OCR</a></li>
<li><a href="../de439326/index.html">Elektrischer Pickup Ford F-150 EV - im Prototyp und unterwegs getestet</a></li>
<li><a href="../de439328/index.html">Ok Google! Bist du gut oder b√∂se?</a></li>
<li><a href="../de439330/index.html">Erkennung von Zahlen. Wie wir eine Genauigkeit von 97% f√ºr ukrainische Zahlen erhalten haben. Teil 2</a></li>
<li><a href="../de439334/index.html">Etwa 2 Milliarden Rubel wurden f√ºr die Umsetzung des Gesetzes √ºber nachhaltige Runen bereitgestellt</a></li>
<li><a href="../de439336/index.html">Wir suchen nach einer Nadel in einem Stapel, ohne bekannte Algorithmen zu verwenden</a></li>
<li><a href="../de439338/index.html">Vergessen Sie die Privatsph√§re: Sie haben immer noch schreckliche Ziele</a></li>
<li><a href="../de439340/index.html">GDPR Backup - Wie das neue Tool hilft</a></li>
<li><a href="../de439342/index.html">DIYorDIE Winter Meetup 17. Februar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>