<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏿 📗 👨🏽‍🎤 Funktionsweise von PageRank: Implementierung in R über lineare Algebra und die Potenzmethode 🤚 🛣️ 🤶🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habrowsk-Bürger! 

 Ich heiße Alex Diesmal habe ich in ITAR-TASS vom Arbeitsplatz aus gesendet. 

 In diesem kurzen Text werde ich Ihnen die Met...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionsweise von PageRank: Implementierung in R über lineare Algebra und die Potenzmethode</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439332/">  Hallo Habrowsk-Bürger! <br><br>  Ich heiße Alex  Diesmal habe ich in ITAR-TASS vom Arbeitsplatz aus gesendet. <br><br>  In diesem kurzen Text werde ich Ihnen die Methode zur Berechnung des PageRank © (im Folgenden als PR bezeichnet) anhand einfacher, verständlicher Beispiele in der Sprache R vorstellen. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Algorithmus</a> ist ein geistiges Eigentum von Google, wird jedoch aufgrund seiner Nützlichkeit für Datenanalyseaufgaben viele Aufgaben verwendet Dies kann darauf reduziert werden, nach großen Knoten im Diagramm zu suchen und diese nach Wichtigkeit zu ordnen. <br><br>  Die Erwähnung eines großen Unternehmens in einem Beitrag ist keine Werbung. <br><a name="habracut"></a><br>  Da ich kein professioneller Mathematiker bin, verwende und empfehle ich diesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> und dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tutorial</a> als Leitfaden. <br><br><h3>  Intuitives Verständnis von PR </h3><br>  Es ist nicht schwer zu verstehen, wie das funktioniert.  Es gibt eine Reihe von Elementen, die miteinander verbunden sind.  Hier erfahren Sie, wie genau sie miteinander verbunden sind - dies ist eine umfassende Frage: Möglicherweise können durch Links (wie Google), möglicherweise durch Verweise aufeinander (fast dieselben Links) die Wahrscheinlichkeiten von Übergängen zwischen Elementen (Matrix des Markov-Prozesses) a priori angegeben werden, ohne die physikalische Angabe zu machen Bedeutung der Kommunikation.  Ich möchte diesen Elementen ein bestimmtes Kriterium von Bedeutung zuweisen, das Informationen über die <b>Wahrscheinlichkeit enthält,</b> dass dieses Element von einem abstrakten Teilchen besucht wird, das sich während des Diffusionsprozesses durch den Graphen bewegt. <br><br>  Ähm, das klingt nicht sehr klar.  Es ist einfacher, sich vorzustellen, wie ein Mann einen Laptop mit einer <s>Mohnblume benutzt</s> , auf den Seiten der Suchergebnisse surft, eine Wasserpfeife raucht, Links von einer Seite zur anderen folgt und immer häufiger auf derselben Seite (oder mehreren Seiten) erscheint. <br><br>  Dies liegt an der Tatsache, dass einige Seiten, die er besucht, so interessante Informationen in der Originalquelle enthalten, dass andere Seiten gezwungen sind, diese mit einem Hinweis auf den Link erneut zu drucken. <br><br>  Ein solcher Typ in Google wurde Random Surfer genannt.  Er ist ein Teilchen im Diffusionsprozess: eine diskrete Änderung der Position auf dem Graphen im Laufe der Zeit.  Und die Wahrscheinlichkeit, mit der er die Seite mit einer Diffusionszeit besucht, die gegen unendlich tendiert, ist PR. <br><br><h3>  Einfache Implementierung der PR-Berechnung </h3><br>  Lassen Sie uns zustimmen - wir arbeiten mit 10 Elementen in einem so kleinen, gemütlichen kleinen Diagramm. <br><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># clear environment rm(list = ls()); gc() ## load libs library(data.table) library(magrittr) library(markovchain) ## dummy data number_nodes &lt;- 10 node_names &lt;- letters[seq_len(number_nodes)] set.seed(1) nodes &lt;- sapply( seq_len(number_nodes), function(x) { paste( c( node_names[-x] , sample(node_names[-x], sample(1:5, 1), replace = T) ) , collapse = ' ' ) } ) names(nodes) &lt;- node_names print( paste(nodes, collapse = '; ') ) ## make long dt dt &lt;- data.table( citing_node = node_names , cited_node = nodes ) %&gt;% .[, .(cited_node = unlist(strsplit(cited_node, ' '))), by = citing_node] %&gt;% dcast( . , cited_node ~ citing_node , fun.aggregate = length ) dt apply(dt[,-1,with=F], 2, sum) ## affinity matrix A &lt;- as.matrix(dt[, 2:dim(dt)[2]]) A &lt;- sweep(A, 2, colSums(A), `/`) A[is.nan(A)] &lt;- 0 rowSums(A) colSums(A) mark &lt;- new("markovchain", transitionMatrix = t(A), states = node_names, name = "mark") plot(mark)</span></span></code> </pre> <br>  Jedes der 10 Elemente (Knoten) enthält 10 bis 14 Verweise auf andere Knoten in zufälliger Reihenfolge, ausgenommen sich selbst.  Im Moment entscheiden wir nur, dass die genannten Daten ein Weblink sind. <br><br>  Es ist klar, dass es vorkommen kann, dass ein Element häufiger erwähnt wird als andere.  Überprüfen Sie dies heraus. <br><blockquote>  Ich empfehle übrigens, das Paket data.table für Experimente zu verwenden.  In Verbindung mit den Prinzipien von tidyverse läuft alles effizient und schnell ab. </blockquote><img src="https://habrastorage.org/webt/jl/qc/jm/jlqcjm-czf_eyevyiz1uxlssav0.png"><br><br>  So sieht unsere Linkmatrix aus (im Englischen meistens Adjazenzmatrix genannt). <br><br>  Die Summe in jeder Spalte ist größer als Null, was bedeutet, dass von jedem Element eine Verbindung mit einem anderen Element besteht (dies ist wichtig für die weitere Analyse). <br><blockquote>  &gt; anwenden (dt [, - 1, mit = F], 2, Summe) <br>  abcdefghij <br>  11 14 10 10 11 13 11 11 11 12 <br></blockquote><br>  Basierend auf dieser Tabelle können wir die sogenannte Affinitätsmatrix oder unserer Meinung nach die Proximity-Matrix (und sie wird auch als Übergangsmatrix bezeichnet) erstellen, die Mathematiker die stochastische Matrix (spaltenstochastische Matrix) nennen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hauptquelle</a> <br><br>  Weisen Sie es einer Variablen mit dem Namen A zu. <br><br><img src="https://habrastorage.org/webt/xv/x-/f0/xvx-f0z6eow64ngtc4tkofqolj8.png"><br><br>  Das Wichtigste ist jetzt, dass die Summe in allen Spalten gleich eins ist. <br><blockquote>  &gt; Spalten (A) <br>  abcdefghij <br>  1 1 1 1 1 1 1 1 1 1 <br></blockquote><br>  Hier ist es - eine Matrix von Übergängen, es ist Markov, es sind Ähnlichkeiten.  Abbildungen sind die Wahrscheinlichkeiten von Übergängen von einem Element in einer Spalte zu einem Element in einer Zeile. <br><br>  Dies sind natürlich keine wirklichen "Ähnlichkeiten".  Die Gegenwart wäre zum Beispiel, wenn wir den Kosinus des Winkels zwischen der Präsentation von Dokumenten berechnen würden.  Es ist jedoch wichtig, dass die Übergangsmatrix auf (Pseudo-) Wahrscheinlichkeiten reduziert wird, damit die Summe über jede Spalte gleich eins ist. <br><br>  Schauen wir uns das Markov-Übergangsdiagramm (unser A) an: <br><br><img src="https://habrastorage.org/webt/s9/yv/br/s9yvbr-kaqvsyfqs0wokofkojpk.png"><br><br>  Alles ist ungefähr gleichmäßig verwirrt).  Dies liegt daran, dass wir gleichwahrscheinliche Übergänge angegeben haben. <br><br>  <b>Und jetzt ist die Zeit für Magie!</b> <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">## calculate pagerank ei &lt;- eigen(A) as.numeric(ei$values[1]) pr &lt;- as.numeric(ei$vectors[,1] / sum(ei$vectors[,1])) sum(pr) names(pr) &lt;- node_names print(round(pr, 2))</span></span></code> </pre><br>  Für eine stochastische Matrix A sollte der erste Eigenwert gleich Eins sein, und der entsprechende Eigenvektor ist der PageRank-Vektor. <br><blockquote>  &gt; drucken (rund (pr, 2)) <br>  abcdefghij <br>  0,09 0,11 0,09 0,10 0,10 0,11 0,10 0,11 0,08 0,11 <br></blockquote><br>  Dies ist der Vektor der PR-Werte - dies ist der normalisierte Eigenvektor der Übergangsmatrix A, der dem Eigenwert dieser Matrix entspricht, der gleich Eins ist - der dominante Eigenvektor. <br><br>  Jetzt können Sie die Elemente ordnen.  Aufgrund der Besonderheiten des Experiments haben sie jedoch ein sehr ähnliches Gewicht. <br><br><h3>  Probleme und ihre Lösungen mit der Power-Methode </h3><br>  Die Übergangsmatrix A erfüllt möglicherweise nicht die Stochastizitätsbedingungen. <br><br>  <b>Erstens kann es Elemente geben, die sich nirgendwo beziehen, dh ohne Feedback (sie können sich selbst auf sie beziehen).</b>  <b>Bei großen realen Graphen ist dies ein wahrscheinliches Problem.</b>  <b>Dies bedeutet, dass eine der Spalten der Matrix nur Nullen enthält.</b>  <b>In diesem Fall funktioniert die Lösung durch Eigenvektoren nicht.</b> <br><br>  Google hat dieses Problem gelöst, indem eine Spalte mit einer gleichmäßigen Wahrscheinlichkeitsverteilung p = 1 / N ausgefüllt wurde.  Wobei N die Anzahl aller Elemente ist. <br><br><pre> <code class="python hljs">dim<span class="hljs-number"><span class="hljs-number">.1</span></span> &lt;- dim(A)[<span class="hljs-number"><span class="hljs-number">1</span></span>] A &lt;- <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.data.table(A) nul_cols &lt;- apply(A, <span class="hljs-number"><span class="hljs-number">2</span></span>, function(x) sum(x) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( sum(nul_cols) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { A[ , (colnames(A)[nul_cols]) := lapply(.SD, function(x) <span class="hljs-number"><span class="hljs-number">1</span></span> / dim<span class="hljs-number"><span class="hljs-number">.1</span></span>) , .SDcols = colnames(A)[nul_cols] ] } A &lt;- <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.matrix(A)</code> </pre><br>  <b>Zweitens kann das Diagramm Elemente mit gegenseitiger Rückkopplung enthalten, jedoch nicht die verbleibenden Elemente des Diagramms.</b>  <b>Dies ist auch ein unüberwindbares Problem für die lineare Algebra aufgrund von Verstößen gegen Annahmen.</b> <br><br>  Es wird gelöst, indem eine Konstante eingeführt wird, die als Dämpfungsfaktor bezeichnet wird und die a priori Wahrscheinlichkeit eines Übergangs von einem Element zu einem anderen angibt, selbst wenn keine physischen Verbindungen bestehen.  Mit anderen Worten ist eine Diffusion in jedem Zustand möglich. <br><br><pre> <code class="python hljs">d = <span class="hljs-number"><span class="hljs-number">0.15</span></span> <span class="hljs-comment"><span class="hljs-comment">#damping factor (to ensure algorithm convergence) M &lt;- (1 - d) * A + d * (1 / dim.1 * matrix(1, nrow = dim.1, ncol = dim.1)) # google matrix</span></span></code> </pre><br>  Wenn wir diese Transformationen auf unsere Matrix anwenden, kann sie wieder durch Eigenvektoren gelöst werden! <br><br>  <b>Drittens ist die abgedroschene Matrix möglicherweise nicht quadratisch, aber dies ist kritisch!</b>  <b>Ich werde auf diesen Moment nicht näher eingehen, weil ich glaube, dass Sie selbst herausfinden werden, wie Sie ihn beheben können.</b> <br><br>  Es gibt jedoch eine schnellere und genauere Methode, die auch im Speicher wirtschaftlicher ist (was für große Diagramme relevant sein kann): die Leistungsmethode. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">## pagerank function (tested on example from tutorial) rm(pagerank_func) pagerank_func &lt;- function( A #transition matrix , eps = 0.00001 #sufficiently small error , d = 0.15 #damping factor (to ensure algorithm convergence) ) { dim.1 &lt;- dim(A)[1] A &lt;- as.data.table(A) nul_cols &lt;- apply(A, 2, function(x) sum(x) == 0) if( sum(nul_cols) &gt; 0 ) { A[ , (colnames(A)[nul_cols]) := lapply(.SD, function(x) 1 / dim.1) , .SDcols = colnames(A)[nul_cols] ] } A &lt;- as.matrix(A) M &lt;- (1 - d) * A + d * (1 / dim.1 * matrix(1, nrow = dim.1, ncol = dim.1)) # google matrix rank = as.numeric(rep(1 / dim.1, dim.1)) ## iterate until convergence while( sum( (rank - M %*% rank) ^ 2 ) &gt; eps ) { rank &lt;- M %*% rank } return(rank) } pr2 &lt;- pagerank_func(A) pr2=as.vector(pr2) names(pr2)=node_names</span></span></code> </pre><br>  Voila! <br><blockquote>  &gt; drucken (rund (pr, 2)) <br>  abcdefghij <br>  0,09 0,11 0,09 0,10 0,10 0,11 0,10 0,11 0,08 0,11 <br>  &gt; drucken (rund (pr2, 2)) <br>  abcdefghij <br>  0,09 0,11 0,09 0,10 0,10 0,11 0,10 0,11 0,08 0,11 <br></blockquote><br>  Dazu werde ich das Tutorial beenden.  Ich hoffe, Sie finden es nützlich. <br><br>  Ich habe vergessen zu sagen, dass Sie zum Erstellen einer Matrix von Übergängen (Wahrscheinlichkeiten) die Ähnlichkeit von Texten, die Anzahl der Referenzen, die Tatsache eines Links und andere Metriken verwenden können, die zu Pseudowahrscheinlichkeiten führen oder Wahrscheinlichkeiten sind.  Ein ziemlich interessantes Beispiel ist die Rangfolge der Sätze im Text in der Ähnlichkeitsmatrix der Wortbeutel tf-idf, um den Satz hervorzuheben, der den gesamten Text zusammenfasst.  Es kann andere kreative Verwendungen von PR geben. <br><br>  Ich empfehle, alleine zu versuchen, mit der Übergangsmatrix zu spielen und sicherzustellen, dass Sie coole PR-Werte erhalten, die auch recht einfach zu interpretieren sind. <br><br>  Wenn Sie Ungenauigkeiten oder Fehler bei mir sehen - geben Sie dies in den Kommentaren oder in der Nachricht an, und ich werde alles korrigieren. <br><br>  Der gesamte Code wird hier kompiliert: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># clear environment rm(list = ls()); gc() ## load libs library(data.table) library(magrittr) library(markovchain) ## dummy data number_nodes &lt;- 10 node_names &lt;- letters[seq_len(number_nodes)] set.seed(1) nodes &lt;- sapply( seq_len(number_nodes), function(x) { paste( c( node_names[-x] , sample(node_names[-x], sample(1:5, 1), replace = T) ) , collapse = ' ' ) } ) names(nodes) &lt;- node_names print( paste(nodes, collapse = '; ') ) ## make long dt dt &lt;- data.table( citing_node = node_names , cited_node = nodes ) %&gt;% .[, .(cited_node = unlist(strsplit(cited_node, ' '))), by = citing_node] %&gt;% dcast( . , cited_node ~ citing_node , fun.aggregate = length ) dt apply(dt[,-1,with=F], 2, sum) ## affinity matrix A &lt;- as.matrix(dt[, 2:dim(dt)[2]]) A &lt;- sweep(A, 2, colSums(A), `/`) A[is.nan(A)] &lt;- 0 rowSums(A) colSums(A) mark &lt;- new("markovchain", transitionMatrix = t(A), states = node_names, name = "mark") plot(mark) ## calculate pagerank ei &lt;- eigen(A) as.numeric(ei$values[1]) pr &lt;- as.numeric(ei$vectors[,1] / sum(ei$vectors[,1])) sum(pr) names(pr) &lt;- node_names print(round(pr, 2)) ## pagerank function (tested on example from tutorial) rm(pagerank_func) pagerank_func &lt;- function( A #transition matrix , eps = 0.00001 #sufficiently small error , d = 0.15 #damping factor (to ensure algorithm convergence) ) { dim.1 &lt;- dim(A)[1] A &lt;- as.data.table(A) nul_cols &lt;- apply(A, 2, function(x) sum(x) == 0) if( sum(nul_cols) &gt; 0 ) { A[ , (colnames(A)[nul_cols]) := lapply(.SD, function(x) 1 / dim.1) , .SDcols = colnames(A)[nul_cols] ] } A &lt;- as.matrix(A) M &lt;- (1 - d) * A + d * (1 / dim.1 * matrix(1, nrow = dim.1, ncol = dim.1)) # google matrix rank = as.numeric(rep(1 / dim.1, dim.1)) ## iterate until convergence while( sum( (rank - M %*% rank) ^ 2 ) &gt; eps ) { rank &lt;- M %*% rank } return(rank) } pr2 &lt;- pagerank_func(A) pr2=as.vector(pr2) names(pr2)=node_names print(round(pr, 2)) print(round(pr2, 2))</span></span></code> </pre><br></div></div><br>  PS: Diese ganze Idee lässt sich auch leicht in anderen Sprachen umsetzen, zumindest in Python, ich habe alles ohne Schwierigkeiten gemacht. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439332/">https://habr.com/ru/post/de439332/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439320/index.html">So diversifizieren Sie den Programmierunterricht für Kinder unterschiedlichen Alters</a></li>
<li><a href="../de439324/index.html">Verwenden eines Binärbaums in Swift mit Enum am Beispiel von OCR</a></li>
<li><a href="../de439326/index.html">Elektrischer Pickup Ford F-150 EV - im Prototyp und unterwegs getestet</a></li>
<li><a href="../de439328/index.html">Ok Google! Bist du gut oder böse?</a></li>
<li><a href="../de439330/index.html">Erkennung von Zahlen. Wie wir eine Genauigkeit von 97% für ukrainische Zahlen erhalten haben. Teil 2</a></li>
<li><a href="../de439334/index.html">Etwa 2 Milliarden Rubel wurden für die Umsetzung des Gesetzes über nachhaltige Runen bereitgestellt</a></li>
<li><a href="../de439336/index.html">Wir suchen nach einer Nadel in einem Stapel, ohne bekannte Algorithmen zu verwenden</a></li>
<li><a href="../de439338/index.html">Vergessen Sie die Privatsphäre: Sie haben immer noch schreckliche Ziele</a></li>
<li><a href="../de439340/index.html">GDPR Backup - Wie das neue Tool hilft</a></li>
<li><a href="../de439342/index.html">DIYorDIE Winter Meetup 17. Februar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>