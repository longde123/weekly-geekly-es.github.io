<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏬 👨🏼‍🏭 🚴🏻 Fantasien zum Thema Metaklassen in C # 👄 👶🏽 ✌🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Programmierer wie ich, die mit umfassender Erfahrung in Delphi zu C # gekommen sind, haben oft nicht genug von dem, was in Delphi-Klassenreferenzen un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fantasien zum Thema Metaklassen in C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464141/"> Programmierer wie ich, die mit umfassender Erfahrung in Delphi zu C # gekommen sind, haben oft nicht genug von dem, was in Delphi-Klassenreferenzen und in theoretischen Arbeiten häufig als Metaklassen bezeichnet wird.  Mehrmals in verschiedenen Foren stieß ich auf eine Diskussion, die in der gleichen Richtung stattfand.  Es beginnt mit einer Frage eines ehemaligen Delfisten, wie man eine Metaklasse in C # erstellt.  Scharfschützen verstehen das Problem einfach nicht und versuchen zu klären, um welche Art von Tier es sich handelt - eine Metaklasse, Delphisten, wie sie erklären können, aber die Erklärungen sind kurz und unvollständig, und infolgedessen sind die Schärfer völlig ratlos, warum all dies notwendig ist.  Schließlich kann das Gleiche mit Hilfe von Reflexions- und Klassenfabriken getan werden. <br><br>  In diesem Artikel werde ich versuchen, Ihnen zu sagen, was Metaklassen für diejenigen sind, die ihnen noch nie begegnet sind.  Lassen Sie außerdem jeden selbst entscheiden, ob es gut wäre, so etwas in der Sprache zu haben, oder ob Reflexion ausreicht.  Ich schreibe hier nur Fantasien darüber, wie es hätte sein können, wenn es in C # wirklich Metaklassen gegeben hätte.  Alle Beispiele in diesem Artikel sind in dieser hypothetischen Version von C # geschrieben, die derzeit von keinem einzigen Compiler kompiliert werden kann. <br><a name="habracut"></a><br><h2>  Was ist eine Metaklasse? </h2><br>  Was ist eine Metaklasse?  Dies ist ein spezieller Typ, der zur Beschreibung anderer Typen dient.  In C # gibt es etwas sehr Ähnliches - den Typ Type.  Aber nur ähnlich.  Ein Wert vom Typ Typ kann jeden Typ beschreiben, eine Metaklasse kann nur die Erben der Klasse beschreiben, die angegeben wurde, als die Metaklasse deklariert wurde. <br><br>  Zu diesem Zweck erhält unsere hypothetische Version von C # den Typ Type &lt;T&gt;, der der Nachfolger von Type ist.  Der Typ &lt;T&gt; eignet sich jedoch nur zur Beschreibung des Typs T oder seiner Nachkommen. <br>  Ich werde dies anhand eines Beispiels erklären: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A2</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;A&gt; ta; ta = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A); <span class="hljs-comment"><span class="hljs-comment">//   ta = typeof(A2); //    ta = typeof(B); //   – Type&lt;B&gt;   Type&lt;A&gt; ta = (Type&lt;A&gt;)typeof(B); //      -   Type tx = typeof(A); ta = tx; //   –    Type  Type&lt;A&gt; ta = (Type&lt;A&gt;)tx; //    Type&lt;B&gt; tb = (Type&lt;B&gt;)tx; //  } }</span></span></code> </pre> <br>  Das obige Beispiel ist der erste Schritt zur Entstehung von Metaklassen.  Mit Typ &lt;T&gt; können Sie einschränken, welche Typen durch die entsprechenden Werte beschrieben werden können.  Diese Funktion mag sich an sich als nützlich erweisen, aber die Möglichkeiten von Metaklassen sind nicht darauf beschränkt. <br><br><h2>  Metaklassen und statische Klassenmitglieder </h2><br>  Wenn eine Klasse X statische Elemente hat, erhält der Metaklassentyp &lt;X&gt; ähnliche Elemente, die nicht mehr statisch sind, über die Sie auf die statischen Elemente von X zugreifen können. Lassen Sie uns diesen verwirrenden Satz anhand eines Beispiels erläutern. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;X&gt; tx = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(X); tx.DoSomething(); <span class="hljs-comment"><span class="hljs-comment">//   ,     X.DoSomething(); } }</span></span></code> </pre><br>  <i>Hier stellt sich im Allgemeinen die Frage: Was ist, wenn in Klasse X eine statische Methode deklariert wird, deren Name und Parametersatz mit dem Namen und Parametersatz einer der Methoden der Typklasse übereinstimmen, deren Vererbung Typ &lt;X&gt; ist?</i>  <i>Es gibt einige ziemlich einfache Möglichkeiten, um dieses Problem zu lösen, aber ich werde nicht darauf eingehen - der Einfachheit halber glauben wir, dass es in unserer Fantasy-Sprache der Konflikte keine magischen Namen gibt.</i> <br><br>  Der obige Code für eine normale Person sollte verwirrend sein - warum brauchen wir eine Variable, um eine Methode aufzurufen, wenn wir diese Methode direkt aufrufen können?  In dieser Form ist diese Gelegenheit in der Tat nutzlos.  Der Vorteil ergibt sich jedoch, wenn Sie Klassenmethoden hinzufügen. <br><br><h2>  Klassenmethoden </h2><br>  Klassenmethoden sind ein weiteres Konstrukt von Delphi, das jedoch in C # fehlt.  Wenn diese Methoden deklariert sind, werden sie mit der Wortklasse markiert und sind eine Kreuzung zwischen statischen Methoden und Instanzmethoden.  Wie statische Methoden sind sie nicht an eine bestimmte Instanz gebunden und können über den Klassennamen aufgerufen werden, ohne eine Instanz zu erstellen.  Im Gegensatz zu statischen Methoden haben sie jedoch einen impliziten Parameter.  Nur dies ist in diesem Fall keine Instanz der Klasse, sondern eine Metaklasse, d.h.  Wenn die Klassenmethode in Klasse X beschrieben ist, ist dieser Parameter vom Typ Typ &lt;X&gt;.  Und Sie können es so verwenden: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> class </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine($”    {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Name}”); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Y</span></span> : <span class="hljs-title"><span class="hljs-title">X</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { X.Report() <span class="hljs-comment"><span class="hljs-comment">// : «    X» Y.Report() // : «    Y» } }</span></span></code> </pre><br>  Diese Funktion ist bisher nicht sehr beeindruckend.  Dank dessen können Klassenmethoden im Gegensatz zu statischen Methoden virtuell sein.  Genauer gesagt könnten statische Methoden auch virtuell gemacht werden, aber es ist nicht klar, was als nächstes mit dieser Virtualität zu tun ist.  Bei Klassenmethoden treten solche Probleme jedoch nicht auf.  Betrachten Sie dies anhand eines Beispiels. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoReport</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(“!”); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { DoReport(); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Y</span></span> : <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoReport</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Consloe.WriteLine(“!”); } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { X.Report() <span class="hljs-comment"><span class="hljs-comment">// : «!» Y.Report() // : ??? } }</span></span></code> </pre><br>  Nach der Logik der Dinge sollte beim Aufrufen von Y.Report "Bye!" Angezeigt werden.  Die X.Report-Methode enthält jedoch keine Informationen darüber, von welcher Klasse sie aufgerufen wurde, sodass sie nicht dynamisch zwischen X.DoReport und Y.DoReport wählen kann.  Infolgedessen ruft X.Report immer X.DoReport auf, auch wenn Report über Y aufgerufen wurde. Es macht keinen Sinn, die DoReport-Methode virtuell zu machen.  Daher erlaubt C # nicht, statische Methoden virtuell zu machen - es wäre möglich, sie virtuell zu machen, aber Sie können nicht von ihrer Virtualität profitieren. <br><br>  Eine andere Sache sind Klassenmethoden.  Wenn der Bericht im vorherigen Beispiel nicht statisch, sondern eine Klasse wäre, würde er "wissen", wann er über X und wann über Y aufgerufen wurde. Dementsprechend könnte der Compiler Code generieren, der den gewünschten DoReport auswählt, und ein Aufruf von Y.Report würde resultieren zum Abschluss "Bye!". <br><br>  Diese Funktion ist an sich nützlich, wird jedoch noch nützlicher, wenn Sie die Möglichkeit hinzufügen, Klassenvariablen über Metaklassen aufzurufen.  So etwas wie das: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(“!”); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Y</span></span> : <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Consloe.WriteLine(“!”); } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;X&gt; tx = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(X); tx.Report() <span class="hljs-comment"><span class="hljs-comment">// : «!» tx = typeof(Y); tx.Report() // : «!» } }</span></span></code> </pre><br>  Um einen solchen Polymorphismus ohne Metaklassen und virtuelle Klassenmethoden zu erreichen, müssten Klasse X und jeder ihrer Nachkommen eine Hilfsklasse mit der üblichen virtuellen Methode schreiben.  Dies erfordert erheblich mehr Aufwand und die Kontrolle durch den Compiler ist nicht so vollständig, was die Wahrscheinlichkeit erhöht, irgendwo einen Fehler zu machen.  In der Zwischenzeit treten regelmäßig Situationen auf, in denen Polymorphismus auf Typebene und nicht auf Instanzebene erforderlich ist. Wenn die Sprache einen solchen Polymorphismus unterstützt, ist dies eine sehr nützliche Eigenschaft. <br><br><h2>  Virtuelle Konstruktoren </h2><br>  Wenn Metaklassen in der Sprache angezeigt werden, müssen ihnen virtuelle Konstruktoren hinzugefügt werden.  Wenn ein virtueller Konstruktor in einer Klasse deklariert ist, müssen alle seine Nachkommen ihn überlappen, d. H.  Haben Sie einen eigenen Konstruktor mit denselben Parametern, zum Beispiel: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">C</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ... } }</code> </pre><br>  In diesem Code sollte Klasse C nicht kompiliert werden, da es keinen Konstruktor mit den Parametern int x, int y gibt, Klasse B jedoch fehlerfrei kompiliert wird. <br><br>  <i>Eine andere Option ist möglich: Wenn sich der virtuelle Konstruktor des Vorfahren im Erben nicht überlappt, überlappt der Compiler ihn automatisch, ähnlich wie er jetzt automatisch den Standardkonstruktor erstellt.</i>  <i>Beide Ansätze haben offensichtliche Vor- und Nachteile, aber dies ist für das Gesamtbild nicht wichtig.</i> <br><br>  Ein virtueller Konstruktor kann überall dort verwendet werden, wo ein regulärer Konstruktor verwendet werden kann.  Wenn die Klasse über einen virtuellen Konstruktor verfügt, verfügt ihre Metaklasse über eine CreateInstance-Methode mit denselben Parametern wie der Konstruktor. Diese Methode erstellt eine Instanz der Klasse, wie im folgenden Beispiel gezeigt. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;A&gt; ta = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A); A a1 = ta.CreateInstance(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    A ta = typeof(B); A a2 = ta.CreateInstance(2, 7); //    B } }</span></span></code> </pre><br>  Mit anderen Worten, wir haben die Möglichkeit, Objekte zu erstellen, deren Typ zur Laufzeit bestimmt wird.  Dies kann jetzt auch mit Activator.CreateInstance erfolgen.  Diese Methode funktioniert jedoch durch Reflexion, sodass die Richtigkeit des Parametersatzes nur in der Ausführungsphase überprüft wird.  Wenn wir jedoch Metaklassen haben, wird der Code mit den falschen Parametern einfach nicht kompiliert.  Darüber hinaus lässt die Arbeitsgeschwindigkeit bei Verwendung der Reflexion zu wünschen übrig, und mit Metaklassen können Sie die Kosten minimieren. <br><br><h2>  Fazit </h2><br>  Ich war immer überrascht, warum Halesberg, der der Hauptentwickler von Delphi und C # ist, keine Metaklassen in C # herstellte, obwohl sie sich in Delphi so gut bewährt haben.  Vielleicht ist der Punkt hier, dass es in Delphi (in den Versionen, die Halesberg gemacht hat) fast keine Reflexion gibt und es einfach keine Alternative zu Metaklassen gibt, was man über C # nicht sagen kann.  In der Tat sind alle Beispiele aus diesem Artikel nicht so schwer zu wiederholen, da nur die Tools verwendet werden, die bereits in der Sprache vorhanden sind.  All dies funktioniert jedoch merklich langsamer als bei Metaklassen, und die Richtigkeit der Aufrufe wird zur Laufzeit überprüft und nicht kompiliert.  Meine persönliche Meinung ist also, dass C # sehr davon profitieren würde, wenn Metaklassen darin erscheinen würden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464141/">https://habr.com/ru/post/de464141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464127/index.html">Entwicklung animierter Favicons</a></li>
<li><a href="../de464129/index.html">JavaScript-Innovationen: Ergebnisse von Google I / O 2019 Teil 1</a></li>
<li><a href="../de464131/index.html">JavaScript-Innovationen: Ergebnisse von Google I / O 2019 Teil 2</a></li>
<li><a href="../de464133/index.html">Bei der Leistung geht es nicht nur um die CPU: Erstellen Sie Ihre eigenen Profiler für Python</a></li>
<li><a href="../de464137/index.html">Technischer Support Miran: wie es funktioniert</a></li>
<li><a href="../de464143/index.html">Persönliche Krebsheilung. Wie Patientengene den Behandlungserfolg beeinflussen</a></li>
<li><a href="../de464145/index.html">CMake: Der Fall, in dem die Qualität des Projekts unverzeihlich ist</a></li>
<li><a href="../de464147/index.html">CMake: Der Fall, in dem das Projekt unverzeihlich ist, ist die Qualität seines Codes</a></li>
<li><a href="../de464149/index.html">Die Geschichte eines Monolithen</a></li>
<li><a href="../de464151/index.html">Victor Vyalichkin: „Freiheit, Gleichheit, Brüderlichkeit gibt es nur in OpenStreetMap, wo immer alles in Sicht ist.“</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>