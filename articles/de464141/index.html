<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¬ ğŸ‘¨ğŸ¼â€ğŸ­ ğŸš´ğŸ» Fantasien zum Thema Metaklassen in C # ğŸ‘„ ğŸ‘¶ğŸ½ âœŒğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Programmierer wie ich, die mit umfassender Erfahrung in Delphi zu C # gekommen sind, haben oft nicht genug von dem, was in Delphi-Klassenreferenzen un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fantasien zum Thema Metaklassen in C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464141/"> Programmierer wie ich, die mit umfassender Erfahrung in Delphi zu C # gekommen sind, haben oft nicht genug von dem, was in Delphi-Klassenreferenzen und in theoretischen Arbeiten hÃ¤ufig als Metaklassen bezeichnet wird.  Mehrmals in verschiedenen Foren stieÃŸ ich auf eine Diskussion, die in der gleichen Richtung stattfand.  Es beginnt mit einer Frage eines ehemaligen Delfisten, wie man eine Metaklasse in C # erstellt.  ScharfschÃ¼tzen verstehen das Problem einfach nicht und versuchen zu klÃ¤ren, um welche Art von Tier es sich handelt - eine Metaklasse, Delphisten, wie sie erklÃ¤ren kÃ¶nnen, aber die ErklÃ¤rungen sind kurz und unvollstÃ¤ndig, und infolgedessen sind die SchÃ¤rfer vÃ¶llig ratlos, warum all dies notwendig ist.  SchlieÃŸlich kann das Gleiche mit Hilfe von Reflexions- und Klassenfabriken getan werden. <br><br>  In diesem Artikel werde ich versuchen, Ihnen zu sagen, was Metaklassen fÃ¼r diejenigen sind, die ihnen noch nie begegnet sind.  Lassen Sie auÃŸerdem jeden selbst entscheiden, ob es gut wÃ¤re, so etwas in der Sprache zu haben, oder ob Reflexion ausreicht.  Ich schreibe hier nur Fantasien darÃ¼ber, wie es hÃ¤tte sein kÃ¶nnen, wenn es in C # wirklich Metaklassen gegeben hÃ¤tte.  Alle Beispiele in diesem Artikel sind in dieser hypothetischen Version von C # geschrieben, die derzeit von keinem einzigen Compiler kompiliert werden kann. <br><a name="habracut"></a><br><h2>  Was ist eine Metaklasse? </h2><br>  Was ist eine Metaklasse?  Dies ist ein spezieller Typ, der zur Beschreibung anderer Typen dient.  In C # gibt es etwas sehr Ã„hnliches - den Typ Type.  Aber nur Ã¤hnlich.  Ein Wert vom Typ Typ kann jeden Typ beschreiben, eine Metaklasse kann nur die Erben der Klasse beschreiben, die angegeben wurde, als die Metaklasse deklariert wurde. <br><br>  Zu diesem Zweck erhÃ¤lt unsere hypothetische Version von C # den Typ Type &lt;T&gt;, der der Nachfolger von Type ist.  Der Typ &lt;T&gt; eignet sich jedoch nur zur Beschreibung des Typs T oder seiner Nachkommen. <br>  Ich werde dies anhand eines Beispiels erklÃ¤ren: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A2</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;A&gt; ta; ta = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A); <span class="hljs-comment"><span class="hljs-comment">//   ta = typeof(A2); //    ta = typeof(B); //   â€“ Type&lt;B&gt;   Type&lt;A&gt; ta = (Type&lt;A&gt;)typeof(B); //      -   Type tx = typeof(A); ta = tx; //   â€“    Type  Type&lt;A&gt; ta = (Type&lt;A&gt;)tx; //    Type&lt;B&gt; tb = (Type&lt;B&gt;)tx; //  } }</span></span></code> </pre> <br>  Das obige Beispiel ist der erste Schritt zur Entstehung von Metaklassen.  Mit Typ &lt;T&gt; kÃ¶nnen Sie einschrÃ¤nken, welche Typen durch die entsprechenden Werte beschrieben werden kÃ¶nnen.  Diese Funktion mag sich an sich als nÃ¼tzlich erweisen, aber die MÃ¶glichkeiten von Metaklassen sind nicht darauf beschrÃ¤nkt. <br><br><h2>  Metaklassen und statische Klassenmitglieder </h2><br>  Wenn eine Klasse X statische Elemente hat, erhÃ¤lt der Metaklassentyp &lt;X&gt; Ã¤hnliche Elemente, die nicht mehr statisch sind, Ã¼ber die Sie auf die statischen Elemente von X zugreifen kÃ¶nnen. Lassen Sie uns diesen verwirrenden Satz anhand eines Beispiels erlÃ¤utern. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;X&gt; tx = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(X); tx.DoSomething(); <span class="hljs-comment"><span class="hljs-comment">//   ,     X.DoSomething(); } }</span></span></code> </pre><br>  <i>Hier stellt sich im Allgemeinen die Frage: Was ist, wenn in Klasse X eine statische Methode deklariert wird, deren Name und Parametersatz mit dem Namen und Parametersatz einer der Methoden der Typklasse Ã¼bereinstimmen, deren Vererbung Typ &lt;X&gt; ist?</i>  <i>Es gibt einige ziemlich einfache MÃ¶glichkeiten, um dieses Problem zu lÃ¶sen, aber ich werde nicht darauf eingehen - der Einfachheit halber glauben wir, dass es in unserer Fantasy-Sprache der Konflikte keine magischen Namen gibt.</i> <br><br>  Der obige Code fÃ¼r eine normale Person sollte verwirrend sein - warum brauchen wir eine Variable, um eine Methode aufzurufen, wenn wir diese Methode direkt aufrufen kÃ¶nnen?  In dieser Form ist diese Gelegenheit in der Tat nutzlos.  Der Vorteil ergibt sich jedoch, wenn Sie Klassenmethoden hinzufÃ¼gen. <br><br><h2>  Klassenmethoden </h2><br>  Klassenmethoden sind ein weiteres Konstrukt von Delphi, das jedoch in C # fehlt.  Wenn diese Methoden deklariert sind, werden sie mit der Wortklasse markiert und sind eine Kreuzung zwischen statischen Methoden und Instanzmethoden.  Wie statische Methoden sind sie nicht an eine bestimmte Instanz gebunden und kÃ¶nnen Ã¼ber den Klassennamen aufgerufen werden, ohne eine Instanz zu erstellen.  Im Gegensatz zu statischen Methoden haben sie jedoch einen impliziten Parameter.  Nur dies ist in diesem Fall keine Instanz der Klasse, sondern eine Metaklasse, d.h.  Wenn die Klassenmethode in Klasse X beschrieben ist, ist dieser Parameter vom Typ Typ &lt;X&gt;.  Und Sie kÃ¶nnen es so verwenden: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> class </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine($â€    {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Name}â€); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Y</span></span> : <span class="hljs-title"><span class="hljs-title">X</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { X.Report() <span class="hljs-comment"><span class="hljs-comment">// : Â«    XÂ» Y.Report() // : Â«    YÂ» } }</span></span></code> </pre><br>  Diese Funktion ist bisher nicht sehr beeindruckend.  Dank dessen kÃ¶nnen Klassenmethoden im Gegensatz zu statischen Methoden virtuell sein.  Genauer gesagt kÃ¶nnten statische Methoden auch virtuell gemacht werden, aber es ist nicht klar, was als nÃ¤chstes mit dieser VirtualitÃ¤t zu tun ist.  Bei Klassenmethoden treten solche Probleme jedoch nicht auf.  Betrachten Sie dies anhand eines Beispiels. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoReport</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(â€œ!â€); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { DoReport(); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Y</span></span> : <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoReport</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Consloe.WriteLine(â€œ!â€); } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { X.Report() <span class="hljs-comment"><span class="hljs-comment">// : Â«!Â» Y.Report() // : ??? } }</span></span></code> </pre><br>  Nach der Logik der Dinge sollte beim Aufrufen von Y.Report "Bye!" Angezeigt werden.  Die X.Report-Methode enthÃ¤lt jedoch keine Informationen darÃ¼ber, von welcher Klasse sie aufgerufen wurde, sodass sie nicht dynamisch zwischen X.DoReport und Y.DoReport wÃ¤hlen kann.  Infolgedessen ruft X.Report immer X.DoReport auf, auch wenn Report Ã¼ber Y aufgerufen wurde. Es macht keinen Sinn, die DoReport-Methode virtuell zu machen.  Daher erlaubt C # nicht, statische Methoden virtuell zu machen - es wÃ¤re mÃ¶glich, sie virtuell zu machen, aber Sie kÃ¶nnen nicht von ihrer VirtualitÃ¤t profitieren. <br><br>  Eine andere Sache sind Klassenmethoden.  Wenn der Bericht im vorherigen Beispiel nicht statisch, sondern eine Klasse wÃ¤re, wÃ¼rde er "wissen", wann er Ã¼ber X und wann Ã¼ber Y aufgerufen wurde. Dementsprechend kÃ¶nnte der Compiler Code generieren, der den gewÃ¼nschten DoReport auswÃ¤hlt, und ein Aufruf von Y.Report wÃ¼rde resultieren zum Abschluss "Bye!". <br><br>  Diese Funktion ist an sich nÃ¼tzlich, wird jedoch noch nÃ¼tzlicher, wenn Sie die MÃ¶glichkeit hinzufÃ¼gen, Klassenvariablen Ã¼ber Metaklassen aufzurufen.  So etwas wie das: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(â€œ!â€); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Y</span></span> : <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Consloe.WriteLine(â€œ!â€); } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;X&gt; tx = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(X); tx.Report() <span class="hljs-comment"><span class="hljs-comment">// : Â«!Â» tx = typeof(Y); tx.Report() // : Â«!Â» } }</span></span></code> </pre><br>  Um einen solchen Polymorphismus ohne Metaklassen und virtuelle Klassenmethoden zu erreichen, mÃ¼ssten Klasse X und jeder ihrer Nachkommen eine Hilfsklasse mit der Ã¼blichen virtuellen Methode schreiben.  Dies erfordert erheblich mehr Aufwand und die Kontrolle durch den Compiler ist nicht so vollstÃ¤ndig, was die Wahrscheinlichkeit erhÃ¶ht, irgendwo einen Fehler zu machen.  In der Zwischenzeit treten regelmÃ¤ÃŸig Situationen auf, in denen Polymorphismus auf Typebene und nicht auf Instanzebene erforderlich ist. Wenn die Sprache einen solchen Polymorphismus unterstÃ¼tzt, ist dies eine sehr nÃ¼tzliche Eigenschaft. <br><br><h2>  Virtuelle Konstruktoren </h2><br>  Wenn Metaklassen in der Sprache angezeigt werden, mÃ¼ssen ihnen virtuelle Konstruktoren hinzugefÃ¼gt werden.  Wenn ein virtueller Konstruktor in einer Klasse deklariert ist, mÃ¼ssen alle seine Nachkommen ihn Ã¼berlappen, d. H.  Haben Sie einen eigenen Konstruktor mit denselben Parametern, zum Beispiel: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">C</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ... } }</code> </pre><br>  In diesem Code sollte Klasse C nicht kompiliert werden, da es keinen Konstruktor mit den Parametern int x, int y gibt, Klasse B jedoch fehlerfrei kompiliert wird. <br><br>  <i>Eine andere Option ist mÃ¶glich: Wenn sich der virtuelle Konstruktor des Vorfahren im Erben nicht Ã¼berlappt, Ã¼berlappt der Compiler ihn automatisch, Ã¤hnlich wie er jetzt automatisch den Standardkonstruktor erstellt.</i>  <i>Beide AnsÃ¤tze haben offensichtliche Vor- und Nachteile, aber dies ist fÃ¼r das Gesamtbild nicht wichtig.</i> <br><br>  Ein virtueller Konstruktor kann Ã¼berall dort verwendet werden, wo ein regulÃ¤rer Konstruktor verwendet werden kann.  Wenn die Klasse Ã¼ber einen virtuellen Konstruktor verfÃ¼gt, verfÃ¼gt ihre Metaklasse Ã¼ber eine CreateInstance-Methode mit denselben Parametern wie der Konstruktor. Diese Methode erstellt eine Instanz der Klasse, wie im folgenden Beispiel gezeigt. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;A&gt; ta = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A); A a1 = ta.CreateInstance(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    A ta = typeof(B); A a2 = ta.CreateInstance(2, 7); //    B } }</span></span></code> </pre><br>  Mit anderen Worten, wir haben die MÃ¶glichkeit, Objekte zu erstellen, deren Typ zur Laufzeit bestimmt wird.  Dies kann jetzt auch mit Activator.CreateInstance erfolgen.  Diese Methode funktioniert jedoch durch Reflexion, sodass die Richtigkeit des Parametersatzes nur in der AusfÃ¼hrungsphase Ã¼berprÃ¼ft wird.  Wenn wir jedoch Metaklassen haben, wird der Code mit den falschen Parametern einfach nicht kompiliert.  DarÃ¼ber hinaus lÃ¤sst die Arbeitsgeschwindigkeit bei Verwendung der Reflexion zu wÃ¼nschen Ã¼brig, und mit Metaklassen kÃ¶nnen Sie die Kosten minimieren. <br><br><h2>  Fazit </h2><br>  Ich war immer Ã¼berrascht, warum Halesberg, der der Hauptentwickler von Delphi und C # ist, keine Metaklassen in C # herstellte, obwohl sie sich in Delphi so gut bewÃ¤hrt haben.  Vielleicht ist der Punkt hier, dass es in Delphi (in den Versionen, die Halesberg gemacht hat) fast keine Reflexion gibt und es einfach keine Alternative zu Metaklassen gibt, was man Ã¼ber C # nicht sagen kann.  In der Tat sind alle Beispiele aus diesem Artikel nicht so schwer zu wiederholen, da nur die Tools verwendet werden, die bereits in der Sprache vorhanden sind.  All dies funktioniert jedoch merklich langsamer als bei Metaklassen, und die Richtigkeit der Aufrufe wird zur Laufzeit Ã¼berprÃ¼ft und nicht kompiliert.  Meine persÃ¶nliche Meinung ist also, dass C # sehr davon profitieren wÃ¼rde, wenn Metaklassen darin erscheinen wÃ¼rden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464141/">https://habr.com/ru/post/de464141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464127/index.html">Entwicklung animierter Favicons</a></li>
<li><a href="../de464129/index.html">JavaScript-Innovationen: Ergebnisse von Google I / O 2019 Teil 1</a></li>
<li><a href="../de464131/index.html">JavaScript-Innovationen: Ergebnisse von Google I / O 2019 Teil 2</a></li>
<li><a href="../de464133/index.html">Bei der Leistung geht es nicht nur um die CPU: Erstellen Sie Ihre eigenen Profiler fÃ¼r Python</a></li>
<li><a href="../de464137/index.html">Technischer Support Miran: wie es funktioniert</a></li>
<li><a href="../de464143/index.html">PersÃ¶nliche Krebsheilung. Wie Patientengene den Behandlungserfolg beeinflussen</a></li>
<li><a href="../de464145/index.html">CMake: Der Fall, in dem die QualitÃ¤t des Projekts unverzeihlich ist</a></li>
<li><a href="../de464147/index.html">CMake: Der Fall, in dem das Projekt unverzeihlich ist, ist die QualitÃ¤t seines Codes</a></li>
<li><a href="../de464149/index.html">Die Geschichte eines Monolithen</a></li>
<li><a href="../de464151/index.html">Victor Vyalichkin: â€Freiheit, Gleichheit, BrÃ¼derlichkeit gibt es nur in OpenStreetMap, wo immer alles in Sicht ist.â€œ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>