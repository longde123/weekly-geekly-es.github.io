<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõèÔ∏è üë®üèø‚Äçü§ù‚Äçüë®üèª üõçÔ∏è M√©canismes d'allocation de Go ‚ò∫Ô∏è üìì üßîüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lorsque j'ai essay√© pour la premi√®re fois de comprendre le fonctionnement des outils d'allocation de m√©moire dans Go, ce que je voulais g√©rer semblait...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√©canismes d'allocation de Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442648/">  Lorsque j'ai essay√© pour la premi√®re fois de comprendre le fonctionnement des outils d'allocation de m√©moire dans Go, ce que je voulais g√©rer semblait √™tre une myst√©rieuse bo√Æte noire.  Comme pour toute autre technologie, la chose la plus importante ici est cach√©e derri√®re de nombreuses couches d'abstractions, √† travers lesquelles vous devez passer pour comprendre quelque chose. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/tv/0k/gh/tv0kghio2zhsc-og7bjd-mtl41q.jpeg"></a> <br><br>  L'auteur du mat√©riel, dont nous publions la traduction, a d√©cid√© d'aller au fond des moyens d'allocation de m√©moire dans Go et d'en parler. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">M√©moire physique et virtuelle</font> </h2><br>  Tous les moyens d'allocation de m√©moire doivent fonctionner avec l'espace d'adressage de la m√©moire virtuelle, qui est contr√¥l√© par le syst√®me d'exploitation.  Voyons comment fonctionne la m√©moire, en commen√ßant au niveau le plus bas - avec les cellules de m√©moire. <br>  Voici comment imaginer une cellule RAM. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e22/5e5/74c/e225e574c2649eb0bf9f5dd9cb1edadb.png"></div><br>  <i><font color="#999999">Disposition des cellules de m√©moire</font></i> <br><br>  Si, tr√®s simplifi√©, imaginez une cellule m√©moire et ce qui l'entoure, alors nous obtenons ce qui suit: <br><br><ol><li>  La ligne d'adresse (le transistor agit comme un interrupteur) est ce qui donne acc√®s au condensateur (ligne de donn√©es). </li><li>  Lorsqu'un signal appara√Æt dans la ligne d'adresse (ligne rouge), la ligne de donn√©es vous permet d'√©crire des donn√©es dans la cellule m√©moire, c'est-√†-dire de charger le condensateur, ce qui permet d'y stocker une valeur logique correspondant √† 1. </li><li> Lorsqu'il n'y a pas de signal dans la ligne d'adresse (ligne verte), le condensateur est isol√© et sa charge ne change pas.  Pour √©crire dans la cellule 0, vous devez s√©lectionner son adresse et soumettre un 0 logique via la ligne de donn√©es, c'est-√†-dire connecter la ligne de donn√©es avec un moins, d√©chargeant ainsi le condensateur. </li><li>  Lorsque le processeur doit lire la valeur de la m√©moire, le signal est envoy√© le long de la ligne d'adresse (le commutateur se ferme).  Si le condensateur est charg√©, le signal passe par la ligne de donn√©es (1 est lu), sinon le signal ne passe pas par la ligne de donn√©es (0 est lu). </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8d/33a/100/e8d33a100b5dbf94d34e794785670f24.png"></div><br>  <i><font color="#999999">Le sch√©ma d'interaction de la m√©moire physique et du processeur</font></i> <br><br>  Le bus de donn√©es est responsable du transport des donn√©es entre le processeur et la m√©moire physique. <br><br>  Parlons maintenant de la ligne d'adresse et des octets adressables. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d24/e38/542/d24e38542de230b449750b26641f5e8c.png"></div><br>  <i><font color="#999999">Lignes d'adresse de bus entre le processeur et la m√©moire physique</font></i> <br><br><ol><li>  Chaque octet dans la RAM se voit attribuer un identifiant num√©rique unique (adresse).  Il est √† noter que le nombre d'octets physiques pr√©sents dans la m√©moire n'est pas √©gal au nombre de lignes d'adresse. </li><li>  Chaque ligne d'adresse peut sp√©cifier une valeur de 1 bit, elle indique donc un bit dans l'adresse d'un certain octet. </li><li>  Notre circuit dispose de 32 lignes d'adresse.  Par cons√©quent, chaque octet adressable utilise un nombre 32 bits comme adresse.  [00000000000000000000000000000000] - l'adresse m√©moire la plus basse.  [1111111111111111111111111111111111] - l'adresse m√©moire la plus √©lev√©e. </li><li>  √âtant donn√© que chaque octet a une adresse 32 bits, notre espace d'adressage se compose de 2 <sup>32</sup> octets adressables (4 Go). </li></ol><br>  Il en r√©sulte que le nombre d'octets adressables d√©pend du nombre total de lignes d'adresse.  Par exemple, s'il existe 64 lignes d'adresse (processeurs x86-64), vous pouvez adresser 2 <sup>64</sup> octets (16 exaoctets) de m√©moire, mais la plupart des architectures qui utilisent des pointeurs 64 bits utilisent en fait des lignes d'adresse 48 bits (AMD64) et lignes d'adresse 42 bits (Intel), qui permettent th√©oriquement aux ordinateurs d'√™tre √©quip√©s de 256 t√©raoctets de m√©moire physique (Linux permet, sur l'architecture x86-64, lors de l'utilisation des pages d'adresse de niveau 4, d'allouer jusqu'√† 128 To d'espace d'adressage aux processus, Windows vous permet d'allouer jusqu'√† 192 To). <br>  Comme la taille de la RAM physique est limit√©e, chaque processus s'ex√©cute dans son propre "bac √† sable" - dans ce que l'on appelle "l'espace d'adressage virtuel", appel√© m√©moire virtuelle. <br><br>  Les adresses d'octet dans l'espace d'adressage virtuel ne correspondent pas aux adresses que le processeur utilise pour acc√©der √† la m√©moire physique.  En cons√©quence, nous avons besoin d'un syst√®me qui nous permette de convertir des adresses virtuelles en adresses physiques.  Jetez un ≈ìil √† ce √† quoi ressemblent les adresses de m√©moire virtuelle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d0/09b/354/9d009b354ada519bf1280ea96e139e64.jpg"></div><br>  <i><font color="#999999">Repr√©sentation de l'espace d'adressage virtuel</font></i> <br><br>  Par cons√©quent, lorsque le processeur ex√©cute une instruction qui fait r√©f√©rence √† une adresse m√©moire, la premi√®re √©tape consiste √† traduire l'adresse logique en une adresse lin√©aire.  Cette conversion est effectu√©e par l'unit√© de gestion de la m√©moire. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/330/ba9/56a330ba9d27daeb5737e013c0c15156.png"></div><br>  <i><font color="#999999">Repr√©sentation simplifi√©e de la relation entre m√©moire virtuelle et m√©moire physique</font></i> <br><br>  √âtant donn√© que les adresses logiques sont trop grandes pour √™tre pratiques pour les utiliser s√©par√©ment (cela d√©pend de divers facteurs), la m√©moire est organis√©e en structures appel√©es pages.  Dans ce cas, l'espace d'adressage virtuel est divis√© en petites zones, des pages qui, dans la plupart des syst√®mes d'exploitation, ont une taille de 4 Ko, bien que cette taille puisse g√©n√©ralement √™tre modifi√©e.  Il s'agit de la plus petite unit√© de gestion de la m√©moire dans la m√©moire virtuelle.  La m√©moire virtuelle ne stocke rien, elle √©tablit simplement la correspondance entre l'espace d'adressage du programme et la m√©moire physique. <br><br>  Les processus ne voient que les adresses de m√©moire virtuelle.  Que se passe-t-il si un programme a besoin de plus de m√©moire dynamique (√©galement appel√©e m√©moire de tas ou ¬´tas¬ª)?  Voici un exemple de code assembleur simple dans lequel une m√©moire suppl√©mentaire allou√©e dynamiquement est demand√©e au syst√®me: <br><br><pre><code class="plaintext hljs">_start:        mov $12, %rax #    brk        mov $0, %rdi # 0 -  ,            syscall b0:        mov %rax, %rsi #  rsi    ,           mov %rax, %rdi #     ...        add $4, %rdi # ..  4 ,           mov $12, %rax #    brk        syscall</code> </pre> <br>  Voici comment il peut √™tre repr√©sent√© sous forme de diagramme. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c22/962/904/c229629041c7612e254d89d146fcc4ef.png"></div><br>  <i><font color="#999999">Augmentez la m√©moire allou√©e dynamiquement</font></i> <br><br>  Le programme demande de la m√©moire suppl√©mentaire √† l'aide de l'appel syst√®me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">brk</a> (sbrk / mmap, etc.).  Le noyau met √† jour les informations sur la m√©moire virtuelle, mais de nouvelles pages n'ont pas encore √©t√© pr√©sent√©es dans la m√©moire physique, et ici il y a une diff√©rence entre la m√©moire virtuelle et la m√©moire physique. <br><br><h2>  <font color="#3AC1EF">Allocateur de m√©moire</font> </h2><br>  Apr√®s avoir, en termes g√©n√©raux, discut√© de l'utilisation de l'espace d'adressage virtuel, parl√© de la fa√ßon de demander de la m√©moire dynamique suppl√©mentaire (m√©moire sur le tas), il nous sera plus facile de parler des moyens d'allouer de la m√©moire. <br><br>  Si le tas a suffisamment de m√©moire pour satisfaire nos requ√™tes de code, alors l'allocateur de m√©moire peut ex√©cuter ces requ√™tes sans acc√©der au noyau.  Sinon, il doit augmenter la taille du tas en utilisant un appel syst√®me (en utilisant brk, par exemple), tout en demandant un gros bloc de m√©moire.  Dans le cas de malloc, ¬´grand¬ª signifie la taille d√©crite par le param√®tre <code>MMAP_THRESHOLD</code> , qui, par d√©faut, est de 128 Ko. <br><br>  Cependant, un allocateur de m√©moire a plus de responsabilit√©s que d'allouer simplement de la m√©moire.  L'une de ses responsabilit√©s les plus importantes est de r√©duire la fragmentation de la m√©moire interne et externe et d'allouer les blocs de m√©moire le plus rapidement possible.  Supposons que notre programme ex√©cute s√©quentiellement des demandes d'allocation de blocs de m√©moire continus √† l'aide d'une fonction de la forme <code>malloc(size)</code> , apr√®s quoi cette m√©moire est lib√©r√©e √† l'aide d'une fonction de la forme <code>free(pointer)</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/8a0/779/9448a077982dfb81e4c982c1228cad15.png"></div><br>  <i><font color="#999999">D√©monstration de fragmentation externe</font></i> <br><br>  Dans le diagramme pr√©c√©dent, √† l'√©tape p4, nous n'avons pas suffisamment de blocs de m√©moire situ√©s s√©quentiellement pour r√©pondre √† la demande d'allocation de six de ces blocs, bien que la quantit√© totale de m√©moire libre le permette.  Cette situation entra√Æne une fragmentation de la m√©moire. <br><br>  Comment r√©duire la fragmentation de la m√©moire?  La r√©ponse √† cette question d√©pend de l'algorithme d'allocation de m√©moire sp√©cifique, sur lequel la biblioth√®que de base est utilis√©e pour travailler avec la m√©moire. <br><br>  Nous allons maintenant examiner l'outil d'allocation de m√©moire TCMalloc, sur lequel les m√©canismes d'allocation de m√©moire Go sont bas√©s. <br><br><h2>  <font color="#3AC1EF">TCMalloc</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TCMalloc</a> est bas√© sur l'id√©e de diviser la m√©moire en plusieurs niveaux pour r√©duire la fragmentation de la m√©moire.  Dans TCMalloc, la gestion de la m√©moire est divis√©e en deux parties: travailler avec la m√©moire des threads et travailler avec le tas. <br><br><h3>  <font color="#3AC1EF">‚ñç M√©moire de thread</font> </h3><br>  Chaque page de m√©moire est divis√©e en une s√©quence de fragments de certaines tailles, s√©lectionn√©s en fonction des classes de taille.  Cela r√©duit la fragmentation.  De ce fait, chaque thread dispose d'un cache pour les petits objets, ce qui permet une allocation tr√®s efficace de la m√©moire pour les objets inf√©rieurs ou √©gaux √† 32 Ko. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/331/901/7c8/3319017c8657e4b75a25003357d4b4f4.png"></div><br>  <i><font color="#999999">Cache de flux</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñçBunch</font> </h3><br>  Un tas g√©r√© TCMalloc est une collection de pages dans laquelle un ensemble de pages cons√©cutives peut √™tre repr√©sent√© comme une plage de pages (span).  Lorsque vous devez allouer de la m√©moire √† un objet dont la taille est sup√©rieure √† 32 Ko, le segment de m√©moire est utilis√© pour allouer de la m√©moire. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48c/f49/707/48cf497071e18b1539c18e6c2057e85d.png"></div><br>  <i><font color="#999999">Tassez et travaillez avec des pages</font></i> <br><br>  Lorsqu'il n'y a pas assez d'espace pour placer de petits objets en m√©moire, ils se tournent vers le tas de m√©moire.  Si le tas n'a pas assez de m√©moire libre, une m√©moire suppl√©mentaire est demand√©e au syst√®me d'exploitation. <br><br>  Par cons√©quent, le mod√®le pr√©sent√© de travail avec la m√©moire prend en charge le pool de m√©moire de l'espace utilisateur; son utilisation am√©liore consid√©rablement l'efficacit√© de l'allocation et de la lib√©ration de m√©moire. <br><br>  Il convient de noter que l'outil d'allocation de m√©moire Go √©tait √† l'origine bas√© sur TCMalloc, mais il en diff√®re l√©g√®rement. <br><br><h2>  <font color="#3AC1EF">Go allocateur de m√©moire</font> </h2><br>  Nous savons que le runtime Go pr√©voit d'ex√©cuter des goroutines sur des processeurs logiques.  De m√™me, la version de TCMalloc utilis√©e par Go divise les pages m√©moire en blocs dont les tailles correspondent √† certaines classes de taille dont 67 existent. <br><br>  Si vous n'√™tes pas familier avec le planificateur Go <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">,</a> vous pouvez en lire plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/824/d5c/0df/824d5c0dfac562629662650924292583.png"></div><br>  <i><font color="#999999">Allez classes de taille</font></i> <br><br>  √âtant donn√© que la taille de page minimale dans Go est de 8192 octets (8 Ko), si une telle page est divis√©e en blocs de 1 Ko, nous obtiendrons 8 de ces blocs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/150/865/6ba/1508656ba4a4c009624468a164d41e5b.png"></div><br>  <i><font color="#999999">Une taille de page de 8 Ko est divis√©e en blocs correspondant √† une taille de classe de 1 Ko</font></i> <br><br>  Les s√©quences de pages similaires dans Go sont contr√¥l√©es √† l'aide d'une structure appel√©e mspan. <br><br><h3>  <font color="#3AC1EF">‚ñçStructure mspan</font> </h3><br>  La structure mspan est une liste doublement li√©e, un objet qui contient l'adresse de d√©part de la page, des informations sur la taille de la page et le nombre de pages qu'elle contient. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dbd/cae/fc0/dbdcaefc090a443369d33c2cde7e06ae.png"></div><br>  <i><font color="#999999">Structure Mspan</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç structure mcache</font> </h3><br>  Comme TCMalloc, Go fournit √† chaque processeur logique un cache de thread local, appel√© mcache.  Par cons√©quent, si goroutine a besoin de m√©moire, il peut l'obtenir directement depuis mcache.  Pour ce faire, vous n'avez pas besoin d'effectuer de verrouillage, car √† tout moment, un seul goroutin est ex√©cut√© sur un processeur logique. <br><br>  La structure mcache contient, sous forme de cache, des structures mspan de diff√©rentes classes de taille. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/478/7bb/459/4787bb4597d56f89b474189c5e86441b.png"></div><br>  <i><font color="#999999">Interaction entre processeur logique, mcache et mspan dans Go</font></i> <br><br>  √âtant donn√© que chaque processeur logique a son propre mcache, il n'est pas n√©cessaire de verrouiller lors de l'allocation de m√©moire √† partir de mcache. <br><br>  Chaque classe de taille peut √™tre repr√©sent√©e par l'un des objets suivants: <br><br><ul><li>  Un objet num√©ris√© est un objet qui contient un pointeur. </li><li>  Un objet noscan est un objet dans lequel il n'y a pas de pointeur. </li></ul><br>  L'une des forces de cette approche est que lorsque la r√©cup√©ration de place est effectu√©e, les objets noscan n'ont pas besoin d'√™tre contourn√©s, car ils ne contiennent pas d'objets pour lesquels de la m√©moire est allou√©e. <br><br>  Qu'est-ce qui entre dans mache?  Les objets dont la taille ne d√©passe pas 32 Ko vont directement √† mcache en utilisant mspan de la classe de taille correspondante. <br><br>  Que se passe-t-il si mcache n'a pas de cellule libre?  Ensuite, ils obtiennent un nouveau mspan de la classe de taille souhait√©e dans la liste des objets mspan appel√©s mcentral. <br><br><h3>  <font color="#3AC1EF">Structure Structure centrale</font> </h3><br>  La structure mcentral collecte toutes les plages de pages d'une classe de taille particuli√®re.  Chaque objet mcentral contient deux listes d'objets mspan. <br><br><ol><li>  Liste des objets mspan dans lesquels il n'y a pas d'objets libres, ou ceux mspan qui sont dans mcache. </li><li>  Liste des objets mspan contenant des objets libres. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6dc/b88/7f9/6dcb887f9c717bb1f24735daa4b50aa7.png"></div><br>  <i><font color="#999999">Structure Mcentral</font></i> <br><br>  Chaque structure mcentral existe au sein de la structure mheap. <br><br><h3>  <font color="#3AC1EF">Structure Structure de tas</font> </h3><br>  La structure mheap est repr√©sent√©e par un objet qui g√®re la gestion des segments dans Go.  Un seul objet global de ce type poss√®de un espace d'adressage virtuel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8e/b07/01b/c8eb0701bbe46523e2735e695db97115.png"></div><br>  <i><font color="#999999">Structure mheap</font></i> <br><br>  Comme vous pouvez le voir sur le diagramme ci-dessus, la structure mheap contient un tableau de structures mcentral.  Ce tableau contient des structures mcentral pour toutes les classes de taille. <br><br><pre> <code class="plaintext hljs">central [numSpanClasses]struct { mcentral mcentral   pad     [sys.CacheLineSize unsafe.Sizeof(mcentral{})%sys.CacheLineSize]byte }</code> </pre> <br>  √âtant donn√© que nous avons une structure mcentral pour chaque classe de taille, lorsque mcache demande la structure mspan √† mcentral, un verrou est appliqu√© au niveau mcentral individuel, par cons√©quent, les demandes d'autres mcache demandant des structures mspan d'autres tailles peuvent √™tre servies en m√™me temps. <br><br>  L'alignement (pad) garantit que les structures mcentral sont s√©par√©es les unes des autres par le nombre d'octets correspondant √† la valeur <code>CacheLineSize</code> .  En cons√©quence, chaque <code>mcentral.lock</code> a sa propre ligne de cache, ce qui √©vite les probl√®mes associ√©s au partage de fausses m√©moires. <br><br>  Que se passe-t-il si la liste mcentral est vide?  Ensuite, mcentral re√ßoit une s√©quence de pages de mheap pour allouer des fragments de m√©moire de la classe de taille requise. <br><br><ul><li>  <code>free[_MaxMHeapList]mSpanList</code> est un tableau de spanList.  La structure mspan dans chaque spanList se compose de 1 √† 127 pages (_MaxMHeapList - 1).  Par exemple, free [3] est une liste cha√Æn√©e de structures mspan contenant 3 pages.  Le mot "libre" dans ce cas indique que nous parlons d'une liste vide dans laquelle la m√©moire n'est pas allou√©e.  Une liste peut √™tre, par opposition √† vide, une liste dans laquelle la m√©moire est allou√©e (occup√©e). </li><li>  <code>freelarge mSpanList</code> est une liste de structures mspan libres.  Le nombre de pages par √©l√©ment (c'est-√†-dire, mspan) est sup√©rieur √† 127. Pour prendre en charge cette liste, la structure de donn√©es mtreap est utilis√©e.  La liste des structures mspan occup√©es est appel√©e busylarge. </li></ul><br>  Les objets sup√©rieurs √† 32 Ko sont consid√©r√©s comme des objets volumineux, leur m√©moire est allou√©e directement √† partir de mheap.  Les demandes d'allocation de m√©moire pour de tels objets sont effectu√©es √† l'aide d'un verrou, par cons√©quent, √† un moment donn√©, une demande similaire peut √™tre trait√©e √† partir d'un seul processeur logique. <br><br><h2>  <font color="#3AC1EF">Processus d'allocation de m√©moire aux objets</font> </h2><br><ul><li>  Si la taille de l'objet d√©passe 32 Ko, il est consid√©r√© comme grand, la m√©moire pour lui est allou√©e directement √† partir de mheap. </li><li>  Si la taille de l'objet est inf√©rieure √† 16 Ko, le m√©canisme mcache appel√© allocateur minuscule est utilis√©. </li><li>  Si la taille de l'objet est comprise entre 16 et 32 ‚Äã‚ÄãKo, il s'av√®re que la classe de taille (sizeClass) √† utiliser, puis un bloc appropri√© est allou√© dans mcache. </li><li>  S'il n'y a pas de blocs disponibles dans la classe de taille correspondant √† mcache, mcentral est appel√©. </li><li>  Si mcentral n'a pas de blocs libres, alors ils appellent mheap et recherchent le mspan le plus appropri√©.  Si la taille de m√©moire requise par l'application s'av√®re sup√©rieure √† ce qu'il est possible d'allouer, la taille de m√©moire demand√©e sera trait√©e afin qu'il soit possible de renvoyer autant de pages que le programme le souhaite, apr√®s avoir form√© une nouvelle structure mspan. </li><li>  Si la m√©moire virtuelle de l'application n'est toujours pas suffisante, le syst√®me d'exploitation est accessible pour un nouvel ensemble de pages (au moins 1 Mo de m√©moire est requis). </li></ul><br>  En fait, au niveau du syst√®me d'exploitation, Go demande l'allocation de pi√®ces de m√©moire encore plus grandes appel√©es ar√®nes.  L'allocation simultan√©e de gros fragments de m√©moire vous permet de trouver un compromis entre la quantit√© de m√©moire allou√©e √† l'application et l'acc√®s co√ªteux au syst√®me d'exploitation en termes de performances. <br><br>  La m√©moire demand√©e sur le tas est allou√©e depuis l'ar√®ne.  Consid√©rez ce m√©canisme. <br><br><h2>  <font color="#3AC1EF">M√©moire virtuelle go</font> </h2><br>  Jetez un ≈ìil √† l'utilisation de la m√©moire avec un programme simple √©crit en Go: <br><br><pre> <code class="plaintext hljs">func main() {   for {} }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c33/4cd/dee/c334cddee46f32a66d3528b08deda48e.png"></div><br>  <i><font color="#999999">Informations sur le processus du programme</font></i> <br><br>  L'espace d'adressage virtuel d'un programme aussi simple est d'environ 100 Mo, tandis que l'index RSS n'est que de 696 Ko.  Tout d'abord, essayons de trouver la raison de cet √©cart. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f34/2a7/f41/f342a7f41d8ff7fbf3b5f081415c5ab4.png"></div><br>  <i><font color="#999999">Carte et informations sur la carte</font></i> <br><br>  Vous pouvez voir ici les zones de m√©moire, dont la taille est approximativement √©gale √† 2 Mo, 64 Mo, 32 Mo.  Quel genre de m√©moire est-ce? <br><br><h3>  <font color="#3AC1EF">‚ñçArena</font> </h3><br>  Il s'av√®re que la m√©moire virtuelle dans Go se compose d'un ensemble d'ar√®nes.  La taille de m√©moire initiale destin√©e au tas correspond √† une ar√®ne, soit - 64 Mo (ceci est pertinent pour Go 1.11.5). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9dd/17e/ba9/9dd17eba9a4c5acf9371052d62d902d9.png"></div><br>  <i><font color="#999999">Taille actuelle de l'ar√©na dans divers syst√®mes</font></i> <br><br>  En cons√©quence, la m√©moire n√©cessaire pour les besoins actuels du programme est allou√©e en petites portions.  Ce processus commence par une ar√®ne de 64 Mo. <br><br>  Ces indicateurs num√©riques dont nous parlons ici ne doivent pas √™tre pris pour certaines valeurs absolues et inchang√©es.  Ils peuvent changer.  Plus t√¥t, par exemple, Go avait r√©serv√© un espace virtuel continu √† l'avance, sur les syst√®mes 64 bits, la taille de l'ar√®ne √©tait de 512 Go (il est int√©ressant de penser √† ce qui se passe si la demande de m√©moire r√©elle est si importante que la demande correspondante sera rejet√©e par mmap?). <br><br>  En fait, nous appelons un tas d'ar√®nes un tas.  Dans Go, les ar√®nes sont per√ßues comme des fragments de m√©moire, divis√©s en blocs de 8192 octets (8 Ko). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55b/927/7e0/55b9277e0c55876b1bbf11bb1b869c9e.png"></div><br>  <i><font color="#999999">Une ar√®ne de 64 Mo</font></i> <br><br>  Go a quelques autres saveurs de blocs - span et bitmap.  La m√©moire pour eux est allou√©e en dehors du tas, ils stockent les m√©tadonn√©es de l'ar√®ne.  Ils sont principalement utilis√©s dans la collecte des ordures. <br>  Voici un aper√ßu g√©n√©ral du fonctionnement des m√©canismes d'allocation de m√©moire dans Go. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b01/61f/13f/b0161f13f6bc905731f0bfb339fd3a10.png"></div><br>  <i><font color="#999999">Aper√ßu g√©n√©ral des m√©canismes d'allocation de m√©moire dans Go</font></i> <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  En g√©n√©ral, on peut noter que dans ce document, nous avons d√©crit les sous-syst√®mes pour travailler avec la m√©moire Go en termes tr√®s g√©n√©raux.  L'id√©e principale du sous-syst√®me de m√©moire dans Go est d'allouer de la m√©moire en utilisant diff√©rentes structures et caches de diff√©rents niveaux.  Cela prend en compte la taille des objets auxquels la m√©moire est allou√©e. <br><br>  La repr√©sentation d'un seul bloc d'adresses de m√©moire continue re√ßues du syst√®me d'exploitation sous la forme d'une structure √† plusieurs niveaux augmente l'efficacit√© du m√©canisme d'allocation de m√©moire du fait que cette approche √©vite le blocage.  L'allocation des ressources, en tenant compte de la taille des objets qui doivent √™tre stock√©s en m√©moire, r√©duit la fragmentation et, apr√®s avoir lib√©r√© de la m√©moire, vous permet d'acc√©l√©rer le garbage collection. <br><br>  <b>Chers lecteurs!</b>  Avez-vous rencontr√© des probl√®mes dus √† un dysfonctionnement de la m√©moire dans les programmes √©crits en Go? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr442648/">https://habr.com/ru/post/fr442648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr442638/index.html">Mise √† l'√©chelle des applications Kubernetes bas√©e sur les m√©triques de Prometheus</a></li>
<li><a href="../fr442640/index.html">Bug parfait: utilisation de la confusion de types dans Flash. Partie 1</a></li>
<li><a href="../fr442642/index.html">Que lire en mars: 22 nouveaux livres pour les sp√©cialistes du marketing, les gestionnaires, les d√©veloppeurs et les concepteurs</a></li>
<li><a href="../fr442644/index.html">La plupart des comp√©tences hors programmation augmentent la valeur pour les d√©veloppeurs</a></li>
<li><a href="../fr442646/index.html">R√©seaux Kubernetes: Ingress</a></li>
<li><a href="../fr442650/index.html">Analyse et optimisation des applications React</a></li>
<li><a href="../fr442652/index.html">Utilisation de Fastify et de Preact pour prototyper rapidement des applications Web</a></li>
<li><a href="../fr442654/index.html">Passer √† Next.js et acc√©l√©rer 7,5 fois le chargement de la page d'accueil de manifold.co</a></li>
<li><a href="../fr442658/index.html">8 astuces pour travailler avec CSS: parallaxe, pied de page collant et autres</a></li>
<li><a href="../fr442660/index.html">Math√©matiques r√©conciliant Newton avec le monde quantique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>