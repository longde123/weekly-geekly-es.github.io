<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÑ üÜô üê≠ Flexibles System zum Testen und Sammeln von Programmmetriken am Beispiel der LLVM-Testsuite üì≤ üïô üë©üèæ‚Äçü§ù‚Äçüë®üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Die meisten Entwickler haben eindeutig von einigen ziemlich bedeutenden Open-Source-Entwicklungen wie dem LLVM-System und dem Clang-Compi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Flexibles System zum Testen und Sammeln von Programmmetriken am Beispiel der LLVM-Testsuite</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428421/"><h2>  Einf√ºhrung </h2><br>  Die meisten Entwickler haben eindeutig von einigen ziemlich bedeutenden Open-Source-Entwicklungen wie dem LLVM-System und dem Clang-Compiler geh√∂rt.  LLVM ist jetzt jedoch nicht nur das System selbst zum Erstellen von Compilern, sondern auch ein gro√ües √ñkosystem, das viele Projekte zur L√∂sung verschiedener Probleme umfasst, die in jeder Phase der Compilererstellung auftreten (normalerweise verf√ºgt jedes dieser Projekte √ºber ein eigenes Repository).  Ein Teil der Infrastruktur umfasst nat√ºrlich Test- und Benchmarking-Tools wie  Bei der Entwicklung eines Compilers ist seine Wirksamkeit ein sehr wichtiger Indikator.  Eines dieser einzelnen LLVM-Testinfrastrukturprojekte ist die Testsuite ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offizielle Dokumentation</a> ). <br><br><h2>  LLVM-Testsuite </h2><br>  Auf den ersten Blick scheint es, dass dies nur eine Reihe von Benchmarks in C / C ++ ist, aber dies ist nicht ganz richtig.  Neben dem Quellcode der Programme, an denen Leistungsmessungen durchgef√ºhrt werden, enth√§lt die Testsuite eine flexible Infrastruktur zum Erstellen, Ausf√ºhren und Sammeln von Metriken.  Standardm√§√üig werden die folgenden Metriken erfasst: Kompilierungszeit, Ausf√ºhrungszeit, Verkn√ºpfungszeit, Codegr√∂√üe (in Abschnitten). <br><a name="habracut"></a><br>  Die Testsuite ist nat√ºrlich n√ºtzlich zum Testen und Benchmarking von Compilern, kann aber auch f√ºr einige andere Forschungsaufgaben verwendet werden, bei denen eine C / C ++ - Codebasis erforderlich ist.  Diejenigen, die einmal versucht haben, etwas auf dem Gebiet der Datenanalyse zu tun, standen meines Erachtens vor dem Problem des Mangels und der Fragmentierung der Quelldaten.  Eine Testsuite besteht zwar nicht aus einer Vielzahl von Anwendungen, verf√ºgt jedoch √ºber einen einheitlichen Datenerfassungsmechanismus.  Das Hinzuf√ºgen eigener Anwendungen zur Sammlung und das Sammeln der f√ºr Ihre spezielle Aufgabe erforderlichen Metriken ist sehr einfach.  Daher ist meiner Meinung nach die Testsuite (zus√§tzlich zu den Hauptaufgaben des Testens und Benchmarking) eine gute Option f√ºr ein Basisprojekt, auf dessen Grundlage Sie Ihre eigene Datenerfassung f√ºr Aufgaben erstellen k√∂nnen, bei denen Sie einige Funktionen des Programmcodes oder einige Merkmale der Programme analysieren m√ºssen. <br><br><h3>  LLVM-Testsuite-Struktur </h3><br><pre><code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">test</span></span>-suite |----CMakeLists.txt //  CMake ,   ,  | //   .. | |---- cmake | |---- .modules //        , | //   API    | |---- litsupport //  Python,      <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>-suite, | //    lit (  LLVM) | |---- tools //   :    | //     (    | // ),    .. | | //     | |---- SingleSource //   ,       | // .        . | |---- MultiSource //   ,      | //  .        | //  . | |---- MicroBenchmarks // ,   google-benchmark.   | //  ,    ,  | //       | |---- External //    ,     <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>-suite,  | // ,     (  ) | // -   </code> </pre> <br>  Die Struktur ist einfach und unkompliziert. <br><br><h3>  Arbeitsprinzip </h3><br>  Wie Sie sehen k√∂nnen, sind CMake und ein spezielles Lit-Test-Format f√ºr alle Arbeiten zur Beschreibung der Zusammenstellung, des Starts und der Erfassung von Metriken verantwortlich. <br><br>  Wenn wir es sehr abstrakt betrachten, ist es klar, dass der Benchmarking-Prozess mit diesem System einfach und sehr vorhersehbar aussieht: <br><img src="https://habrastorage.org/webt/5p/ny/s8/5pnys8slvpcfavbmriofq4lymrs.jpeg"><br><br>  Wie sieht das genauer aus?  In diesem Artikel m√∂chte ich genau darauf eingehen, welche Rolle CMake im gesamten System spielt und welche einzige Datei Sie schreiben m√ºssen, wenn Sie diesem System etwas hinzuf√ºgen m√∂chten. <br><br>  <b>1. Erstellen von Testanwendungen.</b> <br><br>  Als Build-System ist es zum De-facto-Standard f√ºr C / C ++ - CMake-Programme geworden.  CMake konfiguriert das Projekt und generiert je nach Benutzereinstellung make-, ninja- usw. Dateien.  f√ºr den direkten Bau. <br>  In der Testsuite generiert CMake jedoch nicht nur Regeln zum Erstellen von Anwendungen, sondern konfiguriert auch die Tests selbst. <br><br>  Nach dem Starten von CMake werden weitere Dateien (mit der Erweiterung .test) in das Build-Verzeichnis geschrieben, in denen beschrieben wird, wie die Anwendung ausgef√ºhrt und auf Richtigkeit √ºberpr√ºft werden soll. <br><br>  Beispiel f√ºr die Standard-Testdatei <br><br><pre> <code class="cmake hljs">RUN: cd &lt;some_path_to_build_directory&gt;/MultiSource/Benchmarks/Prolangs-C/football ; &lt;some_path_to_build_directory&gt;/MultiSource/Benchmarks/Prolangs-C/football/football VERIFY: cd &lt;some_path_to_build_directory&gt;/MultiSource/Benchmarks/Prolangs-C/football ; &lt;some_path_to_build_directory&gt;/tools/fpcmp %o football.reference_output</code> </pre><br>  Die Datei mit der Erweiterung .test kann die folgenden Abschnitte enthalten: <br><br><ul><li>  PREPARE - beschreibt alle Aktionen, die vor dem Starten der Anwendung ausgef√ºhrt werden m√ºssen, sehr √§hnlich der Before-Methode, die in verschiedenen Unit-Test-Frameworks vorhanden ist. </li><li>  RUN - beschreibt, wie die Anwendung ausgef√ºhrt wird. </li><li>  VERIFY - beschreibt, wie der korrekte Betrieb der Anwendung √ºberpr√ºft wird. </li><li>  METRIC - beschreibt die Metriken, die im Standard zus√§tzlich erfasst werden m√ºssen. </li></ul><br>  Jeder dieser Abschnitte kann weggelassen werden. <br><br>  Da diese Datei jedoch automatisch generiert wird, wird in der CMake-Datei f√ºr den Benchmark beschrieben, wie die Objektdateien abgerufen, zu einer Anwendung zusammengesetzt und anschlie√üend mit dieser Anwendung gearbeitet werden. <br><br>  Betrachten Sie ein Beispiel f√ºr einige CMakeLists.txt, um das Standardverhalten und dessen Beschreibung besser zu verstehen <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">list</span></span>(APPEND CFLAGS -DBREAK_HANDLER -DUNICODE-pthread) <span class="hljs-comment"><span class="hljs-comment">#      (         ..     CMak,       ) list(APPEND LDFLAGS -lstdc++ -pthread) #      </span></span></code> </pre><br>  Flags k√∂nnen je nach Plattform gesetzt werden. Die DetectArchitecture-Datei ist in den cmake-Modulen der Testsuite enthalten. Diese bestimmt die Zielplattform, auf der die Benchmarks ausgef√ºhrt werden, sodass Sie einfach die bereits gesammelten Daten verwenden k√∂nnen.  Andere Daten sind ebenfalls verf√ºgbar: Betriebssystem, Bytereihenfolge usw. <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(TARGET_OS <span class="hljs-keyword"><span class="hljs-keyword">STREQUAL</span></span> <span class="hljs-string"><span class="hljs-string">"Linux"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>(APPEND CPPFLAGS -DC_LINUX) <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> ARCH <span class="hljs-keyword"><span class="hljs-keyword">STREQUAL</span></span> <span class="hljs-string"><span class="hljs-string">"ARM"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ENDIAN <span class="hljs-keyword"><span class="hljs-keyword">STREQUAL</span></span> <span class="hljs-string"><span class="hljs-string">"little"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>(APPEND CPPFLAGS -DFPU_WORDS_BIGENDIAN=<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ENDIAN <span class="hljs-keyword"><span class="hljs-keyword">STREQUAL</span></span> <span class="hljs-string"><span class="hljs-string">"big"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>(APPEND CPPFLAGS -DFPU_WORDS_BIGENDIAN=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span>()</code> </pre><br>  Grunds√§tzlich sollte dieser Teil nichts Neues f√ºr Personen sein, die mindestens einmal eine einfache CMake-Datei gesehen oder geschrieben haben.  Nat√ºrlich k√∂nnen Sie die Bibliotheken verwenden, sie selbst erstellen und im Allgemeinen alle von CMake bereitgestellten Mittel verwenden, um den Prozess der Erstellung Ihrer Anwendung zu beschreiben. <br><br>  Und dann m√ºssen Sie die Generierung der Testdatei sicherstellen.  Welche Tools bietet die tets-suite-Schnittstelle daf√ºr? <br><br>  Es gibt zwei grundlegende Makros <b>llvm_multisource</b> und <b>llvm_singlesource</b> , die f√ºr die meisten trivialen F√§lle ausreichen. <br><br><ul><li>  <b>llvm_multisource wird</b> verwendet, wenn die Anwendung aus mehreren Dateien besteht.  Wenn Sie die Quellcodedateien beim Aufrufen dieses Makros in Ihrem CMake nicht als Parameter √ºbergeben, werden alle Quellcodedateien im aktuellen Verzeichnis als Basis f√ºr die Erstellung verwendet.  Tats√§chlich finden derzeit √Ñnderungen an der Schnittstelle dieses Makros in der Testsuite statt, und die beschriebene Methode zum √úbertragen von Quelldateien als Makroparameter ist die aktuelle Version im Hauptzweig.  Zuvor gab es ein anderes System: Dateien mit Quellcode mussten in die Quellvariable geschrieben werden (wie in Release 7.0), und das Makro akzeptierte keine Parameter.  Die grundlegende Logik der Implementierung ist jedoch dieselbe geblieben. </li><li>  <b>llvm_singlesource</b> ber√ºcksichtigt, dass jede .c / .cpp-Datei ein separater Benchmark ist und f√ºr jede eine separate ausf√ºhrbare Datei sammelt. </li></ul><br>  Standardm√§√üig generieren beide oben beschriebenen Makros zum Starten einer erstellten Anwendung einen Befehl, der diese Anwendung einfach aufruft.  Die Korrektheitspr√ºfung erfolgt aufgrund des Vergleichs mit der erwarteten Ausgabe in der Datei mit der Erweiterung .reference_output (auch mit m√∂glichen Suffixen .reference_output.little-endian, .reference_output.big-endian). <br><br>  Wenn dies zu Ihnen passt, ist es einfach gro√üartig. Eine zus√§tzliche Zeile (Aufruf von llvm_multisource oder llvm_singlesource) reicht aus, um die Anwendung zu starten und die folgenden Metriken abzurufen: Codegr√∂√üe (in Abschnitten), Kompilierungszeit, Verbindungszeit, Ausf√ºhrungszeit. <br><br>  Aber das passiert nat√ºrlich selten so reibungslos.  M√∂glicherweise m√ºssen Sie eine oder mehrere Stufen √§ndern.  Und das ist auch mit einfachen Aktionen m√∂glich.  Das einzige, woran Sie sich erinnern m√ºssen, ist, dass Sie, wenn Sie eine Phase neu definieren, alle anderen beschreiben m√ºssen (auch wenn der Standardalgorithmus ihrer Arbeit passt, was nat√ºrlich ein wenig √§rgerlich ist). <br><br>  Die API enth√§lt Makros, mit denen Aktionen in jeder Phase beschrieben werden. <br><br>  <b>√úber</b> das Makro <b>llvm_test_prepare</b> f√ºr die Vorbereitungsphase <b>gibt es</b> nicht viel zu schreiben. Die Befehle, die Sie ausf√ºhren m√ºssen, werden dort einfach als Parameter √ºbergeben. <br><br>  Was k√∂nnte im Startabschnitt ben√∂tigt werden?  Der vorhersehbarste Fall ist, dass die Anwendung einige Argumente und Eingabedateien akzeptiert.  Dazu gibt es das Makro <b>llvm_test_run</b> , das nur die Anwendungsstartargumente (ohne den Namen der ausf√ºhrbaren Datei) als Parameter akzeptiert. <br><br><pre> <code class="cmake hljs">llvm_test_run(--fixed <span class="hljs-number"><span class="hljs-number">400</span></span> --cpu <span class="hljs-number"><span class="hljs-number">1</span></span> --num <span class="hljs-number"><span class="hljs-number">200000</span></span> --seed <span class="hljs-number"><span class="hljs-number">1158818515</span></span> run.hmm)</code> </pre><br>  Um die Aktionen in der Validierungsphase zu √§ndern, wird das Makro <b>llvm_test_verify verwendet</b> , das alle Befehle als Parameter akzeptiert.  Um die Richtigkeit zu √ºberpr√ºfen, ist es nat√ºrlich besser, die im Werkzeugordner enthaltenen Werkzeuge zu verwenden.  Sie bieten gute M√∂glichkeiten zum Vergleichen der generierten Ausgabe mit der erwarteten (es gibt eine separate Verarbeitung zum Vergleichen von reellen Zahlen mit Fehlern usw.).  Sie k√∂nnen aber irgendwo √ºberpr√ºfen, ob die Bewerbung erfolgreich abgeschlossen wurde usw. <br><br><pre> <code class="cmake hljs">llvm_test_verify(<span class="hljs-string"><span class="hljs-string">"cat %o | grep -q 'exit 0'"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># %o -   placeholder   ,   lit.          lit,    ,    .    lit (  ,   LLVM)      (   &lt;a href="https://llvm.org/docs/CommandGuide/lit.html"&gt; &lt;/a&gt;)</span></span></code> </pre><br>  Was aber, wenn zus√§tzliche Messdaten erfasst werden m√ºssen?  <b>Hierf√ºr</b> gibt es ein <b>llvm_test_metric-</b> Makro. <br><br><pre> <code class="cmake hljs">llvm_test_metric(METRIC &lt; &gt; &lt;,   &gt;)</code> </pre><br>  Beispielsweise kann f√ºr Dhrystone eine daf√ºr spezifische Metrik erhalten werden. <br><br><pre> <code class="cmake hljs">llvm_test_metric(METRIC dhry_score grep 'Dhrystones per Second' %o | awk '{print $<span class="hljs-number"><span class="hljs-number">4</span></span>}')</code> </pre><br>  Wenn Sie zus√§tzliche Metriken f√ºr alle Tests erfassen m√ºssen, ist diese Methode nat√ºrlich etwas unpraktisch.  Entweder m√ºssen Sie den Aufruf llvm_test_metric zu den √ºbergeordneten Makros hinzuf√ºgen, die von der Schnittstelle bereitgestellt werden, oder Sie k√∂nnen TEST_SUITE_RUN_UNDER (die CMake-Variable) und ein bestimmtes Skript verwenden, um Metriken zu erfassen.  Die Variable TEST_SUITE_RUN_UNDER ist sehr n√ºtzlich und kann beispielsweise zum Ausf√ºhren auf Simulatoren usw. verwendet werden.  Tats√§chlich wird ein Befehl geschrieben, der die Anwendung mit ihren Argumenten als Eingabe akzeptiert. <br><br>  Als Ergebnis erhalten wir einige CMakeLists.txt des Formulars <br><br><pre> <code class="cmake hljs"><span class="hljs-comment"><span class="hljs-comment">#       llvm_test_run(--fixed 400 --cpu 1 --num 200000 --seed 1158818515 run.hmm) llvm_test_verify("cat %o | grep -q 'exit 0'") llvm_test_metric(METRIC score grep 'Score' %o | awk '{print $4}') llvm_multisource() # llvm_multisource(my_application)   </span></span></code> </pre><br>  Die Integration erfordert keinen zus√§tzlichen Aufwand. Wenn die Anwendung bereits mit CMake erstellt wurde, k√∂nnen Sie in CMakeList.txt in der Testsuite das vorhandene CMake f√ºr die Assembly einbinden und einige einfache Makroaufrufe hinzuf√ºgen. <br><br>  <b>2. Ausf√ºhren von Tests</b> <br><br>  Als Ergebnis seiner Arbeit hat CMake eine spezielle Testdatei gem√§√ü der angegebenen Beschreibung erstellt.  Aber wie wird diese Datei ausgef√ºhrt? <br><br>  lit verwendet immer eine Konfigurationsdatei lit.cfg, die dementsprechend in der Testsuite vorhanden ist.  In dieser Konfigurationsdatei werden verschiedene Einstellungen zum Ausf√ºhren von Tests angegeben, einschlie√ülich des Formats ausf√ºhrbarer Tests.  Die Test-Suite verwendet ein eigenes Format, das sich im Ordner litsupport befindet. <br><br><pre> <code class="python hljs">config.test_format = litsupport.test.TestSuiteTest()</code> </pre> <br>  Dieses Format wird als Testklasse beschrieben, die vom standardm√§√üigen beleuchteten Test geerbt wurde und die Hauptmethode der Ausf√ºhrungsschnittstelle √ºberschreibt.  Wichtige Komponenten von litsupport ist auch eine Klasse mit einer Beschreibung des TestPlan-Testausf√ºhrungsplans, in der alle Befehle gespeichert sind, die in verschiedenen Phasen ausgef√ºhrt werden m√ºssen, und die Reihenfolge der Phasen kennen.  Um die erforderliche Flexibilit√§t zu gew√§hrleisten, wurden auch Module in die Architektur eingef√ºhrt, die die mutatePlan-Methode bereitstellen sollen, in der sie den Testplan √§ndern k√∂nnen. Sie f√ºhren lediglich eine Beschreibung der Sammlung der erforderlichen Metriken ein und f√ºgen zus√§tzliche Befehle zum Messen der Zeit zum Starten der Anwendung usw. hinzu.  Aufgrund dieser L√∂sung wird die Architektur gut erweitert. <br><br><img src="https://habrastorage.org/webt/a_/s4/6y/a_s46ygow0ah-bmfzx9jkezdysg.png"><br><br>  Ein Beispiel f√ºr die Testsuite der Testsuite (mit Ausnahme von Details in Form von TestContext-Klassen, verschiedenen beleuchteten Konfigurationen und den Tests selbst usw.) ist unten dargestellt. <br><br><img src="https://habrastorage.org/webt/5b/k9/1a/5bk91asgtn8ivhsr4pehhczdgrw.png"><br><br>  Leuchtet, wird der in der Konfigurationsdatei angegebene Testtyp ausgef√ºhrt.  TestSuiteTest analysiert die generierte CMake-Testdatei und erh√§lt eine Beschreibung der Hauptphasen.  Anschlie√üend werden alle gefundenen Module aufgerufen, um den aktuellen Testplan zu √§ndern. Der Start wird instrumentiert.  Anschlie√üend wird der empfangene Testplan ausgef√ºhrt: Sie werden in der Reihenfolge der Vorbereitung, des Starts und der Validierung ausgef√ºhrt.  Bei Bedarf kann eine Profilerstellung durchgef√ºhrt werden (wird von einem der Module hinzugef√ºgt, wenn w√§hrend der Konfiguration eine Variable festgelegt wurde, die auf die Notwendigkeit einer Profilerstellung hinweist).  Der n√§chste Schritt besteht darin, Metriken zu erfassen, die Funktionen zum Sammeln, die von Standardmodulen im Feld metric_collectors in TestPlan hinzugef√ºgt wurden, und anschlie√üend zus√§tzliche vom Benutzer in CMake beschriebene Metriken zu erfassen. <br><br>  <b>3. Ausf√ºhren der Testsuite</b> <br><br>  Es gibt zwei M√∂glichkeiten, die Testsuite auszuf√ºhren: <br><br><ul><li>  Manuell, d.h.  sequentieller Aufruf von Befehlen. <pre> <code class="bash hljs">cmake -DCMAKE_CXX_COMPILER:FILEPATH=clang++ -DCMAKE_C_COMPILER:FILEPATH=clang <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite <span class="hljs-comment"><span class="hljs-comment">#  make #   llvm-lit . -o &lt;output&gt; #  </span></span></code> </pre></li><li>  Verwenden von LNT (ein anderes System aus dem LLVM-√ñkosystem, mit dem Sie Benchmarks ausf√ºhren, Ergebnisse in der Datenbank speichern und die Ergebnisse in der Weboberfl√§che analysieren k√∂nnen).  LNT f√ºhrt innerhalb seines Testlaufteams die gleichen Schritte wie im vorherigen Absatz aus. <br><pre> <code class="bash hljs">lnt runtest <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite --sandbox SANDBOX --cc clang --cxx clang++ --<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite</code> </pre> </li></ul><br>  Das Ergebnis f√ºr jeden Test wird als angezeigt <br><br><pre> <code class="bash hljs">PASS: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite :: MultiSource/Benchmarks/Prolangs-C/football/football.test (m of n) ********** TEST <span class="hljs-string"><span class="hljs-string">'test-suite :: MultiSource/Benchmarks/Prolangs-C/football/football.test'</span></span> RESULTS ********** compile_time: 1.1120 exec_time: 0.0014 <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>: <span class="hljs-string"><span class="hljs-string">"38254c7947642d1adb9d2f1200dbddf7"</span></span> link_time: 0.0240 size: 59784 size..bss: 99800 ‚Ä¶ size..text: 37778 **********</code> </pre><br>  Die Ergebnisse verschiedener Starts k√∂nnen ohne LNT verglichen werden (obwohl dieses Framework gro√üartige M√∂glichkeiten zur Analyse von Informationen mit verschiedenen Tools bietet, aber eine separate √úberpr√ºfung erfordert), indem das in der Testsuite enthaltene Skript verwendet wird <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite/utils/compare.py results_a.json results_b.json</code> </pre> <br>  Ein Beispiel f√ºr den Vergleich der Codegr√∂√üe ein und desselben Benchmarks aus zwei Starts: mit den Flags -O3 und -Os <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite/utils/compare.py -m size SANDBOX1/build/O3.json SANDBOX/build/Os.json Tests: 1 Metric: size Program O3 Os diff <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite...langs-C/football/football.test 59784 47496 -20.6%</code> </pre><br><h2>  Fazit </h2><br>  Die Infrastruktur zum Beschreiben und Ausf√ºhren von in der Testsuite implementierten Benchmarks ist einfach zu verwenden und zu unterst√ºtzen, l√§sst sich gut skalieren und verwendet meiner Meinung nach im Prinzip ziemlich elegante L√∂sungen in ihrer Architektur, was die Testsuite nat√ºrlich zu einem sehr n√ºtzlichen Werkzeug f√ºr Entwickler macht Compiler sowie dieses System k√∂nnen f√ºr die Verwendung in einigen Datenanalyseaufgaben ge√§ndert werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428421/">https://habr.com/ru/post/de428421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428411/index.html">Technologie-Radar: Liste der Sprachen, Tools und Plattformen, die Lamodas H√§nde durchlaufen haben</a></li>
<li><a href="../de428413/index.html">K√ºhlsysteme in Selectel-Rechenzentren</a></li>
<li><a href="../de428415/index.html">√úbersicht √ºber den Cloud-Controller TP-Link Omada OC200</a></li>
<li><a href="../de428417/index.html">Maschinelles Lernen in MatLab / Octave: Beispiele f√ºr Algorithmen, die von Formeln unterst√ºtzt werden</a></li>
<li><a href="../de428419/index.html">Ziehen und wischen Sie in RecyclerView. Teil 2: Drag & Drop-Controller, Raster und benutzerdefinierte Animationen</a></li>
<li><a href="../de428423/index.html">Wie ein 34-Milliarden-Dollar-Deal zwischen IBM und Red Hat den IT-Markt ver√§ndern wird: Experten und Analysten</a></li>
<li><a href="../de428429/index.html">GOST R 34.10 elektronische Signatur von PDF-Dokumenten in der Office-Suite LibreOffice</a></li>
<li><a href="../de428431/index.html">Mehr als konzentrische Schichten</a></li>
<li><a href="../de428433/index.html">Private Pr√ºfungsanw√§lte</a></li>
<li><a href="../de428435/index.html">Was in PHP auf Russisch zu lesen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>