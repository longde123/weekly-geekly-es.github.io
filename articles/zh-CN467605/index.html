<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛂 👩‍🔬 👩🏻‍🎨 您只需要URL 🤷 👨🏾‍🏫 ☃️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="VKontakte用户每天交换100亿条消息。 他们互相发送照片，漫画，模因和其他附件。 我们将告诉您如何使用iOS应用程序使用URLProtocol上传图像，然后逐步了解如何实现自己的图像。 

 大约一年半之前，iOS VK应用程序中新消息部分的开发如火如荼。 这是完全用Swift编写的第一部分...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>您只需要URL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/467605/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/g6/l2/us/g6l2usvzzisf7ezfubycuyoty08.jpeg" alt="图片"></div><br>  VKontakte用户每天交换100亿条消息。 他们互相发送照片，漫画，模因和其他附件。 我们将告诉您如何使用iOS应用程序使用<b><code>URLProtocol</code></b>上传图像，然后逐步了解如何实现自己的图像。 <br><a name="habracut"></a><br> 大约一年半之前，iOS VK应用程序中新消息部分的开发如火如荼。 这是完全用Swift编写的第一部分。 它位于单独的模块<code>vkm</code> （VK消息）中，该模块对主应用程序的设备一无所知。 它甚至可以在单独的项目中运行-阅读和发送消息的基本功能将继续起作用。 在主应用程序中，消息控制器通过相应的“容器视图控制器”添加，以显示例如对话列表或对话中的消息。 <br><br> 消息是VKontakte移动应用程序中最受欢迎的部分之一，因此，它必须像时钟一样工作，这一点很重要。 在<code>messages</code>项目中，我们为每一行代码而战。 我们一直非常喜欢将消息内置到应用程序中的方式多么整洁，并且我们努力确保所有内容保持不变。 <br><br> 逐步用新功能填充了该部分，我们完成了以下任务：我们必须确保邮件中附带的照片首先显示在草稿中，然后在发送后在邮件的常规列表中显示。 我们可以仅添加一个模块以与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>PHImageManager</code></a>一起<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>PHImageManager</code></a> ，但是其他条件使该任务更加困难。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0l/7t/hm/0l7thmey5vyyonmpbt5wicd-vjm.gif" alt="图片"></div><br><br> 选择快照时，用户可以对其进行处理：应用滤镜，旋转，修剪等。在VK应用程序中，此类功能是在单独的<code>AssetService</code>组件中实现的。 现在有必要从消息项目中学习与他合作。 <br><br><blockquote> 好吧，任务很简单，我们会做的。 这大约是平均解决方案，因为存在很多差异。 我们采用协议，将其转储到消息中并开始用方法填充它。 我们添加到AssetService，修改协议并添加我们的缓存实现！ 粘度。 然后，我们将实现放入消息中，将其添加到可以使用所有这些功能的服务或管理器中，然后开始使用它。 同时，仍然有一位新的开发人员来，尽管他试图弄清所有问题，但他还是低声谴责了……（嗯，你知道的）。 同时，额头上出现汗水。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7i/ze/q8/7izeq8h2gkpsgj2qybfro74kobc.jpeg" alt="图片"></div><br></blockquote><br> 这个决定<i>不符合我们的喜好</i> 。 出现新的实体时，消息组件在使用<code>AssetService</code>图像时需要了解。 开发人员还需要做额外的工作来弄清楚该系统如何工作。 最后，还有一个指向主项目各组件的隐式链接，我们试图避免这些隐式链接，以便消息部分继续作为独立模块工作。 <br><br> 我想解决问题，以使该项目完全不了解选择哪种图片，如何存储图片，是否需要特殊的加载和渲染。 而且，我们已经具有从Internet下载常规图像的能力，只有它们不是通过附加服务下载的，而仅仅是通过<code>URL</code> 。 并且，实际上，两种图像之间没有区别。 只有一些存储在本地，而另一些存储在服务器上。 <br><br> 因此，我们提出了一个非常简单的想法：如果还可以学习通过<code>URL</code>加载本地资产怎么办？ 似乎只要按一下<s>Thanos的</s>手指，就可以解决我们所有的问题：您无需了解<code>AssetService</code>任何<code>AssetService</code> ，添加新的数据类型和徒劳地增加熵，学会加载新型图像，处理数据缓存。 听起来像是一个计划。 <br><br><h2> 我们只需要一个URL </h2><br> 我们考虑了这个想法，并决定定义用于加载本地资产的<code>URL</code>格式： <br><br><pre> <code class="json hljs">asset://?id=<span class="hljs-number"><span class="hljs-number">123</span></span>&amp;width=<span class="hljs-number"><span class="hljs-number">1920</span></span>&amp;height=<span class="hljs-number"><span class="hljs-number">1280</span></span></code> </pre> <br> 我们将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>localIdentifier</code></a>属性的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>localIdentifier</code></a>用作<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>PHObject</code></a> ，并将传递<code>width</code>和<code>height</code>参数以加载所需大小的图像。 我们还添加了一些其他参数，例如<code>crop</code> ， <code>filter</code> ， <code>rotate</code> ，这将使您能够处理已处理图像的信息。 <br><br> 为了处理这些<code>URL</code>我们将创建一个<code>AssetURLProtocol</code> ： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AssetURLProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLProtocol</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br> 它的任务是通过<code>AssetService</code>加载图像，并返回已经准备好使用的数据。 <br><br> 所有这些将使我们几乎可以完全委托<code>URL</code>协议和<code>URL Loading System</code> 。 <br><br> 在消息内部，可以使用最常见的<code>URL</code> （仅以不同的格式）进行操作。 还可以重用现有的机制来加载图像，在数据库中序列化非常简单，并通过标准<code>URLCache</code>实现数据缓存。 <br><br> 奏效了吗？ 如果您在阅读本文时可以将图库中的照片附加到VKontakte应用程序上的消息中，则可以:) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bm/6j/tb/bm6jtb7mkd489czjvwhzpy-dpo0.jpeg" alt="图片"></div><br> 为了清楚说明如何实现<code>URLProtocol</code> ，我建议通过一个示例来考虑这一点。 <br><br> 我们为自己设定了任务：使用列表实现一个简单的应用程序，您需要在该列表中显示给定坐标处的地图快照列表。 要下载快照，我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>MKMapSnapshotter</code></a>的标准<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>MapKit</code></a> ，并将通过自定义<code>URLProtocol</code>加载数据。 结果可能如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l1/bg/s8/l1bgs8g0xzehoxt49oddmmtbuoe.gif" alt="图片"></div><br> 首先，我们实现了通过<code>URL</code>加载数据的机制。 要显示地图快照，我们需要知道点的坐标-它的纬度和经度（ <code>latitude</code> ， <code>longitude</code> ）。 定义我们要用来加载信息的定制<code>URL</code>格式： <br><br><pre> <code class="json hljs">map://?latitude=<span class="hljs-number"><span class="hljs-number">59.935634</span></span>&amp;longitude=<span class="hljs-number"><span class="hljs-number">30.325935</span></span></code> </pre> <br> 现在，我们实现<code>URLProtocol</code> ，它将处理此类链接并生成所需的结果。 让我们创建<code>MapURLProtocol</code>类，该类<code>URLProtocol</code>基类<code>URLProtocol</code>继承。 尽管名称， <code>URLProtocol</code>还是一个抽象类。 别为难，这里我们使用其他概念<code>URLProtocol</code>表示<code>URL</code>协议，与OOP术语无关。 所以<code>MapURLProtocol</code> ： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapURLProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLProtocol</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br> 现在，我们重新定义一些必需的方法，没有这些方法， <code>URL</code>协议将无法使用： <br><br><h3>  1. <code>canInit(with:)</code> </h3><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">canInit</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequest</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bool</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.url?.scheme == <span class="hljs-string"><span class="hljs-string">"map"</span></span> }</code> </pre> <br> 需要<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>canInit(with:)</code></a>方法来指示我们的<code>URL</code>协议可以处理哪些类型的请求。 对于此示例，假设协议仅处理<code>URL</code>具有<code>map</code>方案的请求。 在开始任何请求之前，“ <code>URL Loading System</code>将通过为该会话注册的所有协议并调用此方法。 第一个注册的协议（在此方法中将返回<code>true</code> ）将用于处理请求。 <br><br><h4>  <code>canonicalRequest(for:)</code> </h4><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">canonicalRequest</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">for</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequest</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>canonicalRequest(for:)</code></a>方法旨在将请求减少为规范形式。 该文档说，协议本身的实现决定了该概念的定义。 在这里，您可以规范化方案，如有必要，可以向请求中添加标头，等等。此方法起作用的唯一要求是，对于每个传入请求，总应具有相同的结果，包括因为此方法还用于搜索缓存的答案<code>URLCache</code>请求。 <br><br><h4>  3. <code>startLoading()</code> </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>startLoading()</code></a>方法描述了用于加载必要数据的所有逻辑。 在此示例中，您需要解析请求<code>URL</code>并基于其<code>latitude</code>和<code>longitude</code>参数的值，转到<code>MKMapSnapshotter</code>并加载所需的地图快照。 <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> components = <span class="hljs-type"><span class="hljs-type">URLComponents</span></span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queryItems = components.queryItems <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fail(with: .badURL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } load(with: queryItems) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with queryItems: [URLQueryItem])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snapshotter = <span class="hljs-type"><span class="hljs-type">MKMapSnapshotter</span></span>(queryItems: queryItems) snapshotter.start( with: <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.global(qos: .background), completionHandler: handle ) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(snapshot: MKMapSnapshotter.Snapshot?, error: Error?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snapshot = snapshot, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = snapshot.image.jpegData(compressionQuality: <span class="hljs-number"><span class="hljs-number">1</span></span>) { complete(with: data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error { fail(with: error) } }</code> </pre> <br> 收到数据后，有必要正确关闭协议： <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with data: Data)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> client = client <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response = <span class="hljs-type"><span class="hljs-type">URLResponse</span></span>( url: url, mimeType: <span class="hljs-string"><span class="hljs-string">"image/jpeg"</span></span>, expectedContentLength: data.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>, textEncodingName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ) client.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didReceive: response, cacheStoragePolicy: .allowed) client.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didLoad: data) client.urlProtocolDidFinishLoading(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) }</code> </pre> <br> 首先，创建<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>URLResponse</code></a>类型的对象。 该对象包含用于响应请求的重要元数据。 然后，我们对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>URLProtocolClient</code></a>类型的对象执行三种重要的方法。 此类型的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>client</code></a>属性包含<code>URL</code>协议的每个实体。 它充当<code>URL</code>协议和<code>URL Loading System</code>的整个<code>URL Loading System</code>之间的代理，当调用这些方法时，该代理得出有关数据需要完成的结论：缓存，将请求发送到<code>completionHandler</code> ，以某种方式处理协议关闭等。并且这些方法的调用次数可能会根据协议的实现而有所不同。 例如，我们可以批量从网络下载数据，并定期通知<code>URLProtocolClient</code>以显示界面中数据加载的进度。 <br><br> 如果协议的操作中发生错误，则还必须正确处理并通知<code>URLProtocolClient</code> ： <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with error: Error)</span></span></span></span> { client?.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didFailWithError: error) }</code> </pre> <br> 正是这个错误，然后将其发送到请求的<code>completionHandler</code>处理程序，可以在其中进行处理并向用户显示优美的消息。 <br><br><h4>  4. <code>stopLoading()</code> </h4><br> 当协议操作由于某种原因而完成时，将调用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>stopLoading()</code></a>方法。 这可以是成功完成，也可以是错误完成或请求取消。 这是释放占用的资源或删除临时数据的好地方。 <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stopLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { }</code> </pre> <br> 这样就完成了<code>URL</code>协议的实现；可以在应用程序中的任何位置使用它。 要在哪里应用我们的协议，请添加更多内容。 <br><br><h4> <code>URLImageView</code> </h4> <br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLImageView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIImageView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task: <span class="hljs-type"><span class="hljs-type">URLSessionDataTask?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> taskId: <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url: URL)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(task == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || task?.taskIdentifier != taskId) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(url: url) task = session.dataTask(with: request, completionHandler: complete) taskId = task?.taskIdentifier task?.resume() } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data: Data?, response: URLResponse?, error: Error?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.taskId == task?.taskIdentifier, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = data, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> image = <span class="hljs-type"><span class="hljs-type">UIImage</span></span>(data: data) { didLoadRemote(image: image) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didLoadRemote</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image: UIImage)</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.main.async { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.image = image } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareForReuse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { task?.cancel() taskId = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> image = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br> 这是一个简单的类，它是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>UIImageView</code></a>的后代，它可能在任何应用程序中都具有类似的实现。 在这里，我们只是通过<code>render(url:)</code>方法中的<code>URL</code>加载图像并将其写入<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>image</code></a>属性。 方便之处在于，您可以通过<code>http</code> / <code>https</code> <code>URL</code>或我们的自定义<code>URL</code>上传任何图像。 <br><br> 要执行加载图像的请求，您还需要一个<code>URLSession</code>类型的对象： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> config: <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span>.ephemeral <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.protocolClasses = [ <span class="hljs-type"><span class="hljs-type">MapURLProtocol</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> }() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> session = <span class="hljs-type"><span class="hljs-type">URLSession</span></span>( configuration: config, delegate: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, delegateQueue: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> )</code> </pre> <br> 会话配置在这里尤为重要。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>URLSessionConfiguration</code></a> ，us的一个重要属性是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>protocolClasses</code></a> 。 这是具有此配置的会话可以处理的<code>URL</code>协议类型的列表。 默认情况下，会话支持处理<code>http</code> / <code>https</code>协议，如果需要自定义支持，则必须指定它们。 对于我们的示例，指定<code>MapURLProtocol</code> 。 <br><br> 剩下要做的就是实现视图控制器，它将显示地图快照。 它的源代码可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>找到。 <br><br> 结果如下： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/gf/c8/edgfc8crekglljfq33hfggic520.gif" alt="图片"></div><br><h2> 缓存呢？ </h2><br> 一切似乎都运行良好-除了一个重要点：当我们前后滚动列表时，屏幕上会出现白点。 似乎快照没有以任何方式缓存，并且对于<code>render(url:)</code>方法的每次调用，我们都通过<code>MKMapSnapshotter</code>数据。 这需要时间，因此在装载方面存在间隙。 值得实施一种数据缓存机制，以便不再下载已创建的快照。 在这里，我们使用<code>URL Loading System</code> ，该<code>URL Loading System</code>已经具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>URLCache</code></a>提供的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>URLCache</code></a>缓存机制。 <br><br> 更详细地考虑此过程，并将缓存的工作分为两个重要阶段：读取和写入。 <br><br><h3> 读书 </h3><br> 为了正确读取缓存的数据， <code>URL Loading System</code>的<code>URL Loading System</code>需要获得一些重要问题的答案的帮助： <br><br>  <b>1.使用什么URLCache？</b> <br><br> 当然， <code>URLCache.shared</code>已经完成，但是<code>URL Loading System</code>的<code>URL Loading System</code>不能总是使用它-毕竟，开发人员可能想要创建并使用自己的<code>URLCache</code>实体。 为了回答这个问题， <code>URLSessionConfiguration</code>会话<code>URLSessionConfiguration</code>具有<code>urlCache</code>属性。 它用于读取和记录对请求的响应。  <code>URLCache</code> ，我们将在现有配置中<code>URLCache</code>一些<code>URLCache</code> 。 <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> config: <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span>.ephemeral <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.urlCache = <span class="hljs-type"><span class="hljs-type">ImageURLCache</span></span>.current <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.protocolClasses = [ <span class="hljs-type"><span class="hljs-type">MapURLProtocol</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> }()</code> </pre> <br>  <b>2.我需要使用缓存的数据还是再次下载？</b> <br><br> 这个问题的答案取决于我们将要执行的<code>URLRequest</code>请求。 创建请求时，除了<code>URL</code>之外，我们还可以在<code>cachePolicy</code>参数中指定一个缓存策略。 <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>( url: url, cachePolicy: .returnCacheDataElseLoad, timeoutInterval: <span class="hljs-number"><span class="hljs-number">30</span></span> )</code> </pre> <br> 默认值为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>.useProtocolCachePolicy</code></a> ，该值也写在文档中。 这意味着在此版本中，查找对请求的缓存响应并确定其相关性的任务完全在于<code>URL</code>协议的实现。 但是，有一种更简单的方法。 如果设置值<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>.returnCacheDataElseLoad</code></a> ，则在创建下一个实体<code>URLProtocol</code> <code>URL Loading System</code>将承担一些工作：它将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>cachedResponse(for:)</code></a>方法向<code>urlCache</code>询问对当前请求<code>urlCache</code>缓存响应。 如果存在缓存的数据，则将在初始化<code>URLProtocol</code>立即传输类型为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>CachedURLResponse</code></a>的对象，并将其存储在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>cachedResponse</code></a>属性中： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>( request: <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>, cachedResponse: <span class="hljs-type"><span class="hljs-type">CachedURLResponse?</span></span>, client: <span class="hljs-type"><span class="hljs-type">URLProtocolClient?</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>( request: request, cachedResponse: cachedResponse, client: client ) }</code> </pre> <br>  <code>CachedURLResponse</code>是一个简单的类，其中包含数据（ <code>Data</code> ）和元<code>Data</code>信息（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>URLResponse</code></a> ）。 <br><br> 我们只能<code>startLoading</code>更改一下<code>startLoading</code>方法并检查其中的该属性的值，然后立即使用以下数据结束协议： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cachedResponse = cachedResponse { complete(with: cachedResponse.data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> components = <span class="hljs-type"><span class="hljs-type">URLComponents</span></span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queryItems = components.queryItems <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fail(with: .badURL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } load(with: queryItems) } }</code> </pre> <br><h3> 记录 </h3><br> 要在缓存中查找数据，您需要将其放置在缓存中。  <code>URL Loading System</code>也负责这项工作。 我们所要做的就是告诉她我们要使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>cacheStoragePolicy</code></a>缓存策略<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>cacheStoragePolicy</code></a>在协议<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>cacheStoragePolicy</code></a>时缓存数据。 这是具有以下值的简单枚举： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StoragePolicy</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> allowed <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> allowedInMemoryOnly <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> notAllowed }</code> </pre> <br> 它们意味着允许在内存和磁盘中缓存，仅在内存中或禁止缓存。 在我们的示例中，我们指出允许在内存和磁盘中进行缓存，因为为什么不这样做。 <br><br><pre> <code class="swift hljs">client.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didReceive: response, cacheStoragePolicy: .allowed)</code> </pre> <br> 因此，通过执行一些简单的步骤，我们支持了缓存地图快照的功能。 现在，该应用程序的工作方式如下： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l1/bg/s8/l1bgs8g0xzehoxt49oddmmtbuoe.gif" alt="图片"></div><br> 如您所见，没有更多的白点-卡被加载一次，然后可以从缓存中简单地重用。 <br><br><h2> 并不总是那么容易 </h2><br> 在实施<code>URL</code>协议时，我们遇到了一系列崩溃。 <br><br> 第一个与在缓存对请求的响应时<code>URL Loading System</code>与<code>URLCache</code>的内部实现有关。 该文档<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">指出</a> ：尽管<code>URLCache</code>具有<code>URLCache</code>安全性， <code>URLCache</code>用于读取/写入对请求的响应的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>cachedResponse(for:)</code></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>storeCachedResponse(_:for:)</code></a>方法的操作可能导致状态竞争，因此， <code>URLCache</code>子类中应考虑这一点。 我们期望使用<code>URLCache.shared</code>可以解决此问题，但事实证明这是错误的。 为了解决这个问题，我们使用了一个单独的<code>ImageURLCache</code>缓存（ <code>URLCache</code>的后代），在该缓存中，我们在一个单独的队列上同步执行指定的方法。 令人高兴的是，我们可以与其他<code>URLCache</code>实体分别配置内存和磁盘上的缓存容量。 <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> accessQueue = <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>( label: <span class="hljs-string"><span class="hljs-string">"image-urlcache-access"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cachedResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: URLRequest)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CachedURLResponse?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ImageURLCache</span></span>.accessQueue.sync { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.cachedResponse(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: request) } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">storeCachedResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> response: CachedURLResponse, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: URLRequest)</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">ImageURLCache</span></span>.accessQueue.sync { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.storeCachedResponse(response, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: request) } }</code> </pre> <br> 另一个问题仅在具有iOS 9的设备上重现。用于开始和结束<code>URL</code>协议加载的方法可以在不同的线程上执行，这可能导致罕见但令人不愉快的崩溃。 为了解决该问题，我们将当前线程保存在<code>startLoading</code>方法中，然后直接在该线程上执行下载完成代码。 <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread: <span class="hljs-type"><span class="hljs-type">Thread!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> components = <span class="hljs-type"><span class="hljs-type">URLComponents</span></span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queryItems = components.queryItems <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fail(with: .badURL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } thread = <span class="hljs-type"><span class="hljs-type">Thread</span></span>.current <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cachedResponse = cachedResponse { complete(with: cachedResponse) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { load(request: request, url: url, queryItems: queryItems) } }</code> </pre> <br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(snapshot: MKMapSnapshotter.Snapshot?, error: Error?)</span></span></span></span> { thread.execute { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snapshot = snapshot, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = snapshot.image.jpegData(compressionQuality: <span class="hljs-number"><span class="hljs-number">0.7</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.complete(with: data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fail(with: error) } } }</code> </pre> <br><h2> 什么时候可以使用URL协议？ </h2><br> 结果，几乎我们iOS应用程序的每个用户都以一种或另一种方式遇到通过<code>URL</code>协议起作用的元素。 除了从图库中下载媒体外， <code>URL</code>协议的各种实现方式还可以帮助我们显示地图和民意调查，以及显示由参与者照片组成的聊天头像。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5v/jz/sl/5vjzsliedpi6l9qt6qhnaloi1l8.jpeg" alt="图片"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p0/g4/rz/p0g4rzbdjqqbx3oc-ochol6ilwy.jpeg" alt="图片"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n4/1e/mb/n41embtawargx2zofdmevlyq_nk.jpeg" alt="图片"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j4/dn/gj/j4dngjkluh5gyxb3od9vwkse9zu.jpeg" alt="图片"></div><br> 像任何解决方案一样， <code>URLProtocol</code>也有其优点和缺点。 <br><br><h3>  <code>URLProtocol</code>缺点 </h3><br><ul><li>  <b>缺乏严格的键入</b> -创建<code>URL</code>方案和链接参数是通过字符串手动指定的。 如果输入错误，则不会处理所需的参数。 这会使应用程序的调试和在其操作中查找错误的过程变得复杂。 在VKontakte应用程序中，我们使用特殊的<code>URLBuilder</code> ，它们根据传递的参数形成最终的<code>URL</code> 。 这个决定不是很漂亮，并且与不生产其他实体的目标有些矛盾，但是还没有更好的主意。 但是我们知道，如果您需要创建某种自定义<code>URL</code> ，那么可以肯定有一个特殊的<code>URLBuilder</code>可以帮助您避免犯错。 </li><li>  <b>非显而易见的崩溃</b> -我已经描述了几种可能导致使用<code>URLProtocol</code>的应用程序崩溃的情况。 也许还有其他。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 但是，像往常一样，这些问题可以通过更仔细地阅读文档或通过深入研究堆栈跟踪并找到问题的根源来解决。 </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> URLProtocol的好处 </font></font></h3><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弱组件连通性</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -应用程序中启动其所需数据加载的部分可能根本不知道其组织方式：为此使用了哪些组件，如何安排缓存。</font><font style="vertical-align: inherit;">我们只知道某种格式</font></font><code>URL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且只能与之交互。</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实现的简单性</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -为了正确执行</font></font><code>URL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">协议，只需执行几种简单的方法并注册协议即可。</font><font style="vertical-align: inherit;">之后，可以在应用程序中的任何位置使用它。</font></font></li><li> <b>  </b> —       ,      ,   <code>URL</code> -.       <code>URL</code> , <code>URLSession</code> , <code>URLSessionDataTask</code> . </li><li> <b> </b> —    <code>URL</code> -   <code>URL</code> -,             <code>URL Loading System</code> . </li><li> <b>*  API</b> —      .     ,        API,   -  ,   <code>URL</code> -.       ,       API         ,  .         <code>URL</code> -      <code>http</code> / <code>https</code> . </li></ul><br> <code>URL</code> - —         .      .  -   ,   -    ,   ,    , —  ,      .  ,     , —  <code>URL</code> . <br><br> <b>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  GitHub</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN467605/">https://habr.com/ru/post/zh-CN467605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN467591/index.html">新证明解决了pi等数字的近似问题</a></li>
<li><a href="../zh-CN467593/index.html">（不相关，已修复）注意。 Tele2如何共享对新订户个人帐户的访问权限</a></li>
<li><a href="../zh-CN467595/index.html">穿越Selectel数据中心。 《恐龙大战》，VMware，C2F5H和“隐形狼人”</a></li>
<li><a href="../zh-CN467597/index.html">使用Vowpal Wabbit个性化大数据产品指南</a></li>
<li><a href="../zh-CN467599/index.html">使用OpenGL进行3D图形渲染</a></li>
<li><a href="../zh-CN467607/index.html">码头工人的自白</a></li>
<li><a href="../zh-CN467609/index.html">在React Native上创建移动应用程序</a></li>
<li><a href="../zh-CN467611/index.html">图像轮廓检测算法</a></li>
<li><a href="../zh-CN467615/index.html">如何创建Python包装器而不会发疯</a></li>
<li><a href="../zh-CN467617/index.html">Kaspresso：您正在等待的自动测试框架</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>