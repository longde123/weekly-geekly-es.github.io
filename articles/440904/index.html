<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßóüèø üò¥ üë®üèº‚ÄçüöÄ Comparaci√≥n de las arquitecturas Viper y MVVM: c√≥mo aplicar ambas üôâ üê∑ üìÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Actualmente, VIPER y MVVM son las soluciones arquitect√≥nicas m√°s populares utilizadas en el desarrollo de grandes aplicaciones que requieren la partic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comparaci√≥n de las arquitecturas Viper y MVVM: c√≥mo aplicar ambas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440904/"><img src="https://habrastorage.org/webt/db/bn/4z/dbbn4zxc39qxt6vtlimqyjql5ko.jpeg"><br><br>  Actualmente, VIPER y MVVM son las soluciones arquitect√≥nicas m√°s populares utilizadas en el desarrollo de grandes aplicaciones que requieren la participaci√≥n en el desarrollo de grandes equipos que est√°n bien probados, respaldados a largo plazo y en constante evoluci√≥n.  En este art√≠culo intentaremos aplicarlos en un peque√±o proyecto de prueba, que es una lista de contactos de usuarios con la capacidad de agregar un nuevo contacto.  Este art√≠culo tiene m√°s pr√°ctica que an√°lisis, y est√° dirigido principalmente a aquellos que ya est√°n en teor√≠a familiarizados con estas arquitecturas y ahora quisieran entender c√≥mo funciona esto con ejemplos espec√≠ficos.  Sin embargo, una descripci√≥n b√°sica de las arquitecturas y su comparaci√≥n tambi√©n est√° presente. <br><a name="habracut"></a><br><br>  Este art√≠culo es una traducci√≥n del art√≠culo de Rafael Sacchi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Comparaci√≥n de las arquitecturas MVVM y Viper: cu√°ndo usar una u otra"</a> .  Desafortunadamente, en alg√∫n momento de la creaci√≥n del art√≠culo, se cre√≥ "publicaci√≥n" en lugar de "traducci√≥n", por lo que debe escribir aqu√≠. <br><br>  Una arquitectura bien dise√±ada es esencial para garantizar un soporte continuo para su proyecto.  En este art√≠culo, veremos las arquitecturas MVVM y VIPER como una alternativa al MVC tradicional. <br><br>  MVC es un concepto bien conocido para todos aquellos que han estado involucrados en el desarrollo de software durante bastante tiempo.  Este patr√≥n divide el proyecto en tres partes: modelo que representa entidades;  Ver, que es una interfaz para la interacci√≥n del usuario;  y Controlador, responsable de garantizar la interacci√≥n entre Vista y Modelo.  Esta es la arquitectura que Apple nos ofrece para usar en nuestras aplicaciones. <br><br>  Sin embargo, probablemente sepa que los proyectos vienen con una funcionalidad bastante compleja: soporte para solicitudes de red, an√°lisis, acceso a modelos de datos, conversi√≥n de datos para salida, reacci√≥n a eventos de interfaz, etc.  Como resultado, obtienes enormes controladores que resuelven los problemas anteriores y un mont√≥n de c√≥digo que no se puede reutilizar.  En otras palabras, MVC puede ser una pesadilla para un desarrollador con soporte de proyectos a largo plazo.  Pero, ¬øc√≥mo garantizar una alta modularidad y reutilizaci√≥n en proyectos de iOS? <br><br>  Veremos dos alternativas muy famosas a la arquitectura MVC: MVVM y VIPER.  Ambos son bastante famosos en la comunidad iOS y han demostrado que pueden ser una gran alternativa a MVC.  Hablaremos sobre su estructura, escribiremos una aplicaci√≥n de ejemplo y consideraremos casos en los que es mejor usar una u otra arquitectura. <br><br>  <b>Ejemplo</b> <br><br>  Escribiremos una aplicaci√≥n con una tabla de contactos de usuarios.  Puede usar el c√≥digo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este repositorio</a> .  En las carpetas de inicio, el esqueleto b√°sico del proyecto est√° contenido, y en las carpetas finales hay una aplicaci√≥n completamente terminada. <br><br>  La aplicaci√≥n tendr√° dos pantallas: en la primera se mostrar√° una lista de contactos en forma de tabla, la celda tendr√° el nombre y el apellido del contacto, as√≠ como la imagen base en lugar de la imagen del usuario. <br><br><img src="https://habrastorage.org/webt/gn/kc/ww/gnkcwwblrc7b036fyvuz874zfpu.png"><br><br>  La segunda pantalla es la pantalla para agregar un nuevo contacto, con los campos de entrada de nombre y apellido y los botones Listo y Cancelar. <br><br><img src="https://habrastorage.org/webt/rx/b1/mv/rxb1mvegb0piorji2dovggxdj8q.png"><br><br>  <b>MVVM</b> <br><br>  C√≥mo funciona <br><br>  MVVM significa <b>Model-View-ViewModel</b> .  Este enfoque difiere de MVC en la l√≥gica de distribuci√≥n de responsabilidad entre m√≥dulos. <br><br><ul><li>  <b>Modelo</b> : este m√≥dulo no es diferente al de MVC.  Es responsable de crear modelos de datos y puede contener l√≥gica de negocios.  Tambi√©n puede crear clases auxiliares, por ejemplo, como una clase de administrador para administrar objetos en Model y el administrador de red para procesar solicitudes de red y an√°lisis. </li><li>  <b>Ver</b> : Y aqu√≠ todo comienza a cambiar.  El m√≥dulo View en MVVM cubre la interfaz (subclases de archivos UIView, .xib y .storyboard), la l√≥gica de visualizaci√≥n (animaci√≥n, renderizado) y el manejo de eventos del usuario (clics de botones, etc.) En MVC, View y Controller son responsables de esto.  Esto significa que las vistas que tiene permanecer√°n sin cambios, mientras que ViewController contendr√° una peque√±a parte de lo que hab√≠a en MVC y, en consecuencia, disminuir√° considerablemente. </li><li>  <b>ViewModel</b> : ahora es el lugar donde se <b>ubicar√°</b> la mayor parte del c√≥digo que ten√≠a anteriormente en ViewController.  La capa ViewModel solicita datos del Modelo (puede ser una solicitud a una base de datos local o una solicitud de red) y los transfiere nuevamente a la Vista, en el formato en el que se utilizar√° y se mostrar√° all√≠.  Pero este es un mecanismo bidireccional, las acciones o los datos ingresados ‚Äã‚Äãpor el usuario pasan a trav√©s del ViewModel y actualizan el Modelo.  Dado que ViewModel realiza un seguimiento de todo lo que se muestra, es √∫til utilizar el mecanismo de enlace entre las dos capas. </li></ul><br><br>  En comparaci√≥n con MVC, se est√° moviendo de una arquitectura que se ve as√≠: <br><br><img src="https://habrastorage.org/webt/op/i7/gq/opi7gqlutejiwvehje5zoeey96k.jpeg"><br><br>  Para el pr√≥ximo varant de arquitectura: <br><br><img src="https://habrastorage.org/webt/zu/me/cj/zumecj56yf5vgzckbhjdarwx58i.png"><br><br>  En el que las clases y subclases de UIView y UIViewController se utilizan para implementar la Vista. <br><br>  Bueno, ahora al grano.  Escribamos un ejemplo de nuestra aplicaci√≥n usando la arquitectura MVVM. <br><br>  <b>Aplicaci√≥n de contactos MVVM</b> <br><br>  <b>MODELO</b> <br><br>  La siguiente clase es un modelo de <b>contacto de</b> contacto: <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CoreData open class Contact: NSManagedObject { @NSManaged var firstName: String? @NSManaged var lastName: String? var fullName: String { get { var name = "" if let firstName = firstName { name += firstName } if let lastName = lastName { name += " \(lastName)" } return name } } }</code> </pre> <br><br>  La clase de contacto tiene los campos <i>firstName</i> , <i>lastName</i> , as√≠ como la propiedad calculada <i>fullName</i> . <br><br>  <b>VER</b> <br><br>  VIEW incluye: Storyboard principal, con vistas ya colocadas en √©l;  ContactsViewController, que muestra una lista de contactos en una tabla;  y AddContactViewController con un par de etiquetas y campos de entrada para agregar el nombre y el apellido del nuevo contacto.  Comencemos con el <b>ContactsViewController</b> .  Su c√≥digo se ver√° as√≠: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactsViewController: UIViewController { @IBOutlet var tableView: UITableView! let contactViewModelController = ContactViewModelController() override func viewDidLoad() { super.viewDidLoad() tableView.tableFooterView = UIView() contactViewModelController.retrieveContacts({ [unowned self] in self.tableView.reloadData() }, failure: nil) } override func prepare(for segue: UIStoryboardSegue, sender: Any?) { let addContactNavigationController = segue.destination as? UINavigationController let addContactVC = addContactNavigationController?.viewControllers[0] as? AddContactViewController addContactVC?.contactsViewModelController = contactViewModelController addContactVC?.didAddContact = { [unowned self] (contactViewModel, index) in let indexPath = IndexPath(row: index, section: 0) self.tableView.beginUpdates() self.tableView.insertRows(at: [indexPath], with: .left) self.tableView.endUpdates() } } } extension ContactsViewController: UITableViewDataSource { func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: "ContactCell") as? ContactsTableViewCell guard let contactsCell = cell else { return UITableViewCell() } contactsCell.cellModel = contactViewModelController.viewModel(at: (indexPath as NSIndexPath).row) return contactsCell } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return contactViewModelController.contactsCount } }</code> </pre> <br><br>  Incluso con una mirada superficial, est√° claro que esta clase implementa en su mayor parte tareas de interfaz.  Tambi√©n tiene navegaci√≥n en el <i>m√©todo prepareForSegue (: :)</i> , y este es exactamente el momento que cambiar√° en VIPER al agregar una capa de enrutador. <br><br>  Echemos un vistazo m√°s de cerca a la extensi√≥n de clase que implementa el protocolo UITableViewDataSource.  Las funciones no funcionan directamente con el modelo de contacto del usuario de contacto en la capa Modelo; en su lugar, reciben datos (representados por la estructura ContactViewModel) en la forma en que se mostrar√°n, ya formateados con ViewModelController. <br><br>  Lo mismo sucede en un circuito, que comienza inmediatamente despu√©s de crear un contacto.  Su √∫nica tarea es agregar una fila a la tabla y actualizar la interfaz. <br><br>  Ahora necesita establecer una relaci√≥n entre la subclase de UITableViewCell y ViewModel.  Esto se ver√≠a como la clase de celda de la tabla <b>ContactsTableViewCell</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactsTableViewCell: UITableViewCell { var cellModel: ContactViewModel? { didSet { bindViewModel() } } func bindViewModel() { textLabel?.text = cellModel?.fullName } }</code> </pre> <br><br>  Y tambi√©n lo es la clase <b>AddContactViewController</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class AddContactViewController: UIViewController { @IBOutlet var firstNameTextField: UITextField! @IBOutlet var lastNameTextField: UITextField! var contactsViewModelController: ContactViewModelController? var didAddContact: ((ContactViewModel, Int) -&gt; Void)? override func viewDidLoad() { super.viewDidLoad() firstNameTextField.becomeFirstResponder() } @IBAction func didClickOnDoneButton(_ sender: UIBarButtonItem) { guard let firstName = firstNameTextField.text, let lastName = lastNameTextField.text else { return } if firstName.isEmpty || lastName.isEmpty { showEmptyNameAlert() return } dismiss(animated: true) { [unowned self] in self.contactsViewModelController?.createContact(firstName: firstName, lastName: lastName, success: self.didAddContact, failure: nil) } } @IBAction func didClickOnCancelButton(_ sender: UIBarButtonItem) { dismiss(animated: true, completion: nil) } fileprivate func showEmptyNameAlert() { showMessage(title: "Error", message: "A contact must have first and last names") } fileprivate func showMessage(title: String, message: String) { let alertView = UIAlertController(title: title, message: message, preferredStyle: .alert) alertView.addAction(UIAlertAction(title: "Ok", style: .destructive, handler: nil)) present(alertView, animated: true, completion: nil) } }</code> </pre> <br><br>  Y de nuevo, principalmente el trabajo con la interfaz de usuario est√° sucediendo aqu√≠.  Tenga en cuenta que AddContactViewController delega la funcionalidad de creaci√≥n de contactos al ViewModelController en la funci√≥n <i>didClickOnDoneButton (:)</i> . <br><br>  <b>VER MODELO</b> <br><br>  Es hora de hablar sobre la capa ViewModel completamente nueva para nosotros.  Primero, cree una <b>clase de</b> contacto <b>ContactViewModel</b> que proporcionar√° la vista que necesitamos mostrar, y se definir√°n las funciones &lt;and&gt; con par√°metros para ordenar los contactos: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactViewModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fullName: <span class="hljs-type"><span class="hljs-type">String</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> &lt;(lhs: ContactViewModel, rhs: ContactViewModel) -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bool</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.fullName.lowercased() &lt; rhs.fullName.lowercased() } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> &gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lhs: ContactViewModel, rhs: ContactViewModel)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.fullName.lowercased() &gt; rhs.fullName.lowercased() }</code> </pre> <br><br>  <b>El</b> c√≥digo de <b>ContactViewModelController</b> se ver√° as√≠: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactViewModelController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contactViewModelList: [<span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>] = [] <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataManager = <span class="hljs-type"><span class="hljs-type">ContactLocalDataManager</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contactsCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contactViewModelList.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieveContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> success: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?, failure: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?) { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contacts = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> dataManager.retrieveContactList() contactViewModelList = contacts.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>() { <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: $<span class="hljs-number"><span class="hljs-number">0</span></span>.fullName) } success?() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { failure?() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(at index: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contactViewModelList[index] } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(firstName: String, lastName: String, success: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-params">(ContactViewModel, Int)</span></span></span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?, failure: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?) { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contact = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> dataManager.createContact(firstName: firstName, lastName: lastName) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contactViewModel = <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: contact.fullName) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> insertionIndex = contactViewModelList.insertionIndex(of: contactViewModel) { $<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; $<span class="hljs-number"><span class="hljs-number">1</span></span> } contactViewModelList.insert(contactViewModel, at: insertionIndex) success?(contactViewModel, insertionIndex) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { failure?() } } }</code> </pre><br><br>  <i><u>Nota:</u></i> MVVM no proporciona una definici√≥n exacta de c√≥mo crear un ViewModel.  Cuando quiero crear una arquitectura m√°s estratificada, prefiero crear un ViewModelController que interactuar√° con la capa Modelo y ser√° responsable de crear los objetos ViewModel. <br><br>  Lo principal que es muy f√°cil de recordar: la capa ViewModel no debe participar en el trabajo con la interfaz de usuario.  Para evitar esto, es mejor <b>no</b> importar <b>nunca</b> UIKit a un archivo con ViewModel. <br><br>  La clase ContactViewModelController solicita contactos del almacenamiento local e intenta no afectar la capa Modelo.  Devuelve los datos en el formato que la vista requiere que se muestre y notifica la vista cuando se agrega un nuevo contacto y los datos cambian. <br><br>  En la vida real, esto ser√≠a una solicitud de red, y no una solicitud a la base de datos local, pero en ninguno de los casos deber√≠a ser parte de ViewModel; tanto el trabajo en red como el trabajo con la base de datos local deben proporcionarse utilizando sus propios administradores ( gerentes). <br><br>  Eso es todo sobre MVVM.  Quiz√°s este enfoque le parezca m√°s comprobable, compatible y distribuido que MVC.  Ahora hablemos de VIPER y veamos c√≥mo se diferencia de MVVM. <br><br>  <b>VIPER</b> <br><br>  C√≥mo funciona <br><br>  VIPER es una implementaci√≥n de arquitectura limpia para proyectos de iOS.  Su estructura consiste en: Vista, Interactor, Presentador, Entidad y Enrutador.  Esta es realmente una arquitectura muy distribuida y modular que le permite compartir la responsabilidad, est√° muy bien cubierta por las pruebas unitarias y hace que su c√≥digo sea reutilizable. <br><br><ul><li>  <b>Ver</b> : Una capa de interfaz que generalmente implica archivos UIKit (incluido el UIViewController).  Es comprensible que en sistemas m√°s distribuidos, las subclases de UIViewController se relacionen con View.  En VIPER, las cosas son casi lo mismo que en MVVM: View es responsable de mostrar lo que Presenter proporciona y de transmitir informaci√≥n o acciones ingresadas por el usuario a Presenter. </li><li>  <b>Interactor</b> : contiene la l√≥gica de negocios necesaria para que la aplicaci√≥n funcione.  Interactor es responsable de recuperar datos del Modelo (solicitudes locales o de red) y su implementaci√≥n no est√° relacionada de ninguna manera con la interfaz de usuario.  Es importante recordar que los administradores locales y de red no son parte de VIPER, sino que se tratan como dependencias separadas. </li><li>  <b>Presentador</b> : responsable de formatear los datos para mostrar en la vista.  En MVVM en nuestro ejemplo, ViewModelController fue responsable de esto.  Presenter recibe datos de Interactor, crea una instancia de ViewModel (una clase formateada para una visualizaci√≥n correcta) y la pasa a View.  Tambi√©n responde a la entrada de datos del usuario, solicita datos adicionales de la base de datos o viceversa, se los pasa. </li><li>  <b>Entidad</b> : Forma parte de la responsabilidad de la capa Modelo, que se usa en otras arquitecturas.  La entidad es un objeto de datos simple, sin l√≥gica empresarial, administrado por un tractor en l√≠nea y varios administradores de datos. </li><li>  <b>Enrutador</b> : toda la l√≥gica de navegaci√≥n de la aplicaci√≥n.  Puede parecer que esta no es la capa m√°s importante, pero si necesita, por ejemplo, reutilizar la misma vista tanto en el iPhone como en la aplicaci√≥n para iPad, lo √∫nico que puede cambiar es c√≥mo aparecen sus vistas en la pantalla.  Esto le permite no tocar m√°s capas, excepto el enrutador, que ser√° responsable de esto en cada caso. </li></ul><br><br>  En comparaci√≥n con MVVM, VIPER tiene varias diferencias clave en la distribuci√≥n de responsabilidad: <br><br>  - √©l tiene un enrutador, una capa separada responsable de la navegaci√≥n <br><br>  - Las entidades son simples objetos de datos, que redistribuyen la responsabilidad de acceder a los datos del Modelo al Interactor. <br><br>  - Las responsabilidades de ViewModelController se comparten entre Interactor y Presenter <br><br>  Y ahora repitamos la misma aplicaci√≥n, pero ya en VIPER.  Pero para facilitar la comprensi√≥n, solo haremos un controlador con contactos.  Puede encontrar el c√≥digo del controlador para agregar un nuevo contacto en el proyecto utilizando el enlace (carpeta de inicio de contactos VIPER en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este repositorio</a> ). <br><br>  <i><u>Nota</u></i> : Si decide realizar su proyecto en VIPER, entonces no debe intentar crear todos los archivos manualmente; puede usar uno de los generadores de c√≥digo, por ejemplo, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">VIPER Gen</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Generamba (proyecto Rambler)</a> . <br><br>  <b>Aplicaci√≥n de contactos VIPER</b> <br><br>  <b>VER</b> <br><br>  VIEW est√° representado por elementos de Main.storyboard y la clase ContactListView.  VIEW es muy pasivo;  sus √∫nicas tareas son transferir eventos de interfaz al presentador y actualizar su estado, previa notificaci√≥n del presentador.  As√≠ es como se ve el c√≥digo <b>ContactListView</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactListView: UIViewController { @IBOutlet var tableView: UITableView! var presenter: ContactListPresenterProtocol? var contactList: [ContactViewModel] = [] override func viewDidLoad() { super.viewDidLoad() presenter?.viewDidLoad() tableView.tableFooterView = UIView() } @IBAction func didClickOnAddButton(_ sender: UIBarButtonItem) { presenter?.addNewContact(from: self) } } extension ContactListView: ContactListViewProtocol { func reloadInterface(with contacts: [ContactViewModel]) { contactList = contacts tableView.reloadData() } func didInsertContact(_ contact: ContactViewModel) { let insertionIndex = contactList.insertionIndex(of: contact) { $0 &lt; $1 } contactList.insert(contact, at: insertionIndex) let indexPath = IndexPath(row: insertionIndex, section: 0) tableView.beginUpdates() tableView.insertRows(at: [indexPath], with: .right) tableView.endUpdates() } } extension ContactListView: UITableViewDataSource { func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { guard let cell = tableView.dequeueReusableCell(withIdentifier: "ContactCell") else { return UITableViewCell() } cell.textLabel?.text = contactList[(indexPath as NSIndexPath).row].fullName return cell } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return contactList.count } }</code> </pre> <br><br>  Ver env√≠a los eventos <i>viewDidLoad</i> y <i>didClickOnAddButton</i> al presentador.  En el primer evento, el presentador solicitar√° datos de Interactor, y en el segundo, el presentador le pedir√° al enrutador que cambie al controlador para agregar un nuevo contacto. <br><br>  Los m√©todos de protocolo ContactListViewProtocol se llaman desde Presenter cuando se solicita una lista de contactos o cuando se agrega un nuevo contacto.  En cualquier caso, los datos en la Vista contienen solo la informaci√≥n necesaria para la visualizaci√≥n. <br><br>  Tambi√©n en la Vista hay m√©todos que implementan el protocolo UITableViewDataSource que puebla la tabla con los datos recibidos. <br><br>  <b>INTERACTOR</b> <br><br>  Interactor en nuestro ejemplo es bastante simple.  Todo lo que hace es solicitar datos a trav√©s del administrador de la base de datos local, y no le importa lo que use este administrador, CoreData, Realm o cualquier otra soluci√≥n.  El c√≥digo en ContactListInteractor ser√° el siguiente: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListInteractor</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListInteractorInputProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presenter: <span class="hljs-type"><span class="hljs-type">ContactListInteractorOutputProtocol?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> localDatamanager: <span class="hljs-type"><span class="hljs-type">ContactListLocalDataManagerInputProtocol?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieveContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contactList = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> localDatamanager?.retrieveContactList() { presenter?.didRetrieveContacts(contactList) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { presenter?.didRetrieveContacts([]) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { presenter?.didRetrieveContacts([]) } } }</code> </pre> <br><br>  Despu√©s de que Interactor recibe los datos solicitados, notifica al presentador.  Adem√°s, como opci√≥n, Interactor puede transmitir un error al presentador, que luego tendr√° que formatear el error en una vista adecuada para mostrar en la vista. <br><br>  <i>Nota</i> : Como habr√°s notado, cada capa en VIPER implementa un protocolo.  Como resultado, las clases dependen de abstracciones, y no de una implementaci√≥n particular, cumpliendo as√≠ el principio de inversi√≥n de dependencia (uno de los principios de SOLID). <br><br>  <b>Presentador</b> <br><br>  El elemento m√°s importante de la arquitectura.  Toda la comunicaci√≥n entre la Vista y el resto de las capas (Interactor y Enrutador) pasa por el Presentador.  <b>ContactListPresenter</b> Code: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenterProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> view: <span class="hljs-type"><span class="hljs-type">ContactListViewProtocol?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interactor: <span class="hljs-type"><span class="hljs-type">ContactListInteractorInputProtocol?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wireFrame: <span class="hljs-type"><span class="hljs-type">ContactListWireFrameProtocol?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { interactor?.retrieveContacts() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addNewContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from view: ContactListViewProtocol)</span></span></span></span> { wireFrame?.presentAddContactScreen(from: view) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListInteractorOutputProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didRetrieveContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> contacts: [Contact])</span></span></span></span> { view?.reloadInterface(with: contacts.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: $<span class="hljs-number"><span class="hljs-number">0</span></span>.fullName) }) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddModuleDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didAddContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> contact: Contact)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contactViewModel = <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: contact.fullName) view?.didInsertContact(contactViewModel) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didCancelAddContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} }</code> </pre> <br><br>  Despu√©s de cargar View, notifica a Presenter, que a su vez solicita datos a trav√©s de Interactor.  Cuando el usuario hace clic en el bot√≥n Agregar nuevo contacto, Ver notifica al presentador, que env√≠a una solicitud para abrir la pantalla Agregar nuevo contacto en el enrutador. <br><br>  Presenter tambi√©n formatea los datos y los devuelve a la Vista despu√©s de consultar la lista de contactos.  Tambi√©n es responsable de implementar el protocolo AddModuleDelegate.  Esto significa que Presenter recibir√° una notificaci√≥n cuando se agregue un nuevo contacto, prepare los datos del contacto para mostrar y transfiera a Ver. <br><br>  Como habr√°s notado, Presenter tiene muchas posibilidades de volverse bastante engorroso.  Si existe tal posibilidad, el Presentador se puede dividir en dos partes: el Presentador, que solo recibe datos, los formatea para mostrarlos y los pasa a Ver;  y un controlador de eventos que responder√° a las acciones del usuario. <br><br>  <b>ENTIDAD</b> <br><br>  Esta capa es similar a la capa Modelo en MVVM.  En nuestra aplicaci√≥n, est√° representado por la clase de contacto y las funciones de definici√≥n de operador &lt;y&gt;.  <b>El</b> contenido del <b>contacto</b> se ver√° as√≠: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CoreData open class Contact: NSManagedObject { var fullName: String { get { var name = "" if let firstName = firstName { name += firstName } if let lastName = lastName { name += " " + lastName } return name } } } public struct ContactViewModel { var fullName = "" } public func &lt;(lhs: ContactViewModel, rhs: ContactViewModel) -&gt; Bool { return lhs.fullName.lowercased() &lt; rhs.fullName.lowercased() } public func &gt;(lhs: ContactViewModel, rhs: ContactViewModel) -&gt; Bool { return lhs.fullName.lowercased() &gt; rhs.fullName.lowercased() }</code> </pre> <br><br>  ContactViewModel contiene los campos que presenta el presentador (formatos) que muestra la vista.  La clase Contact es una subclase de NSManagedObject que contiene los mismos campos que en el modelo CoreData. <br><br>  <b>ROUTER</b> <br><br>  Y finalmente, la √∫ltima, pero ciertamente no importante, capa.  Toda la responsabilidad de la navegaci√≥n recae en Presenter y WireFrame.  El presentador recibe un evento del usuario y sabe cu√°ndo hacer la transici√≥n, y WireFrame sabe c√≥mo y d√≥nde hacer esta transici√≥n.  Para que no se confunda, en este ejemplo, la capa Router est√° representada por la clase ContactListWireFrame y se denomina WireFrame en el texto.  <b>ContactListWireFrame</b> Code: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactListWireFrame: ContactListWireFrameProtocol { class func createContactListModule() -&gt; UIViewController { let navController = mainStoryboard.instantiateViewController(withIdentifier: "ContactsNavigationController") if let view = navController.childViewControllers.first as? ContactListView { let presenter: ContactListPresenterProtocol &amp; ContactListInteractorOutputProtocol = ContactListPresenter() let interactor: ContactListInteractorInputProtocol = ContactListInteractor() let localDataManager: ContactListLocalDataManagerInputProtocol = ContactListLocalDataManager() let wireFrame: ContactListWireFrameProtocol = ContactListWireFrame() view.presenter = presenter presenter.view = view presenter.wireFrame = wireFrame presenter.interactor = interactor interactor.presenter = presenter interactor.localDatamanager = localDataManager return navController } return UIViewController() } static var mainStoryboard: UIStoryboard { return UIStoryboard(name: "Main", bundle: Bundle.main) } func presentAddContactScreen(from view: ContactListViewProtocol) { guard let delegate = view.presenter as? AddModuleDelegate else { return } let addContactsView = AddContactWireFrame.createAddContactModule(with: delegate) if let sourceView = view as? UIViewController { sourceView.present(addContactsView, animated: true, completion: nil) } } }</code> </pre> <br><br>  Como WireFrame es responsable de crear el m√≥dulo, ser√° conveniente configurar todas las dependencias aqu√≠.  Cuando desee abrir otro controlador, la funci√≥n que abre el nuevo controlador recibe como argumento el objeto que lo abrir√°, y crea un nuevo controlador utilizando su WireFrame.  Adem√°s, al crear un nuevo controlador, los datos necesarios se transfieren a √©l, en este caso solo el delegado (Presentador del controlador con contactos) para recibir el contacto creado. <br><br>  La capa de enrutador ofrece una buena oportunidad para evitar el uso de segues (transiciones) en guiones gr√°ficos y organizar todo el c√≥digo de navegaci√≥n.  Dado que los guiones gr√°ficos no proporcionan una soluci√≥n compacta para transferir datos entre controladores, nuestra implementaci√≥n de navegaci√≥n no agregar√° c√≥digo adicional.  Todo lo que obtenemos es solo la mejor reutilizaci√≥n. <br><br><br>  <b>Resumen</b> : <br><br>  Puede encontrar ambos proyectos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este repositorio</a> . <br><br>  Como puede ver, MVVM y VIPER, aunque diferentes, no son √∫nicos.  MVVM nos dice que adem√°s de Ver y Modelo, tambi√©n deber√≠a haber una capa ViewModel.  Pero no se dice nada sobre c√≥mo se debe crear esta capa, ni sobre c√≥mo se solicitan los datos: la responsabilidad de esta capa no est√° claramente definida.  Hay muchas formas de implementarlo y puede usar cualquiera de ellas. <br><br>  VIPER, por otro lado, es una arquitectura bastante √∫nica.  Consiste en muchas capas, cada una de las cuales tiene un √°rea de responsabilidad bien definida y menos de MVVM est√° influenciada por el desarrollador. <br><br>  Cuando se trata de elegir una arquitectura, generalmente no existe la √∫nica soluci√≥n correcta, pero a√∫n as√≠ intentar√© dar algunos consejos.  Si tiene un proyecto grande y largo, con requisitos claros y desea tener muchas oportunidades para reutilizar componentes, entonces VIPER ser√° la mejor soluci√≥n.  Una delimitaci√≥n m√°s clara de la responsabilidad hace posible organizar mejor las pruebas y mejorar la reutilizaci√≥n. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440904/">https://habr.com/ru/post/440904/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440894/index.html">Dise√±o de sonido para Pathfinder: Kingmaker</a></li>
<li><a href="../440896/index.html">Tecnolog√≠as aditivas y escaneo 3D en ingenier√≠a mec√°nica: 7 historias de √©xito</a></li>
<li><a href="../440898/index.html">Marketing de contenidos, publicidad contextual, mejora de la conversi√≥n: 6 gu√≠as √∫tiles de promoci√≥n de inicio</a></li>
<li><a href="../440900/index.html">RESTO pasi√≥n por 200</a></li>
<li><a href="../440902/index.html">La mitad del reino para la IA: cu√°nto ahorran los bancos en aprendizaje autom√°tico, redes neuronales y bots de chat</a></li>
<li><a href="../440906/index.html">Seminario web "167-–§–ó. C√≥mo los bancos pueden cumplir los requisitos del Banco Central para los sistemas antifraude ‚Äù- 26 de febrero de 2019, 11:00 hora de Mosc√∫</a></li>
<li><a href="../440908/index.html">Servir todo</a></li>
<li><a href="../440910/index.html">¬øPor qu√© los bancos monopolizan blockchain?</a></li>
<li><a href="../440912/index.html">Tal dolor, tal dolor, infraestructura como servicio 1: 0</a></li>
<li><a href="../440914/index.html">Perd√≠ la fe en la industria, me quem√©, pero el culto a la herramienta me salv√≥</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>