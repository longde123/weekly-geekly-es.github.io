<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗🏿 😴 👨🏼‍🚀 Comparación de las arquitecturas Viper y MVVM: cómo aplicar ambas 🙉 🐷 📁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Actualmente, VIPER y MVVM son las soluciones arquitectónicas más populares utilizadas en el desarrollo de grandes aplicaciones que requieren la partic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comparación de las arquitecturas Viper y MVVM: cómo aplicar ambas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440904/"><img src="https://habrastorage.org/webt/db/bn/4z/dbbn4zxc39qxt6vtlimqyjql5ko.jpeg"><br><br>  Actualmente, VIPER y MVVM son las soluciones arquitectónicas más populares utilizadas en el desarrollo de grandes aplicaciones que requieren la participación en el desarrollo de grandes equipos que están bien probados, respaldados a largo plazo y en constante evolución.  En este artículo intentaremos aplicarlos en un pequeño proyecto de prueba, que es una lista de contactos de usuarios con la capacidad de agregar un nuevo contacto.  Este artículo tiene más práctica que análisis, y está dirigido principalmente a aquellos que ya están en teoría familiarizados con estas arquitecturas y ahora quisieran entender cómo funciona esto con ejemplos específicos.  Sin embargo, una descripción básica de las arquitecturas y su comparación también está presente. <br><a name="habracut"></a><br><br>  Este artículo es una traducción del artículo de Rafael Sacchi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Comparación de las arquitecturas MVVM y Viper: cuándo usar una u otra"</a> .  Desafortunadamente, en algún momento de la creación del artículo, se creó "publicación" en lugar de "traducción", por lo que debe escribir aquí. <br><br>  Una arquitectura bien diseñada es esencial para garantizar un soporte continuo para su proyecto.  En este artículo, veremos las arquitecturas MVVM y VIPER como una alternativa al MVC tradicional. <br><br>  MVC es un concepto bien conocido para todos aquellos que han estado involucrados en el desarrollo de software durante bastante tiempo.  Este patrón divide el proyecto en tres partes: modelo que representa entidades;  Ver, que es una interfaz para la interacción del usuario;  y Controlador, responsable de garantizar la interacción entre Vista y Modelo.  Esta es la arquitectura que Apple nos ofrece para usar en nuestras aplicaciones. <br><br>  Sin embargo, probablemente sepa que los proyectos vienen con una funcionalidad bastante compleja: soporte para solicitudes de red, análisis, acceso a modelos de datos, conversión de datos para salida, reacción a eventos de interfaz, etc.  Como resultado, obtienes enormes controladores que resuelven los problemas anteriores y un montón de código que no se puede reutilizar.  En otras palabras, MVC puede ser una pesadilla para un desarrollador con soporte de proyectos a largo plazo.  Pero, ¿cómo garantizar una alta modularidad y reutilización en proyectos de iOS? <br><br>  Veremos dos alternativas muy famosas a la arquitectura MVC: MVVM y VIPER.  Ambos son bastante famosos en la comunidad iOS y han demostrado que pueden ser una gran alternativa a MVC.  Hablaremos sobre su estructura, escribiremos una aplicación de ejemplo y consideraremos casos en los que es mejor usar una u otra arquitectura. <br><br>  <b>Ejemplo</b> <br><br>  Escribiremos una aplicación con una tabla de contactos de usuarios.  Puede usar el código de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este repositorio</a> .  En las carpetas de inicio, el esqueleto básico del proyecto está contenido, y en las carpetas finales hay una aplicación completamente terminada. <br><br>  La aplicación tendrá dos pantallas: en la primera se mostrará una lista de contactos en forma de tabla, la celda tendrá el nombre y el apellido del contacto, así como la imagen base en lugar de la imagen del usuario. <br><br><img src="https://habrastorage.org/webt/gn/kc/ww/gnkcwwblrc7b036fyvuz874zfpu.png"><br><br>  La segunda pantalla es la pantalla para agregar un nuevo contacto, con los campos de entrada de nombre y apellido y los botones Listo y Cancelar. <br><br><img src="https://habrastorage.org/webt/rx/b1/mv/rxb1mvegb0piorji2dovggxdj8q.png"><br><br>  <b>MVVM</b> <br><br>  Cómo funciona <br><br>  MVVM significa <b>Model-View-ViewModel</b> .  Este enfoque difiere de MVC en la lógica de distribución de responsabilidad entre módulos. <br><br><ul><li>  <b>Modelo</b> : este módulo no es diferente al de MVC.  Es responsable de crear modelos de datos y puede contener lógica de negocios.  También puede crear clases auxiliares, por ejemplo, como una clase de administrador para administrar objetos en Model y el administrador de red para procesar solicitudes de red y análisis. </li><li>  <b>Ver</b> : Y aquí todo comienza a cambiar.  El módulo View en MVVM cubre la interfaz (subclases de archivos UIView, .xib y .storyboard), la lógica de visualización (animación, renderizado) y el manejo de eventos del usuario (clics de botones, etc.) En MVC, View y Controller son responsables de esto.  Esto significa que las vistas que tiene permanecerán sin cambios, mientras que ViewController contendrá una pequeña parte de lo que había en MVC y, en consecuencia, disminuirá considerablemente. </li><li>  <b>ViewModel</b> : ahora es el lugar donde se <b>ubicará</b> la mayor parte del código que tenía anteriormente en ViewController.  La capa ViewModel solicita datos del Modelo (puede ser una solicitud a una base de datos local o una solicitud de red) y los transfiere nuevamente a la Vista, en el formato en el que se utilizará y se mostrará allí.  Pero este es un mecanismo bidireccional, las acciones o los datos ingresados ​​por el usuario pasan a través del ViewModel y actualizan el Modelo.  Dado que ViewModel realiza un seguimiento de todo lo que se muestra, es útil utilizar el mecanismo de enlace entre las dos capas. </li></ul><br><br>  En comparación con MVC, se está moviendo de una arquitectura que se ve así: <br><br><img src="https://habrastorage.org/webt/op/i7/gq/opi7gqlutejiwvehje5zoeey96k.jpeg"><br><br>  Para el próximo varant de arquitectura: <br><br><img src="https://habrastorage.org/webt/zu/me/cj/zumecj56yf5vgzckbhjdarwx58i.png"><br><br>  En el que las clases y subclases de UIView y UIViewController se utilizan para implementar la Vista. <br><br>  Bueno, ahora al grano.  Escribamos un ejemplo de nuestra aplicación usando la arquitectura MVVM. <br><br>  <b>Aplicación de contactos MVVM</b> <br><br>  <b>MODELO</b> <br><br>  La siguiente clase es un modelo de <b>contacto de</b> contacto: <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CoreData open class Contact: NSManagedObject { @NSManaged var firstName: String? @NSManaged var lastName: String? var fullName: String { get { var name = "" if let firstName = firstName { name += firstName } if let lastName = lastName { name += " \(lastName)" } return name } } }</code> </pre> <br><br>  La clase de contacto tiene los campos <i>firstName</i> , <i>lastName</i> , así como la propiedad calculada <i>fullName</i> . <br><br>  <b>VER</b> <br><br>  VIEW incluye: Storyboard principal, con vistas ya colocadas en él;  ContactsViewController, que muestra una lista de contactos en una tabla;  y AddContactViewController con un par de etiquetas y campos de entrada para agregar el nombre y el apellido del nuevo contacto.  Comencemos con el <b>ContactsViewController</b> .  Su código se verá así: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactsViewController: UIViewController { @IBOutlet var tableView: UITableView! let contactViewModelController = ContactViewModelController() override func viewDidLoad() { super.viewDidLoad() tableView.tableFooterView = UIView() contactViewModelController.retrieveContacts({ [unowned self] in self.tableView.reloadData() }, failure: nil) } override func prepare(for segue: UIStoryboardSegue, sender: Any?) { let addContactNavigationController = segue.destination as? UINavigationController let addContactVC = addContactNavigationController?.viewControllers[0] as? AddContactViewController addContactVC?.contactsViewModelController = contactViewModelController addContactVC?.didAddContact = { [unowned self] (contactViewModel, index) in let indexPath = IndexPath(row: index, section: 0) self.tableView.beginUpdates() self.tableView.insertRows(at: [indexPath], with: .left) self.tableView.endUpdates() } } } extension ContactsViewController: UITableViewDataSource { func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: "ContactCell") as? ContactsTableViewCell guard let contactsCell = cell else { return UITableViewCell() } contactsCell.cellModel = contactViewModelController.viewModel(at: (indexPath as NSIndexPath).row) return contactsCell } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return contactViewModelController.contactsCount } }</code> </pre> <br><br>  Incluso con una mirada superficial, está claro que esta clase implementa en su mayor parte tareas de interfaz.  También tiene navegación en el <i>método prepareForSegue (: :)</i> , y este es exactamente el momento que cambiará en VIPER al agregar una capa de enrutador. <br><br>  Echemos un vistazo más de cerca a la extensión de clase que implementa el protocolo UITableViewDataSource.  Las funciones no funcionan directamente con el modelo de contacto del usuario de contacto en la capa Modelo; en su lugar, reciben datos (representados por la estructura ContactViewModel) en la forma en que se mostrarán, ya formateados con ViewModelController. <br><br>  Lo mismo sucede en un circuito, que comienza inmediatamente después de crear un contacto.  Su única tarea es agregar una fila a la tabla y actualizar la interfaz. <br><br>  Ahora necesita establecer una relación entre la subclase de UITableViewCell y ViewModel.  Esto se vería como la clase de celda de la tabla <b>ContactsTableViewCell</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactsTableViewCell: UITableViewCell { var cellModel: ContactViewModel? { didSet { bindViewModel() } } func bindViewModel() { textLabel?.text = cellModel?.fullName } }</code> </pre> <br><br>  Y también lo es la clase <b>AddContactViewController</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class AddContactViewController: UIViewController { @IBOutlet var firstNameTextField: UITextField! @IBOutlet var lastNameTextField: UITextField! var contactsViewModelController: ContactViewModelController? var didAddContact: ((ContactViewModel, Int) -&gt; Void)? override func viewDidLoad() { super.viewDidLoad() firstNameTextField.becomeFirstResponder() } @IBAction func didClickOnDoneButton(_ sender: UIBarButtonItem) { guard let firstName = firstNameTextField.text, let lastName = lastNameTextField.text else { return } if firstName.isEmpty || lastName.isEmpty { showEmptyNameAlert() return } dismiss(animated: true) { [unowned self] in self.contactsViewModelController?.createContact(firstName: firstName, lastName: lastName, success: self.didAddContact, failure: nil) } } @IBAction func didClickOnCancelButton(_ sender: UIBarButtonItem) { dismiss(animated: true, completion: nil) } fileprivate func showEmptyNameAlert() { showMessage(title: "Error", message: "A contact must have first and last names") } fileprivate func showMessage(title: String, message: String) { let alertView = UIAlertController(title: title, message: message, preferredStyle: .alert) alertView.addAction(UIAlertAction(title: "Ok", style: .destructive, handler: nil)) present(alertView, animated: true, completion: nil) } }</code> </pre> <br><br>  Y de nuevo, principalmente el trabajo con la interfaz de usuario está sucediendo aquí.  Tenga en cuenta que AddContactViewController delega la funcionalidad de creación de contactos al ViewModelController en la función <i>didClickOnDoneButton (:)</i> . <br><br>  <b>VER MODELO</b> <br><br>  Es hora de hablar sobre la capa ViewModel completamente nueva para nosotros.  Primero, cree una <b>clase de</b> contacto <b>ContactViewModel</b> que proporcionará la vista que necesitamos mostrar, y se definirán las funciones &lt;and&gt; con parámetros para ordenar los contactos: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactViewModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fullName: <span class="hljs-type"><span class="hljs-type">String</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> &lt;(lhs: ContactViewModel, rhs: ContactViewModel) -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bool</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.fullName.lowercased() &lt; rhs.fullName.lowercased() } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> &gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lhs: ContactViewModel, rhs: ContactViewModel)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.fullName.lowercased() &gt; rhs.fullName.lowercased() }</code> </pre> <br><br>  <b>El</b> código de <b>ContactViewModelController</b> se verá así: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactViewModelController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contactViewModelList: [<span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>] = [] <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataManager = <span class="hljs-type"><span class="hljs-type">ContactLocalDataManager</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contactsCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contactViewModelList.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieveContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> success: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?, failure: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?) { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contacts = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> dataManager.retrieveContactList() contactViewModelList = contacts.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>() { <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: $<span class="hljs-number"><span class="hljs-number">0</span></span>.fullName) } success?() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { failure?() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(at index: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contactViewModelList[index] } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(firstName: String, lastName: String, success: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-params">(ContactViewModel, Int)</span></span></span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?, failure: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?) { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contact = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> dataManager.createContact(firstName: firstName, lastName: lastName) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contactViewModel = <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: contact.fullName) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> insertionIndex = contactViewModelList.insertionIndex(of: contactViewModel) { $<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; $<span class="hljs-number"><span class="hljs-number">1</span></span> } contactViewModelList.insert(contactViewModel, at: insertionIndex) success?(contactViewModel, insertionIndex) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { failure?() } } }</code> </pre><br><br>  <i><u>Nota:</u></i> MVVM no proporciona una definición exacta de cómo crear un ViewModel.  Cuando quiero crear una arquitectura más estratificada, prefiero crear un ViewModelController que interactuará con la capa Modelo y será responsable de crear los objetos ViewModel. <br><br>  Lo principal que es muy fácil de recordar: la capa ViewModel no debe participar en el trabajo con la interfaz de usuario.  Para evitar esto, es mejor <b>no</b> importar <b>nunca</b> UIKit a un archivo con ViewModel. <br><br>  La clase ContactViewModelController solicita contactos del almacenamiento local e intenta no afectar la capa Modelo.  Devuelve los datos en el formato que la vista requiere que se muestre y notifica la vista cuando se agrega un nuevo contacto y los datos cambian. <br><br>  En la vida real, esto sería una solicitud de red, y no una solicitud a la base de datos local, pero en ninguno de los casos debería ser parte de ViewModel; tanto el trabajo en red como el trabajo con la base de datos local deben proporcionarse utilizando sus propios administradores ( gerentes). <br><br>  Eso es todo sobre MVVM.  Quizás este enfoque le parezca más comprobable, compatible y distribuido que MVC.  Ahora hablemos de VIPER y veamos cómo se diferencia de MVVM. <br><br>  <b>VIPER</b> <br><br>  Cómo funciona <br><br>  VIPER es una implementación de arquitectura limpia para proyectos de iOS.  Su estructura consiste en: Vista, Interactor, Presentador, Entidad y Enrutador.  Esta es realmente una arquitectura muy distribuida y modular que le permite compartir la responsabilidad, está muy bien cubierta por las pruebas unitarias y hace que su código sea reutilizable. <br><br><ul><li>  <b>Ver</b> : Una capa de interfaz que generalmente implica archivos UIKit (incluido el UIViewController).  Es comprensible que en sistemas más distribuidos, las subclases de UIViewController se relacionen con View.  En VIPER, las cosas son casi lo mismo que en MVVM: View es responsable de mostrar lo que Presenter proporciona y de transmitir información o acciones ingresadas por el usuario a Presenter. </li><li>  <b>Interactor</b> : contiene la lógica de negocios necesaria para que la aplicación funcione.  Interactor es responsable de recuperar datos del Modelo (solicitudes locales o de red) y su implementación no está relacionada de ninguna manera con la interfaz de usuario.  Es importante recordar que los administradores locales y de red no son parte de VIPER, sino que se tratan como dependencias separadas. </li><li>  <b>Presentador</b> : responsable de formatear los datos para mostrar en la vista.  En MVVM en nuestro ejemplo, ViewModelController fue responsable de esto.  Presenter recibe datos de Interactor, crea una instancia de ViewModel (una clase formateada para una visualización correcta) y la pasa a View.  También responde a la entrada de datos del usuario, solicita datos adicionales de la base de datos o viceversa, se los pasa. </li><li>  <b>Entidad</b> : Forma parte de la responsabilidad de la capa Modelo, que se usa en otras arquitecturas.  La entidad es un objeto de datos simple, sin lógica empresarial, administrado por un tractor en línea y varios administradores de datos. </li><li>  <b>Enrutador</b> : toda la lógica de navegación de la aplicación.  Puede parecer que esta no es la capa más importante, pero si necesita, por ejemplo, reutilizar la misma vista tanto en el iPhone como en la aplicación para iPad, lo único que puede cambiar es cómo aparecen sus vistas en la pantalla.  Esto le permite no tocar más capas, excepto el enrutador, que será responsable de esto en cada caso. </li></ul><br><br>  En comparación con MVVM, VIPER tiene varias diferencias clave en la distribución de responsabilidad: <br><br>  - él tiene un enrutador, una capa separada responsable de la navegación <br><br>  - Las entidades son simples objetos de datos, que redistribuyen la responsabilidad de acceder a los datos del Modelo al Interactor. <br><br>  - Las responsabilidades de ViewModelController se comparten entre Interactor y Presenter <br><br>  Y ahora repitamos la misma aplicación, pero ya en VIPER.  Pero para facilitar la comprensión, solo haremos un controlador con contactos.  Puede encontrar el código del controlador para agregar un nuevo contacto en el proyecto utilizando el enlace (carpeta de inicio de contactos VIPER en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este repositorio</a> ). <br><br>  <i><u>Nota</u></i> : Si decide realizar su proyecto en VIPER, entonces no debe intentar crear todos los archivos manualmente; puede usar uno de los generadores de código, por ejemplo, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">VIPER Gen</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Generamba (proyecto Rambler)</a> . <br><br>  <b>Aplicación de contactos VIPER</b> <br><br>  <b>VER</b> <br><br>  VIEW está representado por elementos de Main.storyboard y la clase ContactListView.  VIEW es muy pasivo;  sus únicas tareas son transferir eventos de interfaz al presentador y actualizar su estado, previa notificación del presentador.  Así es como se ve el código <b>ContactListView</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactListView: UIViewController { @IBOutlet var tableView: UITableView! var presenter: ContactListPresenterProtocol? var contactList: [ContactViewModel] = [] override func viewDidLoad() { super.viewDidLoad() presenter?.viewDidLoad() tableView.tableFooterView = UIView() } @IBAction func didClickOnAddButton(_ sender: UIBarButtonItem) { presenter?.addNewContact(from: self) } } extension ContactListView: ContactListViewProtocol { func reloadInterface(with contacts: [ContactViewModel]) { contactList = contacts tableView.reloadData() } func didInsertContact(_ contact: ContactViewModel) { let insertionIndex = contactList.insertionIndex(of: contact) { $0 &lt; $1 } contactList.insert(contact, at: insertionIndex) let indexPath = IndexPath(row: insertionIndex, section: 0) tableView.beginUpdates() tableView.insertRows(at: [indexPath], with: .right) tableView.endUpdates() } } extension ContactListView: UITableViewDataSource { func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { guard let cell = tableView.dequeueReusableCell(withIdentifier: "ContactCell") else { return UITableViewCell() } cell.textLabel?.text = contactList[(indexPath as NSIndexPath).row].fullName return cell } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return contactList.count } }</code> </pre> <br><br>  Ver envía los eventos <i>viewDidLoad</i> y <i>didClickOnAddButton</i> al presentador.  En el primer evento, el presentador solicitará datos de Interactor, y en el segundo, el presentador le pedirá al enrutador que cambie al controlador para agregar un nuevo contacto. <br><br>  Los métodos de protocolo ContactListViewProtocol se llaman desde Presenter cuando se solicita una lista de contactos o cuando se agrega un nuevo contacto.  En cualquier caso, los datos en la Vista contienen solo la información necesaria para la visualización. <br><br>  También en la Vista hay métodos que implementan el protocolo UITableViewDataSource que puebla la tabla con los datos recibidos. <br><br>  <b>INTERACTOR</b> <br><br>  Interactor en nuestro ejemplo es bastante simple.  Todo lo que hace es solicitar datos a través del administrador de la base de datos local, y no le importa lo que use este administrador, CoreData, Realm o cualquier otra solución.  El código en ContactListInteractor será el siguiente: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListInteractor</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListInteractorInputProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presenter: <span class="hljs-type"><span class="hljs-type">ContactListInteractorOutputProtocol?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> localDatamanager: <span class="hljs-type"><span class="hljs-type">ContactListLocalDataManagerInputProtocol?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieveContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contactList = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> localDatamanager?.retrieveContactList() { presenter?.didRetrieveContacts(contactList) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { presenter?.didRetrieveContacts([]) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { presenter?.didRetrieveContacts([]) } } }</code> </pre> <br><br>  Después de que Interactor recibe los datos solicitados, notifica al presentador.  Además, como opción, Interactor puede transmitir un error al presentador, que luego tendrá que formatear el error en una vista adecuada para mostrar en la vista. <br><br>  <i>Nota</i> : Como habrás notado, cada capa en VIPER implementa un protocolo.  Como resultado, las clases dependen de abstracciones, y no de una implementación particular, cumpliendo así el principio de inversión de dependencia (uno de los principios de SOLID). <br><br>  <b>Presentador</b> <br><br>  El elemento más importante de la arquitectura.  Toda la comunicación entre la Vista y el resto de las capas (Interactor y Enrutador) pasa por el Presentador.  <b>ContactListPresenter</b> Code: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenterProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> view: <span class="hljs-type"><span class="hljs-type">ContactListViewProtocol?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interactor: <span class="hljs-type"><span class="hljs-type">ContactListInteractorInputProtocol?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wireFrame: <span class="hljs-type"><span class="hljs-type">ContactListWireFrameProtocol?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { interactor?.retrieveContacts() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addNewContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from view: ContactListViewProtocol)</span></span></span></span> { wireFrame?.presentAddContactScreen(from: view) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListInteractorOutputProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didRetrieveContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> contacts: [Contact])</span></span></span></span> { view?.reloadInterface(with: contacts.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: $<span class="hljs-number"><span class="hljs-number">0</span></span>.fullName) }) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListPresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddModuleDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didAddContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> contact: Contact)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contactViewModel = <span class="hljs-type"><span class="hljs-type">ContactViewModel</span></span>(fullName: contact.fullName) view?.didInsertContact(contactViewModel) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didCancelAddContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} }</code> </pre> <br><br>  Después de cargar View, notifica a Presenter, que a su vez solicita datos a través de Interactor.  Cuando el usuario hace clic en el botón Agregar nuevo contacto, Ver notifica al presentador, que envía una solicitud para abrir la pantalla Agregar nuevo contacto en el enrutador. <br><br>  Presenter también formatea los datos y los devuelve a la Vista después de consultar la lista de contactos.  También es responsable de implementar el protocolo AddModuleDelegate.  Esto significa que Presenter recibirá una notificación cuando se agregue un nuevo contacto, prepare los datos del contacto para mostrar y transfiera a Ver. <br><br>  Como habrás notado, Presenter tiene muchas posibilidades de volverse bastante engorroso.  Si existe tal posibilidad, el Presentador se puede dividir en dos partes: el Presentador, que solo recibe datos, los formatea para mostrarlos y los pasa a Ver;  y un controlador de eventos que responderá a las acciones del usuario. <br><br>  <b>ENTIDAD</b> <br><br>  Esta capa es similar a la capa Modelo en MVVM.  En nuestra aplicación, está representado por la clase de contacto y las funciones de definición de operador &lt;y&gt;.  <b>El</b> contenido del <b>contacto</b> se verá así: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CoreData open class Contact: NSManagedObject { var fullName: String { get { var name = "" if let firstName = firstName { name += firstName } if let lastName = lastName { name += " " + lastName } return name } } } public struct ContactViewModel { var fullName = "" } public func &lt;(lhs: ContactViewModel, rhs: ContactViewModel) -&gt; Bool { return lhs.fullName.lowercased() &lt; rhs.fullName.lowercased() } public func &gt;(lhs: ContactViewModel, rhs: ContactViewModel) -&gt; Bool { return lhs.fullName.lowercased() &gt; rhs.fullName.lowercased() }</code> </pre> <br><br>  ContactViewModel contiene los campos que presenta el presentador (formatos) que muestra la vista.  La clase Contact es una subclase de NSManagedObject que contiene los mismos campos que en el modelo CoreData. <br><br>  <b>ROUTER</b> <br><br>  Y finalmente, la última, pero ciertamente no importante, capa.  Toda la responsabilidad de la navegación recae en Presenter y WireFrame.  El presentador recibe un evento del usuario y sabe cuándo hacer la transición, y WireFrame sabe cómo y dónde hacer esta transición.  Para que no se confunda, en este ejemplo, la capa Router está representada por la clase ContactListWireFrame y se denomina WireFrame en el texto.  <b>ContactListWireFrame</b> Code: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ContactListWireFrame: ContactListWireFrameProtocol { class func createContactListModule() -&gt; UIViewController { let navController = mainStoryboard.instantiateViewController(withIdentifier: "ContactsNavigationController") if let view = navController.childViewControllers.first as? ContactListView { let presenter: ContactListPresenterProtocol &amp; ContactListInteractorOutputProtocol = ContactListPresenter() let interactor: ContactListInteractorInputProtocol = ContactListInteractor() let localDataManager: ContactListLocalDataManagerInputProtocol = ContactListLocalDataManager() let wireFrame: ContactListWireFrameProtocol = ContactListWireFrame() view.presenter = presenter presenter.view = view presenter.wireFrame = wireFrame presenter.interactor = interactor interactor.presenter = presenter interactor.localDatamanager = localDataManager return navController } return UIViewController() } static var mainStoryboard: UIStoryboard { return UIStoryboard(name: "Main", bundle: Bundle.main) } func presentAddContactScreen(from view: ContactListViewProtocol) { guard let delegate = view.presenter as? AddModuleDelegate else { return } let addContactsView = AddContactWireFrame.createAddContactModule(with: delegate) if let sourceView = view as? UIViewController { sourceView.present(addContactsView, animated: true, completion: nil) } } }</code> </pre> <br><br>  Como WireFrame es responsable de crear el módulo, será conveniente configurar todas las dependencias aquí.  Cuando desee abrir otro controlador, la función que abre el nuevo controlador recibe como argumento el objeto que lo abrirá, y crea un nuevo controlador utilizando su WireFrame.  Además, al crear un nuevo controlador, los datos necesarios se transfieren a él, en este caso solo el delegado (Presentador del controlador con contactos) para recibir el contacto creado. <br><br>  La capa de enrutador ofrece una buena oportunidad para evitar el uso de segues (transiciones) en guiones gráficos y organizar todo el código de navegación.  Dado que los guiones gráficos no proporcionan una solución compacta para transferir datos entre controladores, nuestra implementación de navegación no agregará código adicional.  Todo lo que obtenemos es solo la mejor reutilización. <br><br><br>  <b>Resumen</b> : <br><br>  Puede encontrar ambos proyectos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este repositorio</a> . <br><br>  Como puede ver, MVVM y VIPER, aunque diferentes, no son únicos.  MVVM nos dice que además de Ver y Modelo, también debería haber una capa ViewModel.  Pero no se dice nada sobre cómo se debe crear esta capa, ni sobre cómo se solicitan los datos: la responsabilidad de esta capa no está claramente definida.  Hay muchas formas de implementarlo y puede usar cualquiera de ellas. <br><br>  VIPER, por otro lado, es una arquitectura bastante única.  Consiste en muchas capas, cada una de las cuales tiene un área de responsabilidad bien definida y menos de MVVM está influenciada por el desarrollador. <br><br>  Cuando se trata de elegir una arquitectura, generalmente no existe la única solución correcta, pero aún así intentaré dar algunos consejos.  Si tiene un proyecto grande y largo, con requisitos claros y desea tener muchas oportunidades para reutilizar componentes, entonces VIPER será la mejor solución.  Una delimitación más clara de la responsabilidad hace posible organizar mejor las pruebas y mejorar la reutilización. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440904/">https://habr.com/ru/post/440904/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440894/index.html">Diseño de sonido para Pathfinder: Kingmaker</a></li>
<li><a href="../440896/index.html">Tecnologías aditivas y escaneo 3D en ingeniería mecánica: 7 historias de éxito</a></li>
<li><a href="../440898/index.html">Marketing de contenidos, publicidad contextual, mejora de la conversión: 6 guías útiles de promoción de inicio</a></li>
<li><a href="../440900/index.html">RESTO pasión por 200</a></li>
<li><a href="../440902/index.html">La mitad del reino para la IA: cuánto ahorran los bancos en aprendizaje automático, redes neuronales y bots de chat</a></li>
<li><a href="../440906/index.html">Seminario web "167-ФЗ. Cómo los bancos pueden cumplir los requisitos del Banco Central para los sistemas antifraude ”- 26 de febrero de 2019, 11:00 hora de Moscú</a></li>
<li><a href="../440908/index.html">Servir todo</a></li>
<li><a href="../440910/index.html">¿Por qué los bancos monopolizan blockchain?</a></li>
<li><a href="../440912/index.html">Tal dolor, tal dolor, infraestructura como servicio 1: 0</a></li>
<li><a href="../440914/index.html">Perdí la fe en la industria, me quemé, pero el culto a la herramienta me salvó</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>