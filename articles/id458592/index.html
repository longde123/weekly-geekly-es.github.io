<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸🏾 🐈 🏞️ Dari Latensi Ceph Tinggi ke Patch Kernel dengan eBPF / BCC 🌡️ 🚼 🕶️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Linux memiliki banyak alat dan aplikasi debugging kernel. Sebagian besar dari mereka mempengaruhi kinerja aplikasi dan tidak dapat digunakan dalam pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dari Latensi Ceph Tinggi ke Patch Kernel dengan eBPF / BCC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/selectel/blog/458592/"><img src="https://habrastorage.org/webt/-8/ok/na/-8okna9qfyroicvgoz-zenv7-si.png" alt="gambar"><br><br>  Linux memiliki banyak alat dan aplikasi debugging kernel.  Sebagian besar dari mereka mempengaruhi kinerja aplikasi dan tidak dapat digunakan dalam produksi. <br><a name="habracut"></a><br>  Beberapa tahun yang lalu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat lain dikembangkan</a> - eBPF.  Itu memungkinkan untuk melacak aplikasi kernel dan pengguna dengan overhead rendah dan tanpa perlu membangun kembali program dan memuat modul pihak ketiga ke dalam kernel. <br><br>  Sudah ada banyak utilitas aplikasi yang menggunakan eBPF, dan dalam artikel ini kita akan melihat bagaimana menulis utilitas profil kita sendiri berdasarkan pada pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PythonBCC</a> .  Artikel ini didasarkan pada peristiwa nyata.  Kami akan beralih dari tampilan masalah ke koreksi untuk menunjukkan bagaimana utilitas yang ada dapat digunakan dalam situasi tertentu. <br><br><h2>  Ceph lambat </h2><br>  Host baru telah ditambahkan ke cluster Ceph.  Setelah memigrasi beberapa data ke dalamnya, kami perhatikan bahwa kecepatan pemrosesan permintaan penulisan jauh lebih rendah daripada di server lain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4c/_r/yv/4c_ryvapivstw8l-nr7dipfvh8e.png"></div><br>  Tidak seperti platform lain, bcache dan kernel linux 4.15 baru digunakan pada host ini.  Sejumlah konfigurasi ini digunakan di sini untuk pertama kalinya.  Dan pada saat itu jelas bahwa secara teoritis apa pun bisa menjadi akar masalah. <br><br><h3>  Investigasi tuan rumah </h3><br>  Untuk memulainya, mari kita lihat apa yang terjadi di dalam proses ceph-osd.  Untuk melakukan ini, kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perf</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">flamescope</a> (lebih lanjut tentang yang dapat dibaca di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uw/gj/ox/uwgjoxekagdl-noj-wp_uy5g8q8.png"></div><br>  Gambar memberi tahu kita bahwa fungsi <strong>fdatasync ()</strong> menghabiskan banyak waktu mengirim permintaan ke fungsi <strong>generic_make_request ()</strong> .  Ini berarti bahwa kemungkinan besar penyebab masalahnya adalah di suatu tempat di luar osd daemon itu sendiri.  Itu bisa berupa kernel atau disk.  Output iostat menunjukkan latensi tinggi dalam memproses permintaan dengan bcache disk. <br><br>  Ketika memeriksa host, kami menemukan bahwa daemon systemd-udevd menghabiskan banyak waktu CPU - sekitar 20% pada banyak core.  Ini adalah perilaku yang aneh, jadi Anda perlu mencari tahu penyebabnya.  Karena Systemd-udevd bekerja dengan banyak, kami memutuskan untuk melihatnya melalui <strong>monitor udevadm</strong> .  Ternyata sejumlah besar peristiwa perubahan dihasilkan untuk setiap perangkat blok dalam sistem.  Ini sangat tidak biasa, jadi Anda perlu melihat apa yang menghasilkan semua peristiwa ini. <br><br><h3>  Menggunakan BCC Toolkit </h3><br>  Seperti yang sudah kita ketahui, kernel (dan daemon ceph di system call) menghabiskan banyak waktu di <strong>generic_make_request ()</strong> .  Mari kita coba mengukur kecepatan fungsi ini.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BCC</a> sudah memiliki utilitas yang hebat - <strong>funclatency</strong> .  Kami akan melacak daemon dengan PID-nya dengan interval antara output informasi 1 detik dan output hasilnya dalam milidetik. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/o7/zw/rl/o7zwrly0nejoo5r7zbezws3jxmo.png"></div><br>  Biasanya fungsi ini cepat.  Yang dia lakukan hanyalah mengirim permintaan ke antrian driver perangkat. <br><br>  <strong>Bcache</strong> adalah perangkat kompleks yang sebenarnya terdiri dari tiga disk: <br><br><ul><li>  perangkat pendukung (disk yang di-cache), dalam hal ini HDD yang lambat; </li><li>  perangkat caching (caching disk), ini dia salah satu bagian dari perangkat NVMe; </li><li>  perangkat virtual bcache yang digunakan aplikasi. </li></ul><br>  Kita tahu bahwa pengiriman permintaan lambat, tetapi untuk perangkat yang mana?  Kami akan mengatasinya nanti. <br><br>  Kita sekarang tahu bahwa banyak kemungkinan penyebab masalah.  Menemukan apa yang sebenarnya menyebabkan generasi mereka tidak sesederhana itu.  Misalkan ini adalah semacam perangkat lunak yang berjalan secara berkala.  Mari kita lihat <strong>jenis</strong> perangkat lunak apa yang diluncurkan pada sistem menggunakan skrip <strong>execsnoop</strong> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rangkaian utilitas BCC yang</a> sama.  Jalankan dan arahkan output ke file. <br><br>  Misalnya, seperti ini: <br><br><pre><code class="bash hljs">/usr/share/bcc/tools/execsnoop | tee ./execdump</code> </pre> <br>  Kami tidak akan memberikan hasil lengkap dari execsnoop di sini, tetapi satu baris yang menarik bagi kami tampak seperti ini: <br><br><pre> <code class="bash hljs">sh 1764905 5802 0 sudo arcconf getconfig 1 AD | grep Temperature | awk -F <span class="hljs-string"><span class="hljs-string">'[:/]'</span></span> <span class="hljs-string"><span class="hljs-string">'{print $2}'</span></span> | sed <span class="hljs-string"><span class="hljs-string">'s/^ \([0-9]*\) C.*/\1/'</span></span></code> </pre><br>  Kolom ketiga adalah PPID (induk PID) dari proses.  Proses dengan PID 5802 ternyata menjadi salah satu utas sistem pemantauan kami.  Saat memeriksa konfigurasi sistem pemantauan, ditemukan parameter yang salah.  Suhu adaptor HBA diambil sekali setiap 30 detik, yang jauh lebih sering daripada yang diperlukan.  Setelah mengubah interval verifikasi menjadi yang lebih lama, kami menemukan bahwa keterlambatan dalam memproses permintaan pada host ini tidak lagi menonjol dari host lainnya. <br><br>  Tetapi masih belum jelas mengapa perangkat bcache sangat lambat.  Kami menyiapkan platform pengujian dengan konfigurasi yang identik dan mencoba mereproduksi masalah dengan menjalankan fio on bcache, secara berkala memulai pemicu udevadm untuk menghasilkan uevents. <br><br><h3>  Menulis Alat Berbasis BCC </h3><br>  Mari kita coba menulis utilitas sederhana untuk melacak dan menampilkan panggilan paling lambat ke <strong>generic_make_request ()</strong> .  Kami juga tertarik dengan nama drive tempat fungsi ini dipanggil. <br><br>  Rencananya sederhana: <br><br><ul><li>  Daftarkan <strong>kprobe</strong> ke <strong>generic_make_request ()</strong> : <br><ul><li>  Kami menyimpan nama disk yang dapat diakses melalui argumen fungsi; </li><li>  Simpan cap waktu. </li></ul><br></li></ul><ul><li>  Daftarkan <strong>kretprobe</strong> untuk kembali dari <strong>generic_make_request ()</strong> : <br><ul><li>  Dapatkan cap waktu saat ini; </li><li>  Kami mencari stempel waktu yang disimpan dan membandingkannya dengan yang sekarang; </li><li>  Jika hasilnya lebih besar dari yang ditentukan, maka kami menemukan nama disk yang disimpan dan menampilkannya di terminal. </li></ul><br></li></ul>  <strong>Kprobes</strong> dan <strong>kretprobes</strong> menggunakan mekanisme breakpoint untuk mengubah kode fungsi dengan cepat.  Anda dapat membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> dan artikel yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagus</a> tentang topik ini.  Jika Anda melihat kode berbagai utilitas di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BCC</a> , Anda akan melihat bahwa mereka memiliki struktur yang sama.  Jadi dalam artikel ini kita akan menghilangkan parsing argumen skrip dan beralih ke program BPF itu sendiri. <br><br>  Teks eBPF di dalam skrip python terlihat seperti ini: <br><br><pre> <code class="python hljs">bpf_text = “”” <span class="hljs-comment"><span class="hljs-comment"># Here will be the bpf program code “””</span></span></code> </pre><br>  Untuk bertukar data antar fungsi, program eBPF menggunakan <a href="">tabel hash</a> .  Begitu juga kita.  Sebagai kuncinya, kita akan menggunakan PID dari proses, dan sebagai nilai kita mendefinisikan struktur: <br><br><pre> <code class="python hljs">struct data_t { u64 pid; u64 ts; char comm[TASK_COMM_LEN]; u64 lat; char disk[DISK_NAME_LEN]; }; BPF_HASH(p, u64, struct data_t); BPF_PERF_OUTPUT(events);</code> </pre><br>  Di sini kita mendaftarkan tabel hash yang disebut <em>p</em> , dengan kunci tipe <em>u64</em> dan nilai tipe <em>struct data_t</em> .  Tabel akan tersedia dalam konteks program BPF kami.  Makro BPF_PERF_OUTPUT mendaftarkan tabel lain yang disebut <em>peristiwa</em> , yang digunakan untuk <a href="">mentransfer data</a> ke ruang pengguna. <br><br>  Ketika mengukur penundaan antara panggilan fungsi dan kembali dari panggilan fungsi, atau di antara panggilan ke fungsi yang berbeda, harus diingat bahwa data yang diterima harus berasal dari konteks yang sama.  Dengan kata lain, Anda perlu mengingat tentang kemungkinan peluncuran fungsi secara paralel.  Kami memiliki kesempatan untuk mengukur penundaan antara memanggil fungsi dalam konteks satu proses dan kembali dari fungsi itu dalam konteks proses lain, tetapi ini kemungkinan besar tidak berguna.  Contoh yang baik di sini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utilitas biolatency</a> , di mana pointer ke <em>permintaan struct</em> , yang mencerminkan <em>permintaan</em> disk tunggal, ditetapkan sebagai kunci dalam tabel hash. <br><br>  Selanjutnya, kita perlu menulis kode yang akan dijalankan ketika fungsi yang diselidiki dipanggil: <br><br><pre> <code class="python hljs">void start(struct pt_regs *ctx, struct bio *bio) { u64 pid = bpf_get_current_pid_tgid(); struct data_t data = {}; u64 ts = bpf_ktime_get_ns(); data.pid = pid; data.ts = ts; bpf_probe_read_str(&amp;data.disk, sizeof(data.disk), (void*)bio-&gt;bi_disk-&gt;disk_name); p.update(&amp;pid, &amp;data); }</code> </pre><br>  Di sini, argumen kedua dari fungsi <a href="">generic_make_request ()</a> disebut akan diganti sebagai argumen kedua.  Setelah itu, kami mendapatkan PID dari proses di mana kami bekerja, dan cap waktu saat ini dalam nanodetik.  Kami menulis semua ini di <em>data data_t struct yang baru dialokasikan</em> .  Kami mendapatkan nama disk dari struktur <em>bio</em> , yang diteruskan saat memanggil <strong>generic_make_request ()</strong> , dan menyimpannya dalam struktur <em>data yang</em> sama.  Langkah terakhir adalah menambahkan entri ke tabel hash yang disebutkan sebelumnya. <br><br>  Fungsi berikut akan dipanggil kembali dari <strong>generic_make_request ()</strong> : <br><br><pre> <code class="python hljs">void stop(struct pt_regs *ctx) { u64 pid = bpf_get_current_pid_tgid(); u64 ts = bpf_ktime_get_ns(); struct data_t* data = p.lookup(&amp;pid); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; data-&gt;ts &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { bpf_get_current_comm(&amp;data-&gt;comm, sizeof(data-&gt;comm)); data-&gt;lat = (ts - data-&gt;ts)/<span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data-&gt;lat &gt; MIN_US) { FACTOR data-&gt;pid &gt;&gt;= <span class="hljs-number"><span class="hljs-number">32</span></span>; events.perf_submit(ctx, data, sizeof(struct data_t)); } p.delete(&amp;pid); } }</code> </pre><br>  Fungsi ini mirip dengan yang sebelumnya: kami mengenali proses PID dan timestamp, tetapi tidak mengalokasikan memori untuk struktur data baru.  Sebagai gantinya, kita melihat tabel hash untuk struktur yang ada dengan kunci == PID saat ini.  Jika struktur ditemukan, maka kita akan mengetahui nama proses yang sedang berjalan dan menambahkannya. <br><br>  Pergeseran biner yang kami gunakan di sini diperlukan untuk mendapatkan GID utas.  yaitu  PID dari proses utama yang memulai utas dalam konteks yang sedang kami kerjakan.  Fungsi <a href="">bpf_get_current_pid_tgid () yang</a> kita <a href="">panggil</a> mengembalikan GID dari utas dan PID-nya dalam satu nilai 64-bit. <br><br>  Saat keluaran ke terminal, sekarang kami tidak tertarik pada aliran, tetapi pada proses utama.  Setelah membandingkan keterlambatan yang diterima dengan ambang yang diberikan, kami mentransfer struktur <em>data</em> kami ke ruang pengguna melalui tabel <em>acara</em> , dan kemudian menghapus catatan dari <em>hal</em> . <br><br>  Dalam skrip python yang akan memuat kode ini, kita perlu mengganti MIN_US dan FACTOR dengan ambang keterlambatan dan satuan waktu, yang akan kita bahas melalui argumen: <br><br><pre> <code class="python hljs">bpf_text = bpf_text.replace(<span class="hljs-string"><span class="hljs-string">'MIN_US'</span></span>,str(min_usec)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args.milliseconds: bpf_text = bpf_text.replace(<span class="hljs-string"><span class="hljs-string">'FACTOR'</span></span>,<span class="hljs-string"><span class="hljs-string">'data-&gt;lat /= 1000;'</span></span>) label = <span class="hljs-string"><span class="hljs-string">"msec"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: bpf_text = bpf_text.replace(<span class="hljs-string"><span class="hljs-string">'FACTOR'</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>) label = <span class="hljs-string"><span class="hljs-string">"usec"</span></span></code> </pre><br>  Sekarang kita perlu menyiapkan program BPF melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">makro BPF</a> dan mendaftarkan sampel: <br><br><pre> <code class="python hljs">b = BPF(text=bpf_text) b.attach_kprobe(event=<span class="hljs-string"><span class="hljs-string">"generic_make_request"</span></span>,fn_name=<span class="hljs-string"><span class="hljs-string">"start"</span></span>) b.attach_kretprobe(event=<span class="hljs-string"><span class="hljs-string">"generic_make_request"</span></span>,fn_name=<span class="hljs-string"><span class="hljs-string">"stop"</span></span>)</code> </pre><br>  Kami juga harus mendefinisikan <em>struct data_t</em> dalam skrip kami, jika tidak, kami tidak akan dapat membaca apa pun: <br><br><pre> <code class="python hljs">TASK_COMM_LEN = <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-comment"><span class="hljs-comment"># linux/sched.h DISK_NAME_LEN = 32 # linux/genhd.h class Data(ct.Structure): _fields_ = [("pid", ct.c_ulonglong), ("ts", ct.c_ulonglong), ("comm", ct.c_char * TASK_COMM_LEN), ("lat", ct.c_ulonglong), ("disk",ct.c_char * DISK_NAME_LEN)]</span></span></code> </pre><br>  Langkah terakhir adalah output data ke terminal: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cpu, data, size)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> start event = ct.cast(data, ct.POINTER(Data)).contents <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> start == <span class="hljs-number"><span class="hljs-number">0</span></span>: start = event.ts time_s = (float(event.ts - start)) / <span class="hljs-number"><span class="hljs-number">1000000000</span></span> print(<span class="hljs-string"><span class="hljs-string">"%-18.9f %-16s %-6d %-1s %s %s"</span></span> % (time_s, event.comm, event.pid, event.lat, label, event.disk)) b[<span class="hljs-string"><span class="hljs-string">"events"</span></span>].open_perf_buffer(print_event) <span class="hljs-comment"><span class="hljs-comment"># format output start = 0 while 1: try: b.perf_buffer_poll() except KeyboardInterrupt: exit()</span></span></code> </pre><br>  Skrip itu sendiri tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GItHub</a> .  Mari kita coba jalankan di platform uji di mana fio ditulis dalam bcache dan panggil monitor udevadm: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0q/wl/yo/0qwlyofk3ynh0ksh1rcqe_9kt6w.png"></div><br>  Akhirnya!  Sekarang kita melihat bahwa apa yang tampak seperti perangkat pengereman bcache sebenarnya adalah panggilan pengereman ke <strong>generic_make_request ()</strong> pada drive yang di-cache. <br><br><h3>  Gali ke dalam kernel </h3><br>  Apa yang sebenarnya melambat selama pengiriman permintaan?  Kami melihat bahwa keterlambatan terjadi bahkan sebelum dimulainya penghitungan permintaan, yaitu  memperhitungkan permintaan khusus untuk statistik lebih lanjut tentang itu (/ proc / diskstats atau iostat) belum dimulai.  Ini dapat dengan mudah diverifikasi dengan menjalankan iostat saat mereproduksi masalah, atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skrip biolatensi BCC</a> , yang didasarkan pada awal dan akhir dari akuntansi permintaan.  Tak satu pun dari utilitas ini akan menunjukkan masalah untuk permintaan ke drive yang di-cache. <br><br>  Jika kita melihat fungsi <strong>generic_make_request ()</strong> , kita akan melihat bahwa dua fungsi lagi dipanggil sebelum permintaan <strong>direkam</strong> .  Yang pertama, <strong>generic_make_request_checks ()</strong> , memeriksa keabsahan permintaan untuk pengaturan disk.  Yang kedua adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blk_queue_enter ()</a> , yang memiliki panggilan menarik ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wait_event_interruptible ()</a> : <br><br><pre> <code class="python hljs">ret = wait_event_interruptible(q-&gt;mq_freeze_wq, (atomic_read(&amp;q-&gt;mq_freeze_depth) == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; (preempt || !blk_queue_preempt_only(q))) || blk_queue_dying(q));</code> </pre><br>  Di dalamnya, kernel menunggu pencairan antrian.  Kami mengukur keterlambatan <strong>blk_queue_enter ()</strong> : <br><br><pre> <code class="bash hljs">~<span class="hljs-comment"><span class="hljs-comment"># /usr/share/bcc/tools/funclatency blk_queue_enter -i 1 -m Tracing 1 functions for "blk_queue_enter"... Hit Ctrl-C to end. msecs : count distribution 0 -&gt; 1 : 341 |****************************************| msecs : count distribution 0 -&gt; 1 : 316 |****************************************| msecs : count distribution 0 -&gt; 1 : 255 |****************************************| 2 -&gt; 3 : 0 | | 4 -&gt; 7 : 0 | | 8 -&gt; 15 : 1 | |</span></span></code> </pre><br>  Tampaknya kita sudah dekat dengan solusi.  Fungsi yang digunakan untuk "membekukan / mencairkan" antrian adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blk_mq_freeze_queue</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blk_mq_unfreeze_queue</a> .  Mereka digunakan ketika perlu untuk mengubah pengaturan antrian permintaan, yang berpotensi berbahaya untuk permintaan dalam antrian ini.  Ketika <strong>blk_mq_freeze_queue ()</strong> dipanggil, fungsi <strong>blk_freeze_queue_start ()</strong> menambah <strong>q-&gt; mq_freeze_depth counter</strong> .  Setelah itu, kernel menunggu pengosongan antrian di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blk_mq_freeze_queue_wait ()</a> . <br><br>  Waktu tunggu untuk menghapus antrian ini sama dengan latensi disk, karena kernel menunggu semua operasi yang antri untuk menyelesaikan.  Segera setelah antrian kosong, perubahan pada pengaturan diterapkan.  Kemudian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blk_mq_unfreeze_queue ()</a> dipanggil, mengurangi counter <strong>freeze_depth</strong> . <br><br>  Sekarang kita cukup tahu untuk memperbaiki situasi.  Perintah memicu udevadm menghasilkan aplikasi pengaturan untuk perangkat blok.  Pengaturan ini dijelaskan dalam aturan udev.  Kita dapat mengetahui pengaturan mana yang “membekukan” antrian dengan mencoba mengubahnya melalui sysfs atau dengan melihat kode sumber kernel.  Kita juga dapat mencoba utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jejak</a> BCC, yang menampilkan tumpukan kernel dan jejak ruang pengguna untuk terminal untuk setiap panggilan <strong>blk_freeze_queue</strong> , misalnya: <br><br><pre> <code class="bash hljs">~<span class="hljs-comment"><span class="hljs-comment"># /usr/share/bcc/tools/trace blk_freeze_queue -K -U PID TID COMM FUNC 3809642 3809642 systemd-udevd blk_freeze_queue blk_freeze_queue+0x1 [kernel] elevator_switch+0x29 [kernel] elv_iosched_store+0x197 [kernel] queue_attr_store+0x5c [kernel] sysfs_kf_write+0x3c [kernel] kernfs_fop_write+0x125 [kernel] __vfs_write+0x1b [kernel] vfs_write+0xb8 [kernel] sys_write+0x55 [kernel] do_syscall_64+0x73 [kernel] entry_SYSCALL_64_after_hwframe+0x3d [kernel] __write_nocancel+0x7 [libc-2.23.so] [unknown] 3809631 3809631 systemd-udevd blk_freeze_queue blk_freeze_queue+0x1 [kernel] queue_requests_store+0xb6 [kernel] queue_attr_store+0x5c [kernel] sysfs_kf_write+0x3c [kernel] kernfs_fop_write+0x125 [kernel] __vfs_write+0x1b [kernel] vfs_write+0xb8 [kernel] sys_write+0x55 [kernel] do_syscall_64+0x73 [kernel] entry_SYSCALL_64_after_hwframe+0x3d [kernel] __write_nocancel+0x7 [libc-2.23.so] [unknown]</span></span></code> </pre><br>  Aturan Udev jarang berubah dan biasanya ini terjadi di bawah kendali.  Jadi kita melihat bahwa bahkan penggunaan nilai yang sudah ditetapkan menyebabkan lonjakan keterlambatan dalam mengirimkan permintaan dari aplikasi ke disk.  Tentu saja, untuk menghasilkan peristiwa udev ketika tidak ada perubahan dalam konfigurasi disk (misalnya, perangkat tidak terhubung / terputus) bukan praktik yang baik.  Namun, kami dapat membantu kernel tidak bekerja sia-sia dan tidak membekukan antrian permintaan jika ini tidak diperlukan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tiga</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komit</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kecil</a> memperbaiki situasi. <br><br><h2>  Kesimpulan </h2><br>  eBPF adalah alat yang sangat fleksibel dan kuat.  Dalam artikel tersebut, kami memeriksa satu kasus praktis dan menunjukkan sebagian kecil dari apa yang mungkin dilakukan.  Jika Anda tertarik untuk mengembangkan utilitas BCC, Anda harus melihat pada <a href="">tutorial resmi</a> , yang menjelaskan dasar-dasarnya dengan baik. <br><br>  Ada alat debugging dan profiling menarik lainnya berdasarkan eBPF.  Salah satunya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bpftrace</a> , yang memungkinkan Anda untuk menulis program baris tunggal dan kecil yang kuat dalam bahasa mirip bahasa awk.  Lain - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ebpf_exporter</a> , memungkinkan Anda untuk mengumpulkan metrik resolusi tinggi tingkat rendah langsung ke server prometheus Anda, dengan kemampuan untuk mendapatkan visualisasi yang indah dan bahkan peringatan di masa depan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458592/">https://habr.com/ru/post/id458592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458572/index.html">Anatoly Slyusar: "Masa komputer Uni Eropa memungkinkan kami untuk melatih sistem dan pemrogram yang diterapkan"</a></li>
<li><a href="../id458574/index.html">Bagaimana tumbuh dari pengembang menjadi pemimpin tim dan hidup dengannya lebih jauh</a></li>
<li><a href="../id458576/index.html">Manajemen teks dan pelokalan dalam aplikasi web</a></li>
<li><a href="../id458582/index.html">Insinyur Amazon telah menciptakan perangkat pemblokiran AI yang menjaga kucing keluar dari jalan</a></li>
<li><a href="../id458584/index.html">11 Juli, Group-IB Webinar “Analisis Malware untuk Pemula: Pendekatan Dasar”</a></li>
<li><a href="../id458594/index.html">Jangan lupa untuk meningkatkan kemungkinan respons terhadap klien menggunakan permintaan berulang dalam penyeimbangan L7</a></li>
<li><a href="../id458596/index.html">Petty little joy # 6: OpenAI Gym - mainkan game dan kendalikan robot</a></li>
<li><a href="../id458598/index.html">Pengakuan sumber cahaya pada peta lingkungan</a></li>
<li><a href="../id458602/index.html">Bagaimana kami menembus Great Chinese Firewall (Bagian 1)</a></li>
<li><a href="../id458604/index.html">Mengapa dua produsen elektronik terbesar bergabung dalam proyek GPU baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>