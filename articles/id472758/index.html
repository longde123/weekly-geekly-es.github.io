<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŒ ğŸ’© ğŸ‚ğŸ¿ Proposal: coba - fungsi pengecekan kesalahan bawaan ğŸ–•ğŸ» ğŸ¨ ğŸ˜‰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ringkasan 


 try konstruk baru diusulkan yang secara khusus dirancang untuk menghilangkan if -ekspresi umumnya terkait dengan penanganan kesalahan di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Proposal: coba - fungsi pengecekan kesalahan bawaan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472758/"><h2 id="kratkoe-soderzhanie">  Ringkasan </h2><br><p> <code>try</code> konstruk baru diusulkan yang secara khusus dirancang untuk menghilangkan <code>if</code> -ekspresi umumnya terkait dengan penanganan kesalahan di Go.  Ini adalah satu-satunya perubahan bahasa.  Penulis mendukung penggunaan fungsi <code>defer</code> dan perpustakaan standar untuk memperkaya atau membungkus kesalahan.  Ekstensi kecil ini cocok untuk sebagian besar skenario, praktis tanpa menyulitkan bahasa. </p><br><p>  Konstruk <code>try</code> mudah dijelaskan, mudah diimplementasikan, fungsi ini ortogonal untuk konstruk bahasa lain dan sepenuhnya kompatibel ke belakang.  Itu juga bisa diperluas jika kita menginginkannya di masa depan. </p><br><p>  Sisa dokumen ini disusun sebagai berikut: setelah pengantar singkat, kami memberikan definisi fungsi bawaan dan menjelaskan penggunaannya dalam praktik.  Bagian diskusi mengulas saran alternatif dan desain saat ini.  Pada akhirnya, kesimpulan dan rencana implementasi dengan contoh dan bagian dari pertanyaan dan jawaban akan diberikan. </p><a name="habracut"></a><br><h2 id="vvedenie">  Pendahuluan </h2><br><p>  Pada konferensi Gophercon terakhir di Denver, anggota tim Go (Russ Cox, Marcel van Lohuizen) mempresentasikan beberapa ide baru tentang cara mengurangi kebosanan penanganan kesalahan manual di Go ( <a href="">rancangan desain</a> ).  Sejak itu kami telah menerima sejumlah besar umpan balik. </p><br><p>  Sebagaimana dijelaskan oleh Russ Cox dalam <a href="">ulasannya tentang masalah tersebut</a> , tujuan kami adalah membuat penanganan kesalahan menjadi lebih ringan dengan mengurangi jumlah kode yang ditujukan khusus untuk pengecekan kesalahan.  Kami juga ingin membuat kode penanganan kesalahan penulisan lebih nyaman, meningkatkan kemungkinan bahwa pengembang masih akan mencurahkan waktu untuk memperbaiki penanganan kesalahan.  Pada saat yang sama, kami ingin membiarkan kode penanganan kesalahan terlihat jelas dalam kode program. </p><br><p>  Ide-ide yang dibahas dalam draft konsep terkonsentrasi di sekitar pernyataan <code>check</code> unary baru, yang menyederhanakan verifikasi eksplisit dari nilai kesalahan yang diperoleh dari beberapa ekspresi (biasanya panggilan fungsi), serta deklarasi penangan kesalahan ( <code>handle</code> ) dan seperangkat aturan yang menghubungkan dua konstruksi bahasa baru ini. </p><br><p>  Sebagian besar umpan balik yang kami terima berfokus pada detail dan kompleksitas desain <code>handle</code> , dan gagasan operator <code>check</code> ternyata lebih menarik.  Bahkan, beberapa anggota komunitas mengambil ide operator <code>check</code> dan memperluasnya.  Berikut adalah beberapa posting yang paling mirip dengan penawaran kami: </p><br><ul><li>  Proposal tertulis pertama (diketahui oleh kami) untuk menggunakan konstruksi <code>check</code> alih-alih operator diusulkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PeterRK</a> di posnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">. Bagian penting dari penanganan kesalahan</a> </li><li>  Belum lama ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Markus</a> mengusulkan dua kata kunci baru, <code>guard</code> dan <code>must</code> bersama dengan menggunakan <code>defer</code> untuk membungkus kesalahan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="># 31442</a> </li><li>  Juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pjebs</a> menyarankan <code>must</code> membangun di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="># 32219</a> </li></ul><br><p>  Proposal saat ini, meskipun berbeda dalam rinciannya, didasarkan pada ketiganya dan, secara umum, pada umpan balik yang diterima pada rancangan desain yang diusulkan tahun lalu. </p><br><p>  Untuk melengkapi gambar, kami ingin mencatat bahwa lebih banyak saran penanganan kesalahan dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman wiki ini</a> .  Perlu juga dicatat bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Liam Breck</a> datang dengan serangkaian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">persyaratan</a> untuk mekanisme penanganan kesalahan. </p><br><p>  Akhirnya, setelah publikasi proposal ini, kami mengetahui bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ryan Hileman</a> menerapkan <code>try</code> lima tahun lalu menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat penulis ulang</a> dan berhasil menggunakannya dalam proyek nyata.  Lihat ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://news.ycombinator.com/item?id=20101417</a> ). </p><br><h2 id="vstroennaya-funkciya-try">  Fungsi coba bawaan </h2><br><h3 id="predlozhenie">  Tawarkan </h3><br><p>  Kami menyarankan untuk menambahkan elemen bahasa seperti fungsi yang disebut <code>try</code> dan dipanggil dengan tanda tangan </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(expr)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T1, T2, ... Tn)</span></span></span></span></code> </pre> <br><p>  di mana <code>expr</code> berarti ekspresi dari parameter input (biasanya panggilan fungsi) yang mengembalikan n + 1 nilai tipe <code>T1, T2, ... Tn</code> dan <code>error</code> untuk nilai terakhir.  Jika <code>expr</code> adalah nilai tunggal (n = 0), nilai ini harus bertipe <code>error</code> dan <code>try</code> tidak mengembalikan hasilnya.  Memanggil <code>try</code> dengan ekspresi yang tidak mengembalikan nilai <code>error</code> tipe terakhir menghasilkan kesalahan kompilasi. </p><br><p>  Konstruk <code>try</code> hanya dapat digunakan dalam fungsi yang mengembalikan setidaknya satu nilai, dan nilai pengembalian terakhirnya adalah tipe <code>error</code> .  Memanggil <code>try</code> dalam konteks lain mengarah ke kesalahan kompilasi. </p><br><p>  Panggil <code>try</code> dengan <code>f()</code> seperti pada contoh </p><br><pre> <code class="go hljs">x1, x2, â€¦ xn = try(f())</code> </pre> <br><p>  mengarah ke kode berikut: </p><br><pre> <code class="go hljs">t1, â€¦ tn, te := f() <span class="hljs-comment"><span class="hljs-comment">// t1, â€¦ tn,  ()   if te != nil { err = te //  te    error return //     } x1, â€¦ xn = t1, â€¦ tn //     //    </span></span></code> </pre><br><p>  Dengan kata lain, jika tipe <code>error</code> terakhir yang dikembalikan oleh <code>expr</code> adalah <code>nil</code> , maka <code>try</code> mengembalikan nilai n pertama, menghapus <code>nil</code> terakhir. </p><br><p>  Jika nilai terakhir yang dikembalikan oleh <code>expr</code> tidak <code>nil</code> , maka: </p><br><ul><li>  Nilai pengembalian <code>error</code> dari fungsi melampirkan (dalam pseudocode di atas bernama <code>err</code> , meskipun ini bisa berupa pengidentifikasi atau nilai pengembalian tidak bernama) menerima nilai kesalahan yang dikembalikan dari <code>expr</code> </li><li>  ada jalan keluar dari fungsi membungkus </li><li>  jika fungsi melampirkan memiliki parameter pengembalian tambahan, parameter ini mempertahankan nilai-nilai yang terkandung di dalamnya sebelum panggilan <code>try</code> . </li><li>  jika fungsi melampirkan memiliki parameter pengembalian tanpa nama tambahan, nilai nol yang sesuai dikembalikan untuk mereka (yang identik dengan menyimpan nilai nol aslinya dengan mana mereka diinisialisasi). </li></ul><br><p>  Jika <code>try</code> digunakan dalam banyak penugasan, seperti dalam contoh di atas, dan kesalahan bukan nol (selanjutnya tidak-nol - Per.) Terdeteksi, penugasan (oleh variabel pengguna) tidak dilakukan, dan tidak ada variabel di sisi kiri penugasan yang berubah.  Yaitu, <code>try</code> berperilaku seperti panggilan fungsi: hasilnya hanya tersedia jika <code>try</code> mengembalikan kontrol ke penelepon (sebagai lawan kasus dengan pengembalian dari fungsi terlampir).  Akibatnya, jika variabel di sisi kiri penugasan adalah parameter kembali, menggunakan <code>try</code> akan menghasilkan perilaku yang berbeda dari kode khas yang ditemui sekarang.  Misalnya, jika <code>a,b, err</code> dinamai parameter pengembalian fungsi melampirkan, berikut adalah kode ini: </p><br><pre> <code class="go hljs">a, b, err = f() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br><p>  akan selalu memberikan nilai ke variabel <code>a, b</code> dan <code>err</code> , terlepas dari apakah panggilan ke <code>f()</code> mengembalikan kesalahan atau tidak.  Tantangan yang bertolak belakang </p><br><pre> <code class="go hljs">a, b = try(f())</code> </pre> <br><p>  dalam hal terjadi kesalahan, biarkan <code>a</code> dan <code>b</code> tidak berubah.  Terlepas dari kenyataan bahwa ini adalah nuansa yang halus, kami percaya bahwa kasus seperti itu cukup langka.  Jika perilaku tugas tanpa syarat diperlukan, Anda harus terus menggunakan <code>if</code> ekspresi. </p><br><h3 id="ispolzovanie">  Gunakan </h3><br><p>  Definisi <code>try</code> secara eksplisit memberi tahu Anda cara menggunakannya: banyak ekspresi <code>if</code> yang memeriksa pengembalian kesalahan dapat diganti dengan <code>try</code> .  Sebagai contoh: </p><br><pre> <code class="go hljs">f, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> â€¦, err <span class="hljs-comment"><span class="hljs-comment">//       }</span></span></code> </pre> <br><p>  dapat disederhanakan menjadi </p><br><pre> <code class="go hljs">f := try(os.Open(filename))</code> </pre> <br><p>  Jika fungsi panggilan tidak mengembalikan kesalahan, <code>try</code> tidak dapat digunakan (lihat bagian Diskusi).  Dalam hal ini, kesalahan harus diproses secara lokal (karena tidak ada pengembalian kesalahan), dan dalam kasus ini, <code>if</code> tetap mekanisme yang tepat untuk memeriksa kesalahan. </p><br><p>  Secara umum, tujuan kami bukan untuk mengganti semua pemeriksaan kesalahan yang mungkin dengan <code>try</code> .  Kode yang memerlukan semantik yang berbeda dapat dan harus terus digunakan <code>if</code> ekspresi dan variabel eksplisit dengan nilai kesalahan. </p><br><h3 id="testirovanie-i-try">  Menguji dan mencoba </h3><br><p>  Dalam salah satu upaya kami sebelumnya untuk menulis spesifikasi (lihat bagian iterasi desain di bawah), <code>try</code> dirancang untuk panik ketika kesalahan terjadi ketika digunakan di dalam fungsi tanpa kesalahan kembali.  Ini diizinkan menggunakan <code>try</code> dalam unit berdasarkan pada paket <code>testing</code> pustaka standar. </p><br><p>  Sebagai salah satu opsi, dimungkinkan untuk menggunakan fungsi pengujian dengan tanda tangan dalam paket <code>testing</code> </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestXxx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*testing.T)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkXxx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*testing.B)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><p>  untuk memungkinkan penggunaan uji coba.  Fungsi tes yang mengembalikan kesalahan bukan nol secara implisit akan memanggil <code>t.Fatal(err)</code> atau <code>b.Fatal(err)</code> .  Ini adalah perubahan perpustakaan kecil yang menghindari perlunya perilaku yang berbeda (kembali atau panik) untuk <code>try</code> , tergantung pada konteksnya. </p><br><p>  Salah satu kelemahan dari pendekatan ini adalah bahwa <code>t.Fatal</code> dan <code>b.Fatal</code> tidak akan dapat mengembalikan nomor baris di mana tes jatuh.  Kerugian lainnya adalah kita harus mengubah subtitle juga.  Solusi untuk masalah ini adalah pertanyaan terbuka;  kami tidak mengusulkan perubahan spesifik pada paket <code>testing</code> dalam dokumen ini. </p><br><p>  Lihat juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="># 21111</a> , yang menyarankan agar fungsi contoh mengembalikan kesalahan. </p><br><h3 id="obrabotka-oshibok">  Menangani kesalahan </h3><br><p>  <a href="">Draf desain</a> asli sebagian besar berkaitan dengan dukungan bahasa untuk kesalahan pembungkus atau penambahan.  Draf mengusulkan <code>handle</code> kata kunci baru dan cara baru untuk <em>menyatakan penangan kesalahan</em> .  Konstruksi bahasa baru ini menarik masalah seperti lalat karena semantik non-sepele, terutama ketika mempertimbangkan efeknya pada aliran eksekusi.  Secara khusus, fungsionalitas <code>handle</code> disilang dengan fungsi <code>defer</code> , yang membuat fitur bahasa baru menjadi non-ortogonal bagi yang lainnya. </p><br><p>  Proposal ini mengurangi esensi rancangan asli.  Jika pengayaan atau pembungkus kesalahan diperlukan, ada dua pendekatan: lampirkan <code>if err != nil { return err}</code> , atau "nyatakan" penangan kesalahan di dalam ekspresi <code>defer</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      -   err = â€¦ // /  } }()</span></span></code> </pre> <br><p>  Dalam contoh ini, <code>err</code> adalah nama parameter pengembalian <code>error</code> ketik fungsi melampirkan. </p><br><p>  Dalam praktiknya, kami membayangkan fungsi pembantu seperti </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleErrorf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err *error, format </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, args ...</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { *err = fmt.Errorf(format + <span class="hljs-string"><span class="hljs-string">": %v"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(args, *err)...) } }</code> </pre><br><p>  atau yang serupa.  Paket <code>fmt</code> dapat menjadi tempat alami untuk pembantu seperti itu (sudah menyediakan <code>fmt.Errorf</code> ).  Menggunakan bantuan, definisi penangan kesalahan dalam banyak kasus akan dikurangi menjadi satu baris.  Misalnya, untuk memperkaya kesalahan dari fungsi "salin", Anda dapat menulis </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> fmt.HandleErrorf(&amp;err, <span class="hljs-string"><span class="hljs-string">"copy %s %s"</span></span>, src, dst)</code> </pre><br><p>  jika <code>fmt.HandleErrorf</code> secara implisit menambahkan informasi kesalahan. Konstruksi semacam itu cukup mudah dibaca dan memiliki kelebihan yang dapat diimplementasikan tanpa menambahkan elemen baru dari sintaks bahasa. </p><br><p>  Kerugian utama dari pendekatan ini adalah bahwa parameter kesalahan yang dikembalikan harus dinamai, yang berpotensi mengarah ke API yang kurang akurat (lihat FAQ tentang topik ini).  Kami percaya bahwa kami akan terbiasa ketika gaya penulisan kode yang sesuai dibuat. </p><br><h3 id="effektivnost-defer">  Penundaan efisiensi </h3><br><p>  Pertimbangan penting saat menggunakan <code>defer</code> sebagai penangan kesalahan adalah efisiensi.  Ekspresi <code>defer</code> dianggap <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lambat</a> .  Kami tidak ingin memilih antara kode efisien dan penanganan kesalahan yang baik.  Terlepas dari proposal ini, tim runtime Go dan kompiler membahas metode implementasi alternatif, dan kami percaya bahwa kami dapat membuat cara khas menggunakan defer untuk menangani kesalahan yang sebanding dalam efisiensi dengan kode "manual" yang ada.  Kami berharap dapat menambahkan implementasi <code>defer</code> lebih cepat di Go 1.14 (lihat juga tiket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CL 171158</a> , yang merupakan langkah pertama ke arah ini). </p><br><h3 id="specialnye-sluchai-go-tryf-defer-tryf">  Kasus khusus, <code>go try(f), defer try(f)</code> </h3><br><p>  Konstruk <code>try</code> terlihat seperti fungsi, dan karena ini, diharapkan dapat digunakan di mana saja di mana panggilan fungsi dapat diterima.  Namun, jika <code>try</code> call digunakan dalam pernyataan <code>go</code> , segalanya menjadi rumit: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> try(f())</code> </pre><br><p>  Di sini <code>f()</code> dieksekusi ketika ekspresi go dieksekusi di goroutine saat ini, hasil pemanggilan <code>f</code> dilewatkan sebagai argumen untuk <code>try</code> , yang dimulai pada goroutine baru.  Jika <code>f</code> mengembalikan kesalahan bukan nol, <code>try</code> diharapkan untuk kembali dari fungsi melampirkan;  Namun, tidak ada fungsi (dan tidak ada parameter pengembalian <code>error</code> tipe), karena  kode dieksekusi di goroutine terpisah.  Karena itu, kami sarankan untuk menonaktifkan <code>try</code> dalam ekspresi <code>go</code> . </p><br><p>  Situasi dengan </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> try(f())</code> </pre><br><p>  terlihat serupa, tetapi di sini semantik <code>defer</code> berarti bahwa pelaksanaan <code>try</code> akan ditunda sampai kembali dari fungsi melampirkan.  Seperti sebelumnya, <code>f()</code> dievaluasi ketika <code>defer</code> , dan hasilnya diteruskan ke <code>try</code> ditunda. </p><br><p>  <code>try</code> periksa kesalahan <code>f()</code> dikembalikan hanya pada saat-saat terakhir sebelum kembali dari fungsi melampirkan.  Tanpa mengubah perilaku <code>try</code> , kesalahan semacam itu dapat menimpa nilai kesalahan lain yang coba dikembalikan oleh fungsi terlampir.  Ini paling membingungkan, paling buruk itu memprovokasi kesalahan.  Karena itu, kami mengusulkan agar Anda melarang panggilan <code>try</code> dalam pernyataan <code>defer</code> juga.  Kami selalu dapat mempertimbangkan kembali keputusan ini jika ada aplikasi semantik yang masuk akal. </p><br><p>  Akhirnya, seperti sisa konstruksi bawaan, <code>try</code> hanya dapat digunakan sebagai panggilan;  itu tidak dapat digunakan sebagai fungsi nilai atau dalam ekspresi penugasan variabel seperti dalam <code>f := try</code> (sama seperti <code>f := print</code> dan <code>f := new</code> dilarang). </p><br><h2 id="obsuzhdenie">  Diskusi </h2><br><h3 id="iteracii-dizayna">  Iterasi desain </h3><br><p>  Berikut ini adalah diskusi singkat dari desain sebelumnya yang mengarah ke proposal minimal saat ini.  Kami berharap ini akan menjelaskan keputusan desain yang dipilih. </p><br><p>  Iterasi pertama kami dari kalimat ini terinspirasi oleh dua gagasan dari artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Bagian Kunci Penanganan Kesalahan,"</a> yaitu, menggunakan fungsi bawaan sebagai ganti operator dan fungsi Go biasa untuk menangani kesalahan alih-alih konstruksi bahasa baru.  Tidak seperti publikasi itu, penangan kesalahan kami memiliki kesalahan <code>func(error) error</code> tanda tangan tetap untuk menyederhanakan masalah.  Penangan kesalahan akan dipanggil oleh fungsi <code>try</code> jika ada kesalahan sebelum <code>try</code> akan keluar dari fungsi melampirkan.  Berikut ini sebuah contoh: </p><br><pre> <code class="go hljs">handler := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"foo failed: %v"</span></span>, err) <span class="hljs-comment"><span class="hljs-comment">//   } f := try(os.Open(filename), handler) //     </span></span></code> </pre><br><p>  Sementara pendekatan ini memungkinkan definisi dari penangan kesalahan yang didefinisikan pengguna yang efektif, pendekatan ini juga menimbulkan banyak pertanyaan yang jelas tidak memiliki jawaban yang benar: Apa yang harus terjadi jika nihil diteruskan ke penangan?  Haruskah Anda <code>try</code> panik atau menganggap ini sebagai kekurangan pawang?  Bagaimana jika pawang dipanggil dengan kesalahan bukan nol dan kemudian mengembalikan hasil nol?  Apakah ini berarti kesalahannya "dibatalkan"?  Atau haruskah fungsi melampirkan mengembalikan kesalahan kosong?  Ada juga keraguan bahwa transfer opsional penangan kesalahan akan mendorong pengembang untuk mengabaikan kesalahan alih-alih memperbaikinya.  Ini juga akan mudah untuk melakukan penanganan kesalahan yang benar di mana-mana, tetapi lewati satu kali <code>try</code> .  Dan sejenisnya. </p><br><p>  Dalam iterasi berikutnya, kemampuan untuk melewati penangan kesalahan khusus dihapus karena menggunakan <code>defer</code> untuk membungkus kesalahan.  Ini tampak seperti pendekatan yang lebih baik karena itu membuat penangan kesalahan jauh lebih terlihat dalam kode sumber.  Langkah ini juga menghilangkan semua masalah tentang transfer opsional fungsi handler, tetapi menuntut agar parameter yang dikembalikan dengan jenis <code>error</code> dinamai jika akses diperlukan (kami memutuskan bahwa ini normal).  Selain itu, dalam upaya membuat <code>try</code> berguna tidak hanya di dalam fungsi yang mengembalikan kesalahan, perlu untuk membuat perilaku <code>try</code> context-sensitive: jika <code>try</code> digunakan pada tingkat paket, atau jika itu disebut di dalam fungsi yang tidak mengembalikan kesalahan, <code>try</code> otomatis panik ketika kesalahan terdeteksi.  (Dan sebagai efek samping, karena properti ini, konstruksi bahasa dipanggil <code>must</code> alih-alih <code>try</code> dalam kalimat itu.) Perilaku sensitif konteks <code>try</code> (atau <code>must</code> ) tampak alami dan juga cukup berguna: itu akan menghilangkan banyak fungsi yang ditentukan pengguna yang digunakan dalam ekspresi menginisialisasi variabel paket.  Ini juga membuka kemungkinan menggunakan <code>try</code> dalam unit dengan paket <code>testing</code> . </p><br><p>  Namun, perilaku <code>try</code> - <code>try</code> peka konteks penuh dengan kesalahan: misalnya, perilaku fungsi menggunakan <code>try</code> dapat dengan diam-diam berubah (panik atau tidak) ketika menambahkan atau menghapus kesalahan pengembalian ke tanda tangan fungsi.  Ini properti yang tampaknya terlalu berbahaya.  Solusi yang jelas adalah untuk membagi fungsionalitas <code>try</code> menjadi dua <code>must</code> terpisah dan fungsi <code>try</code> , (sangat mirip dengan cara yang disarankan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="># 31442</a> ).  Namun, ini akan membutuhkan dua fungsi bawaan, sementara hanya <code>try</code> secara langsung terkait dengan dukungan yang lebih baik untuk penanganan kesalahan. </p><br><p>  Oleh karena itu, dalam iterasi saat ini, alih-alih menyertakan fungsi bawaan kedua, kami memutuskan untuk menghapus semantik ganda <code>try</code> dan, oleh karena itu, memungkinkan penggunaannya hanya dalam fungsi yang mengembalikan kesalahan. </p><br><h3 id="osobennosti-predlozhennogo-dizayna">  Fitur desain yang diusulkan </h3><br><p>  Saran ini cukup singkat dan mungkin tampak mundur dibandingkan dengan draft tahun lalu.  Kami percaya bahwa solusi yang dipilih dibenarkan: </p><br><ul><li><p>  Hal pertama yang pertama, <code>try</code> memiliki semantik yang sama persis dengan pernyataan <code>check</code> yang diusulkan dalam aslinya tanpa <code>handle</code> .  Ini menegaskan kesetiaan draft asli di salah satu aspek penting. </p><br></li><li><p>  Memilih fungsi bawaan bukannya operator memiliki beberapa keunggulan.  Itu tidak memerlukan kata kunci baru seperti <code>check</code> , yang akan membuat desain tidak kompatibel dengan parser yang ada.  Juga tidak perlu memperluas sintaks ekspresi dengan operator baru.  Menambahkan fungsi bawaan yang baru relatif sepele dan sepenuhnya ortogonal ke fitur bahasa lainnya. </p><br></li><li><p>  Menggunakan fungsi sebaris alih-alih operator membutuhkan penggunaan tanda kurung.  Kita harus menulis <code>try(f())</code> daripada <code>try f()</code> .  Ini adalah harga (kecil) yang harus kami bayar untuk kompatibilitas mundur dengan parser yang ada.  Namun, ini juga membuat desain tersebut kompatibel dengan versi-versi mendatang: jika kita memutuskan untuk melewati beberapa bentuk fungsi penanganan kesalahan atau menambahkan parameter tambahan untuk <code>try</code> untuk tujuan ini adalah ide yang bagus, menambahkan argumen tambahan ke panggilan panggilan akan sepele. </p><br></li><li><p>  Ternyata, kebutuhan untuk menulis tanda kurung memiliki kelebihan.  Dalam ekspresi yang lebih kompleks dengan beberapa panggilan <code>try</code> , tanda kurung meningkatkan keterbacaan dengan menghilangkan kebutuhan untuk berurusan dengan prioritas operator, seperti dalam contoh berikut: </p><br></li></ul><br><pre> <code class="go hljs">info := try(try(os.Open(file)).Stat()) <span class="hljs-comment"><span class="hljs-comment">//   try info := try (try os.Open(file)).Stat() //  try   info := try (try (os.Open(file)).Stat()) //  try  </span></span></code> </pre><br><p>     <code>try</code> ,      :       <code>try</code> , ..   <code>try</code>   (receiver)  <code>.Stat</code> (  <code>os.Open</code> ). </p><br><p>     <code>try</code> ,        :    <code>os.Open(file)</code> ..       <code>try</code> (  ,   <code>try</code>    <code>os</code> ,   ,   <code>try</code>      <code>try</code> ). </p><br><p>           , ..      . </p><br><ul><li>           .   ,          .   ,      ,      ,     . </li></ul><br><h2 id="vyvody">  </h2><br><p>       <a href="">  </a>         .    ,      .            <code>defer</code> ,           . </p><br><p>  Go         -  ,         . ,   Go     <code>append</code> .     <code>append</code>         ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>     .    ,       .  ,        <code>try</code> . </p><br><p>          ,     ,   Go      : <code>panic</code>  <code>recover</code> .   <code>error</code>   <code>try</code>   . </p><br><p>  , <code>try</code>     ,     ,      â€”      â€”   ,     .        Go: </p><br><ul><li>       </li><li>     , <code>try</code>       </li><li>      </li><li>    - </li></ul><br><p>        ,    ,       .     <code>if</code> -. </p><br><h2 id="realizaciya">  Implementasi </h2><br><p>   : </p><br><ul><li>   Go. </li><li>     <code>try</code> . ,            .      . </li><li>  <code>go/types</code>  <code>try</code> .   . </li><li>    <code>gccgo</code> . ( ,  ). </li><li>      . </li></ul><br><p>    -  ,     . ,        .           . </p><br><p> Robert Griesemer    <code>go/types</code> ,     () <code>cmd/compile</code> .    ,         Go 1.14,  1  2019. </p><br><p> , Ian Lance Taylor    <code>gccgo</code> ,    . </p><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Go 2,  !"</a> ,                . </p><br><p> 1 ,    ,      ,    Go 1.14  . </p><br><p>  </p><br><p>  <code>CopyFile</code>     : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src, dst </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"copy %s %s: %v"</span></span>, src, dst, err) } }() r := try(os.Open(src)) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> r.Close() w := try(os.Create(dst)) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { w.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { os.Remove(dst) <span class="hljs-comment"><span class="hljs-comment">//    â€œtryâ€    } }() try(io.Copy(w, r)) try(w.Close()) return nil }</span></span></code> </pre><br><p>   ,    " ",  <code>defer</code>  : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> fmt.HandleErrorf(&amp;err, <span class="hljs-string"><span class="hljs-string">"copy %s %s"</span></span>, src, dst)</code> </pre><br><p>           (  <code>defer</code> -),        <code>defer</code>     ,    . </p><br><p>  <code>printSum</code>          </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { x := try(strconv.Atoi(a)) y := try(strconv.Atoi(b)) fmt.Println(<span class="hljs-string"><span class="hljs-string">"result:"</span></span>, x + y) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><p>   : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { fmt.Println( <span class="hljs-string"><span class="hljs-string">"result:"</span></span>, try(strconv.Atoi(a)) + try(strconv.Atoi(b)), ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><p>  <code>main</code>  <a href="">   </a>      : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">localMain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { hex := try(ioutil.ReadAll(os.Stdin)) data := try(parseHexdump(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(hex))) try(os.Stdout.Write(data)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := localMain(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }</code> </pre><br><p> -   <code>try</code>      ,        : </p><br><pre> <code class="plaintext hljs">n, err := src.Read(buf) if err == io.EOF { break } try(err)</code> </pre><br><h2 id="voprosy-i-otvety">    </h2><br><p> ,     . </p><br><p> <strong>:        ?</strong> </p><br><p> :        <code>check</code>  <code>handle</code> ,     .  ,  <code>handle</code>          <code>defer</code> ,   <code>handle</code>   . </p><br><p> <strong>:  try   ?</strong> </p><br><p> :    <code>try</code>     Go     .       -  ,           .          ,     .        ,     "  ".  <code>try</code>     , ..          . </p><br><p> <strong>:  <code>try</code>  try?</strong> </p><br><p> :    ,  <code>check</code> , <code>must</code>  <code>do</code> .   <code>try</code>            ,           . <code>try</code>       <code>check</code> (,        ),  -       .         .         <code>must</code>          ; <code>try</code> â€”  . ,  Rust  Swift   <code>try</code>       (   ).         . </p><br><p> <strong>:      <code>?</code>   Rust?</strong> </p><br><p> : Go      ;  ,           Go (        ;   -   ).         ,     <code>?</code> ,      .   , ,   ,     (package, interface, if, append, recover, ...),  ,        (struct, var, func, int, len, image,  ..). Rust   <code>?</code>     <code>try</code>   â€”      Go,    ,   (   )   . ,  <code>?</code>      .    ,   ,     (,   ..)  .       .       ,   . </p><br><p> <strong>:       ( error)  ,  defer   ,   go doc.    ?</strong> </p><br><p> :     <code>go doc</code>   ,       -   ( <code>_</code> ) ,         . ,  <code>func f() (_ A, _ B, err error)</code>    <code>go doc</code>  <code>func f() (A, B, error)</code> .      ,   ,     ,      .  ,         ,     . ,   ,    ,       -,       (deferred) .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jonathan Geddes</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>   <code>try()</code>        . </p><br><p> <strong>:     defer    ?</strong> </p><br><p> :    <code>defer</code>          . ,  ,       defer         "" . .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CL 171758</a> ,     defer   30%. </p><br><p> <strong>:           ?</strong> </p><br><p> :  ,        . ,         ( ,    ),      .     <code>defer</code>              ,     .   <code>defer</code> -   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://golang.org/issue/29934</a> (   Go 2),    . </p><br><p> <strong>:  ,   try,    error.  ,       ?</strong> </p><br><p> :           <code>error</code> (  )   ,  ,     <code>nil</code> .           <code>try</code> . (      ,  .     - ). </p><br><p> <strong>:    Go  ,     try   ?</strong> </p><br><p> :  <code>try</code>     ,   <code>try</code> .    <code>super return</code> -, <code>try</code>      <code>Go</code>        . <code>try</code>       .     <em></em>  . </p><br><p> <strong>:     try   ,         .   ?</strong> </p><br><p> : <code>try</code>        ;       ,     .       <code>try</code>    ( ),     .   , <code>if</code>   . </p><br><p> <strong>:   ,       .    try,    defer    .   ?</strong> </p><br><p> :         ,       .     . </p><br><p> <strong>:  <code>try</code>     (  <code>catch</code> )?</strong> </p><br><p> : <code>try</code> â€”   ("")      ,  ,      (    )   . <code>try</code>   ;       .        .     "" .     ,        .  , <code>try</code> â€”      .   ,  ,       <code>throw</code>  <code>try-catch</code>     Go. ,         (,    ),     (   )     ,      .    ""      <code>try-catch</code> ,       . ,    ,      .  Go    .     <code>panic</code> ,       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472758/">https://habr.com/ru/post/id472758/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472746/index.html">Server terminal untuk admin; Tidak ada celah SSH tunggal</a></li>
<li><a href="../id472748/index.html">Browser semantik atau kehidupan tanpa situs</a></li>
<li><a href="../id472750/index.html">OK, apakah saya benar-benar membutuhkan Kubernet?</a></li>
<li><a href="../id472752/index.html">CSE: Kubernetes untuk siapa pun di vCloud</a></li>
<li><a href="../id472754/index.html">Cara berbicara bahasa Inggris dalam sebulan. 9 langkah mudah dan terbukti</a></li>
<li><a href="../id472760/index.html">Kurangi waktu komputasi dari beberapa tahun menjadi beberapa menit. Memahami pembelajaran mesin kuantum</a></li>
<li><a href="../id472762/index.html">Analisis teknis eksploitasi checkm8</a></li>
<li><a href="../id472766/index.html">Parameterisasi dari file di py.test</a></li>
<li><a href="../id472768/index.html">Cara merekrut, memecat, dan kembali dari manajemen ke pengembangan: video dari Badoo Techleads Meetup # 5</a></li>
<li><a href="../id472770/index.html">Organisasi antarmuka dalam Persatuan dengan Kanvas UI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>