<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÜîÔ∏è üë©üèª‚Äçüíº üõåüèæ Jenis Kompilasi di JVM: Mengekspos Sesi Sihir Hitam ü¶ã üå∏ ü§òüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 

 Hari ini, perhatian Anda diundang ke terjemahan artikel, yang menunjukkan contoh opsi kompilasi di JVM. Perhatian khusus diberikan p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jenis Kompilasi di JVM: Mengekspos Sesi Sihir Hitam</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/466529/">  Halo semuanya! <br><br>  Hari ini, perhatian Anda diundang ke terjemahan artikel, yang menunjukkan contoh opsi kompilasi di JVM.  Perhatian khusus diberikan pada kompilasi AOT yang didukung di Java 9 dan di atasnya. <br><br>  Selamat membaca! <br><a name="habracut"></a><br>  Saya percaya siapa pun yang pernah diprogram di Jawa telah mendengar kompilasi instan (JIT), dan mungkin kompilasi sebelum eksekusi (AOT).  Selain itu, tidak perlu menjelaskan apa itu bahasa "ditafsirkan".  Artikel ini akan menjelaskan bagaimana semua fitur ini diimplementasikan dalam mesin virtual Java, JVM. <br><br>  Anda mungkin tahu bahwa ketika memprogram di Jawa, Anda perlu menjalankan kompiler (menggunakan program ‚Äújavac‚Äù) yang mengumpulkan kode sumber Java (file .java) ke dalam bytecode Java (file .class).  Bytecode Java adalah bahasa perantara.  Ini disebut "perantara" karena tidak dipahami oleh perangkat komputasi nyata (CPU) dan tidak dapat dieksekusi oleh komputer dan, dengan demikian, merupakan bentuk transisi antara kode sumber dan kode mesin "asli" yang dieksekusi dalam prosesor. <br><br>  Agar bytecode Java melakukan pekerjaan tertentu, ada 3 cara untuk melakukannya: <br><br><ol><li>  Langsung jalankan kode perantara.  Lebih baik dan lebih benar untuk mengatakan bahwa itu perlu "ditafsirkan".  JVM memiliki juru bahasa Java.  Seperti yang Anda ketahui, agar JVM berfungsi, Anda harus menjalankan program "java". </li><li>  Tepat sebelum menjalankan kode perantara, kompilasi ke dalam kode asli dan paksakan CPU untuk mengeksekusi kode asli yang baru dipanggang ini.  Dengan demikian, kompilasi terjadi sesaat sebelum eksekusi (Just in Time) dan disebut "dinamis". </li><li>  3Hal pertama, bahkan sebelum program diluncurkan, kode perantara diterjemahkan ke dalam bahasa asli dan menjalankannya melalui CPU dari awal hingga akhir.  Kompilasi ini dilakukan sebelum eksekusi dan disebut AoT (Ahead of Time). </li></ol><br>  Jadi, (1) adalah karya penerjemah, (2) adalah hasil dari kompilasi JIT, dan (3) adalah hasil dari kompilasi AOT. <br><br>  Demi kelengkapan, saya akan menyebutkan bahwa ada pendekatan keempat - untuk langsung menafsirkan kode sumber, tetapi di Jawa ini tidak diterima.  Ini dilakukan, misalnya, dengan Python. <br>  Sekarang mari kita lihat bagaimana "java" bekerja sebagai (1) juru bahasa dari (2) kompiler JIT dan / atau (3) kompiler AOT - dan kapan. <br><br>  Singkatnya - sebagai aturan, "java" melakukan keduanya (1) dan (2).  Dimulai dengan Java 9, opsi ketiga juga dimungkinkan. <br><br>  Inilah kelas <code>Test</code> kami, yang akan digunakan dalam contoh di masa mendatang. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { System.out.println(<span class="hljs-string"><span class="hljs-string">"call "</span></span> + Integer.valueOf(i)); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a = System.nanoTime(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test().f(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> b = System.nanoTime(); System.out.println(<span class="hljs-string"><span class="hljs-string">"elapsed= "</span></span> + (ba)); } } }</code> </pre> <br>  Seperti yang Anda lihat, ada metode <code>main</code> yang instantiate objek <code>Test</code> dan secara otomatis memanggil fungsi <code>f</code> 10 kali berturut-turut.  Fungsi <code>f</code> hampir tidak menghasilkan apa-apa. <br><br>  Jadi, jika Anda mengkompilasi dan menjalankan kode di atas, output akan sangat diharapkan (tentu saja, nilai waktu yang telah berlalu akan berbeda untuk Anda): <br><br><pre> <code class="plaintext hljs">call 1 elapsed= 5373 call 2 elapsed= 913 call 3 elapsed= 654 call 4 elapsed= 623 call 5 elapsed= 680 call 6 elapsed= 710 call 7 elapsed= 728 call 8 elapsed= 699 call 9 elapsed= 853 call 10 elapsed= 645</code> </pre> <br>  Dan sekarang pertanyaannya adalah: apakah kesimpulan ini hasil dari pekerjaan "java" sebagai penerjemah, yaitu, opsi (1), "java" sebagai kompiler JIT, yaitu, opsi (2) atau entah bagaimana itu terkait dengan kompilasi AOT , yaitu opsi (3)?  Dalam artikel ini saya akan menemukan jawaban yang tepat untuk semua pertanyaan ini. <br><br>  Jawaban pertama yang ingin saya berikan adalah kemungkinan besar bahwa hanya (1) yang terjadi di sini.  Saya katakan "kemungkinan besar", karena saya tidak tahu apakah ada variabel lingkungan yang ditetapkan di sini yang akan mengubah opsi JVM default.  Jika tidak ada yang berlebihan diinstal, dan ini adalah bagaimana "java" bekerja secara default, maka di sini kita 100% mengamati opsi yang adil (1), yaitu, kode sepenuhnya ditafsirkan.  Saya yakin akan hal ini, karena: <br><br><ul><li>  Menurut dokumentasi java, opsi <code>-XX:CompileThreshold=invocations</code> dimulai dengan <code>invocations=1500</code> default <code>invocations=1500</code> pada klien JVM (lebih lanjut tentang klien JVM dijelaskan di bawah).  Karena saya menjalankannya hanya 10 kali, dan 10 &lt;1500, kita tidak berbicara tentang kompilasi dinamis di sini.  Biasanya, opsi baris perintah ini menentukan berapa kali (maksimum) fungsi harus ditafsirkan sebelum langkah kompilasi dinamis dimulai.  Saya akan membahas ini di bawah. </li><li>  Sebenarnya, saya menjalankan kode ini dengan tanda diagnostik, jadi saya tahu jika kode itu dikompilasi secara dinamis.  Saya juga akan menjelaskan poin ini di bawah ini. </li></ul><br>  Harap dicatat: JVM dapat bekerja dalam mode klien atau server, dan opsi yang ditetapkan secara default dalam kasus pertama dan kedua akan berbeda.  Sebagai aturan, keputusan tentang mode startup dibuat secara otomatis, tergantung pada lingkungan atau komputer tempat JVM diluncurkan.  Selanjutnya, saya akan menentukan opsi <code>‚Äìclient</code> selama semua dimulai, agar tidak meragukan bahwa program sedang berjalan dalam mode klien.  Opsi ini tidak akan memengaruhi aspek yang ingin saya tunjukkan di pos ini. <br><br>  Jika Anda menjalankan "java" dengan opsi <code>-XX:PrintCompilation</code> , program akan mencetak baris ketika fungsi dikompilasi secara dinamis.  Jangan lupa bahwa kompilasi JIT dilakukan untuk setiap fungsi secara terpisah, beberapa fungsi di kelas mungkin tetap dalam bytecode (yaitu, tidak dikompilasi), sementara yang lain mungkin sudah melewati kompilasi JIT, yaitu, siap untuk dieksekusi langsung di prosesor . <br><br>  Di bawah ini saya juga menambahkan opsi <code>-Xbatch</code> .  Opsi <code>-Xbatch</code> diperlukan hanya untuk membuat output terlihat lebih rapi;  jika tidak, kompilasi JIT berlangsung secara kompetitif (bersama dengan interpretasi), dan output setelah kompilasi terkadang terlihat aneh saat runtime (karena <code>-XX:PrintCompilation</code> ).  Namun, opsi <code>‚ÄìXbatch</code> menonaktifkan kompilasi latar belakang, oleh karena itu, sebelum menjalankan kompilasi JIT, eksekusi program kami akan dihentikan. <br><br>  (Demi keterbacaan, saya akan menulis setiap opsi dari baris baru) <br><br><pre> <code class="plaintext hljs">$ java -client -Xbatch -XX:+PrintCompilation Test</code> </pre> <br>  Saya tidak akan menyisipkan output dari perintah ini di sini, karena secara default JVM mengkompilasi banyak fungsi internal (terkait, misalnya, untuk paket java, sun, jdk), sehingga output akan sangat panjang - jadi, di layar saya, ada 274 baris pada fungsi internal , dan beberapa lagi - hingga akhir program).  Untuk mempermudah penelitian ini, saya akan membatalkan kompilasi JIT untuk kelas dalam atau secara selektif mengaktifkannya hanya untuk metode saya ( <code>Test.f</code> ).  Untuk melakukan ini, tentukan satu opsi lagi, <code>-XX:CompileCommand</code> .  Anda dapat menentukan banyak perintah (kompilasi), sehingga akan lebih mudah untuk menempatkannya dalam file terpisah.  Untungnya, kami memiliki opsi <code>-XX:CompileCommandFile</code> .  Jadi, beralihlah ke membuat file.  Saya akan menyebutnya <code>hotspot_compiler</code> karena alasan yang akan saya jelaskan segera dan tulis yang berikut ini: <br><br><pre> <code class="plaintext hljs">quiet exclude java/* * exclude jdk/* * exclude sun/* *</code> </pre> <br>  Dalam hal ini, harus sepenuhnya jelas bahwa kita mengecualikan semua fungsi (* terakhir) di semua kelas dari semua paket yang dimulai dengan java, jdk dan sun (nama paket dipisahkan oleh /, dan Anda dapat menggunakan *).  Perintah <code>quiet</code> memberitahu JVM untuk tidak menulis apa pun tentang kelas yang dikecualikan, jadi hanya mereka yang sekarang dikompilasi akan output ke konsol.  Jadi, saya jalankan: <br><br><pre> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler Test</code> </pre> <br>  Sebelum memberitahu Anda tentang output dari perintah ini, saya mengingatkan Anda bahwa saya menamai file ini <code>hotspot_compiler</code> , karena tampaknya (saya tidak memeriksa) bahwa dalam Oracle JDK nama <code>.hotspot_compiler</code> diatur secara default untuk file dengan perintah kompiler. <br><br>  Jadi kesimpulannya adalah: <br><br><pre> <code class="plaintext hljs">many lines like this 111 1 n 0 java.lang.invoke.MethodHandle::linkToStatic(LLLLLL)L (native) (static) call 1 some more lines like this 161 48 n 0 java.lang.invoke.MethodHandle::linkToStatic(ILIJL)I (native) (static) elapsed= 7558 call 2 elapsed= 1532 call 3 elapsed= 920 call 4 elapsed= 732 call 5 elapsed= 774 call 6 elapsed= 815 call 7 elapsed= 767 call 8 elapsed= 765 call 9 elapsed= 757 call 10 elapsed= 868</code> </pre> <br>  Pertama, saya tidak tahu mengapa beberapa metode <code>java.lang.invoke.MethodHandler.</code> masih dikompilasi <code>java.lang.invoke.MethodHandler.</code>  Mungkin, beberapa hal tidak bisa dimatikan.  Karena saya mengerti apa masalahnya, saya akan memperbarui pos ini.  Namun, seperti yang Anda lihat, semua langkah kompilasi lainnya (sebelumnya ada 274 baris) kini telah menghilang.  Dalam contoh lebih lanjut, saya juga akan menghapus <code>java.lang.invoke.MethodHandler</code> dari output log kompilasi. <br><br>  Mari kita lihat apa yang telah kita lakukan.  Sekarang kita memiliki kode sederhana di mana kita menjalankan fungsi kita 10 kali.  Saya sebutkan sebelumnya bahwa fungsi ini ditafsirkan, tidak dikompilasi, seperti yang ditunjukkan dalam dokumentasi, dan sekarang kita melihatnya di log (pada saat yang sama, kita tidak melihatnya dalam kompilasi log, dan ini berarti bahwa itu tidak dikompilasi dengan JIT).  Nah, Anda baru saja melihat alat "java" dalam aksi, menafsirkan dan hanya menafsirkan fungsi kami dalam 100% kasus.  Jadi, kita dapat mencentang kotak yang menemukan dengan opsi (1).  Kami lolos ke (2), kompilasi dinamis. <br><br>  Menurut dokumentasi, Anda dapat menjalankan fungsi 1.500 kali dan memastikan bahwa kompilasi JIT benar-benar terjadi.  Namun, Anda juga dapat menggunakan <code>-XX:CompileThreshold=invocations</code> panggilan <code>-XX:CompileThreshold=invocations</code> , mengatur nilai yang diinginkan alih-alih 1500.  Mari kita tunjukkan di sini 5. Ini berarti bahwa kita mengharapkan yang berikut: setelah 5 "interpretasi" fungsi kita f, JVM harus mengkompilasi metode, dan kemudian menjalankan versi yang dikompilasi. <br>  java -client -Xbatch <br><br><pre> <code class="plaintext hljs">-XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 Test</code> </pre> <br>  Jika Anda menjalankan perintah ini, Anda mungkin telah memperhatikan bahwa tidak ada yang berubah dibandingkan dengan contoh di atas.  Artinya, kompilasi masih belum terjadi.  Ternyata, menurut dokumentasi, <code>-XX:CompileThreshold</code> hanya berfungsi ketika <code>TieredCompilation</code> dinonaktifkan, yang merupakan default.  <code>-XX:-TieredCompilation</code> seperti ini: <code>-XX:-TieredCompilation</code> .  Tiered Compilation adalah fitur yang diperkenalkan di Java 7 untuk meningkatkan kecepatan peluncuran dan daya jelajah JVM.  Dalam konteks posting ini, itu tidak penting, jadi silakan menonaktifkannya.  Sekarang mari kita jalankan perintah ini lagi: <br><br><pre> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation Test</code> </pre> <br>  Ini adalah output (saya ingat, saya telah melewatkan baris tentang <code>java.lang.invoke.MethodHandle</code> ): <br><br><pre> <code class="plaintext hljs">call 1 elapsed= 9411 call 2 elapsed= 1291 call 3 elapsed= 862 call 4 elapsed= 1023 call 5 227 56 b Test::&lt;init&gt; (5 bytes) 228 57 b Test::f (4 bytes) elapsed= 1051739 call 6 elapsed= 18516 call 7 elapsed= 940 call 8 elapsed= 769 call 9 elapsed= 855 call 10 elapsed= 838</code> </pre> <br>  Kami menyambut (halo!) Fungsi yang dikompilasi secara dinamis Test.f atau <code>Test::&lt;init&gt;</code> segera setelah memanggil nomor 5, karena saya mengatur CompileThreshold ke 5. JVM menginterpretasikan fungsi 5 kali, kemudian mengkompilasinya dan akhirnya menjalankan versi yang dikompilasi.  Karena fungsi ini dikompilasi, ia harus berjalan lebih cepat, tetapi kami tidak dapat memverifikasi ini di sini, karena fungsi ini tidak melakukan apa pun.  Saya pikir ini adalah topik yang bagus untuk pos terpisah. <br><br>  Seperti yang mungkin sudah Anda tebak, fungsi lain dikompilasi di sini, yaitu <code>Test::&lt;init&gt;</code> , yang merupakan konstruktor dari kelas <code>Test</code> .  Karena kode memanggil constructor ( <code>Test()</code> baru <code>Test()</code> ), setiap kali <code>f</code> dipanggil, ia mengkompilasi secara bersamaan dengan fungsi <code>f</code> , tepat setelah 5 panggilan. <br><br>  Pada prinsipnya, ini dapat mengakhiri diskusi opsi (2), kompilasi JIT.  Seperti yang Anda lihat, dalam kasus ini, fungsi pertama kali ditafsirkan oleh JVM, kemudian secara dinamis dikompilasi setelah interpretasi lima kali lipat.  Saya ingin menambahkan detail terakhir tentang kompilasi JIT, yaitu, untuk menyebutkan opsi <code>-XX:+PrintAssembly</code> .  Seperti namanya, itu output ke konsol versi terkompilasi dari fungsi (versi dikompilasi = kode mesin asli = kode assembler).  Namun, ini hanya akan berfungsi jika ada disassembler di jalur perpustakaan.  Saya kira disassembler mungkin berbeda di JVM yang berbeda, tetapi dalam kasus ini kita berurusan dengan hsdis - disassembler untuk openjdk.  Kode sumber perpustakaan hsdis atau file binernya dapat diambil di tempat yang berbeda.  Dalam hal ini, saya mengkompilasi file ini dan meletakkan <code>hsdis-amd64.so</code> di <code>JAVA_HOME/lib/server</code> . <br><br>  Jadi sekarang kita bisa menjalankan perintah ini.  Tetapi pertama-tama saya harus menambahkan itu untuk menjalankan <code>-XX:+PrintAssembly</code> juga perlu menambahkan opsi <code>-XX:+UnlockDiagnosticVMOptions</code> , dan harus mengikuti sebelum opsi <code>PrintAssembly</code> .  Jika ini tidak dilakukan, maka JVM akan memberi Anda peringatan tentang penggunaan opsi <code>PrintAssembly</code> .  Mari kita jalankan kode ini: <br><br><pre> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly Test</code> </pre> <br>  Outputnya akan panjang, dan akan ada baris seperti: <br><br><pre> <code class="plaintext hljs">0x00007f4b7cab1120: mov 0x8(%rsi),%r10d 0x00007f4b7cab1124: shl $0x3,%r10 0x00007f4b7cab1128: cmp %r10,%rax</code> </pre> <br>  Seperti yang Anda lihat, fungsi yang sesuai dikompilasi ke dalam kode mesin asli. <br><br>  Akhirnya, diskusikan opsi 3, AOT.  Kompilasi sebelum eksekusi, AOT, tidak tersedia di Java sebelum versi 9. <br><br>  Alat baru telah muncul di JDK 9, jaotc - seperti namanya, itu adalah kompiler AOT untuk Java.  Idenya adalah ini: jalankan Java "javac" compiler, kemudian compiler AOT untuk Java "jaotc", dan kemudian jalankan JVM "java" seperti biasa.  JVM biasanya melakukan interpretasi dan kompilasi JIT.  Namun, jika fungsi memiliki kode yang dikompilasi AOT, ia langsung menggunakannya, dan tidak menggunakan interpretasi atau kompilasi JIT.  Biarkan saya jelaskan: Anda tidak harus menjalankan kompiler AOT, itu adalah opsional, dan jika Anda menggunakannya, Anda hanya dapat mengkompilasi kelas yang Anda inginkan sebelum dijalankan. <br><br>  Mari kita membangun perpustakaan yang terdiri dari versi <code>Test::f</code> dikompilasi AOT.  Jangan lupa: untuk melakukannya sendiri, Anda membutuhkan JDK 9 dalam versi 150+. <br><br><pre> <code class="plaintext hljs">jaotc --output=libTest.so Test.class</code> </pre> <br>  Akibatnya, <code>libTest.so</code> dihasilkan, pustaka yang berisi kode fungsi asli yang dikompilasi AOT yang termasuk dalam kelas <code>Test</code> .  Anda dapat melihat karakter yang ditentukan di perpustakaan ini: <br><br><pre> <code class="plaintext hljs">nm libTest.so</code> </pre> <br>  Dalam kesimpulan kami, antara lain, akan ada: <br><br><pre> <code class="plaintext hljs">0000000000002120 t Test.f()I 00000000000021a0 t Test.&lt;init&gt;()V 00000000000020a0 t Test.main([Ljava/lang/String;)V</code> </pre> <br>  Jadi, semua fungsi kita, konstruktor, <code>f</code> , metode statis <code>main</code> ada di <code>libTest.so</code> perpustakaan. <br><br>  Seperti dalam kasus opsi "java" yang sesuai, dalam hal ini opsi dapat disertai dengan file, untuk ini ada opsi -compile-commands ke jaotc.  JEP 295 memberikan contoh yang relevan yang tidak akan saya perlihatkan di sini. <br><br>  Sekarang mari kita jalankan "java" dan lihat apakah metode yang dikompilasi AOT digunakan.  Jika Anda menjalankan "java" seperti sebelumnya, maka pustaka AOT tidak akan digunakan, dan ini tidak mengejutkan.  Untuk menggunakan fitur baru ini, opsi <code>-XX:AOTLibrary</code> disediakan, yang harus Anda tentukan: <br><br><pre> <code class="plaintext hljs">java -XX:AOTLibrary=./libTest.so Test</code> </pre> <br>  Anda dapat menentukan beberapa pustaka AOT, dipisahkan dengan koma. <br><br>  Output dari perintah ini persis sama dengan ketika memulai "java" tanpa <code>AOTLibrary</code> , karena perilaku program Test tidak berubah sama sekali.  Untuk memeriksa apakah fungsi yang dikompilasi AOT digunakan, Anda dapat menambahkan opsi baru, <code>-XX:+PrintAOT</code> . <br><br><pre> <code class="plaintext hljs">java -XX:AOTLibrary=./libTest.so -XX:+PrintAOT Test</code> </pre> <br>  Sebelum hasil <code>Test</code> Program, perintah ini menunjukkan yang berikut: <br><br><pre> <code class="plaintext hljs"> 9 1 loaded ./libTest.so aot library 99 1 aot[ 1] Test.main([Ljava/lang/String;)V 99 2 aot[ 1] Test.f()I 99 3 aot[ 1] Test.&lt;init&gt;()V</code> </pre> <br>  Seperti yang direncanakan, pustaka AOT dimuat, dan fungsi yang dikompilasi AOT digunakan. <br><br>  Jika Anda tertarik, Anda dapat menjalankan perintah berikut dan memeriksa apakah kompilasi JIT terjadi. <br><br><pre> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation -XX:AOTLibrary=./libTest.so -XX:+PrintAOT Test</code> </pre> <br>  Seperti yang diharapkan, kompilasi JIT tidak terjadi, karena metode di kelas Test dikompilasi sebelum eksekusi dan disediakan sebagai perpustakaan. <br><br>  Sebuah pertanyaan yang mungkin adalah: jika kita memberikan kode fungsi asli, lalu bagaimana JVM menentukan apakah kode asli sudah usang / basi?  Sebagai contoh terakhir, mari kita modifikasi fungsi <code>f</code> dan atur menjadi 6. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre> <br>  Saya melakukan ini hanya untuk memodifikasi file kelas.  Sekarang kita membuat kompilasi javac dan menjalankan perintah yang sama seperti di atas. <br><br><pre> <code class="plaintext hljs">javac Test.java java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation -XX:AOTLibrary=./libTest.so -XX:+PrintAOT Test</code> </pre> <br>  Seperti yang Anda lihat, saya tidak menjalankan "jaotc" setelah "javac", jadi kode dari pustaka AOT sekarang sudah tua dan salah, dan fungsi <code>f</code> memiliki a = 5. <br><br>  Output dari perintah "java" di atas menunjukkan: <br><br><pre> <code class="plaintext hljs">228 56 b Test::&lt;init&gt; (5 bytes) 229 57 b Test::f (5 bytes)</code> </pre> <br>  Ini berarti bahwa fungsi dalam hal ini dikompilasi secara dinamis, sehingga kode yang dihasilkan dari kompilasi AOT tidak digunakan.  Jadi, perubahan telah terdeteksi di file kelas.  Ketika kompilasi dilakukan menggunakan javac, sidik jarinya dimasukkan ke dalam kelas, dan sidik jari kelas juga disimpan di perpustakaan AOT.  Karena sidik jari baru dari kelas berbeda dari yang disimpan di perpustakaan AOT, kode asli yang dikompilasi sebelumnya (AOT) tidak digunakan.  Itu saja yang ingin saya ceritakan tentang opsi kompilasi terakhir, sebelum eksekusi. <br><br>  Dalam artikel ini, saya mencoba menjelaskan dan mengilustrasikan dengan contoh-contoh realistis sederhana bagaimana JVM mengeksekusi kode Java: menafsirkannya, mengkompilasi secara dinamis (JIT) atau di muka (AOT) - apalagi, kesempatan terakhir hanya muncul di JDK 9. Saya harap Anda mempelajari sesuatu baru. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466529/">https://habr.com/ru/post/id466529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466517/index.html">Pelatihan lokalisasi Universitas Washington</a></li>
<li><a href="../id466519/index.html">Analisis terperinci AWS Lambda</a></li>
<li><a href="../id466521/index.html">C for Metal - logam mulia untuk komputasi pada kartu grafis Intel</a></li>
<li><a href="../id466525/index.html">Apa itu tata letak iPhone PSD dan bagaimana menggunakannya?</a></li>
<li><a href="../id466527/index.html">Menguji fungsionalitas pengguna situs web dengan objek halaman Capybara</a></li>
<li><a href="../id466533/index.html">Pastilda: hasil</a></li>
<li><a href="../id466535/index.html">Memikirkan kembali deepClone</a></li>
<li><a href="../id466537/index.html">Menggunakan modul JavaScript dalam produksi: keadaan saat ini. Bagian 1</a></li>
<li><a href="../id466539/index.html">Menggunakan modul JavaScript dalam produksi: keadaan saat ini. Bagian 2</a></li>
<li><a href="../id466541/index.html">Menggunakan DbTool untuk Menyemai Basis Data dalam Aplikasi .NET (Core)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>