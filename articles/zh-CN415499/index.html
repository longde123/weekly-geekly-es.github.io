<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒 🛅 🍳 如何停止害怕Proguard并开始生活 🤱🏼 🍥 🤣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您好，我是一名Android开发人员，我不再担心ProGuard ... 


通常，在遇到dalvik dex-limit问题或需要提高应用程序安全性时会记住该实用程序。 不幸的是，要正确配置Proguard并不是第一次。 在中断项目之后，我经常看到有多少人关闭了Proguard并打开了Muldi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何停止害怕Proguard并开始生活</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415499/"><p><img src="https://habrastorage.org/webt/ws/uk/rs/wsukrsowhkx1zzbqyocrumhhsmi.png"></p><br><p> 您好，我是一名Android开发人员，我不再担心ProGuard ... </p><br><p>通常，在遇到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dalvik dex-limit问题</a>或需要提高应用程序安全性时会记住该实用程序。 不幸的是，要正确配置Proguard并不是第一次。 在中断项目之后，我经常看到有多少人关闭了Proguard并打开了Mulditex支持，而每次我对此感到有点难过，因为Proguard既有助于减小应用程序的大小，又可以提高其性能。 </p><br><p> 最后，我决定写一篇文章，其中可以介绍我在与Proguard一起工作的几年中学到的所有有用信息，并且可以对初学者和已经知道一些知识的人都有帮助。 </p><a name="habracut"></a><br><h2 id="o-chem-eto"> 有什么事 </h2><br><p>  Proguard是用于优化和混淆Java代码的开源实用程序。 该工具处理已编译的Java代码，因此它可以与任何JVM语言一起使用。 更准确地说，Proguard的语言本身是无关紧要的，仅字节码很重要。 所有proguard字节码操作都可以分为3个主要类别： <strong>代码收缩</strong> ， <strong>优化</strong>和<strong>混淆</strong> 。 </p><br><h3 id="code-shrinking"> 代码缩小 </h3><br><p> 是的，编写代码然后删除它是一件很奇怪的事情，但这是Android开发的现实。 当然，这与手工编写的代码无关（尽管这种情况确实发生了），而是与各种图书馆带来的无数载货有关。  <strong>Guava</strong> ， <strong>Apache Commons</strong> ， <strong>Google Play Services</strong>和其他公司可以将apk文件的大小从500kb扩大到几十兆字节。 有时，由于超出<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dalvik方法的限制</a> ，程序无法编译。  Proguard将帮助删除所有未使用的代码，并将应用程序的大小减小到几兆字节。 </p><br><h3 id="optimisation"> 最佳化 </h3><br><p> 除了删除不必要的代码外，Proguard还可以优化剩余的代码。 它的工具库包括控制流分析，数据流分析，部分评估，静态单项分配，全局值编号，活动性分析。  Proguard可以执行窥孔优化，减少变量分配的数量，简化尾部递归等等（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wiki</a> ）。 除了此类常规操作之外，Proguard还具有专门用于Android平台的优化，例如，用int替换枚举类，删除日志记录指令。 </p><br><h3 id="obfuscation"> 混淆 </h3><br><p> 最后，Proguard可以通过将所有类，方法和字段重命名为随机（实际上不是很随机）字母集，从而将所有代码变成难以理解的混乱。 这是一个非常有用的选项，因为任何人都可以反编译您的apk文件，并且并非每个人都有耐心来理解混淆的代码。 </p><br><h2 id="princip-raboty"> 工作原理 </h2><br><p>  Proguard按上述顺序分3个步骤工作： <strong>代码收缩</strong> → <strong>优化</strong> → <strong>混淆</strong> 。 每个步骤都是可选的。 </p><br><p>  <em>对于Android SDK，优化步骤默认为关闭。</em> </p><br><p> 为了使Proguard正常工作，您需要提供3个组件： </p><br><ul><li>编译后的代码是一个归档文件，其中包含程序的<code>class</code>文件以及您使用的所有库（jar，aar，apk，war，zip等）。  Proguard仅修改已经编译的代码，与源代码无关。 </li><li> 配置文件-包含要开始处理的所有规则，选项和设置的文件。 </li><li>  Library jars（aar，apks，...）-运行程序的平台的类。 如果是Android，则为<code>android.jar</code> 。 这些归档文件仅用于正确分析您的代码，它们不会被修改（这没有意义，因为<code>android.jar</code>位于“电话中”，我们无法访问它）。 </li></ul><br><p><img src="https://habrastorage.org/webt/sf/vb/b8/sfvbb8uuvqdacgnjvzmeka3zpa4.png" alt="Jeb Ware演示文稿中的图片，文章末尾的链接"><br>  （图片来自Jeb Ware的演讲，文章末尾的链接） </p><br><p> 通过使用库类和配置文件，Proguard定义了程序（ <strong>种子</strong> ）的所有入口点。 换句话说，它定义了可以从外部调用并且无法触摸的类和方法。 然后，从发现的<strong>种子开始</strong> ，Proguard递归遍历您的所有代码，标记“使用”了它可能到达的所有内容。 所有其他代码将被删除。 您必须在配置中至少指定一个入口点。 对于标准的Java程序，这是<code>main</code>功能。 在Android中，程序中没有单个入口；相反，我们具有由系统创建和调用的标准组件（活动，服务等）。 幸运的是，我们不需要自己在此处指定任何内容，Android SDK会为我们创建必要的配置。 </p><br><h3 id="soputstvuyuschie-fayly"> 伴随文件 </h3><br><p> 检测到所有入口点后，Proguard会将它们写入<code>seeds.txt</code>文件。 </p><br><p>  Proguard认为不需要的所有代码都写入了<code>usage.txt</code>文件。 对于包含远程代码的文件来说，这是一个相当奇怪的名称，将其命名为unusage.txt会更正确，但是请记住，我们已经拥有了。 </p><br><p> 在混淆步骤中，将创建一个包含对&lt;原始类名|方法|字段&gt;-&gt; &lt;混淆类名|方法|字段&gt;对的<code>mapping.txt</code>文件。 当您需要对程序进行模糊处理时（例如，读取stacktrace），此文件很有用。 不需要手动将文件映射回； Android SDK具有<code>retrace</code>和<code>proguardui</code>实用程序来提供帮助。 而且，如果您使用Fabric Crashlytics，那么他们的gradle插件可以独立地找到该文件并将其加载到控制台中，因此您无需担心。 </p><br><p> 对于Android，这些文件通常位于<code>app/build/output/mapping/&lt;product-flavor-name&gt;/</code> 。 </p><br><p>  Proguard还会创建一个<code>dump.txt</code>文件，其中包含Proguard放入最终归档文件中的所有内容。 他从来没有为我派上用场，但也许对某人有用。 </p><br><h3 id="kak-dela-obstoyat-v-android">  Android上的情况如何 </h3><br><p>  Android Gradle插件可以自行运行Proguard。 您要做的就是启用此选项并指定配置文件。 </p><br><pre> <code class="hljs cs">buildTypes { &lt;...&gt; release { minifyEnabled <span class="hljs-literal"><span class="hljs-literal">true</span></span> proguardFiles <span class="hljs-string"><span class="hljs-string">'proguard-rules.pro'</span></span>, getDefaultProguardFile(<span class="hljs-string"><span class="hljs-string">'proguard-android.txt'</span></span>) } }</code> </pre> <br><p>  <code>minifyEnabled true</code>在构建时启用Proguard </p><br><p>  <code>proguardFiles</code>配置文件列表。 来自所有配置文件的规则将按照它们出现的顺序添加到常规列表中。 </p><br><p>  <code>proguard-rules.pro</code>是带有项目特定规则的配置文件 </p><br><p>  <code>getDefaultProguardFile('proguard-android.txt')</code> -返回针对Android应用程序的标准配置文件的函数。 它位于<code>AndroidSDK/tools/proguard</code> </p><br><p> 实际上，Android SDK有两个<code>proguard-android.txt</code> ： <code>proguard-android.txt</code>和<code>proguard-android-optimize.txt</code> 。 第一个具有<code>-dontoptimize</code>选项，该选项关闭所有优化。 如果要启用优化，请使用第二个配置。 </p><br><p> 除了这些标准配置之外，Android SDK（aapt）会自动生成一组资源规则：aapt检查所有xml文件（包括清单）以查找所有活动，服务，视图等。 并为他们生成必要的规则。 生成的规则可以在<code>app/build/intermediates/proguard-rules/&lt;flavor&gt;/aapt_rules.txt</code> 。 您无需自行指定，Android Gradle插件会自动添加这些规则。 </p><br><p><img src="https://habrastorage.org/webt/1r/w4/t6/1rw4t6egtvymigl79hnxc3n8t9a.png" alt="Jeb Ware演示文稿中的图片，文章末尾的链接"><br>  （图片来自Jeb Ware的演讲，文章末尾的链接） </p><br><h2 id="konfigi"> 设定档 </h2><br><p> 设置Proguard是使用它的最基本的部分，同时也是最困难的部分。 错误的配置很容易在运行时中断应用程序和应用程序本身的编译。 所有可用的配置选项均已详细记录为开。 网站。 </p><br><p> 在所有选项中，我将选出三个最重要的组： </p><br><ul><li> 保留规则-程序的所有可能的入口点。 告诉Proguard哪些类别或类别的一部分保持不变或哪些修改对特定类别有效的规则。 </li><li> 优化调整-指明可接受哪些优化，需要完成多少个优化周期。 </li><li> 处理警告，错误和调试 </li></ul><br><h3 id="keep-rules"> 遵守规则 </h3><br><p> 这是一组旨在保护您的代码免受无情的Proguard攻击的选项。 在最一般的形式下，此规则如下所示： </p><br><pre> <code class="hljs powershell"><span class="hljs-literal"><span class="hljs-literal">-keep</span></span> [,<span class="hljs-type"><span class="hljs-type">modifier</span></span>,<span class="hljs-type"><span class="hljs-type">...</span></span>] class_specification</code> </pre> <br><p>  <code>keep</code>是这些选项中最常见的选项（还有其他选项），它告诉Proguard保存类本身及其所有类成员：字段和方法。 </p><br><p>  <code>class_specification</code>指向类或其部分（类成员）的模板。 模板的一般视图非常大，可以将其<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关闭。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文件</a> 。 您可以与他联系，但总的来说，您只需要记住我们就有机会编写以下组件的模板： </p><br><ul><li> 选择所有具有特定名称的类，包 </li><li> 选择所有继承/实现某些类/接口的类 </li><li> 选择所有带有特定修饰符和/或特定注释的类 </li><li> 选择所有具有特定名称，修饰符，参数和返回值的方法 </li><li> 选择具有特定名称，修饰符和特定类型的所有字段。 </li><li><p> 可以使用通配符 </p><br><p> 再一次，这不是对模板的严格描述；它只是我们所拥有功能的列表。 以下是一些示例： </p><br></li></ul><br><p> <code>-keep public class com.example.MyActivity</code> <br> 保存类<code>com.example.MyActivity</code> </p><br><p> <code>-keep public class * extends android.app.Activity</code> <br> 保存所有继承自<code>android.app.Activity</code>公共类 </p><br><pre> <code class="hljs scala">-keep public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">*</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">android</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">view</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ public &lt;init&gt;(android.content.<span class="hljs-type"><span class="hljs-type">Context</span></span>); public &lt;init&gt;(android.content.<span class="hljs-type"><span class="hljs-type">Context</span></span>, android.util.<span class="hljs-type"><span class="hljs-type">AttributeSet</span></span>); public &lt;init&gt;(android.content.<span class="hljs-type"><span class="hljs-type">Context</span></span>, android.util.<span class="hljs-type"><span class="hljs-type">AttributeSet</span></span>, int); public void set*(...); }</code> </pre> <br><p> 找到所有继承<code>android.view.View</code>公共类，并在其中保存3个带有某些参数的构造函数+所有公共方法， <code>void</code>修饰符，任何参数和以<code>set</code>开头的名称。 该类的所有其他部分都可以修改。 </p><br><p> <code>-keep class com.habr.** { *; }</code> <br> 将所有类及其所有内容保存在<code>com.habr</code>包中 </p><br><p>  <code>modifiers</code> -保留规则的补充： </p><br><ul><li>  <code>includedescriptorclasses</code>除了指定的类/方法/字段外，您还需要保存在其描述符中出现的所有类。 </li><li>  <code>includecode</code>此特定规则所指向的方法的内容也不能被触及。 </li><li>  <code>allowshrinking</code>此规则指向的类不是种子，可以删除，但只有在程序本身未使用它们时才可以删除。 但是，如果在代码收缩后仍保留该代码（由于有人使用它），则不可能优化/混淆该代码。 </li><li>  <code>allowoptimization</code>此规则引用的类只能进行优化，而不能删除或混淆。 </li><li>  <code>allowobfuscation</code>此规则指向的类只能被混淆，而不能删除或优化。 </li></ul><br><p> 除了<code>keep</code> ，还有其他一些选择： </p><br><p>  <code>-keepclassmembers</code>指示如果代码收缩后保留了类本身，则应该保存类成员。 </p><br><p>  <code>-keepclasseswithmembers</code>表示您要保存其内容属于指定模板的类。 例如， <code>-keepclasseswithmembers class * { public &lt;init&gt;(android.content.Context); }</code>  <code>-keepclasseswithmembers class * { public &lt;init&gt;(android.content.Context); }</code> -保存所有具有一个公共构造函数且其参数类型为<code>Context</code>的类。 </p><br><p>  <code>-keepnames</code> -- <code>-keepnames</code>缩写<code>-keep,allowshrinking</code> 。 </p><br><p>  <code>-keepclassmembernames</code> -- <code>-keepclassmembernames</code>简写， <code>-keepclassmembers,allowshrinking</code> 。 </p><br><p>  <code>keepclasseswithmembernames</code> -- <code>-keepclasseswithmembers,allowshrinking</code> 。 </p><br><h3 id="optimisation-tuning"> 优化调整 </h3><br><p> 这里最重要的选项是<code>-dontoptimize</code>标志。 如果存在，将不执行优化，所有其他优化选项都将被忽略。 </p><br><p> 有许多优化选项，但是以下对我来说最有用： </p><br><p>  <code>-optimizations optimization_filter</code>列出您要使用的所有方式。 最好使用在<code>proguard-android-optimize.txt</code>指定的集合或其子集。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到所有优化的列表。 </p><br><p>  <code>-optimizationpasses n</code>优化周期数。 几个循环可以改善结果。 同时，如果Proguard认为结果与上次相比没有改善，则足以停止周期。 </p><br><p>  <code>-assumenosideeffects class_specification</code>指示此方法没有副作用，仅返回一些值。 如果Proguard检测到未使用返回的结果，则将删除对该方法的调用。 此选项最常见的用法是删除所有调试日志： <code>-assumenosideeffects class android.util.Log { public static int d(...); }</code> <code>-assumenosideeffects class android.util.Log { public static int d(...); }</code> </p><br><p>  <code>-allowaccessmodification</code>显示所有隐藏的内容:)一个不错的选择，它使您摆脱了一堆嵌套类的人工访问器方法。 仅与<code>-repackageclasses</code>一起使用 </p><br><p>  <code>-repackageclasses</code>将所有类移动到一个指定的软件包。 这更适用于混淆，但同时在优化方面提供了良好的结果。 </p><br><h3 id="prochie-poleznye-opcii"> 其他有用的选择 </h3><br><p>  <code>-dontwarn</code>和<code>-dontnote</code> </p><br><p>  Proguard非常聪明，在代码分析过程中总是报告可疑的地方，有时是注释，有时是警告。 如果在打开Proguard的情况下构建失败，请确保阅读生成的所有日志，它将记录出错误的地方，并且很可能甚至会告诉您如何修复它。 阅读所有消息后，如果确定没有问题，则可以解决问题或忽略这些选项之一的消息。 </p><br><p> 例如，碰巧某些Java库使用的平台类不在android.jar中，Proguard会对此发出警告。 如果您确定该库在Android环境中可以正常运行，则可以关闭此警告<code>-dontwarn java.lang.management.**</code> </p><br><p>  <code>-whyareyoukeeping class_specification</code>是一个有用的选项，它将显示Proguard决定不触摸此类/方法的原因。 </p><br><p>  <code>-verbose</code>打印更详细的日志和异常 </p><br><p>  <code>-printconfiguration</code>从使用的所有配置文件中打印选项的完整列表，包括库中的规则以及通过aapt生成的规则。 </p><br><p>  <code>-keepattributes SourceFile, LineNumberTable</code>保存元信息（文件名，行号），以便能够在IDE中调试代码并获得有意义的堆栈跟踪。 确保添加此选项。 </p><br><h3 id="praktika"> 练习 </h3><br><p> 通常会发生这种情况：打开Proguard，它会使您整个项目陷入瘫痪，并带来大量错误。 许多人在此步骤中关闭了Proguard，并尝试不返回它。 我将尝试提供一些技巧，以使过渡过程更容易。 </p><br><h4 id="opredelitsya-s-nachalnymi-vhodnymi-tochkami"> 确定起点 </h4><br><p> 如果您是Android开发人员，那么一切都非常基础-只需从Android SDK中选择以下两个标准配置之一： <code>proguard-android.txt</code>或<code>proguard-android-optimize.txt</code> ，它们将处理所有应保持不变的内容。 </p><br><h4 id="proverit-vse-biblioteki"> 检查所有库 </h4><br><p> 近来，越来越多的带有现成的proguard-config的库被分发。  Proguard可以查看存档文件，找到库配置并将其添加到其他选项。 检查用于此配置的每个库。 </p><br><p><img src="https://habrastorage.org/webt/rf/dq/vn/rfdqvnztj-zagmqtzwctc73x3-k.png" alt="（其中一个库的aar文件的内容）"><br>  （其中一个库的aar文件的内容） </p><br><p> 如果您使用Google Play服务，则<code>com.google.gms.google-services</code>插件将自行选择所需的配置。 </p><br><p> 如果该库的作者未将配置打包到档案中，则可能是他们注意了并将规则写在其网站，存储库页面或README文件中。 尝试自己找到所用库版本的配置。 </p><br><p> 如果在任何地方都找不到任何现成的规则，则必须阅读日志并单独解决问题。 最有可能的是，您将需要为已损坏的库代码添加保留规则。 如果不干扰程序，则忽略它们。 </p><br><h4 id="provesti-inspekciyu-svoego-koda"> 检查您的代码 </h4><br><p> 您会更好地知道可以在刀下发送什么代码，但是您应该仔细查看所有使用反射的地方： </p><br><ul><li>  Class.forName（...）（文档承诺Proguard能够定义此类代码，但是，在某些情况下，值得检查） </li><li> 序列化，映射中使用的模型/实体类。 所有其字段名称（有时是类本身）都很重要的类（Gson，RealmIO等） </li><li> 通过JNI进行本地库调用 </li></ul><br><h4 id="testy"> 测验 </h4><br><p> 如果仅在测试中使用类/方法，而在其他地方均未使用，则Proguard会删除此代码。 如果您有TDD，这是一种常见情况：)对于这种情况，我有一个单独的配置，其中添加了尚未集成到项目中，不在任何地方使用但需要进行测试的类。 </p><br><p> 在Android Gradle插件中，除了<code>proguardFiles</code>指令之外，仍然还有<code>testProguardFiles</code> 。 需要此说明来指定将应用于生成的测试应用程序的配置，以便在运行测试时测试您的应用程序。 通常，这用于在两个apk文件中实现相同的优化/混淆，因此它们之间不会出现同步。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">友情链接</a> </p><br><h4 id="apk-analyzer">  APK分析器 </h4><br><p>  Android Studio具有如此出色的工具。 您可以通过“查找操作”-&gt;“分析APK”或通过在Android Studio中打开apk文件本身来打开它。 分析器显示了很多有用的信息，但是现在我们对代码感兴趣。 要查看最终打包到APK文件中的文件，您需要选择<code>classes.dex</code>文件 </p><br><p><img src="https://habrastorage.org/webt/go/zz/o_/gozzo_o83s3e1mknkxhqldrzr3g.png"></p><br><p> 默认情况下，将精确显示经过缩小和优化步骤的结果代码。 但是，您可以单击“ <strong>Load Proguard映射...”</strong>按钮，添加<code>seeds.txt</code>和<code>usage.txt</code>以查看已删除的代码。 </p><br><p><img src="https://habrastorage.org/webt/gy/4a/gk/gy4agkxifirpyy95-exhk1xmguc.png"></p><br><p> 如果Proguard出于某种原因修改了所需的代码，请在Analyzer中找到它，然后选择<strong>“</strong>通过RMB <strong>生成Proguard保留规则”</strong> 。 分析器将为规则生成几个选项供您选择，从最通用到最具体，选择其中一个。 </p><br><p><img src="https://habrastorage.org/webt/ny/zc/ob/nyzcobecp45cnrrjgq3unu3_zba.png"></p><br><p><img src="https://habrastorage.org/webt/yq/wg/0m/yqwg0mwllbw9wauhemkvffgk_h8.png"></p><br><h4 id="dlya-avtorov-bibliotek"> 对于图书馆作者 </h4><br><p> 如果要创建Android库，则可以为客户端添加proguard配置，如下所示： </p><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">buildTypes</span></span> { <span class="hljs-section"><span class="hljs-section">release</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">consumerProguardFiles</span></span> <span class="hljs-string"><span class="hljs-string">'proguard-rules.pro'</span></span> } }</code> </pre> <br><p> 我认为，最好不要热心优化和混淆您的图书馆，而要为您的客户提供这个机会。 一个不错的基调是将配置添加到客户（如果客户包括Proguard）仍要添加的内容。 但是，如果您仍想增加安全性，那么很明显，您需要保护库的整个公共API不受Proguard的保护，包括描述符和签名。 </p><br><h3 id="r8-dexguard-i-redex">  R8，DexGuard和Redex </h3><br><p>  R8是Google用来替代当前Proguard的新工具。 请稍等，不要忘记忘记您​​在本文中阅读的所有内容，就像对待新的Proguard一样。  Google承诺保留整个公共api，以便所有配置都能像以前一样工作。 该项目仍处于测试阶段，但您可以自己尝试。 </p><br><p>  DexGuard是Proguard开发人员的付费实用程序。 它可以一起使用，也可以代替Proguard使用。 有人认为DexGuard可以做Proguard可以做的所有事情，但效果更好。 不幸的是，我没有机会尝试，如果有人有经验，请分享。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Redex</a>是Facebook的另一个dex优化器。 据报道，通过将工具应用于Proguard已经处理的代码，您可以将生产率提高25％，并减小应用程序的大小。 </p><br><h2 id="vmesto-zaklyucheniya"> 而不是结论 </h2><br><p> 不要害怕使用Proguard，不要懒惰并花一些时间进行设置。 与增加用户忠诚度相比，这将减小其尺寸，提高工作速度。 同时，尝试创建有效的Proguard配置，不要编写“地毯”规则，否则生气的Jake Wharton会来找您并责骂您。 </p><br><p><img src="https://habrastorage.org/webt/ma/tf/kz/matfkzxceoougdvn7pfyx4klnho.png"></p><br><h2 id="resursy"> 资源资源 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Proguard网站</a> 。 也有关于DexGuard的信息。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">各种示例规则</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">R8</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">录制Proguard如何与DroidCon一起使用的演示文稿</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有效的ProGuard保留了较小的应用程序（Google I / O '18）演示记录的规则</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">启用和配置Android Proguard的说明</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">维基页面</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Redex</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN415499/">https://habr.com/ru/post/zh-CN415499/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN415487/index.html">英特尔历史页面。 第一芯片Intel 3101</a></li>
<li><a href="../zh-CN415489/index.html">Facebook通过太阳能无人机关闭互联网分配项目</a></li>
<li><a href="../zh-CN415493/index.html">德雷克公式的新计算表明：人类在其星系中处于孤独状态，概率为53–99.6％</a></li>
<li><a href="../zh-CN415495/index.html">CRM系统：商业80级工具</a></li>
<li><a href="../zh-CN415497/index.html">收集器马达+ Digispark = $ 50电动自行车</a></li>
<li><a href="../zh-CN415501/index.html">冬宫的虚拟大厅-迈向未来的第一步</a></li>
<li><a href="../zh-CN415503/index.html">NetScaler SD-WAN用户界面</a></li>
<li><a href="../zh-CN415509/index.html">编程中的深度学习：什么，为什么以及如何</a></li>
<li><a href="../zh-CN415527/index.html">DUMP 2018会议：所有报告和演示的视频</a></li>
<li><a href="../zh-CN415529/index.html">7月IT活动摘要</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>