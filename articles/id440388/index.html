<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤¾ğŸ¼ ğŸ„ ğŸ¤’ Interval: Evolusi C ++ yang Mendatang ğŸ ğŸ‘¨ğŸ»â€ğŸ³ ğŸ¤¦ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Standar C ++ 20 akan segera muncul, yang kemungkinan akan menambah konsep rentang , tetapi sedikit orang yang tahu apa yang mereka dan apa yang mereka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interval: Evolusi C ++ yang Mendatang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440388/">  Standar C ++ 20 akan segera muncul, yang kemungkinan akan menambah konsep <i>rentang</i> , tetapi sedikit orang yang tahu apa yang mereka dan apa yang mereka makan.  Saya tidak dapat menemukan sumber berbahasa Rusia yang dapat diakses tentang binatang buas ini, oleh karena itu dalam artikel ini saya ingin memberi tahu Anda lebih banyak tentangnya, berdasarkan ceramah oleh Arno SchÃ¶dl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Dari Iterators ke Ranges: Evolusi STL yang Akan Datang"</a> dari Konferensi Rapat C ++ 2015- tahun ini.  Saya akan mencoba membuat artikel ini sejelas mungkin bagi mereka yang pertama kali menemukan konsep ini, dan pada saat yang sama saya akan berbicara tentang semua jenis chip seperti adapter interval untuk mereka yang sudah akrab dengan konsep ini dan ingin tahu lebih banyak. <br><br><h2>  Perpustakaan dengan rentang </h2><br>  Pada saat penulisan ini, ada tiga perpustakaan utama yang mengimplementasikan interval: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tingkatkan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rentang v3</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan umum think-cell</a> </li></ul><br>  Perpustakaan pertama, pada kenyataannya, adalah nenek moyang dari konsep ini (yang tidak mengejutkan, karena tidak ada dalam koleksi perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Boost</a> :)).  Yang kedua adalah perpustakaan Eric Niebler, yang akan dijelaskan nanti.  Dan akhirnya, perpustakaan terakhir, seperti yang Anda duga, ditulis oleh think-cell, yang, bisa dikatakan, dikembangkan dan ditingkatkan Boost.Range. <br><a name="habracut"></a><br><h2>  Mengapa interval adalah masa depan kita? </h2><br>  Bagi mereka yang tidak terbiasa dengan konsep interval, kami mendefinisikan konsep non-sepele ini sebagai sesuatu yang memiliki awal dan akhir ( <u>sepasang iterator</u> ). <br><br>  Sekarang mari kita pertimbangkan tugas berikut: ada vektor, perlu untuk menghapus semua elemen berulang dari itu.  Di bawah standar saat ini, kami akan menyelesaikannya seperti ini: <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; vec=...; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort( vec.begin(), vec.end() ); vec.erase( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique( vec.begin(), vec.end() ), vec.end() );</code> </pre> <br>  Dalam hal ini, kami menunjukkan nama vektor sebanyak <b>6</b> kali!  Namun, dengan menggunakan konsep interval (menggabungkan iterator di awal dan akhir vektor ke dalam satu objek), kita dapat menulis berkali-kali lebih mudah dengan menetapkan vektor yang diinginkan hanya <b>sekali</b> : <br><br><pre> <code class="cpp hljs">tc::unique_inplace( tc::sort(vec) );</code> </pre> <br><h2>  Manakah dari interval saat ini dalam standar saat ini? </h2><br>  Dalam standar C ++ 11, rentang berbasis untuk loop dan akses universal ke awal / akhir wadah ditambahkan, dan dalam standar C ++ 17 terakhir, tidak ada yang baru terkait dengan interval yang ditambahkan. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; i : &lt;range_expression&gt; ) { ... }</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin/end(&lt;range_expression&gt;)</code> </pre> <br><h2>  Interval masa depan </h2><br>  Sekarang mari kita memikirkan perpustakaan Range V3 yang disebutkan sebelumnya.  Eric Nibler, penciptanya, ketika proyek rumahnya menciptakan <i>Spesifikasi Teknis Range</i> , memodifikasi perpustakaan <i>algoritma</i> untuk mendukung interval.  Itu terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> ranges { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> What &gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) find( Rng &amp;&amp; rng, What <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; what ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find( ranges::begin(rng), ranges::end(rng), what ); } }</code> </pre> <br>  Di situsnya ada beberapa pratinjau dari apa yang ingin dia standarisasi, ini adalah <i>Range V3</i> . <br><br><h2>  Rentang apa yang bisa dipertimbangkan? </h2><br>  Pertama-tama, <i>wadah</i> (vektor, string, daftar dll), karena mereka memiliki awal dan akhir.  Jelas bahwa wadah memiliki elemennya sendiri, yaitu, ketika kita merujuk ke wadah, maka kita merujuk ke semua elemennya.  Demikian pula ketika menyalin dan mendeklarasikan konstan (penyalinan dalam dan konsistensi).  Kedua, <i>tampilan</i> juga dapat dianggap sebagai interval.  Tampilan hanyalah sepasang iterator yang menunjuk ke awal dan akhir.  Berikut ini adalah implementasi mereka yang paling sederhana: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> It&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_range</span></span></span><span class="hljs-class"> {</span></span> It m_itBegin; It m_itEnd; <span class="hljs-function"><span class="hljs-function">It </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_itBegin; } <span class="hljs-function"><span class="hljs-function">It </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_itEnd; } };</code> </pre> <br>  Tampilan, pada gilirannya, hanya merujuk ke elemen, sehingga penyalinan dan konsistensi malas (ini tidak mempengaruhi elemen). <br><br><h2>  Adapter Interval </h2><br>  Para penemu interval tidak berhenti pada ini, karena kalau tidak konsep ini akan menjadi agak tidak berguna.  Oleh karena itu, mereka memperkenalkan konsep seperti itu sebagai range adapter. <br><br><h3>  Ubah adaptor </h3><br>  Pertimbangkan tugas berikut: biarkan vektor <i>int</i> diberikan, di mana kita perlu menemukan elemen pertama sama dengan 4: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find(v, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br>  Sekarang mari kita bayangkan bahwa jenis vektornya bukan int, tetapi semacam struktur tulisan-sendiri yang kompleks, tetapi di dalamnya ada int, dan tugasnya masih sama: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> data; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;A&gt; v={...}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find_if( v, [](A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.id == <span class="hljs-number"><span class="hljs-number">4</span></span>; } );</code> </pre> <br>  Jelas bahwa kedua kode ini mirip dalam semantik, namun, mereka berbeda secara signifikan dalam sintaks, karena dalam kasus terakhir, kami harus secara manual menulis fungsi yang berjalan melalui bidang <i>int</i> .  Tetapi jika Anda menggunakan transform adapter ( <i>transform adapter</i> ), maka semuanya terlihat jauh lebih ringkas: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> data; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;A&gt; v={...}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find( tc::transform(v, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mem_fn(&amp;A::id)), <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br>  Faktanya, adaptor yang mentransformasikan â€œmengubahâ€ struktur kita dengan membuat kelas pembungkus di sekitar bidang int.  Jelas bahwa pointer menunjuk ke bidang <i>id</i> , tetapi jika kita ingin menunjuk ke seluruh struktur, kita perlu menambahkan di akhir <i>.base ()</i> .  Perintah ini merangkum bidang, karena penunjuk dapat berjalan melalui seluruh struktur: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find( tc::transform(v, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mem_fn(&amp;A::id)), <span class="hljs-number"><span class="hljs-number">4</span></span>).base();</code> </pre><br>  Berikut ini adalah contoh implementasi transform adaptor (terdiri dari iterator, yang masing-masing memiliki functor sendiri): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">transform_range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Func m_func; <span class="hljs-comment"><span class="hljs-comment">//    decltype( tc::begin(std::declval&lt;Base&amp;&gt;()) ) m_it; public: decltype(auto) operator*() const { return m_func(*m_it); } decltype(auto) base() const { return (m_it); } ... }; };</span></span></code> </pre><br><h3>  Adaptor filter </h3><br>  Dan jika dalam tugas terakhir kita tidak perlu menemukan elemen pertama, tetapi "menyaring" <b>seluruh</b> bidang <i>int</i> untuk keberadaan elemen tersebut?  Dalam hal ini, kami akan menggunakan adaptor filter: <br><br><pre> <code class="cpp hljs">tc::filter( v, [](A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> == a.id; } );</code> </pre><br>  Perhatikan bahwa filter dijalankan dengan malas selama iterasi. <br><br>  Dan inilah implementasi naifnya (sesuatu seperti ini diterapkan di Boost.Range): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filter_range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Func m_func; <span class="hljs-comment"><span class="hljs-comment">//     decltype( ranges::begin(std::declval&lt;Base&amp;&gt;()) ) m_it; decltype( ranges::begin(std::declval&lt;Base&amp;&gt;()) ) m_itEnd; public: iterator&amp; operator++() { ++m_it; while( m_it != m_itEnd &amp;&amp; !static_cast&lt;bool&gt;(m_func(*m_it)) ) ++m_it; return *this; } ... }; };</span></span></code> </pre><br>  Seperti yang bisa kita lihat, dua iterator diperlukan di sini, bukan satu, seperti yang ada di adaptor transform.  Iterator kedua diperlukan agar tidak sengaja melampaui batas wadah selama iterasi. <br><br><h2>  Beberapa optimasi </h2><br>  Oke, tapi seperti apa iteratornya dari <b>tc :: filter (tc :: filter (tc :: filter (...)))</b> ? <br><br><h3>  Tingkatkan </h3><br>  Sebagai bagian dari implementasi di atas, terlihat seperti ini: <br><br><div class="spoiler">  <b class="spoiler_title">Pingsan hati jangan melihat!</b> <div class="spoiler_text"> <code>m_func3 <br> m_it3 <br> m_func2 <br> m_it2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd3 <br> m_func2 <br> m_it2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br></code> <br></div></div><br>  Jelas, ini <u>sangat</u> tidak efisien. <br><br><h3>  Rentang v3 </h3><br>  Mari kita pikirkan cara mengoptimalkan adaptor ini.  Ide Eric Nibler adalah untuk meletakkan informasi umum (sebuah fungsi dan pointer ke ujung) di objek adaptor, dan kemudian kita dapat menyimpan tautan ke objek adaptor ini dan iterator yang diinginkan <br> <code>*m_rng <br> m_it <br></code> <br>  Kemudian, dalam kerangka implementasi seperti itu, filter tiga akan terlihat seperti ini: <br><br><div class="spoiler">  <b class="spoiler_title">Tyk</b> <div class="spoiler_text"> <code>m_rng3 <br> m_it3 <br> m_rng2 <br> m_it2 <br> m_rng1 <br> m_it1 <br></code> <br></div></div><br>  Ini masih belum sempurna, walaupun kadang-kadang lebih cepat dari implementasi sebelumnya. <br><br><h3>  think-cell, konsep indeks </h3><br>  Sekarang pertimbangkan solusi sel berpikir.  Mereka memperkenalkan <i>konsep indeks yang</i> disebut untuk memecahkan masalah ini.  Indeks adalah iterator yang melakukan semua operasi yang sama dengan iterator biasa, tetapi melakukan ini dengan mengacu pada interval. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">index_range</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Index = ...; <span class="hljs-function"><span class="hljs-function">Index </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Index </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decrement_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">reference </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dereference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; ... };</code> </pre><br>  Kami menunjukkan cara menggabungkan indeks dengan iterator biasa. <br><br>  Jelas bahwa iterator reguler juga dapat dianggap sebagai indeks.  Di arah yang berlawanan, kompatibilitas dapat diterapkan, misalnya, sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_for_index</span></span></span><span class="hljs-class"> {</span></span> IndexRng* m_rng; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng::Index m_idx; iterator&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++() { m_rng.increment_index(m_idx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } ... };</code> </pre><br>  Kemudian filter tiga kali lipat akan diterapkan secara sangat efisien: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filter_range</span></span></span><span class="hljs-class"> {</span></span> Func m_func; Base&amp; m_base; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Index = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base::Index; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { m_base.increment_index(idx); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( idx != m_base.end_index() &amp;&amp; !m_func(m_base.dereference_index(idx)) ); } };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_for_index</span></span></span><span class="hljs-class"> {</span></span> IndexRng* m_rng; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng::Index m_idx; ... };</code> </pre><br>  Dalam kerangka implementasi seperti itu, algoritme akan bekerja dengan cepat terlepas dari kedalaman filter. <br><br><h2>  Interval dengan wadah nilai dan nilai </h2><br>  Sekarang mari kita lihat bagaimana interval bekerja dengan wadah nilai dan nilai: <br><br><h3>  lvalue </h3><br>  Rentang V3 dan think-cell berperilaku sama dengan lvalue.  Misalkan kita memiliki kode seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = view::filter(vec, pred1); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = ranges::any_of(rng, pred2);</code> </pre><br>  Di sini kita memiliki vektor yang dinyatakan sebelumnya yang terletak di memori (lvalue), dan kita perlu membuat interval dan kemudian bekerja dengannya.  Kami membuat tampilan menggunakan <i>view :: filter</i> atau <i>tc :: filter</i> dan menjadi senang, tidak ada kesalahan, dan kami kemudian dapat menggunakan tampilan ini, misalnya, di any_of. <br><br><h3>  Rentang V3 dan rvalue </h3><br>  Namun, jika vektor kami belum ada di memori (misalnya, jika kami baru saja membuatnya), dan kami akan menghadapi tugas yang sama, maka kami akan mencoba menulis dan kami menemukan kesalahan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = view::filter(create_vector(), pred1); <span class="hljs-comment"><span class="hljs-comment">//   bool b = ranges::any_of(rng, pred2);</span></span></code> </pre><br>  Mengapa itu muncul?  Lihat akan menjadi tautan menggantung ke nilai karena fakta bahwa kita membuat vektor dan langsung meletakkannya di filter, yaitu, akan ada tautan nilai di filter, yang kemudian akan menunjuk ke sesuatu yang tidak diketahui ketika kompiler pergi ke baris berikutnya dan kesalahan terjadi.  Untuk mengatasi masalah ini, Range V3 datang dengan <i>aksi</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = action::filter(create_vector(), pred1); <span class="hljs-comment"><span class="hljs-comment">//   bool b = ranges::any_of(rng, pred2);</span></span></code> </pre> <br>  Tindakan melakukan semuanya sekaligus, yaitu hanya membutuhkan vektor, menyaring berdasarkan predikat, dan menempatkannya dalam interval.  Namun, minusnya adalah bahwa ia tidak lagi malas, dan sel berpikir mencoba untuk memperbaiki minus ini. <br><br><h3>  sel berpikir dan menilai </h3><br>  Think-cell membuatnya sehingga alih-alih melihat wadah dibuat: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = tc::filter(creates_vector(), pred1); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = ranges::any_of(rng, pred2);</code> </pre><br>  Akibatnya, kami tidak menemukan kesalahan yang sama, karena dalam implementasinya, filter mengumpulkan wadah nilai alih-alih tautan, jadi ini terjadi dengan malas.  Dalam Range V3 mereka tidak ingin melakukan ini, karena mereka takut akan ada kesalahan karena filter berperilaku baik sebagai tampilan atau sebagai wadah, namun sel berpikir yakin bahwa programmer memahami bagaimana filter berperilaku, dan sebagian besar kesalahan muncul justru karena "kemalasan" ini. <br><br><h2>  Interval Generator </h2><br>  Kami menggeneralisasi konsep interval.  Bahkan, ada interval tanpa iterator.  Mereka disebut <i>rentang generator</i> .  Misalkan kita memiliki widget GUI (elemen antarmuka) dan kami menyebutnya widget bergerak.  Kami memiliki jendela yang meminta untuk memindahkan widgetnya, kami juga memiliki tombol di <i>kotak daftar</i> , dan jendela lain juga harus menggulir widgetnya, yaitu, kami memanggil <i>traverse_widgets</i> , yang menghubungkan elemen ke functor ( <i>Anda dapat mengatakan ada fungsi enumerasi di mana Anda sambungkan functor, dan fungsinya daftar semua elemen yang ada di functor ini</i> ). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse_widgets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Func func )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window1) { window1-&gt;traverse_widgets(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(func)); } func(button1); func(listbox1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window2) { window2-&gt;traverse_widgets(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(func)); } }</code> </pre><br>  Ini agak mengingatkan pada jarak widget, tetapi tidak ada iterator di sini.  Menulisnya secara langsung akan menjadi tidak efisien dan, di atas segalanya, sangat sulit.  Dalam hal ini, kita dapat mengatakan bahwa struktur seperti itu juga dianggap sebagai interval.  Kemudian untuk kasus seperti itu ada penggunaan metode interval yang berguna, seperti <i>any_of</i> : <br><br><pre> <code class="cpp hljs">mouse_hit_any_widget=tc::any_of( [] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> func) { traverse_widgets(func); }, [] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; widget) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.mouse_hit(); } );</code> </pre><br>  think-cell mencoba mengimplementasikan metode sehingga mereka memiliki antarmuka yang sama untuk semua jenis interval: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tc { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Rng </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; rng )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bResult = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; tc::enumerate( rng, [&amp;](bool_context b) { bResult = bResult || b; } ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bResult; } }</code> </pre><br>  Menggunakan <i>tc :: enumerate</i> , perbedaan antara interval disembunyikan, karena implementasi seperti itu menganut konsep <i>iterasi internal</i> (apa konsep <i>iterasi</i> <i>eksternal</i> dan <i>internal</i> dijelaskan secara lebih rinci dalam kuliah), namun, implementasi ini memiliki kelemahan, yaitu, <i>std :: any_of</i> berhenti segera setelah <i>true</i> ditemukan.  Mereka mencoba menyelesaikan masalah ini, misalnya, dengan menambahkan pengecualian ( <i>interval generator yang</i> disebut <i>terputus</i> ). <br><br><h2>  Kesimpulan </h2><br>  Saya benci rentang berbasis untuk loop karena memotivasi orang untuk menulisnya di mana saja diperlukan dan di mana tidak diperlukan, karena keringkasan kode yang sering memburuk, misalnya, orang menulis ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n : rng) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( is_prime(n) ) { b = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  sebagai gantinya: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = tc::any_of( rng, is_prime );</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440388/">https://habr.com/ru/post/id440388/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440374/index.html">Fungsi Yandex mengirim email</a></li>
<li><a href="../id440376/index.html">20 game untuk mengajarkan pemrograman anak Anda</a></li>
<li><a href="../id440378/index.html">Kembali ke layanan microser dengan Istio. Bagian 2</a></li>
<li><a href="../id440382/index.html">Apakah 200 baik atau buruk?</a></li>
<li><a href="../id440386/index.html">Membebaskan penanganan kesalahan dengan menghilangkan kesalahan</a></li>
<li><a href="../id440390/index.html">Dunia beragam sistem embedded dan tempat Embox di dalamnya</a></li>
<li><a href="../id440392/index.html">WebRTC di situs Anda - tanpa bug dan tanpa anggaran</a></li>
<li><a href="../id440394/index.html">Eskalasi hak istimewa PostgreSQL - parsing CVE-2018-10915</a></li>
<li><a href="../id440398/index.html">Sejarah partisipasi (dan kemenangan) di Piala AI Rusia 2018 - CodeBall</a></li>
<li><a href="../id440400/index.html">Apache Kafka + Spring Boot: Halo, layanan microser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>