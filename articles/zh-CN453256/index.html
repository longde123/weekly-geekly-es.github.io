<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>◼️ 🤵🏽 👩🏿‍💼 SObjectizer-5.6.0：现场直播以进一步发展 🏥 🗝️ 🌋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="第三天，提供了新版本的SObjectizer：5.6.0 。 它的主要特征是拒绝与以前的稳定分支5.5兼容，该分支在过去四年半的时间里稳步发展。 


 SObjectizer-5的基本操作原理保持不变。 通信，代理，合作和调度员仍在我们身边。 但是有些事情发生了严重变化，有些事情通常被扔掉了。 因...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SObjectizer-5.6.0：现场直播以进一步发展</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453256/"><p><img src="https://habrastorage.org/webt/vp/ah/jx/vpahjx-dkpsauwtfzyeiktnsfp4.jpeg"></p><br><p> 第三天，提供了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">新版本的SObjectizer：5.6.0</a> 。 它的主要特征是拒绝与以前的稳定分支5.5兼容，该分支在过去四年半的时间里稳步发展。 </p><br><p>  SObjectizer-5的基本操作原理保持不变。 通信，代理，合作和调度员仍在我们身边。 但是有些事情发生了严重变化，有些事情通常被扔掉了。 因此，仅采用SO-5.6.0并重新编译代码将失败。 需要重写某些内容。 某些内容可能必须重新设计。 </p><br><p> 我们为什么要照顾兼容性好几年，然后才决定收拾一切并破坏一切？ 什么最彻底地破坏了？ </p><br><p> 我将在本文中尝试讨论这一点。 </p><br><h1 id="zachem-voobsche-potrebovalos-chto-to-lomat"> 你为什么要破坏一些东西？ </h1><br><p> 就这么简单。 </p><a name="habracut"></a><br><p>  SObjectizer-5.5在其开发过程中吸收了许多原本未计划的不同事物，因此，它在内部形成了太多的拐杖和道具。 对于每个新版本，向SO-5.5添加新的东西变得越来越难。 最后，问题是“为什么我们需要所有这些？” 找不到合适的答案。 </p><br><p> 因此，第一个原因是SObjectizer内脏的重新复杂化。 </p><br><p> 第二个原因是我们愚蠢地专注于旧的C ++编译器。  5.5分支始于2014年，当时，如果没有记错的话，我们拥有gcc-4.8和MSVS2013。 在这个级别上，我们仍然继续保持对C ++标准支持级别的要求。 </p><br><p> 最初，我们对此有“自私的兴趣”。 另外，一段时间以来，我们将对C ++标准支持质量的低要求视为我们的“竞争优势”。 </p><br><p> 但是随着时间的流逝，“自私的利益”结束了。 这种“竞争优势”带来的一些好处是不可见的。 也许他们会的，如果我们完全使用C ++ 98，那么我们会对血腥的企业感兴趣。 但是，原则上，像我们这样的血腥企业并不感兴趣。 因此，决定停止自我限制，取一些新鲜事物。 因此，我们选择了目前最稳定的版本：C ++ 17。 </p><br><p> 显然，并不是所有人都喜欢这种解决方案，毕竟，对于许多C ++ 17而言，这已经是无法实现的领先优势，而且仍然非常非常遥远。 </p><br><p> 尽管如此，我们还是决定了这种风险。 同样，普及SObjectizer的过程并没有很快，因此，当SObjectizer的需求或多或少变得越来越广泛时，C ++ 17将不再是“前沿”。 相反，它将像现在在C ++ 11中一样被对待。 </p><br><p> 通常，我们决定不再使用C ++ 11的子集继续构建拐杖，而是决定使用C ++ 17认真地重新构建SObjectizer的内部结构。 为SObjectizer在未来四五年内可以逐步发展奠定基础。 </p><br><h1 id="chto-serezno-pomenyalos-v-sobjectizer-56"> 在SObjectizer-5.6中发生了什么严重变化？ </h1><br><p> 现在，让我们简要介绍一些最引人注目的变化。 </p><br><h2 id="u-kooperaciy-agentov-bolshe-net-strokovyh-imen"> 代理合作不再具有字符串名称 </h2><br><h3 id="problema"> 问题 </h3><br><p> 从一开始，SObjectizer-5要求每个合作都有其自己的唯一字符串名称。 此功能是从先前的第四个SObjectizer的第五个SObjectizer继承而来的。 </p><br><p> 因此，SObjectizer需要存储已注册合作的名称。 在注册时检查其唯一性。 在注销等期间按名称搜索合作等。 </p><br><p> 从第一个版本开始，在SObjectzer-5中使用了一种简单的方案：受互斥量保护的注册合作的单个字典。 注册合作伙伴时，将捕获互斥体，合作伙伴名称的唯一性，父代的存在等。 检查后，修改字典，然后释放互斥锁。 这意味着，如果同时一次开始注册/注销多个合作，则在某些时候它们将暂停并等待，直到其中一项操作完成了合作词典的工作。 因此，合作业务无法很好地扩展。 </p><br><p> 这就是我要摆脱的问题，以便以合作注册的速度改善情况。 </p><br><h3 id="reshenie"> 解决方案 </h3><br><p> 考虑了解决该问题的两种主要方法。 </p><br><p> 首先，存储字符串名称，但是更改字典的存储方式，以便可以扩展合作注册操作。 例如，字典分片，即 将其分为几部分，每部分都将受到其互斥量的保护。 </p><br><p> 其次，完全拒绝字符串名称，并使用SObjectizer分配的某些标识符。 </p><br><p>结果，我们选择了第二种方法，完全放弃了合作社的命名。 现在在SObjectizer中有诸如coop_handle之类的东西，即 向用户隐藏其内容的句柄，但可以将其与<code>std::weak_ptr</code>进行比较。 </p><br><p> 注册协作时，SObjectizer返回<code>coop_handle</code> ： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> coop = env.make_coop(); ... <span class="hljs-comment"><span class="hljs-comment">//    . auto coop_id = env.register_coop(std::move(coop)); // . //   coop_id    .</span></span></code> </pre> <br><p> 此句柄应用于注销合作： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> coop = env.make_coop(); ... <span class="hljs-comment"><span class="hljs-comment">//    . auto coop_id = env.register_coop(std::move(coop)); // . //   coop_id    . ... // - . // ,     . //       . env.deregister_coop(coop_id, ...);</span></span></code> </pre> <br><p> 同样，在建立父子关系时应使用此句柄： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   . auto parent = env.make_coop(); ... //  parent . auto parent_id = env.register_coop(std::move(parent)); //  . ... //      ,    . auto child = env.make_coop(parent_id); ...</span></span></code> </pre> <br><p>  SObjectizer Environment中用于合作的存储库的结构也发生了巨大变化。 如果在包含5.5版之前的版本中，它是一本通用词典，那么现在每个合作社都是一个指向儿童合作社链接的存储库。 即 合作社形成一棵树，该树的根在对用户隐藏的特殊根合作社中。 </p><br><p> 这种结构使得更好地缩放<code>register_coop</code>和<code>deregister_coop</code>成为可能：并行操作的相互阻塞只有在它们都属于同一个父母合作的情况下才会发生。 为了清楚起见，这是启动一个<a href="" rel="nofollow">特殊的基准测试</a>的结果，该<a href="" rel="nofollow">基准</a>通过我在旧笔记本电脑上与Ubuntu 16.04和GCC-7.3的配合来测量操作的性能： </p><br><pre> <code class="plaintext hljs">_test.bench.so_5.parallel_parent_child -r 4 -l 7 -s 5 Configuration: roots: 4, levels: 7, level-size: 5 parallel_parent_child: 15.69s 488280 488280 488280 488280 Total: 1953120</code> </pre> <br><p> 即  5.6.0版在大约15.5秒内处理了将近200万次合作。 </p><br><p> 这是5.5.24.4版本，是当前分支5.5的最后一个版本： </p><br><pre> <code class="plaintext hljs">_test.bench.so_5.parallel_parent_child -r 4 -l 7 -s 5 Configuration: roots: 4, levels: 7, level-size: 5 parallel_parent_child: 46.856s 488280 488280 488280 488280 Total: 1953120</code> </pre> <br><p> 相同的情况，但结果差了三倍。 </p><br><h2 id="ostalsya-vsego-odin-vid-dispetcherov"> 只剩下一种调度员 </h2><br><p> 调度程序是SObjectizer的基石之一。 调度员确定代理将在何处以及如何处理其消息。 因此，如果没有调度程序的想法，可能就不会有SObjectizer。 </p><br><p> 但是，调度员本身已经发展，演变和预先发展，以至于我们为SObjectizer-5.5创建新的调度员甚至都不困难。 但是很麻烦。 但是，让我们按顺序进行。 </p><br><p> 最初，只能在SObjectizer的开头创建应用程序所需的所有调度程序： </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { <span class="hljs-comment"><span class="hljs-comment">/* -   */</span></span> }, <span class="hljs-comment"><span class="hljs-comment">//    SObjectizer-. []( so_5::environment_params_t &amp; params ) { p.add_named_dispatcher("active_obj", so_5::disp::active_obj::create_disp()); p.add_named_dispatcher("shutdowner", so_5::disp::active_obj::create_disp()); p.add_named_dispatcher("groups", so_5::disp::active_group::create_disp()); ... } );</span></span></code> </pre> <br><p> 我没有在开始之前创建必要的调度程序-一切都是我的错，您无法进行任何更改。 </p><br><p> 很明显，这很不方便，并且随着SObjectizer的使用场景的扩展，有必要解决此问题。 因此， <code>add_dispatcher_if_not_exists</code>了<code>add_dispatcher_if_not_exists</code>方法，该方法检查是否存在调度程序，如果没有调度程序，则允许创建一个新实例： </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . env.add_dispatcher_if_not_exists( "extra_dispatcher", []{ return so_5::disp::active_obj::create_disp(); } ); }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><p> 这样的调度员被称为公众。 公共调度员具有唯一的名称。 并使用这些名称，将代理商绑定到调度员： </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . env.add_dispatcher_if_not_exists( "extra_dispatcher", []{ return so_5::disp::active_obj::create_disp(); } ); //         //    . auto coop = env.create_coop( "ping_pong", //     extra_dispatcher. so_5::disp::active_obj::create_disp_binder( "extra_dispatcher" ) ); coop-&gt;make_agent&lt; a_pinger_t &gt;(...); coop-&gt;make_agent&lt; a_ponger_t &gt;(...); ... }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><p> 但是公共调度员具有一个不愉快的特征。 在将它们添加到SObjectizer Environment之后，他们立即开始工作，并继续工作直到SObjectizer Environment完成其工作。 </p><br><p> 再一次，随着时间的流逝，它开始干扰。 有必要确保可以根据需要添加调度程序，并自动删除不需要的调度程序。 </p><br><p> 因此有“私人”调度员。 这些调度员没有名字，只要有提及他们就活着。 启动SObjectizer Environment之后，可以随时创建私有调度程序，它们会被自动销毁。 </p><br><p> 总的来说，私人调度员是调度员发展过程中非常成功的纽带，但与公共调度员的合作与之不同： </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . auto disp = so_5::disp::active_obj::create_private_disp(env); //         //    . auto coop = env.create_coop( "ping_pong", //      . disp-&gt;binder() ); coop-&gt;make_agent&lt; a_pinger_t &gt;(...); coop-&gt;make_agent&lt; a_ponger_t &gt;(...); ... }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><p> 甚至更多的私人和公共调度员在实现上有所不同。 因此，为了不复制代码并分别编写相同类型的公共和私人调度程序，我不得不使用带有模板和继承的相当复杂的构造。 </p><br><p> 结果，我厌倦了所有这些变化，在SObjectizer-5.6中只剩下一种调度程序。 实际上，这类似于私人调度员。 但只是没有明确提及“私人”一词。 因此，现在上面显示的片段将写为： </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . auto disp = so_5::disp::active_obj::make_dispatcher(env); //         //    . auto coop = env.create_coop( "ping_pong", //      . disp.binder() ); coop-&gt;make_agent&lt; a_pinger_t &gt;(...); coop-&gt;make_agent&lt; a_ponger_t &gt;(...); ... }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><h2 id="ostalis-tolko-svobodnye-funkcii-send-send_delayed-i-send_periodic"> 只有自由功能send，send_delayed和send_periodic </h2><br><p> 用于向SObjectizer发送消息的API的开发可能是最令人震惊的示例，说明了随着我们可以使用的编译器对C ++ 11的支持得到改善，SObjectizer发生了变化。 </p><br><p> 首先，消息是这样发送的： </p><br><pre> <code class="cpp hljs">mbox-&gt;deliver_message(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> my_message(...));</code> </pre> <br><p> 或者，如果您遵循“最佳犬种推荐”（c）： </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;my_message&gt; msg(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> my_message(...)); mbox-&gt;deliver_message(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(msg));</code> </pre> <br><p> 但是，随后我们可以使用支持可变参数模板和发送功能的编译器。 可以这样写： </p><br><pre> <code class="cpp hljs">send&lt;my_message&gt;(target, ...);</code> </pre> <br><p> 的确，整个家庭从一个简单的<code>send</code> （包括<code>send_to_agent</code> ， <code>send_delayed_to_agent</code>等）中<code>send_to_agent</code>起来需要花费更多时间。 然后，使这个族缩小到熟悉的<code>send</code> ， <code>send_delayed</code>和<code>send_periodic</code> 。 </p><br><p> 但是，尽管事实上发送函数家族已经形成很久了，并且已经成为推荐的发送消息方法<code>deliver_message</code>多年了，但是用户仍然可以使用诸如<code>deliver_message</code> ， <code>schedule_timer</code>和<code>single_timer</code>类的旧方法。 </p><br><p> 但是在版本5.6.0中，只有免费的<code>send</code> ， <code>send_delayed</code>和<code>send_periodic</code>函数保存在公共SObjectizer API中。 其他所有内容全部删除或转移到内部SObjectizer命名空间。 </p><br><p> 因此，在SObjectizer-5.6中，如果我们从一开始就拥有支持常规C ++ 11的编译器，则发送消息的接口最终将变成原来的接口。 好吧，除此之外，如果我们有使用这种非常普通的C ++ 11的经验。 </p><br><h2 id="edinyy-format-send_delayed-i-send_periodic"> 单一格式send_delayed和send_periodic </h2><br><p> 在以前版本的SObjectizer中使用<code>send_delayed</code>和<code>send_periodic</code> ，又发生了另一件事。 </p><br><p> 要使用计时器，您必须有权访问SObjectizer Environment。 代理内部有一个指向SObjectizer Environment的链接。 在mchain内部有这样的链接。 但是在mbox内部，她不在那儿。 因此，如果将待处理消息发送到代理或mchain，则<code>send_delayed</code>调用如下所示： </p><br><pre> <code class="cpp hljs">send_delayed&lt;my_message&gt;(target_agent, pause, ...); send_delayed&lt;my_message&gt;(target_mchain, pause, ...);</code> </pre> <br><p> 对于mbox，我们必须从其他地方获取指向SObjectizer Environment的链接： </p><br><pre> <code class="cpp hljs">send_delayed&lt;my_message&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;so_environment(), target_mbox, pause, ...);</code> </pre> <br><p>  <code>send_delayed</code>和<code>send_periodic</code>此功能是次要的分裂。 没有那么多的干扰，但是很烦人。 所有这些都是因为最初我们并未开始将指向SObjectizer Environment的链接存储在mbox-ahs中。 </p><br><p> 违反与先前版本的兼容性是摆脱这种分裂的一个很好的理由。 </p><br><p> 现在，您可以从mbox中找到为其创建的SObjectizer Environment。 这样就可以对任何类型的计时器消息接收者使用单个<code>send_delayed</code>和<code>send_periodic</code> ： </p><br><pre> <code class="cpp hljs">send_delayed&lt;my_message&gt;(target_agent, pause, ...); send_delayed&lt;my_message&gt;(target_mchain, pause, ...); send_delayed&lt;my_message&gt;(target_mbox, pause, ...);</code> </pre> <br><p> 从字面上看，“有点琐事，但很好。” </p><br><h2 id="net-bolshe-ad-hoc-agentov"> 不再有临时代理 </h2><br><p> 俗话说：“每一次事故都有名字，中间名和姓氏。” 对于临时代理，这是我的名字，中间名和姓氏:( </p><br><p> 关键是这个。 当我们开始在公共场合谈论SObjectizer-5时，我们听到了很多关于SObjectizer示例代码的冗长性的指责。 从个人角度来看，这种冗长的词在我看来是一个严重的问题，我需要认真对待。 </p><br><p> 详细程度的一种来源是需要代理从特殊的基本类型<code>agent_t</code>继承。 从这看来，没有逃脱的可能。 还是不行 </p><br><p> 因此，有一些临时代理商，即 代理，对于确定不必编写单独的类的决定，仅以lambda函数形式设置对消息的响应就足够了。 例如，关于临时代理的经典乒乓示例可以这样编写： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pinger = coop-&gt;define_agent(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ponger = coop-&gt;define_agent(); pinger .on_start( [ponger]{ so_5::send&lt; msg_ping &gt;( ponger ); } ) .event&lt; msg_pong &gt;( pinger, [ponger]{ so_5::send&lt; msg_ping &gt;( ponger ); } ); ponger .event&lt; msg_ping &gt;( ponger, [pinger]{ so_5::send&lt; msg_pong &gt;( pinger ); } );</code> </pre> <br><p> 即 没有自己的课程。 我们只在合作上调用<code>define_agent()</code>并获得某种代理对象，您可以订阅传入的消息。 </p><br><p> 因此，在SObjectizer-5中，常规代理和临时代理是分离的。 </p><br><p> 它没有带来任何明显的奖金，只是伴随这种离职的额外劳动力成本。 随着时间的流逝，很明显，特工就像没有把手的手提箱：难以携带，可惜离开。 但是在使用SObjectizer-5.6时，决定退出。 </p><br><p> 同时，还吸取了另一个教训，也许更重要了：在互联网上对该工具进行的任何公开讨论中，都会有很多人对这种工具的种类，为何需要它，为什么要使用该工具不感兴趣。 表达他们的强烈意见对他们来说很重要。 除此之外，在Internet的俄语部分中，将工具的愚蠢和未受教育的程度以及不需要多少工作成果传达给工具的开发人员仍然非常重要。 </p><br><p> 因此，您在输入内容时应该非常小心。 而且您只能（然后仔细地）听一听，这就是我所说的：“我试图那样在您的乐器上这样做，我不喜欢它在这里得到多少代码。” 即使是这样的愿望也应该非常谨慎地对待：“如果在这里和这里会更容易，我会帮助您发展。” </p><br><p> 不幸的是，大约五年前，“好心人”在互联网上所说的“过滤”技能远不如现在。 因此，像SObjectizer中的临时代理这样的特定实验。 </p><br><h2 id="sobjectizer-56-bolshe-ne-podderzhivaet-sinhronnogo-vzaimodeystviya-agentov">  SObjectizer-5.6不再支持同步的代理交互 </h2><br><p> 代理之间的同步交互主题非常古老且痛苦。 </p><br><p> 它始于SObjectizer-4时代。 并在SObjectizer-5中继续。 到目前为止，终于，所谓的  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">服务要求</a> 。 坦白说，最初它令人恐惧。 但是后来我设法<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">给了他们一个或多或少的体面的表情</a> 。 </p><br><p> 但是事实证明，这是第一个薄煎饼出来时块状的情况：( </p><br><p> 在SObjectizer内部，我必须以一种方式实现常规消息的传递和处理，并以另一种方式实现同​​步请求的传递和处理。 尤其令人遗憾的是，必须考虑这些功能，包括在实现自己的mbox-s时。 </p><br><p> 并且，在将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信封消息</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">功能</a>添加到SObjectizer之后，变得需要更频繁，更仔细地查看常规消息和同步请求之间的区别。 </p><br><p> 通常，在SObjectizer维护/开发过程中出现同步请求时，实在太麻烦了。 如此之多，以至于起初有一种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">具体的愿望，希望摆脱这些非常同步的请求</a> 。 然后，这种愿望得以实现。 </p><br><p> 因此，在SObjectizer-5.6中，代理只能通过异步消息再次进行交互。 </p><br><p> 而且由于有时仍需要诸如同步交互之类的东西，因此已向<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">随附的so5extra项目提交了</a>对这种类型的交互的支持： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    "-". using my_request_reply = so_5::extra::sync::request_reply_t&lt;my_request, my_reply&gt;; ... //  ,    . class request_handler final : public so_5::agent_t { ... //  .      . void on_request(typename my_request_reply::request_mhood_t cmd) { ... //  . //      cmd-&gt;request(). //   . cmd-&gt;make_reply(...); //      my_reply. } ... void so_define_agent() override { //       . so_subscribe_self().event(&amp;request_handler::on_request); } }; ... //     . so_5::mbox_t handler_mbox = ...; //        15s. //    ,    . my_reply reply = my_request_reply::ask_value(handler_mbox, 15s, ...); //       my_request.</span></span></code> </pre> <br><p> 即 现在处理同步请求根本不同，因为请求处理程序不会像以前那样从处理程序方法中返回值。 而是使用<code>make_reply</code>方法。 </p><br><p> 新的实现是好的，因为请求和响应都像常规异步消息一样在SObjectizer内部发送。 实际上， <code>make_reply</code>是<code>send</code>更具体的实现。 </p><br><p> 而且，重要的是，新的实现使我们能够获得以前无法实现的功能： </p><br><ul><li> 同步请求（即<code>request_reply_t&lt;Request, Reply&gt;</code>对象）现在可以保存和/或转发到其他处理程序。 什么使得可以实现各种负载平衡方案； </li><li> 您可以在发起请求的代理的常规mbox中做出对请求的响应。 发起方将以通常的方式处理响应，就像其他任何消息一样； </li><li> 您可以一次将多个请求发送给不同的收件人，然后按接收顺序解析来自他们的响应： </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> first_dialog = so_5::extra::sync::<span class="hljs-keyword"><span class="hljs-keyword">request_reply_t</span></span>&lt;first_request, first_reply&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> second_dialog = so_5::extra::sync::<span class="hljs-keyword"><span class="hljs-keyword">request_reply_t</span></span>&lt;second_request, second_reply&gt;; <span class="hljs-comment"><span class="hljs-comment">//         . auto reply_ch = create_mchain(env); //     . first_dialog::initiate_with_custom_reply_to( one_service, reply_ch, so_5::extra::sync::do_not_close_reply_chain, ...); second_dialog::initiate_with_custom_reply_to( another_service, reply_ch, so_5::extra::sync::do_not_close_reply_chain, ...); //    . receive(from(reply_ch).handle_n(2).empty_timeout(15s), [](typename first_dialog::reply_mhood_t cmd) {...}, [](typename second_dialog::reply_mhood_t cmd) {...});</span></span></code> </pre> <br><p> 因此，可以说，在SObjectizer中进行同步交互时，发生了以下情况： </p><br><ul><li> 很长一段时间他出于意识形态原因而离开了； </li><li> 然后添加了它，结果发现有时这种交互很有用； </li><li> 但是经验表明，第一个实现不是很成功。 </li><li> 原来的实现完全被丢弃了，因此提出了新的实现。 </li></ul><br><p> 通常，他们确实是为自己的错误而工作。 </p><br><h1 id="zaklyuchenie"> 结论 </h1><br><p> 本文相当简短地讨论了SObjectizer-5.6.0中的一些更改以及这些更改背后的原因。 </p><br><p> 在<a href="" rel="nofollow">此处</a>可以找到更完整的更改列表。 </p><br><p> 总之，我想提供尚未尝试过SObjectizer的人，请尝试一下。 并与我们分享您的感受：您喜欢什么，您不喜欢什么，缺少什么。 </p><br><p> 我们会认真听取所有建设性的意见/建议。 而且，近年来，SObjectizer仅包含某人的需求。 因此，如果您不告诉我们您希望在SObjectizer中拥有什么，那么它将不会出现。 如果你告诉我，那么谁知道...;） </p><br><p> 该项目现在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">在这里</a>生活和发展。 对于那些只使用GitHub的人，这里有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">GitHub镜像</a> 。 这面镜子是全新的，因此您可以忽略缺少星星的情况。 </p><br><p>  PS。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">在此Google组中</a>关注SObjectizer相关新闻。 在那里您可以提出与SObjectizer相关的问题。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN453256/">https://habr.com/ru/post/zh-CN453256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN453242/index.html">夏季活动的游乐场</a></li>
<li><a href="../zh-CN453246/index.html">ERP-连续降级系统</a></li>
<li><a href="../zh-CN453248/index.html">阿耳emi弥斯（Artemis）月球任务-开始生产“月球通道”月球轨道站的主要元素</a></li>
<li><a href="../zh-CN453252/index.html">我们如何进行Sportmaster俱乐部计划</a></li>
<li><a href="../zh-CN453254/index.html">关于GOST的代码，Grasshopper，其SBox和丢失的种子</a></li>
<li><a href="../zh-CN453258/index.html">使用PT2399芯片制作混响踏板（第1部分）</a></li>
<li><a href="../zh-CN453260/index.html">DPI设置功能</a></li>
<li><a href="../zh-CN453262/index.html">您的常量存储在CortexM微控制器上的什么位置（以C ++ IAR编译器为例）</a></li>
<li><a href="../zh-CN453264/index.html">Virtuali-tee：不会覆盖但会暴露在外的“医用T恤”</a></li>
<li><a href="../zh-CN453272/index.html">GitHub赞助商：一种为开源做出贡献的新方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>