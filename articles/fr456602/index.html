<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëåüèΩ üòµ üìù Guide de mise en ≈ìuvre des abonnements auto-renouvelables dans les applications iOS ü¶Ç üë©üèæ‚Äçüç≥ üìó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! Je m'appelle Denis, je d√©veloppe Apphud , un service d'analyse des abonnements auto-renouvelables dans les applications iOS. 


 Dans ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guide de mise en ≈ìuvre des abonnements auto-renouvelables dans les applications iOS</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/apphud/blog/456602/"><p><img src="https://habrastorage.org/webt/qy/ut/ez/qyutezbsfdccsr1yrml6revzsbm.png" alt="image"></p><br><p>  Bonjour √† tous!  Je m'appelle Denis, je d√©veloppe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apphud</a> , un service d'analyse des abonnements auto-renouvelables dans les applications iOS. </p><br><p>  Dans cet article, je vais vous expliquer comment configurer, impl√©menter et valider des abonnements auto-renouvelables dans iOS 12 et iOS 13. En bonus, je vais vous parler de points subtils et d'emb√ªches que tous les d√©veloppeurs ne prennent pas en compte. <a name="habracut"></a></p><br><h2 id="nastroyka-podpisok-v-app-store-connect">  Configurer des abonnements sur l'App Store Connect </h2><br><p>  Si vous avez d√©j√† un ID de bundle et une application cr√©√©e, vous pouvez ignorer ces √©tapes.  Si vous cr√©ez une application pour la premi√®re fois, proc√©dez comme suit: </p><br><p>  Vous devez cr√©er <em>un ID de bundle explicite (ID d'application)</em> sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le portail des d√©veloppeurs Apple</a> .  Une page intitul√©e <em>Certificats, identifiants et profils √©tant</em> ouverte, acc√©dez √† l'onglet <em>Identifiants</em> .  En juin 2019, Apple a finalement mis √† jour la disposition du portail conform√©ment √† ASC (abr√©viation de App Store Connect). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fad/ba4/609/fadba4609e2e25bf48f1f9149cf81332.png" alt="Nouveau design pour Apple Developer Portal en 2019"><br>  <em>Nouveau design pour Apple Developer Portal en 2019</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/cbb/84c/1ea/cbb84c1eac492c0c10e18aa373272c49.png"></p><br><p> L'ID de <code>com.apphud.subscriptionstest</code> explicite est g√©n√©ralement sp√©cifi√© dans le style de domaine ( <code>com.apphud.subscriptionstest</code> ).  Dans la section <em>Capacit√©s</em> , vous remarquerez que la coche <em>en regard des achats int√©gr√©s est</em> d√©j√† coch√©e.  Apr√®s avoir cr√©√© le <em>Bundle ID</em> ( <em>App ID</em> ), acc√©dez √† l'App Store Connect. </p><br><h3 id="testovye-polzovateli-sandbox-users">  Utilisateurs de test (utilisateurs Sandbox) </h3><br><p>  Pour tester les futurs achats, vous devrez cr√©er un utilisateur test.  Pour ce faire, acc√©dez √† ASC dans l'onglet <em>Utilisateurs et acc√®s</em> , puis √† <em>Sandbox Testers.</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6b9/15b/25d/6b915b25d4b0ee1374756d84c04d64a4.png" alt="Formulaire de cr√©ation de sandbox utilisateur"><br>  <em>Formulaire de cr√©ation de sandbox utilisateur</em> </p><br><blockquote>  Lors de la cr√©ation d'un testeur, vous pouvez sp√©cifier toutes les donn√©es inexistantes, surtout, n'oubliez pas l'e-mail et le mot de passe! </blockquote><p>  Je vais vous expliquer comment tester les achats avec des informations d'identification de test vers la fin de l'article. </p><br><p>  Une autre √©tape importante est la mise en place de contrats et de donn√©es bancaires dans la section ¬´ <em>Accords, taxes et op√©rations bancaires</em> ¬ª.  Si vous n'avez pas d'accord pour les applications payantes, vous ne pourrez pas tester les abonnements auto-renouvelables! </p><br><p>  Apr√®s cela, vous pouvez cr√©er une nouvelle application dans l'App Store Connect.  Sp√©cifiez un nom unique et s√©lectionnez votre <em>ID de bundle</em> comme <em>ID</em> de package. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2b9/15d/251/2b915d25116265c73951ebe326ca672f.png" alt="L'ID de package est votre ID de bundle"><br>  <em>L'ID de package est votre ID de bundle</em> </p><br><p>  Imm√©diatement apr√®s la cr√©ation de l'application, acc√©dez √† l'onglet <em>Fonctionnalit√©s.</em> </p><br><blockquote>  Si vous avez d√©j√† cr√©√© l'application, vous pouvez continuer √† lire √† partir d'ici. </blockquote><p>  Le processus de cr√©ation d'un abonnement auto-renouvelable comprend plusieurs √©tapes: </p><br><p>  <strong>1. Cr√©ez un identifiant d'abonnement et cr√©ez un <em>groupe d'abonnements</em> .</strong>  Un groupe d'abonnements est un ensemble d'abonnements avec des p√©riodes et des prix diff√©rents, mais qui ouvrent la m√™me fonctionnalit√© dans l'application.  De plus, dans le groupe d'abonnements, vous ne pouvez activer la p√©riode d'essai gratuite qu'une seule fois et un seul des abonnements peut √™tre actif.  Si vous souhaitez que votre application ait deux abonnements diff√©rents en m√™me temps, vous devrez cr√©er deux groupes d'abonnements. </p><br><p>  <strong>2. Remplir les donn√©es d'abonnement: dur√©e, nom d'affichage dans l'App Store (√† ne pas confondre avec le seul nom) et description.</strong>  Si vous ajoutez le premier abonnement au groupe, vous devrez indiquer le nom d'affichage du groupe d'abonnement.  N'oubliez pas d'enregistrer vos modifications plus souvent, ASC peut se bloquer √† tout moment et cesser de r√©pondre. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/62b/639/230/62b6392305ee8cd98000ba60aa408eb8.png" alt="Page d'abonnement"><br>  <em>√âcran d'abonnement</em> </p><br><p>  <strong>3. Remplir le prix de l'abonnement.</strong>  Il y a deux √©tapes: cr√©er des prix et des offres sp√©ciales.  Indiquez le prix r√©el dans n'importe quelle devise, il est automatiquement recalcul√© pour tous les autres pays.  Offres de lancement: vous pouvez ici offrir aux utilisateurs une p√©riode d'essai gratuite ou des remises pr√©pay√©es.  Des promotions sont apparues r√©cemment sur l'App Store en 2019: elles vous permettent d'offrir des remises sp√©ciales aux utilisateurs qui se sont d√©sabonn√©s et que vous souhaitez retourner. </p><br><h3 id="generaciya-sekretnogo-obschego-klyucha-shared-secret-key">  G√©n√©ration de cl√© secr√®te partag√©e </h3><br><p>  Sur la page avec une liste de tous vos abonnements cr√©√©s, vous verrez la <em>cl√© partag√©e pour le</em> bouton <em>de l'application</em> .  Il s'agit d'une ligne sp√©ciale qui est n√©cessaire pour valider une v√©rification dans une application iOS.  Nous devrons valider le ch√®que pour d√©terminer le statut de l'abonnement. </p><br><p>  La cl√© partag√©e peut √™tre de deux types: une cl√© unique pour votre application ou une seule cl√© pour votre compte.  Important: en aucun cas recr√©er la cl√© si vous avez d√©j√† l'application dans l'App Store, sinon les utilisateurs ne pourront pas valider le ch√®que et votre application cessera de fonctionner comme pr√©vu. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/644/ce1/5d1/644ce15d1961d54f5f6cc1cf15b7dda0.png" alt="Dans cet exemple, trois groupes d'abonnements et 3 abonnements annuels sont cr√©√©s."><br>  <em>Dans cet exemple, trois groupes d'abonnements et 3 abonnements annuels sont cr√©√©s.</em> </p><br><p>  Copiez l'ID de tous vos abonnements et la cl√© partag√©e, cela vous sera utile plus tard dans le code. </p><br><h2 id="programmnaya-chast">  Partie logiciel </h2><br><p>  Passons √† la partie pratique.  Que faut-il pour faire un directeur commercial complet?  Au minimum, les √©l√©ments suivants devraient √™tre mis en ≈ìuvre: </p><br><ol><li><p>  Commander </p><br></li><li><p>  V√©rifier l'√©tat de l'abonnement </p><br></li><li><p>  V√©rifier la mise √† jour </p><br></li><li><p>  R√©cup√©ration de transaction (√† ne pas confondre avec la mise √† jour d'un ch√®que!) </p><br></li></ol><br><h3 id="oformlenie-pokupok">  Commander </h3><br><p>  L'ensemble du processus d'achat peut √™tre divis√© en 2 √©tapes: r√©ception des produits (classe <code>SKProduct</code> ) et initialisation du processus d'achat (classe <code>SKPayment</code> ).  Tout d'abord, nous devons sp√©cifier le d√©l√©gu√© du protocole <code>SKPaymentTransactionObserver</code> . </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Starts products loading and sets transaction observer delegate @objc func startWith(arrayOfIds : Set&lt;String&gt;!, sharedSecret : String){ SKPaymentQueue.default().add(self) self.sharedSecret = sharedSecret self.productIds = arrayOfIds loadProducts() } private func loadProducts(){ let request = SKProductsRequest.init(productIdentifiers: productIds) request.delegate = self request.start() } public func productsRequest(_ request: SKProductsRequest, didReceive response: SKProductsResponse) { products = response.products DispatchQueue.main.async { NotificationCenter.default.post(name: IAP_PRODUCTS_DID_LOAD_NOTIFICATION, object: nil) } } func request(_ request: SKRequest, didFailWithError error: Error){ print("error: \(error.localizedDescription)") }</span></span></code> </pre> <br><p>  La notification <code>IAP_PRODUCTS_DID_LOAD_NOTIFICATION</code> utilis√©e pour mettre √† jour l'interface utilisateur dans une application. </p><br><p>  Ensuite, nous √©crivons une m√©thode pour initialiser l'achat: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">purchaseProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(product : SKProduct, success: @escaping SuccessBlock, failure: @escaping FailureBlock)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.canMakePayments() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().transactions.last?.transactionState != .purchasing <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.successBlock = success <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.failureBlock = failure <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> payment = <span class="hljs-type"><span class="hljs-type">SKPayment</span></span>(product: product) <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().add(payment) }</code> </pre> <br><p>  Le d√©l√©gu√© <code>SKPaymentTransactionObserver</code> ressemble √† ceci: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAPManager</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SKPaymentTransactionObserver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paymentQueue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> transaction <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> transactions { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (transaction.transactionState) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .purchased: <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().finishTransaction(transaction) notifyIsPurchased(transaction: transaction) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .failed: <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().finishTransaction(transaction) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"purchase error : \(transaction.error?.localizedDescription ?? "</span></span><span class="hljs-string"><span class="hljs-string">")"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.failureBlock?(transaction.error) cleanUp() <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .restored: <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().finishTransaction(transaction) notifyIsPurchased(transaction: transaction) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .deferred, .purchasing: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notifyIsPurchased</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(transaction: SKPaymentTransaction)</span></span></span></span> { refreshSubscriptionsStatus(callback: { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.successBlock?() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cleanUp() }) { (error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">// couldn't verify receipt self.failureBlock?(error) self.cleanUp() } } func cleanUp(){ self.successBlock = nil self.failureBlock = nil } }</span></span></code> </pre> <br><p>  En cas d'abonnement r√©ussi, la m√©thode d√©l√©gu√©e est appel√©e dans laquelle la transaction a le statut <code>purchased</code> . </p><br><p>  Mais comment d√©terminer la date d'expiration d'un abonnement?  Pour ce faire, faites une demande distincte √† Apple. </p><br><h3 id="proverka-statusa-podpiski">  V√©rifier l'√©tat de l'abonnement </h3><br><p>  Le ch√®que est valid√© √† l'aide de la demande <code>verifyReceipt</code> POST √† ‚Äã‚ÄãApple, nous envoyons le ch√®que crypt√© sous la forme d'une cha√Æne cod√©e en base64 comme param√®tre, et dans la r√©ponse, nous recevons le m√™me ch√®que au format JSON.  Dans le tableau, la cl√© <code>latest_receipt_info</code> r√©pertorie toutes les transactions de chaque p√©riode de chaque abonnement, y compris les p√©riodes d'essai.  Nous pouvons uniquement analyser la r√©ponse et obtenir la date d'expiration actuelle de chaque produit. </p><br><blockquote>  Lors de la WWDC 2017, ils ont ajout√© la possibilit√© de recevoir uniquement les ch√®ques en cours pour chaque abonnement √† l'aide de la cl√© <code>exclude-old-transactions</code> dans la demande <code>verifyReceipt</code> . </blockquote><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refreshSubscriptionsStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callback : @escaping SuccessBlock, failure : @escaping FailureBlock)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// save blocks for further use self.refreshSubscriptionSuccessBlock = callback self.refreshSubscriptionFailureBlock = failure guard let receiptUrl = Bundle.main.appStoreReceiptURL else { refreshReceipt() // do not call block yet return } #if DEBUG let urlString = "https://sandbox.itunes.apple.com/verifyReceipt" #else let urlString = "https://buy.itunes.apple.com/verifyReceipt" #endif let receiptData = try? Data(contentsOf: receiptUrl).base64EncodedString() let requestData = ["receipt-data" : receiptData ?? "", "password" : self.sharedSecret, "exclude-old-transactions" : true] as [String : Any] var request = URLRequest(url: URL(string: urlString)!) request.httpMethod = "POST" request.setValue("Application/json", forHTTPHeaderField: "Content-Type") let httpBody = try? JSONSerialization.data(withJSONObject: requestData, options: []) request.httpBody = httpBody URLSession.shared.dataTask(with: request) { (data, response, error) in DispatchQueue.main.async { if data != nil { if let json = try? JSONSerialization.jsonObject(with: data!, options: .allowFragments){ self.parseReceipt(json as! Dictionary&lt;String, Any&gt;) return } } else { print("error validating receipt: \(error?.localizedDescription ?? "")") } self.refreshSubscriptionFailureBlock?(error) self.cleanUpRefeshReceiptBlocks() } }.resume() }</span></span></code> </pre> <br><p>  Au d√©but de la m√©thode, vous pouvez voir qu'il existe un contr√¥le de l'existence d'une copie locale du contr√¥le.  Une v√©rification locale peut ne pas exister, par exemple, si l'application a √©t√© install√©e via iTunes.  S'il n'y a pas de v√©rification, nous ne pouvons pas ex√©cuter la demande <code>verifyReceipt</code> .  Nous devons d'abord obtenir le ch√®que local actuel, puis essayer de le valider √† nouveau.  La mise √† jour de la v√©rification s'effectue √† l'aide de la classe <code>SKReceiptRefreshRequest</code> : </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refreshReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">SKReceiptRefreshRequest</span></span>(receiptProperties: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) request.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> request.start() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestDidFinish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: SKRequest)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// call refresh subscriptions method again with same blocks if request is SKReceiptRefreshRequest { refreshSubscriptionsStatus(callback: self.successBlock ?? {}, failure: self.failureBlock ?? {_ in}) } } func request(_ request: SKRequest, didFailWithError error: Error){ if request is SKReceiptRefreshRequest { self.refreshSubscriptionFailureBlock?(error) self.cleanUpRefeshReceiptBlocks() } print("error: \(error.localizedDescription)") }</span></span></code> </pre> <br><p>  <strong>La mise √† jour de la v√©rification est</strong> impl√©ment√©e dans la fonction <code>refreshReceipt()</code> .  Si la v√©rification a √©t√© mise √† jour avec succ√®s, la m√©thode d√©l√©gu√©e <code>requestDidFinish(_ request : SKRequest)</code> est appel√©e, qui appelle √† <code>refreshSubscriptionsStatus</code> m√©thode <code>refreshSubscriptionsStatus</code> . </p><br><p>  Comment l'analyse des informations d'achat est-elle impl√©ment√©e?  Nous sommes retourn√©s un objet JSON dans lequel il y a un tableau imbriqu√© de transactions (par la derni√®re <code>latest_receipt_info</code> ).  Nous <code>expires_date</code> le tableau, obtenons la date d'expiration √† l'aide de la cl√© <code>expires_date</code> et l'enregistrons si cette date n'est pas encore arriv√©e. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> json : Dictionary&lt;String, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// It's the most simple way to get latest expiration date. Consider this code as for learning purposes. Do not use current code in production apps. guard let receipts_array = json["latest_receipt_info"] as? [Dictionary&lt;String, Any&gt;] else { self.refreshSubscriptionFailureBlock?(nil) self.cleanUpRefeshReceiptBlocks() return } for receipt in receipts_array { let productID = receipt["product_id"] as! String let formatter = DateFormatter() formatter.dateFormat = "yyyy-MM-dd HH:mm:ss VV" if let date = formatter.date(from: receipt["expires_date"] as! String) { if date &gt; Date() { // do not save expired date to user defaults to avoid overwriting with expired date UserDefaults.standard.set(date, forKey: productID) } } } self.refreshSubscriptionSuccessBlock?() self.cleanUpRefeshReceiptBlocks() }</span></span></code> </pre> <br><p>  J'ai donn√© un exemple simple de la fa√ßon d'extraire la date d'expiration actuelle d'un abonnement.  Il n'y a pas de gestion des erreurs et, par exemple, il n'y a pas de contr√¥le pour le retour d'un achat (la <em>date d'annulation est</em> ajout√©e). </p><br><p>  Pour d√©terminer si un abonnement est actif ou non, il suffit de comparer la date actuelle avec la date des <em>valeurs</em> par <em>d√©faut</em> de l' <em>utilisateur</em> par cl√© de produit.  S'il est absent ou inf√©rieur √† la date actuelle, l'abonnement est alors consid√©r√© comme inactif. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expirationDateFor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> identifier : String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Date?</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">UserDefaults</span></span>.standard.object(forKey: identifier) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">Date</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subscriptionDate = <span class="hljs-type"><span class="hljs-type">IAPManager</span></span>.shared.expirationDateFor(<span class="hljs-string"><span class="hljs-string">"YOUR_PRODUCT_ID"</span></span>) ?? <span class="hljs-type"><span class="hljs-type">Date</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isActive = subscriptionDate &gt; <span class="hljs-type"><span class="hljs-type">Date</span></span>()</code> </pre> <br><p>  La r√©cup√©ration de transaction est effectu√©e sur une seule ligne <code>SKPaymentQueue.default().restoreCompletedTransactions()</code> .  Cette fonction restaure toutes les transactions termin√©es, appelant √† nouveau la m√©thode d√©l√©gu√©e <code>func paymentQueue(**_** queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction])</code> . </p><br><h3 id="chem-otlichaetsya-obnovlenie-cheka-ot-vosstanovleniya-tranzakciy">  Quelle est la diff√©rence entre la mise √† jour d'un ch√®que √† partir de la r√©cup√©ration de transaction? </h3><br><p>  Les deux m√©thodes permettent de restaurer vos donn√©es d'achat.  Mais quelles sont leurs diff√©rences?  Il y a une merveilleuse table avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une vid√©o wwdc</a> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c21/520/f53/c21520f531f3df7a185296f33bfa8f2b.png" alt="Tableau des diff√©rences de deux fa√ßons de restaurer les achats de la WWDC"><br>  <em>Tableau des diff√©rences de deux fa√ßons de restaurer les achats de la WWDC</em> </p><br><p>  Dans la plupart des cas, il vous suffit d'utiliser <code>SKReceiptRefreshRequest()</code> , car nous souhaitons uniquement recevoir un ch√®que pour le calcul ult√©rieur de la date d'expiration. </p><br><p>  Dans le cas des abonnements auto-renouvelables, les transactions elles-m√™mes ne nous int√©ressent pas, il suffit donc de n'utiliser que la mise √† jour des ch√®ques.  Cependant, il existe des cas o√π vous devez utiliser la m√©thode de r√©cup√©ration de transaction: si votre application t√©l√©charge du contenu lors de l'achat (contenu h√©berg√© par Apple) ou si vous prenez toujours en charge les versions inf√©rieures √† iOS 7. </p><br><h3 id="testirovanie-pokupok-sandbox-testing">  Test de magasinage (test de bac √† sable) </h3><br><p>  Auparavant, pour tester les achats, vous deviez vous connecter depuis l'App Store dans les param√®tres de votre iPhone.  C'√©tait tr√®s g√™nant (par exemple, toute la biblioth√®que musicale Apple a √©t√© effac√©e).  Cependant, cela n'a pas besoin d'√™tre fait maintenant: le compte sandbox existe d√©sormais s√©par√©ment du compte principal. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/846/b0d/1d5/846b0d1d5a265e9a3f38ebeaa1bd61ef.jpg"></p><br><p>  Le processus d'achat est similaire par rapport aux achats r√©els dans l'App Store, mais il y a quelques points: </p><br><ul><li><p>  Vous devrez toujours saisir le mot de passe de connexion via la fen√™tre syst√®me.  Les achats utilisant Touch ID / Face ID ne sont toujours pas pris en charge. </p><br></li><li><p>  Si, lors de la saisie correcte du login et du mot de passe, le syst√®me demande encore et encore le mot de passe de connexion, <em>cliquez sur ¬´Annuler¬ª</em> , minimisez l'application, puis r√©essayez.  Cela ressemble √† un non-sens, mais cela fonctionne pour beaucoup.  Mais parfois, apr√®s la deuxi√®me entr√©e du mot de passe, le processus continue. </p><br></li><li><p>  Vous ne pourrez pas tester le processus de d√©sinscription. </p><br></li><li><p>  La dur√©e des p√©riodes d'abonnement est bien inf√©rieure √† la r√©alit√©.  Et ils ne sont pas mis √† jour plus de 6 fois par jour. </p><br></li></ul><br><div class="scrollable-table"><table><thead><tr><th>  Dur√©e r√©elle </th><th>  Dur√©e du test </th></tr></thead><tbody><tr><td>  1 semaine </td><td>  3 minutes </td></tr><tr><td>  1 mois </td><td>  5 minutes </td></tr><tr><td>  2 mois </td><td>  10 minutes </td></tr><tr><td>  3 mois </td><td>  15 minutes </td></tr><tr><td>  6 mois </td><td>  30 minutes </td></tr><tr><td>  1 an </td><td>  1 heure </td></tr></tbody></table></div><br><h3 id="chto-novogo-v-storekit-v-ios-13">  Quoi de neuf dans StoreKit dans iOS 13? </h3><br><p>  De la nouvelle - uniquement la classe <code>SKStorefront</code> , qui donne des informations sur le pays dans lequel l'utilisateur est enregistr√© dans l'App Store.  Cela peut √™tre utile aux d√©veloppeurs qui utilisent diff√©rents abonnements pour diff√©rents pays.  Auparavant, tout le monde v√©rifiait par g√©olocalisation ou par r√©gion de l'appareil, mais cela ne donnait pas de r√©sultat pr√©cis.  Il est d√©sormais tr√®s facile de d√©couvrir le pays dans l'App Store: <code>SKPaymentQueue.default().storefront?.countryCode</code> .  Un d√©l√©gu√© de m√©thode a √©galement √©t√© ajout√© si le pays de l'App Store a chang√© au cours du processus d'achat.  Dans ce cas, vous pouvez continuer ou annuler vous-m√™me le processus d'achat. </p><br><h2 id="podvodnye-kamni-pri-rabote-s-podpiskami">  Pi√®ges lors de l'utilisation d'abonnements </h2><br><ul><li>  V√©rifier un ch√®que directement √† partir d'un appareil n'est pas recommand√© par Apple.  Ils en ont parl√© plusieurs fois <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√† la WWDC</a> (√† partir de 5h50) et cela est indiqu√© dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> .  Ceci n'est pas s√ªr car un attaquant peut intercepter des donn√©es √† l'aide d'une attaque par l'homme du milieu.  La bonne fa√ßon de v√©rifier les ch√®ques est la validation locale √† l'aide de votre serveur. </li><li>  Il y a un probl√®me avec la v√©rification de la date d'expiration.  Si vous n'utilisez pas votre serveur, l'heure du syst√®me sur l'appareil peut √™tre remplac√©e par une ancienne, puis notre code donnera le mauvais r√©sultat - l'abonnement sera consid√©r√© comme actif.  Si cela ne vous convient pas, vous pouvez utiliser n'importe quel service qui √©met l'heure exacte du monde. </li><li>  Tous les utilisateurs ne peuvent pas b√©n√©ficier d'un essai gratuit.  L'utilisateur peut r√©installer l'application apr√®s un certain temps et l'application montrera que la version d'essai est disponible comme d'habitude.  Il sera correct de mettre √† jour la v√©rification, de la valider et de v√©rifier dans JSON la disponibilit√© de la version d'essai pour cet utilisateur.  Beaucoup ne le font pas. </li><li>  Si l'utilisateur a demand√© un remboursement, la date d' <code>cancellation_date</code> sera ajout√©e √† l'abonnement JSON, mais la date d' <code>expires_date</code> restera inchang√©e.  Par cons√©quent, il est important de toujours v√©rifier la pr√©sence du champ d' <code>cancellation_date</code> , qui est pr√©f√©rable √† <code>expires_date</code> . </li><li>  Cela ne vaut pas la peine de mettre √† jour la v√©rification chaque fois que l'application est lanc√©e, car, premi√®rement, cela est inutile, et deuxi√®mement, tr√®s probablement, l'utilisateur verra la fen√™tre de saisie du mot de passe Apple ID.  Cela vaut la peine de mettre √† jour le ch√®que, par exemple, lorsque l'utilisateur a lui-m√™me cliqu√© sur le bouton de restauration des achats. </li><li>  Comment d√©terminer √† quel moment il vaut la peine de valider un ch√®que pour obtenir la date d'expiration actuelle d'un abonnement?  Vous pouvez valider le ch√®que √† chaque d√©marrage, ou uniquement √† la fin de l'abonnement.  Cependant, si vous ne cochez le ch√®que qu'√† la fin de l'abonnement, l'utilisateur qui a √©mis le remboursement pourra utiliser gratuitement votre application jusqu'√† la fin de la p√©riode. </li></ul><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  J'esp√®re que cet article vous sera utile.  J'ai essay√© d'ajouter non seulement le code, mais aussi d'expliquer les points subtils du d√©veloppement.  Le code complet de la classe peut √™tre t√©l√©charg√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Ce cours sera tr√®s utile pour faire la connaissance des d√©veloppeurs novices et de ceux qui veulent en savoir plus sur le fonctionnement de tout.  Pour les applications en direct, il est recommand√© d'utiliser des solutions plus s√©rieuses, par exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SwiftyStoreKit</a> . </p><br><blockquote>  Vous souhaitez mettre en ≈ìuvre des abonnements dans votre application iOS en 10 minutes?  Int√©grez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apphud</a> et: <br><ul><li>  Faites des achats en utilisant une seule m√©thode; </li><li>  suivre automatiquement l'√©tat de l'abonnement de chaque utilisateur; </li><li>  Int√©grez facilement les offres d'abonnement </li><li>  envoyer des √©v√©nements d'abonnement √† Amplitude, Mixpanel, Slack et Telegram en tenant compte de la devise locale de l'utilisateur; </li><li>  diminuer le taux de d√©sabonnement dans les applications et renvoyer les utilisateurs non abonn√©s. </li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr456602/">https://habr.com/ru/post/fr456602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr456584/index.html"># ITX5 r√©unira un groupe de d√©veloppeurs JAVA</a></li>
<li><a href="../fr456588/index.html">√âtudier l'injection de d√©pendance</a></li>
<li><a href="../fr456592/index.html">Les distorsions cognitives dans le d√©veloppement des ¬´temps¬ª de la langue anglaise, ou Qui interf√®re avec nous nous aidera</a></li>
<li><a href="../fr456596/index.html">Microbiota. Comment fonctionne le test?</a></li>
<li><a href="../fr456600/index.html">Recettes Nginx: autorisation LDAP avec captcha</a></li>
<li><a href="../fr456604/index.html">Comment nous avons automatis√© une grande boutique en ligne et commenc√© √† faire correspondre automatiquement les produits</a></li>
<li><a href="../fr456606/index.html">Nouvelles du monde d'OpenStreetMap n ¬∞ 464 (04/04/2019 - 06/10/2019)</a></li>
<li><a href="../fr456608/index.html">Southbridge √† Chelyabinsk et Bitrix √† Kubernetes</a></li>
<li><a href="../fr456610/index.html">N'appuyez pas et n'approuvez pas</a></li>
<li><a href="../fr456612/index.html">L'une des centaines de fa√ßons de publier plusieurs projets de production sur un seul serveur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>