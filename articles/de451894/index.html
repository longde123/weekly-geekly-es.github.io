<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💅🏻 👨 😈 Ein kurzer und übersichtlicher Überblick über die Compiler-Architektur 🥈 👨🏽‍🚒 🙋🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die meisten Compiler haben die folgende Architektur: 



 In diesem Artikel werde ich diese Architektur Element für Element im Detail analysieren. 
 W...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein kurzer und übersichtlicher Überblick über die Compiler-Architektur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/451894/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sl/ej/-i/slej-ivpokabgczeqdbgiafc0rw.jpeg"></div><br>  Die meisten Compiler haben die folgende Architektur: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/73e/ff7/c46/73eff7c467213f5de1b9134666f9e569.png"><br><br>  In diesem Artikel werde ich diese Architektur Element für Element im Detail analysieren. <br>  Wir können sagen, dass dieser Artikel eine Ergänzung zu der großen Menge vorhandener Ressourcen zum Thema Compiler ist.  Es ist eine autonome Quelle, die es Ihnen ermöglicht, die Grundlagen des Entwurfs und der Implementierung von Programmiersprachen zu verstehen. <br><br>  Die Zielgruppe des Artikels sind Personen, deren Vorstellung von der Arbeit der Compiler äußerst begrenzt ist (das Maximum ist, dass sie am Kompilieren beteiligt sind).  Ich erwarte jedoch, dass der Leser Datenstrukturen und Algorithmen versteht. <br><br>  Der Artikel ist keineswegs modernen Produktions-Compilern mit Millionen von Codezeilen gewidmet - nein, dies ist ein kurzer Kurs „Compiler für Dummies“, der Ihnen hilft, zu verstehen, was ein Compiler ist. <br><a name="habracut"></a><br><h2>  Einführung </h2><br>  Ich arbeite derzeit an der von Rust and Go inspirierten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Krug-</a> Systemsprache.  In dem Artikel werde ich Krug als Beispiel nennen, um meine Gedanken zu veranschaulichen.  Krug befindet sich in der Entwicklung, ist jedoch bereits unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/krug-lang</a> in den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Caasper-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Krug-</a> Repositories verfügbar.  Die Sprache ist im Vergleich zur üblichen Compiler-Architektur nicht ganz typisch, was mich teilweise dazu inspiriert hat, einen Artikel zu schreiben - aber dazu später mehr. <br><br>  Ich beeile mich, Ihnen mitzuteilen, dass ich in keiner Weise ein Spezialist für Compiler bin!  Ich habe keinen Doktortitel und keine formelle Ausbildung absolviert. In meiner Freizeit habe ich alles, was im Artikel beschrieben ist, selbst studiert.  Ich muss auch sagen, dass ich nicht den tatsächlichen, nur richtigen Ansatz zum Erstellen eines Compilers beschreibe, sondern die grundlegenden Methoden vorstelle, die zum Erstellen eines kleinen "Spielzeug" -Compilers geeignet sind. <br><br><h2>  Frontend </h2><br>  Kehren wir zum obigen Diagramm zurück: Die Pfeile links, die auf das Frontendfeld gerichtet sind, sind bekannte und beliebte Sprachen wie C. Das Frontend sieht ungefähr so ​​aus: lexikalische Analyse -&gt; Parser. <br><br><h2>  Lexikalische Analyse </h2><br>  Als ich anfing, Compiler und Sprachdesign zu studieren, wurde mir gesagt, dass lexikalische Analyse dasselbe ist wie Tokenisierung.  Wir werden diese Beschreibung verwenden.  Der Analysator nimmt Eingabedaten in Form von Zeichenfolgen oder einem Strom von Zeichen auf und erkennt darin Muster, die er in Token schneidet. <br><br>  Im Falle eines Compilers erhält er am Eingang ein geschriebenes Programm.  Es wird aus einer Datei in eine Zeichenfolge eingelesen, und der Analysator markiert seinen Quellcode. <br><br><pre><code class="plaintext hljs">enum TokenType { Identifier, Number, }; struct Token { std::string Lexeme; TokenType type; // ... // It's also handy to store things in here // like the position of the token (start to end row:col) };</code> </pre> <br>  In diesem Fragment, das in einer C-förmigen Sprache geschrieben ist, sehen Sie die Struktur, die das oben genannte Lexem enthält, sowie TokenType, das zur Erkennung dieses Tokens dient. <br><br>  Hinweis: Der Artikel ist keine Anleitung zum Erstellen einer Sprache mit Beispielen. Zum besseren Verständnis werde ich jedoch von Zeit zu Zeit Codefragmente einfügen. <br><br>  Analysatoren sind normalerweise die einfachsten Compilerkomponenten.  Das gesamte Frontend ist im Vergleich zu den anderen Puzzleteilen recht einfach.  Obwohl es sehr von Ihrer Arbeit abhängt. <br><br>  Nehmen Sie den folgenden C-Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello world!\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Nachdem Sie es aus einer Datei in eine Zeile gelesen und einen linearen Scan durchgeführt haben, können Sie möglicherweise Token in Scheiben schneiden.  Wir identifizieren Token auf natürliche Weise - da int ein "Wort" und 0 in der return-Anweisung eine "Zahl" ist.  Der lexikalische Analysator führt das gleiche Verfahren wie wir aus - später werden wir diesen Prozess genauer untersuchen.  Analysieren Sie beispielsweise die Zahlen: <br><br><pre> <code class="plaintext hljs">0xdeadbeef — HexNumber ( ) 1231234234 — WholeNumber ( ) 3.1412 — FloatingNumber (   ) 55.5555 — FloatingNumber (   ) 0b0001 — BinaryNumber ( )</code> </pre> <br>  Das Definieren von Wörtern kann schwierig sein.  Die meisten Sprachen definieren ein Wort als eine Folge von Buchstaben und Zahlen, und ein Bezeichner sollte normalerweise mit einem Buchstaben oder einem Unterstrich beginnen.  Zum Beispiel: <br><br><pre> <code class="plaintext hljs">123foobar := 3 person-age := 5 fmt.Println(123foobar)</code> </pre> <br>  In Go wird dieser Code nicht als korrekt angesehen und in die folgenden Token analysiert: <br><br><pre> <code class="plaintext hljs">Number(123), Identifier(foobar), Symbol(:=), Number(3) ...</code> </pre> <br>  Die meisten der gefundenen Bezeichner sehen folgendermaßen aus: <br><br><pre> <code class="plaintext hljs">foo_bar __uint8_t fooBar123</code> </pre> <br>  Analysatoren müssen andere Probleme lösen, z. B. Leerzeichen, mehrzeilige und einzeilige Kommentare, Bezeichner, Zahlen, Zahlensysteme und Zahlenformatierung (z. B. 1_000_000) und Codierungen (z. B. Unterstützung für UTF8 anstelle von ASCII). <br><br>  Und wenn Sie denken, Sie können auf reguläre Ausdrücke zurückgreifen - besser nicht wert.  Es ist viel einfacher, einen Analysator von Grund auf neu zu schreiben, aber ich empfehle dringend, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Artikel</a> von unserem König und Gott Rob Pike zu lesen.  Die Gründe, warum Regex für uns nicht geeignet ist, sind in vielen anderen Artikeln beschrieben, daher werde ich diesen Punkt weglassen.  Darüber hinaus ist das Schreiben eines Analysators viel interessanter, als sich mit langen, ausführlichen Ausdrücken zu quälen, die um 5:24 Uhr auf regex101.com hochgeladen wurden.  In meiner ersten Sprache habe ich die Funktion <code>split(str)</code> für die Tokenisierung verwendet - und bin nicht weit gegangen. <br><br><h2>  Parsen </h2><br>  Das Parsen ist etwas komplizierter als die lexikalische Analyse.  Es gibt viele Parser und Parser-Generatoren - hier beginnt das Spiel in großem Stil. <br><br>  Parser in Compilern nehmen normalerweise Eingaben in Form von Token entgegen und erstellen einen bestimmten Baum - einen abstrakten Syntaxbaum oder einen Parsing-Baum.  Sie sind von Natur aus ähnlich, weisen jedoch einige Unterschiede auf. <br><br>  Diese Stufen können als Funktionen dargestellt werden: <br><br><pre> <code class="plaintext hljs">fn lex(string input) []Token {...} fn parse(tokens []Token) AST {...} let input = "int main() { return 0; }"; let tokens = lex(input); let parse_tree = parse(tokens); // ....</code> </pre> <br>  In der Regel bestehen Compiler aus vielen kleinen Komponenten, die Eingaben übernehmen, ändern oder in andere Ausgaben konvertieren.  Dies ist einer der Gründe, warum funktionale Sprachen gut zum Erstellen von Compilern geeignet sind.  Andere Gründe sind ausgezeichnetes Benchmarking und ziemlich umfangreiche Standardbibliotheken.  Unterhaltsame Tatsache: Die erste Implementierung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust-</a> Compilers war auf Ocaml. <br><br>  Ich rate Ihnen, diese Komponenten so einfach und autonom wie möglich zu halten - Modularität erleichtert den Prozess erheblich.  Meiner Meinung nach gilt das Gleiche für viele andere Aspekte der Softwareentwicklung. <br><br><h2>  Bäume </h2><br><h4>  Parsing-Baum </h4><br>  Was zum Teufel ist das?  Dieser dicke Baum wird auch als Analysebaum bezeichnet und dient zur Visualisierung des Quellprogramms.  Sie enthalten alle Informationen (oder die meisten davon) über das Eingabeprogramm, normalerweise die gleichen wie in der Grammatik Ihrer Sprache beschrieben.  Jeder Baumknoten ist nachlaufend oder nicht nachlaufend, z. B. NumberConstant oder StringConstant. <br><br><h4>  Abstrakter Syntaxbaum </h4><br>  Wie der Name schon sagt, ist die ASD ein <i>abstrakter</i> Syntaxbaum.  Der Analysebaum enthält viele (häufig redundante) Informationen zu Ihrem Programm. Bei einer ASD sind diese nicht erforderlich.  ASD benötigt keine nutzlosen Informationen über die Struktur und Grammatik, was die Semantik des Programms nicht beeinflusst. <br><br>  Angenommen, Ihr Baum hat einen Ausdruck wie ((5 + 5) -3) +2.  Im Analysebaum würden Sie ihn zusammen mit Klammern, Operatoren und Werten 5, 5, 3 und 2 vollständig speichern. Sie können ihn jedoch einfach mit der ASD verknüpfen - wir müssen nur die Werte, Operatoren und deren Reihenfolge kennen. <br><br>  Das Bild unten zeigt den Baum für den Ausdruck a + b / c. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98c/61a/cb3/98c61acb355e7887b53b5c37de0aa34f.png" width="400"></div><br>  ASD kann wie folgt dargestellt werden: <br><br><pre> <code class="plaintext hljs">interface Expression { ... }; struct UnaryExpression { Expression value; char op; }; struct BinaryExpression { Expression lhand, rhand; string op; // string because the op could be more than 1 char. }; interface Node { ... }; // or for something like a variable struct Variable : Node { Token identifier; Expression value; };</code> </pre> <br>  Diese Ansicht ist ziemlich eingeschränkt, aber ich hoffe, Sie können sehen, wie Ihre Knoten strukturiert werden.  Zum Parsen können Sie wie folgt vorgehen: <br><br><pre> <code class="plaintext hljs">Node parseNode() { Token current = consume(); switch (current.lexeme) { case "var": return parseVariableNode(); // ... } panic("unrecognized input!"); } Node n = parseNode(); if (n != null) { // append to some list of top level nodes? // or append to a block of nodes! }</code> </pre> <br>  Ich hoffe, dass Sie einen Überblick darüber erhalten, wie das schrittweise Parsen der verbleibenden Knoten ablaufen wird, beginnend mit Sprachkonstrukten auf hoher Ebene.  Wie genau ein Parser mit rekursiver Abstammung implementiert ist, müssen Sie selbst studieren. <br><br><h2>  Grammatik </h2><br>  Das Parsen in einem ADS aus einer Reihe von Token kann schwierig sein.  Normalerweise sollten Sie mit der Grammatik Ihrer Sprache beginnen.  Im Wesentlichen bestimmt die Grammatik die Struktur Ihrer Sprache.  Es gibt mehrere Sprachen zum Definieren von Sprachen, die sich selbst beschreiben (oder analysieren) können. <br><br>  Ein Beispiel für eine Sprache zur Bestimmung von Sprachen ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erweiterte Form von Backus-Naur</a> (RBNF).  Es ist eine Variante von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BNF</a> mit weniger spitzen Klammern.  Hier ist ein RBNF-Beispiel aus einem Wikipedia-Artikel: <br><br><pre> <code class="plaintext hljs">digit excluding zero = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ; digit = "0" | digit excluding zero ;</code> </pre> <br>  Produktionsregeln sind definiert: Sie geben an, welche Terminalvorlage „nicht terminal“ ist.  Terminals sind Teil des Alphabets, z. B. sind das if-Token oder 0 und 1 im obigen Beispiel Terminals.  Nicht-Terminals sind das Gegenteil, sie befinden sich auf der linken Seite der Produktionsregeln und können als Variablen oder „benannte Zeiger“ auf Gruppen von Terminals und Nicht-Terminals betrachtet werden. <br><br>  Viele Sprachen haben Spezifikationen, die Grammatik enthalten.  Zum Beispiel für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">D.</a> <br><br><h2>  Rekursive Abstiegsanalysatoren </h2><br>  Rekursiver Abstieg ist der einfachste von vielen Parsing-Ansätzen. <br><br>  Rekursive Abstiegsanalysatoren - absteigend, basierend auf rekursiven Verfahren.  Es ist viel einfacher, einen Parser zu schreiben, da Ihre Grammatik keine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rekursion hinterlassen hat</a> .  In den meisten "Spielzeug" -Sprachen reicht diese Technik zum Parsen aus.  GCC verwendet einen handgeschriebenen absteigenden Parser, obwohl YACC zuvor verwendet wurde. <br><br>  Das Parsen dieser Sprachen kann jedoch zu Problemen führen.  Insbesondere C, wo <br><br><pre> <code class="cpp hljs">foo * bar</code> </pre> <br>  kann interpretiert werden als <br><br><pre> <code class="plaintext hljs">int foo = 3; int bar = 4; foo * bar; // unused expression</code> </pre> <br>  oder wie <br><br><pre> <code class="plaintext hljs">typedef struct { int b; } foo; foo* bar; bar.b = 3;</code> </pre> <br>  Die Clang-Implementierung verwendet auch einen rekursiven Abstiegsanalysator: <br><br>  <i>Da dies regulärer C ++ - Code ist, erleichtert ein rekursiver Abstieg Anfängern das Verständnis.</i>  <i>Es unterstützt benutzerdefinierte Regeln und andere seltsame Dinge, die C / C ++ erfordert, und hilft Ihnen, Fehler einfach zu diagnostizieren und zu beheben.</i> <br><br>  Es lohnt sich auch, auf andere Ansätze zu achten: <br><br><ul><li>  absteigender LL, rekursiver Abstieg </li><li>  aufsteigender LR, Verschiebung, aufsteigender Abstieg </li></ul><br><h2>  Parser-Generatoren </h2><br>  Ein weiterer guter Weg.  Natürlich gibt es auch Nachteile - aber dies kann über jede andere Wahl gesagt werden, die Programmierer beim Erstellen von Software treffen. <br><br>  Parser-Generatoren arbeiten sehr zügig.  Ihre Verwendung ist einfacher als das Schreiben eines eigenen Analysators und das Erhalten eines Qualitätsergebnisses - obwohl sie nicht sehr benutzerfreundlich sind und nicht immer Fehlermeldungen anzeigen.  Außerdem müssen Sie lernen, wie Sie den Parser-Generator verwenden, und wenn Sie den Compiler hochstufen, müssen Sie wahrscheinlich den Parser-Generator abwickeln. <br><br>  Ein Beispiel für einen Parser-Generator ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ANTLR</a> , es gibt viele andere. <br><br>  Ich denke, dieses Tool ist für diejenigen geeignet, die keine Zeit damit verbringen möchten, ein Frontend zu schreiben, und die es vorziehen, die Mitte und das Backend des Compilers / Interpreters zu schreiben und irgendetwas zu analysieren. <br><br><h2>  Analyseanwendung </h2><br>  Wenn du dich immer noch nicht verstehst.  Sogar das Compiler-Frontend (lex / parse) kann verwendet werden, um andere Probleme zu lösen: <br><br><ul><li>  Syntaxhervorhebung </li><li>  HTML / CSS-Analyse für die Rendering-Engine </li><li>  Transpiler: TypeScript, CoffeeScript </li><li>  Linker </li><li>  REGEX </li><li>  Schnittstellendatenanalyse </li><li>  URL-Analyse </li><li>  Formatierungswerkzeuge wie <i>gofmt</i> </li><li>  SQL-Analyse und mehr. </li></ul><br><h2>  Mitte </h2><br>  Semantische Analyse!  Die Analyse der Sprachsemantik ist eine der schwierigsten Aufgaben beim Erstellen eines Compilers. <br><br>  Sie müssen sicherstellen, dass alle Eingabeprogramme ordnungsgemäß funktionieren.  In meiner Krug-Sprache wurden Aspekte der semantischen Analyse noch nicht berücksichtigt, und ohne sie muss der Programmierer immer den richtigen Code schreiben.  In Wirklichkeit ist dies unmöglich - und wir schreiben, kompilieren, führen manchmal Fehler aus.  Diese Spirale ist endlos. <br><br>  Darüber hinaus ist die Kompilierung von Programmen ohne eine Analyse der Richtigkeit der Semantik in der entsprechenden Phase der Kompilierung nicht möglich. <br><br>  Ich bin einmal auf ein Diagramm über den Prozentsatz von Frontend, Midland und Backend gestoßen.  Dann sah es so aus <br><br><pre> <code class="plaintext hljs">F: 20% M: 20%: B: 60%</code> </pre> <br>  Heute ist es so etwas wie <br><br><pre> <code class="plaintext hljs">F: 5% M: 60% B: 35%</code> </pre> <br>  Das Frontend befasst sich hauptsächlich mit dem Generator, und in kontextlosen Sprachen, die nicht die Dualität der Grammatik haben, können sie recht schnell abgeschlossen werden - ein rekursiver Abstieg hilft hier. <br><br>  Mit der LLVM-Technologie kann der größte Teil der Optimierungsarbeit in das Framework hochgeladen werden, das eine Reihe vorgefertigter Optimierungen enthält. <br><br>  Der nächste Schritt ist die semantische Analyse, ein wesentlicher Bestandteil der Kompilierungsphase. <br><br>  In Rust mit seinem Speicherverwaltungsmodell fungiert der Compiler beispielsweise als große, leistungsstarke Maschine, die verschiedene Arten der statischen Analyse von Einführungsformularen durchführt.  Ein Teil dieser Aufgabe besteht darin, die Eingabedaten in eine bequemere Form für die Analyse umzuwandeln. <br><br>  Aus diesem Grund spielt die semantische Analyse eine wichtige Rolle in der Architektur des Compilers, und anstrengende Vorbereitungsarbeiten wie die Optimierung der generierten Assembly oder das Lesen der Eingabedaten in der ASD werden für Sie durchgeführt. <br><br><h2>  Semantische Passagen </h2><br>  Im Verlauf der semantischen Analyse führen die meisten Compiler eine große Anzahl von "semantischen Durchläufen" auf dem SDA oder einer anderen abstrakten Form des Code-Ausdrucks durch.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dieser Artikel</a> enthält Details zu den meisten im .NET C # -Compiler durchgeführten Durchläufen. <br><br>  Ich werde nicht jede Passage betrachten, zumal sie je nach Sprache variieren, aber einige Schritte werden unten in Krug beschrieben. <br><br><h2>  Top Level Ad </h2><br>  Der Compiler durchläuft alle "Top-Level" -Ankündigungen in den Modulen und ist sich ihrer Existenz bewusst.  Er wird nicht tiefer in Blöcke gehen - er wird einfach erklären, welche Strukturen, Funktionen usw.  sind in dem einen oder anderen Modul verfügbar. <br><br><h2>  Namens- / Symbolauflösung </h2><br>  Der Compiler durchläuft alle Codeblöcke in Funktionen usw.  und löst sie auf - das heißt, es werden Zeichen gefunden, für die eine Berechtigung erforderlich ist.  Dies ist ein häufiger Durchgang, und von hier aus tritt beim Kompilieren von Go-Code normalerweise der Fehler " <i>Kein solches Symbol XYZ" auf</i> . <br><br>  Das Durchführen dieses Durchlaufs kann sehr schwierig sein, insbesondere wenn Ihr Abhängigkeitsdiagramm zirkuläre Abhängigkeiten enthält.  Einige Sprachen erlauben sie nicht, zum Beispiel, Go gibt einen Fehler aus, wenn eines Ihrer Pakete eine Schleife bildet, wie meine Krug-Sprache.  Zyklische Abhängigkeiten können als Nebeneffekt einer schlechten Architektur angesehen werden. <br><br>  Schleifen können durch Ändern der DFS im Abhängigkeitsdiagramm oder durch Verwenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">des Tarjan-Algorithmus</a> (wie von Krug ausgeführt) zum Definieren (mehrerer) Schleifen bestimmt werden. <br><br><h2>  Typ Inferenz </h2><br>  Der Compiler durchläuft alle Variablen und zeigt deren Typen an.  Die Typinferenz in Krug ist sehr schwach und gibt einfach Variablen basierend auf ihren Werten aus.  Es ist keineswegs ein bizarres System, wie man es in funktionalen Sprachen wie Haskell findet. <br><br>  Typen können mithilfe des Prozesses "Vereinheitlichung" oder "Vereinheitlichung von Typen" abgeleitet werden.  Für einfachere Typsysteme kann eine sehr einfache Implementierung verwendet werden. <br><br>  Typen werden in Krug folgendermaßen implementiert: <br><br><pre> <code class="plaintext hljs">interface Type {}; struct IntegerType : Type { int width; bool signed; }; struct FloatingType : Type { int width; }; struct ArrayType : Type { Type base_type; uint64 length; };</code> </pre> <br>  Sie können auch eine einfache Typinferenz verwenden, bei der Sie Ausdrucksknoten einen Typ zuweisen. Beispielsweise kann <code>IntegerConstantNode</code> vom Typ IntegerType (64) sein.  Und dann erhalten Sie möglicherweise die Funktion <code>unify(t1, t2)</code> , mit der der breiteste Typ ausgewählt wird, mit dem der Typ komplexerer Ausdrücke abgeleitet werden kann, z. B. binäre.  Es geht also darum, den Werten der angegebenen Typen rechts eine Variable auf der linken Seite zuzuweisen. <br><br>  Ich habe einmal eine einfache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Besetzung</a> von Go geschrieben, die zu einem Prototyp für Krug wurde. <br><br><h2>  Mutability Pass </h2><br>  Krug (wie Rust) ist standardmäßig eine unveränderliche Sprache, dh Variablen bleiben unverändert, sofern nicht anders angegeben: <br><br><pre> <code class="plaintext hljs">let x = 3; x = 4; // BAD! mut y = 5; y = 6; // OK!</code> </pre> <br>  Der Compiler durchläuft alle Blöcke und Funktionen und prüft, ob ihre „Variablen korrekt“ sind, dh wir ändern nicht, was nicht folgt, und dass alle an bestimmte Funktionen übergebenen Variablen bei Bedarf konstant oder änderbar sind. <br><br>  Dies geschieht mit Hilfe symbolischer Informationen, die in früheren Durchgängen gesammelt wurden.  Eine Symboltabelle, die auf den Ergebnissen des semantischen Durchlaufs basiert, enthält Token-Namen und Zeichen variabler Variabilität.  Es kann andere Daten enthalten, z. B. in C ++ kann eine Tabelle Informationen darüber speichern, ob ein Symbol extern oder statisch ist. <br><br><h2>  Zeichentabellen </h2><br>  Eine Zeichentabelle oder „Stich“ ist eine Tabelle zum Auffinden der Zeichen, die in Ihrem Programm verwendet werden.  Für jeden Bereich wird eine Tabelle erstellt, die alle Informationen zu den in einem bestimmten Bereich vorhandenen Zeichen enthält. <br><br>  Diese Informationen umfassen Eigenschaften wie den Symbolnamen, den Typ, das Zeichen der Veränderlichkeit, das Vorhandensein externer Kommunikation, den Speicherort im statischen Speicher usw. <br><br><h3>  Geltungsbereich </h3><br>  Dies ist ein wichtiges Konzept in Programmiersprachen.  Natürlich muss Ihre Sprache es nicht ermöglichen, verschachtelte Bereiche zu erstellen, alles kann in einem gemeinsamen Namespace platziert werden! <br><br>  Obwohl die Darstellung des Bereichs eine interessante Aufgabe für die Compilerarchitektur ist, verhält sich der Bereich in den meisten C-ähnlichen Sprachen wie eine Stapeldatenstruktur (oder ist dies auch). <br><br>  Normalerweise erstellen und zerstören wir Bereiche, und sie werden normalerweise zum Verwalten von Namen verwendet, dh sie ermöglichen es uns, Variablen zu verbergen (zu beschatten): <br><br><pre> <code class="plaintext hljs">{ // push scope let x = 3; { // push scope let x = 4; // OK! } // pop scope } // pop scope</code> </pre> <br>  Es kann anders dargestellt werden: <br><br><pre> <code class="plaintext hljs">struct Scope { Scope* outer; SymbolTable symbols; }</code> </pre> <br>  Ein kleines offtopic, aber ich empfehle, über den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spaghetti-Stapel zu</a> lesen.  Dies ist eine Datenstruktur, die zum Speichern von Sichtbarkeitsbereichen in den ASD-Knoten gegenüberliegender Blöcke verwendet wird. <br><br><h2>  Typ Systeme </h2><br>  Viele der folgenden Abschnitte können zu separaten Artikeln entwickelt werden, aber es scheint mir, dass dieser Titel dies am meisten verdient.  Heutzutage sind viele Informationen über Typsysteme sowie Sorten der Systeme selbst verfügbar, um die herum viele Kopien brechen.  Ich werde mich nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eingehend</a> mit diesem Thema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">befassen, sondern</a> nur einen Link zu dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausgezeichneten Artikel von Steve Klabnik hinterlassen</a> . <br><br>  Ein Typsystem wird im Compiler mithilfe von Compiler-Darstellungen und der Analyse dieser Darstellungen bereitgestellt und semantisch definiert. <br><br><h2>  Besitz </h2><br>  Dieses Konzept wird in der Programmierung immer häufiger verwendet.  Die Prinzipien der Semantik von Eigentum und Bewegung sind in die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust-</a> Sprache eingebettet, und ich hoffe, dass sie in anderen Sprachen erscheinen.  Rust führt viele verschiedene Arten der statischen Analyse durch, um zu überprüfen, ob die Eingabe eine Reihe von Regeln bezüglich des Speichers erfüllt: Wem gehört welcher Speicher, wann wird der Speicher zerstört und wie viele Verweise (oder Ausleihen) auf diese Werte oder Speicher vorhanden sind. <br><br>  Das Schöne an Rust liegt in der Tatsache, dass dies alles während der Kompilierung im Compiler erfolgt, sodass sich der Programmierer nicht mit der Speicherbereinigung oder der Linkzählung befassen muss.  Alle diese Semantiken sind dem Typsystem zugeordnet und können bereitgestellt werden, noch bevor das Programm in Form einer vollständigen Binärdatei präsentiert wird. <br><br>  Ich kann nicht sagen, wie das alles unter der Haube funktioniert, aber all dies ist das Ergebnis statischer Analysen und wunderbarer Forschungen des Mozilla-Teams und der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cyclone-</a> Projektteilnehmer. <br><br><h2>  Kontrollflussdiagramme </h2><br>  Zur Darstellung von Programmabläufen verwenden wir Kontrollflussdiagramme (CFGs), die alle Pfade enthalten, denen die Programmausführung folgen kann.  Dies wird in der semantischen Analyse verwendet, um inaktive Codeabschnitte auszuschließen, dh Blöcke, Funktionen und sogar Module, die während der Programmausführung niemals erreicht werden.  Diagramme können auch verwendet werden, um Zyklen zu identifizieren, die nicht unterbrochen werden können.  Oder um nach unzugänglichem Code zu suchen, wenn Sie beispielsweise eine „Panik“ (Panik) aufrufen oder in einer Schleife zurückkehren und der Code außerhalb der Schleife nicht ausgeführt wird.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Datenflussanalyse</a> spielt in der semantischen Phase des Compilers eine wichtige Rolle. Ich empfehle daher, zu lesen, welche Analysetypen Sie ausführen können, wie sie funktionieren und welche Optimierungen möglich sind. <br><br><h2>  Backend </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/330/914/1b9/3309141b9d53be1d9e5c8f77fb46d982.jpg"><br>  <i>Der letzte Teil unseres Architekturschemas.</i> <br><br>  Wir haben den größten Teil der Arbeit zum Generieren ausführbarer Binärdateien geleistet.  Dies kann auf verschiedene Arten geschehen, die wir unten diskutieren werden. <br><br>        - ,   . ,     ,    «». <br><br><h2>     </h2><br>   ,           . ,    ,      .   ,   ,         ,    .        ,      . <br><br>   ,           .  ,   ++ — Cfront —     C. <br><br>    JavaScript.     TypeScript    ,     ,   ,              ,         . <br><br>    «» ,     ,             ,       ,    «  »  .        —   ,        ,     . <br><br><h2> LLVM </h2><br>          LLVM: Rust, Swift, C/C++ (clang), D, Haskell. <br><br>    « »,             ,      .     , LLVM      .   ,       .  ,   ,     , , 1, 4, 8  16-.       ,  ,   -    . <br><br><h2>  - </h2><br>      —     , —     ,      . <br><br> Go —    ,      LLVM (    ). Go     ,    Windows, Linux  MacOS. ,    Krug    -. <br><br>        .  ,     LLVM,     ,   ,        LLVM      ,     . <br><br>   ,        ,       ,        LLVM,      IR,    ,  , ,    (    ). <br><br>     .      ,         ,   ,       .       IR (    )  «»       fprintf   .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8cc</a> . <br><br><h2>   </h2><br>             .   — Java:  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JVM</a>        , , Kotlin. <br><br>     ,   Java   .         ,           .            ,       . <br>   , JVM   JIT       ,     JIT-,     . <br><br><h2>  </h2><br>     ,      !      ,     ,   .   -          ,   ,   . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Godbolt</a> —  ,  ,             .       , ,     . <br><br>      ,         ,       (strip the debug symbols),  ,   GCC.     ,  -  . <br><br>            .       .    ,         .        production-. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>        rwmj ,    8  ,   80%     .        1971-!    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  ,  Rust. <br><br><h2>  IR </h2><br>   (intermediate representation, IR)  ,  .      ,        ,     . <br><br>   IR     .      ,  ,    ,    . <br><br>    IR,  «»,       IR   . , SSA — Static Single Assignment,   ,        . <br><br>  Go     IR   SSA. IR  LLVM   SSA,    . <br><br>  SSA   ,  ,   (constant propagation),     ( )  . <br><br><h2>   </h2><br>      ,  .  ,    ,   ,      ,    .         (  16  32),     ,      (spill to the stack). <br><br>   —             (   ).     ,     ,          . <br><br>     : <br><br><ul><li>   (graph colouring) —   (NP- ).      ,     (liveness ranges) . <br></li><li>   —       . <br></li></ul><br><h2>     </h2><br>     . ,       .   ,       ,         . <br><br><h2>   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Name Mangling</a> ) </h2><br>    -,            ,        .         ,   . <br><br><pre> <code class="plaintext hljs">fn main() int { let x = 0; { let x = 0; { let x = 0; } } return 0; }</code> </pre> <br> ,    (  -    :) )      ,      .        ,        . <br><br><h2>   </h2><br>   LLDB     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DWARF</a> .     LLVM   ,   DWARF         GNU-. ,     ,     ,   . <br><br><h2>    (Foreign Function Interface, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FFI</a> ) </h2><br>   libc   ,        ,      .       ,        ? <br><br><h2>  </h2><br>   —  .     ,      (  .s/.asm)?       ? ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jai</a>        .   ,     . <br><br><h2>    (CaaS) </h2><br>         API-.  ,       Krug-,         .  ,     ,      . <br><br> ,     , ,      .         ,     API-. <br><br>   production-   CaaS.    Microsofts Roslyn,       ,     .    , , ,      ,     API-,     , ,  Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RLS</a> . <br><br>    Krug —        —   Caasper  CaaS-. <br><br> Caasper      (,  ,  ),      , krug,    .   ,        ,      (bootstrap)   ,     . <br><br>   Krug   JavaScript,       Go*,  , ,   Krug. JavaScript     ,         yarn/npm. <br><br> <i>*      Go   ()  ,    JS.</i> <br><br>    Caasper  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> Github   Krug,    D    LLVM.       YouTube- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br><br>   Krug ()  <a href=""></a> . <br><br><h2>  Nützliche Links </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jack Crenshaw</a> —        . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Crafting Interpreters</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  LLVM ( Go)</a> — ! <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PL/0</a> <br></li><li> The Dragon Book —  ,    . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8cc</a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451894/">https://habr.com/ru/post/de451894/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451878/index.html">Live-Streaming von Stereovideos auf VR-Brillen (Oculus Go)</a></li>
<li><a href="../de451880/index.html">DevPRO'19: Blick vom Wrike-Stand</a></li>
<li><a href="../de451884/index.html">Sieben Jahre als Entwickler gearbeitet: Welche Lektionen habe ich gelernt?</a></li>
<li><a href="../de451886/index.html">Verwenden diskreter Mathematik beim Testen</a></li>
<li><a href="../de451890/index.html">Delegierung einer Reverse-Subnetzzone von weniger als / 24 in BIND. Wie funktioniert es?</a></li>
<li><a href="../de451896/index.html">Eine "unzerbrechliche" eyeDisk ist durch einen Iris-Scan geschützt, überträgt jedoch ein Passwort im Klartext</a></li>
<li><a href="../de451898/index.html">Innovation auf Russisch</a></li>
<li><a href="../de451900/index.html">Erster Beitrag zur Browser-API von Facebook</a></li>
<li><a href="../de451902/index.html">Microsoft Azure Developer Camp Russland</a></li>
<li><a href="../de451904/index.html">Manchmal ist mehr weniger. Wenn eine Abnahme der Last zu einer Zunahme der Verzögerung führt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>