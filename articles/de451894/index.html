<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÖüèª üë® üòà Ein kurzer und √ºbersichtlicher √úberblick √ºber die Compiler-Architektur ü•à üë®üèΩ‚Äçüöí üôãüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die meisten Compiler haben die folgende Architektur: 



 In diesem Artikel werde ich diese Architektur Element f√ºr Element im Detail analysieren. 
 W...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein kurzer und √ºbersichtlicher √úberblick √ºber die Compiler-Architektur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/451894/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sl/ej/-i/slej-ivpokabgczeqdbgiafc0rw.jpeg"></div><br>  Die meisten Compiler haben die folgende Architektur: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/73e/ff7/c46/73eff7c467213f5de1b9134666f9e569.png"><br><br>  In diesem Artikel werde ich diese Architektur Element f√ºr Element im Detail analysieren. <br>  Wir k√∂nnen sagen, dass dieser Artikel eine Erg√§nzung zu der gro√üen Menge vorhandener Ressourcen zum Thema Compiler ist.  Es ist eine autonome Quelle, die es Ihnen erm√∂glicht, die Grundlagen des Entwurfs und der Implementierung von Programmiersprachen zu verstehen. <br><br>  Die Zielgruppe des Artikels sind Personen, deren Vorstellung von der Arbeit der Compiler √§u√üerst begrenzt ist (das Maximum ist, dass sie am Kompilieren beteiligt sind).  Ich erwarte jedoch, dass der Leser Datenstrukturen und Algorithmen versteht. <br><br>  Der Artikel ist keineswegs modernen Produktions-Compilern mit Millionen von Codezeilen gewidmet - nein, dies ist ein kurzer Kurs ‚ÄûCompiler f√ºr Dummies‚Äú, der Ihnen hilft, zu verstehen, was ein Compiler ist. <br><a name="habracut"></a><br><h2>  Einf√ºhrung </h2><br>  Ich arbeite derzeit an der von Rust and Go inspirierten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Krug-</a> Systemsprache.  In dem Artikel werde ich Krug als Beispiel nennen, um meine Gedanken zu veranschaulichen.  Krug befindet sich in der Entwicklung, ist jedoch bereits unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/krug-lang</a> in den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Caasper-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Krug-</a> Repositories verf√ºgbar.  Die Sprache ist im Vergleich zur √ºblichen Compiler-Architektur nicht ganz typisch, was mich teilweise dazu inspiriert hat, einen Artikel zu schreiben - aber dazu sp√§ter mehr. <br><br>  Ich beeile mich, Ihnen mitzuteilen, dass ich in keiner Weise ein Spezialist f√ºr Compiler bin!  Ich habe keinen Doktortitel und keine formelle Ausbildung absolviert. In meiner Freizeit habe ich alles, was im Artikel beschrieben ist, selbst studiert.  Ich muss auch sagen, dass ich nicht den tats√§chlichen, nur richtigen Ansatz zum Erstellen eines Compilers beschreibe, sondern die grundlegenden Methoden vorstelle, die zum Erstellen eines kleinen "Spielzeug" -Compilers geeignet sind. <br><br><h2>  Frontend </h2><br>  Kehren wir zum obigen Diagramm zur√ºck: Die Pfeile links, die auf das Frontendfeld gerichtet sind, sind bekannte und beliebte Sprachen wie C. Das Frontend sieht ungef√§hr so ‚Äã‚Äãaus: lexikalische Analyse -&gt; Parser. <br><br><h2>  Lexikalische Analyse </h2><br>  Als ich anfing, Compiler und Sprachdesign zu studieren, wurde mir gesagt, dass lexikalische Analyse dasselbe ist wie Tokenisierung.  Wir werden diese Beschreibung verwenden.  Der Analysator nimmt Eingabedaten in Form von Zeichenfolgen oder einem Strom von Zeichen auf und erkennt darin Muster, die er in Token schneidet. <br><br>  Im Falle eines Compilers erh√§lt er am Eingang ein geschriebenes Programm.  Es wird aus einer Datei in eine Zeichenfolge eingelesen, und der Analysator markiert seinen Quellcode. <br><br><pre><code class="plaintext hljs">enum TokenType { Identifier, Number, }; struct Token { std::string Lexeme; TokenType type; // ... // It's also handy to store things in here // like the position of the token (start to end row:col) };</code> </pre> <br>  In diesem Fragment, das in einer C-f√∂rmigen Sprache geschrieben ist, sehen Sie die Struktur, die das oben genannte Lexem enth√§lt, sowie TokenType, das zur Erkennung dieses Tokens dient. <br><br>  Hinweis: Der Artikel ist keine Anleitung zum Erstellen einer Sprache mit Beispielen. Zum besseren Verst√§ndnis werde ich jedoch von Zeit zu Zeit Codefragmente einf√ºgen. <br><br>  Analysatoren sind normalerweise die einfachsten Compilerkomponenten.  Das gesamte Frontend ist im Vergleich zu den anderen Puzzleteilen recht einfach.  Obwohl es sehr von Ihrer Arbeit abh√§ngt. <br><br>  Nehmen Sie den folgenden C-Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello world!\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Nachdem Sie es aus einer Datei in eine Zeile gelesen und einen linearen Scan durchgef√ºhrt haben, k√∂nnen Sie m√∂glicherweise Token in Scheiben schneiden.  Wir identifizieren Token auf nat√ºrliche Weise - da int ein "Wort" und 0 in der return-Anweisung eine "Zahl" ist.  Der lexikalische Analysator f√ºhrt das gleiche Verfahren wie wir aus - sp√§ter werden wir diesen Prozess genauer untersuchen.  Analysieren Sie beispielsweise die Zahlen: <br><br><pre> <code class="plaintext hljs">0xdeadbeef ‚Äî HexNumber ( ) 1231234234 ‚Äî WholeNumber ( ) 3.1412 ‚Äî FloatingNumber (   ) 55.5555 ‚Äî FloatingNumber (   ) 0b0001 ‚Äî BinaryNumber ( )</code> </pre> <br>  Das Definieren von W√∂rtern kann schwierig sein.  Die meisten Sprachen definieren ein Wort als eine Folge von Buchstaben und Zahlen, und ein Bezeichner sollte normalerweise mit einem Buchstaben oder einem Unterstrich beginnen.  Zum Beispiel: <br><br><pre> <code class="plaintext hljs">123foobar := 3 person-age := 5 fmt.Println(123foobar)</code> </pre> <br>  In Go wird dieser Code nicht als korrekt angesehen und in die folgenden Token analysiert: <br><br><pre> <code class="plaintext hljs">Number(123), Identifier(foobar), Symbol(:=), Number(3) ...</code> </pre> <br>  Die meisten der gefundenen Bezeichner sehen folgenderma√üen aus: <br><br><pre> <code class="plaintext hljs">foo_bar __uint8_t fooBar123</code> </pre> <br>  Analysatoren m√ºssen andere Probleme l√∂sen, z. B. Leerzeichen, mehrzeilige und einzeilige Kommentare, Bezeichner, Zahlen, Zahlensysteme und Zahlenformatierung (z. B. 1_000_000) und Codierungen (z. B. Unterst√ºtzung f√ºr UTF8 anstelle von ASCII). <br><br>  Und wenn Sie denken, Sie k√∂nnen auf regul√§re Ausdr√ºcke zur√ºckgreifen - besser nicht wert.  Es ist viel einfacher, einen Analysator von Grund auf neu zu schreiben, aber ich empfehle dringend, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Artikel</a> von unserem K√∂nig und Gott Rob Pike zu lesen.  Die Gr√ºnde, warum Regex f√ºr uns nicht geeignet ist, sind in vielen anderen Artikeln beschrieben, daher werde ich diesen Punkt weglassen.  Dar√ºber hinaus ist das Schreiben eines Analysators viel interessanter, als sich mit langen, ausf√ºhrlichen Ausdr√ºcken zu qu√§len, die um 5:24 Uhr auf regex101.com hochgeladen wurden.  In meiner ersten Sprache habe ich die Funktion <code>split(str)</code> f√ºr die Tokenisierung verwendet - und bin nicht weit gegangen. <br><br><h2>  Parsen </h2><br>  Das Parsen ist etwas komplizierter als die lexikalische Analyse.  Es gibt viele Parser und Parser-Generatoren - hier beginnt das Spiel in gro√üem Stil. <br><br>  Parser in Compilern nehmen normalerweise Eingaben in Form von Token entgegen und erstellen einen bestimmten Baum - einen abstrakten Syntaxbaum oder einen Parsing-Baum.  Sie sind von Natur aus √§hnlich, weisen jedoch einige Unterschiede auf. <br><br>  Diese Stufen k√∂nnen als Funktionen dargestellt werden: <br><br><pre> <code class="plaintext hljs">fn lex(string input) []Token {...} fn parse(tokens []Token) AST {...} let input = "int main() { return 0; }"; let tokens = lex(input); let parse_tree = parse(tokens); // ....</code> </pre> <br>  In der Regel bestehen Compiler aus vielen kleinen Komponenten, die Eingaben √ºbernehmen, √§ndern oder in andere Ausgaben konvertieren.  Dies ist einer der Gr√ºnde, warum funktionale Sprachen gut zum Erstellen von Compilern geeignet sind.  Andere Gr√ºnde sind ausgezeichnetes Benchmarking und ziemlich umfangreiche Standardbibliotheken.  Unterhaltsame Tatsache: Die erste Implementierung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust-</a> Compilers war auf Ocaml. <br><br>  Ich rate Ihnen, diese Komponenten so einfach und autonom wie m√∂glich zu halten - Modularit√§t erleichtert den Prozess erheblich.  Meiner Meinung nach gilt das Gleiche f√ºr viele andere Aspekte der Softwareentwicklung. <br><br><h2>  B√§ume </h2><br><h4>  Parsing-Baum </h4><br>  Was zum Teufel ist das?  Dieser dicke Baum wird auch als Analysebaum bezeichnet und dient zur Visualisierung des Quellprogramms.  Sie enthalten alle Informationen (oder die meisten davon) √ºber das Eingabeprogramm, normalerweise die gleichen wie in der Grammatik Ihrer Sprache beschrieben.  Jeder Baumknoten ist nachlaufend oder nicht nachlaufend, z. B. NumberConstant oder StringConstant. <br><br><h4>  Abstrakter Syntaxbaum </h4><br>  Wie der Name schon sagt, ist die ASD ein <i>abstrakter</i> Syntaxbaum.  Der Analysebaum enth√§lt viele (h√§ufig redundante) Informationen zu Ihrem Programm. Bei einer ASD sind diese nicht erforderlich.  ASD ben√∂tigt keine nutzlosen Informationen √ºber die Struktur und Grammatik, was die Semantik des Programms nicht beeinflusst. <br><br>  Angenommen, Ihr Baum hat einen Ausdruck wie ((5 + 5) -3) +2.  Im Analysebaum w√ºrden Sie ihn zusammen mit Klammern, Operatoren und Werten 5, 5, 3 und 2 vollst√§ndig speichern. Sie k√∂nnen ihn jedoch einfach mit der ASD verkn√ºpfen - wir m√ºssen nur die Werte, Operatoren und deren Reihenfolge kennen. <br><br>  Das Bild unten zeigt den Baum f√ºr den Ausdruck a + b / c. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98c/61a/cb3/98c61acb355e7887b53b5c37de0aa34f.png" width="400"></div><br>  ASD kann wie folgt dargestellt werden: <br><br><pre> <code class="plaintext hljs">interface Expression { ... }; struct UnaryExpression { Expression value; char op; }; struct BinaryExpression { Expression lhand, rhand; string op; // string because the op could be more than 1 char. }; interface Node { ... }; // or for something like a variable struct Variable : Node { Token identifier; Expression value; };</code> </pre> <br>  Diese Ansicht ist ziemlich eingeschr√§nkt, aber ich hoffe, Sie k√∂nnen sehen, wie Ihre Knoten strukturiert werden.  Zum Parsen k√∂nnen Sie wie folgt vorgehen: <br><br><pre> <code class="plaintext hljs">Node parseNode() { Token current = consume(); switch (current.lexeme) { case "var": return parseVariableNode(); // ... } panic("unrecognized input!"); } Node n = parseNode(); if (n != null) { // append to some list of top level nodes? // or append to a block of nodes! }</code> </pre> <br>  Ich hoffe, dass Sie einen √úberblick dar√ºber erhalten, wie das schrittweise Parsen der verbleibenden Knoten ablaufen wird, beginnend mit Sprachkonstrukten auf hoher Ebene.  Wie genau ein Parser mit rekursiver Abstammung implementiert ist, m√ºssen Sie selbst studieren. <br><br><h2>  Grammatik </h2><br>  Das Parsen in einem ADS aus einer Reihe von Token kann schwierig sein.  Normalerweise sollten Sie mit der Grammatik Ihrer Sprache beginnen.  Im Wesentlichen bestimmt die Grammatik die Struktur Ihrer Sprache.  Es gibt mehrere Sprachen zum Definieren von Sprachen, die sich selbst beschreiben (oder analysieren) k√∂nnen. <br><br>  Ein Beispiel f√ºr eine Sprache zur Bestimmung von Sprachen ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erweiterte Form von Backus-Naur</a> (RBNF).  Es ist eine Variante von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BNF</a> mit weniger spitzen Klammern.  Hier ist ein RBNF-Beispiel aus einem Wikipedia-Artikel: <br><br><pre> <code class="plaintext hljs">digit excluding zero = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ; digit = "0" | digit excluding zero ;</code> </pre> <br>  Produktionsregeln sind definiert: Sie geben an, welche Terminalvorlage ‚Äûnicht terminal‚Äú ist.  Terminals sind Teil des Alphabets, z. B. sind das if-Token oder 0 und 1 im obigen Beispiel Terminals.  Nicht-Terminals sind das Gegenteil, sie befinden sich auf der linken Seite der Produktionsregeln und k√∂nnen als Variablen oder ‚Äûbenannte Zeiger‚Äú auf Gruppen von Terminals und Nicht-Terminals betrachtet werden. <br><br>  Viele Sprachen haben Spezifikationen, die Grammatik enthalten.  Zum Beispiel f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">D.</a> <br><br><h2>  Rekursive Abstiegsanalysatoren </h2><br>  Rekursiver Abstieg ist der einfachste von vielen Parsing-Ans√§tzen. <br><br>  Rekursive Abstiegsanalysatoren - absteigend, basierend auf rekursiven Verfahren.  Es ist viel einfacher, einen Parser zu schreiben, da Ihre Grammatik keine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rekursion hinterlassen hat</a> .  In den meisten "Spielzeug" -Sprachen reicht diese Technik zum Parsen aus.  GCC verwendet einen handgeschriebenen absteigenden Parser, obwohl YACC zuvor verwendet wurde. <br><br>  Das Parsen dieser Sprachen kann jedoch zu Problemen f√ºhren.  Insbesondere C, wo <br><br><pre> <code class="cpp hljs">foo * bar</code> </pre> <br>  kann interpretiert werden als <br><br><pre> <code class="plaintext hljs">int foo = 3; int bar = 4; foo * bar; // unused expression</code> </pre> <br>  oder wie <br><br><pre> <code class="plaintext hljs">typedef struct { int b; } foo; foo* bar; bar.b = 3;</code> </pre> <br>  Die Clang-Implementierung verwendet auch einen rekursiven Abstiegsanalysator: <br><br>  <i>Da dies regul√§rer C ++ - Code ist, erleichtert ein rekursiver Abstieg Anf√§ngern das Verst√§ndnis.</i>  <i>Es unterst√ºtzt benutzerdefinierte Regeln und andere seltsame Dinge, die C / C ++ erfordert, und hilft Ihnen, Fehler einfach zu diagnostizieren und zu beheben.</i> <br><br>  Es lohnt sich auch, auf andere Ans√§tze zu achten: <br><br><ul><li>  absteigender LL, rekursiver Abstieg </li><li>  aufsteigender LR, Verschiebung, aufsteigender Abstieg </li></ul><br><h2>  Parser-Generatoren </h2><br>  Ein weiterer guter Weg.  Nat√ºrlich gibt es auch Nachteile - aber dies kann √ºber jede andere Wahl gesagt werden, die Programmierer beim Erstellen von Software treffen. <br><br>  Parser-Generatoren arbeiten sehr z√ºgig.  Ihre Verwendung ist einfacher als das Schreiben eines eigenen Analysators und das Erhalten eines Qualit√§tsergebnisses - obwohl sie nicht sehr benutzerfreundlich sind und nicht immer Fehlermeldungen anzeigen.  Au√üerdem m√ºssen Sie lernen, wie Sie den Parser-Generator verwenden, und wenn Sie den Compiler hochstufen, m√ºssen Sie wahrscheinlich den Parser-Generator abwickeln. <br><br>  Ein Beispiel f√ºr einen Parser-Generator ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ANTLR</a> , es gibt viele andere. <br><br>  Ich denke, dieses Tool ist f√ºr diejenigen geeignet, die keine Zeit damit verbringen m√∂chten, ein Frontend zu schreiben, und die es vorziehen, die Mitte und das Backend des Compilers / Interpreters zu schreiben und irgendetwas zu analysieren. <br><br><h2>  Analyseanwendung </h2><br>  Wenn du dich immer noch nicht verstehst.  Sogar das Compiler-Frontend (lex / parse) kann verwendet werden, um andere Probleme zu l√∂sen: <br><br><ul><li>  Syntaxhervorhebung </li><li>  HTML / CSS-Analyse f√ºr die Rendering-Engine </li><li>  Transpiler: TypeScript, CoffeeScript </li><li>  Linker </li><li>  REGEX </li><li>  Schnittstellendatenanalyse </li><li>  URL-Analyse </li><li>  Formatierungswerkzeuge wie <i>gofmt</i> </li><li>  SQL-Analyse und mehr. </li></ul><br><h2>  Mitte </h2><br>  Semantische Analyse!  Die Analyse der Sprachsemantik ist eine der schwierigsten Aufgaben beim Erstellen eines Compilers. <br><br>  Sie m√ºssen sicherstellen, dass alle Eingabeprogramme ordnungsgem√§√ü funktionieren.  In meiner Krug-Sprache wurden Aspekte der semantischen Analyse noch nicht ber√ºcksichtigt, und ohne sie muss der Programmierer immer den richtigen Code schreiben.  In Wirklichkeit ist dies unm√∂glich - und wir schreiben, kompilieren, f√ºhren manchmal Fehler aus.  Diese Spirale ist endlos. <br><br>  Dar√ºber hinaus ist die Kompilierung von Programmen ohne eine Analyse der Richtigkeit der Semantik in der entsprechenden Phase der Kompilierung nicht m√∂glich. <br><br>  Ich bin einmal auf ein Diagramm √ºber den Prozentsatz von Frontend, Midland und Backend gesto√üen.  Dann sah es so aus <br><br><pre> <code class="plaintext hljs">F: 20% M: 20%: B: 60%</code> </pre> <br>  Heute ist es so etwas wie <br><br><pre> <code class="plaintext hljs">F: 5% M: 60% B: 35%</code> </pre> <br>  Das Frontend befasst sich haupts√§chlich mit dem Generator, und in kontextlosen Sprachen, die nicht die Dualit√§t der Grammatik haben, k√∂nnen sie recht schnell abgeschlossen werden - ein rekursiver Abstieg hilft hier. <br><br>  Mit der LLVM-Technologie kann der gr√∂√üte Teil der Optimierungsarbeit in das Framework hochgeladen werden, das eine Reihe vorgefertigter Optimierungen enth√§lt. <br><br>  Der n√§chste Schritt ist die semantische Analyse, ein wesentlicher Bestandteil der Kompilierungsphase. <br><br>  In Rust mit seinem Speicherverwaltungsmodell fungiert der Compiler beispielsweise als gro√üe, leistungsstarke Maschine, die verschiedene Arten der statischen Analyse von Einf√ºhrungsformularen durchf√ºhrt.  Ein Teil dieser Aufgabe besteht darin, die Eingabedaten in eine bequemere Form f√ºr die Analyse umzuwandeln. <br><br>  Aus diesem Grund spielt die semantische Analyse eine wichtige Rolle in der Architektur des Compilers, und anstrengende Vorbereitungsarbeiten wie die Optimierung der generierten Assembly oder das Lesen der Eingabedaten in der ASD werden f√ºr Sie durchgef√ºhrt. <br><br><h2>  Semantische Passagen </h2><br>  Im Verlauf der semantischen Analyse f√ºhren die meisten Compiler eine gro√üe Anzahl von "semantischen Durchl√§ufen" auf dem SDA oder einer anderen abstrakten Form des Code-Ausdrucks durch.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dieser Artikel</a> enth√§lt Details zu den meisten im .NET C # -Compiler durchgef√ºhrten Durchl√§ufen. <br><br>  Ich werde nicht jede Passage betrachten, zumal sie je nach Sprache variieren, aber einige Schritte werden unten in Krug beschrieben. <br><br><h2>  Top Level Ad </h2><br>  Der Compiler durchl√§uft alle "Top-Level" -Ank√ºndigungen in den Modulen und ist sich ihrer Existenz bewusst.  Er wird nicht tiefer in Bl√∂cke gehen - er wird einfach erkl√§ren, welche Strukturen, Funktionen usw.  sind in dem einen oder anderen Modul verf√ºgbar. <br><br><h2>  Namens- / Symbolaufl√∂sung </h2><br>  Der Compiler durchl√§uft alle Codebl√∂cke in Funktionen usw.  und l√∂st sie auf - das hei√üt, es werden Zeichen gefunden, f√ºr die eine Berechtigung erforderlich ist.  Dies ist ein h√§ufiger Durchgang, und von hier aus tritt beim Kompilieren von Go-Code normalerweise der Fehler " <i>Kein solches Symbol XYZ" auf</i> . <br><br>  Das Durchf√ºhren dieses Durchlaufs kann sehr schwierig sein, insbesondere wenn Ihr Abh√§ngigkeitsdiagramm zirkul√§re Abh√§ngigkeiten enth√§lt.  Einige Sprachen erlauben sie nicht, zum Beispiel, Go gibt einen Fehler aus, wenn eines Ihrer Pakete eine Schleife bildet, wie meine Krug-Sprache.  Zyklische Abh√§ngigkeiten k√∂nnen als Nebeneffekt einer schlechten Architektur angesehen werden. <br><br>  Schleifen k√∂nnen durch √Ñndern der DFS im Abh√§ngigkeitsdiagramm oder durch Verwenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">des Tarjan-Algorithmus</a> (wie von Krug ausgef√ºhrt) zum Definieren (mehrerer) Schleifen bestimmt werden. <br><br><h2>  Typ Inferenz </h2><br>  Der Compiler durchl√§uft alle Variablen und zeigt deren Typen an.  Die Typinferenz in Krug ist sehr schwach und gibt einfach Variablen basierend auf ihren Werten aus.  Es ist keineswegs ein bizarres System, wie man es in funktionalen Sprachen wie Haskell findet. <br><br>  Typen k√∂nnen mithilfe des Prozesses "Vereinheitlichung" oder "Vereinheitlichung von Typen" abgeleitet werden.  F√ºr einfachere Typsysteme kann eine sehr einfache Implementierung verwendet werden. <br><br>  Typen werden in Krug folgenderma√üen implementiert: <br><br><pre> <code class="plaintext hljs">interface Type {}; struct IntegerType : Type { int width; bool signed; }; struct FloatingType : Type { int width; }; struct ArrayType : Type { Type base_type; uint64 length; };</code> </pre> <br>  Sie k√∂nnen auch eine einfache Typinferenz verwenden, bei der Sie Ausdrucksknoten einen Typ zuweisen. Beispielsweise kann <code>IntegerConstantNode</code> vom Typ IntegerType (64) sein.  Und dann erhalten Sie m√∂glicherweise die Funktion <code>unify(t1, t2)</code> , mit der der breiteste Typ ausgew√§hlt wird, mit dem der Typ komplexerer Ausdr√ºcke abgeleitet werden kann, z. B. bin√§re.  Es geht also darum, den Werten der angegebenen Typen rechts eine Variable auf der linken Seite zuzuweisen. <br><br>  Ich habe einmal eine einfache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Besetzung</a> von Go geschrieben, die zu einem Prototyp f√ºr Krug wurde. <br><br><h2>  Mutability Pass </h2><br>  Krug (wie Rust) ist standardm√§√üig eine unver√§nderliche Sprache, dh Variablen bleiben unver√§ndert, sofern nicht anders angegeben: <br><br><pre> <code class="plaintext hljs">let x = 3; x = 4; // BAD! mut y = 5; y = 6; // OK!</code> </pre> <br>  Der Compiler durchl√§uft alle Bl√∂cke und Funktionen und pr√ºft, ob ihre ‚ÄûVariablen korrekt‚Äú sind, dh wir √§ndern nicht, was nicht folgt, und dass alle an bestimmte Funktionen √ºbergebenen Variablen bei Bedarf konstant oder √§nderbar sind. <br><br>  Dies geschieht mit Hilfe symbolischer Informationen, die in fr√ºheren Durchg√§ngen gesammelt wurden.  Eine Symboltabelle, die auf den Ergebnissen des semantischen Durchlaufs basiert, enth√§lt Token-Namen und Zeichen variabler Variabilit√§t.  Es kann andere Daten enthalten, z. B. in C ++ kann eine Tabelle Informationen dar√ºber speichern, ob ein Symbol extern oder statisch ist. <br><br><h2>  Zeichentabellen </h2><br>  Eine Zeichentabelle oder ‚ÄûStich‚Äú ist eine Tabelle zum Auffinden der Zeichen, die in Ihrem Programm verwendet werden.  F√ºr jeden Bereich wird eine Tabelle erstellt, die alle Informationen zu den in einem bestimmten Bereich vorhandenen Zeichen enth√§lt. <br><br>  Diese Informationen umfassen Eigenschaften wie den Symbolnamen, den Typ, das Zeichen der Ver√§nderlichkeit, das Vorhandensein externer Kommunikation, den Speicherort im statischen Speicher usw. <br><br><h3>  Geltungsbereich </h3><br>  Dies ist ein wichtiges Konzept in Programmiersprachen.  Nat√ºrlich muss Ihre Sprache es nicht erm√∂glichen, verschachtelte Bereiche zu erstellen, alles kann in einem gemeinsamen Namespace platziert werden! <br><br>  Obwohl die Darstellung des Bereichs eine interessante Aufgabe f√ºr die Compilerarchitektur ist, verh√§lt sich der Bereich in den meisten C-√§hnlichen Sprachen wie eine Stapeldatenstruktur (oder ist dies auch). <br><br>  Normalerweise erstellen und zerst√∂ren wir Bereiche, und sie werden normalerweise zum Verwalten von Namen verwendet, dh sie erm√∂glichen es uns, Variablen zu verbergen (zu beschatten): <br><br><pre> <code class="plaintext hljs">{ // push scope let x = 3; { // push scope let x = 4; // OK! } // pop scope } // pop scope</code> </pre> <br>  Es kann anders dargestellt werden: <br><br><pre> <code class="plaintext hljs">struct Scope { Scope* outer; SymbolTable symbols; }</code> </pre> <br>  Ein kleines offtopic, aber ich empfehle, √ºber den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spaghetti-Stapel zu</a> lesen.  Dies ist eine Datenstruktur, die zum Speichern von Sichtbarkeitsbereichen in den ASD-Knoten gegen√ºberliegender Bl√∂cke verwendet wird. <br><br><h2>  Typ Systeme </h2><br>  Viele der folgenden Abschnitte k√∂nnen zu separaten Artikeln entwickelt werden, aber es scheint mir, dass dieser Titel dies am meisten verdient.  Heutzutage sind viele Informationen √ºber Typsysteme sowie Sorten der Systeme selbst verf√ºgbar, um die herum viele Kopien brechen.  Ich werde mich nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eingehend</a> mit diesem Thema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">befassen, sondern</a> nur einen Link zu dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausgezeichneten Artikel von Steve Klabnik hinterlassen</a> . <br><br>  Ein Typsystem wird im Compiler mithilfe von Compiler-Darstellungen und der Analyse dieser Darstellungen bereitgestellt und semantisch definiert. <br><br><h2>  Besitz </h2><br>  Dieses Konzept wird in der Programmierung immer h√§ufiger verwendet.  Die Prinzipien der Semantik von Eigentum und Bewegung sind in die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust-</a> Sprache eingebettet, und ich hoffe, dass sie in anderen Sprachen erscheinen.  Rust f√ºhrt viele verschiedene Arten der statischen Analyse durch, um zu √ºberpr√ºfen, ob die Eingabe eine Reihe von Regeln bez√ºglich des Speichers erf√ºllt: Wem geh√∂rt welcher Speicher, wann wird der Speicher zerst√∂rt und wie viele Verweise (oder Ausleihen) auf diese Werte oder Speicher vorhanden sind. <br><br>  Das Sch√∂ne an Rust liegt in der Tatsache, dass dies alles w√§hrend der Kompilierung im Compiler erfolgt, sodass sich der Programmierer nicht mit der Speicherbereinigung oder der Linkz√§hlung befassen muss.  Alle diese Semantiken sind dem Typsystem zugeordnet und k√∂nnen bereitgestellt werden, noch bevor das Programm in Form einer vollst√§ndigen Bin√§rdatei pr√§sentiert wird. <br><br>  Ich kann nicht sagen, wie das alles unter der Haube funktioniert, aber all dies ist das Ergebnis statischer Analysen und wunderbarer Forschungen des Mozilla-Teams und der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cyclone-</a> Projektteilnehmer. <br><br><h2>  Kontrollflussdiagramme </h2><br>  Zur Darstellung von Programmabl√§ufen verwenden wir Kontrollflussdiagramme (CFGs), die alle Pfade enthalten, denen die Programmausf√ºhrung folgen kann.  Dies wird in der semantischen Analyse verwendet, um inaktive Codeabschnitte auszuschlie√üen, dh Bl√∂cke, Funktionen und sogar Module, die w√§hrend der Programmausf√ºhrung niemals erreicht werden.  Diagramme k√∂nnen auch verwendet werden, um Zyklen zu identifizieren, die nicht unterbrochen werden k√∂nnen.  Oder um nach unzug√§nglichem Code zu suchen, wenn Sie beispielsweise eine ‚ÄûPanik‚Äú (Panik) aufrufen oder in einer Schleife zur√ºckkehren und der Code au√üerhalb der Schleife nicht ausgef√ºhrt wird.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Datenflussanalyse</a> spielt in der semantischen Phase des Compilers eine wichtige Rolle. Ich empfehle daher, zu lesen, welche Analysetypen Sie ausf√ºhren k√∂nnen, wie sie funktionieren und welche Optimierungen m√∂glich sind. <br><br><h2>  Backend </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/330/914/1b9/3309141b9d53be1d9e5c8f77fb46d982.jpg"><br>  <i>Der letzte Teil unseres Architekturschemas.</i> <br><br>  Wir haben den gr√∂√üten Teil der Arbeit zum Generieren ausf√ºhrbarer Bin√§rdateien geleistet.  Dies kann auf verschiedene Arten geschehen, die wir unten diskutieren werden. <br><br>        - ,   . ,     ,    ¬´¬ª. <br><br><h2>     </h2><br>   ,           . ,    ,      .   ,   ,         ,    .        ,      . <br><br>   ,           .  ,   ++ ‚Äî Cfront ‚Äî     C. <br><br>    JavaScript.     TypeScript    ,     ,   ,              ,         . <br><br>    ¬´¬ª ,     ,             ,       ,    ¬´  ¬ª  .        ‚Äî   ,        ,     . <br><br><h2> LLVM </h2><br>          LLVM: Rust, Swift, C/C++ (clang), D, Haskell. <br><br>    ¬´ ¬ª,             ,      .     , LLVM      .   ,       .  ,   ,     , , 1, 4, 8  16-.       ,  ,   -    . <br><br><h2>  - </h2><br>      ‚Äî     , ‚Äî     ,      . <br><br> Go ‚Äî    ,      LLVM (    ). Go     ,    Windows, Linux  MacOS. ,    Krug    -. <br><br>        .  ,     LLVM,     ,   ,        LLVM      ,     . <br><br>   ,        ,       ,        LLVM,      IR,    ,  , ,    (    ). <br><br>     .      ,         ,   ,       .       IR (    )  ¬´¬ª       fprintf   .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8cc</a> . <br><br><h2>   </h2><br>             .   ‚Äî Java:  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JVM</a>        , , Kotlin. <br><br>     ,   Java   .         ,           .            ,       . <br>   , JVM   JIT       ,     JIT-,     . <br><br><h2>  </h2><br>     ,      !      ,     ,   .   -          ,   ,   . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Godbolt</a> ‚Äî  ,  ,             .       , ,     . <br><br>      ,         ,       (strip the debug symbols),  ,   GCC.     ,  -  . <br><br>            .       .    ,         .        production-. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>        rwmj ,    8  ,   80%     .        1971-!    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  ,  Rust. <br><br><h2>  IR </h2><br>   (intermediate representation, IR)  ,  .      ,        ,     . <br><br>   IR     .      ,  ,    ,    . <br><br>    IR,  ¬´¬ª,       IR   . , SSA ‚Äî Static Single Assignment,   ,        . <br><br>  Go     IR   SSA. IR  LLVM   SSA,    . <br><br>  SSA   ,  ,   (constant propagation),     ( )  . <br><br><h2>   </h2><br>      ,  .  ,    ,   ,      ,    .         (  16  32),     ,      (spill to the stack). <br><br>   ‚Äî             (   ).     ,     ,          . <br><br>     : <br><br><ul><li>   (graph colouring) ‚Äî   (NP- ).      ,     (liveness ranges) . <br></li><li>   ‚Äî       . <br></li></ul><br><h2>     </h2><br>     . ,       .   ,       ,         . <br><br><h2>   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Name Mangling</a> ) </h2><br>    -,            ,        .         ,   . <br><br><pre> <code class="plaintext hljs">fn main() int { let x = 0; { let x = 0; { let x = 0; } } return 0; }</code> </pre> <br> ,    (  -    :) )      ,      .        ,        . <br><br><h2>   </h2><br>   LLDB     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DWARF</a> .     LLVM   ,   DWARF         GNU-. ,     ,     ,   . <br><br><h2>    (Foreign Function Interface, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FFI</a> ) </h2><br>   libc   ,        ,      .       ,        ? <br><br><h2>  </h2><br>   ‚Äî  .     ,      (  .s/.asm)?       ? ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jai</a>        .   ,     . <br><br><h2>    (CaaS) </h2><br>         API-.  ,       Krug-,         .  ,     ,      . <br><br> ,     , ,      .         ,     API-. <br><br>   production-   CaaS.    Microsofts Roslyn,       ,     .    , , ,      ,     API-,     , ,  Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RLS</a> . <br><br>    Krug ‚Äî        ‚Äî   Caasper  CaaS-. <br><br> Caasper      (,  ,  ),      , krug,    .   ,        ,      (bootstrap)   ,     . <br><br>   Krug   JavaScript,       Go*,  , ,   Krug. JavaScript     ,         yarn/npm. <br><br> <i>*      Go   ()  ,    JS.</i> <br><br>    Caasper  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> Github   Krug,    D    LLVM.       YouTube- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br><br>   Krug ()  <a href=""></a> . <br><br><h2>  N√ºtzliche Links </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jack Crenshaw</a> ‚Äî        . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Crafting Interpreters</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  LLVM ( Go)</a> ‚Äî ! <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PL/0</a> <br></li><li> The Dragon Book ‚Äî  ,    . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8cc</a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451894/">https://habr.com/ru/post/de451894/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451878/index.html">Live-Streaming von Stereovideos auf VR-Brillen (Oculus Go)</a></li>
<li><a href="../de451880/index.html">DevPRO'19: Blick vom Wrike-Stand</a></li>
<li><a href="../de451884/index.html">Sieben Jahre als Entwickler gearbeitet: Welche Lektionen habe ich gelernt?</a></li>
<li><a href="../de451886/index.html">Verwenden diskreter Mathematik beim Testen</a></li>
<li><a href="../de451890/index.html">Delegierung einer Reverse-Subnetzzone von weniger als / 24 in BIND. Wie funktioniert es?</a></li>
<li><a href="../de451896/index.html">Eine "unzerbrechliche" eyeDisk ist durch einen Iris-Scan gesch√ºtzt, √ºbertr√§gt jedoch ein Passwort im Klartext</a></li>
<li><a href="../de451898/index.html">Innovation auf Russisch</a></li>
<li><a href="../de451900/index.html">Erster Beitrag zur Browser-API von Facebook</a></li>
<li><a href="../de451902/index.html">Microsoft Azure Developer Camp Russland</a></li>
<li><a href="../de451904/index.html">Manchmal ist mehr weniger. Wenn eine Abnahme der Last zu einer Zunahme der Verz√∂gerung f√ºhrt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>