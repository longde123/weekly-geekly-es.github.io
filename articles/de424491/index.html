<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍉 🥌 💣 Unity Hexagon Maps: Rauheiten, Flüsse und Straßen 👨🏿‍🔧 👩‍👩‍👦‍👦 💘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teile 1-3: Netz, Farben und Zellenhöhen 

 Teile 4-7: Unebenheiten, Flüsse und Straßen 

 Teile 8-11: Wasser, Landformen und Wälle 

 Teile 12-15: Spe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity Hexagon Maps: Rauheiten, Flüsse und Straßen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424491/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/b6b/8a9/716b6b8a9d024dc87b2d645b5d4bdbb6.jpg" alt="Bild"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 1-3: Netz, Farben und Zellenhöhen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 4-7: Unebenheiten, Flüsse und Straßen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 8-11: Wasser, Landformen und Wälle</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 12-15: Speichern und Laden, Texturen, Entfernungen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 16-19: Weg finden, Spielerkader, Animationen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 20-23: Nebel des Krieges, Kartenforschung, Verfahrensgenerierung</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 24-27: Wasserkreislauf, Erosion, Biomes, zylindrische Karte</a> <br><br><h1>  Teil 4: Rauheiten </h1><br><h2>  Inhaltsverzeichnis </h2><br><ul><li>  Probieren Sie die Rauschstruktur aus. </li><li>  Verschieben Sie die Eckpunkte. </li><li>  Wir bewahren die Flachheit der Zellen. </li><li>  Unterteilen Sie die Kanten der Zellen. </li></ul><br>  Während unser Gitter ein strenges Muster von Waben war.  In diesem Teil werden wir Unebenheiten hinzufügen, damit die Karte natürlicher aussieht. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e33/034/982/e33034982aafb942e1e656b76dde0981.png"></div><br>  <i>Keine gleichmäßigen Sechsecke mehr.</i> <br><br><h2>  Der Lärm </h2><br>  Um Unebenheiten hinzuzufügen, benötigen wir eine Randomisierung, aber keine echte Zufälligkeit.  Wir möchten, dass beim Ändern der Karte alles konsistent ist.  Andernfalls springen die Objekte, wenn Sie Änderungen vornehmen.  Das heißt, wir brauchen irgendeine Form von reproduzierbarem Pseudozufallsrauschen. <br><br>  Ein guter Kandidat ist Perlins Lärm.  Es ist überall reproduzierbar.  Wenn mehrere Frequenzen kombiniert werden, entsteht auch ein Rauschen, das über große Entfernungen stark variieren kann, auf kurzen Entfernungen jedoch nahezu gleich bleibt.  Dadurch können relativ glatte Verzerrungen erzeugt werden.  Aneinander benachbarte Punkte bleiben normalerweise in der Nähe und sind nicht in entgegengesetzte Richtungen verstreut. <br><br>  Wir können Perlin-Rauschen programmgesteuert erzeugen.  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Noise-</a> Tutorial erkläre ich, wie das geht.  Wir können aber auch von einer vorgenerierten Rauschtextur abtasten.  Der Vorteil der Verwendung von Texturen besteht darin, dass sie einfacher und schneller sind als die Berechnung des Mehrfrequenzrauschens von Perlin.  Der Nachteil ist, dass die Textur mehr Speicherplatz beansprucht und nur einen kleinen Rauschbereich abdeckt.  Daher sollte es nahtlos verbunden und groß genug sein, damit die Wiederholung nicht auffällt. <br><br><h3>  Rauschstruktur </h3><br>  Wir werden die Textur verwenden, daher ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Noise-</a> Tutorial optional.  Wir brauchen also eine Textur.  Da ist sie: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbd/8e8/5d7/fbd8e85d783626c737decd6bc69a2519.png"></div><br>  <i>Perlin Noise Textur nahtlos verbinden.</i> <br><br>  Die oben gezeigte Textur enthält Perlins nahtlos gekoppeltes Mehrfrequenzrauschen.  Dies ist ein Graustufenbild.  Sein Durchschnittswert beträgt 0,5 und die Extremwerte tendieren zu 0 und 1. <br><br>  Aber warten Sie, es gibt nur einen Wert für jeden Punkt.  Wenn wir eine 3D-Verzerrung benötigen, benötigen wir mindestens drei Pseudozufallsstichproben!  Daher benötigen wir zwei weitere Texturen mit unterschiedlichem Rauschen. <br><br>  Wir können sie erstellen oder unterschiedliche Rauschwerte in jedem der Farbkanäle speichern.  Auf diese Weise können wir bis zu vier Rauschmuster in einer Textur speichern.  Hier ist diese Textur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1d/509/aca/a1d509acaf05d64de002829afc59cb90.png"></div><br>  <i>Vier in einem.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Wie erstelle ich eine solche Textur?</b> <div class="spoiler_text">  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NumberFlow verwendet</a> .  Dies ist der prozedurale Textureditor, den ich für Unity erstellt habe. </div></div><br>  Laden Sie diese Textur herunter und importieren Sie sie in Ihr Unity-Projekt.  Da wir die Textur durch Code abtasten werden, sollte sie lesbar sein.  Schalten Sie den <em>Texturtyp</em> auf <em>Erweitert</em> und aktivieren Sie <em>Lesen / Schreiben aktiviert</em> .  Dadurch werden die Texturdaten im Speicher gespeichert und können über C # -Code aufgerufen werden.  Stellen Sie <em>Format</em> auf <em>Automatic Truecolor ein</em> , sonst funktioniert nichts.  Wir möchten nicht, dass die Texturkomprimierung unser Rauschmuster zerstört. <br><br>  Sie können <em>Mip Maps generieren</em> deaktivieren, da wir sie nicht benötigen.  Aktivieren Sie auch <em>Bypass sRGB Sampling</em> .  Wir werden das nicht brauchen, aber es wird so sein.  Dieser Parameter gibt an, dass die Textur keine Farbdaten im Gammaraum enthält. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3aa/c36/e45/3aac36e45d7ead64823dc57b55afe67e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5fe/6c8/99a/5fe6c899a966eecb34046d5c243036b7.png"></div><br>  Importierte Rauschtextur. <br><br><div class="spoiler">  <b class="spoiler_title">Wann ist sRGB-Sampling wichtig?</b> <div class="spoiler_text">  Wenn wir eine Textur in einem Shader verwenden möchten, würde dies einen Unterschied machen.  Wenn Sie den linearen Rendering-Modus verwenden, konvertiert das Abtasten der Textur automatisch die Farbdaten aus dem Farbumfang in einen linearen Farbraum.  Im Fall unserer Rauschstruktur führt dies zu falschen Ergebnissen, sodass wir dies nicht benötigen. </div></div><br><div class="spoiler">  <b class="spoiler_title">Warum sehen meine Einstellungen für den Texturimport anders aus?</b> <div class="spoiler_text">  Sie wurden geändert, nachdem dieses Tutorial geschrieben wurde.  Sie müssen die Standard-2D-Textureinstellungen verwenden, <em>sRGB (Color Texture)</em> sollte deaktiviert und <em>Compression</em> auf <em>None gesetzt sein</em> . </div></div><br><h3>  Rauschabtastung </h3><br>  <code>HexMetrics</code> wir <code>HexMetrics</code> Rauschabtastfunktionen <code>HexMetrics</code> damit Sie es überall verwenden können.  Dies bedeutet, dass <code>HexMetrics</code> einen Verweis auf die Rauschtextur enthalten muss. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Texture2D noiseSource;</code> </pre> <br>  Da dies keine Komponente ist, können wir ihr über den Editor keine Textur zuweisen.  Daher verwenden wir als Vermittler <code>HexGrid</code> .  Da <code>HexGrid</code> zuerst wirkt, ist es in Ordnung, wenn wir die Textur zu Beginn der <code>Awake</code> Methode übergeben. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Texture2D noiseSource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; … }</code> </pre> <br>  Dieser Ansatz überlebt jedoch die Neukompilierung im Wiedergabemodus nicht.  Statische Variablen werden von der Unity-Engine nicht serialisiert.  Um dieses Problem zu lösen, <code>OnEnable</code> die Textur auch in der <code>OnEnable</code> Ereignismethode neu zu.  Diese Methode wird nach der Neukompilierung aufgerufen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d87/4fd/3a5/d874fd3a57faad4e57e5af830b202a19.png"></div><br>  <i>Weisen Sie eine Rauschstruktur zu.</i> <br><br>  <code>HexMetrics</code> nun Zugriff auf die Textur hat, fügen wir eine praktische Rauschabtastmethode hinzu.  Diese Methode nimmt eine Position in der Welt ein und erzeugt einen 4D-Vektor, der vier Rauschproben enthält. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Proben wurden durch Abtasten der Textur unter Verwendung einer bilinearen Filterung erstellt, bei der die Koordinaten der Welt X und Z als UV-Koordinaten verwendet wurden. Da unsere Rauschquelle zweidimensional ist, ignorieren wir die dritte Koordinate der Welt.  Wenn die Rauschquelle dreidimensional wäre, würden wir auch die Y-Koordinate verwenden. <br><br>  Als Ergebnis erhalten wir eine Farbe, die in einen 4D-Vektor konvertiert werden kann.  Eine solche Reduzierung kann indirekt sein, <code>(Vector4)</code> wir können die Farbe direkt zurückgeben, ohne explizit <code>(Vector4)</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> noiseSource.GetPixelBilinear(position.x, position.z); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Wie funktioniert die bilineare Filterung?</b> <div class="spoiler_text">  Eine Erklärung der UV-Koordinaten und der Texturfilterung finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendering 2-</a> Tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, Shader Fundamentals</a> . </div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Scheitelpunktbewegung </h2><br>  Wir werden unser glattes Gitter aus Waben verzerren und jeden der Eckpunkte einzeln bewegen.  <code>HexMesh</code> Sie dazu die <code>HexMesh</code> Methode zu <code>Perturb</code> .  Es nimmt einen unbeweglichen Punkt und gibt den bewegten zurück.  Zu diesem Zweck verwendet er beim Abtasten von Rauschen einen nicht verschobenen Punkt. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); }</code> </pre> <br>  Fügen wir einfach die Rauschabtastwerte X, Y und Z direkt zu den entsprechenden Punktkoordinaten hinzu und verwenden Sie diese als Ergebnis. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += sample.x; position.y += sample.y; position.z += sample.z; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br>  Wie können wir <code>HexMesh</code> schnell ändern, um alle Scheitelpunkte zu verschieben?  <code>AddTriangle</code> Ändern jedes Scheitelpunkts beim Hinzufügen von Scheitelpunkten zur Liste in den <code>AddQuad</code> <code>AddTriangle</code> und <code>AddQuad</code> .  Lass es uns tun. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(Perturb(v1)); vertices.Add(Perturb(v2)); vertices.Add(Perturb(v3)); … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(Perturb(v1)); vertices.Add(Perturb(v2)); vertices.Add(Perturb(v3)); vertices.Add(Perturb(v4)); … }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Bleiben Vierecke nach dem Verschieben ihrer Eckpunkte flach?</b> <div class="spoiler_text">  Höchstwahrscheinlich nicht.  Sie bestehen aus zwei Dreiecken, die nicht mehr in derselben Ebene liegen.  Da diese Dreiecke jedoch zwei gemeinsame Scheitelpunkte haben, werden die Normalen dieser Scheitelpunkte geglättet.  Dies bedeutet, dass wir keine scharfen Übergänge zwischen zwei Dreiecken haben werden.  Wenn die Verzerrung nicht zu groß ist, werden wir die Vierecke immer noch als flach wahrnehmen. </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/589/55c/47d/58955c47d221104096d943df9f9b948c.png"></div><br>  <i>Die Eckpunkte werden entweder verschoben oder nicht.</i> <br><br>  Während die Änderungen nicht sehr auffällig sind, sind nur die Zellbezeichnungen verschwunden.  Dies geschah, weil wir den Punkten Rauschproben hinzugefügt haben, die immer positiv sind.  Infolgedessen stiegen alle Dreiecke über ihre Markierungen und schlossen sie.  Wir müssen die Änderungen so zentrieren, dass sie in beide Richtungen auftreten.  Ändern Sie das Intervall der Rauschprobe von 0–1 auf –1–1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>; position.y += sample.y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>; position.z += sample.z * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f0/bd6/83a/1f0bd683ad92592fa6c5df171eab646c.png"></div><br>  <i>Zentrierte Verschiebung.</i> <br><br><h3>  Die Größe (Kraft) der Verschiebung </h3><br>  Jetzt ist es offensichtlich, dass wir das Raster verzerrt haben, aber der Effekt ist kaum spürbar.  Die Änderung in jeder Dimension beträgt nicht mehr als 1 Einheit.  Das heißt, die theoretische maximale Verschiebung beträgt √3 ≈ 1,73 Einheiten, was, wenn überhaupt, äußerst selten vorkommt.  Da der Außenradius der Zellen 10 Einheiten beträgt, sind die Verschiebungen relativ klein. <br><br>  Die Lösung besteht darin, <code>HexMetrics</code> einen <code>HexMetrics</code> damit Sie die Bewegungen skalieren können.  Versuchen wir, Kraft 5 anzuwenden. In diesem Fall beträgt die theoretische maximale Verschiebung √75 ≈ 8,66 Einheiten, was viel deutlicher ist. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">5f</span></span>;</code> </pre> <br>  Wir wenden Kraft an, indem wir sie mit Stichproben in <code>HexMesh.Perturb</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += (sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; position.y += (sample.y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; position.z += (sample.z * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa8/2ef/fc0/fa82effc05a418729e81ee54f0922f26.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b19/fc8/3f0/b19fc83f0828160b2100a346083f1047.png"></div><br>  <i>Erhöhte Kraft.</i> <br><br><h3>  Geräuschskala </h3><br>  Obwohl das Raster vor der Änderung gut aussieht, kann nach dem Erscheinen der Leisten alles schief gehen.  Ihre Spitzen können in unvorhersehbar unterschiedliche Richtungen verzerrt sein, was zu Chaos führt.  Bei Verwendung von Perlin-Rauschen sollte dies nicht passieren. <br><br>  Das Problem entsteht, weil wir die Koordinaten der Welt direkt verwenden, um das Rauschen abzutasten.  Aus diesem Grund ist die Textur in jeder Einheit verborgen und die Zellen sind viel größer als dieser Wert.  Tatsächlich wird die Textur an beliebigen Punkten abgetastet, wodurch ihre vorhandene Integrität zerstört wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3f/bd1/717/f3fbd1717515fdf4e500e9674d82a08f.png"></div><br>  <i>Zeilen mit einem Raster von 10 x 10 überlappen Zellen.</i> <br><br>  Wir müssen die Rauschabtastung so skalieren, dass die Textur einen viel größeren Bereich abdeckt.  <code>HexMetrics</code> wir diese Skala zu <code>HexMetrics</code> weisen ihr einen Wert von 0,003 zu und skalieren dann die Koordinaten der Stichproben um diesen Faktor. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> noiseScale = <span class="hljs-number"><span class="hljs-number">0.003f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); }</code> </pre> <br>  Es stellt sich plötzlich heraus, dass unsere Textur 333 &amp; frac13;  quadratische Einheiten, und seine lokale Integrität wird offensichtlich. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9de/219/e7a/9de219e7ae0495bcc9dfc2eca4ce52d6.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53c/0fc/e14/53c0fce142f96daecfd5001ac45e2222.png"></div><br>  <i>Skaliertes Rauschen.</i> <br><br>  Zusätzlich vergrößert eine neue Skala den Abstand zwischen den Geräuschfugen.  Da die Zellen einen Innendurchmesser von 10 √ 3 Einheiten haben, werden sie in der X-Dimension niemals exakt gekachelt. Aufgrund der lokalen Integrität des Rauschens können wir jedoch in größerem Maßstab immer noch sich wiederholende Muster erkennen, etwa alle 20 Zellen. auch wenn die Details nicht übereinstimmen.  Sie sind jedoch nur auf der Karte ohne andere charakteristische Merkmale erkennbar. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Zellzentren ausrichten </h2><br>  Wenn Sie alle Scheitelpunkte verschieben, sieht die Karte natürlicher aus, es gibt jedoch mehrere Probleme.  Da die Zellen jetzt gezackt sind, schneiden sich ihre Beschriftungen mit dem Netz.  Und in den Fugen der Felsvorsprünge mit Klippen entstehen Risse.  Wir werden die Risse für später verlassen, aber jetzt werden wir uns auf die Oberflächen der Zellen konzentrieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/320/626/85f/32062685fe221819ba4d9375175f66ee.png"></div><br>  <i>Die Karte wurde weniger streng, aber es traten mehr Probleme auf.</i> <br><br>  Der einfachste Weg, das Schnittpunktproblem zu lösen, besteht darin, die Zentren der Zellen flach zu machen.  Lassen Sie uns die Y-Koordinate in <code>HexMesh.Perturb</code> einfach nicht ändern. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += (sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; <span class="hljs-comment"><span class="hljs-comment">// position.y += (sample.y * 2f - 1f) * HexMetrics.cellPerturbStrength; position.z += (sample.z * 2f - 1f) * HexMetrics.cellPerturbStrength; return position; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfb/6f6/38e/bfb6f638e8cdb45d6178d1f18cdb723b.png"></div><br>  <i>Ausgerichtete Zellen.</i> <br><br>  Mit dieser Änderung bleiben alle vertikalen Positionen unverändert, sowohl in der Mitte der Zellen als auch an den Stufen der Leisten.  Es ist zu beachten, dass dies die maximale Verschiebung nur in der XZ-Ebene auf √50 ≈ 7.07 reduziert. <br><br>  Dies ist eine gute Änderung, da dadurch die Identifizierung einzelner Zellen vereinfacht wird und die Leisten nicht zu chaotisch werden.  Aber es wäre trotzdem schön, eine kleine vertikale Bewegung hinzuzufügen. <br><br><h3>  Zellenhöhe verschieben </h3><br>  Anstatt auf jeden Scheitelpunkt eine vertikale Bewegung anzuwenden, können wir sie auf eine Zelle anwenden.  In diesem Fall bleibt jede Zelle flach, aber die Variabilität zwischen den Zellen bleibt bestehen.  Es wäre auch logisch, eine andere Skala zu verwenden, um die Höhe zu <code>HexMetrics</code> . <code>HexMetrics</code> Sie sie daher zu <code>HexMetrics</code> .  Eine Kraft von 1,5 Einheiten erzeugt eine geringfügige Abweichung, die ungefähr der Höhe einer Stufe der Kante entspricht. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> elevationPerturbStrength = <span class="hljs-number"><span class="hljs-number">1.5f</span></span>;</code> </pre> <br>  Ändern Sie die <code>HexCell.Elevation</code> Eigenschaft so, dass diese Verschiebung auf die vertikale Position der Zelle <code>HexCell.Elevation</code> wird. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Vector3 position = transform.localPosition; position.y = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * HexMetrics.elevationStep; position.y += (HexMetrics.SampleNoise(position).y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.elevationPerturbStrength; transform.localPosition = position; Vector3 uiPosition = uiRect.localPosition; uiPosition.z = -position.y; uiRect.localPosition = uiPosition; } }</code> </pre> <br>  Damit die Verschiebung sofort angewendet werden kann, müssen Sie die Höhe jeder Zelle in <code>HexGrid.CreateCell</code> explizit <code>HexGrid.CreateCell</code> .  Andernfalls ist das Raster zunächst flach.  Lassen Sie es uns am Ende tun, nachdem Sie die Benutzeroberfläche erstellt haben. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … cell.Elevation = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4f/dd7/15c/d4fdd715c130c8cd8b2519ff37c837de.png"></div><br>  <i>Verschobene Höhen mit Rissen.</i> <br><br><h3>  Mit den gleichen Höhen </h3><br>  Im Netz sind viele Risse aufgetreten, da wir beim Triangulieren des Netzes nicht die gleichen Zellenhöhen verwenden.  <code>HexCell</code> wir <code>HexCell</code> eine Eigenschaft <code>HexCell</code> , um ihre Position zu ermitteln, sodass Sie sie überall verwenden können. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> transform.localPosition; } }</code> </pre> <br>  Jetzt können wir diese Eigenschaft in <code>HexMesh.Triangulate</code> , um die Mitte der Zelle zu bestimmen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; … }</code> </pre> <br>  Und wir können es in <code>TriangulateConnection</code> wenn wir die vertikalen Positionen benachbarter Zellen definieren. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { … Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; v3.y = v4.y = neighbor.Position.y; … HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 v5 = v2 + HexMetrics.GetBridge(direction.Next()); v5.y = nextNeighbor.Position.y; … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69b/9a2/d90/69b9a2d90b7f29ef57f658f8206f6dda.png"></div><br>  <i>Konsequente Verwendung der Zellenhöhe.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Zellenkanteneinheit </h2><br>  Obwohl die Zellen eine schöne Variation haben, sehen sie immer noch wie offensichtliche Sechsecke aus.  Dies ist an sich kein Problem, aber wir können ihr Aussehen verbessern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d5/895/e86/6d5895e8650286653b532d9c6fa1c10d.png"></div><br>  <i>Deutlich sichtbare hexagonale Zellen.</i> <br><br>  Wenn wir mehr Eckpunkte hätten, gäbe es eine größere lokale Variabilität.  Teilen wir also jede Kante der Zelle in zwei Teile, indem wir die Oberseite der Kante in der Mitte zwischen jedem Eckenpaar hinzufügen.  Dies bedeutet, dass <code>HexMesh.Triangulate</code> nicht ein, sondern zwei Dreiecke hinzufügen sollte. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; Vector3 v1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 v2 = center + HexMetrics.GetSecondSolidCorner(direction); Vector3 e1 = Vector3.Lerp(v1, v2, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); AddTriangle(center, v1, e1); AddTriangleColor(cell.color); AddTriangle(center, e1, v2); AddTriangleColor(cell.color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, v1, v2); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b09/03c/d20/b0903cd20983599abdc064f04c95aa4f.png"></div><br>  <i>Zwölf statt sechs Seiten.</i> <br><br>  Durch das Verdoppeln von Scheitelpunkten und Dreiecken werden die Kanten der Zelle variabler.  Machen wir sie noch ungleichmäßiger, indem wir die Anzahl der Eckpunkte verdreifachen. <br><br><pre> <code class="cs hljs"> Vector3 e1 = Vector3.Lerp(v1, v2, <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); Vector3 e2 = Vector3.Lerp(v1, v2, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); AddTriangle(center, v1, e1); AddTriangleColor(cell.color); AddTriangle(center, e1, e2); AddTriangleColor(cell.color); AddTriangle(center, e2, v2); AddTriangleColor(cell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/852/e6c/ad2852e6ccbf3db0adca140818545bb3.png"></div><br>  <i>18 Seiten.</i> <br><br><h3>  Rib Joint Division </h3><br>  Natürlich müssen wir auch die Kantenfugen unterteilen.  Daher werden wir die neuen Scheitelpunktkanten an <code>TriangulateConnection</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, v1, e1, e2, v2); }</code> </pre> <br>  Fügen Sie der <code>TriangulateConnection</code> die entsprechenden Parameter hinzu, damit sie mit zusätzlichen Scheitelpunkten arbeiten kann. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 e1, Vector3 e2, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { … }</code> </pre> <br>  Wir müssen auch die zusätzlichen Kanten der Kanten für benachbarte Zellen berechnen.  Wir können sie berechnen, nachdem wir die Brücke mit der anderen Seite verbunden haben. <br><br><pre> <code class="cs hljs"> Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; v3.y = v4.y = neighbor.Position.y; Vector3 e3 = Vector3.Lerp(v3, v4, <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); Vector3 e4 = Vector3.Lerp(v3, v4, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>);</code> </pre> <br>  Als nächstes müssen wir die Triangulation der Rippe ändern.  Bis wir die Hänge mit den Leisten ignorieren, fügen Sie einfach drei statt eines Quad hinzu. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddQuad(v1, e1, v3, e3); AddQuadColor(cell.color, neighbor.color); AddQuad(e1, e2, e3, e4); AddQuadColor(cell.color, neighbor.color); AddQuad(e2, v2, e4, v4); AddQuadColor(cell.color, neighbor.color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afa/9d6/708/afa9d67080045b6ea2951a715c569003.png"></div><br>  <i>Unterteilte Verbindungen.</i> <br><br><h3>  Die Vereinigung der Kanten der Kanten </h3><br>  Da wir zur Beschreibung der Kanten jetzt vier Eckpunkte benötigen, wäre es logisch, sie zu einer Menge zu kombinieren.  Dies ist bequemer als das Arbeiten mit vier unabhängigen Scheitelpunkten.  Erstellen Sie hierfür eine einfache <code>EdgeVertices</code> Struktur.  Es sollte vier Eckpunkte enthalten, die im Uhrzeigersinn entlang der Zellenkante verlaufen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EdgeVertices { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 v1, v2, v3, v4; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Sollten sie nicht serialisierbar sein?</b> <div class="spoiler_text">  Wir werden diese Struktur nur zur Triangulation verwenden.  Zu diesem Zeitpunkt müssen die Eckpunkte der Kanten nicht gespeichert werden, sodass sie nicht serialisierbar sein müssen. </div></div><br>  Fügen Sie eine praktische Konstruktormethode hinzu, die sich mit der Berechnung der Zwischenpunkte der Kante befasst. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EdgeVertices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 corner1, Vector3 corner2</span></span></span><span class="hljs-function">)</span></span> { v1 = corner1; v2 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); v3 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); v4 = corner2; }</code> </pre> <br>  Jetzt können wir <code>HexMesh</code> eine separate Triangulationsmethode <code>HexMesh</code> , um einen Fächer aus Dreiecken zwischen der Mitte der Zelle und einer ihrer Kanten zu erstellen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, Color color</span></span></span><span class="hljs-function">)</span></span> { AddTriangle(center, edge.v1, edge.v2); AddTriangleColor(color); AddTriangle(center, edge.v2, edge.v3); AddTriangleColor(color); AddTriangle(center, edge.v3, edge.v4); AddTriangleColor(color); }</code> </pre> <br>  Und ein Verfahren zum Triangulieren eines Viereckstreifens zwischen zwei Kanten. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2 </span></span></span><span class="hljs-function">)</span></span> { AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); AddQuadColor(c1, c2); AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); AddQuadColor(c1, c2); AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); AddQuadColor(c1, c2); }</code> </pre> <br>  Dadurch können wir die <code>Triangulate</code> vereinfachen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; EdgeVertices e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); TriangulateEdgeFan(center, e, cell.color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, e); } }</code> </pre> <br>  Fahren wir mit <code>TriangulateConnection</code> .  Jetzt können wir <code>TriangulateEdgeStrip</code> , aber es müssen andere Ersetzungen vorgenommen werden.  Wo wir früher <code>v1</code> , müssen wir <code>e1.v1</code> .  In ähnlicher Weise wird <code>v2</code> zu <code>e1.v4</code> , <code>v3</code> zu <code>e2.v1</code> und <code>v4</code> zu <code>e2.v4</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 bridge = HexMetrics.GetBridge(direction); bridge.y = neighbor.Position.y - cell.Position.y; EdgeVertices e2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( e1.v1 + bridge, e1.v4 + bridge ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1.v1, e1.v4, cell, e2.v1, e2.v4, neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip(e1, cell.color, e2, neighbor.color); } HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 v5 = e1.v4 + HexMetrics.GetBridge(direction.Next()); v5.y = nextNeighbor.Position.y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= neighbor.Elevation) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner( e1.v4, cell, e2.v4, neighbor, v5, nextNeighbor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner( v5, nextNeighbor, e1.v4, cell, e2.v4, neighbor ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner( e2.v4, neighbor, v5, nextNeighbor, e1.v4, cell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner( v5, nextNeighbor, e1.v4, cell, e2.v4, neighbor ); } }</code> </pre> <br><h3>  Ledge Division </h3><br>  Wir müssen die Leisten teilen.  Daher übergeben wir die Kanten an <code>TriangulateEdgeTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor); }</code> </pre> <br>  Jetzt müssen wir <code>TriangulateEdgeTerraces</code> so ändern, dass es zwischen Kanten und nicht zwischen Scheitelpunktpaaren interpoliert.  Nehmen wir an, dass <code>EdgeVertices</code> eine bequeme statische Methode dafür hat.  Auf diese Weise können wir <code>TriangulateEdgeTerraces</code> vereinfachen, anstatt es zu komplizieren. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); TriangulateEdgeStrip(begin, beginCell.color, e2, c2); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, i); TriangulateEdgeStrip(e1, c1, e2, c2); } TriangulateEdgeStrip(e2, c2, end, endCell.color); }</code> </pre> <br>  Die <code>EdgeVertices.TerraceLerp</code> Methode interpoliert einfach die Leisten zwischen allen vier Scheitelpunktpaaren zweier Kanten. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EdgeVertices </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices a, EdgeVertices b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { EdgeVertices result; result.v1 = HexMetrics.TerraceLerp(a.v1, b.v1, step); result.v2 = HexMetrics.TerraceLerp(a.v2, b.v2, step); result.v3 = HexMetrics.TerraceLerp(a.v3, b.v3, step); result.v4 = HexMetrics.TerraceLerp(a.v4, b.v4, step); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7d/ead/906/a7dead9066cbd1f7ddd29ca751d81cb0.png"></div><br>  <i>Unterteilte Leisten.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Verbinden Sie Klippen und Felsvorsprünge wieder </h2><br>  Bisher haben wir Risse in der Kreuzung von Klippen und Felsvorsprüngen ignoriert.  Es ist Zeit, dieses Problem zu lösen.  Betrachten wir zunächst die Fälle Cliff-Slope-Slope (OSS) und Slope-Cliff-Slope (SOS). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/402/951/0fa/4029510fa08226cc4e4aee18faf1959b.png"></div><br>  <i>Maschenlöcher.</i> <br><br>  Das Problem entsteht, weil sich die Grenzen verschoben haben.  Dies bedeutet, dass sie jetzt nicht genau auf der Seite der Klippe liegen, was zu einem Riss führt.  Manchmal sind diese Löcher unsichtbar und manchmal auffällig. <br><br>  Die Lösung besteht darin, den oberen Rand nicht zu verschieben.  Dies bedeutet, dass wir steuern müssen, ob der Punkt verschoben wird.  Am einfachsten wäre es, eine <code>AddTriangle</code> Alternative zu erstellen, die Scheitelpunkte überhaupt nicht verschiebt. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleUnperturbed</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(v1); vertices.Add(v2); vertices.Add(v3); triangles.Add(vertexIndex); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Ändern Sie das <code>TriangulateBoundaryTriangle</code> so, dass es diese Methode verwendet.  Dies bedeutet, dass er alle Scheitelpunkte mit Ausnahme der Grenzscheitelpunkte explizit verschieben muss. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangleUnperturbed(Perturb(begin), Perturb(v2), boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.TerraceLerp(begin, left, i); c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); AddTriangleUnperturbed(Perturb(v1), Perturb(v2), boundary); AddTriangleColor(c1, c2, boundaryColor); } AddTriangleUnperturbed(Perturb(v2), Perturb(left), boundary); AddTriangleColor(c2, leftCell.color, boundaryColor); }</code> </pre> <br>  Folgendes ist zu beachten: Da wir <code>v2</code> nicht verwenden, um einen anderen Punkt zu erhalten, können wir ihn sofort verschieben.  Dies ist eine einfache Optimierung, die die Codemenge reduziert. Lassen Sie uns sie einführen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangleUnperturbed(Perturb(begin), v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); AddTriangleUnperturbed(v1, v2, boundary); AddTriangleColor(c1, c2, boundaryColor); } AddTriangleUnperturbed(v2, Perturb(left), boundary); AddTriangleColor(c2, leftCell.color, boundaryColor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fd/221/0ed/3fd2210ed0a8148ba9d39ef1655848e8.png"></div><br>  <i>Unbewegte Grenzen.</i> <br><br>  Es sieht besser aus, aber wir sind noch nicht fertig.  Innerhalb der <code>TriangulateCornerTerracesCliff</code> Methode wird der Grenzpunkt zwischen dem linken und dem rechten Punkt interpoliert.  Diese Punkte wurden jedoch noch nicht verschoben.  Damit der Grenzpunkt der resultierenden Klippe entspricht, müssen wir zwischen den bewegten Punkten interpolieren. <br><br><pre> <code class="cs hljs"> Vector3 boundary = Vector3.Lerp(Perturb(begin), Perturb(right), b);</code> </pre> <br>  Gleiches gilt für die <code>TriangulateCornerCliffTerraces</code> Methode. <br><br><pre> <code class="cs hljs"> Vector3 boundary = Vector3.Lerp(Perturb(begin), Perturb(left), b);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c18/917/670/c189176704e7ebcdfd92bc6a1cffaee3.png"></div><br>  <i>Die Löcher sind weg.</i> <br><br><h3>  Doppelklippen und Hang </h3><br>  In allen verbleibenden problematischen Fällen sind zwei Klippen und ein Hang vorhanden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/408/f2f/4a6/408f2f4a6fca5fffd8659b4380f59e51.png"></div><br>  <i>Großes Loch wegen eines einzelnen Dreiecks.</i> <br><br>  Dieses Problem wird behoben, indem ein einzelnes Dreieck im <code>else</code> Block am Ende von <code>TriangulateCornerTerracesCliff</code> manuell <code>TriangulateCornerTerracesCliff</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangleUnperturbed(Perturb(left), Perturb(right), boundary); AddTriangleColor(leftCell.color, rightCell.color, boundaryColor); }</code> </pre> <br>  Gleiches gilt für <code>TriangulateCornerCliffTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangleUnperturbed(Perturb(left), Perturb(right), boundary); AddTriangleColor(leftCell.color, rightCell.color, boundaryColor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/b34/64a/9ffb3464a6de3dc443cede9d42797022.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Befreien Sie sich von den neuesten Rissen. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fertigstellung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir ein völlig korrektes verzerrtes Netz. </font><font style="vertical-align: inherit;">Sein Aussehen hängt vom spezifischen Geräusch, seiner Größe und den Verzerrungskräften ab. </font><font style="vertical-align: inherit;">In unserem Fall scheint die Verzerrung zu stark zu sein. </font><font style="vertical-align: inherit;">Obwohl diese Ungleichmäßigkeit schön aussieht, möchten wir nicht, dass die Zellen zu stark vom geraden Gitter abweichen. </font><font style="vertical-align: inherit;">Am Ende verwenden wir es immer noch, um die Zelle zu definieren, deren Größe geändert werden soll. </font><font style="vertical-align: inherit;">Und wenn die Größe der Zellen zu stark variiert, wird es für uns schwieriger sein, den Inhalt darin zu platzieren.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35f/32e/d06/35f32ed066f03b1079ed0bec70ba83ca.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eac/3f5/d6c/eac3f5d6cd6a1e65185d1aec48e8abb0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unverzerrte und verzerrte Netze. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es scheint, dass die Kraft 5 zum Verzerren der Zellen zu groß ist.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verzerrung der Zellen liegt zwischen 0 und 5.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reduzieren wir sie auf 4, um den Komfort des Rasters zu erhöhen, ohne es zu korrekt zu machen. </font><font style="vertical-align: inherit;">Dies stellt sicher, dass der maximale XZ-Versatz √32 ≈ 5,66 Einheiten beträgt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/803/2f6/b8d/8032f6b8d0cf048f5d55c30e2d0e465d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zellverzerrungsstärke 4.</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein weiterer Wert, der geändert werden kann, ist der Integritätskoeffizient. </font><font style="vertical-align: inherit;">Wenn wir es erhöhen, werden die flachen Zentren der Zellen größer, dh es wird mehr Platz für zukünftige Inhalte geben. </font><font style="vertical-align: inherit;">Dabei werden sie natürlich sechseckiger.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Integritätskoeffizient von 0,75 bis 0,95. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine leichte Erhöhung des Integritätskoeffizienten auf 0,8 wird unser zukünftiges Leben leicht vereinfachen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> solidFactor = <span class="hljs-number"><span class="hljs-number">0.8f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/9a2/036/a9a9a2036fbcd0e4e5f11e56078911c1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Integritätskoeffizient 0.8. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schließlich stellen Sie möglicherweise fest, dass die Unterschiede zwischen den Höhenstufen zu stark sind. </font><font style="vertical-align: inherit;">Dies ist praktisch, wenn Sie sicherstellen müssen, dass das Netz korrekt generiert wird. Damit sind wir jedoch bereits fertig. </font><font style="vertical-align: inherit;">Reduzieren wir es auf 1 Einheit pro Schritt, dh auf 3.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> elevationStep = <span class="hljs-number"><span class="hljs-number">3f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5cc/4b0/028/5cc4b002843f822556c7ced67b9f54db.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Tonhöhe wird auf 3 reduziert.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir können auch die Stärke der Tonhöhenverzerrung ändern. </font><font style="vertical-align: inherit;">Aber jetzt hat es einen Wert von 1,5, was einem halben Höhenschritt entspricht, was zu uns passt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kleine Höhenstufen ermöglichen eine logischere Verwendung aller sieben Höhenstufen. </font><font style="vertical-align: inherit;">Dies erhöht die Variabilität der Karte.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f63/9b3/aac/f639b3aac128c4c72c28fa85d68cc0e4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden sieben Höhenstufen. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 5: größere Karten </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir teilen das Gitter in Fragmente. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir steuern die Kamera. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Färben Sie die Farben und Höhen separat aus. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden Sie den vergrößerten Pinsel der Zellen. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher haben wir mit einer sehr kleinen Karte gearbeitet. </font><font style="vertical-align: inherit;">Es ist Zeit, es zu erhöhen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c8/11c/4b4/0c811c4b480c13b584a2b824fdae1cee.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist Zeit zu zoomen.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Netzfragmente </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können das Gitter nicht zu groß machen, weil wir an die Grenzen dessen stoßen, was in ein Netz passen kann. </font><font style="vertical-align: inherit;">Wie kann man dieses Problem lösen? </font><font style="vertical-align: inherit;">Verwenden Sie mehrere Netze. </font><font style="vertical-align: inherit;">Dazu müssen wir unser Gitter in mehrere Fragmente aufteilen. </font><font style="vertical-align: inherit;">Wir verwenden rechteckige Fragmente konstanter Größe.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/423/453/db2/423453db217ed74da2457198c576ef63.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teilen Sie das Gitter in 3 mal 3 Segmente.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden Sie 5 mal 5 Blöcke, dh 25 Zellen pro Fragment. </font><font style="vertical-align: inherit;">Definieren Sie sie in </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSizeX = <span class="hljs-number"><span class="hljs-number">5</span></span>, chunkSizeZ = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welche Fragmentgröße kann als geeignet angesehen werden?</font></font></b> <div class="spoiler_text">  .       ,     .      .      ,       (frustum culling),       .            . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir keine Größe für das Netz verwenden, es muss ein Vielfaches der Fragmentgröße sein. </font><font style="vertical-align: inherit;">Ändern wir es </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">daher so, dass es seine Größe nicht in separaten Zellen, sondern in Fragmenten festlegt. </font><font style="vertical-align: inherit;">Stellen Sie die Standardgröße auf 4 x 3 Fragmente ein, dh nur 12 Fragmente oder 300 Zellen. </font><font style="vertical-align: inherit;">So bekommen wir eine bequeme Testkarte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkCountX = <span class="hljs-number"><span class="hljs-number">4</span></span>, chunkCountZ = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir benutzen immer noch </font></font><code>width</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>height</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber jetzt sollten sie privat werden. </font><font style="vertical-align: inherit;">Und benenne sie in </font></font><code>cellCountX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und um </font></font><code>cellCountZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Verwenden Sie den Editor, um alle Vorkommen dieser Variablen gleichzeitig umzubenennen. </font><font style="vertical-align: inherit;">Jetzt wird klar, wann es sich um die Anzahl der Fragmente oder Zellen handelt.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public int width = 6; // public int height = 6; int cellCountX, cellCountZ;</span></span></code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/227/ff4/160/227ff41602f115787a8a0e5d98ca89c9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geben Sie die Größe in Fragmenten an. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern Sie dies </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass bei Bedarf die Anzahl der Zellen aus der Anzahl der Fragmente berechnet wird. </font><font style="vertical-align: inherit;">Wir heben die Erstellung von Zellen in einer separaten Methode hervor, um nicht zu verstopfen </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cellCountX = chunkCountX * HexMetrics.chunkSizeX; cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; CreateCells(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[cellCountZ * cellCountX]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; cellCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; cellCountX; x++) { CreateCell(x, z, i++); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fragment Fertighaus </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um die Netzfragmente zu beschreiben, benötigen wir einen neuen Komponententyp. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGridChunk</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als nächstes erstellen wir ein vorgefertigtes Fragment. </font><font style="vertical-align: inherit;">Dazu duplizieren wir das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekt </font><font style="vertical-align: inherit;">und benennen es in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid Chunk um</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Entfernen Sie die Komponente </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und fügen Sie stattdessen eine Komponente hinzu </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Verwandeln Sie es dann in ein Fertighaus und entfernen Sie das Objekt aus der Szene.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/106/a02/bea/106a02bead67c37151be26d5f6a4bea9.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cb/586/7a3/1cb5867a3851159ce2bf1747a4e213bc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Fragment vorgefertigt mit eigener Leinwand und Netz. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da er Instanzen dieser Fragmente erstellen </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird, geben wir ihm einen Link zum Fertighaus des Fragments.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGridChunk chunkPrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a9/6b8/882/2a96b8882c5d6cc5bdb6345d5217ae83.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt mit Fragmenten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Erstellen von Instanzen von Fragmenten ähnelt dem Erstellen von Instanzen von Zellen. </font><font style="vertical-align: inherit;">Wir werden sie mit Hilfe eines Arrays verfolgen und mit einer Doppelschleife füllen.</font></font><br><br><pre> <code class="cs hljs"> HexGridChunk[] chunks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … CreateChunks(); CreateCells(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexGridChunk[chunkCountX * chunkCountZ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; chunkCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { HexGridChunk chunk = chunks[i++] = Instantiate(chunkPrefab); chunk.transform.SetParent(transform); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Initialisieren eines Fragments ähnelt dem Initialisieren eines Sechseckgitters. </font><font style="vertical-align: inherit;">Sie setzt alles ein </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und führt eine Triangulation durch </font></font><code>Start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es erfordert einen Verweis auf die Zeichenfläche und das Netz sowie ein Array für die Zellen. </font><font style="vertical-align: inherit;">Das Fragment erstellt diese Zellen jedoch nicht. </font><font style="vertical-align: inherit;">Das Raster wird dies weiterhin tun.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGridChunk</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { HexCell[] cells; HexMesh hexMesh; Canvas gridCanvas; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Triangulate(cells); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zuweisen von Zellen zu Fragmenten </font></font></h3><br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erstellt immer noch alle Zellen. </font><font style="vertical-align: inherit;">Dies ist normal, aber jetzt müssen wir jede Zelle einem geeigneten Fragment hinzufügen und dürfen sie nicht mit unserem eigenen Netz und unserer eigenen Leinwand festlegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); <span class="hljs-comment"><span class="hljs-comment">// cell.transform.SetParent(transform, false); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.color = defaultColor; … Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); // label.rectTransform.SetParent(gridCanvas.transform, false); label.rectTransform.anchoredPosition = new Vector2(position.x, position.z); label.text = cell.coordinates.ToStringOnSeparateLines(); cell.uiRect = label.rectTransform; cell.Elevation = 0; AddCellToChunk(x, z, cell); } void AddCellToChunk (int x, int z, HexCell cell) { }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können das richtige Fragment mithilfe der Ganzzahldivision </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Fragmentgröße finden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCellToChunk</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkX = x / HexMetrics.chunkSizeX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkZ = z / HexMetrics.chunkSizeZ; HexGridChunk chunk = chunks[chunkX + chunkZ * chunkCountX]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mithilfe von Zwischenergebnissen können wir auch den lokalen Index der Zelle in diesem Fragment bestimmen. </font><font style="vertical-align: inherit;">Danach können Sie dem Fragment eine Zelle hinzufügen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCellToChunk</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkX = x / HexMetrics.chunkSizeX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkZ = z / HexMetrics.chunkSizeZ; HexGridChunk chunk = chunks[chunkX + chunkZ * chunkCountX]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> localX = x - chunkX * HexMetrics.chunkSizeX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> localZ = z - chunkZ * HexMetrics.chunkSizeZ; chunk.AddCell(localX + localZ * HexMetrics.chunkSizeX, cell); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anschließend wird </font></font><code>HexGridChunk.AddCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Zelle in einem eigenen Array platziert und die übergeordneten Elemente für die Zelle und ihre Benutzeroberfläche festgelegt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cells[index] = cell; cell.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); cell.uiRect.SetParent(gridCanvas.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fegen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt kann er </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Leinwand und das Sechsecknetz seiner Kinder sowie den Code entfernen.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Canvas gridCanvas; // HexMesh hexMesh; void Awake () { HexMetrics.noiseSource = noiseSource; // gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); // hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); … } // void Start () { // hexMesh.Triangulate(cells); // } // public void Refresh () { // hexMesh.Triangulate(cells); // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir es losgeworden sind </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sollten wir es </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht mehr benutzen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cell.color = activeColor; cell.Elevation = activeElevation; <span class="hljs-comment"><span class="hljs-comment">// hexGrid.Refresh(); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a0/f4b/c99/5a0f4bc99bce766e53ff1a0192abd16e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das gereinigte Sechseckgitter. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Starten des Wiedergabemodus sieht die Karte immer noch gleich aus. </font><font style="vertical-align: inherit;">Die Hierarchie der Objekte wird jedoch unterschiedlich sein. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erstellt jetzt untergeordnete Fragmentobjekte, die Zellen sowie deren Netz und Zeichenfläche enthalten.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7f/bc4/f8e/a7fbc4f8e4898504bc34a4a918ebb567.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untergeordnete Fragmente im Wiedergabemodus. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielleicht haben wir einige Probleme mit Zelletiketten. </font><font style="vertical-align: inherit;">Zunächst haben wir die Beschriftungsbreite auf 5 gesetzt. Dies war ausreichend, um die beiden Zeichen, die für uns ausreichten, auf einer kleinen Karte anzuzeigen. </font><font style="vertical-align: inherit;">Aber jetzt können wir Koordinaten wie −10 haben, in denen es drei Zeichen gibt. </font><font style="vertical-align: inherit;">Sie passen nicht und werden zugeschnitten. </font><font style="vertical-align: inherit;">Um dies zu beheben, erhöhen Sie die Breite der Zellenbezeichnung auf 10 oder noch mehr.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e7/fd3/4a5/2e7fd34a5b649256e326b73a3aa9227a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7c/926/fae/f7c926fae8356aa8d2402a21359fea8f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweiterte Zellbezeichnungen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir viel größere Karten erstellen! </font><font style="vertical-align: inherit;">Da wir beim Start das gesamte Raster generieren, kann es lange dauern, große Karten zu erstellen. </font><font style="vertical-align: inherit;">Aber nach der Fertigstellung werden wir einen riesigen Raum zum Experimentieren haben.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Korrektur der Zellbearbeitung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bearbeitung scheint derzeit nicht zu funktionieren, da das Raster nicht mehr aktualisiert wird. </font><font style="vertical-align: inherit;">Wir Fragmente fügen Sie </font><font style="vertical-align: inherit;">so ein Verfahren aktualisiert werden müssen , </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Triangulate(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wann sollten wir diese Methode aufrufen? </font><font style="vertical-align: inherit;">Wir haben das gesamte Raster jedes Mal aktualisiert, da wir nur ein Netz hatten. </font><font style="vertical-align: inherit;">Aber jetzt haben wir viele Fragmente. </font><font style="vertical-align: inherit;">Anstatt sie alle jedes Mal zu aktualisieren, ist es viel effizienter, die geänderten Fragmente zu aktualisieren. </font><font style="vertical-align: inherit;">Andernfalls wird das Wechseln großer Karten zu einem sehr langsamen Vorgang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber woher wissen wir, welches Fragment aktualisiert werden soll? </font><font style="vertical-align: inherit;">Am einfachsten ist es, jeder Zelle mitzuteilen, zu welchem ​​Fragment sie gehört. </font><font style="vertical-align: inherit;">Dann kann die Zelle ihr Fragment aktualisieren, wenn diese Zelle geändert wird. </font><font style="vertical-align: inherit;">Geben wir also einen </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zu seinem Fragment.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGridChunk chunk;</code> </pre> <br> <code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann sich beim Hinzufügen selbst zur Zelle hinzufügen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cells[index] = cell; cell.chunk = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; cell.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); cell.uiRect.SetParent(gridCanvas.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indem wir sie verbinden, ergänzen wir die </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jedes Mal, wenn eine Zelle aktualisiert wird, wird einfach ihr Fragment aktualisiert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunk.Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir müssen es nicht </font></font><code>HexCell.Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemein machen, da die Zelle selbst besser weiß, wann sie geändert wurde. </font><font style="vertical-align: inherit;">Zum Beispiel, nachdem seine Höhe geändert wurde.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { … Refresh(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tatsächlich müssen wir es nur aktualisieren, wenn sich seine Höhe auf einen anderen Wert geändert hat. </font><font style="vertical-align: inherit;">Sie muss nicht einmal etwas neu berechnen, wenn wir ihr dieselbe Größe wie zuvor zuweisen. </font><font style="vertical-align: inherit;">Daher können wir den Anfang des Setters verlassen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } … } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden jedoch auch Berechnungen zum ersten Mal überspringen, wenn die Höhe auf 0 gesetzt ist, da dies der Standardwert für die Maschenhöhe ist. </font><font style="vertical-align: inherit;">Um dies zu vermeiden, werden wir den Anfangswert so festlegen, wie wir ihn niemals verwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevation = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MinValue;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist int.MinValue?</font></font></b> <div class="spoiler_text">   ,    integer.    C# integer — <br>  32- ,   2 <sup>32</sup>  integer,    ,    .       . <br><br>  —  −2 <sup>31</sup> = −2 147 483 648.        ! <br><br>   2 <sup>31</sup> − 1 = 2 147 483 647.     2 <sup>31</sup> - . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Farbänderung der Zelle zu erkennen, müssen wir sie auch in eine Eigenschaft umwandeln. </font><font style="vertical-align: inherit;">Benennen Sie es in </font></font><code>Color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Großbuchstaben um und verwandeln Sie es dann in eine Eigenschaft mit einer privaten Variablen </font></font><code>color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der Standardfarbwert ist transparentes Schwarz, was zu uns passt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color Color { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (color == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } color = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } Color color;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir jetzt den Wiedergabemodus starten, erhalten wir Nullreferenzausnahmen. </font><font style="vertical-align: inherit;">Dies geschieht, weil wir die Farbe und Höhe auf ihre Standardwerte setzen, bevor wir eine Zelle ihrem Fragment zuweisen. </font><font style="vertical-align: inherit;">Es ist normal, dass wir die Fragmente zu diesem Zeitpunkt nicht aktualisieren, da wir sie triangulieren, nachdem die Initialisierung abgeschlossen ist. </font><font style="vertical-align: inherit;">Mit anderen Worten, wir aktualisieren ein Fragment nur, wenn es zugewiesen ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunk) { chunk.Refresh(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können endlich wieder die Zellen wechseln! </font><font style="vertical-align: inherit;">Es tritt jedoch ein Problem auf. </font><font style="vertical-align: inherit;">Beim Zeichnen entlang der Ränder von Fragmenten erscheinen Nähte.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41a/94f/50c/41a94f50c430ce8f13fb1a3be274b520.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehler an den Grenzen von Fragmenten.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist logisch, denn wenn sich eine einzelne Zelle ändert, ändern sich auch alle Verbindungen zu ihren Nachbarn. Und diese Nachbarn können in anderen Fragmenten sein. Die einfachste Lösung besteht darin, alle benachbarten Zellen zu aktualisieren, wenn sie unterschiedlich sind.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunk) { chunk.Refresh(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; neighbors.Length; i++) { HexCell neighbor = neighbors[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; neighbor.chunk != chunk) { neighbor.chunk.Refresh(); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl dies funktioniert, kann es sich herausstellen, dass wir ein Fragment mehrmals aktualisieren. Und wenn wir anfangen, mehrere Zellen gleichzeitig zu färben, wird alles schlimmer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir müssen jedoch nicht sofort nach der Aktualisierung des Fragments triangulieren. Stattdessen schreiben wir einfach, dass ein Update erforderlich ist, und triangulieren, nachdem die Änderung abgeschlossen ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da es </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nichts anderes tut, können wir seinen aktivierten Status verwenden, um die Notwendigkeit von Updates zu signalisieren. Bei der Aktualisierung wird die Komponente berücksichtigt. Durch mehrmaliges Einschalten ändert sich nichts. Die Komponente wird später aktualisiert. Wir werden an dieser Stelle triangulieren und die Komponente wieder deaktivieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden </font></font><code>LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stattdessen</font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um sicherzustellen, dass die Triangulation erfolgt, nachdem die Änderung für den aktuellen Frame abgeschlossen ist. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// hexMesh.Triangulate(cells); enabled = true; } void LateUpdate () { hexMesh.Triangulate(cells); enabled = false; }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist der Unterschied zwischen Update und LateUpdate?</font></font></b> <div class="spoiler_text">     <code>Update</code>    -     .          <code>LateUpdate</code> .      ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da unsere Komponente standardmäßig aktiviert ist, müssen wir nicht mehr explizit triangulieren </font></font><code>Start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Daher kann diese Methode entfernt werden.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// void Start () { // hexMesh.Triangulate(cells); // }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6f/104/7c3/a6f1047c34bb9cf9b69360343ab53aac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmente von 20 mal 20 mit 10.000 Zellen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verallgemeinerte Listen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir die Art und Weise, wie das Gitter trianguliert wird, erheblich geändert haben, </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bleibt es gleich. </font><font style="vertical-align: inherit;">Alles, was er zum Arbeiten braucht, ist eine Reihe von Zellen. </font><font style="vertical-align: inherit;">Es ist ihm egal, ob es ein oder mehrere Sechsecke gibt. </font><font style="vertical-align: inherit;">Wir haben jedoch noch nicht in Betracht gezogen, mehrere Netze zu verwenden. </font><font style="vertical-align: inherit;">Vielleicht kann hier etwas verbessert werden? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die verwendeten </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listen sind im Wesentlichen temporäre Puffer. </font><font style="vertical-align: inherit;">Sie werden nur zur Triangulation verwendet. </font><font style="vertical-align: inherit;">Und die Fragmente werden einzeln trianguliert. </font><font style="vertical-align: inherit;">Daher benötigen wir in der Tat nur einen Satz von Listen und nicht einen Satz für jedes Sechsecknetzobjekt. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem die Listen statisch gemacht werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;Vector3&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector3&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;Color&gt; colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Color&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); meshCollider = gameObject.AddComponent&lt;MeshCollider&gt;(); hexMesh.name = <span class="hljs-string"><span class="hljs-string">"Hex Mesh"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// vertices = new List&lt;Vector3&gt;(); // colors = new List&lt;Color&gt;(); // triangles = new List&lt;int&gt;(); }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sind statische Listen wirklich so wichtig?</font></font></b> <div class="spoiler_text">           .    ,   ,       . <br><br>     ,           .    20  20     100. </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kamerasteuerung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die große Kamera ist wunderbar, aber sie ist nutzlos, wenn wir sie nicht sehen können. Um die gesamte Karte zu inspizieren, müssen wir die Kamera bewegen. Zoomen ist ebenfalls nützlich. Erstellen wir daher eine Kamera, um diese Aktionen auszuführen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie ein Dummy-Objekt und nennen Sie es </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Map Camera</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Legen Sie die Transformationskomponente so ab, dass sie sich zum Ursprung bewegt, ohne ihre Drehung und Skalierung zu ändern. In dem es ein Kind - </font><font style="vertical-align: inherit;">Objekt namens </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schwenker</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und er wird ein Child - </font><font style="vertical-align: inherit;">Objekt hinzufügen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stock</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Machen Sie die Hauptkamera zu einem Kind des Sticks und setzen Sie die Transformationskomponente zurück.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a8/33f/3d9/0a833f3d9eea9b9fef1682ef63a7f372.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Hierarchie der Kamera. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ziel des Kamerascharniers (Swivel) besteht darin, den Winkel zu steuern, in dem die Kamera auf die Karte schaut. </font><font style="vertical-align: inherit;">Lassen Sie es uns drehen (45, 0, 0). </font><font style="vertical-align: inherit;">Der Griff (Stick) steuert die Entfernung, in der sich die Kameras befinden. </font><font style="vertical-align: inherit;">Setzen wir ihr eine Position (0, 0, -45). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt brauchen wir eine Komponente, um dieses System zu steuern. </font><font style="vertical-align: inherit;">Weisen Sie diese Komponente dem Stamm der Kamerahierarchie zu. </font><font style="vertical-align: inherit;">Geben Sie ihm eine Verbindung zum Scharnier und Griff, um sie hineinzuholen </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapCamera</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Transform swivel, stick; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { swivel = transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); stick = swivel.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb6/2e5/44b/eb62e544b9e00bc558dfbc504802cfba.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hexagon Kartenkamera.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zoom </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste Funktion, die wir erstellen, ist das Zoomen (Zoomen). </font><font style="vertical-align: inherit;">Wir können die aktuelle Zoomstufe mit der Float-Variablen steuern. </font><font style="vertical-align: inherit;">Ein Wert von 0 bedeutet, dass wir vollständig entfernt sind, und ein Wert von 1 bedeutet, dass wir vollständig entfernt sind. </font><font style="vertical-align: inherit;">Beginnen wir mit dem maximalen Zoom.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoom = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Zoomen erfolgt normalerweise mit dem Mausrad oder der analogen Steuerung. </font><font style="vertical-align: inherit;">Wir können es mit der </font><font style="vertical-align: inherit;">Standard- </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maus-ScrollWheel-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eingabeachse implementieren </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Fügen Sie eine Methode hinzu </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die das Vorhandensein eines Eingabedeltas überprüft. Wenn eines vorhanden ist, wird die Zoomänderungsmethode aufgerufen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoomDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Mouse ScrollWheel"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zoomDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustZoom(zoomDelta); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um die Zoomstufe zu ändern, fügen wir einfach ein Delta hinzu und begrenzen dann den Wert (Klemme), um im Bereich von 0 bis 1 zu bleiben. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { zoom = Mathf.Clamp01(zoom + delta); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Vergrößern und Verkleinern sollte sich der Abstand zur Kamera entsprechend ändern. </font><font style="vertical-align: inherit;">Dies kann durch Ändern der Position des Griffs in Z erfolgen. Fügen Sie zwei allgemeine Float-Variablen hinzu, um die Position des Griffs bei minimalem und maximalem Zoom anzupassen. </font><font style="vertical-align: inherit;">Da wir eine relativ kleine Karte entwickeln, setzen Sie die Werte auf -250 und -45.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> stickMinZoom, stickMaxZoom;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Ändern des Zooms führen wir eine lineare Interpolation zwischen diesen beiden Werten basierend auf dem neuen Zoomwert durch. </font><font style="vertical-align: inherit;">Aktualisieren Sie dann die Position des Griffs.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { zoom = Mathf.Clamp01(zoom + delta); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = Mathf.Lerp(stickMinZoom, stickMaxZoom, zoom); stick.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, distance); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cec/f4c/f07/cecf4cf07d627d6eaab94ecdc2953d30.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimale und maximale Stick-Werte. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt funktioniert der Zoom, ist aber bisher nicht sehr nützlich. </font><font style="vertical-align: inherit;">Wenn der Zoom weiter entfernt ist, zeigt die Kamera normalerweise eine Draufsicht. </font><font style="vertical-align: inherit;">Wir können dies durch Drehen des Scharniers realisieren. </font><font style="vertical-align: inherit;">Daher addieren wir die Variablen min und max für das Scharnier. </font><font style="vertical-align: inherit;">Stellen wir ihnen die Werte 90 und 45 ein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> swivelMinZoom, swivelMaxZoom;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bei der Griffposition interpolieren wir, um einen geeigneten Zoomwinkel zu finden. </font><font style="vertical-align: inherit;">Dann stellen wir die Drehung des Scharniers ein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { zoom = Mathf.Clamp01(zoom + delta); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = Mathf.Lerp(stickMinZoom, stickMaxZoom, zoom); stick.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, distance); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Mathf.Lerp(swivelMinZoom, swivelMaxZoom, zoom); swivel.localRotation = Quaternion.Euler(angle, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/766/0c3/fcd/7660c3fcd621567398ea7c013fae549c.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der minimale und maximale Wert von Swivel. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Änderungsrate des Zooms kann durch Ändern der Empfindlichkeit der Eingabeparameter des Mausrads angepasst werden. </font><font style="vertical-align: inherit;">Sie finden sie unter </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bearbeiten / Projekteinstellungen / Eingabe</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn Sie sie beispielsweise von 0,1 auf 0,025 ändern, wird der Zoom langsamer und gleichmäßiger geändert.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d43/f86/ef3/d43f86ef3587be1bfd15ca208eec418f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mausrad-Eingabemöglichkeiten.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Umzug </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fahren wir nun mit dem Bewegen der Kamera fort. </font><font style="vertical-align: inherit;">Die Bewegung in Richtung X und Z müssen wir </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie beim Zoom </font><font style="vertical-align: inherit;">implementieren </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hierfür können wir </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horizontale</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vertikale</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eingabeachsen verwenden </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dadurch können wir die Kamera mit den Pfeilen und den WASD-Tasten bewegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoomDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Mouse ScrollWheel"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zoomDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustZoom(zoomDelta); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Horizontal"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span> || zDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustPosition(xDelta, zDelta); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der einfachste Ansatz besteht darin, die aktuelle Position des Kamerasystems zu ermitteln, die Deltas X und Z hinzuzufügen und das Ergebnis der Position des Systems zuzuweisen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { Vector3 position = transform.localPosition; position += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta); transform.localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus diesem Grund bewegt sich die Kamera, während Sie die Pfeile oder WASD gedrückt halten, jedoch nicht mit konstanter Geschwindigkeit. </font><font style="vertical-align: inherit;">Dies hängt von der Bildrate ab. </font><font style="vertical-align: inherit;">Um die Entfernung zu bestimmen, die Sie zurücklegen müssen, verwenden wir das Zeitdelta sowie die erforderliche Geschwindigkeit. </font><font style="vertical-align: inherit;">Daher fügen wir eine gemeinsame Variable hinzu, </font></font><code>moveSpeed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setzen sie auf 100 und multiplizieren sie dann mit dem Zeitdelta, um das Positionsdelta zu erhalten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moveSpeed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = moveSpeed * Time.deltaTime; Vector3 position = transform.localPosition; position += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta) * distance; transform.localPosition = position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6da/1bc/307/6da1bc3074dc31868b934a35aaa31b10.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bewegungsgeschwindigkeit. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir uns mit konstanter Geschwindigkeit entlang der X- oder Z-Achse bewegen. Wenn wir uns jedoch gleichzeitig (diagonal) entlang beider Achsen bewegen, ist die Bewegung schneller. </font><font style="vertical-align: inherit;">Um dies zu beheben, müssen wir den Delta-Vektor normalisieren. </font><font style="vertical-align: inherit;">Auf diese Weise können Sie es als Ziel verwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { Vector3 direction = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta).normalized; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = moveSpeed * Time.deltaTime; Vector3 position = transform.localPosition; position += direction * distance; transform.localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die diagonale Bewegung ist jetzt korrekt implementiert, aber plötzlich stellt sich heraus, dass sich die Kamera auch nach dem Loslassen aller Tasten noch ziemlich lange weiterbewegt. Dies liegt daran, dass die Eingangsachsen unmittelbar nach dem Drücken der Tasten nicht sofort zu den Grenzwerten springen. Sie brauchen etwas Zeit dafür. Gleiches gilt für das Loslassen von Schlüsseln. Es braucht Zeit, um zu den Nullachsenwerten zurückzukehren. Da wir jedoch die Eingabewerte normalisiert haben, wird die maximale Geschwindigkeit ständig beibehalten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können die Eingabeparameter anpassen, um die Verzögerungen zu beseitigen, aber sie vermitteln ein Gefühl der Glätte, das es wert ist, gespeichert zu werden. Wir können den extremsten Wert der Achsen als Dämpfungsbewegungskoeffizienten anwenden.</font></font><br><br><pre> <code class="cs hljs"> Vector3 direction = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta).normalized; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> damping = Mathf.Max(Mathf.Abs(xDelta), Mathf.Abs(zDelta)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = moveSpeed * damping * Time.deltaTime;</code> </pre><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bewegung mit Dämpfung. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt funktioniert die Bewegung gut, zumindest mit zunehmendem Zoom. </font><font style="vertical-align: inherit;">Aber in einiger Entfernung stellt sich heraus, dass es zu langsam ist. </font><font style="vertical-align: inherit;">Mit reduziertem Zoom müssen wir beschleunigen. </font><font style="vertical-align: inherit;">Dies kann durch Ersetzen einer Variablen </font></font><code>moveSpeed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durch zwei für minimalen und maximalen Zoom und anschließendes Interpolieren erfolgen. </font><font style="vertical-align: inherit;">Weisen Sie ihnen Werte von 400 und 100 zu.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public float moveSpeed; public float moveSpeedMinZoom, moveSpeedMaxZoom; void AdjustPosition (float xDelta, float zDelta) { Vector3 direction = new Vector3(xDelta, 0f, zDelta).normalized; float damping = Mathf.Max(Mathf.Abs(xDelta), Mathf.Abs(zDelta)); float distance = Mathf.Lerp(moveSpeedMinZoom, moveSpeedMaxZoom, zoom) * damping * Time.deltaTime; Vector3 position = transform.localPosition; position += direction * distance; transform.localPosition = position; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/cb8/65e/5a9cb865ee0a67d4b3ad056317faf479.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bewegungsgeschwindigkeit variiert mit der Zoomstufe. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir uns schnell auf der Karte bewegen! </font><font style="vertical-align: inherit;">Tatsächlich können wir uns weit über die Karte hinausbewegen, aber dies ist unerwünscht. </font><font style="vertical-align: inherit;">Die Kamera sollte in der Karte bleiben. </font><font style="vertical-align: inherit;">Um dies sicherzustellen, müssen wir die Grenzen der Karte kennen, daher ist eine Verknüpfung mit dem Raster erforderlich. </font><font style="vertical-align: inherit;">Fügen Sie es hinzu und verbinden Sie es.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid grid;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e71/f87/68e/e71f8768e16aee250700a7bd694a0e6b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie müssen die Rastergröße anfordern. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir an eine neue Position gewechselt sind, werden wir sie mit der neuen Methode begrenzen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { … transform.localPosition = ClampPosition(position); } <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Position X hat einen Minimalwert von 0 und das Maximum wird durch die Größe der Karte bestimmt. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = grid.chunkCountX * HexMetrics.chunkSizeX * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gleiches gilt für Position Z. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = grid.chunkCountX * HexMetrics.chunkSizeX * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = grid.chunkCountZ * HexMetrics.chunkSizeZ * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Tat ist dies ein wenig ungenau. </font><font style="vertical-align: inherit;">Der Startpunkt befindet sich in der Mitte der Zelle, nicht links. </font><font style="vertical-align: inherit;">Daher soll die Kamera in der Mitte der Zellen ganz rechts anhalten. </font><font style="vertical-align: inherit;">Subtrahieren Sie dazu die Hälfte der Zelle vom Maximum von X.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.chunkCountX * HexMetrics.chunkSizeX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aus dem gleichen Grund müssen wir das Maximum Z reduzieren. Da sich die Metriken geringfügig unterscheiden, müssen wir die gesamte Zelle subtrahieren. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.chunkCountZ * HexMetrics.chunkSizeZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit der Bewegung, die wir gemacht haben, bleibt nur ein kleines Detail übrig. </font><font style="vertical-align: inherit;">Manchmal reagiert die Benutzeroberfläche auf die Pfeiltasten, und dies führt dazu, dass sich der Schieberegler bewegt, wenn Sie die Kamera bewegen. </font><font style="vertical-align: inherit;">Dies geschieht, wenn sich die Benutzeroberfläche als aktiv betrachtet, nachdem Sie darauf geklickt haben und sich der Cursor weiterhin darüber befindet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können verhindern, dass die Benutzeroberfläche Tastatureingaben abhört. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das EventSystem-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekt </font><em><font style="vertical-align: inherit;">angewiesen wird</font></em><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Send Navigation Events</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht auszuführen </font><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/008/313/35c/00831335c530f6fcb06d4fe15890c316.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keine Navigationsereignisse mehr.</font></font></i> <br><br><h3>  Drehen Sie sich </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Möchten Sie sehen, was sich hinter der Klippe befindet? </font><font style="vertical-align: inherit;">Es wäre bequem, die Kamera drehen zu können! </font><font style="vertical-align: inherit;">Fügen wir diese Funktion hinzu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zoomstufe ist für die Drehung nicht wichtig, nur die Geschwindigkeit reicht aus. </font><font style="vertical-align: inherit;">Fügen Sie eine gemeinsame Variable hinzu </font></font><code>rotationSpeed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und setzen Sie sie auf 180 Grad. </font><font style="vertical-align: inherit;">Überprüfen Sie das Rotationsdelta, </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indem Sie die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rotationsachse</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abtasten </font><font style="vertical-align: inherit;">und gegebenenfalls </font><font style="vertical-align: inherit;">die </font><em><font style="vertical-align: inherit;">Rotation</font></em><font style="vertical-align: inherit;"> ändern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationSpeed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoomDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Mouse ScrollWheel"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zoomDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustZoom(zoomDelta); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Rotation"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rotationDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustRotation(rotationDelta); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Horizontal"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span> || zDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustPosition(xDelta, zDelta); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c17/189/c8f/c17189c8f16ef3e50aa8af32f7ff34c8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drehgeschwindigkeit. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tatsächlich ist die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rotationsachse</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht standardmäßig. </font><font style="vertical-align: inherit;">Wir müssen es selbst schaffen. </font><font style="vertical-align: inherit;">Gehen Sie zu den Eingabeparametern und duplizieren Sie den obersten Eintrag </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertikal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ändern Sie den Namen des Duplikats in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rotation</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und ändern Sie die Tasten in QE und ein Komma (,) mit einem Punkt (.).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/549/6a8/50a/5496a850af906515b57a0d0fd1aea7b5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eingangsachse drehen.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe das Unity-Paket heruntergeladen. Warum habe ich diese Eingabe nicht?</font></font></b> <div class="spoiler_text">     .       Unity.  ,     .    ,    ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Drehwinkel, den wir verfolgen und ändern werden </font></font><code>AdjustRotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Danach drehen wir das gesamte Kamerasystem.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationAngle; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { rotationAngle += delta * rotationSpeed * Time.deltaTime; transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, rotationAngle, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da der Vollkreis 360 Grad beträgt, rollen wir den Drehwinkel so, dass er im Bereich von 0 bis 360 liegt. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { rotationAngle += delta * rotationSpeed * Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rotationAngle &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span>) { rotationAngle += <span class="hljs-number"><span class="hljs-number">360f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rotationAngle &gt;= <span class="hljs-number"><span class="hljs-number">360f</span></span>) { rotationAngle -= <span class="hljs-number"><span class="hljs-number">360f</span></span>; } transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, rotationAngle, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Aktion schalten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt funktioniert die Rotation. </font><font style="vertical-align: inherit;">Wenn Sie es überprüfen, können Sie sehen, dass die Bewegung absolut ist. </font><font style="vertical-align: inherit;">Daher ist die Bewegung nach dem Drehen um 180 Grad das Gegenteil von dem, was erwartet wurde. </font><font style="vertical-align: inherit;">Für den Benutzer wäre es viel bequemer, wenn die Bewegung relativ zum Betrachtungswinkel der Kamera ausgeführt wird. </font><font style="vertical-align: inherit;">Wir können dies tun, indem wir die aktuelle Drehung mit der Bewegungsrichtung multiplizieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { Vector3 direction = transform.localRotation * <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta).normalized; … }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relative Verschiebung. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erweiterte Bearbeitung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt, da wir eine größere Karte haben, können Sie die Kartenbearbeitungswerkzeuge verbessern. </font><font style="vertical-align: inherit;">Das Ändern einer Zelle zu einem Zeitpunkt ist zu lang, daher wäre es schön, einen größeren Pinsel zu erstellen. </font><font style="vertical-align: inherit;">Es ist auch praktisch, wenn Sie malen oder die Höhe ändern können, wobei alles andere unverändert bleibt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optionale Farbe und Höhe </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können Farben optional machen, indem wir der Umschaltgruppe eine leere Auswahloption hinzufügen. </font><font style="vertical-align: inherit;">Duplizieren Sie einen der Farbschalter und ersetzen Sie das Etikett durch </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">---</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder ähnliches, um anzuzeigen, dass es sich nicht um eine Farbe handelt. </font><font style="vertical-align: inherit;">Ändern Sie dann das Argument des Ereignisses </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Value Changed</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in −1.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/786/485/b0c/786485b0cbbae8edee6c80873f19afc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ungültiger Farbindex. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Natürlich ist dieser Index für ein Array von Farben nicht gültig. </font><font style="vertical-align: inherit;">Wir können damit bestimmen, ob Farbe auf Zellen angewendet werden soll.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { applyColor = index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { activeColor = colors[index]; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } cell.Elevation = activeElevation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Höhe wird durch einen Schieberegler gesteuert, daher können wir keinen Schalter hinzufügen. </font><font style="vertical-align: inherit;">Stattdessen können wir einen separaten Schalter verwenden, um die Höhenbearbeitung zu aktivieren oder zu deaktivieren. </font><font style="vertical-align: inherit;">Standardmäßig ist es aktiviert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyElevation = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie der Benutzeroberfläche einen neuen Höhenschalter hinzu. </font><font style="vertical-align: inherit;">Ich werde auch alles auf ein neues Bedienfeld setzen und den Höhenregler horizontal machen, damit die Benutzeroberfläche schöner wird.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07d/cab/84d/07dcab84d8e8fe4daac4b6120df34d60.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optionale Farbe und Höhe. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Höhe zu aktivieren, benötigen wir eine neue Methode, die wir mit der Benutzeroberfläche verbinden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyElevation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyElevation = toggle; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie durch Anschließen an den Höhenschalter sicher, dass die dynamische Bool-Methode oben in der Liste der Methoden verwendet wird. </font><font style="vertical-align: inherit;">Die richtigen Versionen zeigen im Inspektor kein Häkchen an.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/d5b/1b2/887d5b1b275cb18957b63bcbecf145d4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir übermitteln den Status des Höhenschalters. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir nur noch die Färbung mit Blumen oder nur die Höhe wählen. </font><font style="vertical-align: inherit;">Oder beides wie immer. </font><font style="vertical-align: inherit;">Wir können uns sogar dafür entscheiden, weder das eine noch das andere zu ändern, aber bisher ist es für uns nicht besonders nützlich.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wechseln Sie zwischen Farbe und Höhe.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum schaltet sich die Höhe bei der Auswahl einer Farbe aus?</font></font></b> <div class="spoiler_text">  ,       toggle group. ,          ,     toggle group. </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pinselgröße </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie zur Unterstützung der Größe des Pinsels eine ganzzahlige Variable </font></font><code>brushSize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und eine Methode zum Festlegen über die Benutzeroberfläche hinzu. </font><font style="vertical-align: inherit;">Wir werden den Schieberegler verwenden, also müssen wir den Wert erneut von float in int konvertieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brushSize; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetBrushSize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size</span></span></span><span class="hljs-function">)</span></span> { brushSize = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)size; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/794/bfb/60f/794bfb60f2f1c777fa0363ede3f19540.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schieberegler für Pinselgröße. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können einen neuen Schieberegler erstellen, indem Sie den Höhenschieberegler duplizieren. </font><font style="vertical-align: inherit;">Ändern Sie den Maximalwert auf 4 und hängen Sie ihn an die entsprechende Methode an. </font><font style="vertical-align: inherit;">Ich habe ihm auch einen Tag hinzugefügt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88e/8b2/f58/88e8b2f58abfd48657387e6670c51215.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einstellungen für den Pinselgrößen-Schieberegler. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt, da wir mehrere Zellen gleichzeitig bearbeiten können, müssen wir die Methode verwenden </font></font><code>EditCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Methode ruft </font></font><code>EditCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alle beteiligten Zellen auf. </font><font style="vertical-align: inherit;">Die ursprünglich ausgewählte Zelle wird als Mitte des Pinsels betrachtet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { EditCells(hexGrid.GetCell(hit.point)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Größe des Pinsels bestimmt den Radius der Bearbeitung. </font><font style="vertical-align: inherit;">Bei einem Radius von 0 ist dies nur eine zentrale Zelle. </font><font style="vertical-align: inherit;">Mit einem Radius von 1 ist dies das Zentrum und seine Nachbarn. </font><font style="vertical-align: inherit;">In einem Radius von 2 werden die Nachbarn des Zentrums und ihre unmittelbaren Nachbarn eingeschaltet.</font></font> Usw. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/14d/b65/61214db6508869c0ceda156c103ca032.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bis zu Radius 3.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um Zellen zu bearbeiten, müssen Sie sie in einer Schleife umgehen. </font><font style="vertical-align: inherit;">Zuerst brauchen wir die X- und Z-Koordinaten des Zentrums.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX = center.coordinates.X; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerZ = center.coordinates.Z; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir finden die minimale Z-Koordinate durch Subtrahieren des Radius. </font><font style="vertical-align: inherit;">Also definieren wir die Nulllinie. </font><font style="vertical-align: inherit;">Ab dieser Linie durchlaufen wir die Linie, bis wir die Linie in der Mitte abdecken.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX = center.coordinates.X; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerZ = center.coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ - brushSize; z &lt;= centerZ; z++, r++) { } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste Zelle in der unteren Reihe hat dieselbe X-Koordinate wie die mittlere Zelle. </font><font style="vertical-align: inherit;">Diese Koordinate nimmt mit zunehmender Zeilennummer ab. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die letzte Zelle hat immer eine X-Koordinate, die der Mittelkoordinate plus Radius entspricht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir jede Zeile durchlaufen und Zellen anhand ihrer Koordinaten abrufen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ - brushSize; z &lt;= centerZ; z++, r++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = centerX - r; x &lt;= centerX + brushSize; x++) { EditCell(hexGrid.GetCell(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z))); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben noch keine Methode </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einem Koordinatenparameter, also erstellen Sie sie. </font><font style="vertical-align: inherit;">Konvertieren Sie in die Koordinaten der Verschiebungen und erhalten Sie die Zelle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates coordinates</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = coordinates.X + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[x + z * cellCountX]; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b59/490/9f2/b594909f28de1c2d52c954d312d7b90f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der untere Teil des Pinsels, Größe 2.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir bedecken den Rest des Pinsels und führen einen Zyklus von oben nach unten zur Mitte durch. </font><font style="vertical-align: inherit;">In diesem Fall wird die Logik gespiegelt und die zentrale Zeile muss ausgeschlossen werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX = center.coordinates.X; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerZ = center.coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ - brushSize; z &lt;= centerZ; z++, r++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = centerX - r; x &lt;= centerX + brushSize; x++) { EditCell(hexGrid.GetCell(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z))); } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ + brushSize; z &gt; centerZ; z--, r++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = centerX - brushSize; x &lt;= centerX + r; x++) { EditCell(hexGrid.GetCell(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z))); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e8/add/c7c/9e8addc7cf0012210cdd5dc0588bc6cf.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der gesamte Pinsel, Größe 2.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies funktioniert, es sei denn, unser Pinsel geht über die Ränder des Rasters hinaus. </font><font style="vertical-align: inherit;">In diesem Fall erhalten wir eine Ausnahme für einen Index außerhalb des Bereichs. </font><font style="vertical-align: inherit;">Um dies zu vermeiden, überprüfen Sie die Grenzen </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und kehren Sie zurück, </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn eine nicht vorhandene Zelle angefordert wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates coordinates</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || z &gt;= cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = coordinates.X + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || x &gt;= cellCountX) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[x + z * cellCountX]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um eine Nullreferenzausnahme zu vermeiden, </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss vor dem Bearbeiten geprüft werden, ob die Zelle tatsächlich vorhanden ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mehrere Pinselgrößen verwenden. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schalten Sie die Sichtbarkeit der Zellenbeschriftung um </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meistens müssen wir keine Zelletiketten sehen. </font><font style="vertical-align: inherit;">Machen wir sie also optional. </font><font style="vertical-align: inherit;">Da jedes Stück seine eigene Leinwand schafft, fügen Sie </font><font style="vertical-align: inherit;">ein Verfahren </font></font><code>ShowUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn die Benutzeroberfläche sichtbar sein soll, aktivieren wir die Zeichenfläche. </font><font style="vertical-align: inherit;">Andernfalls deaktivieren Sie es.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { gridCanvas.gameObject.SetActive(visible); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lassen Sie uns die Benutzeroberfläche standardmäßig ausblenden. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; ShowUI(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da das Auftreten von UI - </font><font style="vertical-align: inherit;">Schalter für die gesamte Karte, fügen Sie </font><font style="vertical-align: inherit;">eine Methode </font></font><code>ShowUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es leitet die Anfrage nur an seine Fragmente weiter.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].ShowUI(visible); } }</code> </pre> <br> <code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erhält die gleiche Methode und leitet die Anforderung an das Raster weiter. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { hexGrid.ShowUI(visible); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schließlich können wir der Benutzeroberfläche einen Schalter hinzufügen und diese verbinden. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/120/637/740/120637740d174168d298407ec129c0d3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tag-Sichtbarkeitsschalter. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 6: Flüsse </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hinzufügen von Flüssen zu Zellen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Drag &amp; Drop-Unterstützung zum Zeichnen von Flüssen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flussbetten schaffen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden mehrerer Netze pro Fragment. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen Sie einen gemeinsamen Listenpool. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation und Animation von fließendem Wasser. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im vorherigen Teil haben wir über die Unterstützung großer Karten gesprochen. </font><font style="vertical-align: inherit;">Jetzt können wir zu größeren Reliefelementen übergehen. </font><font style="vertical-align: inherit;">Dieses Mal werden wir über die Flüsse sprechen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/e66/4fb/56ae664fb799dd59d5d8e85397945937.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flüsse fließen aus den Bergen.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flusszellen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt drei Möglichkeiten, einem Sechseckgitter Flüsse hinzuzufügen. Der erste Weg ist, sie von Zelle zu Zelle fließen zu lassen. So wird es in Endless Legend implementiert. Die zweite Möglichkeit besteht darin, sie zwischen den Zellen von Kante zu Kante fließen zu lassen. So wird es in Civilization 5 implementiert. Der dritte Weg besteht darin, überhaupt keine speziellen Flussstrukturen zu schaffen, sondern Wasserzellen zu verwenden, um sie vorzuschlagen. So werden die Flüsse in Age of Wonders 3 implementiert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In unserem Fall sind die Ränder der Zellen bereits von Hängen und Klippen besetzt. Dies lässt wenig Raum für Flüsse. Deshalb werden wir sie von Zelle zu Zelle fließen lassen. Dies bedeutet, dass in jeder Zelle entweder kein Fluss vorhanden ist oder ein Fluss entlang des Flusses fließt oder dass sich ein Anfang oder ein Ende des Flusses darin befindet. In den Zellen, entlang derer der Fluss fließt, kann er gerade fließen und eine oder zwei Schritte drehen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/db2/2a4/e7fdb22a4346f9281865ad95a1946f75.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fünf mögliche Flusskonfigurationen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden das Verzweigen oder Zusammenführen von Flüssen nicht unterstützen. </font><font style="vertical-align: inherit;">Dies wird die Dinge noch komplizierter machen, insbesondere den Wasserfluss. </font><font style="vertical-align: inherit;">Wir werden auch nicht von großen Wassermengen verwirrt sein. </font><font style="vertical-align: inherit;">Wir werden sie in einem anderen Tutorial betrachten.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flussverfolgung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zelle, entlang der der Fluss fließt, kann gleichzeitig als ein ein- und ausgehender Fluss betrachtet werden. </font><font style="vertical-align: inherit;">Wenn es den Anfang eines Flusses enthält, hat es nur einen abgehenden Fluss. </font><font style="vertical-align: inherit;">Und wenn es das Ende des Flusses enthält, dann hat es nur einen ankommenden Fluss. </font><font style="vertical-align: inherit;">Wir können diese Informationen unter </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwendung von zwei Booleschen Werten </font><font style="vertical-align: inherit;">speichern </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasIncomingRiver, hasOutgoingRiver;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das reicht aber nicht. </font><font style="vertical-align: inherit;">Wir müssen auch die Richtung dieser Flüsse kennen. </font><font style="vertical-align: inherit;">Im Fall eines abgehenden Flusses zeigt es an, wohin er sich bewegt. </font><font style="vertical-align: inherit;">Bei einem ankommenden Fluss wird angezeigt, woher er stammt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasIncomingRiver, hasOutgoingRiver; HexDirection incomingRiver, outgoingRiver;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Informationen werden beim Triangulieren von Zellen benötigt, daher werden Eigenschaften hinzugefügt, um Zugriff darauf zu erhalten. </font><font style="vertical-align: inherit;">Wir werden es nicht unterstützen, sie direkt zuzuweisen. </font><font style="vertical-align: inherit;">Dazu fügen wir eine separate Methode hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasIncomingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasOutgoingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasOutgoingRiver; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection IncomingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> incomingRiver; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection OutgoingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine wichtige Frage ist, ob sich in der Zelle ein Fluss befindet, unabhängig von den Details. </font><font style="vertical-align: inherit;">Fügen wir daher auch hierfür eine Eigenschaft hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver || hasOutgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere logische Frage: ist der Anfang oder das Ende des Flusses in der Zelle. </font><font style="vertical-align: inherit;">Wenn der Zustand des ein- und ausgehenden Flusses unterschiedlich ist, ist dies nur der Fall. </font><font style="vertical-align: inherit;">Daher werden wir dies zu einer weiteren Eigenschaft machen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasRiverBeginOrEnd { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver != hasOutgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und schließlich ist es hilfreich zu wissen, ob der Fluss durch einen bestimmten Kamm fließt, ob er ein- oder ausgeht. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasRiverThroughEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver &amp;&amp; incomingRiver == direction || hasOutgoingRiver &amp;&amp; outgoingRiver == direction; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flussentfernung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir einer Zelle einen Fluss hinzufügen, implementieren wir zunächst die Unterstützung für die Flussentfernung. </font><font style="vertical-align: inherit;">Zunächst werden wir eine Methode schreiben, um nur den abgehenden Teil des Flusses zu entfernen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn sich in der Zelle kein abfließender Fluss befindet, muss nichts unternommen werden. </font><font style="vertical-align: inherit;">Andernfalls schalten Sie es aus und führen Sie das Update durch.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasOutgoingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist aber noch nicht alles. </font><font style="vertical-align: inherit;">Der abgehende Fluss muss irgendwo weitergehen. </font><font style="vertical-align: inherit;">Daher muss es einen Nachbarn mit dem ankommenden Fluss geben. </font><font style="vertical-align: inherit;">Wir müssen sie auch loswerden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasOutgoingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Refresh(); HexCell neighbor = GetNeighbor(outgoingRiver); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbor.Refresh(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kann ein Fluss nicht aus einer Karte fließen?</font></font></b> <div class="spoiler_text">      ,     .     ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Entfernen eines Flusses aus einer Zelle ändert nur das Erscheinungsbild dieser Zelle. </font><font style="vertical-align: inherit;">Im Gegensatz zur Bearbeitungshöhe oder -farbe hat dies keine Auswirkungen auf die Nachbarn. </font><font style="vertical-align: inherit;">Daher müssen wir nur die Zelle selbst aktualisieren, nicht aber ihre Nachbarn.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasOutgoingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; RefreshSelfOnly(); HexCell neighbor = GetNeighbor(outgoingRiver); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbor.RefreshSelfOnly(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Methode </font></font><code>RefreshSelfOnly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aktualisiert einfach das Fragment, zu dem die Zelle gehört. </font><font style="vertical-align: inherit;">Da wir den Fluss während der Netzinitialisierung nicht ändern, müssen wir uns keine Sorgen machen, wenn bereits ein Fragment zugewiesen wurde.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshSelfOnly</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunk.Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Entfernen eingehender Flüsse funktioniert genauso. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveIncomingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasIncomingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; RefreshSelfOnly(); HexCell neighbor = GetNeighbor(incomingRiver); neighbor.hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbor.RefreshSelfOnly(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und die Entfernung des gesamten Flusses bedeutet einfach die Entfernung sowohl der ankommenden als auch der abgehenden Teile des Flusses. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RemoveOutgoingRiver(); RemoveIncomingRiver(); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flüsse hinzufügen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Entstehung von Flüssen zu unterstützen, benötigen wir eine Methode zur Spezifizierung des abgehenden Flusses der Zelle. </font><font style="vertical-align: inherit;">Er muss alle vorherigen ausgehenden Flüsse neu definieren und den entsprechenden ankommenden Fluss festlegen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zunächst müssen wir nichts tun, wenn der Fluss bereits existiert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasOutgoingRiver &amp;&amp; outgoingRiver == direction) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als nächstes müssen wir sicherstellen, dass es einen Nachbarn in der richtigen Richtung gibt. </font><font style="vertical-align: inherit;">Außerdem können Flüsse nicht fließen. </font><font style="vertical-align: inherit;">Daher müssen wir die Operation abschließen, wenn der Nachbar höher ist.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || elevation &lt; neighbor.elevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als nächstes müssen wir den vorherigen abgehenden Fluss räumen. </font><font style="vertical-align: inherit;">Und wir müssen auch den ankommenden Fluss entfernen, wenn er einem neuen abgehenden Fluss überlagert ist.</font></font><br><br><pre> <code class="cs hljs"> RemoveOutgoingRiver(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasIncomingRiver &amp;&amp; incomingRiver == direction) { RemoveIncomingRiver(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt können wir mit dem Aufbau des ausgehenden Flusses fortfahren. </font></font><br><br><pre> <code class="cs hljs"> hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; outgoingRiver = direction; RefreshSelfOnly();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und vergessen Sie nicht, den eingehenden Fluss für eine andere Zelle festzulegen, nachdem Sie den aktuell eingehenden Fluss entfernt haben, falls vorhanden. </font></font><br><br><pre> <code class="cs hljs"> neighbor.RemoveIncomingRiver(); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; neighbor.incomingRiver = direction.Opposite(); neighbor.RefreshSelfOnly();</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flüsse losfließen lassen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir es nun möglich gemacht haben, nur die richtigen Flüsse hinzuzufügen, können andere Aktionen immer noch die falschen erzeugen. </font><font style="vertical-align: inherit;">Wenn wir die Höhe der Zelle ändern, müssen wir erneut mit Nachdruck sicherstellen, dass die Flüsse nur nach unten fließen können. </font><font style="vertical-align: inherit;">Alle unregelmäßigen Flüsse müssen entfernt werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasOutgoingRiver &amp;&amp; elevation &lt; GetNeighbor(outgoingRiver).elevation ) { RemoveOutgoingRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasIncomingRiver &amp;&amp; elevation &gt; GetNeighbor(incomingRiver).elevation ) { RemoveIncomingRiver(); } Refresh(); } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flüsse wechseln </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Flussbearbeitung zu unterstützen, müssen wir der Benutzeroberfläche einen Flussschalter hinzufügen. </font><font style="vertical-align: inherit;">Tatsächlich. </font><font style="vertical-align: inherit;">Wir brauchen Unterstützung für drei Bearbeitungsmodi. </font><font style="vertical-align: inherit;">Wir müssen entweder die Flüsse ignorieren oder sie hinzufügen oder löschen. </font><font style="vertical-align: inherit;">Wir können eine einfache Helfer-Aufzählung von Schaltern verwenden, um den Status zu verfolgen. </font><font style="vertical-align: inherit;">Da wir es nur im Editor verwenden, können wir es innerhalb der Klasse </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zusammen mit dem Feld für den Flussmodus definieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> OptionalToggle { Ignore, Yes, No } OptionalToggle riverMode;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und wir brauchen eine Methode, um das Flussregime über die Benutzeroberfläche zu ändern. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRiverMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { riverMode = (OptionalToggle)mode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das Flussregime zu steuern, fügen Sie der Benutzeroberfläche drei Schalter hinzu und verbinden Sie sie mit der neuen Umschaltgruppe, wie wir es mit den Farben getan haben. </font><font style="vertical-align: inherit;">Ich habe die Schalter so konfiguriert, dass sich ihre Beschriftungen unter den Kontrollkästchen befinden. </font><font style="vertical-align: inherit;">Aus diesem Grund bleiben sie dünn genug, um alle drei Optionen in einer Zeile unterzubringen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/1bf/d9c/0f51bfd9ce2a73bc23f1ef99cbd4b24e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UI Flüsse</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum nicht eine Dropdown-Liste verwenden?</font></font></b> <div class="spoiler_text">  ,    .   dropdown list  Unity        Play.    ,      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Drag &amp; Drop-Erkennung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um einen Fluss zu schaffen, brauchen wir sowohl eine Zelle als auch eine Richtung. </font><font style="vertical-align: inherit;">Im Moment </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">liefert uns diese Information nicht. </font><font style="vertical-align: inherit;">Daher müssen wir Drag &amp; Drop-Unterstützung von einer Zelle zur anderen hinzufügen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir müssen wissen, ob dieser Widerstand korrekt ist, und auch seine Richtung bestimmen. </font><font style="vertical-align: inherit;">Und um das Ziehen und Ablegen zu erkennen, müssen wir uns an die vorherige Zelle erinnern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isDrag; HexDirection dragDirection; HexCell previousCell;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das Ziehen nicht ausgeführt wird, ist dies in der vorherigen Zelle zunächst nicht der Fall. </font><font style="vertical-align: inherit;">Das heißt, wenn keine Eingabe erfolgt oder wir nicht mit der Karte interagieren, müssen Sie ihr einen Wert zuweisen </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetMouseButton(<span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; !EventSystem.current.IsPointerOverGameObject() ) { HandleInput(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { EditCells(hexGrid.GetCell(hit.point)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die aktuelle Zelle ist diejenige, die wir gefunden haben, indem wir den Strahl mit dem Netz gekreuzt haben. </font><font style="vertical-align: inherit;">Nach dem Bearbeiten der Zellen wird es aktualisiert und wird zur vorherigen Zelle für ein neues Update.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { HexCell currentCell = hexGrid.GetCell(hit.point); EditCells(currentCell); previousCell = currentCell; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir die aktuelle Zelle ermittelt haben, können wir sie gegebenenfalls mit der vorherigen Zelle vergleichen. </font><font style="vertical-align: inherit;">Wenn wir zwei verschiedene Zellen erhalten, haben wir möglicherweise das richtige Drag &amp; Drop und müssen dies überprüfen. </font><font style="vertical-align: inherit;">Ansonsten ist dies definitiv kein Drag &amp; Drop.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { HexCell currentCell = hexGrid.GetCell(hit.point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isDrag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } EditCells(currentCell); previousCell = currentCell; isDrag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie überprüfen wir das Drag &amp; Drop? </font><font style="vertical-align: inherit;">Überprüfen, ob die aktuelle Zelle ein Nachbar der vorherigen ist. </font><font style="vertical-align: inherit;">Wir überprüfen dies, indem wir seine Nachbarn in einem Zyklus umgehen. </font><font style="vertical-align: inherit;">Wenn wir eine Übereinstimmung finden, erkennen wir auch sofort die Richtung des Ziehens.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateDrag</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell currentCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( dragDirection = HexDirection.NE; dragDirection &lt;= HexDirection.NW; dragDirection++ ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousCell.GetNeighbor(dragDirection) == currentCell) { isDrag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } isDrag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Werden wir ruckartige Drags erzeugen?</font></font></b> <div class="spoiler_text">       ,          .         «» ,     . <br><br>    ,   .            . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen ändern </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt, da wir Drag &amp; Drop erkennen können, können wir ausgehende Flüsse definieren. </font><font style="vertical-align: inherit;">Wir können auch Flüsse entfernen, dafür ist keine Drag &amp; Drop-Unterstützung erforderlich.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.No) { cell.RemoveRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag &amp;&amp; riverMode == OptionalToggle.Yes) { previousCell.SetOutgoingRiver(dragDirection); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Code zeichnet den Fluss von der vorherigen Zelle in die aktuelle. </font><font style="vertical-align: inherit;">Aber er ignoriert die Größe des Pinsels. </font><font style="vertical-align: inherit;">Das ist ziemlich logisch, aber zeichnen wir die Flüsse für alle Zellen, die von der Bürste geschlossen werden. </font><font style="vertical-align: inherit;">Dies kann durch Ausführen von Operationen an der bearbeiteten Zelle erfolgen. </font><font style="vertical-align: inherit;">In unserem Fall müssen wir sicherstellen, dass tatsächlich eine andere Zelle existiert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag &amp;&amp; riverMode == OptionalToggle.Yes) { HexCell otherCell = cell.GetNeighbor(dragDirection.Opposite()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherCell) { otherCell.SetOutgoingRiver(dragDirection); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir die Flüsse bearbeiten, aber noch nicht sehen. </font><font style="vertical-align: inherit;">Wir können überprüfen, ob dies funktioniert, indem wir die geänderten Zellen im Debug-Inspektor untersuchen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fe/927/46f/4fe92746f97fc517dc0d1da7c0aeee62.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Zelle mit einem Fluss im Debug-Inspektor.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist ein Debug-Inspektor?</font></font></b> <div class="spoiler_text">             .        .    ,     . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flussbetten zwischen Zellen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Triangulation eines Flusses müssen zwei Teile berücksichtigt werden: die Lage des Flussbettes und das durch ihn fließende Wasser. </font><font style="vertical-align: inherit;">Zuerst werden wir einen Kanal erstellen und das Wasser für später verlassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der einfachste Teil des Flusses ist dort, wo er in Verbindungsstellen zwischen Zellen fließt. </font><font style="vertical-align: inherit;">Während wir diesen Bereich mit einem Streifen von drei Quad triangulieren. </font><font style="vertical-align: inherit;">Wir können ein Flussbett hinzufügen, indem wir das mittlere Quad absenken und zwei Kanalwände hinzufügen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/545/b3c/b93/545b3cb9373e9479011916513c3c51da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinzufügen eines Flusses zu einem Rippenstreifen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dafür werden im Fall des Flusses zwei zusätzliche Quads benötigt und ein Kanal mit zwei vertikalen Wänden erstellt. </font><font style="vertical-align: inherit;">Ein alternativer Ansatz ist die Verwendung von vier Quad. </font><font style="vertical-align: inherit;">Dann senken wir den mittleren Gipfel, um ein Bett mit schrägen Wänden zu schaffen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/757/7d9/ac1/7577d9ac1978be05cbdda0f8925c75d0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immer vier Quad. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die ständige Verwendung der gleichen Anzahl von Vierecken ist praktisch. Wählen Sie diese Option.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Edge Tops hinzufügen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Übergang von drei zu vier pro Kante erfordert die Erstellung eines zusätzlichen Scheitelpunkts der Kante. </font><font style="vertical-align: inherit;">Rewrite </font></font><code>EdgeVertices</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, erste Umbenennung </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>v5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und dann umbenannt </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aktionen in dieser Reihenfolge stellen sicher, dass der gesamte Code weiterhin auf die richtigen Scheitelpunkte verweist. </font><font style="vertical-align: inherit;">Verwenden Sie dazu die Umbenennungs- oder Refactor-Option Ihres Editors, damit die Änderungen überall angewendet werden. </font><font style="vertical-align: inherit;">Andernfalls müssen Sie den gesamten Code manuell überprüfen und Änderungen vornehmen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 v1, v2, v4, v5;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie nach dem Umbenennen alles hinzu </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 v1, v2, v3, v4, v5;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie dem Konstruktor einen neuen Scheitelpunkt hinzu. </font><font style="vertical-align: inherit;">Es befindet sich in der Mitte zwischen den Eckgipfeln. </font><font style="vertical-align: inherit;">Außerdem sollten andere Eckpunkte jetzt in ½ und ¾ und nicht in &amp; frac13; </font><font style="vertical-align: inherit;">und &amp; frac23;</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EdgeVertices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 corner1, Vector3 corner2</span></span></span><span class="hljs-function">)</span></span> { v1 = corner1; v2 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); v3 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); v4 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.75f</span></span>); v5 = corner2; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinzufügen </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">hinzufügen </font></font><code>TerraceLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EdgeVertices </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices a, EdgeVertices b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { EdgeVertices result; result.v1 = HexMetrics.TerraceLerp(a.v1, b.v1, step); result.v2 = HexMetrics.TerraceLerp(a.v2, b.v2, step); result.v3 = HexMetrics.TerraceLerp(a.v3, b.v3, step); result.v4 = HexMetrics.TerraceLerp(a.v4, b.v4, step); result.v5 = HexMetrics.TerraceLerp(a.v5, b.v5, step); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss </font><font style="vertical-align: inherit;">ich </font><font style="vertical-align: inherit;">einen zusätzlichen Scheitelpunkt in die Fächerdreiecke der Rippe aufnehmen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, Color color</span></span></span><span class="hljs-function">)</span></span> { AddTriangle(center, edge.v1, edge.v2); AddTriangleColor(color); AddTriangle(center, edge.v2, edge.v3); AddTriangleColor(color); AddTriangle(center, edge.v3, edge.v4); AddTriangleColor(color); AddTriangle(center, edge.v4, edge.v5); AddTriangleColor(color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und auch in seinen Streifen von Vierecken. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2 </span></span></span><span class="hljs-function">)</span></span> { AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); AddQuadColor(c1, c2); AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); AddQuadColor(c1, c2); AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); AddQuadColor(c1, c2); AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); AddQuadColor(c1, c2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/819/89d/599/81989d5996d7c2832e3dd7f61b4a9bb1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/625/9b1/6a2/6259b16a2776344c51725d32d70001e8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergleich von vier und fünf Eckpunkten pro Kante.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Höhe des Flussbettes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben den Kanal erstellt, indem wir die untere Oberseite der Rippe abgesenkt haben. </font><font style="vertical-align: inherit;">Es bestimmt die vertikale Position des Flussbettes. </font><font style="vertical-align: inherit;">Obwohl die genaue vertikale Position jeder Zelle verzerrt ist, müssen wir in Zellen mit derselben Höhe die gleiche Höhe des Flussbettes beibehalten. </font><font style="vertical-align: inherit;">Dank dieses Wassers muss es nicht stromaufwärts fließen. </font><font style="vertical-align: inherit;">Darüber hinaus sollte das Bett niedrig genug sein, um auch bei den am stärksten abgelenkten vertikalen Zellen darunter zu bleiben, während gleichzeitig genügend Platz für Wasser bleibt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie diesen Versatz auf ein </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und drücken Sie ihn als Höhe aus. </font><font style="vertical-align: inherit;">Offsets einer Ebene reichen aus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> streamBedElevationOffset = <span class="hljs-number"><span class="hljs-number">-1f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können diese Metrik verwenden, um Eigenschaften hinzuzufügen </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die vertikale Position des Zellflussbettes zu erhalten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> StreamBedY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (elevation + HexMetrics.streamBedElevationOffset) * HexMetrics.elevationStep; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kanal erstellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einer der sechs dreieckigen Teile einer Zelle trianguliert ist, können wir bestimmen, ob ein Fluss entlang seines Randes fließt. </font><font style="vertical-align: inherit;">Wenn ja, können wir den mittleren Gipfel der Rippe auf die Höhe des Flussbettes absenken.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; EdgeVertices e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; } TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, e); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0d/a57/028/d0da570288985442d990858b2831c07a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern Sie den mittleren Scheitelpunkt der Rippe. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können sehen, wie die ersten Anzeichen des Flusses erscheinen, aber im Relief entstehen Löcher. </font><font style="vertical-align: inherit;">Um sie zu schließen, müssen wir eine andere Kante ändern und dann die Verbindung triangulieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 bridge = HexMetrics.GetBridge(direction); bridge.y = neighbor.Position.y - cell.Position.y; EdgeVertices e2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( e1.v1 + bridge, e1.v5 + bridge ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e2.v3.y = neighbor.StreamBedY; } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4c/aa9/5f4/b4caa95f424004569e7876bc19c73a20.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abgeschlossene Kanäle der Rippengelenke. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flussbetten durch eine Zelle </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir die richtigen Flussbetten zwischen den Zellen. Wenn der Fluss durch die Zelle fließt, enden die Kanäle immer in ihrer Mitte. Um dieses Problem zu lösen, muss es funktionieren. Beginnen wir mit dem Fall, dass ein Fluss direkt von einer Kante zur anderen durch eine Zelle fließt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es keinen Fluss gibt, kann jeder Teil der Zelle ein einfacher Fan von Dreiecken sein. Wenn der Fluss jedoch direkt fließt, muss ein Kanal eingefügt werden. Tatsächlich müssen wir den zentralen Scheitelpunkt in eine Linie strecken und so die beiden mittleren Dreiecke in Vierecke verwandeln. Dann verwandelt sich der Fächer der Dreiecke in ein Trapez.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a9/919/ffb/9a9919ffbb99bcded8d44f45e62c3955.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir fügen den Kanal in das Dreieck ein. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solche Kanäle sind viel länger als diejenigen, die durch die Verbindung von Zellen verlaufen. </font><font style="vertical-align: inherit;">Dies wird deutlich, wenn die Scheitelpunktpositionen verzerrt sind. </font><font style="vertical-align: inherit;">Teilen wir daher das Trapez in zwei Segmente, indem wir einen weiteren Satz von Scheitelpunktkanten in die Mitte zwischen der Mitte und der Kante einfügen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/650/f94/109/650f9410923cb781f145b5211dbe4950.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kanal-Triangulation. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da sich die Triangulation mit einem Fluss stark von der Triangulation ohne Fluss unterscheidet, erstellen wir eine separate Methode dafür. </font><font style="vertical-align: inherit;">Wenn wir einen Fluss haben, verwenden wir diese Methode, andernfalls hinterlassen wir einen Fan von Dreiecken.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; EdgeVertices e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; TriangulateWithRiver(direction, cell, center, e); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeFan(center, e, cell.Color); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/928/f0f/526/928f0f526852960fce6c37bdb480b5bc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Löcher, in denen es Flüsse geben sollte. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deaktivieren Sie vorübergehend die Zellverzerrung, um besser zu sehen, was passiert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 4f;</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2aa/f49/ae3/2aaf49ae366805585727f1a1ed11c2aa.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unverzerrte Spitzen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation direkt durch die Zelle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um einen Kanal direkt durch einen Teil der Zelle zu erstellen, müssen wir die Mitte in eine Linie strecken. </font><font style="vertical-align: inherit;">Diese Linie sollte die gleiche Breite wie der Kanal haben. </font><font style="vertical-align: inherit;">Wir können den linken Scheitelpunkt finden, indem wir ¼ der Entfernung von der Mitte zur ersten Ecke des vorherigen Teils verschieben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { Vector3 centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ähnliches gilt für den rechten Scheitelpunkt. </font><font style="vertical-align: inherit;">In diesem Fall benötigen wir die zweite Ecke des nächsten Teils.</font></font><br><br><pre> <code class="cs hljs"> Vector3 centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; Vector3 centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Mittellinie kann durch Erstellen von Scheitelpunktkanten zwischen der Mitte und der Kante gefunden werden. </font></font><br><br><pre> <code class="cs hljs"> EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(centerL, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(centerR, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ändern Sie als Nächstes den mittleren Scheitelpunkt der Mittelrippe sowie die Mitte, da diese zu den unteren Punkten des Kanals werden. </font></font><br><br><pre> <code class="cs hljs"> m.v3.y = center.y = e.v3.y;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Raum zwischen der Mittellinie und der Kantenlinie füllen.</font></font><br><br><pre> <code class="cs hljs"> TriangulateEdgeStrip(m, cell.Color, e, cell.Color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ab/050/b30/3ab050b301f8815479142c5b8feae26e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komprimierte Kanäle.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leider sehen die Kanäle komprimiert aus. Dies geschieht, weil die mittleren Eckpunkte der Rippe zu nahe beieinander liegen. Warum ist das passiert? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir annehmen, dass die Länge der Außenkante 1 ist, beträgt die Länge der Mittellinie ½. Da sich die mittlere Kante in der Mitte zwischen ihnen befindet, sollte ihre Länge gleich ¾ sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kanalbreite beträgt ½ und sollte konstant bleiben. Da die Länge der Mittelkante ¾ beträgt, bleibt laut &amp; frac18; nur ¼ übrig. auf beiden Seiten des Kanals.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e1/25f/037/2e125f03727f078ccfd094a29ad4d596.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relative Längen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Länge der Mittelkante ¾ beträgt, ist &amp; frac18; </font><font style="vertical-align: inherit;">wird relativ zur Länge der Mittelrippe gleich &amp; frac16; </font><font style="vertical-align: inherit;">Dies bedeutet, dass der zweite und vierte Eckpunkt mit Sechsteln und nicht mit Vierteln interpoliert werden sollten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können eine solche alternative Interpolation unterstützen, indem wir sie einem </font></font><code>EdgeVertices</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anderen Konstruktor </font><font style="vertical-align: inherit;">hinzufügen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Anstelle fester Interpolationen für </font></font><code>v2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verwenden </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir einen Parameter.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EdgeVertices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 corner1, Vector3 corner2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> outerStep</span></span></span><span class="hljs-function">)</span></span> { v1 = corner1; v2 = Vector3.Lerp(corner1, corner2, outerStep); v3 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); v4 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">1f</span></span> - outerStep); v5 = corner2; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir es mit &amp; frac16; </font><font style="vertical-align: inherit;">c </font></font><code>HexMesh.TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(centerL, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(centerR, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span> );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4a/df8/cb5/c4adf8cb5aa6b1685f6d5c592976ea3b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Direkte Kanäle. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir den Kanal gerade gemacht haben, können wir zum zweiten Teil des Trapezes gehen. </font><font style="vertical-align: inherit;">In diesem Fall können wir den Rippenstreifen nicht verwenden, daher müssen wir dies manuell tun. </font><font style="vertical-align: inherit;">Lassen Sie uns zuerst Dreiecke an den Seiten erstellen.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(centerL, m.v1, m.v2); AddTriangleColor(cell.Color); AddTriangle(centerR, m.v4, m.v5); AddTriangleColor(cell.Color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10b/dc7/a5b/10bdc7a5b1d32d03dbc155a2d00bbfb5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seitendreiecke. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sieht gut aus, also füllen wir den verbleibenden Raum mit zwei Vierecken und erstellen den letzten Teil des Kanals.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(centerL, m.v1, m.v2); AddTriangleColor(cell.Color); AddQuad(centerL, center, m.v2, m.v3); AddQuadColor(cell.Color); AddQuad(center, centerR, m.v3, m.v4); AddQuadColor(cell.Color); AddTriangle(centerR, m.v4, m.v5); AddTriangleColor(cell.Color);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tatsächlich haben wir keine Alternative, </font></font><code>AddQuadColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die nur einen Parameter erfordert. </font><font style="vertical-align: inherit;">Wir haben es zwar nicht gebraucht. </font><font style="vertical-align: inherit;">Also lasst es uns schaffen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color color</span></span></span><span class="hljs-function">)</span></span> { colors.Add(color); colors.Add(color); colors.Add(color); colors.Add(color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af0/b62/c32/af0b62c3232b36cd0a136b1fc009b7dd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gerade Kanäle abgeschlossen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation starten und beenden </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Triangulation eines Teils, der nur den Anfang oder das Ende eines Flusses hat, ist ganz anders und erfordert daher eine eigene Methode. </font><font style="vertical-align: inherit;">Daher werden wir dies einchecken </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die entsprechende Methode aufrufen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { TriangulateWithRiverBeginOrEnd(direction, cell, center, e); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithRiver(direction, cell, center, e); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall möchten wir den Kanal in der Mitte vervollständigen, verwenden dafür jedoch immer noch zwei Stufen. </font><font style="vertical-align: inherit;">Daher erstellen wir erneut die mittlere Kante zwischen der Mitte oder der Kante. </font><font style="vertical-align: inherit;">Da wir den Kanal vervollständigen möchten, freuen wir uns sehr, dass er komprimiert wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit der Kanal nicht zu schnell flach wird, ordnen wir die Höhe des Flussbettes dem mittleren Gipfel zu. </font><font style="vertical-align: inherit;">Das Zentrum muss jedoch nicht geändert werden.</font></font><br><br><pre> <code class="cs hljs"> m.v3.y = e.v3.y;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir können mit einem Rippenstreifen und einem Fächer triangulieren. </font></font><br><br><pre> <code class="cs hljs"> TriangulateEdgeStrip(m, cell.Color, e, cell.Color); TriangulateEdgeFan(center, m, cell.Color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16b/0c5/9e0/16b0c59e0999f2a505e709648c1e1af7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start- und Endpunkte.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> One-Step-Turns </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betrachten Sie als nächstes die scharfen Kurven im Zickzack zwischen benachbarten Zellen. </font><font style="vertical-align: inherit;">Wir werden auch damit umgehen </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Daher müssen wir bestimmen, mit welcher Art von Fluss wir arbeiten.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/523/c03/e37/523c03e370096f804df6b84a97dbdfbf.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zick-Zack-Fluss. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn in der Zelle ein Fluss fließt, der sowohl in die entgegengesetzte Richtung als auch in die Richtung fließt, mit der wir arbeiten, sollte dies ein gerader Fluss sein. </font><font style="vertical-align: inherit;">In diesem Fall können wir die bereits berechnete Mittellinie speichern. </font><font style="vertical-align: inherit;">Andernfalls kehrt es zu einem Punkt zurück und faltet die Mittellinie.</font></font><br><br><pre> <code class="cs hljs"> Vector3 centerL, centerR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = centerR = center; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90c/992/4c0/90c9924c049cf8033e7480c90b74b903.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gekräuselte Zickzacke. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können scharfe Kurven erkennen, indem wir prüfen, ob in der Zelle ein Fluss durch den nächsten oder vorherigen Teil der Zelle fließt. </font><font style="vertical-align: inherit;">Wenn ja, müssen wir die Mittellinie an der Kante zwischen diesem und dem benachbarten Teil ausrichten. </font><font style="vertical-align: inherit;">Wir können dies tun, indem wir die entsprechende Seite der Linie in der Mitte zwischen der Mitte und dem gemeinsamen Winkel platzieren. </font><font style="vertical-align: inherit;">Die andere Seite der Linie wird dann zur Mitte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { centerL = center; centerR = Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { centerL = Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); centerR = center; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = centerR = center; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem wir entschieden haben, wo sich der linke und der rechte Punkt befinden, können wir das resultierende Zentrum bestimmen, indem wir sie mitteln. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { … } center = Vector3.Lerp(centerL, centerR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f14/cc6/4f9/f14cc64f953da69fb270ff2adf613b2e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versetzte Mittelrippe. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl der Kanal auf beiden Seiten die gleiche Breite hat, sieht er ziemlich komprimiert aus. </font><font style="vertical-align: inherit;">Dies wird durch Drehen der Mittellinie um 60 ° verursacht. </font><font style="vertical-align: inherit;">Sie können diesen Effekt glätten, indem Sie die Breite der Mittellinie leicht erhöhen. </font><font style="vertical-align: inherit;">Anstatt mit ½ zu interpolieren, verwenden wir &amp; frac23;</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { centerL = center; centerR = Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { centerL = Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); centerR = center; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28c/c01/ea3/28cc01ea3d203243a1dfe49cde5e9802.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zickzack ohne Kompression.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zweistufige Kurven </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die restlichen Fälle liegen zwischen Zickzack und geraden Flüssen. </font><font style="vertical-align: inherit;">Dies sind zweistufige Kurven, die sanft geschwungene Flüsse erzeugen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67d/bab/9b2/67dbab9b235833d69b3201c9b38ac653.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der sich schlängelnde Fluss. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um zwischen zwei möglichen Orientierungen zu unterscheiden, müssen wir verwenden </font></font><code>direction.Next().Next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aber lassen Sie </font><font style="vertical-align: inherit;">uns machen es bequemer durch Hinzufügen von </font></font><code>HexDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweiterungsmethoden </font></font><code>Next2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>Previous2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Previous2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { direction -= <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction &gt;= HexDirection.NE ? direction : (direction + <span class="hljs-number"><span class="hljs-number">6</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Next2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { direction += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction &lt;= HexDirection.NW ? direction : (direction - <span class="hljs-number"><span class="hljs-number">6</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zurück zu </font></font><code>HexMesh.TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jetzt können wir die Richtung unseres mäandrierenden Flusses mit erkennen </font></font><code>direction.Next2()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { centerL = center; centerR = Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { centerL = Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); centerR = center; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next2())) { centerL = centerR = center; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = centerR = center; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesen beiden letzten Fällen müssen wir die Mittellinie auf den Teil der Zelle verschieben, der sich auf der Innenseite der Kurve befindet. </font><font style="vertical-align: inherit;">Wenn wir einen Vektor in der Mitte einer festen Kante hätten, könnten wir ihn verwenden, um den Endpunkt zu positionieren. </font><font style="vertical-align: inherit;">Stellen wir uns vor, wir haben eine Methode dafür.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next2())) { centerL = center; centerR = center + HexMetrics.GetSolidEdgeMiddle(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = center + HexMetrics.GetSolidEdgeMiddle(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; centerR = center; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Natürlich müssen wir jetzt eine solche Methode hinzufügen </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Er muss nur zwei Vektoren benachbarter Winkel mitteln und den Integritätskoeffizienten anwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSolidEdgeMiddle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] + corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]) * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> * solidFactor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be1/058/429/be1058429e3d36cd25b8e1da0c1be77a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leicht komprimierte Kurven. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsere Mittellinien sind jetzt korrekt um 30 ° gedreht. </font><font style="vertical-align: inherit;">Sie sind aber nicht lang genug, weshalb die Kanäle etwas komprimiert sind. </font><font style="vertical-align: inherit;">Dies geschieht, weil der Mittelpunkt der Rippe näher an der Mitte liegt als der Winkel der Rippe. </font><font style="vertical-align: inherit;">Sein Abstand entspricht dem inneren Radius, nicht dem äußeren. </font><font style="vertical-align: inherit;">Das heißt, wir arbeiten im falschen Maßstab. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir konvertieren bereits von extern zu intern Radius bei </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir müssen den umgekehrten Vorgang ausführen. </font><font style="vertical-align: inherit;">Lassen Sie uns also beide Umrechnungsfaktoren über verfügbar machen </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outerToInner = <span class="hljs-number"><span class="hljs-number">0.866025404f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerToOuter = <span class="hljs-number"><span class="hljs-number">1f</span></span> / outerToInner; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outerRadius = <span class="hljs-number"><span class="hljs-number">10f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerRadius = outerRadius * outerToInner;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir zur richtigen Skala übergehen </font></font><code>HexMesh.TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Kanäle bleiben aufgrund ihrer Drehung immer noch etwas zusammengedrückt, dies ist jedoch viel weniger ausgeprägt als im Fall von Zickzacklinien. </font><font style="vertical-align: inherit;">Daher müssen wir dies nicht kompensieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next2())) { centerL = center; centerR = center + HexMetrics.GetSolidEdgeMiddle(direction.Next()) * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> * HexMetrics.innerToOuter); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = center + HexMetrics.GetSolidEdgeMiddle(direction.Previous()) * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> * HexMetrics.innerToOuter); centerR = center; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a2/849/49c/2a284949c066c558391613611b93d093.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Glatte Kurven. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation in der Nähe von Flüssen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsere Flüsse sind bereit. </font><font style="vertical-align: inherit;">Aber wir haben noch keine anderen Teile der Zellen, die die Flüsse enthalten, trianguliert. </font><font style="vertical-align: inherit;">Jetzt werden wir diese Löcher schließen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f47/5fd/74d/f475fd74d147a577e8adb72cd1ff63fb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Löcher in der Nähe der Kanäle. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Zelle einen Fluss hat, dieser aber nicht in die aktuelle Richtung fließt, </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rufen wir eine neue Methode in auf.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { TriangulateWithRiverBeginOrEnd(direction, cell, center, e); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithRiver(direction, cell, center, e); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateAdjacentToRiver(direction, cell, center, e); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeFan(center, e, cell.Color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei dieser Methode füllen wir das Zellendreieck mit einem Streifen und einem Fächer. </font><font style="vertical-align: inherit;">Nur ein Ventilator wird uns nicht ausreichen, da die Gipfel dem mittleren Rand der Teile entsprechen sollten, die den Fluss enthalten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) ); TriangulateEdgeStrip(m, cell.Color, e, cell.Color); TriangulateEdgeFan(center, m, cell.Color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/059/4df/7bb/0594df7bb3225d20852c9e0d0d708101.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überlagerung in Kurven und geraden Flüssen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Passen Sie den Kanal an </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Natürlich müssen wir das Zentrum, das wir verwenden, an den zentralen Teil anpassen, der von den Flussteilen verwendet wird. </font><font style="vertical-align: inherit;">Mit Zickzack ist alles in Ordnung und Kurven und gerade Flüsse erfordern Aufmerksamkeit. </font><font style="vertical-align: inherit;">Daher müssen wir sowohl den Flusstyp als auch seine relative Ausrichtung bestimmen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit der Überprüfung, ob wir uns innerhalb der Kurve befinden. </font><font style="vertical-align: inherit;">In diesem Fall enthalten sowohl die vorherige als auch die nächste Richtung den Fluss. </font><font style="vertical-align: inherit;">Wenn ja, müssen wir die Mitte an den Rand verschieben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { center += HexMetrics.GetSolidEdgeMiddle(direction) * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } } EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/016/620/d89/016620d89847368d487d49bb1c81cdc7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wurde ein Fall behoben, in dem der Fluss von beiden Seiten fließt. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir einen Fluss in eine andere Richtung haben, aber nicht in die vorherige, prüfen wir, ob er gerade ist. </font><font style="vertical-align: inherit;">Wenn ja, verschieben Sie die Mitte in die erste Ecke.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { center += HexMetrics.GetSolidEdgeMiddle(direction) * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( cell.HasRiverThroughEdge(direction.Previous2()) ) { center += HexMetrics.GetFirstSolidCorner(direction) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1d/85a/366/a1d85a3669a55984eb69a43af5e8631f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feste halbe Überlagerung mit einem geraden Fluss. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also haben wir das Problem mit der Hälfte der Teile gelöst, die an die geraden Flüsse angrenzen. </font><font style="vertical-align: inherit;">Der letzte Fall - wir haben einen Fluss in der vorherigen Richtung und er ist gerade. </font><font style="vertical-align: inherit;">In diesem Fall müssen Sie die Mitte in die nächste Ecke verschieben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { center += HexMetrics.GetSolidEdgeMiddle(direction) * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( cell.HasRiverThroughEdge(direction.Previous2()) ) { center += HexMetrics.GetFirstSolidCorner(direction) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( cell.HasRiverThroughEdge(direction.Previous()) &amp;&amp; cell.HasRiverThroughEdge(direction.Next2()) ) { center += HexMetrics.GetSecondSolidCorner(direction) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c9d/d1a/20c/c9dd1a20c213658aeed27b9065e6bf58.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keine Überlagerungen mehr. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HexMesh-Generalisierung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben die Triangulation der Kanäle abgeschlossen. </font><font style="vertical-align: inherit;">Jetzt können wir sie mit Wasser füllen. </font><font style="vertical-align: inherit;">Da sich Wasser von Land unterscheidet, müssen wir ein anderes Netz mit unterschiedlichen Scheitelpunktdaten und unterschiedlichem Material verwenden. </font><font style="vertical-align: inherit;">Es wäre sehr praktisch, wenn wir </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sowohl Sushi als auch Wasser verwenden </font><font style="vertical-align: inherit;">könnten </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Verallgemeinern wir es also, </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indem </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">es in eine Klasse verwandeln, die sich mit diesen Netzen befasst, unabhängig davon, wofür es verwendet wird. </font><font style="vertical-align: inherit;">Wir werden die Aufgabe der Triangulation seiner Zellen weitergeben </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschieben der Störungsmethode </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Methode </font></font><code>Perturb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ziemlich verallgemeinert ist und an verschiedenen Stellen verwendet wird, verschieben wir sie auf </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Benennen Sie es zunächst in um </font></font><code>HexMetrics.Perturb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist ein falscher Methodenname, der jedoch den gesamten Code für die ordnungsgemäße Verwendung umgestaltet. </font><font style="vertical-align: inherit;">Wenn Ihr Code-Editor über spezielle Funktionen zum Verschieben von Methoden verfügt, verwenden Sie diese. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie die Methode nach innen verschieben </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, machen Sie sie allgemein und statisch und korrigieren Sie dann ihren Namen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = SampleNoise(position); position.x += (sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * cellPerturbStrength; position.z += (sample.z * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * cellPerturbStrength; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulationsmethoden verschieben </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Änderung von Variablen </font></font><code>hexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in den gemeinsamen Variablen </font></font><code>terrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain; <span class="hljs-comment"><span class="hljs-comment">// HexMesh hexMesh; void Awake () { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); // hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cells = new HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; ShowUI(false); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als nächstes überarbeiten wir alle Methoden </font></font><code>Add…</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>terrain.Add…</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Verschieben Sie dann alle Methoden </font></font><code>Triangulate…</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Danach können Sie die Namen der Methoden </font></font><code>Add…</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font><font style="vertical-align: inherit;">korrigieren </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und allgemein machen. </font><font style="vertical-align: inherit;">Infolgedessen werden alle komplexen Triangulationsmethoden gefunden </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und einfache Methoden zum Hinzufügen von Daten zum Netz bleiben erhalten </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sind noch nicht fertig. </font><font style="vertical-align: inherit;">Jetzt </font></font><code>HexGridChunk.LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte es seine eigene Methode aufrufen </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Außerdem sollte es keine Zellen mehr als Argument übergeben. </font><font style="vertical-align: inherit;">Daher kann es </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seinen Parameter verlieren. </font><font style="vertical-align: inherit;">Und er muss die Reinigung und Anwendung der Netzdaten delegieren </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Triangulate(); <span class="hljs-comment"><span class="hljs-comment">// hexMesh.Triangulate(cells); enabled = false; } public void Triangulate () { terrain.Clear(); // hexMesh.Clear(); // vertices.Clear(); // colors.Clear(); // triangles.Clear(); for (int i = 0; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); // hexMesh.vertices = vertices.ToArray(); // hexMesh.colors = colors.ToArray(); // hexMesh.triangles = triangles.ToArray(); // hexMesh.RecalculateNormals(); // meshCollider.sharedMesh = hexMesh; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie </font><font style="vertical-align: inherit;">die erforderlichen Methoden </font></font><code>Clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>Apply</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices.Clear(); colors.Clear(); triangles.Clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); hexMesh.SetColors(colors); hexMesh.SetTriangles(triangles, <span class="hljs-number"><span class="hljs-number">0</span></span>); hexMesh.RecalculateNormals(); meshCollider.sharedMesh = hexMesh; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist mit SetVertices, SetColors und SetTriangles?</font></font></b> <div class="spoiler_text">        <code>Mesh</code> .        .  ,           . <br><br>  <code>SetTriangles</code>    integer,    .      ,    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Schluss hängen Sie das untergeordnete Element des Netzes manuell an das Fragment-Fertighaus an. </font><font style="vertical-align: inherit;">Wir können dies nicht mehr automatisch tun, da wir dem Netz bald ein zweites Kind hinzufügen werden. </font><font style="vertical-align: inherit;">Benennen Sie es in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um, um seinen Zweck anzugeben.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/614/3b4/0dc/6143b40dc88ecec6761348d9e6208944.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weisen Sie eine Erleichterung zu.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Umbenennen eines Fertighauses funktioniert nicht?</font></font></b> <div class="spoiler_text">          .    ,   .  ,     <em>Apply</em> ,       .        . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Listenpools erstellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir ziemlich viel Code verschoben haben, sollte unsere Karte immer noch genauso funktionieren wie zuvor. </font><font style="vertical-align: inherit;">Das Hinzufügen eines weiteren Netzes zum Fragment ändert dies nicht. </font><font style="vertical-align: inherit;">Wenn wir dies jedoch mit der Gegenwart tun </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, können Fehler auftreten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem ist, dass wir davon ausgegangen sind, dass wir jeweils nur mit einem Netz arbeiten würden. </font><font style="vertical-align: inherit;">Dies ermöglichte es uns, statische Listen zum Speichern temporärer Netzdaten zu verwenden. </font><font style="vertical-align: inherit;">Nach dem Hinzufügen von Wasser arbeiten wir jedoch gleichzeitig mit zwei Maschen, sodass wir keine statischen Listen mehr verwenden können. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden jedoch nicht für jede Instanz zu den Listensätzen zurückkehren </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Stattdessen verwenden wir einen statischen Listenpool. </font><font style="vertical-align: inherit;">Standardmäßig ist dieses Pooling nicht vorhanden. Beginnen wir also damit, selbst eine gemeinsame Listenpoolklasse zu erstellen.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListPool</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie funktioniert ListPool &lt;T&gt;?</font></font></b> <div class="spoiler_text">     ,  <code>List&lt;int&gt;</code>    .  <code>&lt;T&gt;</code>    <code>ListPool</code> ,  ,    .      ,    <code>T</code> (  template). </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um eine Sammlung von Listen in einem Pool zu speichern, können wir den Stapel verwenden. </font><font style="vertical-align: inherit;">Normalerweise verwende ich keine Listen, da Unity sie nicht serialisiert, aber in diesem Fall spielt es keine Rolle.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListPool</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Stack&lt;List&lt;T&gt;&gt; stack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stack&lt;List&lt;T&gt;&gt;(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was bedeutet Stapel &lt;Liste &lt;t&gt;&gt;?</font></font></b> <div class="spoiler_text">     .  ,     .      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie eine allgemeine statische Methode hinzu, um die Liste aus dem Pool abzurufen. </font><font style="vertical-align: inherit;">Wenn der Stapel nicht leer ist, extrahieren wir die Top-Liste und geben diese zurück. </font><font style="vertical-align: inherit;">Andernfalls erstellen wir eine neue Liste.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stack.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stack.Pop(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;T&gt;(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Listen wiederzuverwenden, müssen Sie sie dem Pool hinzufügen, nachdem Sie mit ihnen gearbeitet haben. </font></font><code>ListPool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">löscht die Liste und schiebt sie auf den Stapel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;T&gt; list</span></span></span><span class="hljs-function">)</span></span> { list.Clear(); stack.Push(list); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir die Pools in nutzen </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ersetzen Sie statische Listen durch nicht statische private Links. </font><font style="vertical-align: inherit;">Markieren wir sie </font></font><code>NonSerialized</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass Unity sie beim Neukompilieren nicht beibehält. </font><font style="vertical-align: inherit;">Oder schreiben </font></font><code>System.NonSerialized</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>using System;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">am Anfang des Skripts </font><font style="vertical-align: inherit;">hinzufügen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">NonSerialized</span></span>] List&lt;Vector3&gt; vertices; [NonSerialized] List&lt;Color&gt; colors; [NonSerialized] List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; triangles; <span class="hljs-comment"><span class="hljs-comment">// static List&lt;Vector3&gt; vertices = new List&lt;Vector3&gt;(); // static List&lt;Color&gt; colors = new List&lt;Color&gt;(); // static List&lt;int&gt; triangles = new List&lt;int&gt;();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da das Netz unmittelbar vor dem Hinzufügen neuer Daten bereinigt wird, müssen Sie hier Listen aus Pools abrufen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); colors = ListPool&lt;Color&gt;.Get(); triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem wir diese Netze angewendet haben, brauchen wir sie nicht mehr, sodass wir sie hier zu den Pools hinzufügen können. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); hexMesh.SetColors(colors); ListPool&lt;Color&gt;.Add(colors); hexMesh.SetTriangles(triangles, <span class="hljs-number"><span class="hljs-number">0</span></span>); ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Add(triangles); hexMesh.RecalculateNormals(); meshCollider.sharedMesh = hexMesh; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Daher haben wir Listen mehrfach verwendet, unabhängig davon, wie viele Netze wir gleichzeitig füllen. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optionaler Collider </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl unser Gelände einen Collider benötigt, wird er für Flüsse nicht wirklich benötigt. </font><font style="vertical-align: inherit;">Die Strahlen passieren einfach das Wasser und schneiden sich mit dem darunter liegenden Kanal. </font><font style="vertical-align: inherit;">Machen wir es so, dass wir das Vorhandensein eines Colliders für konfigurieren können </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir erkennen dies, indem wir ein gemeinsames Feld hinzufügen </font></font><code>bool useCollider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Für das Gelände schalten wir es ein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e7/f19/a3c/4e7f19a3c7eb01a1432618a8be6903e5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden eines Mesh-Colliders. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Collider muss erst erstellt und zugewiesen werden, wenn er aktiviert ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCollider) { meshCollider = gameObject.AddComponent&lt;MeshCollider&gt;(); } hexMesh.name = <span class="hljs-string"><span class="hljs-string">"Hex Mesh"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCollider) { meshCollider.sharedMesh = hexMesh; } … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optionale Farben </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scheitelpunktfarben können auch optional sein. </font><font style="vertical-align: inherit;">Wir brauchen sie, um verschiedene Arten von Reliefs zu demonstrieren, aber Wasser ändert seine Farbe nicht. </font><font style="vertical-align: inherit;">Wir können sie optional machen, genauso wie wir den Collider optional gemacht haben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { colors = ListPool&lt;Color&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { hexMesh.SetColors(colors); ListPool&lt;Color&gt;.Add(colors); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Natürlich sollte das Gelände die Farben der Eckpunkte verwenden, also schalten Sie sie ein. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/624/c01/bbd/624c01bbda8ad0250747b9c1af852590.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwendung von Farben.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optionales UV </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Währenddessen können wir auch Unterstützung für optionale UV-Koordinaten hinzufügen. </font><font style="vertical-align: inherit;">Obwohl das Relief sie nicht benutzt, werden wir sie für Wasser brauchen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors, useUVCoordinates; [NonSerialized] List&lt;Vector2&gt; uvs; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { colors = ListPool&lt;Color&gt;.Get(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { uvs = ListPool&lt;Vector2&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { hexMesh.SetColors(colors); ListPool&lt;Color&gt;.Add(colors); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">0</span></span>, uvs); ListPool&lt;Vector2&gt;.Add(uvs); } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b01/a99/559/b01a9955989cdc83a2e8de2582c1cbeb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden keine UV-Koordinaten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um diese Funktion zu verwenden, erstellen Sie Methoden zum Hinzufügen von UV-Koordinaten zu Dreiecken und Vierecken.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleUV</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3</span></span></span><span class="hljs-function">)</span></span> { uvs.Add(uv1); uvs.Add(uv2); uvs.Add(uv3); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3, Vector3 uv4</span></span></span><span class="hljs-function">)</span></span> { uvs.Add(uv1); uvs.Add(uv2); uvs.Add(uv3); uvs.Add(uv4); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen wir eine zusätzliche Methode hinzu, </font></font><code>AddQuadUV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um bequem einen rechteckigen UV-Bereich hinzuzufügen. </font><font style="vertical-align: inherit;">Dies ist der Standardfall, wenn das Quad und seine Textur gleich sind. Wir werden es für das Wasser des Flusses verwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMax, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMax</span></span></span><span class="hljs-function">)</span></span> { uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMin)); uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMin)); uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMax)); uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMax)); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aktuelle Flüsse </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endlich ist es Zeit, Wasser zu schaffen! </font><font style="vertical-align: inherit;">Wir werden dies mit einem Quad tun, das die Wasseroberfläche anzeigt. </font><font style="vertical-align: inherit;">Und da wir mit Flüssen arbeiten, muss Wasser fließen. </font><font style="vertical-align: inherit;">Dazu verwenden wir UV-Koordinaten, die die Ausrichtung des Flusses angeben. </font><font style="vertical-align: inherit;">Um dies zu visualisieren, benötigen wir einen neuen Shader. </font><font style="vertical-align: inherit;">Erstellen Sie daher einen neuen Standard-Shader und nennen Sie ihn </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ändern Sie es so, dass die UV-Koordinaten in den grünen und roten Albedokanälen aufgezeichnet werden.</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/River" { … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemeinen Feld hinzufügen </font></font><code>HexMesh rivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir reinigen es und wenden es auf die gleiche Weise an wie im Falle einer Erleichterung.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Werden wir zusätzliche Draw Calls haben, auch wenn wir keine Flüsse haben?</font></font></b> <div class="spoiler_text">  Unity  ,        .     ,  -  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern Sie das Fertighaus (über die Instanz), duplizieren Sie das Geländeobjekt, benennen Sie es in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flüsse um</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und verbinden Sie es.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efd/0d6/680/efd0d66801d78d636d07f59b34e5c615.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e46/119/b43/e46119b43f4cd398d96261715975a36a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertighausfragment mit Flüssen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Material </font><font style="vertical-align: inherit;">mit unserem neuen Shader und lassen Sie das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekt es verwenden </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir haben auch die Sechsecknetzkomponente des Objekts so eingerichtet, dass UV-Koordinaten verwendet werden, jedoch keine Scheitelpunktfarben oder der Kollider.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7df/db6/134/7dfdb6134b4dc27d843db92492b61708.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterobjekt Flüsse.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wasser triangulieren </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir Wasser triangulieren können, müssen wir den Pegel seiner Oberfläche bestimmen. </font><font style="vertical-align: inherit;">Machen </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">eine Höhenverschiebung </font><font style="vertical-align: inherit;">, wie wir es mit dem Flussbett gemacht haben. </font><font style="vertical-align: inherit;">Da die vertikale Verzerrung der Zelle gleich der Hälfte der Höhenverschiebung ist, verwenden wir sie, um die Oberfläche des Flusses zu verschieben. </font><font style="vertical-align: inherit;">Wir garantieren also, dass sich das Wasser niemals über der Topographie der Zelle befindet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> riverSurfaceElevationOffset = <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum nicht etwas niedriger machen?</font></font></b> <div class="spoiler_text">          ,   . ,         . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie eine </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft hinzu, um die vertikale Position der Oberfläche des Flusses zu ermitteln.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> RiverSurfaceY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (elevation + HexMetrics.riverSurfaceElevationOffset) * HexMetrics.elevationStep; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir arbeiten </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font><font style="vertical-align: inherit;">Da wir viele Flussvierecke erstellen werden, fügen wir hierfür eine separate Methode hinzu. </font><font style="vertical-align: inherit;">Geben wir ihm vier Eckpunkte und eine Höhe als Parameter. </font><font style="vertical-align: inherit;">Auf diese Weise können wir bequem die vertikale Position aller vier Scheitelpunkte gleichzeitig einstellen, bevor wir Quad hinzufügen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = v3.y = v4.y = y; rivers.AddQuad(v1, v2, v3, v4); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden hier die UV-Koordinaten des Vierecks hinzufügen. </font><font style="vertical-align: inherit;">Gehen Sie einfach von links nach rechts und von unten nach oben.</font></font><br><br><pre> <code class="cs hljs"> rivers.AddQuad(v1, v2, v3, v4); rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br> <code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Dies ist die erste Methode, zu der wir die Vierecke der Flüsse hinzufügen. </font><font style="vertical-align: inherit;">Das erste Quad befindet sich zwischen der Mitte und der Mitte. </font><font style="vertical-align: inherit;">Der zweite ist zwischen der Mitte und der Rippe. </font><font style="vertical-align: inherit;">Wir verwenden nur die Eckpunkte, die wir bereits haben. </font><font style="vertical-align: inherit;">Da diese Spitzen unterschätzt werden, befindet sich das Wasser infolgedessen teilweise unter den geneigten Wänden des Kanals. </font><font style="vertical-align: inherit;">Daher müssen wir uns nicht um die genaue Position des Wasserrands kümmern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … TriangulateRiverQuad(centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY); TriangulateRiverQuad(m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/418/a40/e9c/418a40e9c73fd3da885ce467e475ff63.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die ersten Anzeichen von Wasser. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum ändert sich die Breite des Wassers?</font></font></b> <div class="spoiler_text">  ,     ,      — .           .      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mit dem Fluss bewegen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Derzeit stimmen die UV-Koordinaten nicht mit der Flussrichtung überein. </font><font style="vertical-align: inherit;">Wir müssen hier die Konsistenz wahren. </font><font style="vertical-align: inherit;">Angenommen, die U-Koordinate ist 0 auf der linken Seite des Flusses und 1 auf der rechten Seite, wenn Sie stromabwärts schauen. </font><font style="vertical-align: inherit;">Und die V-Koordinate sollte in Flussrichtung von 0 bis 1 variieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unter Verwendung dieser Spezifikation sind UVs korrekt, wenn der ausgehende Fluss trianguliert wird, aber sie stellen sich als falsch heraus und müssen umgedreht werden, wenn der eingehende Fluss trianguliert wird. </font><font style="vertical-align: inherit;">Fügen Sie den </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter </font><font style="vertical-align: inherit;">hinzu, um die Arbeit zu vereinfachen </font></font><code>bool reversed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Verwenden Sie es, um UV bei Bedarf umzudrehen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = v3.y = v4.y = y; rivers.AddQuad(v1, v2, v3, v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir wissen , </font><font style="vertical-align: inherit;">dass wir die Richtung drehen müssen, wenn sie </font><font style="vertical-align: inherit;">mit eingehendem Fluss geht.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.IncomingRiver == direction; TriangulateRiverQuad( centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY, reversed ); TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, reversed );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/546/c86/e9d/546c86e9d2d8752caa30523098283542.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die vereinbarte Richtung der Flüsse.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Anfang und das Ende des Flusses </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Inneren müssen </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir nur prüfen, ob wir einen ankommenden Fluss haben, um die Richtung des Flusses zu bestimmen. </font><font style="vertical-align: inherit;">Dann können wir einen weiteren Quad River zwischen der Mitte und der Rippe einfügen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.HasIncomingRiver; TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, reversed ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Teil zwischen der Mitte und der Mitte ist ein Dreieck, daher können wir ihn nicht verwenden </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der einzige signifikante Unterschied besteht darin, dass sich der zentrale Gipfel in der Mitte des Flusses befindet. </font><font style="vertical-align: inherit;">Daher ist seine Koordinate U immer gleich ½.</font></font><br><br><pre> <code class="cs hljs"> center.y = m.v2.y = m.v4.y = cell.RiverSurfaceY; rivers.AddTriangle(center, m.v2, m.v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c04/07f/539/c0407f539ce2ff6a91081e84062a4097.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasser am Anfang und am Ende.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehlen an den Enden Teile des Wassers?</font></font></b> <div class="spoiler_text">       ,   quad  ,     .           .           . <br><br>      ,  .     ,      .      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fluss zwischen Zellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Hinzufügen von Wasser zwischen den Zellen müssen wir auf den Höhenunterschied achten. </font><font style="vertical-align: inherit;">Damit Wasser Hänge und Klippen hinunterfließen kann, </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss es zwei Höhenparameter unterstützen. </font><font style="vertical-align: inherit;">Fügen wir also einen zweiten hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = y1; v3.y = v4.y = y2; rivers.AddQuad(v1, v2, v3, v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie der Einfachheit halber eine Option hinzu, die eine Höhe erhält. </font><font style="vertical-align: inherit;">Es wird nur eine andere Methode aufgerufen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { TriangulateRiverQuad(v1, v2, v3, v4, y, y, reversed); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir Quad River und In hinzufügen </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da wir uns zwischen den Zellen befinden, können wir nicht sofort herausfinden, um welche Art von Fluss es sich handelt. </font><font style="vertical-align: inherit;">Um festzustellen, ob eine Abbiegung erforderlich ist, müssen wir prüfen, ob ein Fluss ankommt und ob er sich in unsere Richtung bewegt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e2.v3.y = neighbor.StreamBedY; TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/283/1f2/62e/2831f262ed46e82bebabf45d0a8215f2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der fertiggestellte Fluss.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dehnung der V-Koordinate </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher haben wir in jedem Flusssegment V-Koordinaten von 0 bis 1. Das heißt, es gibt nur vier davon in der Zelle. Fünf, wenn wir auch Verbindungen zwischen Zellen hinzufügen. Was auch immer wir verwenden, um den Fluss zu texturieren, es muss genauso oft wiederholt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können die Anzahl der Wiederholungen reduzieren, indem wir die V-Koordinaten so strecken, dass sie in der gesamten Zelle plus einer Verbindung von 0 auf 1 gehen. Dies kann durch Erhöhen der V-Koordinate in jedem Segment um 0,2 erfolgen. Wenn wir 0,4 in die Mitte setzen, wird es in der Mitte 0,6 und am Rand 0,8. In der Zellenverbindung ist der Wert dann 1.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Fluss in die entgegengesetzte Richtung fließt, können wir immer noch 0,4 in die Mitte setzen, aber in der Mitte wird es 0,2 und am Rand - 0. Wenn wir so weitermachen, bis sich die Zelle verbindet, ist das Ergebnis -0,2. </font><font style="vertical-align: inherit;">Dies ist normal, da es für eine Textur mit Wiederholungsfilterungsmodus ähnlich wie 0,8 ist, genauso wie 0 gleich 1 ist.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22e/4de/cd9/22e4decd99e9c2f0c9312be9eaaceb9a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Änderung der Koordinaten V.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um dies zu unterstützen, müssen wir </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen weiteren Parameter </font><font style="vertical-align: inherit;">hinzufügen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { TriangulateRiverQuad(v1, v2, v3, v4, y, y, v, reversed); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn die Richtung nicht umgekehrt wird, verwenden wir einfach die übertragene Koordinate am unteren Rand des Vierecks und addieren am oberen Rand 0,2. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, v, v + <span class="hljs-number"><span class="hljs-number">0.2f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir können mit einer umgekehrten Richtung arbeiten, indem wir die Koordinaten von 0,8 und 0,6 subtrahieren. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span> - v, <span class="hljs-number"><span class="hljs-number">0.6f</span></span> - v); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt müssen wir die richtigen Koordinaten übertragen, als hätten wir es mit einem abgehenden Fluss zu tun. </font><font style="vertical-align: inherit;">Beginnen wir mit </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> TriangulateRiverQuad( centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, reversed ); TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ändert sich </font><font style="vertical-align: inherit;">wie folgt.</font></font><br><br><pre> <code class="cs hljs"> TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und schließlich </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed ); center.y = m.v2.y = m.v4.y = cell.RiverSurfaceY; rivers.AddTriangle(center, m.v2, m.v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44e/786/63f/44e78663f2d77264660f30917a5e1a94.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gestreckte V-Koordinaten</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um die Faltung der V-Koordinaten korrekt anzuzeigen, stellen Sie sicher, dass sie im River Shader positiv bleiben.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y += <span class="hljs-number"><span class="hljs-number">1</span></span>; } o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aec/30e/a84/aec30ea849af0c8ba42cd6e0cef44635.png"></div><br> <i><font style="vertical-align: inherit;"></font></i> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Reduzierte </font></a><i><font style="vertical-align: inherit;">Koordinaten V. </font></i></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flussanimation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir mit den UV-Koordinaten fertig sind, können wir mit der Animation der Flüsse fortfahren. Der River Shader wird dies tun, damit wir das Netz nicht ständig aktualisieren müssen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden in diesem Tutorial keinen komplexen River Shader erstellen, aber später. Im Moment erstellen wir einen einfachen Effekt, der ein Verständnis der Funktionsweise von Animationen vermittelt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Animation wird durch Verschieben der V-Koordinaten basierend auf der Spielzeit erstellt. Mit Unity können Sie den Wert mithilfe einer Variablen ermitteln </font></font><code>_Time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Seine Komponente Y enthält die unveränderte Zeit, die wir verwenden. Andere Komponenten enthalten andere Zeitskalen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden die Faltung entlang V loswerden, weil wir sie nicht mehr brauchen. Stattdessen subtrahieren wir die aktuelle Zeit von der V-Koordinate. Dadurch wird die Koordinate nach unten verschoben, wodurch die Illusion entsteht, dass der Strom stromabwärts des Flusses fließt.</font></font><br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { // <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y += <span class="hljs-number"><span class="hljs-number">1</span></span>; // } <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y -= _Time.y; o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In einer Sekunde wird die V-Koordinate an allen Punkten kleiner als Null, sodass wir den Unterschied nicht mehr sehen. </font><font style="vertical-align: inherit;">Dies ist wiederum normal, wenn die Filterung im Texturwiederholungsmodus verwendet wird. </font><font style="vertical-align: inherit;">Aber um zu sehen, was passiert, können wir den Bruchteil der V-Koordinate nehmen.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y -= _Time.y; <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y = frac(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y); o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animierte V-Koordinaten.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lärmgebrauch </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt ist unser Fluss animiert, aber in Richtung und Geschwindigkeit gibt es scharfe Übergänge. </font><font style="vertical-align: inherit;">Unser UV-Muster macht sie ziemlich offensichtlich, aber es ist schwieriger zu erkennen, wenn Sie ein wasserähnlicheres Muster verwenden. </font><font style="vertical-align: inherit;">Anstatt rohes UV-Licht anzuzeigen, probieren wir die Textur aus. </font><font style="vertical-align: inherit;">Wir können unsere vorhandene Rauschstruktur verwenden. </font><font style="vertical-align: inherit;">Wir probieren es aus und multiplizieren die Farbe des Materials mit dem ersten Rauschkanal.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv.y -= _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, uv); fixed4 c = _Color * noise.r; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Weisen Sie dem Flussmaterial die Geräuschstruktur zu und stellen Sie sicher, dass es weiß ist. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc8/dd4/e4e/dc8dd4e4ee9b92f2f104ba3107da30ce.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3f/0ca/319/b3f0ca31928fd594a715868ebbb7265c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rauschtextur verwenden. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die V-Koordinaten sehr gestreckt sind, erstreckt sich die Rauschstruktur auch entlang des Flusses. </font><font style="vertical-align: inherit;">Leider ist der Kurs nicht sehr schön. </font><font style="vertical-align: inherit;">Lassen Sie uns versuchen, es auf eine andere Weise zu dehnen - die Skalierung der Koordinaten von U stark zu reduzieren. Ein Sechzehntel wird ausreichen. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir nur ein schmales Band von Rauschtexturen abtasten.</font></font><br><br><pre> <code class="hljs pgsql"> float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv.x *= <span class="hljs-number"><span class="hljs-number">0.0625</span></span>; uv.y -= _Time.y;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa9/957/2a9/aa99572a9c0ad3daaa7b5b4eb3978cc0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dehnen der U-Koordinate.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lassen Sie uns auch auf ein Viertel pro Sekunde verlangsamen, damit der Abschluss des Texturzyklus vier Sekunden dauert.</font></font><br><br><pre> <code class="hljs"> uv.y -= _Time.y * 0.25;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das aktuelle Rauschen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rauschmischung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles sieht schon viel besser aus, aber das Muster bleibt immer das gleiche. Wasser verhält sich nicht so. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir nur ein kleines Rauschband verwenden, können wir das Muster variieren, indem wir dieses Band entlang der Textur verschieben. Dies erfolgt durch Hinzufügen von Zeit zur U-Koordinate. Wir müssen es langsam machen, sonst scheint der Fluss seitwärts zu fließen. Versuchen wir den Koeffizienten von 0,005. Dies bedeutet, dass es 200 Sekunden dauert, um das Muster fertigzustellen.</font></font><br><br><pre> <code class="hljs markdown"> uv.x = uv.x <span class="hljs-bullet"><span class="hljs-bullet">* 0.0625 + _Time.y *</span></span> 0.005;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bewegliches Geräusch. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das sieht leider nicht sehr schön aus. </font><font style="vertical-align: inherit;">Wasser scheint immer noch statisch und die Verschiebung ist deutlich spürbar, obwohl es sehr langsam ist. </font><font style="vertical-align: inherit;">Wir können die Verschiebung verbergen, indem wir zwei Rauschproben kombinieren und sie in entgegengesetzte Richtungen verschieben. </font><font style="vertical-align: inherit;">Wenn wir zum Verschieben des zweiten Samples leicht unterschiedliche Werte verwenden, erstellen wir eine leichte Animation der Änderung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit wir niemals dasselbe Rauschmuster überlappen, verwenden wir für das zweite Sample einen anderen Kanal.</font></font><br><br><pre> <code class="hljs pgsql"> float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv.x = uv.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> + _Time.y * <span class="hljs-number"><span class="hljs-number">0.005</span></span>; uv.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, uv); float2 uv2 = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv2.x = uv2.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> - _Time.y * <span class="hljs-number"><span class="hljs-number">0.0052</span></span>; uv2.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.23</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise2 = tex2D(_MainTex, uv2); fixed4 c = _Color * (noise.r * noise2.a);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Kombination aus zwei sich verschiebenden Geräuschmustern.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durchscheinendes Wasser </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser Muster sieht sehr dynamisch aus. </font><font style="vertical-align: inherit;">Der nächste Schritt besteht darin, es durchscheinend zu machen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie zunächst sicher, dass das Wasser keine Schatten wirft. </font><font style="vertical-align: inherit;">Sie können sie über die Renderer-Komponente des </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekts </font><font style="vertical-align: inherit;">im Fertighaus deaktivieren.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a61/894/e14/a61894e14d9999315d59b5ff0c0de517.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schattenwurf ist deaktiviert. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schalten Sie nun den Shader in den transparenten Modus. </font><font style="vertical-align: inherit;">Verwenden Sie dazu Shader-Tags. </font><font style="vertical-align: inherit;">Fügen Sie dann das </font></font><code>#pragma surface</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlüsselwort </font><font style="vertical-align: inherit;">zur Zeile hinzu </font></font><code>alpha</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Während wir hier sind, können Sie das Schlüsselwort entfernen </font></font><code>fullforwardshadows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da wir immer noch keine Schatten werfen.</font></font><br><br><pre> <code class="hljs cs"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Standard alpha // fullforwardshadows #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> target 3.0</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt werden wir die Art und Weise ändern, wie wir die Farbe des Flusses einstellen. </font><font style="vertical-align: inherit;">Anstatt Rauschen mit Farbe zu multiplizieren, fügen wir Rauschen hinzu. </font><font style="vertical-align: inherit;">Dann verwenden wir die Funktion </font></font><code>saturate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um das Ergebnis so zu begrenzen, dass es 1 nicht überschreitet.</font></font><br><br><pre> <code class="hljs swift"> fixed4 <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = saturate(_Color + noise.r * noise2.a);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dadurch können wir die Materialfarbe als Grundfarbe verwenden. </font><font style="vertical-align: inherit;">Rauschen erhöht die Helligkeit und Deckkraft. </font><font style="vertical-align: inherit;">Versuchen wir, eine blaue Farbe mit einer relativ geringen Deckkraft zu verwenden. </font><font style="vertical-align: inherit;">Als Ergebnis erhalten wir blaues durchscheinendes Wasser mit weißen Spritzern.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af8/3f7/5a1/af83f75a143aabdd3b83525e4114fc3b.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Farbiges durchscheinendes Wasser. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fertigstellung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt, da alles zu funktionieren scheint, ist es Zeit, die Spitzen wieder zu verzerren. </font><font style="vertical-align: inherit;">Dies verformt nicht nur die Ränder der Zellen, sondern macht unsere Flüsse auch uneben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c8/ff5/96b/8c8ff596bc247be79a30122e49ca27f5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ca/664/808/6ca66480859e94d00e2e558caa17cbf4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verzerrte und verzerrte Spitzen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untersuchen wir das Gelände auf Probleme, die durch Verzerrungen entstanden sind. </font><font style="vertical-align: inherit;">Sieht aus wie sie sind! </font><font style="vertical-align: inherit;">Schauen wir uns die hohen Wasserfälle an.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df1/95b/a33/df195ba33947744e97173412373f5ad4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasser von Klippen abgeschnitten.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wasser, das von einem hohen Wasserfall fällt, verschwindet hinter einer Klippe. Wenn dies passiert, ist es sehr auffällig, also müssen wir etwas dagegen tun. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viel weniger offensichtlich ist, dass die Wasserfälle abfallen können, anstatt direkt abzusteigen. Obwohl Wasser in Wirklichkeit nicht so fließt, fällt es nicht besonders auf. Unser Gehirn wird es so interpretieren, dass es uns normal erscheint. Also ignoriere es einfach. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der einfachste Weg, um Wasserverluste zu vermeiden, ist die Vertiefung der Flussbetten. So schaffen wir mehr Platz zwischen der Wasseroberfläche und dem Flussbett. Dadurch werden auch die Wände des Kanals vertikaler, gehen Sie also nicht zu tief. Fragen wir</font></font><code>HexMetrics.streamBedElevationOffset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert -1,75. </font><font style="vertical-align: inherit;">Dies wird den Großteil der Probleme lösen und das Bett wird nicht zu tief. </font><font style="vertical-align: inherit;">Ein Teil des Wassers wird immer noch abgeschnitten, aber nicht die gesamten Wasserfälle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> streamBedElevationOffset = <span class="hljs-number"><span class="hljs-number">-1.75f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/80c/d26/57b80cd2687ff6afb9be83176e984b7d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detaillierte Kanäle. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 7: Straßen </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Straßenunterstützung hinzufügen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulieren Sie die Straße. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir kombinieren Straßen und Flüsse. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verbesserung des Erscheinungsbildes von Straßen. </font></font></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f7/b24/05e/9f7b2405e5ceed9842cc1ebd7b549b0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die ersten Anzeichen der Zivilisation.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen mit Straßen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Flüsse verlaufen Straßen von Zelle zu Zelle durch die Mitte der Zellenränder. </font><font style="vertical-align: inherit;">Der große Unterschied besteht darin, dass auf den Straßen kein Wasser fließt und sie daher bidirektional sind. </font><font style="vertical-align: inherit;">Darüber hinaus sind Kreuzungen für ein funktionierendes Straßennetz erforderlich, sodass mehr als zwei Straßen pro Zelle unterstützt werden müssen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie zulassen, dass die Straßen in alle sechs Richtungen verlaufen, kann die Zelle null bis sechs Straßen enthalten. </font><font style="vertical-align: inherit;">Das sind insgesamt vierzehn mögliche Straßenkonfigurationen. </font><font style="vertical-align: inherit;">Dies sind viel mehr als fünf mögliche Flusskonfigurationen. </font><font style="vertical-align: inherit;">Um dies zu handhaben, müssen wir einen allgemeineren Ansatz verwenden, der alle Konfigurationen handhaben kann.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d46/965/5b7/d469655b7efdbab33a6cac1c42e61a7e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14 mögliche Straßenkonfigurationen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Straßenverfolgung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der einfachste Weg, Straßen in einer Zelle zu verfolgen, besteht darin, ein Array von Booleschen Werten zu verwenden. </font><font style="vertical-align: inherit;">Fügen Sie das private Feld des Arrays hinzu </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und machen Sie es serialisierbar, damit Sie es im Inspektor sehen können. </font><font style="vertical-align: inherit;">Stellen Sie die Größe des Arrays über das Zellen-Fertighaus so ein, dass es sechs Straßen unterstützt.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] roads;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/439/167/2c4/4391672c4c1de9075138eef3f1cafd73.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertighaus mit sechs Straßen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie eine Methode hinzu, um zu überprüfen, ob die Zelle einen Pfad in eine bestimmte Richtung hat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasRoadThroughEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist auch praktisch zu wissen, ob sich mindestens eine Straße in der Zelle befindet, daher fügen wir hierfür eine Eigenschaft hinzu. </font><font style="vertical-align: inherit;">Gehen Sie einfach um das Array in der Schleife herum und kehren Sie zurück </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sobald wir den Weg gefunden haben. </font><font style="vertical-align: inherit;">Wenn es keine Straßen gibt, kehren Sie zurück </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasRoads { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Straßenentfernung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bei Flüssen werden wir eine Methode hinzufügen, um alle Straßen aus der Zelle zu entfernen. </font><font style="vertical-align: inherit;">Dies kann mit einer Schleife erfolgen, die jede zuvor aktivierte Straße trennt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveRoads</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; neighbors.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { roads[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Natürlich müssen wir auch die entsprechenden teuren Zellen in den Nachbarn deaktivieren. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { roads[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbors[i].roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((HexDirection)i).Opposite()] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danach müssen wir jede der Zellen aktualisieren. </font><font style="vertical-align: inherit;">Da die Straßen lokal für die Zellen sind, müssen wir nur die Zellen selbst ohne ihre Nachbarn aktualisieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { roads[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbors[i].roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((HexDirection)i).Opposite()] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbors[i].RefreshSelfOnly(); RefreshSelfOnly(); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Straßen hinzufügen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Hinzufügen von Straßen ähnelt dem Entfernen von Straßen. </font><font style="vertical-align: inherit;">Der einzige Unterschied besteht darin, dass wir Boolean einen Wert zuweisen </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nicht </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir können eine private Methode erstellen, die beide Operationen ausführen kann. </font><font style="vertical-align: inherit;">Dann wird es möglich sein, die Straße sowohl hinzuzufügen als auch zu entfernen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveRoads</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; neighbors.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { SetRoad(i, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span> { roads[index] = state; neighbors[index].roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((HexDirection)index).Opposite()] = state; neighbors[index].RefreshSelfOnly(); RefreshSelfOnly(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können nicht gleichzeitig einen Fluss und eine Straße in die gleiche Richtung führen. </font><font style="vertical-align: inherit;">Daher werden wir vor dem Hinzufügen der Straße prüfen, ob ein Platz dafür vorhanden ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] &amp;&amp; !HasRiverThroughEdge(direction)) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Außerdem können Straßen nicht mit Klippen kombiniert werden, da sie zu scharf sind. </font><font style="vertical-align: inherit;">Oder lohnt es sich vielleicht, den Weg durch eine niedrige Klippe zu ebnen, aber nicht durch eine hohe? </font><font style="vertical-align: inherit;">Um dies festzustellen, müssen wir eine Methode erstellen, die den Höhenunterschied in eine bestimmte Richtung angibt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetElevationDifference</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> difference = elevation - GetNeighbor(direction).elevation; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> difference &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ? difference : -difference; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir die Straßen in einem ausreichend kleinen Höhenunterschied hinzufügen. </font><font style="vertical-align: inherit;">Ich beschränke mich nur auf Pisten, also maximal 1 Einheit.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] &amp;&amp; !HasRiverThroughEdge(direction) &amp;&amp; GetElevationDifference(direction) &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die falschen Straßen entfernen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben Straßen nur hinzugefügt, wenn dies zulässig ist. </font><font style="vertical-align: inherit;">Jetzt müssen wir sicherstellen, dass sie entfernt werden, wenn sie später falsch werden, beispielsweise beim Hinzufügen eines Flusses. </font><font style="vertical-align: inherit;">Wir können die Platzierung von Flüssen auf Straßen verbieten, aber Flüsse werden nicht durch Straßen unterbrochen. </font><font style="vertical-align: inherit;">Lassen Sie sie die Straße aus dem Weg waschen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird für uns ausreichen, nach der Straße zu fragen </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, unabhängig davon, ob die Straße war. </font><font style="vertical-align: inherit;">Es wird immer beide Zellen aktualisiert werden, so dass wir nicht mehr benötigen , </font><font style="vertical-align: inherit;">um explizit nennt </font></font><code>RefreshSelfOnly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>SetOutgoingRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasOutgoingRiver &amp;&amp; outgoingRiver == direction) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } HexCell neighbor = GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || elevation &lt; neighbor.elevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } RemoveOutgoingRiver(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasIncomingRiver &amp;&amp; incomingRiver == direction) { RemoveIncomingRiver(); } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; outgoingRiver = direction; <span class="hljs-comment"><span class="hljs-comment">// RefreshSelfOnly(); neighbor.RemoveIncomingRiver(); neighbor.hasIncomingRiver = true; neighbor.incomingRiver = direction.Opposite(); // neighbor.RefreshSelfOnly(); SetRoad((int)direction, false); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere Operation, die die Straße falsch machen kann, ist eine Änderung der Höhe. </font><font style="vertical-align: inherit;">In diesem Fall müssen wir nach Straßen in alle Richtungen suchen. </font><font style="vertical-align: inherit;">Wenn der Höhenunterschied zu groß ist, muss die vorhandene Straße gelöscht werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i] &amp;&amp; GetElevationDifference((HexDirection)i) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { SetRoad(i, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } Refresh(); } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Straßenbearbeitung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Bearbeiten von Straßen funktioniert genauso wie das Bearbeiten von Flüssen. </font><font style="vertical-align: inherit;">Daher </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist ein weiterer Schalter sowie eine Methode zum Festlegen des Status erforderlich.</font></font><br><br><pre> <code class="cs hljs"> OptionalToggle riverMode, roadMode; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRiverMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { riverMode = (OptionalToggle)mode; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRoadMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { roadMode = (OptionalToggle)mode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Methode </font></font><code>EditCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte nun das Entfernen durch Hinzufügen von Straßen unterstützen. </font><font style="vertical-align: inherit;">Dies bedeutet, dass er beim Ziehen und Ablegen eine von zwei möglichen Aktionen ausführen kann. </font><font style="vertical-align: inherit;">Wir strukturieren den Code ein wenig um, damit bei korrektem Drag &amp; Drop die Zustände beider Schalter überprüft werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.No) { cell.RemoveRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roadMode == OptionalToggle.No) { cell.RemoveRoads(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag) { HexCell otherCell = cell.GetNeighbor(dragDirection.Opposite()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherCell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.Yes) { otherCell.SetOutgoingRiver(dragDirection); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roadMode == OptionalToggle.Yes) { otherCell.AddRoad(dragDirection); } } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können der Benutzeroberfläche schnell eine Straßenleiste hinzufügen, indem wir die Flussleiste kopieren und die von den Schaltern aufgerufene Methode ändern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Ergebnis erhalten wir eine ziemlich hohe Benutzeroberfläche. </font><font style="vertical-align: inherit;">Um dies zu beheben, habe ich das Layout der Farbfelder geändert, um es an die kompakteren Straßen- und Flussfelder anzupassen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fd/de5/a8a/0fdde5a8a4abc86308b771f43b36bf4a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benutzeroberfläche mit Straßen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da ich jetzt zwei Zeilen mit drei Farboptionen verwende, ist Platz für eine andere Farbe. </font><font style="vertical-align: inherit;">Also habe ich einen Artikel für Orange hinzugefügt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a06/9c6/08d/a069c608dfe531a5e1b2a8c59fef5846.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e96/12a/499/e9612a49993e3a2d4cb20790186ecf02.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fünf Farben: Gelb, Grün, Blau, Orange und Weiß. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir die Straßen bearbeiten, aber bisher sind sie nicht sichtbar. </font><font style="vertical-align: inherit;">Mit dem Inspektor können Sie sicherstellen, dass alles funktioniert.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/160/c4f/0e4/160c4f0e496acec2a2a2d739152a7cfa.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zelle mit Straßen im Inspektor. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Straßentriangulation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Straßen anzuzeigen, müssen Sie sie triangulieren. </font><font style="vertical-align: inherit;">Dies ähnelt der Erstellung eines Netzes für Flüsse, nur das Flussbett wird nicht im Relief angezeigt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie zunächst einen neuen Standard-Shader, der erneut UV-Koordinaten verwendet, um die Straßenoberfläche zu malen.</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/Road" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } SubShader { Tags { "RenderType"="Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Standard fullforwardshadows #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; }; half _Glossiness; half _Metallic; fixed4 _Color; <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = fixed4(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen Sie mit diesem Shader ein Straßenmaterial. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/973/9e3/2b8/9739e32b82ad2148c559b8f7c4caa868.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Materielle Straße. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie das Fertighaus des Fragments so ein, dass es ein weiteres untergeordnetes Sechsecknetz für die Straßen erhält. </font><font style="vertical-align: inherit;">Dieses Netz sollte keine Schatten werfen und darf nur UV-Koordinaten verwenden. </font><font style="vertical-align: inherit;">Der schnellste Weg, dies zu tun, ist eine vorgefertigte Instanz - duplizieren Sie das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekt </font><font style="vertical-align: inherit;">und ersetzen Sie sein Material.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf8/476/a9e/bf8476a9e950a13c69051a5cd43480c1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a64/4d8/776/a644d8776f3c6f0ba64cf3aef666f475.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kinderobjektstraßen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie danach das </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemeine Feld hinzu </font></font><code>HexMesh roads</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">fügen Sie </font><font style="vertical-align: inherit;">es in ein </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Verbinden Sie es im Inspektor mit dem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roads-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekt </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers, roads; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a95/c0e/c2a/a95c0ec2ae59dccbb249e6a02ccdc7c5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Roads-Objekt ist verbunden.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Straßen zwischen Zellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns zunächst die Straßensegmente zwischen den Zellen an. </font><font style="vertical-align: inherit;">Wie Flüsse sind Straßen durch zwei mittlere Quad gesperrt. </font><font style="vertical-align: inherit;">Wir decken diese Verbindungsvierecke vollständig mit den Straßenvierecken ab, damit die Positionen der gleichen sechs Spitzen verwendet werden können. </font><font style="vertical-align: inherit;">Fügen Sie dazu der </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode hinzu </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, Vector3 v5, Vector3 v6 </span></span></span><span class="hljs-function">)</span></span> { roads.AddQuad(v1, v2, v4, v5); roads.AddQuad(v2, v3, v5, v6); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir uns nicht mehr um den Wasserfluss kümmern müssen, ist die V-Koordinate nicht erforderlich, daher weisen wir ihr überall den Wert 0 zu. Mit der U-Koordinate können wir angeben, ob wir uns mitten auf der Straße oder auf der Seite befinden. </font><font style="vertical-align: inherit;">Lassen Sie es in der Mitte gleich 1 und auf beiden Seiten gleich 0 sein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, Vector3 v5, Vector3 v6 </span></span></span><span class="hljs-function">)</span></span> { roads.AddQuad(v1, v2, v4, v5); roads.AddQuad(v2, v3, v5, v6); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26a/730/868/26a73086896099b06098de0a25eb63ae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Straßenabschnitt zwischen Zellen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wäre logisch, diese Methode aufzurufen </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber nur, wenn es wirklich eine Straße gibt. </font><font style="vertical-align: inherit;">Fügen Sie der Methode einen booleschen Parameter hinzu, um diese Informationen zu übergeben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Natürlich werden wir jetzt Compilerfehler erhalten, da diese Informationen bisher noch nicht übertragen wurden. </font><font style="vertical-align: inherit;">In allen Fällen kann der Aufruf </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als </font><font style="vertical-align: inherit;">letztes Argument </font><font style="vertical-align: inherit;">hinzugefügt werden </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir können jedoch auch deklarieren, dass der Standardwert dieses Parameters gleich ist </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aus diesem Grund wird der Parameter optional und Kompilierungsfehler verschwinden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { … }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie funktionieren optionale Parameter?</font></font></b> <div class="spoiler_text">        ,   . ,  <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; }</code> </pre> <br>    <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyMethod(x, <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyMethod(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; }</code> </pre> <br>   .      .    .      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Straße zu triangulieren, rufen Sie </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bei Bedarf </font><font style="vertical-align: inherit;">einfach </font><font style="vertical-align: inherit;">mit den mittleren sechs Gipfeln an.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); terrain.AddQuadColor(c1, c2); terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); terrain.AddQuadColor(c1, c2); terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); terrain.AddQuadColor(c1, c2); terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); terrain.AddQuadColor(c1, c2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoad) { TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So gehen wir mit Flachzellenverbindungen um. </font><font style="vertical-align: inherit;">Um die Straßen auf den Felsvorsprüngen zu unterstützen, müssen wir auch angeben, </font></font><code>TriangulateEdgeTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wo die Straße hinzugefügt werden soll. </font><font style="vertical-align: inherit;">Er kann diese Informationen einfach übermitteln </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.Color, endCell.Color, <span class="hljs-number"><span class="hljs-number">1</span></span>); TriangulateEdgeStrip(begin, beginCell.Color, e2, c2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(beginCell.Color, endCell.Color, i); TriangulateEdgeStrip(e1, c1, e2, c2, hasRoad); } TriangulateEdgeStrip(e2, c2, end, endCell.Color, hasRoad); }</code> </pre> <br> <code>TriangulateEdgeTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drinnen gerufen </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hier können wir feststellen, ob tatsächlich eine Straße in die aktuelle Richtung führt, sowohl beim Triangulieren einer Kante als auch beim Triangulieren von Leisten.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces( e1, cell, e2, neighbor, cell.HasRoadThroughEdge(direction) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip( e1, cell.Color, e2, neighbor.Color, cell.HasRoadThroughEdge(direction) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7a/67d/e7d/d7a67de7d2edeb2d23b63e9b37bc7508.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Straßensegmente zwischen Zellen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zelle über Rendering </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Zeichnen von Straßen sehen Sie, dass Straßensegmente zwischen Zellen angezeigt werden. Die Mitte dieser Segmente ist lila mit einem Übergang zu blau an den Rändern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie die Kamera bewegen, können die Segmente jedoch flackern und manchmal vollständig verschwinden. Dies liegt daran, dass die Dreiecke der Straßen genau die Geländedreiecke überlappen. Dreiecke zum Rendern werden zufällig ausgewählt. Dieses Problem kann in zwei Schritten behoben werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zunächst möchten wir die Straßen zeichnen, nachdem das Relief gezeichnet wurde. Dies kann erreicht werden, indem sie nach dem Rendern der üblichen Geometrie gerendert werden, dh indem sie in eine spätere Renderwarteschlange gestellt werden.</font></font><br><br><pre> <code class="hljs objectivec"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Opaque"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span> = <span class="hljs-string"><span class="hljs-string">"Geometry+1"</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens müssen wir sicherstellen, dass Straßen an derselben Position über Geländedreiecke gezogen werden. </font><font style="vertical-align: inherit;">Dies kann durch Hinzufügen des Tiefentestversatzes erfolgen. </font><font style="vertical-align: inherit;">Dadurch kann die GPU davon ausgehen, dass sich die Dreiecke näher an der Kamera befinden als sie tatsächlich sind.</font></font><br><br><pre> <code class="hljs powershell"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Opaque"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span> = <span class="hljs-string"><span class="hljs-string">"Geometry+1"</span></span> } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> Offset <span class="hljs-literal"><span class="hljs-literal">-1</span></span>, <span class="hljs-literal"><span class="hljs-literal">-1</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Straßen durch Zellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Triangulieren von Flüssen mussten wir uns mit nicht mehr als zwei Flussrichtungen pro Zelle befassen. Wir könnten fünf mögliche Optionen identifizieren und sie unterschiedlich triangulieren, um die richtig aussehenden Flüsse zu erzeugen. Bei Straßen gibt es jedoch vierzehn mögliche Optionen. Wir werden nicht für jede dieser Optionen separate Ansätze verwenden. Stattdessen werden wir jede der sechs Zellenrichtungen unabhängig von der spezifischen Straßenkonfiguration auf dieselbe Weise verarbeiten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn eine Straße entlang eines Teils der Zelle verläuft, zeichnen wir sie direkt in die Mitte der Zelle, ohne die Dreieckszone zu verlassen. Wir werden einen Straßenabschnitt vom Rand bis zur Hälfte in Richtung des Zentrums zeichnen. Dann verwenden wir zwei Dreiecke, um den Rest zur Mitte zu schließen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df0/659/a13/df0659a13206731d401579ba8c7f3b8f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangulation eines Teils der Straße. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dieses Schema zu triangulieren, müssen wir die Mitte der Zelle, die linken und rechten mittleren Eckpunkte und die Eckpunkte der Kante kennen. </font><font style="vertical-align: inherit;">Fügen Sie eine Methode </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit den entsprechenden Parametern hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um ein Straßensegment zu bauen, benötigen wir einen zusätzlichen Gipfel. </font><font style="vertical-align: inherit;">Es befindet sich zwischen dem linken und rechten mittleren Gipfel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { Vector3 mC = Vector3.Lerp(mL, mR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); TriangulateRoadSegment(mL, mC, mR, e.v2, e.v3, e.v4); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt können wir auch die verbleibenden zwei Dreiecke hinzufügen. </font></font><br><br><pre> <code class="cs hljs"> TriangulateRoadSegment(mL, mC, mR, e.v2, e.v3, e.v4); roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir müssen auch die UV-Koordinaten der Dreiecke hinzufügen. </font><font style="vertical-align: inherit;">Zwei ihrer Gipfel befinden sich in der Mitte der Straße, der Rest befindet sich am Rande.</font></font><br><br><pre> <code class="cs hljs"> roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beschränken wir uns vorerst auf Zellen, in denen es keine Flüsse gibt. </font><font style="vertical-align: inherit;">In diesen Fällen wird </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einfach ein Fan von Dreiecken erzeugt. </font><font style="vertical-align: inherit;">Verschieben Sie diesen Code in eine separate Methode. </font><font style="vertical-align: inherit;">Dann fügen wir einen Anruf hinzu, </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn die Straße tatsächlich ist. </font><font style="vertical-align: inherit;">Der linke und der rechte mittlere Scheitelpunkt können durch Interpolation zwischen dem mittleren und zwei Eckscheitelpunkten gefunden werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithoutRiver(direction, cell, center, e); } … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoadThroughEdge(direction)) { TriangulateRoad( center, Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), e ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29d/ae4/def/29dae4def1f841ae190e64b267f6e4ea.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Straßen, die durch die Zellen führen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Straßenrippen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir die Straßen sehen, aber näher an der Mitte der Zellen verengen sie sich. Da wir nicht prüfen, um welche der vierzehn Optionen es sich handelt, können wir die Mitte der Straße nicht verschieben, um schönere Formen zu erstellen. Stattdessen können wir zusätzliche Straßenkanten in anderen Teilen der Zelle hinzufügen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Straßen durch die Zelle verlaufen, jedoch nicht in der aktuellen Richtung, fügen wir den Straßenrändern ein Dreieck hinzu. Dieses Dreieck wird durch den mittleren, linken und rechten mittleren Eckpunkt definiert. In diesem Fall liegt nur der zentrale Gipfel in der Mitte der Straße. Die anderen beiden liegen auf ihrer Rippe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, Vector3 mL, Vector3 mR</span></span></span><span class="hljs-function">)</span></span> { roads.AddTriangle(center, mL, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/293/6ec/bd12936ec0833f7d7da4e038158bb167.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Teil des Straßenrandes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir eine volle Straße oder nur eine Kante triangulieren müssen, müssen wir sie verlassen </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zu diesem Zweck muss diese Methode wissen, ob die Straße durch die Richtung der aktuellen Zellenkante verläuft. </font><font style="vertical-align: inherit;">Deshalb fügen wir hierfür einen Parameter hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoadThroughCellEdge </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoadThroughCellEdge) { Vector3 mC = Vector3.Lerp(mL, mR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); TriangulateRoadSegment(mL, mC, mR, e.v2, e.v3, e.v4); roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateRoadEdge(center, mL, mR); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt muss </font></font><code>TriangulateWithoutRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es anrufen, </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn Straßen durch die Zelle führen. </font><font style="vertical-align: inherit;">Und er muss Informationen darüber übermitteln, ob die Straße durch die aktuelle Kante führt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { TriangulateRoad( center, Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), e, cell.HasRoadThroughEdge(direction) ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/89e/f99/1a0/89ef991a0790911d140b68b1457fb9df.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Straßen mit fertigen Rippen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Straßenglättung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Straßen sind jetzt fertig. </font><font style="vertical-align: inherit;">Leider erzeugt dieser Ansatz Ausbuchtungen in der Mitte der Zellen. </font><font style="vertical-align: inherit;">Das Platzieren der linken und rechten Spitze in der Mitte zwischen der Mitte und den Ecken passt zu uns, wenn sich neben ihnen eine Straße befindet. </font><font style="vertical-align: inherit;">Wenn dies nicht der Fall ist, liegt eine Ausbuchtung vor. </font><font style="vertical-align: inherit;">Um dies zu vermeiden, können wir in solchen Fällen die Eckpunkte näher an der Mitte platzieren. </font><font style="vertical-align: inherit;">Genauer gesagt, dann interpolieren mit ¼, nicht mit ½. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen wir eine separate Methode, um herauszufinden, welche Interpolatoren verwendet werden sollen. </font><font style="vertical-align: inherit;">Da es zwei davon gibt, können wir das Ergebnis eingeben </font></font><code>Vector2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seine Komponente X ist der Interpolator des linken Punktes und seine Komponente Y ist der Interpolator des rechten Punktes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRoadInterpolators</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector2 interpolators; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interpolators; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn eine Straße in die aktuelle Richtung führt, können wir die Punkte in der Mitte platzieren. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRoadInterpolators</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector2 interpolators; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoadThroughEdge(direction)) { interpolators.x = interpolators.y = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interpolators; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andernfalls können die Optionen unterschiedlich sein. </font><font style="vertical-align: inherit;">Für den linken Punkt können wir ½ verwenden, wenn eine Straße in die vorherige Richtung führt. </font><font style="vertical-align: inherit;">Wenn dies nicht der Fall ist, müssen wir ¼ verwenden. </font><font style="vertical-align: inherit;">Gleiches gilt für den richtigen Punkt, jedoch unter Berücksichtigung der folgenden Richtung.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRoadInterpolators</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector2 interpolators; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoadThroughEdge(direction)) { interpolators.x = interpolators.y = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { interpolators.x = cell.HasRoadThroughEdge(direction.Previous()) ? <span class="hljs-number"><span class="hljs-number">0.5f</span></span> : <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; interpolators.y = cell.HasRoadThroughEdge(direction.Next()) ? <span class="hljs-number"><span class="hljs-number">0.5f</span></span> : <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interpolators; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dieser neuen Methode können Sie jetzt bestimmen, welche Interpolatoren verwendet werden. </font><font style="vertical-align: inherit;">Dank dessen werden die Straßen geglättet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { Vector2 interpolators = GetRoadInterpolators(direction, cell); TriangulateRoad( center, Vector3.Lerp(center, e.v1, interpolators.x), Vector3.Lerp(center, e.v5, interpolators.y), e, cell.HasRoadThroughEdge(direction) ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c9/d0b/d12/3c9d0bd1262c2d47a3efc2d300212efd.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84c/5fa/4f8/84c5fa4f8ef27bd4f6d294d0bf50acf6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Glatte Straßen. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Kombination von Flüssen und Straßen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gegenwärtig haben wir funktionierende Straßen, aber nur, wenn es keine Flüsse gibt. </font><font style="vertical-align: inherit;">Wenn sich in der Zelle ein Fluss befindet, werden die Straßen nicht trianguliert.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5e/76f/814/f5e76f814407359057d0c1bb1688988c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Nähe der Flüsse gibt es keine Straßen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns eine Methode erstellen, </font></font><code>TriangulateRoadAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um mit dieser Situation umzugehen. </font><font style="vertical-align: inherit;">Wir stellen es auf die üblichen Parameter ein. </font><font style="vertical-align: inherit;">Wir werden es am Anfang der Methode aufrufen </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { TriangulateRoadAdjacentToRiver(direction, cell, center, e); } … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zunächst werden wir das Gleiche tun wie für Straßen ohne Flüsse. </font><font style="vertical-align: inherit;">Wir werden prüfen, ob die Straße durch die aktuelle Kante führt, Interpolatoren erhalten, Mittelspitzen erstellen und anrufen </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da jedoch Flüsse auf dem Weg erscheinen, müssen wir die Straßen von ihnen wegbewegen. </font><font style="vertical-align: inherit;">Infolgedessen befindet sich die Mitte der Straße in einer anderen Position. </font><font style="vertical-align: inherit;">Wir verwenden eine Variable, um diese neue Position zu speichern </font></font><code>roadCenter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Anfangs ist es gleich der Mitte der Zelle.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoadThroughEdge = cell.HasRoadThroughEdge(direction); Vector2 interpolators = GetRoadInterpolators(direction, cell); Vector3 roadCenter = center; Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also werden wir Teilstraßen in Zellen mit Flüssen erstellen. </font><font style="vertical-align: inherit;">Die Richtungen, durch die die Flüsse fließen, werden die Lücken in den Straßen durchschneiden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95e/029/595/95e0295954967415965a3992ffd91882.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Straßen mit Räumen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anfang oder Ende des Flusses </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns zunächst Zellen an, die entweder den Anfang oder das Ende eines Flusses enthalten. </font><font style="vertical-align: inherit;">Damit sich die Straßen nicht mit Wasser überschneiden, verschieben wir die Straßenmitte vom Fluss. </font><font style="vertical-align: inherit;">Fügen Sie die </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft </font><font style="vertical-align: inherit;">hinzu, um die Richtung des ein- oder ausgehenden Flusses zu ermitteln </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection RiverBeginOrEndDirection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver ? incomingRiver : outgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir diese Eigenschaft verwenden </font></font><code>HexGridChunk.TriangulateRoadAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Straßenmitte in die entgegengesetzte Richtung zu verschieben. </font><font style="vertical-align: inherit;">Es reicht aus, ein Drittel in diese Richtung zur Mittelrippe zu bewegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoadThroughEdge = cell.HasRoadThroughEdge(direction); Vector2 interpolators = GetRoadInterpolators(direction, cell); Vector3 roadCenter = center; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { roadCenter += HexMetrics.GetSolidEdgeMiddle( cell.RiverBeginOrEndDirection.Opposite() ) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f18/12b/280/f1812b2807add77e4d173b85ad65e4da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geänderte Straßen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als nächstes müssen wir die Lücken schließen. </font><font style="vertical-align: inherit;">Wir werden dies tun, indem wir zusätzliche Dreiecke an den Straßenrändern hinzufügen, wenn wir uns in der Nähe des Flusses befinden. </font><font style="vertical-align: inherit;">Wenn es in der vorherigen Richtung einen Fluss gibt, fügen wir ein Dreieck zwischen der Mitte der Straße, der Mitte der Zelle und dem mittleren linken Punkt hinzu. </font><font style="vertical-align: inherit;">Und wenn der Fluss in die nächste Richtung geht, fügen wir ein Dreieck zwischen der Mitte der Straße, dem mittleren rechten Punkt und der Mitte der Zelle hinzu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden dies unabhängig von der Konfiguration des Flusses tun, also setzen Sie diesen Code am Ende der Methode.</font></font><br><br><pre> <code class="cs hljs"> Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { TriangulateRoadEdge(roadCenter, center, mL); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { TriangulateRoadEdge(roadCenter, mR, center); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Können Sie die else-Anweisung nicht verwenden?</font></font></b> <div class="spoiler_text">      .   ,     . </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93d/485/bc8/93d485bc8072e6fa8471fb98d084467a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bereit Straßen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gerade Flüsse </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zellen mit geraden Flüssen sind besonders schwierig, da sie das Zentrum der Zelle im Wesentlichen in zwei Teile teilen. </font><font style="vertical-align: inherit;">Wir fügen bereits zusätzliche Dreiecke hinzu, um die Lücken zwischen den Flüssen zu füllen, aber wir müssen auch die Straßen auf gegenüberliegenden Seiten des Flusses trennen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab6/203/055/ab62030558305530ed4aed038669ba9c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Straßen, die einen geraden Fluss überlappen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Zelle nicht den Anfang oder das Ende des Flusses hat, können wir prüfen, ob die ein- und ausgehenden Flüsse in entgegengesetzte Richtungen fließen. </font><font style="vertical-align: inherit;">Wenn ja, dann haben wir einen direkten Fluss.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { roadCenter += HexMetrics.GetSolidEdgeMiddle( cell.RiverBeginOrEndDirection.Opposite() ) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um festzustellen, wo sich der Fluss relativ zur aktuellen Richtung befindet, müssen wir die benachbarten Richtungen überprüfen. </font><font style="vertical-align: inherit;">Der Fluss ist entweder links oder rechts. </font><font style="vertical-align: inherit;">Da wir dies am Ende der Methode tun, werden diese Anforderungen in booleschen Variablen zwischengespeichert. </font><font style="vertical-align: inherit;">Dies vereinfacht auch das Lesen unseres Codes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoadThroughEdge = cell.HasRoadThroughEdge(direction); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> previousHasRiver = cell.HasRiverThroughEdge(direction.Previous()); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> nextHasRiver = cell.HasRiverThroughEdge(direction.Next()); Vector2 interpolators = GetRoadInterpolators(direction, cell); Vector3 roadCenter = center; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { roadCenter += HexMetrics.GetSolidEdgeMiddle( cell.RiverBeginOrEndDirection.Opposite() ) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { } } Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { TriangulateRoadEdge(roadCenter, center, mL); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { TriangulateRoadEdge(roadCenter, mR, center); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir müssen die Mitte der Straße auf einen Winkelvektor verschieben, der in die entgegengesetzte Richtung vom Fluss zeigt. </font><font style="vertical-align: inherit;">Wenn der Fluss durch die vorherige Richtung fließt, ist dies der zweite Raumwinkel. </font><font style="vertical-align: inherit;">Ansonsten ist dies der erste Raumwinkel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { Vector3 corner; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { corner = HexMetrics.GetSecondSolidCorner(direction); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { corner = HexMetrics.GetFirstSolidCorner(direction); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Straße so zu bewegen, dass sie an den Fluss angrenzt, müssen wir die Mitte der Straße um den halben Abstand zu dieser Ecke verschieben. </font><font style="vertical-align: inherit;">Dann müssen wir auch die Mitte der Zelle um ein Viertel der Entfernung in diese Richtung bewegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { Vector3 corner; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { corner = HexMetrics.GetSecondSolidCorner(direction); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { corner = HexMetrics.GetFirstSolidCorner(direction); } roadCenter += corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; center += corner * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4c/6bf/85b/e4c6bf85b3120697996ad75a3256a3a0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geteilte Straßen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben ein Straßennetz in dieser Zelle geteilt. </font><font style="vertical-align: inherit;">Dies ist normal, wenn sich die Straßen auf beiden Seiten des Flusses befinden. </font><font style="vertical-align: inherit;">Aber wenn es auf einer Seite keine Straße gibt, haben wir ein kleines Stück einer abgelegenen Straße. </font><font style="vertical-align: inherit;">Das ist unlogisch, also lasst uns solche Teile loswerden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sicher, dass eine Straße in die aktuelle Richtung führt. </font><font style="vertical-align: inherit;">Ist dies nicht der Fall, überprüfen Sie die andere Richtung derselben Flussseite auf das Vorhandensein der Straße. </font><font style="vertical-align: inherit;">Wenn es dort oder dort keine vorbeifahrende Straße gibt, verlassen wir die Methode vor dem Triangulieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !hasRoadThroughEdge &amp;&amp; !cell.HasRoadThroughEdge(direction.Next()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } corner = HexMetrics.GetSecondSolidCorner(direction); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !hasRoadThroughEdge &amp;&amp; !cell.HasRoadThroughEdge(direction.Previous()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } corner = HexMetrics.GetFirstSolidCorner(direction); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09e/398/532/09e398532543dcd7f78987c23e012571.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verkürzte Straßen.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist mit Brücken?</font></font></b> <div class="spoiler_text">     .         . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zick-Zack-Flüsse </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die nächste Art von Fluss ist Zickzack. </font><font style="vertical-align: inherit;">Solche Flüsse teilen sich nicht das Straßennetz, daher müssen wir nur die Mitte der Straße verschieben.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/851/29b/f56/85129bf56e4948296b17916094fd9d8b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zickzack durch die Straßen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der einfachste Weg, um nach Zickzack zu suchen, besteht darin, die Richtungen der ein- und ausgehenden Flüsse zu vergleichen. </font><font style="vertical-align: inherit;">Wenn sie benachbart sind, haben wir einen Zickzack. </font><font style="vertical-align: inherit;">Dies führt je nach Strömungsrichtung zu zwei möglichen Optionen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Previous()) { } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Next()) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können die Mitte der Straße mit einer der Ecken der Richtung des ankommenden Flusses verschieben. </font><font style="vertical-align: inherit;">Der von Ihnen gewählte Winkel hängt von der Strömungsrichtung ab. </font><font style="vertical-align: inherit;">Bewegen Sie die Straßenmitte aus diesem Winkel um den Faktor 0,2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Previous()) { roadCenter -= HexMetrics.GetSecondCorner(cell.IncomingRiver) * <span class="hljs-number"><span class="hljs-number">0.2f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Next()) { roadCenter -= HexMetrics.GetFirstCorner(cell.IncomingRiver) * <span class="hljs-number"><span class="hljs-number">0.2f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fa/3c6/f27/1fa3c6f277079e277491027207f9398f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Straße schob sich von den Zickzacklinien weg.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In den krummen Flüssen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die letzte Flusskonfiguration ist eine glatte Kurve. </font><font style="vertical-align: inherit;">Wie beim direkten Fluss kann auch dieser Straßen trennen. </font><font style="vertical-align: inherit;">In diesem Fall sind die Parteien jedoch unterschiedlich. </font><font style="vertical-align: inherit;">Zuerst müssen wir mit der Innenseite der Kurve arbeiten.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/566/b8f/3db/566b8f3dbffec4cdc91556abe0f2bf5e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein geschwungener Fluss mit asphaltierten Straßen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir auf beiden Seiten der aktuellen Richtung einen Fluss haben, befinden wir uns innerhalb der Kurve.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Next()) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir müssen die Straßenmitte zum aktuellen Rand der Zelle bewegen und die Straße etwas verkürzen. </font><font style="vertical-align: inherit;">Ein Koeffizient von 0,7 reicht aus. </font><font style="vertical-align: inherit;">Das Zellzentrum sollte sich ebenfalls mit einem Koeffizienten von 0,5 verschieben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { Vector3 offset = HexMetrics.GetSolidEdgeMiddle(direction) * HexMetrics.innerToOuter; roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>; center += offset * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2d/64f/a82/a2d64fa828544540d43856bf94e34f9d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verkürzte Straßen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bei geraden Flüssen müssen wir die isolierten Teile der Straßen abschneiden. </font><font style="vertical-align: inherit;">In diesem Fall reicht es aus, nur die aktuelle Richtung zu überprüfen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasRoadThroughEdge) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 offset = HexMetrics.GetSolidEdgeMiddle(direction) * HexMetrics.innerToOuter; roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>; center += offset * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30b/6a0/d9d/30b6a0d9db5fe0960265713c62ef2ae5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Straßen abschneiden.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Außerhalb der krummen Flüsse </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach Überprüfung aller vorherigen Fälle war die einzige verbleibende Option der äußere Teil des gekrümmten Flusses. </font><font style="vertical-align: inherit;">Draußen gibt es drei Teile der Zelle. </font><font style="vertical-align: inherit;">Wir müssen die mittlere Richtung finden. </font><font style="vertical-align: inherit;">Nachdem wir es erhalten haben, können wir die Mitte der Straße um den Faktor 0,25 in Richtung dieser Rippe bewegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { HexDirection middle; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { middle = direction.Next(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { middle = direction.Previous(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { middle = direction; } roadCenter += HexMetrics.GetSolidEdgeMiddle(middle) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b8/84c/a29/8b884ca29118c36e522674cd00ab8613.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Außenseite der Straße wurde geändert. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als letzten Schritt müssen wir die Straßen auf dieser Seite des Flusses abschneiden. </font><font style="vertical-align: inherit;">Am einfachsten ist es, alle drei Straßenrichtungen relativ zur Mitte zu überprüfen. </font><font style="vertical-align: inherit;">Wenn es keine Straßen gibt, hören wir auf zu arbeiten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { HexDirection middle; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { middle = direction.Next(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { middle = direction.Previous(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { middle = direction; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !cell.HasRoadThroughEdge(middle) &amp;&amp; !cell.HasRoadThroughEdge(middle.Previous()) &amp;&amp; !cell.HasRoadThroughEdge(middle.Next()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } roadCenter += HexMetrics.GetSolidEdgeMiddle(middle) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56d/69a/d1b/56d69ad1b8d6ffdf74e9adb1c4800695.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/8c3/178/a9a8c3178c8a44738b4bbd01ef5f221d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Straßen vor und nach dem Abschneiden. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem alle Flussoptionen verarbeitet wurden, können unsere Flüsse und Straßen nebeneinander existieren. </font><font style="vertical-align: inherit;">Flüsse ignorieren Straßen und Straßen passen sich an Flüsse an.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b32/6e4/28b/b326e428b45df027cac2f99a336e71e9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kombination von Flüssen und Straßen. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Aussehen der Straßen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bis zu diesem Moment haben wir ihre UV-Koordinaten als Straßenfarben verwendet. </font><font style="vertical-align: inherit;">Da sich nur die U-Koordinate geändert hat, haben wir tatsächlich den Übergang zwischen der Mitte und dem Straßenrand angezeigt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/cb2/8ac/084cb28ac448ddb258846c09d8b3b83a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anzeige von UV-Koordinaten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt, da die Straßen genau richtig trianguliert sind, können wir den Road Shader so ändern, dass er eher Straßen ähnelt. </font><font style="vertical-align: inherit;">Wie bei Flüssen ist dies eine einfache Visualisierung ohne Schnickschnack. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir beginnen mit der Verwendung von Volltonfarben für Straßen. </font><font style="vertical-align: inherit;">Verwenden Sie einfach die Farbe des Materials. </font><font style="vertical-align: inherit;">Ich habe es rot gemacht.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = _Color; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/304/2e4/ab4/3042e4ab4b01b3389822072244208cb6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rote Straßen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und es sieht schon viel besser aus! </font><font style="vertical-align: inherit;">Aber lassen Sie uns fortfahren und die Straße mit dem Gelände mischen, wobei wir die U-Koordinate als Mischfaktor verwenden.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = _Color; <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = blend; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es scheint, dass dies nichts geändert hat. </font><font style="vertical-align: inherit;">Es ist passiert, weil unser Shader undurchsichtig ist. </font><font style="vertical-align: inherit;">Jetzt braucht er Alpha-Blending. </font><font style="vertical-align: inherit;">Insbesondere benötigen wir einen Shader für eine passende Aufkleberoberfläche. </font><font style="vertical-align: inherit;">Wir können den erforderlichen Shader erhalten, indem wir der Direktive eine </font></font><code>#pragma surface</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeile </font><font style="vertical-align: inherit;">hinzufügen </font></font><code>decal:blend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Standard fullforwardshadows decal:blend</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/66c/501/7a066c5015ea14533f1b9ed881469323.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Mischung der Straßen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also haben wir eine glatte lineare Mischung von der Mitte bis zur Kante erstellt, die nicht sehr hübsch aussieht. </font><font style="vertical-align: inherit;">Damit es wie eine Straße aussieht, benötigen wir einen festen Bereich, gefolgt von einem schnellen Übergang zu einem undurchsichtigen Bereich. </font><font style="vertical-align: inherit;">Sie können die Funktion dafür verwenden </font></font><code>smoothstep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es wandelt einen linearen Verlauf von 0 nach 1 in eine S-förmige Kurve um.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b0/030/f57/2b0030f57819183470fc7fae72ea18bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lineare Progression und sanfter Schritt. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Funktion </font></font><code>smoothstep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verfügt über einen minimalen und einen maximalen Parameter, um die Kurve in einem beliebigen Intervall anzupassen. </font><font style="vertical-align: inherit;">Eingabewerte außerhalb des Bereichs sind begrenzt, um die Kurve flach zu halten. </font><font style="vertical-align: inherit;">Verwenden wir 0,4 am Anfang der Kurve und 0,7 am Ende. </font><font style="vertical-align: inherit;">Dies bedeutet, dass die U-Koordinate von 0 bis 0,4 vollständig transparent ist. </font><font style="vertical-align: inherit;">Und U-Koordinaten von 0,7 bis 1 sind vollständig undurchsichtig. </font><font style="vertical-align: inherit;">Der Übergang erfolgt zwischen 0,4 und 0,7.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x; blend = smoothstep(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, blend);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/543/fe1/4b4/543fe14b4d760b820ec106626230876f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schneller Übergang zwischen undurchsichtigen und transparenten Bereichen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Straße mit Lärm </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da das Straßennetz verzerrt wird, haben die Straßen unterschiedliche Breiten. </font><font style="vertical-align: inherit;">Daher ist auch die Breite des Übergangs an den Kanten variabel. </font><font style="vertical-align: inherit;">Manchmal ist es verschwommen, manchmal hart. </font><font style="vertical-align: inherit;">Eine solche Variabilität passt zu uns, wenn wir die Straßen als sandig oder erdig wahrnehmen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Machen wir den nächsten Schritt und fügen Sie den Straßenrändern Lärm hinzu. </font><font style="vertical-align: inherit;">Dadurch werden sie ungleichmäßiger und weniger polygonal. </font><font style="vertical-align: inherit;">Wir können dies tun, indem wir die Rauschtextur abtasten. </font><font style="vertical-align: inherit;">Für die Abtastung können Sie die Koordinaten der XZ-Welt verwenden, genau wie beim Verzerren der Eckpunkte der Zellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie der Eingabestruktur hinzu, um Zugriff auf die Position der Welt im Surface Shader zu erhalten </font></font><code>float3 worldPos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float2 uv_MainTex; float3 worldPos; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir diese Position verwenden </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Haupttextur abzutasten. </font><font style="vertical-align: inherit;">Verkleinern Sie auch, sonst wiederholt sich die Textur zu oft.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); fixed4 c = _Color; <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verzerren den Übergang, indem wir die Koordinate U mit multiplizieren </font></font><code>noise.x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da die Geräuschwerte jedoch durchschnittlich 0,5 betragen, verschwinden die meisten Straßen. </font><font style="vertical-align: inherit;">Um dies zu vermeiden, addieren Sie vor der Multiplikation 0,5 zum Rauschen.</font></font><br><br><pre> <code class="hljs mel"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blend = IN.uv_MainTex.x; blend *= <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>.x + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; blend = <span class="hljs-keyword"><span class="hljs-keyword">smoothstep</span></span>(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, blend);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/b7d/e28/c08b7de2879b84c816286530871b6a6f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4be/bdf/28f/4bebdf28fc519b3f186f119b6e501261.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verzerrte Straßenränder. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dies zu beenden, werden wir auch die Farbe der Straßen verzerren. </font><font style="vertical-align: inherit;">Dies gibt den Straßen ein Gefühl von Schmutz, der unscharfen Kanten entspricht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multiplizieren Sie die Farbe mit einem anderen Rauschkanal, z </font></font><code>noise.y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">B. mit </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir erhalten also durchschnittlich die Hälfte des Farbwerts. </font><font style="vertical-align: inherit;">Da dies zu viel ist, werden wir die Rauschskala leicht reduzieren und eine Konstante hinzufügen, damit die Summe 1 erreichen kann.</font></font><br><br><pre> <code class="hljs swift"> fixed4 <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = _Color * (noise.y * <span class="hljs-number"><span class="hljs-number">0.75</span></span> + <span class="hljs-number"><span class="hljs-number">0.25</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d2/a25/d49/6d2a25d4929cf56f7c4059352b4ed70a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raue Straßen. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424491/">https://habr.com/ru/post/de424491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424475/index.html">Bericht des Informationssicherheits-Überwachungszentrums für das erste Halbjahr 2018</a></li>
<li><a href="../de424477/index.html">Die Verfügbarkeit von Spielen auf Pygame</a></li>
<li><a href="../de424481/index.html">Die ganze Wahrheit über RTOS. Artikel 11. Aufgaben: Konfiguration und Einführung in die API</a></li>
<li><a href="../de424483/index.html">38-Milliarden-Dollar-Deal und seine Auswirkungen: Wie Comcast und Disney Amazon und Netflix mit Investitionen bekämpfen</a></li>
<li><a href="../de424485/index.html">SSL-Pinning-Bypass in der iOS-App</a></li>
<li><a href="../de424495/index.html">Google Chrome bietet die Möglichkeit, die automatische Profilsynchronisierung bei der Anmeldung bei den Diensten des Unternehmens abzulehnen. *</a></li>
<li><a href="../de424497/index.html">Hören Sie auf, die Entwickler von Betrug zu verdächtigen. Lerne besser zu interviewen</a></li>
<li><a href="../de424499/index.html">Nun er, dein Pentest</a></li>
<li><a href="../de424501/index.html">Diagnoseterminals für echte Schweißer</a></li>
<li><a href="../de424503/index.html">Boot dich selbst, der Frühling kommt (Teil 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>