<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçâ ü•å üí£ Unity Hexagon Maps: Rauheiten, Fl√ºsse und Stra√üen üë®üèø‚Äçüîß üë©‚Äçüë©‚Äçüë¶‚Äçüë¶ üíò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teile 1-3: Netz, Farben und Zellenh√∂hen 

 Teile 4-7: Unebenheiten, Fl√ºsse und Stra√üen 

 Teile 8-11: Wasser, Landformen und W√§lle 

 Teile 12-15: Spe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity Hexagon Maps: Rauheiten, Fl√ºsse und Stra√üen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424491/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/b6b/8a9/716b6b8a9d024dc87b2d645b5d4bdbb6.jpg" alt="Bild"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 1-3: Netz, Farben und Zellenh√∂hen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 4-7: Unebenheiten, Fl√ºsse und Stra√üen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 8-11: Wasser, Landformen und W√§lle</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 12-15: Speichern und Laden, Texturen, Entfernungen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 16-19: Weg finden, Spielerkader, Animationen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 20-23: Nebel des Krieges, Kartenforschung, Verfahrensgenerierung</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 24-27: Wasserkreislauf, Erosion, Biomes, zylindrische Karte</a> <br><br><h1>  Teil 4: Rauheiten </h1><br><h2>  Inhaltsverzeichnis </h2><br><ul><li>  Probieren Sie die Rauschstruktur aus. </li><li>  Verschieben Sie die Eckpunkte. </li><li>  Wir bewahren die Flachheit der Zellen. </li><li>  Unterteilen Sie die Kanten der Zellen. </li></ul><br>  W√§hrend unser Gitter ein strenges Muster von Waben war.  In diesem Teil werden wir Unebenheiten hinzuf√ºgen, damit die Karte nat√ºrlicher aussieht. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e33/034/982/e33034982aafb942e1e656b76dde0981.png"></div><br>  <i>Keine gleichm√§√üigen Sechsecke mehr.</i> <br><br><h2>  Der L√§rm </h2><br>  Um Unebenheiten hinzuzuf√ºgen, ben√∂tigen wir eine Randomisierung, aber keine echte Zuf√§lligkeit.  Wir m√∂chten, dass beim √Ñndern der Karte alles konsistent ist.  Andernfalls springen die Objekte, wenn Sie √Ñnderungen vornehmen.  Das hei√üt, wir brauchen irgendeine Form von reproduzierbarem Pseudozufallsrauschen. <br><br>  Ein guter Kandidat ist Perlins L√§rm.  Es ist √ºberall reproduzierbar.  Wenn mehrere Frequenzen kombiniert werden, entsteht auch ein Rauschen, das √ºber gro√üe Entfernungen stark variieren kann, auf kurzen Entfernungen jedoch nahezu gleich bleibt.  Dadurch k√∂nnen relativ glatte Verzerrungen erzeugt werden.  Aneinander benachbarte Punkte bleiben normalerweise in der N√§he und sind nicht in entgegengesetzte Richtungen verstreut. <br><br>  Wir k√∂nnen Perlin-Rauschen programmgesteuert erzeugen.  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Noise-</a> Tutorial erkl√§re ich, wie das geht.  Wir k√∂nnen aber auch von einer vorgenerierten Rauschtextur abtasten.  Der Vorteil der Verwendung von Texturen besteht darin, dass sie einfacher und schneller sind als die Berechnung des Mehrfrequenzrauschens von Perlin.  Der Nachteil ist, dass die Textur mehr Speicherplatz beansprucht und nur einen kleinen Rauschbereich abdeckt.  Daher sollte es nahtlos verbunden und gro√ü genug sein, damit die Wiederholung nicht auff√§llt. <br><br><h3>  Rauschstruktur </h3><br>  Wir werden die Textur verwenden, daher ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Noise-</a> Tutorial optional.  Wir brauchen also eine Textur.  Da ist sie: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbd/8e8/5d7/fbd8e85d783626c737decd6bc69a2519.png"></div><br>  <i>Perlin Noise Textur nahtlos verbinden.</i> <br><br>  Die oben gezeigte Textur enth√§lt Perlins nahtlos gekoppeltes Mehrfrequenzrauschen.  Dies ist ein Graustufenbild.  Sein Durchschnittswert betr√§gt 0,5 und die Extremwerte tendieren zu 0 und 1. <br><br>  Aber warten Sie, es gibt nur einen Wert f√ºr jeden Punkt.  Wenn wir eine 3D-Verzerrung ben√∂tigen, ben√∂tigen wir mindestens drei Pseudozufallsstichproben!  Daher ben√∂tigen wir zwei weitere Texturen mit unterschiedlichem Rauschen. <br><br>  Wir k√∂nnen sie erstellen oder unterschiedliche Rauschwerte in jedem der Farbkan√§le speichern.  Auf diese Weise k√∂nnen wir bis zu vier Rauschmuster in einer Textur speichern.  Hier ist diese Textur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1d/509/aca/a1d509acaf05d64de002829afc59cb90.png"></div><br>  <i>Vier in einem.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Wie erstelle ich eine solche Textur?</b> <div class="spoiler_text">  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NumberFlow verwendet</a> .  Dies ist der prozedurale Textureditor, den ich f√ºr Unity erstellt habe. </div></div><br>  Laden Sie diese Textur herunter und importieren Sie sie in Ihr Unity-Projekt.  Da wir die Textur durch Code abtasten werden, sollte sie lesbar sein.  Schalten Sie den <em>Texturtyp</em> auf <em>Erweitert</em> und aktivieren Sie <em>Lesen / Schreiben aktiviert</em> .  Dadurch werden die Texturdaten im Speicher gespeichert und k√∂nnen √ºber C # -Code aufgerufen werden.  Stellen Sie <em>Format</em> auf <em>Automatic Truecolor ein</em> , sonst funktioniert nichts.  Wir m√∂chten nicht, dass die Texturkomprimierung unser Rauschmuster zerst√∂rt. <br><br>  Sie k√∂nnen <em>Mip Maps generieren</em> deaktivieren, da wir sie nicht ben√∂tigen.  Aktivieren Sie auch <em>Bypass sRGB Sampling</em> .  Wir werden das nicht brauchen, aber es wird so sein.  Dieser Parameter gibt an, dass die Textur keine Farbdaten im Gammaraum enth√§lt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3aa/c36/e45/3aac36e45d7ead64823dc57b55afe67e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5fe/6c8/99a/5fe6c899a966eecb34046d5c243036b7.png"></div><br>  Importierte Rauschtextur. <br><br><div class="spoiler">  <b class="spoiler_title">Wann ist sRGB-Sampling wichtig?</b> <div class="spoiler_text">  Wenn wir eine Textur in einem Shader verwenden m√∂chten, w√ºrde dies einen Unterschied machen.  Wenn Sie den linearen Rendering-Modus verwenden, konvertiert das Abtasten der Textur automatisch die Farbdaten aus dem Farbumfang in einen linearen Farbraum.  Im Fall unserer Rauschstruktur f√ºhrt dies zu falschen Ergebnissen, sodass wir dies nicht ben√∂tigen. </div></div><br><div class="spoiler">  <b class="spoiler_title">Warum sehen meine Einstellungen f√ºr den Texturimport anders aus?</b> <div class="spoiler_text">  Sie wurden ge√§ndert, nachdem dieses Tutorial geschrieben wurde.  Sie m√ºssen die Standard-2D-Textureinstellungen verwenden, <em>sRGB (Color Texture)</em> sollte deaktiviert und <em>Compression</em> auf <em>None gesetzt sein</em> . </div></div><br><h3>  Rauschabtastung </h3><br>  <code>HexMetrics</code> wir <code>HexMetrics</code> Rauschabtastfunktionen <code>HexMetrics</code> damit Sie es √ºberall verwenden k√∂nnen.  Dies bedeutet, dass <code>HexMetrics</code> einen Verweis auf die Rauschtextur enthalten muss. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Texture2D noiseSource;</code> </pre> <br>  Da dies keine Komponente ist, k√∂nnen wir ihr √ºber den Editor keine Textur zuweisen.  Daher verwenden wir als Vermittler <code>HexGrid</code> .  Da <code>HexGrid</code> zuerst wirkt, ist es in Ordnung, wenn wir die Textur zu Beginn der <code>Awake</code> Methode √ºbergeben. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Texture2D noiseSource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; ‚Ä¶ }</code> </pre> <br>  Dieser Ansatz √ºberlebt jedoch die Neukompilierung im Wiedergabemodus nicht.  Statische Variablen werden von der Unity-Engine nicht serialisiert.  Um dieses Problem zu l√∂sen, <code>OnEnable</code> die Textur auch in der <code>OnEnable</code> Ereignismethode neu zu.  Diese Methode wird nach der Neukompilierung aufgerufen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d87/4fd/3a5/d874fd3a57faad4e57e5af830b202a19.png"></div><br>  <i>Weisen Sie eine Rauschstruktur zu.</i> <br><br>  <code>HexMetrics</code> nun Zugriff auf die Textur hat, f√ºgen wir eine praktische Rauschabtastmethode hinzu.  Diese Methode nimmt eine Position in der Welt ein und erzeugt einen 4D-Vektor, der vier Rauschproben enth√§lt. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Proben wurden durch Abtasten der Textur unter Verwendung einer bilinearen Filterung erstellt, bei der die Koordinaten der Welt X und Z als UV-Koordinaten verwendet wurden. Da unsere Rauschquelle zweidimensional ist, ignorieren wir die dritte Koordinate der Welt.  Wenn die Rauschquelle dreidimensional w√§re, w√ºrden wir auch die Y-Koordinate verwenden. <br><br>  Als Ergebnis erhalten wir eine Farbe, die in einen 4D-Vektor konvertiert werden kann.  Eine solche Reduzierung kann indirekt sein, <code>(Vector4)</code> wir k√∂nnen die Farbe direkt zur√ºckgeben, ohne explizit <code>(Vector4)</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> noiseSource.GetPixelBilinear(position.x, position.z); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Wie funktioniert die bilineare Filterung?</b> <div class="spoiler_text">  Eine Erkl√§rung der UV-Koordinaten und der Texturfilterung finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendering 2-</a> Tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, Shader Fundamentals</a> . </div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Scheitelpunktbewegung </h2><br>  Wir werden unser glattes Gitter aus Waben verzerren und jeden der Eckpunkte einzeln bewegen.  <code>HexMesh</code> Sie dazu die <code>HexMesh</code> Methode zu <code>Perturb</code> .  Es nimmt einen unbeweglichen Punkt und gibt den bewegten zur√ºck.  Zu diesem Zweck verwendet er beim Abtasten von Rauschen einen nicht verschobenen Punkt. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); }</code> </pre> <br>  F√ºgen wir einfach die Rauschabtastwerte X, Y und Z direkt zu den entsprechenden Punktkoordinaten hinzu und verwenden Sie diese als Ergebnis. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += sample.x; position.y += sample.y; position.z += sample.z; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br>  Wie k√∂nnen wir <code>HexMesh</code> schnell √§ndern, um alle Scheitelpunkte zu verschieben?  <code>AddTriangle</code> √Ñndern jedes Scheitelpunkts beim Hinzuf√ºgen von Scheitelpunkten zur Liste in den <code>AddQuad</code> <code>AddTriangle</code> und <code>AddQuad</code> .  Lass es uns tun. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(Perturb(v1)); vertices.Add(Perturb(v2)); vertices.Add(Perturb(v3)); ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(Perturb(v1)); vertices.Add(Perturb(v2)); vertices.Add(Perturb(v3)); vertices.Add(Perturb(v4)); ‚Ä¶ }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Bleiben Vierecke nach dem Verschieben ihrer Eckpunkte flach?</b> <div class="spoiler_text">  H√∂chstwahrscheinlich nicht.  Sie bestehen aus zwei Dreiecken, die nicht mehr in derselben Ebene liegen.  Da diese Dreiecke jedoch zwei gemeinsame Scheitelpunkte haben, werden die Normalen dieser Scheitelpunkte gegl√§ttet.  Dies bedeutet, dass wir keine scharfen √úberg√§nge zwischen zwei Dreiecken haben werden.  Wenn die Verzerrung nicht zu gro√ü ist, werden wir die Vierecke immer noch als flach wahrnehmen. </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/589/55c/47d/58955c47d221104096d943df9f9b948c.png"></div><br>  <i>Die Eckpunkte werden entweder verschoben oder nicht.</i> <br><br>  W√§hrend die √Ñnderungen nicht sehr auff√§llig sind, sind nur die Zellbezeichnungen verschwunden.  Dies geschah, weil wir den Punkten Rauschproben hinzugef√ºgt haben, die immer positiv sind.  Infolgedessen stiegen alle Dreiecke √ºber ihre Markierungen und schlossen sie.  Wir m√ºssen die √Ñnderungen so zentrieren, dass sie in beide Richtungen auftreten.  √Ñndern Sie das Intervall der Rauschprobe von 0‚Äì1 auf ‚Äì1‚Äì1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>; position.y += sample.y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>; position.z += sample.z * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f0/bd6/83a/1f0bd683ad92592fa6c5df171eab646c.png"></div><br>  <i>Zentrierte Verschiebung.</i> <br><br><h3>  Die Gr√∂√üe (Kraft) der Verschiebung </h3><br>  Jetzt ist es offensichtlich, dass wir das Raster verzerrt haben, aber der Effekt ist kaum sp√ºrbar.  Die √Ñnderung in jeder Dimension betr√§gt nicht mehr als 1 Einheit.  Das hei√üt, die theoretische maximale Verschiebung betr√§gt ‚àö3 ‚âà 1,73 Einheiten, was, wenn √ºberhaupt, √§u√üerst selten vorkommt.  Da der Au√üenradius der Zellen 10 Einheiten betr√§gt, sind die Verschiebungen relativ klein. <br><br>  Die L√∂sung besteht darin, <code>HexMetrics</code> einen <code>HexMetrics</code> damit Sie die Bewegungen skalieren k√∂nnen.  Versuchen wir, Kraft 5 anzuwenden. In diesem Fall betr√§gt die theoretische maximale Verschiebung ‚àö75 ‚âà 8,66 Einheiten, was viel deutlicher ist. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">5f</span></span>;</code> </pre> <br>  Wir wenden Kraft an, indem wir sie mit Stichproben in <code>HexMesh.Perturb</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += (sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; position.y += (sample.y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; position.z += (sample.z * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa8/2ef/fc0/fa82effc05a418729e81ee54f0922f26.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b19/fc8/3f0/b19fc83f0828160b2100a346083f1047.png"></div><br>  <i>Erh√∂hte Kraft.</i> <br><br><h3>  Ger√§uschskala </h3><br>  Obwohl das Raster vor der √Ñnderung gut aussieht, kann nach dem Erscheinen der Leisten alles schief gehen.  Ihre Spitzen k√∂nnen in unvorhersehbar unterschiedliche Richtungen verzerrt sein, was zu Chaos f√ºhrt.  Bei Verwendung von Perlin-Rauschen sollte dies nicht passieren. <br><br>  Das Problem entsteht, weil wir die Koordinaten der Welt direkt verwenden, um das Rauschen abzutasten.  Aus diesem Grund ist die Textur in jeder Einheit verborgen und die Zellen sind viel gr√∂√üer als dieser Wert.  Tats√§chlich wird die Textur an beliebigen Punkten abgetastet, wodurch ihre vorhandene Integrit√§t zerst√∂rt wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3f/bd1/717/f3fbd1717515fdf4e500e9674d82a08f.png"></div><br>  <i>Zeilen mit einem Raster von 10 x 10 √ºberlappen Zellen.</i> <br><br>  Wir m√ºssen die Rauschabtastung so skalieren, dass die Textur einen viel gr√∂√üeren Bereich abdeckt.  <code>HexMetrics</code> wir diese Skala zu <code>HexMetrics</code> weisen ihr einen Wert von 0,003 zu und skalieren dann die Koordinaten der Stichproben um diesen Faktor. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> noiseScale = <span class="hljs-number"><span class="hljs-number">0.003f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); }</code> </pre> <br>  Es stellt sich pl√∂tzlich heraus, dass unsere Textur 333 &amp; frac13;  quadratische Einheiten, und seine lokale Integrit√§t wird offensichtlich. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9de/219/e7a/9de219e7ae0495bcc9dfc2eca4ce52d6.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53c/0fc/e14/53c0fce142f96daecfd5001ac45e2222.png"></div><br>  <i>Skaliertes Rauschen.</i> <br><br>  Zus√§tzlich vergr√∂√üert eine neue Skala den Abstand zwischen den Ger√§uschfugen.  Da die Zellen einen Innendurchmesser von 10 ‚àö 3 Einheiten haben, werden sie in der X-Dimension niemals exakt gekachelt. Aufgrund der lokalen Integrit√§t des Rauschens k√∂nnen wir jedoch in gr√∂√üerem Ma√üstab immer noch sich wiederholende Muster erkennen, etwa alle 20 Zellen. auch wenn die Details nicht √ºbereinstimmen.  Sie sind jedoch nur auf der Karte ohne andere charakteristische Merkmale erkennbar. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Zellzentren ausrichten </h2><br>  Wenn Sie alle Scheitelpunkte verschieben, sieht die Karte nat√ºrlicher aus, es gibt jedoch mehrere Probleme.  Da die Zellen jetzt gezackt sind, schneiden sich ihre Beschriftungen mit dem Netz.  Und in den Fugen der Felsvorspr√ºnge mit Klippen entstehen Risse.  Wir werden die Risse f√ºr sp√§ter verlassen, aber jetzt werden wir uns auf die Oberfl√§chen der Zellen konzentrieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/320/626/85f/32062685fe221819ba4d9375175f66ee.png"></div><br>  <i>Die Karte wurde weniger streng, aber es traten mehr Probleme auf.</i> <br><br>  Der einfachste Weg, das Schnittpunktproblem zu l√∂sen, besteht darin, die Zentren der Zellen flach zu machen.  Lassen Sie uns die Y-Koordinate in <code>HexMesh.Perturb</code> einfach nicht √§ndern. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += (sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; <span class="hljs-comment"><span class="hljs-comment">// position.y += (sample.y * 2f - 1f) * HexMetrics.cellPerturbStrength; position.z += (sample.z * 2f - 1f) * HexMetrics.cellPerturbStrength; return position; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfb/6f6/38e/bfb6f638e8cdb45d6178d1f18cdb723b.png"></div><br>  <i>Ausgerichtete Zellen.</i> <br><br>  Mit dieser √Ñnderung bleiben alle vertikalen Positionen unver√§ndert, sowohl in der Mitte der Zellen als auch an den Stufen der Leisten.  Es ist zu beachten, dass dies die maximale Verschiebung nur in der XZ-Ebene auf ‚àö50 ‚âà 7.07 reduziert. <br><br>  Dies ist eine gute √Ñnderung, da dadurch die Identifizierung einzelner Zellen vereinfacht wird und die Leisten nicht zu chaotisch werden.  Aber es w√§re trotzdem sch√∂n, eine kleine vertikale Bewegung hinzuzuf√ºgen. <br><br><h3>  Zellenh√∂he verschieben </h3><br>  Anstatt auf jeden Scheitelpunkt eine vertikale Bewegung anzuwenden, k√∂nnen wir sie auf eine Zelle anwenden.  In diesem Fall bleibt jede Zelle flach, aber die Variabilit√§t zwischen den Zellen bleibt bestehen.  Es w√§re auch logisch, eine andere Skala zu verwenden, um die H√∂he zu <code>HexMetrics</code> . <code>HexMetrics</code> Sie sie daher zu <code>HexMetrics</code> .  Eine Kraft von 1,5 Einheiten erzeugt eine geringf√ºgige Abweichung, die ungef√§hr der H√∂he einer Stufe der Kante entspricht. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> elevationPerturbStrength = <span class="hljs-number"><span class="hljs-number">1.5f</span></span>;</code> </pre> <br>  √Ñndern Sie die <code>HexCell.Elevation</code> Eigenschaft so, dass diese Verschiebung auf die vertikale Position der Zelle <code>HexCell.Elevation</code> wird. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Vector3 position = transform.localPosition; position.y = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * HexMetrics.elevationStep; position.y += (HexMetrics.SampleNoise(position).y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.elevationPerturbStrength; transform.localPosition = position; Vector3 uiPosition = uiRect.localPosition; uiPosition.z = -position.y; uiRect.localPosition = uiPosition; } }</code> </pre> <br>  Damit die Verschiebung sofort angewendet werden kann, m√ºssen Sie die H√∂he jeder Zelle in <code>HexGrid.CreateCell</code> explizit <code>HexGrid.CreateCell</code> .  Andernfalls ist das Raster zun√§chst flach.  Lassen Sie es uns am Ende tun, nachdem Sie die Benutzeroberfl√§che erstellt haben. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cell.Elevation = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4f/dd7/15c/d4fdd715c130c8cd8b2519ff37c837de.png"></div><br>  <i>Verschobene H√∂hen mit Rissen.</i> <br><br><h3>  Mit den gleichen H√∂hen </h3><br>  Im Netz sind viele Risse aufgetreten, da wir beim Triangulieren des Netzes nicht die gleichen Zellenh√∂hen verwenden.  <code>HexCell</code> wir <code>HexCell</code> eine Eigenschaft <code>HexCell</code> , um ihre Position zu ermitteln, sodass Sie sie √ºberall verwenden k√∂nnen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> transform.localPosition; } }</code> </pre> <br>  Jetzt k√∂nnen wir diese Eigenschaft in <code>HexMesh.Triangulate</code> , um die Mitte der Zelle zu bestimmen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; ‚Ä¶ }</code> </pre> <br>  Und wir k√∂nnen es in <code>TriangulateConnection</code> wenn wir die vertikalen Positionen benachbarter Zellen definieren. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; v3.y = v4.y = neighbor.Position.y; ‚Ä¶ HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 v5 = v2 + HexMetrics.GetBridge(direction.Next()); v5.y = nextNeighbor.Position.y; ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69b/9a2/d90/69b9a2d90b7f29ef57f658f8206f6dda.png"></div><br>  <i>Konsequente Verwendung der Zellenh√∂he.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Zellenkanteneinheit </h2><br>  Obwohl die Zellen eine sch√∂ne Variation haben, sehen sie immer noch wie offensichtliche Sechsecke aus.  Dies ist an sich kein Problem, aber wir k√∂nnen ihr Aussehen verbessern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d5/895/e86/6d5895e8650286653b532d9c6fa1c10d.png"></div><br>  <i>Deutlich sichtbare hexagonale Zellen.</i> <br><br>  Wenn wir mehr Eckpunkte h√§tten, g√§be es eine gr√∂√üere lokale Variabilit√§t.  Teilen wir also jede Kante der Zelle in zwei Teile, indem wir die Oberseite der Kante in der Mitte zwischen jedem Eckenpaar hinzuf√ºgen.  Dies bedeutet, dass <code>HexMesh.Triangulate</code> nicht ein, sondern zwei Dreiecke hinzuf√ºgen sollte. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; Vector3 v1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 v2 = center + HexMetrics.GetSecondSolidCorner(direction); Vector3 e1 = Vector3.Lerp(v1, v2, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); AddTriangle(center, v1, e1); AddTriangleColor(cell.color); AddTriangle(center, e1, v2); AddTriangleColor(cell.color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, v1, v2); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b09/03c/d20/b0903cd20983599abdc064f04c95aa4f.png"></div><br>  <i>Zw√∂lf statt sechs Seiten.</i> <br><br>  Durch das Verdoppeln von Scheitelpunkten und Dreiecken werden die Kanten der Zelle variabler.  Machen wir sie noch ungleichm√§√üiger, indem wir die Anzahl der Eckpunkte verdreifachen. <br><br><pre> <code class="cs hljs"> Vector3 e1 = Vector3.Lerp(v1, v2, <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); Vector3 e2 = Vector3.Lerp(v1, v2, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); AddTriangle(center, v1, e1); AddTriangleColor(cell.color); AddTriangle(center, e1, e2); AddTriangleColor(cell.color); AddTriangle(center, e2, v2); AddTriangleColor(cell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/852/e6c/ad2852e6ccbf3db0adca140818545bb3.png"></div><br>  <i>18 Seiten.</i> <br><br><h3>  Rib Joint Division </h3><br>  Nat√ºrlich m√ºssen wir auch die Kantenfugen unterteilen.  Daher werden wir die neuen Scheitelpunktkanten an <code>TriangulateConnection</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, v1, e1, e2, v2); }</code> </pre> <br>  F√ºgen Sie der <code>TriangulateConnection</code> die entsprechenden Parameter hinzu, damit sie mit zus√§tzlichen Scheitelpunkten arbeiten kann. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 e1, Vector3 e2, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br>  Wir m√ºssen auch die zus√§tzlichen Kanten der Kanten f√ºr benachbarte Zellen berechnen.  Wir k√∂nnen sie berechnen, nachdem wir die Br√ºcke mit der anderen Seite verbunden haben. <br><br><pre> <code class="cs hljs"> Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; v3.y = v4.y = neighbor.Position.y; Vector3 e3 = Vector3.Lerp(v3, v4, <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); Vector3 e4 = Vector3.Lerp(v3, v4, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>);</code> </pre> <br>  Als n√§chstes m√ºssen wir die Triangulation der Rippe √§ndern.  Bis wir die H√§nge mit den Leisten ignorieren, f√ºgen Sie einfach drei statt eines Quad hinzu. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddQuad(v1, e1, v3, e3); AddQuadColor(cell.color, neighbor.color); AddQuad(e1, e2, e3, e4); AddQuadColor(cell.color, neighbor.color); AddQuad(e2, v2, e4, v4); AddQuadColor(cell.color, neighbor.color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afa/9d6/708/afa9d67080045b6ea2951a715c569003.png"></div><br>  <i>Unterteilte Verbindungen.</i> <br><br><h3>  Die Vereinigung der Kanten der Kanten </h3><br>  Da wir zur Beschreibung der Kanten jetzt vier Eckpunkte ben√∂tigen, w√§re es logisch, sie zu einer Menge zu kombinieren.  Dies ist bequemer als das Arbeiten mit vier unabh√§ngigen Scheitelpunkten.  Erstellen Sie hierf√ºr eine einfache <code>EdgeVertices</code> Struktur.  Es sollte vier Eckpunkte enthalten, die im Uhrzeigersinn entlang der Zellenkante verlaufen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EdgeVertices { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 v1, v2, v3, v4; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Sollten sie nicht serialisierbar sein?</b> <div class="spoiler_text">  Wir werden diese Struktur nur zur Triangulation verwenden.  Zu diesem Zeitpunkt m√ºssen die Eckpunkte der Kanten nicht gespeichert werden, sodass sie nicht serialisierbar sein m√ºssen. </div></div><br>  F√ºgen Sie eine praktische Konstruktormethode hinzu, die sich mit der Berechnung der Zwischenpunkte der Kante befasst. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EdgeVertices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 corner1, Vector3 corner2</span></span></span><span class="hljs-function">)</span></span> { v1 = corner1; v2 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); v3 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); v4 = corner2; }</code> </pre> <br>  Jetzt k√∂nnen wir <code>HexMesh</code> eine separate Triangulationsmethode <code>HexMesh</code> , um einen F√§cher aus Dreiecken zwischen der Mitte der Zelle und einer ihrer Kanten zu erstellen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, Color color</span></span></span><span class="hljs-function">)</span></span> { AddTriangle(center, edge.v1, edge.v2); AddTriangleColor(color); AddTriangle(center, edge.v2, edge.v3); AddTriangleColor(color); AddTriangle(center, edge.v3, edge.v4); AddTriangleColor(color); }</code> </pre> <br>  Und ein Verfahren zum Triangulieren eines Viereckstreifens zwischen zwei Kanten. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2 </span></span></span><span class="hljs-function">)</span></span> { AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); AddQuadColor(c1, c2); AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); AddQuadColor(c1, c2); AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); AddQuadColor(c1, c2); }</code> </pre> <br>  Dadurch k√∂nnen wir die <code>Triangulate</code> vereinfachen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; EdgeVertices e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); TriangulateEdgeFan(center, e, cell.color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, e); } }</code> </pre> <br>  Fahren wir mit <code>TriangulateConnection</code> .  Jetzt k√∂nnen wir <code>TriangulateEdgeStrip</code> , aber es m√ºssen andere Ersetzungen vorgenommen werden.  Wo wir fr√ºher <code>v1</code> , m√ºssen wir <code>e1.v1</code> .  In √§hnlicher Weise wird <code>v2</code> zu <code>e1.v4</code> , <code>v3</code> zu <code>e2.v1</code> und <code>v4</code> zu <code>e2.v4</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 bridge = HexMetrics.GetBridge(direction); bridge.y = neighbor.Position.y - cell.Position.y; EdgeVertices e2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( e1.v1 + bridge, e1.v4 + bridge ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1.v1, e1.v4, cell, e2.v1, e2.v4, neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip(e1, cell.color, e2, neighbor.color); } HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 v5 = e1.v4 + HexMetrics.GetBridge(direction.Next()); v5.y = nextNeighbor.Position.y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= neighbor.Elevation) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner( e1.v4, cell, e2.v4, neighbor, v5, nextNeighbor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner( v5, nextNeighbor, e1.v4, cell, e2.v4, neighbor ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner( e2.v4, neighbor, v5, nextNeighbor, e1.v4, cell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner( v5, nextNeighbor, e1.v4, cell, e2.v4, neighbor ); } }</code> </pre> <br><h3>  Ledge Division </h3><br>  Wir m√ºssen die Leisten teilen.  Daher √ºbergeben wir die Kanten an <code>TriangulateEdgeTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor); }</code> </pre> <br>  Jetzt m√ºssen wir <code>TriangulateEdgeTerraces</code> so √§ndern, dass es zwischen Kanten und nicht zwischen Scheitelpunktpaaren interpoliert.  Nehmen wir an, dass <code>EdgeVertices</code> eine bequeme statische Methode daf√ºr hat.  Auf diese Weise k√∂nnen wir <code>TriangulateEdgeTerraces</code> vereinfachen, anstatt es zu komplizieren. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); TriangulateEdgeStrip(begin, beginCell.color, e2, c2); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, i); TriangulateEdgeStrip(e1, c1, e2, c2); } TriangulateEdgeStrip(e2, c2, end, endCell.color); }</code> </pre> <br>  Die <code>EdgeVertices.TerraceLerp</code> Methode interpoliert einfach die Leisten zwischen allen vier Scheitelpunktpaaren zweier Kanten. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EdgeVertices </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices a, EdgeVertices b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { EdgeVertices result; result.v1 = HexMetrics.TerraceLerp(a.v1, b.v1, step); result.v2 = HexMetrics.TerraceLerp(a.v2, b.v2, step); result.v3 = HexMetrics.TerraceLerp(a.v3, b.v3, step); result.v4 = HexMetrics.TerraceLerp(a.v4, b.v4, step); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7d/ead/906/a7dead9066cbd1f7ddd29ca751d81cb0.png"></div><br>  <i>Unterteilte Leisten.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Verbinden Sie Klippen und Felsvorspr√ºnge wieder </h2><br>  Bisher haben wir Risse in der Kreuzung von Klippen und Felsvorspr√ºngen ignoriert.  Es ist Zeit, dieses Problem zu l√∂sen.  Betrachten wir zun√§chst die F√§lle Cliff-Slope-Slope (OSS) und Slope-Cliff-Slope (SOS). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/402/951/0fa/4029510fa08226cc4e4aee18faf1959b.png"></div><br>  <i>Maschenl√∂cher.</i> <br><br>  Das Problem entsteht, weil sich die Grenzen verschoben haben.  Dies bedeutet, dass sie jetzt nicht genau auf der Seite der Klippe liegen, was zu einem Riss f√ºhrt.  Manchmal sind diese L√∂cher unsichtbar und manchmal auff√§llig. <br><br>  Die L√∂sung besteht darin, den oberen Rand nicht zu verschieben.  Dies bedeutet, dass wir steuern m√ºssen, ob der Punkt verschoben wird.  Am einfachsten w√§re es, eine <code>AddTriangle</code> Alternative zu erstellen, die Scheitelpunkte √ºberhaupt nicht verschiebt. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleUnperturbed</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(v1); vertices.Add(v2); vertices.Add(v3); triangles.Add(vertexIndex); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  √Ñndern Sie das <code>TriangulateBoundaryTriangle</code> so, dass es diese Methode verwendet.  Dies bedeutet, dass er alle Scheitelpunkte mit Ausnahme der Grenzscheitelpunkte explizit verschieben muss. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangleUnperturbed(Perturb(begin), Perturb(v2), boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.TerraceLerp(begin, left, i); c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); AddTriangleUnperturbed(Perturb(v1), Perturb(v2), boundary); AddTriangleColor(c1, c2, boundaryColor); } AddTriangleUnperturbed(Perturb(v2), Perturb(left), boundary); AddTriangleColor(c2, leftCell.color, boundaryColor); }</code> </pre> <br>  Folgendes ist zu beachten: Da wir <code>v2</code> nicht verwenden, um einen anderen Punkt zu erhalten, k√∂nnen wir ihn sofort verschieben.  Dies ist eine einfache Optimierung, die die Codemenge reduziert. Lassen Sie uns sie einf√ºhren. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangleUnperturbed(Perturb(begin), v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); AddTriangleUnperturbed(v1, v2, boundary); AddTriangleColor(c1, c2, boundaryColor); } AddTriangleUnperturbed(v2, Perturb(left), boundary); AddTriangleColor(c2, leftCell.color, boundaryColor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fd/221/0ed/3fd2210ed0a8148ba9d39ef1655848e8.png"></div><br>  <i>Unbewegte Grenzen.</i> <br><br>  Es sieht besser aus, aber wir sind noch nicht fertig.  Innerhalb der <code>TriangulateCornerTerracesCliff</code> Methode wird der Grenzpunkt zwischen dem linken und dem rechten Punkt interpoliert.  Diese Punkte wurden jedoch noch nicht verschoben.  Damit der Grenzpunkt der resultierenden Klippe entspricht, m√ºssen wir zwischen den bewegten Punkten interpolieren. <br><br><pre> <code class="cs hljs"> Vector3 boundary = Vector3.Lerp(Perturb(begin), Perturb(right), b);</code> </pre> <br>  Gleiches gilt f√ºr die <code>TriangulateCornerCliffTerraces</code> Methode. <br><br><pre> <code class="cs hljs"> Vector3 boundary = Vector3.Lerp(Perturb(begin), Perturb(left), b);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c18/917/670/c189176704e7ebcdfd92bc6a1cffaee3.png"></div><br>  <i>Die L√∂cher sind weg.</i> <br><br><h3>  Doppelklippen und Hang </h3><br>  In allen verbleibenden problematischen F√§llen sind zwei Klippen und ein Hang vorhanden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/408/f2f/4a6/408f2f4a6fca5fffd8659b4380f59e51.png"></div><br>  <i>Gro√ües Loch wegen eines einzelnen Dreiecks.</i> <br><br>  Dieses Problem wird behoben, indem ein einzelnes Dreieck im <code>else</code> Block am Ende von <code>TriangulateCornerTerracesCliff</code> manuell <code>TriangulateCornerTerracesCliff</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangleUnperturbed(Perturb(left), Perturb(right), boundary); AddTriangleColor(leftCell.color, rightCell.color, boundaryColor); }</code> </pre> <br>  Gleiches gilt f√ºr <code>TriangulateCornerCliffTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangleUnperturbed(Perturb(left), Perturb(right), boundary); AddTriangleColor(leftCell.color, rightCell.color, boundaryColor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/b34/64a/9ffb3464a6de3dc443cede9d42797022.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Befreien Sie sich von den neuesten Rissen. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fertigstellung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir ein v√∂llig korrektes verzerrtes Netz. </font><font style="vertical-align: inherit;">Sein Aussehen h√§ngt vom spezifischen Ger√§usch, seiner Gr√∂√üe und den Verzerrungskr√§ften ab. </font><font style="vertical-align: inherit;">In unserem Fall scheint die Verzerrung zu stark zu sein. </font><font style="vertical-align: inherit;">Obwohl diese Ungleichm√§√üigkeit sch√∂n aussieht, m√∂chten wir nicht, dass die Zellen zu stark vom geraden Gitter abweichen. </font><font style="vertical-align: inherit;">Am Ende verwenden wir es immer noch, um die Zelle zu definieren, deren Gr√∂√üe ge√§ndert werden soll. </font><font style="vertical-align: inherit;">Und wenn die Gr√∂√üe der Zellen zu stark variiert, wird es f√ºr uns schwieriger sein, den Inhalt darin zu platzieren.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35f/32e/d06/35f32ed066f03b1079ed0bec70ba83ca.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eac/3f5/d6c/eac3f5d6cd6a1e65185d1aec48e8abb0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unverzerrte und verzerrte Netze. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es scheint, dass die Kraft 5 zum Verzerren der Zellen zu gro√ü ist.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verzerrung der Zellen liegt zwischen 0 und 5.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reduzieren wir sie auf 4, um den Komfort des Rasters zu erh√∂hen, ohne es zu korrekt zu machen. </font><font style="vertical-align: inherit;">Dies stellt sicher, dass der maximale XZ-Versatz ‚àö32 ‚âà 5,66 Einheiten betr√§gt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/803/2f6/b8d/8032f6b8d0cf048f5d55c30e2d0e465d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zellverzerrungsst√§rke 4.</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein weiterer Wert, der ge√§ndert werden kann, ist der Integrit√§tskoeffizient. </font><font style="vertical-align: inherit;">Wenn wir es erh√∂hen, werden die flachen Zentren der Zellen gr√∂√üer, dh es wird mehr Platz f√ºr zuk√ºnftige Inhalte geben. </font><font style="vertical-align: inherit;">Dabei werden sie nat√ºrlich sechseckiger.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Integrit√§tskoeffizient von 0,75 bis 0,95. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine leichte Erh√∂hung des Integrit√§tskoeffizienten auf 0,8 wird unser zuk√ºnftiges Leben leicht vereinfachen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> solidFactor = <span class="hljs-number"><span class="hljs-number">0.8f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/9a2/036/a9a9a2036fbcd0e4e5f11e56078911c1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Integrit√§tskoeffizient 0.8. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich stellen Sie m√∂glicherweise fest, dass die Unterschiede zwischen den H√∂henstufen zu stark sind. </font><font style="vertical-align: inherit;">Dies ist praktisch, wenn Sie sicherstellen m√ºssen, dass das Netz korrekt generiert wird. Damit sind wir jedoch bereits fertig. </font><font style="vertical-align: inherit;">Reduzieren wir es auf 1 Einheit pro Schritt, dh auf 3.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> elevationStep = <span class="hljs-number"><span class="hljs-number">3f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5cc/4b0/028/5cc4b002843f822556c7ced67b9f54db.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Tonh√∂he wird auf 3 reduziert.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir k√∂nnen auch die St√§rke der Tonh√∂henverzerrung √§ndern. </font><font style="vertical-align: inherit;">Aber jetzt hat es einen Wert von 1,5, was einem halben H√∂henschritt entspricht, was zu uns passt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kleine H√∂henstufen erm√∂glichen eine logischere Verwendung aller sieben H√∂henstufen. </font><font style="vertical-align: inherit;">Dies erh√∂ht die Variabilit√§t der Karte.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f63/9b3/aac/f639b3aac128c4c72c28fa85d68cc0e4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden sieben H√∂henstufen. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 5: gr√∂√üere Karten </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir teilen das Gitter in Fragmente. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir steuern die Kamera. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√§rben Sie die Farben und H√∂hen separat aus. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden Sie den vergr√∂√üerten Pinsel der Zellen. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher haben wir mit einer sehr kleinen Karte gearbeitet. </font><font style="vertical-align: inherit;">Es ist Zeit, es zu erh√∂hen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c8/11c/4b4/0c811c4b480c13b584a2b824fdae1cee.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist Zeit zu zoomen.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Netzfragmente </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen das Gitter nicht zu gro√ü machen, weil wir an die Grenzen dessen sto√üen, was in ein Netz passen kann. </font><font style="vertical-align: inherit;">Wie kann man dieses Problem l√∂sen? </font><font style="vertical-align: inherit;">Verwenden Sie mehrere Netze. </font><font style="vertical-align: inherit;">Dazu m√ºssen wir unser Gitter in mehrere Fragmente aufteilen. </font><font style="vertical-align: inherit;">Wir verwenden rechteckige Fragmente konstanter Gr√∂√üe.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/423/453/db2/423453db217ed74da2457198c576ef63.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teilen Sie das Gitter in 3 mal 3 Segmente.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden Sie 5 mal 5 Bl√∂cke, dh 25 Zellen pro Fragment. </font><font style="vertical-align: inherit;">Definieren Sie sie in </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSizeX = <span class="hljs-number"><span class="hljs-number">5</span></span>, chunkSizeZ = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welche Fragmentgr√∂√üe kann als geeignet angesehen werden?</font></font></b> <div class="spoiler_text">  .       ,     .      .      ,       (frustum culling),       .            . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir keine Gr√∂√üe f√ºr das Netz verwenden, es muss ein Vielfaches der Fragmentgr√∂√üe sein. </font><font style="vertical-align: inherit;">√Ñndern wir es </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">daher so, dass es seine Gr√∂√üe nicht in separaten Zellen, sondern in Fragmenten festlegt. </font><font style="vertical-align: inherit;">Stellen Sie die Standardgr√∂√üe auf 4 x 3 Fragmente ein, dh nur 12 Fragmente oder 300 Zellen. </font><font style="vertical-align: inherit;">So bekommen wir eine bequeme Testkarte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkCountX = <span class="hljs-number"><span class="hljs-number">4</span></span>, chunkCountZ = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir benutzen immer noch </font></font><code>width</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>height</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber jetzt sollten sie privat werden. </font><font style="vertical-align: inherit;">Und benenne sie in </font></font><code>cellCountX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und um </font></font><code>cellCountZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Verwenden Sie den Editor, um alle Vorkommen dieser Variablen gleichzeitig umzubenennen. </font><font style="vertical-align: inherit;">Jetzt wird klar, wann es sich um die Anzahl der Fragmente oder Zellen handelt.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public int width = 6; // public int height = 6; int cellCountX, cellCountZ;</span></span></code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/227/ff4/160/227ff41602f115787a8a0e5d98ca89c9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geben Sie die Gr√∂√üe in Fragmenten an. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie dies </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass bei Bedarf die Anzahl der Zellen aus der Anzahl der Fragmente berechnet wird. </font><font style="vertical-align: inherit;">Wir heben die Erstellung von Zellen in einer separaten Methode hervor, um nicht zu verstopfen </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cellCountX = chunkCountX * HexMetrics.chunkSizeX; cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; CreateCells(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[cellCountZ * cellCountX]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; cellCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; cellCountX; x++) { CreateCell(x, z, i++); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fragment Fertighaus </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um die Netzfragmente zu beschreiben, ben√∂tigen wir einen neuen Komponententyp. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGridChunk</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als n√§chstes erstellen wir ein vorgefertigtes Fragment. </font><font style="vertical-align: inherit;">Dazu duplizieren wir das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekt </font><font style="vertical-align: inherit;">und benennen es in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid Chunk um</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Entfernen Sie die Komponente </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und f√ºgen Sie stattdessen eine Komponente hinzu </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Verwandeln Sie es dann in ein Fertighaus und entfernen Sie das Objekt aus der Szene.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/106/a02/bea/106a02bead67c37151be26d5f6a4bea9.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cb/586/7a3/1cb5867a3851159ce2bf1747a4e213bc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Fragment vorgefertigt mit eigener Leinwand und Netz. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da er Instanzen dieser Fragmente erstellen </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird, geben wir ihm einen Link zum Fertighaus des Fragments.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGridChunk chunkPrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a9/6b8/882/2a96b8882c5d6cc5bdb6345d5217ae83.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt mit Fragmenten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Erstellen von Instanzen von Fragmenten √§hnelt dem Erstellen von Instanzen von Zellen. </font><font style="vertical-align: inherit;">Wir werden sie mit Hilfe eines Arrays verfolgen und mit einer Doppelschleife f√ºllen.</font></font><br><br><pre> <code class="cs hljs"> HexGridChunk[] chunks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ CreateChunks(); CreateCells(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexGridChunk[chunkCountX * chunkCountZ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; chunkCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { HexGridChunk chunk = chunks[i++] = Instantiate(chunkPrefab); chunk.transform.SetParent(transform); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Initialisieren eines Fragments √§hnelt dem Initialisieren eines Sechseckgitters. </font><font style="vertical-align: inherit;">Sie setzt alles ein </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und f√ºhrt eine Triangulation durch </font></font><code>Start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es erfordert einen Verweis auf die Zeichenfl√§che und das Netz sowie ein Array f√ºr die Zellen. </font><font style="vertical-align: inherit;">Das Fragment erstellt diese Zellen jedoch nicht. </font><font style="vertical-align: inherit;">Das Raster wird dies weiterhin tun.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGridChunk</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { HexCell[] cells; HexMesh hexMesh; Canvas gridCanvas; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Triangulate(cells); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zuweisen von Zellen zu Fragmenten </font></font></h3><br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erstellt immer noch alle Zellen. </font><font style="vertical-align: inherit;">Dies ist normal, aber jetzt m√ºssen wir jede Zelle einem geeigneten Fragment hinzuf√ºgen und d√ºrfen sie nicht mit unserem eigenen Netz und unserer eigenen Leinwand festlegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); <span class="hljs-comment"><span class="hljs-comment">// cell.transform.SetParent(transform, false); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.color = defaultColor; ‚Ä¶ Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); // label.rectTransform.SetParent(gridCanvas.transform, false); label.rectTransform.anchoredPosition = new Vector2(position.x, position.z); label.text = cell.coordinates.ToStringOnSeparateLines(); cell.uiRect = label.rectTransform; cell.Elevation = 0; AddCellToChunk(x, z, cell); } void AddCellToChunk (int x, int z, HexCell cell) { }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen das richtige Fragment mithilfe der Ganzzahldivision </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Fragmentgr√∂√üe finden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCellToChunk</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkX = x / HexMetrics.chunkSizeX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkZ = z / HexMetrics.chunkSizeZ; HexGridChunk chunk = chunks[chunkX + chunkZ * chunkCountX]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mithilfe von Zwischenergebnissen k√∂nnen wir auch den lokalen Index der Zelle in diesem Fragment bestimmen. </font><font style="vertical-align: inherit;">Danach k√∂nnen Sie dem Fragment eine Zelle hinzuf√ºgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCellToChunk</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkX = x / HexMetrics.chunkSizeX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkZ = z / HexMetrics.chunkSizeZ; HexGridChunk chunk = chunks[chunkX + chunkZ * chunkCountX]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> localX = x - chunkX * HexMetrics.chunkSizeX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> localZ = z - chunkZ * HexMetrics.chunkSizeZ; chunk.AddCell(localX + localZ * HexMetrics.chunkSizeX, cell); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anschlie√üend wird </font></font><code>HexGridChunk.AddCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Zelle in einem eigenen Array platziert und die √ºbergeordneten Elemente f√ºr die Zelle und ihre Benutzeroberfl√§che festgelegt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cells[index] = cell; cell.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); cell.uiRect.SetParent(gridCanvas.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fegen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt kann er </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Leinwand und das Sechsecknetz seiner Kinder sowie den Code entfernen.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Canvas gridCanvas; // HexMesh hexMesh; void Awake () { HexMetrics.noiseSource = noiseSource; // gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); // hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); ‚Ä¶ } // void Start () { // hexMesh.Triangulate(cells); // } // public void Refresh () { // hexMesh.Triangulate(cells); // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir es losgeworden sind </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sollten wir es </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht mehr benutzen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cell.color = activeColor; cell.Elevation = activeElevation; <span class="hljs-comment"><span class="hljs-comment">// hexGrid.Refresh(); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a0/f4b/c99/5a0f4bc99bce766e53ff1a0192abd16e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das gereinigte Sechseckgitter. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Starten des Wiedergabemodus sieht die Karte immer noch gleich aus. </font><font style="vertical-align: inherit;">Die Hierarchie der Objekte wird jedoch unterschiedlich sein. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erstellt jetzt untergeordnete Fragmentobjekte, die Zellen sowie deren Netz und Zeichenfl√§che enthalten.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7f/bc4/f8e/a7fbc4f8e4898504bc34a4a918ebb567.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untergeordnete Fragmente im Wiedergabemodus. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielleicht haben wir einige Probleme mit Zelletiketten. </font><font style="vertical-align: inherit;">Zun√§chst haben wir die Beschriftungsbreite auf 5 gesetzt. Dies war ausreichend, um die beiden Zeichen, die f√ºr uns ausreichten, auf einer kleinen Karte anzuzeigen. </font><font style="vertical-align: inherit;">Aber jetzt k√∂nnen wir Koordinaten wie ‚àí10 haben, in denen es drei Zeichen gibt. </font><font style="vertical-align: inherit;">Sie passen nicht und werden zugeschnitten. </font><font style="vertical-align: inherit;">Um dies zu beheben, erh√∂hen Sie die Breite der Zellenbezeichnung auf 10 oder noch mehr.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e7/fd3/4a5/2e7fd34a5b649256e326b73a3aa9227a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7c/926/fae/f7c926fae8356aa8d2402a21359fea8f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweiterte Zellbezeichnungen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir viel gr√∂√üere Karten erstellen! </font><font style="vertical-align: inherit;">Da wir beim Start das gesamte Raster generieren, kann es lange dauern, gro√üe Karten zu erstellen. </font><font style="vertical-align: inherit;">Aber nach der Fertigstellung werden wir einen riesigen Raum zum Experimentieren haben.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Korrektur der Zellbearbeitung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bearbeitung scheint derzeit nicht zu funktionieren, da das Raster nicht mehr aktualisiert wird. </font><font style="vertical-align: inherit;">Wir Fragmente f√ºgen Sie </font><font style="vertical-align: inherit;">so ein Verfahren aktualisiert werden m√ºssen , </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Triangulate(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wann sollten wir diese Methode aufrufen? </font><font style="vertical-align: inherit;">Wir haben das gesamte Raster jedes Mal aktualisiert, da wir nur ein Netz hatten. </font><font style="vertical-align: inherit;">Aber jetzt haben wir viele Fragmente. </font><font style="vertical-align: inherit;">Anstatt sie alle jedes Mal zu aktualisieren, ist es viel effizienter, die ge√§nderten Fragmente zu aktualisieren. </font><font style="vertical-align: inherit;">Andernfalls wird das Wechseln gro√üer Karten zu einem sehr langsamen Vorgang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber woher wissen wir, welches Fragment aktualisiert werden soll? </font><font style="vertical-align: inherit;">Am einfachsten ist es, jeder Zelle mitzuteilen, zu welchem ‚Äã‚ÄãFragment sie geh√∂rt. </font><font style="vertical-align: inherit;">Dann kann die Zelle ihr Fragment aktualisieren, wenn diese Zelle ge√§ndert wird. </font><font style="vertical-align: inherit;">Geben wir also einen </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zu seinem Fragment.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGridChunk chunk;</code> </pre> <br> <code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann sich beim Hinzuf√ºgen selbst zur Zelle hinzuf√ºgen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cells[index] = cell; cell.chunk = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; cell.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); cell.uiRect.SetParent(gridCanvas.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indem wir sie verbinden, erg√§nzen wir die </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jedes Mal, wenn eine Zelle aktualisiert wird, wird einfach ihr Fragment aktualisiert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunk.Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen es nicht </font></font><code>HexCell.Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemein machen, da die Zelle selbst besser wei√ü, wann sie ge√§ndert wurde. </font><font style="vertical-align: inherit;">Zum Beispiel, nachdem seine H√∂he ge√§ndert wurde.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { ‚Ä¶ Refresh(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tats√§chlich m√ºssen wir es nur aktualisieren, wenn sich seine H√∂he auf einen anderen Wert ge√§ndert hat. </font><font style="vertical-align: inherit;">Sie muss nicht einmal etwas neu berechnen, wenn wir ihr dieselbe Gr√∂√üe wie zuvor zuweisen. </font><font style="vertical-align: inherit;">Daher k√∂nnen wir den Anfang des Setters verlassen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden jedoch auch Berechnungen zum ersten Mal √ºberspringen, wenn die H√∂he auf 0 gesetzt ist, da dies der Standardwert f√ºr die Maschenh√∂he ist. </font><font style="vertical-align: inherit;">Um dies zu vermeiden, werden wir den Anfangswert so festlegen, wie wir ihn niemals verwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevation = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MinValue;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist int.MinValue?</font></font></b> <div class="spoiler_text">   ,    integer.    C# integer ‚Äî <br>  32- ,   2 <sup>32</sup>  integer,    ,    .       . <br><br>  ‚Äî  ‚àí2 <sup>31</sup> = ‚àí2 147 483 648.        ! <br><br>   2 <sup>31</sup> ‚àí 1 = 2 147 483 647.     2 <sup>31</sup> - . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Farb√§nderung der Zelle zu erkennen, m√ºssen wir sie auch in eine Eigenschaft umwandeln. </font><font style="vertical-align: inherit;">Benennen Sie es in </font></font><code>Color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gro√übuchstaben um und verwandeln Sie es dann in eine Eigenschaft mit einer privaten Variablen </font></font><code>color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der Standardfarbwert ist transparentes Schwarz, was zu uns passt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color Color { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (color == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } color = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } Color color;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir jetzt den Wiedergabemodus starten, erhalten wir Nullreferenzausnahmen. </font><font style="vertical-align: inherit;">Dies geschieht, weil wir die Farbe und H√∂he auf ihre Standardwerte setzen, bevor wir eine Zelle ihrem Fragment zuweisen. </font><font style="vertical-align: inherit;">Es ist normal, dass wir die Fragmente zu diesem Zeitpunkt nicht aktualisieren, da wir sie triangulieren, nachdem die Initialisierung abgeschlossen ist. </font><font style="vertical-align: inherit;">Mit anderen Worten, wir aktualisieren ein Fragment nur, wenn es zugewiesen ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunk) { chunk.Refresh(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen endlich wieder die Zellen wechseln! </font><font style="vertical-align: inherit;">Es tritt jedoch ein Problem auf. </font><font style="vertical-align: inherit;">Beim Zeichnen entlang der R√§nder von Fragmenten erscheinen N√§hte.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41a/94f/50c/41a94f50c430ce8f13fb1a3be274b520.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehler an den Grenzen von Fragmenten.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist logisch, denn wenn sich eine einzelne Zelle √§ndert, √§ndern sich auch alle Verbindungen zu ihren Nachbarn. Und diese Nachbarn k√∂nnen in anderen Fragmenten sein. Die einfachste L√∂sung besteht darin, alle benachbarten Zellen zu aktualisieren, wenn sie unterschiedlich sind.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunk) { chunk.Refresh(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; neighbors.Length; i++) { HexCell neighbor = neighbors[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; neighbor.chunk != chunk) { neighbor.chunk.Refresh(); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl dies funktioniert, kann es sich herausstellen, dass wir ein Fragment mehrmals aktualisieren. Und wenn wir anfangen, mehrere Zellen gleichzeitig zu f√§rben, wird alles schlimmer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen jedoch nicht sofort nach der Aktualisierung des Fragments triangulieren. Stattdessen schreiben wir einfach, dass ein Update erforderlich ist, und triangulieren, nachdem die √Ñnderung abgeschlossen ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da es </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nichts anderes tut, k√∂nnen wir seinen aktivierten Status verwenden, um die Notwendigkeit von Updates zu signalisieren. Bei der Aktualisierung wird die Komponente ber√ºcksichtigt. Durch mehrmaliges Einschalten √§ndert sich nichts. Die Komponente wird sp√§ter aktualisiert. Wir werden an dieser Stelle triangulieren und die Komponente wieder deaktivieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden </font></font><code>LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stattdessen</font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um sicherzustellen, dass die Triangulation erfolgt, nachdem die √Ñnderung f√ºr den aktuellen Frame abgeschlossen ist. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// hexMesh.Triangulate(cells); enabled = true; } void LateUpdate () { hexMesh.Triangulate(cells); enabled = false; }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist der Unterschied zwischen Update und LateUpdate?</font></font></b> <div class="spoiler_text">     <code>Update</code>    -     .          <code>LateUpdate</code> .      ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da unsere Komponente standardm√§√üig aktiviert ist, m√ºssen wir nicht mehr explizit triangulieren </font></font><code>Start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Daher kann diese Methode entfernt werden.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// void Start () { // hexMesh.Triangulate(cells); // }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6f/104/7c3/a6f1047c34bb9cf9b69360343ab53aac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmente von 20 mal 20 mit 10.000 Zellen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verallgemeinerte Listen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir die Art und Weise, wie das Gitter trianguliert wird, erheblich ge√§ndert haben, </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bleibt es gleich. </font><font style="vertical-align: inherit;">Alles, was er zum Arbeiten braucht, ist eine Reihe von Zellen. </font><font style="vertical-align: inherit;">Es ist ihm egal, ob es ein oder mehrere Sechsecke gibt. </font><font style="vertical-align: inherit;">Wir haben jedoch noch nicht in Betracht gezogen, mehrere Netze zu verwenden. </font><font style="vertical-align: inherit;">Vielleicht kann hier etwas verbessert werden? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die verwendeten </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listen sind im Wesentlichen tempor√§re Puffer. </font><font style="vertical-align: inherit;">Sie werden nur zur Triangulation verwendet. </font><font style="vertical-align: inherit;">Und die Fragmente werden einzeln trianguliert. </font><font style="vertical-align: inherit;">Daher ben√∂tigen wir in der Tat nur einen Satz von Listen und nicht einen Satz f√ºr jedes Sechsecknetzobjekt. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem die Listen statisch gemacht werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;Vector3&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector3&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;Color&gt; colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Color&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); meshCollider = gameObject.AddComponent&lt;MeshCollider&gt;(); hexMesh.name = <span class="hljs-string"><span class="hljs-string">"Hex Mesh"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// vertices = new List&lt;Vector3&gt;(); // colors = new List&lt;Color&gt;(); // triangles = new List&lt;int&gt;(); }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sind statische Listen wirklich so wichtig?</font></font></b> <div class="spoiler_text">           .    ,   ,       . <br><br>     ,           .    20  20     100. </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kamerasteuerung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die gro√üe Kamera ist wunderbar, aber sie ist nutzlos, wenn wir sie nicht sehen k√∂nnen. Um die gesamte Karte zu inspizieren, m√ºssen wir die Kamera bewegen. Zoomen ist ebenfalls n√ºtzlich. Erstellen wir daher eine Kamera, um diese Aktionen auszuf√ºhren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie ein Dummy-Objekt und nennen Sie es </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Map Camera</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Legen Sie die Transformationskomponente so ab, dass sie sich zum Ursprung bewegt, ohne ihre Drehung und Skalierung zu √§ndern. In dem es ein Kind - </font><font style="vertical-align: inherit;">Objekt namens </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schwenker</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und er wird ein Child - </font><font style="vertical-align: inherit;">Objekt hinzuf√ºgen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stock</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Machen Sie die Hauptkamera zu einem Kind des Sticks und setzen Sie die Transformationskomponente zur√ºck.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a8/33f/3d9/0a833f3d9eea9b9fef1682ef63a7f372.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Hierarchie der Kamera. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ziel des Kamerascharniers (Swivel) besteht darin, den Winkel zu steuern, in dem die Kamera auf die Karte schaut. </font><font style="vertical-align: inherit;">Lassen Sie es uns drehen (45, 0, 0). </font><font style="vertical-align: inherit;">Der Griff (Stick) steuert die Entfernung, in der sich die Kameras befinden. </font><font style="vertical-align: inherit;">Setzen wir ihr eine Position (0, 0, -45). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt brauchen wir eine Komponente, um dieses System zu steuern. </font><font style="vertical-align: inherit;">Weisen Sie diese Komponente dem Stamm der Kamerahierarchie zu. </font><font style="vertical-align: inherit;">Geben Sie ihm eine Verbindung zum Scharnier und Griff, um sie hineinzuholen </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapCamera</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Transform swivel, stick; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { swivel = transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); stick = swivel.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb6/2e5/44b/eb62e544b9e00bc558dfbc504802cfba.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hexagon Kartenkamera.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zoom </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste Funktion, die wir erstellen, ist das Zoomen (Zoomen). </font><font style="vertical-align: inherit;">Wir k√∂nnen die aktuelle Zoomstufe mit der Float-Variablen steuern. </font><font style="vertical-align: inherit;">Ein Wert von 0 bedeutet, dass wir vollst√§ndig entfernt sind, und ein Wert von 1 bedeutet, dass wir vollst√§ndig entfernt sind. </font><font style="vertical-align: inherit;">Beginnen wir mit dem maximalen Zoom.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoom = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Zoomen erfolgt normalerweise mit dem Mausrad oder der analogen Steuerung. </font><font style="vertical-align: inherit;">Wir k√∂nnen es mit der </font><font style="vertical-align: inherit;">Standard- </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maus-ScrollWheel-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eingabeachse implementieren </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">F√ºgen Sie eine Methode hinzu </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die das Vorhandensein eines Eingabedeltas √ºberpr√ºft. Wenn eines vorhanden ist, wird die Zoom√§nderungsmethode aufgerufen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoomDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Mouse ScrollWheel"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zoomDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustZoom(zoomDelta); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um die Zoomstufe zu √§ndern, f√ºgen wir einfach ein Delta hinzu und begrenzen dann den Wert (Klemme), um im Bereich von 0 bis 1 zu bleiben. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { zoom = Mathf.Clamp01(zoom + delta); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Vergr√∂√üern und Verkleinern sollte sich der Abstand zur Kamera entsprechend √§ndern. </font><font style="vertical-align: inherit;">Dies kann durch √Ñndern der Position des Griffs in Z erfolgen. F√ºgen Sie zwei allgemeine Float-Variablen hinzu, um die Position des Griffs bei minimalem und maximalem Zoom anzupassen. </font><font style="vertical-align: inherit;">Da wir eine relativ kleine Karte entwickeln, setzen Sie die Werte auf -250 und -45.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> stickMinZoom, stickMaxZoom;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem √Ñndern des Zooms f√ºhren wir eine lineare Interpolation zwischen diesen beiden Werten basierend auf dem neuen Zoomwert durch. </font><font style="vertical-align: inherit;">Aktualisieren Sie dann die Position des Griffs.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { zoom = Mathf.Clamp01(zoom + delta); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = Mathf.Lerp(stickMinZoom, stickMaxZoom, zoom); stick.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, distance); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cec/f4c/f07/cecf4cf07d627d6eaab94ecdc2953d30.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimale und maximale Stick-Werte. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt funktioniert der Zoom, ist aber bisher nicht sehr n√ºtzlich. </font><font style="vertical-align: inherit;">Wenn der Zoom weiter entfernt ist, zeigt die Kamera normalerweise eine Draufsicht. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies durch Drehen des Scharniers realisieren. </font><font style="vertical-align: inherit;">Daher addieren wir die Variablen min und max f√ºr das Scharnier. </font><font style="vertical-align: inherit;">Stellen wir ihnen die Werte 90 und 45 ein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> swivelMinZoom, swivelMaxZoom;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bei der Griffposition interpolieren wir, um einen geeigneten Zoomwinkel zu finden. </font><font style="vertical-align: inherit;">Dann stellen wir die Drehung des Scharniers ein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { zoom = Mathf.Clamp01(zoom + delta); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = Mathf.Lerp(stickMinZoom, stickMaxZoom, zoom); stick.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, distance); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Mathf.Lerp(swivelMinZoom, swivelMaxZoom, zoom); swivel.localRotation = Quaternion.Euler(angle, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/766/0c3/fcd/7660c3fcd621567398ea7c013fae549c.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der minimale und maximale Wert von Swivel. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die √Ñnderungsrate des Zooms kann durch √Ñndern der Empfindlichkeit der Eingabeparameter des Mausrads angepasst werden. </font><font style="vertical-align: inherit;">Sie finden sie unter </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bearbeiten / Projekteinstellungen / Eingabe</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn Sie sie beispielsweise von 0,1 auf 0,025 √§ndern, wird der Zoom langsamer und gleichm√§√üiger ge√§ndert.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d43/f86/ef3/d43f86ef3587be1bfd15ca208eec418f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mausrad-Eingabem√∂glichkeiten.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Umzug </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fahren wir nun mit dem Bewegen der Kamera fort. </font><font style="vertical-align: inherit;">Die Bewegung in Richtung X und Z m√ºssen wir </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie beim Zoom </font><font style="vertical-align: inherit;">implementieren </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hierf√ºr k√∂nnen wir </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horizontale</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vertikale</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eingabeachsen verwenden </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dadurch k√∂nnen wir die Kamera mit den Pfeilen und den WASD-Tasten bewegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoomDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Mouse ScrollWheel"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zoomDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustZoom(zoomDelta); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Horizontal"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span> || zDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustPosition(xDelta, zDelta); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der einfachste Ansatz besteht darin, die aktuelle Position des Kamerasystems zu ermitteln, die Deltas X und Z hinzuzuf√ºgen und das Ergebnis der Position des Systems zuzuweisen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { Vector3 position = transform.localPosition; position += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta); transform.localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus diesem Grund bewegt sich die Kamera, w√§hrend Sie die Pfeile oder WASD gedr√ºckt halten, jedoch nicht mit konstanter Geschwindigkeit. </font><font style="vertical-align: inherit;">Dies h√§ngt von der Bildrate ab. </font><font style="vertical-align: inherit;">Um die Entfernung zu bestimmen, die Sie zur√ºcklegen m√ºssen, verwenden wir das Zeitdelta sowie die erforderliche Geschwindigkeit. </font><font style="vertical-align: inherit;">Daher f√ºgen wir eine gemeinsame Variable hinzu, </font></font><code>moveSpeed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setzen sie auf 100 und multiplizieren sie dann mit dem Zeitdelta, um das Positionsdelta zu erhalten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moveSpeed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = moveSpeed * Time.deltaTime; Vector3 position = transform.localPosition; position += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta) * distance; transform.localPosition = position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6da/1bc/307/6da1bc3074dc31868b934a35aaa31b10.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bewegungsgeschwindigkeit. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir uns mit konstanter Geschwindigkeit entlang der X- oder Z-Achse bewegen. Wenn wir uns jedoch gleichzeitig (diagonal) entlang beider Achsen bewegen, ist die Bewegung schneller. </font><font style="vertical-align: inherit;">Um dies zu beheben, m√ºssen wir den Delta-Vektor normalisieren. </font><font style="vertical-align: inherit;">Auf diese Weise k√∂nnen Sie es als Ziel verwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { Vector3 direction = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta).normalized; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = moveSpeed * Time.deltaTime; Vector3 position = transform.localPosition; position += direction * distance; transform.localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die diagonale Bewegung ist jetzt korrekt implementiert, aber pl√∂tzlich stellt sich heraus, dass sich die Kamera auch nach dem Loslassen aller Tasten noch ziemlich lange weiterbewegt. Dies liegt daran, dass die Eingangsachsen unmittelbar nach dem Dr√ºcken der Tasten nicht sofort zu den Grenzwerten springen. Sie brauchen etwas Zeit daf√ºr. Gleiches gilt f√ºr das Loslassen von Schl√ºsseln. Es braucht Zeit, um zu den Nullachsenwerten zur√ºckzukehren. Da wir jedoch die Eingabewerte normalisiert haben, wird die maximale Geschwindigkeit st√§ndig beibehalten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen die Eingabeparameter anpassen, um die Verz√∂gerungen zu beseitigen, aber sie vermitteln ein Gef√ºhl der Gl√§tte, das es wert ist, gespeichert zu werden. Wir k√∂nnen den extremsten Wert der Achsen als D√§mpfungsbewegungskoeffizienten anwenden.</font></font><br><br><pre> <code class="cs hljs"> Vector3 direction = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta).normalized; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> damping = Mathf.Max(Mathf.Abs(xDelta), Mathf.Abs(zDelta)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = moveSpeed * damping * Time.deltaTime;</code> </pre><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bewegung mit D√§mpfung. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt funktioniert die Bewegung gut, zumindest mit zunehmendem Zoom. </font><font style="vertical-align: inherit;">Aber in einiger Entfernung stellt sich heraus, dass es zu langsam ist. </font><font style="vertical-align: inherit;">Mit reduziertem Zoom m√ºssen wir beschleunigen. </font><font style="vertical-align: inherit;">Dies kann durch Ersetzen einer Variablen </font></font><code>moveSpeed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durch zwei f√ºr minimalen und maximalen Zoom und anschlie√üendes Interpolieren erfolgen. </font><font style="vertical-align: inherit;">Weisen Sie ihnen Werte von 400 und 100 zu.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public float moveSpeed; public float moveSpeedMinZoom, moveSpeedMaxZoom; void AdjustPosition (float xDelta, float zDelta) { Vector3 direction = new Vector3(xDelta, 0f, zDelta).normalized; float damping = Mathf.Max(Mathf.Abs(xDelta), Mathf.Abs(zDelta)); float distance = Mathf.Lerp(moveSpeedMinZoom, moveSpeedMaxZoom, zoom) * damping * Time.deltaTime; Vector3 position = transform.localPosition; position += direction * distance; transform.localPosition = position; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/cb8/65e/5a9cb865ee0a67d4b3ad056317faf479.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bewegungsgeschwindigkeit variiert mit der Zoomstufe. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir uns schnell auf der Karte bewegen! </font><font style="vertical-align: inherit;">Tats√§chlich k√∂nnen wir uns weit √ºber die Karte hinausbewegen, aber dies ist unerw√ºnscht. </font><font style="vertical-align: inherit;">Die Kamera sollte in der Karte bleiben. </font><font style="vertical-align: inherit;">Um dies sicherzustellen, m√ºssen wir die Grenzen der Karte kennen, daher ist eine Verkn√ºpfung mit dem Raster erforderlich. </font><font style="vertical-align: inherit;">F√ºgen Sie es hinzu und verbinden Sie es.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid grid;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e71/f87/68e/e71f8768e16aee250700a7bd694a0e6b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie m√ºssen die Rastergr√∂√üe anfordern. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir an eine neue Position gewechselt sind, werden wir sie mit der neuen Methode begrenzen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ transform.localPosition = ClampPosition(position); } <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Position X hat einen Minimalwert von 0 und das Maximum wird durch die Gr√∂√üe der Karte bestimmt. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = grid.chunkCountX * HexMetrics.chunkSizeX * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gleiches gilt f√ºr Position Z. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = grid.chunkCountX * HexMetrics.chunkSizeX * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = grid.chunkCountZ * HexMetrics.chunkSizeZ * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Tat ist dies ein wenig ungenau. </font><font style="vertical-align: inherit;">Der Startpunkt befindet sich in der Mitte der Zelle, nicht links. </font><font style="vertical-align: inherit;">Daher soll die Kamera in der Mitte der Zellen ganz rechts anhalten. </font><font style="vertical-align: inherit;">Subtrahieren Sie dazu die H√§lfte der Zelle vom Maximum von X.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.chunkCountX * HexMetrics.chunkSizeX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aus dem gleichen Grund m√ºssen wir das Maximum Z reduzieren. Da sich die Metriken geringf√ºgig unterscheiden, m√ºssen wir die gesamte Zelle subtrahieren. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.chunkCountZ * HexMetrics.chunkSizeZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit der Bewegung, die wir gemacht haben, bleibt nur ein kleines Detail √ºbrig. </font><font style="vertical-align: inherit;">Manchmal reagiert die Benutzeroberfl√§che auf die Pfeiltasten, und dies f√ºhrt dazu, dass sich der Schieberegler bewegt, wenn Sie die Kamera bewegen. </font><font style="vertical-align: inherit;">Dies geschieht, wenn sich die Benutzeroberfl√§che als aktiv betrachtet, nachdem Sie darauf geklickt haben und sich der Cursor weiterhin dar√ºber befindet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen verhindern, dass die Benutzeroberfl√§che Tastatureingaben abh√∂rt. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das EventSystem-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekt </font><em><font style="vertical-align: inherit;">angewiesen wird</font></em><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Send Navigation Events</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht auszuf√ºhren </font><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/008/313/35c/00831335c530f6fcb06d4fe15890c316.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keine Navigationsereignisse mehr.</font></font></i> <br><br><h3>  Drehen Sie sich </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√∂chten Sie sehen, was sich hinter der Klippe befindet? </font><font style="vertical-align: inherit;">Es w√§re bequem, die Kamera drehen zu k√∂nnen! </font><font style="vertical-align: inherit;">F√ºgen wir diese Funktion hinzu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zoomstufe ist f√ºr die Drehung nicht wichtig, nur die Geschwindigkeit reicht aus. </font><font style="vertical-align: inherit;">F√ºgen Sie eine gemeinsame Variable hinzu </font></font><code>rotationSpeed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und setzen Sie sie auf 180 Grad. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie das Rotationsdelta, </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indem Sie die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rotationsachse</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abtasten </font><font style="vertical-align: inherit;">und gegebenenfalls </font><font style="vertical-align: inherit;">die </font><em><font style="vertical-align: inherit;">Rotation</font></em><font style="vertical-align: inherit;"> √§ndern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationSpeed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoomDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Mouse ScrollWheel"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zoomDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustZoom(zoomDelta); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Rotation"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rotationDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustRotation(rotationDelta); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Horizontal"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span> || zDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustPosition(xDelta, zDelta); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c17/189/c8f/c17189c8f16ef3e50aa8af32f7ff34c8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drehgeschwindigkeit. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tats√§chlich ist die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rotationsachse</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht standardm√§√üig. </font><font style="vertical-align: inherit;">Wir m√ºssen es selbst schaffen. </font><font style="vertical-align: inherit;">Gehen Sie zu den Eingabeparametern und duplizieren Sie den obersten Eintrag </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertikal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">√Ñndern Sie den Namen des Duplikats in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rotation</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und √§ndern Sie die Tasten in QE und ein Komma (,) mit einem Punkt (.).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/549/6a8/50a/5496a850af906515b57a0d0fd1aea7b5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eingangsachse drehen.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe das Unity-Paket heruntergeladen. Warum habe ich diese Eingabe nicht?</font></font></b> <div class="spoiler_text">     .       Unity.  ,     .    ,    ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Drehwinkel, den wir verfolgen und √§ndern werden </font></font><code>AdjustRotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Danach drehen wir das gesamte Kamerasystem.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationAngle; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { rotationAngle += delta * rotationSpeed * Time.deltaTime; transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, rotationAngle, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da der Vollkreis 360 Grad betr√§gt, rollen wir den Drehwinkel so, dass er im Bereich von 0 bis 360 liegt. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { rotationAngle += delta * rotationSpeed * Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rotationAngle &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span>) { rotationAngle += <span class="hljs-number"><span class="hljs-number">360f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rotationAngle &gt;= <span class="hljs-number"><span class="hljs-number">360f</span></span>) { rotationAngle -= <span class="hljs-number"><span class="hljs-number">360f</span></span>; } transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, rotationAngle, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Aktion schalten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt funktioniert die Rotation. </font><font style="vertical-align: inherit;">Wenn Sie es √ºberpr√ºfen, k√∂nnen Sie sehen, dass die Bewegung absolut ist. </font><font style="vertical-align: inherit;">Daher ist die Bewegung nach dem Drehen um 180 Grad das Gegenteil von dem, was erwartet wurde. </font><font style="vertical-align: inherit;">F√ºr den Benutzer w√§re es viel bequemer, wenn die Bewegung relativ zum Betrachtungswinkel der Kamera ausgef√ºhrt wird. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies tun, indem wir die aktuelle Drehung mit der Bewegungsrichtung multiplizieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { Vector3 direction = transform.localRotation * <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta).normalized; ‚Ä¶ }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relative Verschiebung. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erweiterte Bearbeitung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt, da wir eine gr√∂√üere Karte haben, k√∂nnen Sie die Kartenbearbeitungswerkzeuge verbessern. </font><font style="vertical-align: inherit;">Das √Ñndern einer Zelle zu einem Zeitpunkt ist zu lang, daher w√§re es sch√∂n, einen gr√∂√üeren Pinsel zu erstellen. </font><font style="vertical-align: inherit;">Es ist auch praktisch, wenn Sie malen oder die H√∂he √§ndern k√∂nnen, wobei alles andere unver√§ndert bleibt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optionale Farbe und H√∂he </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen Farben optional machen, indem wir der Umschaltgruppe eine leere Auswahloption hinzuf√ºgen. </font><font style="vertical-align: inherit;">Duplizieren Sie einen der Farbschalter und ersetzen Sie das Etikett durch </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">---</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder √§hnliches, um anzuzeigen, dass es sich nicht um eine Farbe handelt. </font><font style="vertical-align: inherit;">√Ñndern Sie dann das Argument des Ereignisses </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Value Changed</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in ‚àí1.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/786/485/b0c/786485b0cbbae8edee6c80873f19afc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ung√ºltiger Farbindex. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich ist dieser Index f√ºr ein Array von Farben nicht g√ºltig. </font><font style="vertical-align: inherit;">Wir k√∂nnen damit bestimmen, ob Farbe auf Zellen angewendet werden soll.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { applyColor = index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { activeColor = colors[index]; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } cell.Elevation = activeElevation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die H√∂he wird durch einen Schieberegler gesteuert, daher k√∂nnen wir keinen Schalter hinzuf√ºgen. </font><font style="vertical-align: inherit;">Stattdessen k√∂nnen wir einen separaten Schalter verwenden, um die H√∂henbearbeitung zu aktivieren oder zu deaktivieren. </font><font style="vertical-align: inherit;">Standardm√§√üig ist es aktiviert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyElevation = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie der Benutzeroberfl√§che einen neuen H√∂henschalter hinzu. </font><font style="vertical-align: inherit;">Ich werde auch alles auf ein neues Bedienfeld setzen und den H√∂henregler horizontal machen, damit die Benutzeroberfl√§che sch√∂ner wird.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07d/cab/84d/07dcab84d8e8fe4daac4b6120df34d60.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optionale Farbe und H√∂he. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die H√∂he zu aktivieren, ben√∂tigen wir eine neue Methode, die wir mit der Benutzeroberfl√§che verbinden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyElevation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyElevation = toggle; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie durch Anschlie√üen an den H√∂henschalter sicher, dass die dynamische Bool-Methode oben in der Liste der Methoden verwendet wird. </font><font style="vertical-align: inherit;">Die richtigen Versionen zeigen im Inspektor kein H√§kchen an.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/d5b/1b2/887d5b1b275cb18957b63bcbecf145d4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir √ºbermitteln den Status des H√∂henschalters. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir nur noch die F√§rbung mit Blumen oder nur die H√∂he w√§hlen. </font><font style="vertical-align: inherit;">Oder beides wie immer. </font><font style="vertical-align: inherit;">Wir k√∂nnen uns sogar daf√ºr entscheiden, weder das eine noch das andere zu √§ndern, aber bisher ist es f√ºr uns nicht besonders n√ºtzlich.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wechseln Sie zwischen Farbe und H√∂he.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum schaltet sich die H√∂he bei der Auswahl einer Farbe aus?</font></font></b> <div class="spoiler_text">  ,       toggle group. ,          ,     toggle group. </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pinselgr√∂√üe </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie zur Unterst√ºtzung der Gr√∂√üe des Pinsels eine ganzzahlige Variable </font></font><code>brushSize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und eine Methode zum Festlegen √ºber die Benutzeroberfl√§che hinzu. </font><font style="vertical-align: inherit;">Wir werden den Schieberegler verwenden, also m√ºssen wir den Wert erneut von float in int konvertieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brushSize; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetBrushSize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size</span></span></span><span class="hljs-function">)</span></span> { brushSize = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)size; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/794/bfb/60f/794bfb60f2f1c777fa0363ede3f19540.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schieberegler f√ºr Pinselgr√∂√üe. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen einen neuen Schieberegler erstellen, indem Sie den H√∂henschieberegler duplizieren. </font><font style="vertical-align: inherit;">√Ñndern Sie den Maximalwert auf 4 und h√§ngen Sie ihn an die entsprechende Methode an. </font><font style="vertical-align: inherit;">Ich habe ihm auch einen Tag hinzugef√ºgt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88e/8b2/f58/88e8b2f58abfd48657387e6670c51215.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einstellungen f√ºr den Pinselgr√∂√üen-Schieberegler. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt, da wir mehrere Zellen gleichzeitig bearbeiten k√∂nnen, m√ºssen wir die Methode verwenden </font></font><code>EditCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Methode ruft </font></font><code>EditCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alle beteiligten Zellen auf. </font><font style="vertical-align: inherit;">Die urspr√ºnglich ausgew√§hlte Zelle wird als Mitte des Pinsels betrachtet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { EditCells(hexGrid.GetCell(hit.point)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Gr√∂√üe des Pinsels bestimmt den Radius der Bearbeitung. </font><font style="vertical-align: inherit;">Bei einem Radius von 0 ist dies nur eine zentrale Zelle. </font><font style="vertical-align: inherit;">Mit einem Radius von 1 ist dies das Zentrum und seine Nachbarn. </font><font style="vertical-align: inherit;">In einem Radius von 2 werden die Nachbarn des Zentrums und ihre unmittelbaren Nachbarn eingeschaltet.</font></font> Usw. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/14d/b65/61214db6508869c0ceda156c103ca032.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bis zu Radius 3.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um Zellen zu bearbeiten, m√ºssen Sie sie in einer Schleife umgehen. </font><font style="vertical-align: inherit;">Zuerst brauchen wir die X- und Z-Koordinaten des Zentrums.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX = center.coordinates.X; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerZ = center.coordinates.Z; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir finden die minimale Z-Koordinate durch Subtrahieren des Radius. </font><font style="vertical-align: inherit;">Also definieren wir die Nulllinie. </font><font style="vertical-align: inherit;">Ab dieser Linie durchlaufen wir die Linie, bis wir die Linie in der Mitte abdecken.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX = center.coordinates.X; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerZ = center.coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ - brushSize; z &lt;= centerZ; z++, r++) { } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste Zelle in der unteren Reihe hat dieselbe X-Koordinate wie die mittlere Zelle. </font><font style="vertical-align: inherit;">Diese Koordinate nimmt mit zunehmender Zeilennummer ab. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die letzte Zelle hat immer eine X-Koordinate, die der Mittelkoordinate plus Radius entspricht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir jede Zeile durchlaufen und Zellen anhand ihrer Koordinaten abrufen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ - brushSize; z &lt;= centerZ; z++, r++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = centerX - r; x &lt;= centerX + brushSize; x++) { EditCell(hexGrid.GetCell(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z))); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben noch keine Methode </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einem Koordinatenparameter, also erstellen Sie sie. </font><font style="vertical-align: inherit;">Konvertieren Sie in die Koordinaten der Verschiebungen und erhalten Sie die Zelle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates coordinates</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = coordinates.X + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[x + z * cellCountX]; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b59/490/9f2/b594909f28de1c2d52c954d312d7b90f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der untere Teil des Pinsels, Gr√∂√üe 2.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir bedecken den Rest des Pinsels und f√ºhren einen Zyklus von oben nach unten zur Mitte durch. </font><font style="vertical-align: inherit;">In diesem Fall wird die Logik gespiegelt und die zentrale Zeile muss ausgeschlossen werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX = center.coordinates.X; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerZ = center.coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ - brushSize; z &lt;= centerZ; z++, r++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = centerX - r; x &lt;= centerX + brushSize; x++) { EditCell(hexGrid.GetCell(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z))); } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ + brushSize; z &gt; centerZ; z--, r++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = centerX - brushSize; x &lt;= centerX + r; x++) { EditCell(hexGrid.GetCell(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z))); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e8/add/c7c/9e8addc7cf0012210cdd5dc0588bc6cf.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der gesamte Pinsel, Gr√∂√üe 2.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies funktioniert, es sei denn, unser Pinsel geht √ºber die R√§nder des Rasters hinaus. </font><font style="vertical-align: inherit;">In diesem Fall erhalten wir eine Ausnahme f√ºr einen Index au√üerhalb des Bereichs. </font><font style="vertical-align: inherit;">Um dies zu vermeiden, √ºberpr√ºfen Sie die Grenzen </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und kehren Sie zur√ºck, </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn eine nicht vorhandene Zelle angefordert wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates coordinates</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || z &gt;= cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = coordinates.X + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || x &gt;= cellCountX) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[x + z * cellCountX]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um eine Nullreferenzausnahme zu vermeiden, </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss vor dem Bearbeiten gepr√ºft werden, ob die Zelle tats√§chlich vorhanden ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mehrere Pinselgr√∂√üen verwenden. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schalten Sie die Sichtbarkeit der Zellenbeschriftung um </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meistens m√ºssen wir keine Zelletiketten sehen. </font><font style="vertical-align: inherit;">Machen wir sie also optional. </font><font style="vertical-align: inherit;">Da jedes St√ºck seine eigene Leinwand schafft, f√ºgen Sie </font><font style="vertical-align: inherit;">ein Verfahren </font></font><code>ShowUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn die Benutzeroberfl√§che sichtbar sein soll, aktivieren wir die Zeichenfl√§che. </font><font style="vertical-align: inherit;">Andernfalls deaktivieren Sie es.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { gridCanvas.gameObject.SetActive(visible); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lassen Sie uns die Benutzeroberfl√§che standardm√§√üig ausblenden. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; ShowUI(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da das Auftreten von UI - </font><font style="vertical-align: inherit;">Schalter f√ºr die gesamte Karte, f√ºgen Sie </font><font style="vertical-align: inherit;">eine Methode </font></font><code>ShowUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es leitet die Anfrage nur an seine Fragmente weiter.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].ShowUI(visible); } }</code> </pre> <br> <code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erh√§lt die gleiche Methode und leitet die Anforderung an das Raster weiter. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { hexGrid.ShowUI(visible); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schlie√ülich k√∂nnen wir der Benutzeroberfl√§che einen Schalter hinzuf√ºgen und diese verbinden. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/120/637/740/120637740d174168d298407ec129c0d3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tag-Sichtbarkeitsschalter. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 6: Fl√ºsse </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hinzuf√ºgen von Fl√ºssen zu Zellen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Drag &amp; Drop-Unterst√ºtzung zum Zeichnen von Fl√ºssen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flussbetten schaffen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden mehrerer Netze pro Fragment. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen Sie einen gemeinsamen Listenpool. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation und Animation von flie√üendem Wasser. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im vorherigen Teil haben wir √ºber die Unterst√ºtzung gro√üer Karten gesprochen. </font><font style="vertical-align: inherit;">Jetzt k√∂nnen wir zu gr√∂√üeren Reliefelementen √ºbergehen. </font><font style="vertical-align: inherit;">Dieses Mal werden wir √ºber die Fl√ºsse sprechen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/e66/4fb/56ae664fb799dd59d5d8e85397945937.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fl√ºsse flie√üen aus den Bergen.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flusszellen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt drei M√∂glichkeiten, einem Sechseckgitter Fl√ºsse hinzuzuf√ºgen. Der erste Weg ist, sie von Zelle zu Zelle flie√üen zu lassen. So wird es in Endless Legend implementiert. Die zweite M√∂glichkeit besteht darin, sie zwischen den Zellen von Kante zu Kante flie√üen zu lassen. So wird es in Civilization 5 implementiert. Der dritte Weg besteht darin, √ºberhaupt keine speziellen Flussstrukturen zu schaffen, sondern Wasserzellen zu verwenden, um sie vorzuschlagen. So werden die Fl√ºsse in Age of Wonders 3 implementiert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In unserem Fall sind die R√§nder der Zellen bereits von H√§ngen und Klippen besetzt. Dies l√§sst wenig Raum f√ºr Fl√ºsse. Deshalb werden wir sie von Zelle zu Zelle flie√üen lassen. Dies bedeutet, dass in jeder Zelle entweder kein Fluss vorhanden ist oder ein Fluss entlang des Flusses flie√üt oder dass sich ein Anfang oder ein Ende des Flusses darin befindet. In den Zellen, entlang derer der Fluss flie√üt, kann er gerade flie√üen und eine oder zwei Schritte drehen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/db2/2a4/e7fdb22a4346f9281865ad95a1946f75.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºnf m√∂gliche Flusskonfigurationen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden das Verzweigen oder Zusammenf√ºhren von Fl√ºssen nicht unterst√ºtzen. </font><font style="vertical-align: inherit;">Dies wird die Dinge noch komplizierter machen, insbesondere den Wasserfluss. </font><font style="vertical-align: inherit;">Wir werden auch nicht von gro√üen Wassermengen verwirrt sein. </font><font style="vertical-align: inherit;">Wir werden sie in einem anderen Tutorial betrachten.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flussverfolgung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zelle, entlang der der Fluss flie√üt, kann gleichzeitig als ein ein- und ausgehender Fluss betrachtet werden. </font><font style="vertical-align: inherit;">Wenn es den Anfang eines Flusses enth√§lt, hat es nur einen abgehenden Fluss. </font><font style="vertical-align: inherit;">Und wenn es das Ende des Flusses enth√§lt, dann hat es nur einen ankommenden Fluss. </font><font style="vertical-align: inherit;">Wir k√∂nnen diese Informationen unter </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwendung von zwei Booleschen Werten </font><font style="vertical-align: inherit;">speichern </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasIncomingRiver, hasOutgoingRiver;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das reicht aber nicht. </font><font style="vertical-align: inherit;">Wir m√ºssen auch die Richtung dieser Fl√ºsse kennen. </font><font style="vertical-align: inherit;">Im Fall eines abgehenden Flusses zeigt es an, wohin er sich bewegt. </font><font style="vertical-align: inherit;">Bei einem ankommenden Fluss wird angezeigt, woher er stammt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasIncomingRiver, hasOutgoingRiver; HexDirection incomingRiver, outgoingRiver;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Informationen werden beim Triangulieren von Zellen ben√∂tigt, daher werden Eigenschaften hinzugef√ºgt, um Zugriff darauf zu erhalten. </font><font style="vertical-align: inherit;">Wir werden es nicht unterst√ºtzen, sie direkt zuzuweisen. </font><font style="vertical-align: inherit;">Dazu f√ºgen wir eine separate Methode hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasIncomingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasOutgoingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasOutgoingRiver; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection IncomingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> incomingRiver; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection OutgoingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine wichtige Frage ist, ob sich in der Zelle ein Fluss befindet, unabh√§ngig von den Details. </font><font style="vertical-align: inherit;">F√ºgen wir daher auch hierf√ºr eine Eigenschaft hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver || hasOutgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere logische Frage: ist der Anfang oder das Ende des Flusses in der Zelle. </font><font style="vertical-align: inherit;">Wenn der Zustand des ein- und ausgehenden Flusses unterschiedlich ist, ist dies nur der Fall. </font><font style="vertical-align: inherit;">Daher werden wir dies zu einer weiteren Eigenschaft machen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasRiverBeginOrEnd { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver != hasOutgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und schlie√ülich ist es hilfreich zu wissen, ob der Fluss durch einen bestimmten Kamm flie√üt, ob er ein- oder ausgeht. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasRiverThroughEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver &amp;&amp; incomingRiver == direction || hasOutgoingRiver &amp;&amp; outgoingRiver == direction; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flussentfernung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir einer Zelle einen Fluss hinzuf√ºgen, implementieren wir zun√§chst die Unterst√ºtzung f√ºr die Flussentfernung. </font><font style="vertical-align: inherit;">Zun√§chst werden wir eine Methode schreiben, um nur den abgehenden Teil des Flusses zu entfernen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn sich in der Zelle kein abflie√üender Fluss befindet, muss nichts unternommen werden. </font><font style="vertical-align: inherit;">Andernfalls schalten Sie es aus und f√ºhren Sie das Update durch.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasOutgoingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist aber noch nicht alles. </font><font style="vertical-align: inherit;">Der abgehende Fluss muss irgendwo weitergehen. </font><font style="vertical-align: inherit;">Daher muss es einen Nachbarn mit dem ankommenden Fluss geben. </font><font style="vertical-align: inherit;">Wir m√ºssen sie auch loswerden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasOutgoingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Refresh(); HexCell neighbor = GetNeighbor(outgoingRiver); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbor.Refresh(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kann ein Fluss nicht aus einer Karte flie√üen?</font></font></b> <div class="spoiler_text">      ,     .     ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Entfernen eines Flusses aus einer Zelle √§ndert nur das Erscheinungsbild dieser Zelle. </font><font style="vertical-align: inherit;">Im Gegensatz zur Bearbeitungsh√∂he oder -farbe hat dies keine Auswirkungen auf die Nachbarn. </font><font style="vertical-align: inherit;">Daher m√ºssen wir nur die Zelle selbst aktualisieren, nicht aber ihre Nachbarn.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasOutgoingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; RefreshSelfOnly(); HexCell neighbor = GetNeighbor(outgoingRiver); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbor.RefreshSelfOnly(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Methode </font></font><code>RefreshSelfOnly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aktualisiert einfach das Fragment, zu dem die Zelle geh√∂rt. </font><font style="vertical-align: inherit;">Da wir den Fluss w√§hrend der Netzinitialisierung nicht √§ndern, m√ºssen wir uns keine Sorgen machen, wenn bereits ein Fragment zugewiesen wurde.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshSelfOnly</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunk.Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Entfernen eingehender Fl√ºsse funktioniert genauso. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveIncomingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasIncomingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; RefreshSelfOnly(); HexCell neighbor = GetNeighbor(incomingRiver); neighbor.hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbor.RefreshSelfOnly(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und die Entfernung des gesamten Flusses bedeutet einfach die Entfernung sowohl der ankommenden als auch der abgehenden Teile des Flusses. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RemoveOutgoingRiver(); RemoveIncomingRiver(); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fl√ºsse hinzuf√ºgen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Entstehung von Fl√ºssen zu unterst√ºtzen, ben√∂tigen wir eine Methode zur Spezifizierung des abgehenden Flusses der Zelle. </font><font style="vertical-align: inherit;">Er muss alle vorherigen ausgehenden Fl√ºsse neu definieren und den entsprechenden ankommenden Fluss festlegen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zun√§chst m√ºssen wir nichts tun, wenn der Fluss bereits existiert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasOutgoingRiver &amp;&amp; outgoingRiver == direction) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als n√§chstes m√ºssen wir sicherstellen, dass es einen Nachbarn in der richtigen Richtung gibt. </font><font style="vertical-align: inherit;">Au√üerdem k√∂nnen Fl√ºsse nicht flie√üen. </font><font style="vertical-align: inherit;">Daher m√ºssen wir die Operation abschlie√üen, wenn der Nachbar h√∂her ist.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || elevation &lt; neighbor.elevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als n√§chstes m√ºssen wir den vorherigen abgehenden Fluss r√§umen. </font><font style="vertical-align: inherit;">Und wir m√ºssen auch den ankommenden Fluss entfernen, wenn er einem neuen abgehenden Fluss √ºberlagert ist.</font></font><br><br><pre> <code class="cs hljs"> RemoveOutgoingRiver(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasIncomingRiver &amp;&amp; incomingRiver == direction) { RemoveIncomingRiver(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt k√∂nnen wir mit dem Aufbau des ausgehenden Flusses fortfahren. </font></font><br><br><pre> <code class="cs hljs"> hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; outgoingRiver = direction; RefreshSelfOnly();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und vergessen Sie nicht, den eingehenden Fluss f√ºr eine andere Zelle festzulegen, nachdem Sie den aktuell eingehenden Fluss entfernt haben, falls vorhanden. </font></font><br><br><pre> <code class="cs hljs"> neighbor.RemoveIncomingRiver(); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; neighbor.incomingRiver = direction.Opposite(); neighbor.RefreshSelfOnly();</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fl√ºsse losflie√üen lassen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir es nun m√∂glich gemacht haben, nur die richtigen Fl√ºsse hinzuzuf√ºgen, k√∂nnen andere Aktionen immer noch die falschen erzeugen. </font><font style="vertical-align: inherit;">Wenn wir die H√∂he der Zelle √§ndern, m√ºssen wir erneut mit Nachdruck sicherstellen, dass die Fl√ºsse nur nach unten flie√üen k√∂nnen. </font><font style="vertical-align: inherit;">Alle unregelm√§√üigen Fl√ºsse m√ºssen entfernt werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasOutgoingRiver &amp;&amp; elevation &lt; GetNeighbor(outgoingRiver).elevation ) { RemoveOutgoingRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasIncomingRiver &amp;&amp; elevation &gt; GetNeighbor(incomingRiver).elevation ) { RemoveIncomingRiver(); } Refresh(); } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fl√ºsse wechseln </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Flussbearbeitung zu unterst√ºtzen, m√ºssen wir der Benutzeroberfl√§che einen Flussschalter hinzuf√ºgen. </font><font style="vertical-align: inherit;">Tats√§chlich. </font><font style="vertical-align: inherit;">Wir brauchen Unterst√ºtzung f√ºr drei Bearbeitungsmodi. </font><font style="vertical-align: inherit;">Wir m√ºssen entweder die Fl√ºsse ignorieren oder sie hinzuf√ºgen oder l√∂schen. </font><font style="vertical-align: inherit;">Wir k√∂nnen eine einfache Helfer-Aufz√§hlung von Schaltern verwenden, um den Status zu verfolgen. </font><font style="vertical-align: inherit;">Da wir es nur im Editor verwenden, k√∂nnen wir es innerhalb der Klasse </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zusammen mit dem Feld f√ºr den Flussmodus definieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> OptionalToggle { Ignore, Yes, No } OptionalToggle riverMode;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und wir brauchen eine Methode, um das Flussregime √ºber die Benutzeroberfl√§che zu √§ndern. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRiverMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { riverMode = (OptionalToggle)mode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das Flussregime zu steuern, f√ºgen Sie der Benutzeroberfl√§che drei Schalter hinzu und verbinden Sie sie mit der neuen Umschaltgruppe, wie wir es mit den Farben getan haben. </font><font style="vertical-align: inherit;">Ich habe die Schalter so konfiguriert, dass sich ihre Beschriftungen unter den Kontrollk√§stchen befinden. </font><font style="vertical-align: inherit;">Aus diesem Grund bleiben sie d√ºnn genug, um alle drei Optionen in einer Zeile unterzubringen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/1bf/d9c/0f51bfd9ce2a73bc23f1ef99cbd4b24e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UI Fl√ºsse</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum nicht eine Dropdown-Liste verwenden?</font></font></b> <div class="spoiler_text">  ,    .   dropdown list  Unity        Play.    ,      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Drag &amp; Drop-Erkennung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um einen Fluss zu schaffen, brauchen wir sowohl eine Zelle als auch eine Richtung. </font><font style="vertical-align: inherit;">Im Moment </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">liefert uns diese Information nicht. </font><font style="vertical-align: inherit;">Daher m√ºssen wir Drag &amp; Drop-Unterst√ºtzung von einer Zelle zur anderen hinzuf√ºgen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen wissen, ob dieser Widerstand korrekt ist, und auch seine Richtung bestimmen. </font><font style="vertical-align: inherit;">Und um das Ziehen und Ablegen zu erkennen, m√ºssen wir uns an die vorherige Zelle erinnern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isDrag; HexDirection dragDirection; HexCell previousCell;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das Ziehen nicht ausgef√ºhrt wird, ist dies in der vorherigen Zelle zun√§chst nicht der Fall. </font><font style="vertical-align: inherit;">Das hei√üt, wenn keine Eingabe erfolgt oder wir nicht mit der Karte interagieren, m√ºssen Sie ihr einen Wert zuweisen </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetMouseButton(<span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; !EventSystem.current.IsPointerOverGameObject() ) { HandleInput(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { EditCells(hexGrid.GetCell(hit.point)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die aktuelle Zelle ist diejenige, die wir gefunden haben, indem wir den Strahl mit dem Netz gekreuzt haben. </font><font style="vertical-align: inherit;">Nach dem Bearbeiten der Zellen wird es aktualisiert und wird zur vorherigen Zelle f√ºr ein neues Update.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { HexCell currentCell = hexGrid.GetCell(hit.point); EditCells(currentCell); previousCell = currentCell; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir die aktuelle Zelle ermittelt haben, k√∂nnen wir sie gegebenenfalls mit der vorherigen Zelle vergleichen. </font><font style="vertical-align: inherit;">Wenn wir zwei verschiedene Zellen erhalten, haben wir m√∂glicherweise das richtige Drag &amp; Drop und m√ºssen dies √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Ansonsten ist dies definitiv kein Drag &amp; Drop.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { HexCell currentCell = hexGrid.GetCell(hit.point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isDrag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } EditCells(currentCell); previousCell = currentCell; isDrag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie √ºberpr√ºfen wir das Drag &amp; Drop? </font><font style="vertical-align: inherit;">√úberpr√ºfen, ob die aktuelle Zelle ein Nachbar der vorherigen ist. </font><font style="vertical-align: inherit;">Wir √ºberpr√ºfen dies, indem wir seine Nachbarn in einem Zyklus umgehen. </font><font style="vertical-align: inherit;">Wenn wir eine √úbereinstimmung finden, erkennen wir auch sofort die Richtung des Ziehens.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateDrag</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell currentCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( dragDirection = HexDirection.NE; dragDirection &lt;= HexDirection.NW; dragDirection++ ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousCell.GetNeighbor(dragDirection) == currentCell) { isDrag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } isDrag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Werden wir ruckartige Drags erzeugen?</font></font></b> <div class="spoiler_text">       ,          .         ¬´¬ª ,     . <br><br>    ,   .            . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen √§ndern </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt, da wir Drag &amp; Drop erkennen k√∂nnen, k√∂nnen wir ausgehende Fl√ºsse definieren. </font><font style="vertical-align: inherit;">Wir k√∂nnen auch Fl√ºsse entfernen, daf√ºr ist keine Drag &amp; Drop-Unterst√ºtzung erforderlich.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.No) { cell.RemoveRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag &amp;&amp; riverMode == OptionalToggle.Yes) { previousCell.SetOutgoingRiver(dragDirection); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Code zeichnet den Fluss von der vorherigen Zelle in die aktuelle. </font><font style="vertical-align: inherit;">Aber er ignoriert die Gr√∂√üe des Pinsels. </font><font style="vertical-align: inherit;">Das ist ziemlich logisch, aber zeichnen wir die Fl√ºsse f√ºr alle Zellen, die von der B√ºrste geschlossen werden. </font><font style="vertical-align: inherit;">Dies kann durch Ausf√ºhren von Operationen an der bearbeiteten Zelle erfolgen. </font><font style="vertical-align: inherit;">In unserem Fall m√ºssen wir sicherstellen, dass tats√§chlich eine andere Zelle existiert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag &amp;&amp; riverMode == OptionalToggle.Yes) { HexCell otherCell = cell.GetNeighbor(dragDirection.Opposite()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherCell) { otherCell.SetOutgoingRiver(dragDirection); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir die Fl√ºsse bearbeiten, aber noch nicht sehen. </font><font style="vertical-align: inherit;">Wir k√∂nnen √ºberpr√ºfen, ob dies funktioniert, indem wir die ge√§nderten Zellen im Debug-Inspektor untersuchen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fe/927/46f/4fe92746f97fc517dc0d1da7c0aeee62.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Zelle mit einem Fluss im Debug-Inspektor.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist ein Debug-Inspektor?</font></font></b> <div class="spoiler_text">             .        .    ,     . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flussbetten zwischen Zellen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Triangulation eines Flusses m√ºssen zwei Teile ber√ºcksichtigt werden: die Lage des Flussbettes und das durch ihn flie√üende Wasser. </font><font style="vertical-align: inherit;">Zuerst werden wir einen Kanal erstellen und das Wasser f√ºr sp√§ter verlassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der einfachste Teil des Flusses ist dort, wo er in Verbindungsstellen zwischen Zellen flie√üt. </font><font style="vertical-align: inherit;">W√§hrend wir diesen Bereich mit einem Streifen von drei Quad triangulieren. </font><font style="vertical-align: inherit;">Wir k√∂nnen ein Flussbett hinzuf√ºgen, indem wir das mittlere Quad absenken und zwei Kanalw√§nde hinzuf√ºgen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/545/b3c/b93/545b3cb9373e9479011916513c3c51da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinzuf√ºgen eines Flusses zu einem Rippenstreifen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daf√ºr werden im Fall des Flusses zwei zus√§tzliche Quads ben√∂tigt und ein Kanal mit zwei vertikalen W√§nden erstellt. </font><font style="vertical-align: inherit;">Ein alternativer Ansatz ist die Verwendung von vier Quad. </font><font style="vertical-align: inherit;">Dann senken wir den mittleren Gipfel, um ein Bett mit schr√§gen W√§nden zu schaffen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/757/7d9/ac1/7577d9ac1978be05cbdda0f8925c75d0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immer vier Quad. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die st√§ndige Verwendung der gleichen Anzahl von Vierecken ist praktisch. W√§hlen Sie diese Option.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Edge Tops hinzuf√ºgen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der √úbergang von drei zu vier pro Kante erfordert die Erstellung eines zus√§tzlichen Scheitelpunkts der Kante. </font><font style="vertical-align: inherit;">Rewrite </font></font><code>EdgeVertices</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, erste Umbenennung </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>v5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und dann umbenannt </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aktionen in dieser Reihenfolge stellen sicher, dass der gesamte Code weiterhin auf die richtigen Scheitelpunkte verweist. </font><font style="vertical-align: inherit;">Verwenden Sie dazu die Umbenennungs- oder Refactor-Option Ihres Editors, damit die √Ñnderungen √ºberall angewendet werden. </font><font style="vertical-align: inherit;">Andernfalls m√ºssen Sie den gesamten Code manuell √ºberpr√ºfen und √Ñnderungen vornehmen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 v1, v2, v4, v5;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie nach dem Umbenennen alles hinzu </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 v1, v2, v3, v4, v5;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie dem Konstruktor einen neuen Scheitelpunkt hinzu. </font><font style="vertical-align: inherit;">Es befindet sich in der Mitte zwischen den Eckgipfeln. </font><font style="vertical-align: inherit;">Au√üerdem sollten andere Eckpunkte jetzt in ¬Ω und ¬æ und nicht in &amp; frac13; </font><font style="vertical-align: inherit;">und &amp; frac23;</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EdgeVertices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 corner1, Vector3 corner2</span></span></span><span class="hljs-function">)</span></span> { v1 = corner1; v2 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); v3 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); v4 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.75f</span></span>); v5 = corner2; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinzuf√ºgen </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">hinzuf√ºgen </font></font><code>TerraceLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EdgeVertices </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices a, EdgeVertices b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { EdgeVertices result; result.v1 = HexMetrics.TerraceLerp(a.v1, b.v1, step); result.v2 = HexMetrics.TerraceLerp(a.v2, b.v2, step); result.v3 = HexMetrics.TerraceLerp(a.v3, b.v3, step); result.v4 = HexMetrics.TerraceLerp(a.v4, b.v4, step); result.v5 = HexMetrics.TerraceLerp(a.v5, b.v5, step); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss </font><font style="vertical-align: inherit;">ich </font><font style="vertical-align: inherit;">einen zus√§tzlichen Scheitelpunkt in die F√§cherdreiecke der Rippe aufnehmen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, Color color</span></span></span><span class="hljs-function">)</span></span> { AddTriangle(center, edge.v1, edge.v2); AddTriangleColor(color); AddTriangle(center, edge.v2, edge.v3); AddTriangleColor(color); AddTriangle(center, edge.v3, edge.v4); AddTriangleColor(color); AddTriangle(center, edge.v4, edge.v5); AddTriangleColor(color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und auch in seinen Streifen von Vierecken. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2 </span></span></span><span class="hljs-function">)</span></span> { AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); AddQuadColor(c1, c2); AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); AddQuadColor(c1, c2); AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); AddQuadColor(c1, c2); AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); AddQuadColor(c1, c2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/819/89d/599/81989d5996d7c2832e3dd7f61b4a9bb1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/625/9b1/6a2/6259b16a2776344c51725d32d70001e8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergleich von vier und f√ºnf Eckpunkten pro Kante.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die H√∂he des Flussbettes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben den Kanal erstellt, indem wir die untere Oberseite der Rippe abgesenkt haben. </font><font style="vertical-align: inherit;">Es bestimmt die vertikale Position des Flussbettes. </font><font style="vertical-align: inherit;">Obwohl die genaue vertikale Position jeder Zelle verzerrt ist, m√ºssen wir in Zellen mit derselben H√∂he die gleiche H√∂he des Flussbettes beibehalten. </font><font style="vertical-align: inherit;">Dank dieses Wassers muss es nicht stromaufw√§rts flie√üen. </font><font style="vertical-align: inherit;">Dar√ºber hinaus sollte das Bett niedrig genug sein, um auch bei den am st√§rksten abgelenkten vertikalen Zellen darunter zu bleiben, w√§hrend gleichzeitig gen√ºgend Platz f√ºr Wasser bleibt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie diesen Versatz auf ein </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und dr√ºcken Sie ihn als H√∂he aus. </font><font style="vertical-align: inherit;">Offsets einer Ebene reichen aus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> streamBedElevationOffset = <span class="hljs-number"><span class="hljs-number">-1f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen diese Metrik verwenden, um Eigenschaften hinzuzuf√ºgen </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die vertikale Position des Zellflussbettes zu erhalten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> StreamBedY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (elevation + HexMetrics.streamBedElevationOffset) * HexMetrics.elevationStep; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kanal erstellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einer der sechs dreieckigen Teile einer Zelle trianguliert ist, k√∂nnen wir bestimmen, ob ein Fluss entlang seines Randes flie√üt. </font><font style="vertical-align: inherit;">Wenn ja, k√∂nnen wir den mittleren Gipfel der Rippe auf die H√∂he des Flussbettes absenken.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; EdgeVertices e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; } TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, e); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0d/a57/028/d0da570288985442d990858b2831c07a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie den mittleren Scheitelpunkt der Rippe. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen sehen, wie die ersten Anzeichen des Flusses erscheinen, aber im Relief entstehen L√∂cher. </font><font style="vertical-align: inherit;">Um sie zu schlie√üen, m√ºssen wir eine andere Kante √§ndern und dann die Verbindung triangulieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 bridge = HexMetrics.GetBridge(direction); bridge.y = neighbor.Position.y - cell.Position.y; EdgeVertices e2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( e1.v1 + bridge, e1.v5 + bridge ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e2.v3.y = neighbor.StreamBedY; } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4c/aa9/5f4/b4caa95f424004569e7876bc19c73a20.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abgeschlossene Kan√§le der Rippengelenke. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flussbetten durch eine Zelle </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir die richtigen Flussbetten zwischen den Zellen. Wenn der Fluss durch die Zelle flie√üt, enden die Kan√§le immer in ihrer Mitte. Um dieses Problem zu l√∂sen, muss es funktionieren. Beginnen wir mit dem Fall, dass ein Fluss direkt von einer Kante zur anderen durch eine Zelle flie√üt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es keinen Fluss gibt, kann jeder Teil der Zelle ein einfacher Fan von Dreiecken sein. Wenn der Fluss jedoch direkt flie√üt, muss ein Kanal eingef√ºgt werden. Tats√§chlich m√ºssen wir den zentralen Scheitelpunkt in eine Linie strecken und so die beiden mittleren Dreiecke in Vierecke verwandeln. Dann verwandelt sich der F√§cher der Dreiecke in ein Trapez.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a9/919/ffb/9a9919ffbb99bcded8d44f45e62c3955.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir f√ºgen den Kanal in das Dreieck ein. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solche Kan√§le sind viel l√§nger als diejenigen, die durch die Verbindung von Zellen verlaufen. </font><font style="vertical-align: inherit;">Dies wird deutlich, wenn die Scheitelpunktpositionen verzerrt sind. </font><font style="vertical-align: inherit;">Teilen wir daher das Trapez in zwei Segmente, indem wir einen weiteren Satz von Scheitelpunktkanten in die Mitte zwischen der Mitte und der Kante einf√ºgen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/650/f94/109/650f9410923cb781f145b5211dbe4950.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kanal-Triangulation. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da sich die Triangulation mit einem Fluss stark von der Triangulation ohne Fluss unterscheidet, erstellen wir eine separate Methode daf√ºr. </font><font style="vertical-align: inherit;">Wenn wir einen Fluss haben, verwenden wir diese Methode, andernfalls hinterlassen wir einen Fan von Dreiecken.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; EdgeVertices e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; TriangulateWithRiver(direction, cell, center, e); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeFan(center, e, cell.Color); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/928/f0f/526/928f0f526852960fce6c37bdb480b5bc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√∂cher, in denen es Fl√ºsse geben sollte. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deaktivieren Sie vor√ºbergehend die Zellverzerrung, um besser zu sehen, was passiert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 4f;</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2aa/f49/ae3/2aaf49ae366805585727f1a1ed11c2aa.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unverzerrte Spitzen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation direkt durch die Zelle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um einen Kanal direkt durch einen Teil der Zelle zu erstellen, m√ºssen wir die Mitte in eine Linie strecken. </font><font style="vertical-align: inherit;">Diese Linie sollte die gleiche Breite wie der Kanal haben. </font><font style="vertical-align: inherit;">Wir k√∂nnen den linken Scheitelpunkt finden, indem wir ¬º der Entfernung von der Mitte zur ersten Ecke des vorherigen Teils verschieben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { Vector3 centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñhnliches gilt f√ºr den rechten Scheitelpunkt. </font><font style="vertical-align: inherit;">In diesem Fall ben√∂tigen wir die zweite Ecke des n√§chsten Teils.</font></font><br><br><pre> <code class="cs hljs"> Vector3 centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; Vector3 centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Mittellinie kann durch Erstellen von Scheitelpunktkanten zwischen der Mitte und der Kante gefunden werden. </font></font><br><br><pre> <code class="cs hljs"> EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(centerL, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(centerR, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ñndern Sie als N√§chstes den mittleren Scheitelpunkt der Mittelrippe sowie die Mitte, da diese zu den unteren Punkten des Kanals werden. </font></font><br><br><pre> <code class="cs hljs"> m.v3.y = center.y = e.v3.y;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Raum zwischen der Mittellinie und der Kantenlinie f√ºllen.</font></font><br><br><pre> <code class="cs hljs"> TriangulateEdgeStrip(m, cell.Color, e, cell.Color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ab/050/b30/3ab050b301f8815479142c5b8feae26e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komprimierte Kan√§le.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leider sehen die Kan√§le komprimiert aus. Dies geschieht, weil die mittleren Eckpunkte der Rippe zu nahe beieinander liegen. Warum ist das passiert? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir annehmen, dass die L√§nge der Au√üenkante 1 ist, betr√§gt die L√§nge der Mittellinie ¬Ω. Da sich die mittlere Kante in der Mitte zwischen ihnen befindet, sollte ihre L√§nge gleich ¬æ sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kanalbreite betr√§gt ¬Ω und sollte konstant bleiben. Da die L√§nge der Mittelkante ¬æ betr√§gt, bleibt laut &amp; frac18; nur ¬º √ºbrig. auf beiden Seiten des Kanals.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e1/25f/037/2e125f03727f078ccfd094a29ad4d596.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relative L√§ngen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die L√§nge der Mittelkante ¬æ betr√§gt, ist &amp; frac18; </font><font style="vertical-align: inherit;">wird relativ zur L√§nge der Mittelrippe gleich &amp; frac16; </font><font style="vertical-align: inherit;">Dies bedeutet, dass der zweite und vierte Eckpunkt mit Sechsteln und nicht mit Vierteln interpoliert werden sollten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen eine solche alternative Interpolation unterst√ºtzen, indem wir sie einem </font></font><code>EdgeVertices</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anderen Konstruktor </font><font style="vertical-align: inherit;">hinzuf√ºgen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Anstelle fester Interpolationen f√ºr </font></font><code>v2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verwenden </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir einen Parameter.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EdgeVertices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 corner1, Vector3 corner2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> outerStep</span></span></span><span class="hljs-function">)</span></span> { v1 = corner1; v2 = Vector3.Lerp(corner1, corner2, outerStep); v3 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); v4 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">1f</span></span> - outerStep); v5 = corner2; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir es mit &amp; frac16; </font><font style="vertical-align: inherit;">c </font></font><code>HexMesh.TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(centerL, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(centerR, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span> );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4a/df8/cb5/c4adf8cb5aa6b1685f6d5c592976ea3b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Direkte Kan√§le. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir den Kanal gerade gemacht haben, k√∂nnen wir zum zweiten Teil des Trapezes gehen. </font><font style="vertical-align: inherit;">In diesem Fall k√∂nnen wir den Rippenstreifen nicht verwenden, daher m√ºssen wir dies manuell tun. </font><font style="vertical-align: inherit;">Lassen Sie uns zuerst Dreiecke an den Seiten erstellen.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(centerL, m.v1, m.v2); AddTriangleColor(cell.Color); AddTriangle(centerR, m.v4, m.v5); AddTriangleColor(cell.Color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10b/dc7/a5b/10bdc7a5b1d32d03dbc155a2d00bbfb5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seitendreiecke. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sieht gut aus, also f√ºllen wir den verbleibenden Raum mit zwei Vierecken und erstellen den letzten Teil des Kanals.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(centerL, m.v1, m.v2); AddTriangleColor(cell.Color); AddQuad(centerL, center, m.v2, m.v3); AddQuadColor(cell.Color); AddQuad(center, centerR, m.v3, m.v4); AddQuadColor(cell.Color); AddTriangle(centerR, m.v4, m.v5); AddTriangleColor(cell.Color);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tats√§chlich haben wir keine Alternative, </font></font><code>AddQuadColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die nur einen Parameter erfordert. </font><font style="vertical-align: inherit;">Wir haben es zwar nicht gebraucht. </font><font style="vertical-align: inherit;">Also lasst es uns schaffen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color color</span></span></span><span class="hljs-function">)</span></span> { colors.Add(color); colors.Add(color); colors.Add(color); colors.Add(color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af0/b62/c32/af0b62c3232b36cd0a136b1fc009b7dd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gerade Kan√§le abgeschlossen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation starten und beenden </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Triangulation eines Teils, der nur den Anfang oder das Ende eines Flusses hat, ist ganz anders und erfordert daher eine eigene Methode. </font><font style="vertical-align: inherit;">Daher werden wir dies einchecken </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die entsprechende Methode aufrufen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { TriangulateWithRiverBeginOrEnd(direction, cell, center, e); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithRiver(direction, cell, center, e); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall m√∂chten wir den Kanal in der Mitte vervollst√§ndigen, verwenden daf√ºr jedoch immer noch zwei Stufen. </font><font style="vertical-align: inherit;">Daher erstellen wir erneut die mittlere Kante zwischen der Mitte oder der Kante. </font><font style="vertical-align: inherit;">Da wir den Kanal vervollst√§ndigen m√∂chten, freuen wir uns sehr, dass er komprimiert wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit der Kanal nicht zu schnell flach wird, ordnen wir die H√∂he des Flussbettes dem mittleren Gipfel zu. </font><font style="vertical-align: inherit;">Das Zentrum muss jedoch nicht ge√§ndert werden.</font></font><br><br><pre> <code class="cs hljs"> m.v3.y = e.v3.y;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir k√∂nnen mit einem Rippenstreifen und einem F√§cher triangulieren. </font></font><br><br><pre> <code class="cs hljs"> TriangulateEdgeStrip(m, cell.Color, e, cell.Color); TriangulateEdgeFan(center, m, cell.Color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16b/0c5/9e0/16b0c59e0999f2a505e709648c1e1af7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start- und Endpunkte.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> One-Step-Turns </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betrachten Sie als n√§chstes die scharfen Kurven im Zickzack zwischen benachbarten Zellen. </font><font style="vertical-align: inherit;">Wir werden auch damit umgehen </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Daher m√ºssen wir bestimmen, mit welcher Art von Fluss wir arbeiten.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/523/c03/e37/523c03e370096f804df6b84a97dbdfbf.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zick-Zack-Fluss. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn in der Zelle ein Fluss flie√üt, der sowohl in die entgegengesetzte Richtung als auch in die Richtung flie√üt, mit der wir arbeiten, sollte dies ein gerader Fluss sein. </font><font style="vertical-align: inherit;">In diesem Fall k√∂nnen wir die bereits berechnete Mittellinie speichern. </font><font style="vertical-align: inherit;">Andernfalls kehrt es zu einem Punkt zur√ºck und faltet die Mittellinie.</font></font><br><br><pre> <code class="cs hljs"> Vector3 centerL, centerR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = centerR = center; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90c/992/4c0/90c9924c049cf8033e7480c90b74b903.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gekr√§uselte Zickzacke. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen scharfe Kurven erkennen, indem wir pr√ºfen, ob in der Zelle ein Fluss durch den n√§chsten oder vorherigen Teil der Zelle flie√üt. </font><font style="vertical-align: inherit;">Wenn ja, m√ºssen wir die Mittellinie an der Kante zwischen diesem und dem benachbarten Teil ausrichten. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies tun, indem wir die entsprechende Seite der Linie in der Mitte zwischen der Mitte und dem gemeinsamen Winkel platzieren. </font><font style="vertical-align: inherit;">Die andere Seite der Linie wird dann zur Mitte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { centerL = center; centerR = Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { centerL = Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); centerR = center; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = centerR = center; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem wir entschieden haben, wo sich der linke und der rechte Punkt befinden, k√∂nnen wir das resultierende Zentrum bestimmen, indem wir sie mitteln. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { ‚Ä¶ } center = Vector3.Lerp(centerL, centerR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f14/cc6/4f9/f14cc64f953da69fb270ff2adf613b2e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versetzte Mittelrippe. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl der Kanal auf beiden Seiten die gleiche Breite hat, sieht er ziemlich komprimiert aus. </font><font style="vertical-align: inherit;">Dies wird durch Drehen der Mittellinie um 60 ¬∞ verursacht. </font><font style="vertical-align: inherit;">Sie k√∂nnen diesen Effekt gl√§tten, indem Sie die Breite der Mittellinie leicht erh√∂hen. </font><font style="vertical-align: inherit;">Anstatt mit ¬Ω zu interpolieren, verwenden wir &amp; frac23;</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { centerL = center; centerR = Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { centerL = Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); centerR = center; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28c/c01/ea3/28cc01ea3d203243a1dfe49cde5e9802.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zickzack ohne Kompression.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zweistufige Kurven </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die restlichen F√§lle liegen zwischen Zickzack und geraden Fl√ºssen. </font><font style="vertical-align: inherit;">Dies sind zweistufige Kurven, die sanft geschwungene Fl√ºsse erzeugen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67d/bab/9b2/67dbab9b235833d69b3201c9b38ac653.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der sich schl√§ngelnde Fluss. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um zwischen zwei m√∂glichen Orientierungen zu unterscheiden, m√ºssen wir verwenden </font></font><code>direction.Next().Next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aber lassen Sie </font><font style="vertical-align: inherit;">uns machen es bequemer durch Hinzuf√ºgen von </font></font><code>HexDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweiterungsmethoden </font></font><code>Next2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>Previous2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Previous2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { direction -= <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction &gt;= HexDirection.NE ? direction : (direction + <span class="hljs-number"><span class="hljs-number">6</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Next2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { direction += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction &lt;= HexDirection.NW ? direction : (direction - <span class="hljs-number"><span class="hljs-number">6</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zur√ºck zu </font></font><code>HexMesh.TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jetzt k√∂nnen wir die Richtung unseres m√§andrierenden Flusses mit erkennen </font></font><code>direction.Next2()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { centerL = center; centerR = Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { centerL = Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); centerR = center; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next2())) { centerL = centerR = center; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = centerR = center; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesen beiden letzten F√§llen m√ºssen wir die Mittellinie auf den Teil der Zelle verschieben, der sich auf der Innenseite der Kurve befindet. </font><font style="vertical-align: inherit;">Wenn wir einen Vektor in der Mitte einer festen Kante h√§tten, k√∂nnten wir ihn verwenden, um den Endpunkt zu positionieren. </font><font style="vertical-align: inherit;">Stellen wir uns vor, wir haben eine Methode daf√ºr.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next2())) { centerL = center; centerR = center + HexMetrics.GetSolidEdgeMiddle(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = center + HexMetrics.GetSolidEdgeMiddle(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; centerR = center; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich m√ºssen wir jetzt eine solche Methode hinzuf√ºgen </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Er muss nur zwei Vektoren benachbarter Winkel mitteln und den Integrit√§tskoeffizienten anwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSolidEdgeMiddle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] + corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]) * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> * solidFactor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be1/058/429/be1058429e3d36cd25b8e1da0c1be77a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leicht komprimierte Kurven. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsere Mittellinien sind jetzt korrekt um 30 ¬∞ gedreht. </font><font style="vertical-align: inherit;">Sie sind aber nicht lang genug, weshalb die Kan√§le etwas komprimiert sind. </font><font style="vertical-align: inherit;">Dies geschieht, weil der Mittelpunkt der Rippe n√§her an der Mitte liegt als der Winkel der Rippe. </font><font style="vertical-align: inherit;">Sein Abstand entspricht dem inneren Radius, nicht dem √§u√üeren. </font><font style="vertical-align: inherit;">Das hei√üt, wir arbeiten im falschen Ma√üstab. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir konvertieren bereits von extern zu intern Radius bei </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir m√ºssen den umgekehrten Vorgang ausf√ºhren. </font><font style="vertical-align: inherit;">Lassen Sie uns also beide Umrechnungsfaktoren √ºber verf√ºgbar machen </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outerToInner = <span class="hljs-number"><span class="hljs-number">0.866025404f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerToOuter = <span class="hljs-number"><span class="hljs-number">1f</span></span> / outerToInner; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outerRadius = <span class="hljs-number"><span class="hljs-number">10f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerRadius = outerRadius * outerToInner;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir zur richtigen Skala √ºbergehen </font></font><code>HexMesh.TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Kan√§le bleiben aufgrund ihrer Drehung immer noch etwas zusammengedr√ºckt, dies ist jedoch viel weniger ausgepr√§gt als im Fall von Zickzacklinien. </font><font style="vertical-align: inherit;">Daher m√ºssen wir dies nicht kompensieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next2())) { centerL = center; centerR = center + HexMetrics.GetSolidEdgeMiddle(direction.Next()) * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> * HexMetrics.innerToOuter); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = center + HexMetrics.GetSolidEdgeMiddle(direction.Previous()) * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> * HexMetrics.innerToOuter); centerR = center; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a2/849/49c/2a284949c066c558391613611b93d093.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Glatte Kurven. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation in der N√§he von Fl√ºssen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsere Fl√ºsse sind bereit. </font><font style="vertical-align: inherit;">Aber wir haben noch keine anderen Teile der Zellen, die die Fl√ºsse enthalten, trianguliert. </font><font style="vertical-align: inherit;">Jetzt werden wir diese L√∂cher schlie√üen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f47/5fd/74d/f475fd74d147a577e8adb72cd1ff63fb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√∂cher in der N√§he der Kan√§le. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Zelle einen Fluss hat, dieser aber nicht in die aktuelle Richtung flie√üt, </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rufen wir eine neue Methode in auf.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { TriangulateWithRiverBeginOrEnd(direction, cell, center, e); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithRiver(direction, cell, center, e); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateAdjacentToRiver(direction, cell, center, e); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeFan(center, e, cell.Color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei dieser Methode f√ºllen wir das Zellendreieck mit einem Streifen und einem F√§cher. </font><font style="vertical-align: inherit;">Nur ein Ventilator wird uns nicht ausreichen, da die Gipfel dem mittleren Rand der Teile entsprechen sollten, die den Fluss enthalten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) ); TriangulateEdgeStrip(m, cell.Color, e, cell.Color); TriangulateEdgeFan(center, m, cell.Color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/059/4df/7bb/0594df7bb3225d20852c9e0d0d708101.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberlagerung in Kurven und geraden Fl√ºssen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Passen Sie den Kanal an </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich m√ºssen wir das Zentrum, das wir verwenden, an den zentralen Teil anpassen, der von den Flussteilen verwendet wird. </font><font style="vertical-align: inherit;">Mit Zickzack ist alles in Ordnung und Kurven und gerade Fl√ºsse erfordern Aufmerksamkeit. </font><font style="vertical-align: inherit;">Daher m√ºssen wir sowohl den Flusstyp als auch seine relative Ausrichtung bestimmen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit der √úberpr√ºfung, ob wir uns innerhalb der Kurve befinden. </font><font style="vertical-align: inherit;">In diesem Fall enthalten sowohl die vorherige als auch die n√§chste Richtung den Fluss. </font><font style="vertical-align: inherit;">Wenn ja, m√ºssen wir die Mitte an den Rand verschieben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { center += HexMetrics.GetSolidEdgeMiddle(direction) * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } } EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/016/620/d89/016620d89847368d487d49bb1c81cdc7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wurde ein Fall behoben, in dem der Fluss von beiden Seiten flie√üt. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir einen Fluss in eine andere Richtung haben, aber nicht in die vorherige, pr√ºfen wir, ob er gerade ist. </font><font style="vertical-align: inherit;">Wenn ja, verschieben Sie die Mitte in die erste Ecke.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { center += HexMetrics.GetSolidEdgeMiddle(direction) * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( cell.HasRiverThroughEdge(direction.Previous2()) ) { center += HexMetrics.GetFirstSolidCorner(direction) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1d/85a/366/a1d85a3669a55984eb69a43af5e8631f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feste halbe √úberlagerung mit einem geraden Fluss. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also haben wir das Problem mit der H√§lfte der Teile gel√∂st, die an die geraden Fl√ºsse angrenzen. </font><font style="vertical-align: inherit;">Der letzte Fall - wir haben einen Fluss in der vorherigen Richtung und er ist gerade. </font><font style="vertical-align: inherit;">In diesem Fall m√ºssen Sie die Mitte in die n√§chste Ecke verschieben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { center += HexMetrics.GetSolidEdgeMiddle(direction) * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( cell.HasRiverThroughEdge(direction.Previous2()) ) { center += HexMetrics.GetFirstSolidCorner(direction) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( cell.HasRiverThroughEdge(direction.Previous()) &amp;&amp; cell.HasRiverThroughEdge(direction.Next2()) ) { center += HexMetrics.GetSecondSolidCorner(direction) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c9d/d1a/20c/c9dd1a20c213658aeed27b9065e6bf58.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keine √úberlagerungen mehr. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HexMesh-Generalisierung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben die Triangulation der Kan√§le abgeschlossen. </font><font style="vertical-align: inherit;">Jetzt k√∂nnen wir sie mit Wasser f√ºllen. </font><font style="vertical-align: inherit;">Da sich Wasser von Land unterscheidet, m√ºssen wir ein anderes Netz mit unterschiedlichen Scheitelpunktdaten und unterschiedlichem Material verwenden. </font><font style="vertical-align: inherit;">Es w√§re sehr praktisch, wenn wir </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sowohl Sushi als auch Wasser verwenden </font><font style="vertical-align: inherit;">k√∂nnten </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Verallgemeinern wir es also, </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indem </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">es in eine Klasse verwandeln, die sich mit diesen Netzen befasst, unabh√§ngig davon, wof√ºr es verwendet wird. </font><font style="vertical-align: inherit;">Wir werden die Aufgabe der Triangulation seiner Zellen weitergeben </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschieben der St√∂rungsmethode </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Methode </font></font><code>Perturb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ziemlich verallgemeinert ist und an verschiedenen Stellen verwendet wird, verschieben wir sie auf </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Benennen Sie es zun√§chst in um </font></font><code>HexMetrics.Perturb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist ein falscher Methodenname, der jedoch den gesamten Code f√ºr die ordnungsgem√§√üe Verwendung umgestaltet. </font><font style="vertical-align: inherit;">Wenn Ihr Code-Editor √ºber spezielle Funktionen zum Verschieben von Methoden verf√ºgt, verwenden Sie diese. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie die Methode nach innen verschieben </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, machen Sie sie allgemein und statisch und korrigieren Sie dann ihren Namen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = SampleNoise(position); position.x += (sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * cellPerturbStrength; position.z += (sample.z * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * cellPerturbStrength; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulationsmethoden verschieben </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der √Ñnderung von Variablen </font></font><code>hexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in den gemeinsamen Variablen </font></font><code>terrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain; <span class="hljs-comment"><span class="hljs-comment">// HexMesh hexMesh; void Awake () { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); // hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cells = new HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; ShowUI(false); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als n√§chstes √ºberarbeiten wir alle Methoden </font></font><code>Add‚Ä¶</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>terrain.Add‚Ä¶</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Verschieben Sie dann alle Methoden </font></font><code>Triangulate‚Ä¶</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Danach k√∂nnen Sie die Namen der Methoden </font></font><code>Add‚Ä¶</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font><font style="vertical-align: inherit;">korrigieren </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und allgemein machen. </font><font style="vertical-align: inherit;">Infolgedessen werden alle komplexen Triangulationsmethoden gefunden </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und einfache Methoden zum Hinzuf√ºgen von Daten zum Netz bleiben erhalten </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sind noch nicht fertig. </font><font style="vertical-align: inherit;">Jetzt </font></font><code>HexGridChunk.LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte es seine eigene Methode aufrufen </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Au√üerdem sollte es keine Zellen mehr als Argument √ºbergeben. </font><font style="vertical-align: inherit;">Daher kann es </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seinen Parameter verlieren. </font><font style="vertical-align: inherit;">Und er muss die Reinigung und Anwendung der Netzdaten delegieren </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Triangulate(); <span class="hljs-comment"><span class="hljs-comment">// hexMesh.Triangulate(cells); enabled = false; } public void Triangulate () { terrain.Clear(); // hexMesh.Clear(); // vertices.Clear(); // colors.Clear(); // triangles.Clear(); for (int i = 0; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); // hexMesh.vertices = vertices.ToArray(); // hexMesh.colors = colors.ToArray(); // hexMesh.triangles = triangles.ToArray(); // hexMesh.RecalculateNormals(); // meshCollider.sharedMesh = hexMesh; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie </font><font style="vertical-align: inherit;">die erforderlichen Methoden </font></font><code>Clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>Apply</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices.Clear(); colors.Clear(); triangles.Clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); hexMesh.SetColors(colors); hexMesh.SetTriangles(triangles, <span class="hljs-number"><span class="hljs-number">0</span></span>); hexMesh.RecalculateNormals(); meshCollider.sharedMesh = hexMesh; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist mit SetVertices, SetColors und SetTriangles?</font></font></b> <div class="spoiler_text">        <code>Mesh</code> .        .  ,           . <br><br>  <code>SetTriangles</code>    integer,    .      ,    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Schluss h√§ngen Sie das untergeordnete Element des Netzes manuell an das Fragment-Fertighaus an. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies nicht mehr automatisch tun, da wir dem Netz bald ein zweites Kind hinzuf√ºgen werden. </font><font style="vertical-align: inherit;">Benennen Sie es in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um, um seinen Zweck anzugeben.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/614/3b4/0dc/6143b40dc88ecec6761348d9e6208944.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weisen Sie eine Erleichterung zu.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Umbenennen eines Fertighauses funktioniert nicht?</font></font></b> <div class="spoiler_text">          .    ,   .  ,     <em>Apply</em> ,       .        . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Listenpools erstellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir ziemlich viel Code verschoben haben, sollte unsere Karte immer noch genauso funktionieren wie zuvor. </font><font style="vertical-align: inherit;">Das Hinzuf√ºgen eines weiteren Netzes zum Fragment √§ndert dies nicht. </font><font style="vertical-align: inherit;">Wenn wir dies jedoch mit der Gegenwart tun </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, k√∂nnen Fehler auftreten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem ist, dass wir davon ausgegangen sind, dass wir jeweils nur mit einem Netz arbeiten w√ºrden. </font><font style="vertical-align: inherit;">Dies erm√∂glichte es uns, statische Listen zum Speichern tempor√§rer Netzdaten zu verwenden. </font><font style="vertical-align: inherit;">Nach dem Hinzuf√ºgen von Wasser arbeiten wir jedoch gleichzeitig mit zwei Maschen, sodass wir keine statischen Listen mehr verwenden k√∂nnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden jedoch nicht f√ºr jede Instanz zu den Listens√§tzen zur√ºckkehren </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Stattdessen verwenden wir einen statischen Listenpool. </font><font style="vertical-align: inherit;">Standardm√§√üig ist dieses Pooling nicht vorhanden. Beginnen wir also damit, selbst eine gemeinsame Listenpoolklasse zu erstellen.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListPool</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie funktioniert ListPool &lt;T&gt;?</font></font></b> <div class="spoiler_text">     ,  <code>List&lt;int&gt;</code>    .  <code>&lt;T&gt;</code>    <code>ListPool</code> ,  ,    .      ,    <code>T</code> (  template). </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um eine Sammlung von Listen in einem Pool zu speichern, k√∂nnen wir den Stapel verwenden. </font><font style="vertical-align: inherit;">Normalerweise verwende ich keine Listen, da Unity sie nicht serialisiert, aber in diesem Fall spielt es keine Rolle.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListPool</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Stack&lt;List&lt;T&gt;&gt; stack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stack&lt;List&lt;T&gt;&gt;(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was bedeutet Stapel &lt;Liste &lt;t&gt;&gt;?</font></font></b> <div class="spoiler_text">     .  ,     .      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie eine allgemeine statische Methode hinzu, um die Liste aus dem Pool abzurufen. </font><font style="vertical-align: inherit;">Wenn der Stapel nicht leer ist, extrahieren wir die Top-Liste und geben diese zur√ºck. </font><font style="vertical-align: inherit;">Andernfalls erstellen wir eine neue Liste.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stack.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stack.Pop(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;T&gt;(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Listen wiederzuverwenden, m√ºssen Sie sie dem Pool hinzuf√ºgen, nachdem Sie mit ihnen gearbeitet haben. </font></font><code>ListPool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l√∂scht die Liste und schiebt sie auf den Stapel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;T&gt; list</span></span></span><span class="hljs-function">)</span></span> { list.Clear(); stack.Push(list); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir die Pools in nutzen </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ersetzen Sie statische Listen durch nicht statische private Links. </font><font style="vertical-align: inherit;">Markieren wir sie </font></font><code>NonSerialized</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass Unity sie beim Neukompilieren nicht beibeh√§lt. </font><font style="vertical-align: inherit;">Oder schreiben </font></font><code>System.NonSerialized</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>using System;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">am Anfang des Skripts </font><font style="vertical-align: inherit;">hinzuf√ºgen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">NonSerialized</span></span>] List&lt;Vector3&gt; vertices; [NonSerialized] List&lt;Color&gt; colors; [NonSerialized] List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; triangles; <span class="hljs-comment"><span class="hljs-comment">// static List&lt;Vector3&gt; vertices = new List&lt;Vector3&gt;(); // static List&lt;Color&gt; colors = new List&lt;Color&gt;(); // static List&lt;int&gt; triangles = new List&lt;int&gt;();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da das Netz unmittelbar vor dem Hinzuf√ºgen neuer Daten bereinigt wird, m√ºssen Sie hier Listen aus Pools abrufen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); colors = ListPool&lt;Color&gt;.Get(); triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem wir diese Netze angewendet haben, brauchen wir sie nicht mehr, sodass wir sie hier zu den Pools hinzuf√ºgen k√∂nnen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); hexMesh.SetColors(colors); ListPool&lt;Color&gt;.Add(colors); hexMesh.SetTriangles(triangles, <span class="hljs-number"><span class="hljs-number">0</span></span>); ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Add(triangles); hexMesh.RecalculateNormals(); meshCollider.sharedMesh = hexMesh; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Daher haben wir Listen mehrfach verwendet, unabh√§ngig davon, wie viele Netze wir gleichzeitig f√ºllen. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optionaler Collider </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl unser Gel√§nde einen Collider ben√∂tigt, wird er f√ºr Fl√ºsse nicht wirklich ben√∂tigt. </font><font style="vertical-align: inherit;">Die Strahlen passieren einfach das Wasser und schneiden sich mit dem darunter liegenden Kanal. </font><font style="vertical-align: inherit;">Machen wir es so, dass wir das Vorhandensein eines Colliders f√ºr konfigurieren k√∂nnen </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir erkennen dies, indem wir ein gemeinsames Feld hinzuf√ºgen </font></font><code>bool useCollider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">F√ºr das Gel√§nde schalten wir es ein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e7/f19/a3c/4e7f19a3c7eb01a1432618a8be6903e5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden eines Mesh-Colliders. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Collider muss erst erstellt und zugewiesen werden, wenn er aktiviert ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCollider) { meshCollider = gameObject.AddComponent&lt;MeshCollider&gt;(); } hexMesh.name = <span class="hljs-string"><span class="hljs-string">"Hex Mesh"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCollider) { meshCollider.sharedMesh = hexMesh; } ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optionale Farben </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scheitelpunktfarben k√∂nnen auch optional sein. </font><font style="vertical-align: inherit;">Wir brauchen sie, um verschiedene Arten von Reliefs zu demonstrieren, aber Wasser √§ndert seine Farbe nicht. </font><font style="vertical-align: inherit;">Wir k√∂nnen sie optional machen, genauso wie wir den Collider optional gemacht haben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { colors = ListPool&lt;Color&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { hexMesh.SetColors(colors); ListPool&lt;Color&gt;.Add(colors); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nat√ºrlich sollte das Gel√§nde die Farben der Eckpunkte verwenden, also schalten Sie sie ein. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/624/c01/bbd/624c01bbda8ad0250747b9c1af852590.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwendung von Farben.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optionales UV </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hrenddessen k√∂nnen wir auch Unterst√ºtzung f√ºr optionale UV-Koordinaten hinzuf√ºgen. </font><font style="vertical-align: inherit;">Obwohl das Relief sie nicht benutzt, werden wir sie f√ºr Wasser brauchen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors, useUVCoordinates; [NonSerialized] List&lt;Vector2&gt; uvs; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { colors = ListPool&lt;Color&gt;.Get(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { uvs = ListPool&lt;Vector2&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { hexMesh.SetColors(colors); ListPool&lt;Color&gt;.Add(colors); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">0</span></span>, uvs); ListPool&lt;Vector2&gt;.Add(uvs); } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b01/a99/559/b01a9955989cdc83a2e8de2582c1cbeb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden keine UV-Koordinaten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um diese Funktion zu verwenden, erstellen Sie Methoden zum Hinzuf√ºgen von UV-Koordinaten zu Dreiecken und Vierecken.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleUV</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3</span></span></span><span class="hljs-function">)</span></span> { uvs.Add(uv1); uvs.Add(uv2); uvs.Add(uv3); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3, Vector3 uv4</span></span></span><span class="hljs-function">)</span></span> { uvs.Add(uv1); uvs.Add(uv2); uvs.Add(uv3); uvs.Add(uv4); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen wir eine zus√§tzliche Methode hinzu, </font></font><code>AddQuadUV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um bequem einen rechteckigen UV-Bereich hinzuzuf√ºgen. </font><font style="vertical-align: inherit;">Dies ist der Standardfall, wenn das Quad und seine Textur gleich sind. Wir werden es f√ºr das Wasser des Flusses verwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMax, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMax</span></span></span><span class="hljs-function">)</span></span> { uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMin)); uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMin)); uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMax)); uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMax)); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aktuelle Fl√ºsse </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endlich ist es Zeit, Wasser zu schaffen! </font><font style="vertical-align: inherit;">Wir werden dies mit einem Quad tun, das die Wasseroberfl√§che anzeigt. </font><font style="vertical-align: inherit;">Und da wir mit Fl√ºssen arbeiten, muss Wasser flie√üen. </font><font style="vertical-align: inherit;">Dazu verwenden wir UV-Koordinaten, die die Ausrichtung des Flusses angeben. </font><font style="vertical-align: inherit;">Um dies zu visualisieren, ben√∂tigen wir einen neuen Shader. </font><font style="vertical-align: inherit;">Erstellen Sie daher einen neuen Standard-Shader und nennen Sie ihn </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">√Ñndern Sie es so, dass die UV-Koordinaten in den gr√ºnen und roten Albedokan√§len aufgezeichnet werden.</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/River" { ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemeinen Feld hinzuf√ºgen </font></font><code>HexMesh rivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir reinigen es und wenden es auf die gleiche Weise an wie im Falle einer Erleichterung.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Werden wir zus√§tzliche Draw Calls haben, auch wenn wir keine Fl√ºsse haben?</font></font></b> <div class="spoiler_text">  Unity  ,        .     ,  -  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie das Fertighaus (√ºber die Instanz), duplizieren Sie das Gel√§ndeobjekt, benennen Sie es in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fl√ºsse um</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und verbinden Sie es.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efd/0d6/680/efd0d66801d78d636d07f59b34e5c615.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e46/119/b43/e46119b43f4cd398d96261715975a36a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertighausfragment mit Fl√ºssen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Material </font><font style="vertical-align: inherit;">mit unserem neuen Shader und lassen Sie das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekt es verwenden </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir haben auch die Sechsecknetzkomponente des Objekts so eingerichtet, dass UV-Koordinaten verwendet werden, jedoch keine Scheitelpunktfarben oder der Kollider.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7df/db6/134/7dfdb6134b4dc27d843db92492b61708.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterobjekt Fl√ºsse.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wasser triangulieren </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir Wasser triangulieren k√∂nnen, m√ºssen wir den Pegel seiner Oberfl√§che bestimmen. </font><font style="vertical-align: inherit;">Machen </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">eine H√∂henverschiebung </font><font style="vertical-align: inherit;">, wie wir es mit dem Flussbett gemacht haben. </font><font style="vertical-align: inherit;">Da die vertikale Verzerrung der Zelle gleich der H√§lfte der H√∂henverschiebung ist, verwenden wir sie, um die Oberfl√§che des Flusses zu verschieben. </font><font style="vertical-align: inherit;">Wir garantieren also, dass sich das Wasser niemals √ºber der Topographie der Zelle befindet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> riverSurfaceElevationOffset = <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum nicht etwas niedriger machen?</font></font></b> <div class="spoiler_text">          ,   . ,         . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie eine </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft hinzu, um die vertikale Position der Oberfl√§che des Flusses zu ermitteln.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> RiverSurfaceY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (elevation + HexMetrics.riverSurfaceElevationOffset) * HexMetrics.elevationStep; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir arbeiten </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font><font style="vertical-align: inherit;">Da wir viele Flussvierecke erstellen werden, f√ºgen wir hierf√ºr eine separate Methode hinzu. </font><font style="vertical-align: inherit;">Geben wir ihm vier Eckpunkte und eine H√∂he als Parameter. </font><font style="vertical-align: inherit;">Auf diese Weise k√∂nnen wir bequem die vertikale Position aller vier Scheitelpunkte gleichzeitig einstellen, bevor wir Quad hinzuf√ºgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = v3.y = v4.y = y; rivers.AddQuad(v1, v2, v3, v4); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden hier die UV-Koordinaten des Vierecks hinzuf√ºgen. </font><font style="vertical-align: inherit;">Gehen Sie einfach von links nach rechts und von unten nach oben.</font></font><br><br><pre> <code class="cs hljs"> rivers.AddQuad(v1, v2, v3, v4); rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br> <code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Dies ist die erste Methode, zu der wir die Vierecke der Fl√ºsse hinzuf√ºgen. </font><font style="vertical-align: inherit;">Das erste Quad befindet sich zwischen der Mitte und der Mitte. </font><font style="vertical-align: inherit;">Der zweite ist zwischen der Mitte und der Rippe. </font><font style="vertical-align: inherit;">Wir verwenden nur die Eckpunkte, die wir bereits haben. </font><font style="vertical-align: inherit;">Da diese Spitzen untersch√§tzt werden, befindet sich das Wasser infolgedessen teilweise unter den geneigten W√§nden des Kanals. </font><font style="vertical-align: inherit;">Daher m√ºssen wir uns nicht um die genaue Position des Wasserrands k√ºmmern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ TriangulateRiverQuad(centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY); TriangulateRiverQuad(m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/418/a40/e9c/418a40e9c73fd3da885ce467e475ff63.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die ersten Anzeichen von Wasser. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum √§ndert sich die Breite des Wassers?</font></font></b> <div class="spoiler_text">  ,     ,      ‚Äî .           .      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mit dem Fluss bewegen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Derzeit stimmen die UV-Koordinaten nicht mit der Flussrichtung √ºberein. </font><font style="vertical-align: inherit;">Wir m√ºssen hier die Konsistenz wahren. </font><font style="vertical-align: inherit;">Angenommen, die U-Koordinate ist 0 auf der linken Seite des Flusses und 1 auf der rechten Seite, wenn Sie stromabw√§rts schauen. </font><font style="vertical-align: inherit;">Und die V-Koordinate sollte in Flussrichtung von 0 bis 1 variieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unter Verwendung dieser Spezifikation sind UVs korrekt, wenn der ausgehende Fluss trianguliert wird, aber sie stellen sich als falsch heraus und m√ºssen umgedreht werden, wenn der eingehende Fluss trianguliert wird. </font><font style="vertical-align: inherit;">F√ºgen Sie den </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter </font><font style="vertical-align: inherit;">hinzu, um die Arbeit zu vereinfachen </font></font><code>bool reversed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Verwenden Sie es, um UV bei Bedarf umzudrehen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = v3.y = v4.y = y; rivers.AddQuad(v1, v2, v3, v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir wissen , </font><font style="vertical-align: inherit;">dass wir die Richtung drehen m√ºssen, wenn sie </font><font style="vertical-align: inherit;">mit eingehendem Fluss geht.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.IncomingRiver == direction; TriangulateRiverQuad( centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY, reversed ); TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, reversed );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/546/c86/e9d/546c86e9d2d8752caa30523098283542.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die vereinbarte Richtung der Fl√ºsse.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Anfang und das Ende des Flusses </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Inneren m√ºssen </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir nur pr√ºfen, ob wir einen ankommenden Fluss haben, um die Richtung des Flusses zu bestimmen. </font><font style="vertical-align: inherit;">Dann k√∂nnen wir einen weiteren Quad River zwischen der Mitte und der Rippe einf√ºgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.HasIncomingRiver; TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, reversed ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Teil zwischen der Mitte und der Mitte ist ein Dreieck, daher k√∂nnen wir ihn nicht verwenden </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der einzige signifikante Unterschied besteht darin, dass sich der zentrale Gipfel in der Mitte des Flusses befindet. </font><font style="vertical-align: inherit;">Daher ist seine Koordinate U immer gleich ¬Ω.</font></font><br><br><pre> <code class="cs hljs"> center.y = m.v2.y = m.v4.y = cell.RiverSurfaceY; rivers.AddTriangle(center, m.v2, m.v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c04/07f/539/c0407f539ce2ff6a91081e84062a4097.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasser am Anfang und am Ende.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehlen an den Enden Teile des Wassers?</font></font></b> <div class="spoiler_text">       ,   quad  ,     .           .           . <br><br>      ,  .     ,      .      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fluss zwischen Zellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Hinzuf√ºgen von Wasser zwischen den Zellen m√ºssen wir auf den H√∂henunterschied achten. </font><font style="vertical-align: inherit;">Damit Wasser H√§nge und Klippen hinunterflie√üen kann, </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss es zwei H√∂henparameter unterst√ºtzen. </font><font style="vertical-align: inherit;">F√ºgen wir also einen zweiten hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = y1; v3.y = v4.y = y2; rivers.AddQuad(v1, v2, v3, v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie der Einfachheit halber eine Option hinzu, die eine H√∂he erh√§lt. </font><font style="vertical-align: inherit;">Es wird nur eine andere Methode aufgerufen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { TriangulateRiverQuad(v1, v2, v3, v4, y, y, reversed); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir Quad River und In hinzuf√ºgen </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da wir uns zwischen den Zellen befinden, k√∂nnen wir nicht sofort herausfinden, um welche Art von Fluss es sich handelt. </font><font style="vertical-align: inherit;">Um festzustellen, ob eine Abbiegung erforderlich ist, m√ºssen wir pr√ºfen, ob ein Fluss ankommt und ob er sich in unsere Richtung bewegt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e2.v3.y = neighbor.StreamBedY; TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/283/1f2/62e/2831f262ed46e82bebabf45d0a8215f2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der fertiggestellte Fluss.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dehnung der V-Koordinate </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher haben wir in jedem Flusssegment V-Koordinaten von 0 bis 1. Das hei√üt, es gibt nur vier davon in der Zelle. F√ºnf, wenn wir auch Verbindungen zwischen Zellen hinzuf√ºgen. Was auch immer wir verwenden, um den Fluss zu texturieren, es muss genauso oft wiederholt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen die Anzahl der Wiederholungen reduzieren, indem wir die V-Koordinaten so strecken, dass sie in der gesamten Zelle plus einer Verbindung von 0 auf 1 gehen. Dies kann durch Erh√∂hen der V-Koordinate in jedem Segment um 0,2 erfolgen. Wenn wir 0,4 in die Mitte setzen, wird es in der Mitte 0,6 und am Rand 0,8. In der Zellenverbindung ist der Wert dann 1.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Fluss in die entgegengesetzte Richtung flie√üt, k√∂nnen wir immer noch 0,4 in die Mitte setzen, aber in der Mitte wird es 0,2 und am Rand - 0. Wenn wir so weitermachen, bis sich die Zelle verbindet, ist das Ergebnis -0,2. </font><font style="vertical-align: inherit;">Dies ist normal, da es f√ºr eine Textur mit Wiederholungsfilterungsmodus √§hnlich wie 0,8 ist, genauso wie 0 gleich 1 ist.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22e/4de/cd9/22e4decd99e9c2f0c9312be9eaaceb9a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñnderung der Koordinaten V.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um dies zu unterst√ºtzen, m√ºssen wir </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen weiteren Parameter </font><font style="vertical-align: inherit;">hinzuf√ºgen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { TriangulateRiverQuad(v1, v2, v3, v4, y, y, v, reversed); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn die Richtung nicht umgekehrt wird, verwenden wir einfach die √ºbertragene Koordinate am unteren Rand des Vierecks und addieren am oberen Rand 0,2. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, v, v + <span class="hljs-number"><span class="hljs-number">0.2f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir k√∂nnen mit einer umgekehrten Richtung arbeiten, indem wir die Koordinaten von 0,8 und 0,6 subtrahieren. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span> - v, <span class="hljs-number"><span class="hljs-number">0.6f</span></span> - v); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt m√ºssen wir die richtigen Koordinaten √ºbertragen, als h√§tten wir es mit einem abgehenden Fluss zu tun. </font><font style="vertical-align: inherit;">Beginnen wir mit </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> TriangulateRiverQuad( centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, reversed ); TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√§ndert sich </font><font style="vertical-align: inherit;">wie folgt.</font></font><br><br><pre> <code class="cs hljs"> TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und schlie√ülich </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed ); center.y = m.v2.y = m.v4.y = cell.RiverSurfaceY; rivers.AddTriangle(center, m.v2, m.v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44e/786/63f/44e78663f2d77264660f30917a5e1a94.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gestreckte V-Koordinaten</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um die Faltung der V-Koordinaten korrekt anzuzeigen, stellen Sie sicher, dass sie im River Shader positiv bleiben.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y += <span class="hljs-number"><span class="hljs-number">1</span></span>; } o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aec/30e/a84/aec30ea849af0c8ba42cd6e0cef44635.png"></div><br> <i><font style="vertical-align: inherit;"></font></i> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Reduzierte </font></a><i><font style="vertical-align: inherit;">Koordinaten V. </font></i></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flussanimation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir mit den UV-Koordinaten fertig sind, k√∂nnen wir mit der Animation der Fl√ºsse fortfahren. Der River Shader wird dies tun, damit wir das Netz nicht st√§ndig aktualisieren m√ºssen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden in diesem Tutorial keinen komplexen River Shader erstellen, aber sp√§ter. Im Moment erstellen wir einen einfachen Effekt, der ein Verst√§ndnis der Funktionsweise von Animationen vermittelt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Animation wird durch Verschieben der V-Koordinaten basierend auf der Spielzeit erstellt. Mit Unity k√∂nnen Sie den Wert mithilfe einer Variablen ermitteln </font></font><code>_Time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Seine Komponente Y enth√§lt die unver√§nderte Zeit, die wir verwenden. Andere Komponenten enthalten andere Zeitskalen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden die Faltung entlang V loswerden, weil wir sie nicht mehr brauchen. Stattdessen subtrahieren wir die aktuelle Zeit von der V-Koordinate. Dadurch wird die Koordinate nach unten verschoben, wodurch die Illusion entsteht, dass der Strom stromabw√§rts des Flusses flie√üt.</font></font><br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { // <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y += <span class="hljs-number"><span class="hljs-number">1</span></span>; // } <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y -= _Time.y; o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In einer Sekunde wird die V-Koordinate an allen Punkten kleiner als Null, sodass wir den Unterschied nicht mehr sehen. </font><font style="vertical-align: inherit;">Dies ist wiederum normal, wenn die Filterung im Texturwiederholungsmodus verwendet wird. </font><font style="vertical-align: inherit;">Aber um zu sehen, was passiert, k√∂nnen wir den Bruchteil der V-Koordinate nehmen.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y -= _Time.y; <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y = frac(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y); o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animierte V-Koordinaten.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L√§rmgebrauch </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt ist unser Fluss animiert, aber in Richtung und Geschwindigkeit gibt es scharfe √úberg√§nge. </font><font style="vertical-align: inherit;">Unser UV-Muster macht sie ziemlich offensichtlich, aber es ist schwieriger zu erkennen, wenn Sie ein wasser√§hnlicheres Muster verwenden. </font><font style="vertical-align: inherit;">Anstatt rohes UV-Licht anzuzeigen, probieren wir die Textur aus. </font><font style="vertical-align: inherit;">Wir k√∂nnen unsere vorhandene Rauschstruktur verwenden. </font><font style="vertical-align: inherit;">Wir probieren es aus und multiplizieren die Farbe des Materials mit dem ersten Rauschkanal.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv.y -= _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, uv); fixed4 c = _Color * noise.r; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Weisen Sie dem Flussmaterial die Ger√§uschstruktur zu und stellen Sie sicher, dass es wei√ü ist. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc8/dd4/e4e/dc8dd4e4ee9b92f2f104ba3107da30ce.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3f/0ca/319/b3f0ca31928fd594a715868ebbb7265c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rauschtextur verwenden. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die V-Koordinaten sehr gestreckt sind, erstreckt sich die Rauschstruktur auch entlang des Flusses. </font><font style="vertical-align: inherit;">Leider ist der Kurs nicht sehr sch√∂n. </font><font style="vertical-align: inherit;">Lassen Sie uns versuchen, es auf eine andere Weise zu dehnen - die Skalierung der Koordinaten von U stark zu reduzieren. Ein Sechzehntel wird ausreichen. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir nur ein schmales Band von Rauschtexturen abtasten.</font></font><br><br><pre> <code class="hljs pgsql"> float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv.x *= <span class="hljs-number"><span class="hljs-number">0.0625</span></span>; uv.y -= _Time.y;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa9/957/2a9/aa99572a9c0ad3daaa7b5b4eb3978cc0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dehnen der U-Koordinate.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lassen Sie uns auch auf ein Viertel pro Sekunde verlangsamen, damit der Abschluss des Texturzyklus vier Sekunden dauert.</font></font><br><br><pre> <code class="hljs"> uv.y -= _Time.y * 0.25;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das aktuelle Rauschen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rauschmischung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles sieht schon viel besser aus, aber das Muster bleibt immer das gleiche. Wasser verh√§lt sich nicht so. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir nur ein kleines Rauschband verwenden, k√∂nnen wir das Muster variieren, indem wir dieses Band entlang der Textur verschieben. Dies erfolgt durch Hinzuf√ºgen von Zeit zur U-Koordinate. Wir m√ºssen es langsam machen, sonst scheint der Fluss seitw√§rts zu flie√üen. Versuchen wir den Koeffizienten von 0,005. Dies bedeutet, dass es 200 Sekunden dauert, um das Muster fertigzustellen.</font></font><br><br><pre> <code class="hljs markdown"> uv.x = uv.x <span class="hljs-bullet"><span class="hljs-bullet">* 0.0625 + _Time.y *</span></span> 0.005;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bewegliches Ger√§usch. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das sieht leider nicht sehr sch√∂n aus. </font><font style="vertical-align: inherit;">Wasser scheint immer noch statisch und die Verschiebung ist deutlich sp√ºrbar, obwohl es sehr langsam ist. </font><font style="vertical-align: inherit;">Wir k√∂nnen die Verschiebung verbergen, indem wir zwei Rauschproben kombinieren und sie in entgegengesetzte Richtungen verschieben. </font><font style="vertical-align: inherit;">Wenn wir zum Verschieben des zweiten Samples leicht unterschiedliche Werte verwenden, erstellen wir eine leichte Animation der √Ñnderung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit wir niemals dasselbe Rauschmuster √ºberlappen, verwenden wir f√ºr das zweite Sample einen anderen Kanal.</font></font><br><br><pre> <code class="hljs pgsql"> float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv.x = uv.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> + _Time.y * <span class="hljs-number"><span class="hljs-number">0.005</span></span>; uv.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, uv); float2 uv2 = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv2.x = uv2.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> - _Time.y * <span class="hljs-number"><span class="hljs-number">0.0052</span></span>; uv2.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.23</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise2 = tex2D(_MainTex, uv2); fixed4 c = _Color * (noise.r * noise2.a);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Kombination aus zwei sich verschiebenden Ger√§uschmustern.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durchscheinendes Wasser </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser Muster sieht sehr dynamisch aus. </font><font style="vertical-align: inherit;">Der n√§chste Schritt besteht darin, es durchscheinend zu machen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie zun√§chst sicher, dass das Wasser keine Schatten wirft. </font><font style="vertical-align: inherit;">Sie k√∂nnen sie √ºber die Renderer-Komponente des </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekts </font><font style="vertical-align: inherit;">im Fertighaus deaktivieren.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a61/894/e14/a61894e14d9999315d59b5ff0c0de517.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schattenwurf ist deaktiviert. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schalten Sie nun den Shader in den transparenten Modus. </font><font style="vertical-align: inherit;">Verwenden Sie dazu Shader-Tags. </font><font style="vertical-align: inherit;">F√ºgen Sie dann das </font></font><code>#pragma surface</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schl√ºsselwort </font><font style="vertical-align: inherit;">zur Zeile hinzu </font></font><code>alpha</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">W√§hrend wir hier sind, k√∂nnen Sie das Schl√ºsselwort entfernen </font></font><code>fullforwardshadows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da wir immer noch keine Schatten werfen.</font></font><br><br><pre> <code class="hljs cs"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Standard alpha // fullforwardshadows #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> target 3.0</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt werden wir die Art und Weise √§ndern, wie wir die Farbe des Flusses einstellen. </font><font style="vertical-align: inherit;">Anstatt Rauschen mit Farbe zu multiplizieren, f√ºgen wir Rauschen hinzu. </font><font style="vertical-align: inherit;">Dann verwenden wir die Funktion </font></font><code>saturate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um das Ergebnis so zu begrenzen, dass es 1 nicht √ºberschreitet.</font></font><br><br><pre> <code class="hljs swift"> fixed4 <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = saturate(_Color + noise.r * noise2.a);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dadurch k√∂nnen wir die Materialfarbe als Grundfarbe verwenden. </font><font style="vertical-align: inherit;">Rauschen erh√∂ht die Helligkeit und Deckkraft. </font><font style="vertical-align: inherit;">Versuchen wir, eine blaue Farbe mit einer relativ geringen Deckkraft zu verwenden. </font><font style="vertical-align: inherit;">Als Ergebnis erhalten wir blaues durchscheinendes Wasser mit wei√üen Spritzern.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af8/3f7/5a1/af83f75a143aabdd3b83525e4114fc3b.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Farbiges durchscheinendes Wasser. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fertigstellung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt, da alles zu funktionieren scheint, ist es Zeit, die Spitzen wieder zu verzerren. </font><font style="vertical-align: inherit;">Dies verformt nicht nur die R√§nder der Zellen, sondern macht unsere Fl√ºsse auch uneben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c8/ff5/96b/8c8ff596bc247be79a30122e49ca27f5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ca/664/808/6ca66480859e94d00e2e558caa17cbf4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verzerrte und verzerrte Spitzen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untersuchen wir das Gel√§nde auf Probleme, die durch Verzerrungen entstanden sind. </font><font style="vertical-align: inherit;">Sieht aus wie sie sind! </font><font style="vertical-align: inherit;">Schauen wir uns die hohen Wasserf√§lle an.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df1/95b/a33/df195ba33947744e97173412373f5ad4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasser von Klippen abgeschnitten.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wasser, das von einem hohen Wasserfall f√§llt, verschwindet hinter einer Klippe. Wenn dies passiert, ist es sehr auff√§llig, also m√ºssen wir etwas dagegen tun. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viel weniger offensichtlich ist, dass die Wasserf√§lle abfallen k√∂nnen, anstatt direkt abzusteigen. Obwohl Wasser in Wirklichkeit nicht so flie√üt, f√§llt es nicht besonders auf. Unser Gehirn wird es so interpretieren, dass es uns normal erscheint. Also ignoriere es einfach. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der einfachste Weg, um Wasserverluste zu vermeiden, ist die Vertiefung der Flussbetten. So schaffen wir mehr Platz zwischen der Wasseroberfl√§che und dem Flussbett. Dadurch werden auch die W√§nde des Kanals vertikaler, gehen Sie also nicht zu tief. Fragen wir</font></font><code>HexMetrics.streamBedElevationOffset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert -1,75. </font><font style="vertical-align: inherit;">Dies wird den Gro√üteil der Probleme l√∂sen und das Bett wird nicht zu tief. </font><font style="vertical-align: inherit;">Ein Teil des Wassers wird immer noch abgeschnitten, aber nicht die gesamten Wasserf√§lle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> streamBedElevationOffset = <span class="hljs-number"><span class="hljs-number">-1.75f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/80c/d26/57b80cd2687ff6afb9be83176e984b7d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detaillierte Kan√§le. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 7: Stra√üen </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stra√üenunterst√ºtzung hinzuf√ºgen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulieren Sie die Stra√üe. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir kombinieren Stra√üen und Fl√ºsse. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verbesserung des Erscheinungsbildes von Stra√üen. </font></font></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f7/b24/05e/9f7b2405e5ceed9842cc1ebd7b549b0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die ersten Anzeichen der Zivilisation.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen mit Stra√üen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Fl√ºsse verlaufen Stra√üen von Zelle zu Zelle durch die Mitte der Zellenr√§nder. </font><font style="vertical-align: inherit;">Der gro√üe Unterschied besteht darin, dass auf den Stra√üen kein Wasser flie√üt und sie daher bidirektional sind. </font><font style="vertical-align: inherit;">Dar√ºber hinaus sind Kreuzungen f√ºr ein funktionierendes Stra√üennetz erforderlich, sodass mehr als zwei Stra√üen pro Zelle unterst√ºtzt werden m√ºssen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie zulassen, dass die Stra√üen in alle sechs Richtungen verlaufen, kann die Zelle null bis sechs Stra√üen enthalten. </font><font style="vertical-align: inherit;">Das sind insgesamt vierzehn m√∂gliche Stra√üenkonfigurationen. </font><font style="vertical-align: inherit;">Dies sind viel mehr als f√ºnf m√∂gliche Flusskonfigurationen. </font><font style="vertical-align: inherit;">Um dies zu handhaben, m√ºssen wir einen allgemeineren Ansatz verwenden, der alle Konfigurationen handhaben kann.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d46/965/5b7/d469655b7efdbab33a6cac1c42e61a7e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14 m√∂gliche Stra√üenkonfigurationen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stra√üenverfolgung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der einfachste Weg, Stra√üen in einer Zelle zu verfolgen, besteht darin, ein Array von Booleschen Werten zu verwenden. </font><font style="vertical-align: inherit;">F√ºgen Sie das private Feld des Arrays hinzu </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und machen Sie es serialisierbar, damit Sie es im Inspektor sehen k√∂nnen. </font><font style="vertical-align: inherit;">Stellen Sie die Gr√∂√üe des Arrays √ºber das Zellen-Fertighaus so ein, dass es sechs Stra√üen unterst√ºtzt.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] roads;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/439/167/2c4/4391672c4c1de9075138eef3f1cafd73.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertighaus mit sechs Stra√üen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie eine Methode hinzu, um zu √ºberpr√ºfen, ob die Zelle einen Pfad in eine bestimmte Richtung hat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasRoadThroughEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist auch praktisch zu wissen, ob sich mindestens eine Stra√üe in der Zelle befindet, daher f√ºgen wir hierf√ºr eine Eigenschaft hinzu. </font><font style="vertical-align: inherit;">Gehen Sie einfach um das Array in der Schleife herum und kehren Sie zur√ºck </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sobald wir den Weg gefunden haben. </font><font style="vertical-align: inherit;">Wenn es keine Stra√üen gibt, kehren Sie zur√ºck </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasRoads { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stra√üenentfernung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bei Fl√ºssen werden wir eine Methode hinzuf√ºgen, um alle Stra√üen aus der Zelle zu entfernen. </font><font style="vertical-align: inherit;">Dies kann mit einer Schleife erfolgen, die jede zuvor aktivierte Stra√üe trennt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveRoads</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; neighbors.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { roads[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nat√ºrlich m√ºssen wir auch die entsprechenden teuren Zellen in den Nachbarn deaktivieren. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { roads[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbors[i].roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((HexDirection)i).Opposite()] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danach m√ºssen wir jede der Zellen aktualisieren. </font><font style="vertical-align: inherit;">Da die Stra√üen lokal f√ºr die Zellen sind, m√ºssen wir nur die Zellen selbst ohne ihre Nachbarn aktualisieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { roads[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbors[i].roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((HexDirection)i).Opposite()] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbors[i].RefreshSelfOnly(); RefreshSelfOnly(); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stra√üen hinzuf√ºgen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Hinzuf√ºgen von Stra√üen √§hnelt dem Entfernen von Stra√üen. </font><font style="vertical-align: inherit;">Der einzige Unterschied besteht darin, dass wir Boolean einen Wert zuweisen </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nicht </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir k√∂nnen eine private Methode erstellen, die beide Operationen ausf√ºhren kann. </font><font style="vertical-align: inherit;">Dann wird es m√∂glich sein, die Stra√üe sowohl hinzuzuf√ºgen als auch zu entfernen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveRoads</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; neighbors.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { SetRoad(i, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span> { roads[index] = state; neighbors[index].roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((HexDirection)index).Opposite()] = state; neighbors[index].RefreshSelfOnly(); RefreshSelfOnly(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen nicht gleichzeitig einen Fluss und eine Stra√üe in die gleiche Richtung f√ºhren. </font><font style="vertical-align: inherit;">Daher werden wir vor dem Hinzuf√ºgen der Stra√üe pr√ºfen, ob ein Platz daf√ºr vorhanden ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] &amp;&amp; !HasRiverThroughEdge(direction)) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au√üerdem k√∂nnen Stra√üen nicht mit Klippen kombiniert werden, da sie zu scharf sind. </font><font style="vertical-align: inherit;">Oder lohnt es sich vielleicht, den Weg durch eine niedrige Klippe zu ebnen, aber nicht durch eine hohe? </font><font style="vertical-align: inherit;">Um dies festzustellen, m√ºssen wir eine Methode erstellen, die den H√∂henunterschied in eine bestimmte Richtung angibt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetElevationDifference</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> difference = elevation - GetNeighbor(direction).elevation; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> difference &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ? difference : -difference; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir die Stra√üen in einem ausreichend kleinen H√∂henunterschied hinzuf√ºgen. </font><font style="vertical-align: inherit;">Ich beschr√§nke mich nur auf Pisten, also maximal 1 Einheit.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] &amp;&amp; !HasRiverThroughEdge(direction) &amp;&amp; GetElevationDifference(direction) &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die falschen Stra√üen entfernen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben Stra√üen nur hinzugef√ºgt, wenn dies zul√§ssig ist. </font><font style="vertical-align: inherit;">Jetzt m√ºssen wir sicherstellen, dass sie entfernt werden, wenn sie sp√§ter falsch werden, beispielsweise beim Hinzuf√ºgen eines Flusses. </font><font style="vertical-align: inherit;">Wir k√∂nnen die Platzierung von Fl√ºssen auf Stra√üen verbieten, aber Fl√ºsse werden nicht durch Stra√üen unterbrochen. </font><font style="vertical-align: inherit;">Lassen Sie sie die Stra√üe aus dem Weg waschen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird f√ºr uns ausreichen, nach der Stra√üe zu fragen </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, unabh√§ngig davon, ob die Stra√üe war. </font><font style="vertical-align: inherit;">Es wird immer beide Zellen aktualisiert werden, so dass wir nicht mehr ben√∂tigen , </font><font style="vertical-align: inherit;">um explizit nennt </font></font><code>RefreshSelfOnly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>SetOutgoingRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasOutgoingRiver &amp;&amp; outgoingRiver == direction) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } HexCell neighbor = GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || elevation &lt; neighbor.elevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } RemoveOutgoingRiver(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasIncomingRiver &amp;&amp; incomingRiver == direction) { RemoveIncomingRiver(); } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; outgoingRiver = direction; <span class="hljs-comment"><span class="hljs-comment">// RefreshSelfOnly(); neighbor.RemoveIncomingRiver(); neighbor.hasIncomingRiver = true; neighbor.incomingRiver = direction.Opposite(); // neighbor.RefreshSelfOnly(); SetRoad((int)direction, false); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere Operation, die die Stra√üe falsch machen kann, ist eine √Ñnderung der H√∂he. </font><font style="vertical-align: inherit;">In diesem Fall m√ºssen wir nach Stra√üen in alle Richtungen suchen. </font><font style="vertical-align: inherit;">Wenn der H√∂henunterschied zu gro√ü ist, muss die vorhandene Stra√üe gel√∂scht werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i] &amp;&amp; GetElevationDifference((HexDirection)i) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { SetRoad(i, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } Refresh(); } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stra√üenbearbeitung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Bearbeiten von Stra√üen funktioniert genauso wie das Bearbeiten von Fl√ºssen. </font><font style="vertical-align: inherit;">Daher </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist ein weiterer Schalter sowie eine Methode zum Festlegen des Status erforderlich.</font></font><br><br><pre> <code class="cs hljs"> OptionalToggle riverMode, roadMode; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRiverMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { riverMode = (OptionalToggle)mode; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRoadMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { roadMode = (OptionalToggle)mode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Methode </font></font><code>EditCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte nun das Entfernen durch Hinzuf√ºgen von Stra√üen unterst√ºtzen. </font><font style="vertical-align: inherit;">Dies bedeutet, dass er beim Ziehen und Ablegen eine von zwei m√∂glichen Aktionen ausf√ºhren kann. </font><font style="vertical-align: inherit;">Wir strukturieren den Code ein wenig um, damit bei korrektem Drag &amp; Drop die Zust√§nde beider Schalter √ºberpr√ºft werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.No) { cell.RemoveRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roadMode == OptionalToggle.No) { cell.RemoveRoads(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag) { HexCell otherCell = cell.GetNeighbor(dragDirection.Opposite()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherCell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.Yes) { otherCell.SetOutgoingRiver(dragDirection); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roadMode == OptionalToggle.Yes) { otherCell.AddRoad(dragDirection); } } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen der Benutzeroberfl√§che schnell eine Stra√üenleiste hinzuf√ºgen, indem wir die Flussleiste kopieren und die von den Schaltern aufgerufene Methode √§ndern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Ergebnis erhalten wir eine ziemlich hohe Benutzeroberfl√§che. </font><font style="vertical-align: inherit;">Um dies zu beheben, habe ich das Layout der Farbfelder ge√§ndert, um es an die kompakteren Stra√üen- und Flussfelder anzupassen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fd/de5/a8a/0fdde5a8a4abc86308b771f43b36bf4a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benutzeroberfl√§che mit Stra√üen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da ich jetzt zwei Zeilen mit drei Farboptionen verwende, ist Platz f√ºr eine andere Farbe. </font><font style="vertical-align: inherit;">Also habe ich einen Artikel f√ºr Orange hinzugef√ºgt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a06/9c6/08d/a069c608dfe531a5e1b2a8c59fef5846.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e96/12a/499/e9612a49993e3a2d4cb20790186ecf02.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºnf Farben: Gelb, Gr√ºn, Blau, Orange und Wei√ü. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir die Stra√üen bearbeiten, aber bisher sind sie nicht sichtbar. </font><font style="vertical-align: inherit;">Mit dem Inspektor k√∂nnen Sie sicherstellen, dass alles funktioniert.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/160/c4f/0e4/160c4f0e496acec2a2a2d739152a7cfa.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zelle mit Stra√üen im Inspektor. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stra√üentriangulation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Stra√üen anzuzeigen, m√ºssen Sie sie triangulieren. </font><font style="vertical-align: inherit;">Dies √§hnelt der Erstellung eines Netzes f√ºr Fl√ºsse, nur das Flussbett wird nicht im Relief angezeigt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie zun√§chst einen neuen Standard-Shader, der erneut UV-Koordinaten verwendet, um die Stra√üenoberfl√§che zu malen.</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/Road" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } SubShader { Tags { "RenderType"="Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Standard fullforwardshadows #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; }; half _Glossiness; half _Metallic; fixed4 _Color; <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = fixed4(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen Sie mit diesem Shader ein Stra√üenmaterial. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/973/9e3/2b8/9739e32b82ad2148c559b8f7c4caa868.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Materielle Stra√üe. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie das Fertighaus des Fragments so ein, dass es ein weiteres untergeordnetes Sechsecknetz f√ºr die Stra√üen erh√§lt. </font><font style="vertical-align: inherit;">Dieses Netz sollte keine Schatten werfen und darf nur UV-Koordinaten verwenden. </font><font style="vertical-align: inherit;">Der schnellste Weg, dies zu tun, ist eine vorgefertigte Instanz - duplizieren Sie das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekt </font><font style="vertical-align: inherit;">und ersetzen Sie sein Material.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf8/476/a9e/bf8476a9e950a13c69051a5cd43480c1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a64/4d8/776/a644d8776f3c6f0ba64cf3aef666f475.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kinderobjektstra√üen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie danach das </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemeine Feld hinzu </font></font><code>HexMesh roads</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">f√ºgen Sie </font><font style="vertical-align: inherit;">es in ein </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Verbinden Sie es im Inspektor mit dem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roads-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekt </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers, roads; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a95/c0e/c2a/a95c0ec2ae59dccbb249e6a02ccdc7c5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Roads-Objekt ist verbunden.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stra√üen zwischen Zellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns zun√§chst die Stra√üensegmente zwischen den Zellen an. </font><font style="vertical-align: inherit;">Wie Fl√ºsse sind Stra√üen durch zwei mittlere Quad gesperrt. </font><font style="vertical-align: inherit;">Wir decken diese Verbindungsvierecke vollst√§ndig mit den Stra√üenvierecken ab, damit die Positionen der gleichen sechs Spitzen verwendet werden k√∂nnen. </font><font style="vertical-align: inherit;">F√ºgen Sie dazu der </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode hinzu </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, Vector3 v5, Vector3 v6 </span></span></span><span class="hljs-function">)</span></span> { roads.AddQuad(v1, v2, v4, v5); roads.AddQuad(v2, v3, v5, v6); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir uns nicht mehr um den Wasserfluss k√ºmmern m√ºssen, ist die V-Koordinate nicht erforderlich, daher weisen wir ihr √ºberall den Wert 0 zu. Mit der U-Koordinate k√∂nnen wir angeben, ob wir uns mitten auf der Stra√üe oder auf der Seite befinden. </font><font style="vertical-align: inherit;">Lassen Sie es in der Mitte gleich 1 und auf beiden Seiten gleich 0 sein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, Vector3 v5, Vector3 v6 </span></span></span><span class="hljs-function">)</span></span> { roads.AddQuad(v1, v2, v4, v5); roads.AddQuad(v2, v3, v5, v6); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26a/730/868/26a73086896099b06098de0a25eb63ae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Stra√üenabschnitt zwischen Zellen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es w√§re logisch, diese Methode aufzurufen </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber nur, wenn es wirklich eine Stra√üe gibt. </font><font style="vertical-align: inherit;">F√ºgen Sie der Methode einen booleschen Parameter hinzu, um diese Informationen zu √ºbergeben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich werden wir jetzt Compilerfehler erhalten, da diese Informationen bisher noch nicht √ºbertragen wurden. </font><font style="vertical-align: inherit;">In allen F√§llen kann der Aufruf </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als </font><font style="vertical-align: inherit;">letztes Argument </font><font style="vertical-align: inherit;">hinzugef√ºgt werden </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir k√∂nnen jedoch auch deklarieren, dass der Standardwert dieses Parameters gleich ist </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aus diesem Grund wird der Parameter optional und Kompilierungsfehler verschwinden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie funktionieren optionale Parameter?</font></font></b> <div class="spoiler_text">        ,   . ,  <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; }</code> </pre> <br>    <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyMethod(x, <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyMethod(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; }</code> </pre> <br>   .      .    .      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Stra√üe zu triangulieren, rufen Sie </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bei Bedarf </font><font style="vertical-align: inherit;">einfach </font><font style="vertical-align: inherit;">mit den mittleren sechs Gipfeln an.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); terrain.AddQuadColor(c1, c2); terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); terrain.AddQuadColor(c1, c2); terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); terrain.AddQuadColor(c1, c2); terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); terrain.AddQuadColor(c1, c2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoad) { TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So gehen wir mit Flachzellenverbindungen um. </font><font style="vertical-align: inherit;">Um die Stra√üen auf den Felsvorspr√ºngen zu unterst√ºtzen, m√ºssen wir auch angeben, </font></font><code>TriangulateEdgeTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wo die Stra√üe hinzugef√ºgt werden soll. </font><font style="vertical-align: inherit;">Er kann diese Informationen einfach √ºbermitteln </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.Color, endCell.Color, <span class="hljs-number"><span class="hljs-number">1</span></span>); TriangulateEdgeStrip(begin, beginCell.Color, e2, c2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(beginCell.Color, endCell.Color, i); TriangulateEdgeStrip(e1, c1, e2, c2, hasRoad); } TriangulateEdgeStrip(e2, c2, end, endCell.Color, hasRoad); }</code> </pre> <br> <code>TriangulateEdgeTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drinnen gerufen </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hier k√∂nnen wir feststellen, ob tats√§chlich eine Stra√üe in die aktuelle Richtung f√ºhrt, sowohl beim Triangulieren einer Kante als auch beim Triangulieren von Leisten.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces( e1, cell, e2, neighbor, cell.HasRoadThroughEdge(direction) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip( e1, cell.Color, e2, neighbor.Color, cell.HasRoadThroughEdge(direction) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7a/67d/e7d/d7a67de7d2edeb2d23b63e9b37bc7508.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stra√üensegmente zwischen Zellen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zelle √ºber Rendering </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Zeichnen von Stra√üen sehen Sie, dass Stra√üensegmente zwischen Zellen angezeigt werden. Die Mitte dieser Segmente ist lila mit einem √úbergang zu blau an den R√§ndern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie die Kamera bewegen, k√∂nnen die Segmente jedoch flackern und manchmal vollst√§ndig verschwinden. Dies liegt daran, dass die Dreiecke der Stra√üen genau die Gel√§ndedreiecke √ºberlappen. Dreiecke zum Rendern werden zuf√§llig ausgew√§hlt. Dieses Problem kann in zwei Schritten behoben werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zun√§chst m√∂chten wir die Stra√üen zeichnen, nachdem das Relief gezeichnet wurde. Dies kann erreicht werden, indem sie nach dem Rendern der √ºblichen Geometrie gerendert werden, dh indem sie in eine sp√§tere Renderwarteschlange gestellt werden.</font></font><br><br><pre> <code class="hljs objectivec"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Opaque"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span> = <span class="hljs-string"><span class="hljs-string">"Geometry+1"</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens m√ºssen wir sicherstellen, dass Stra√üen an derselben Position √ºber Gel√§ndedreiecke gezogen werden. </font><font style="vertical-align: inherit;">Dies kann durch Hinzuf√ºgen des Tiefentestversatzes erfolgen. </font><font style="vertical-align: inherit;">Dadurch kann die GPU davon ausgehen, dass sich die Dreiecke n√§her an der Kamera befinden als sie tats√§chlich sind.</font></font><br><br><pre> <code class="hljs powershell"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Opaque"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span> = <span class="hljs-string"><span class="hljs-string">"Geometry+1"</span></span> } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> Offset <span class="hljs-literal"><span class="hljs-literal">-1</span></span>, <span class="hljs-literal"><span class="hljs-literal">-1</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stra√üen durch Zellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Triangulieren von Fl√ºssen mussten wir uns mit nicht mehr als zwei Flussrichtungen pro Zelle befassen. Wir k√∂nnten f√ºnf m√∂gliche Optionen identifizieren und sie unterschiedlich triangulieren, um die richtig aussehenden Fl√ºsse zu erzeugen. Bei Stra√üen gibt es jedoch vierzehn m√∂gliche Optionen. Wir werden nicht f√ºr jede dieser Optionen separate Ans√§tze verwenden. Stattdessen werden wir jede der sechs Zellenrichtungen unabh√§ngig von der spezifischen Stra√üenkonfiguration auf dieselbe Weise verarbeiten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn eine Stra√üe entlang eines Teils der Zelle verl√§uft, zeichnen wir sie direkt in die Mitte der Zelle, ohne die Dreieckszone zu verlassen. Wir werden einen Stra√üenabschnitt vom Rand bis zur H√§lfte in Richtung des Zentrums zeichnen. Dann verwenden wir zwei Dreiecke, um den Rest zur Mitte zu schlie√üen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df0/659/a13/df0659a13206731d401579ba8c7f3b8f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangulation eines Teils der Stra√üe. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dieses Schema zu triangulieren, m√ºssen wir die Mitte der Zelle, die linken und rechten mittleren Eckpunkte und die Eckpunkte der Kante kennen. </font><font style="vertical-align: inherit;">F√ºgen Sie eine Methode </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit den entsprechenden Parametern hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um ein Stra√üensegment zu bauen, ben√∂tigen wir einen zus√§tzlichen Gipfel. </font><font style="vertical-align: inherit;">Es befindet sich zwischen dem linken und rechten mittleren Gipfel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { Vector3 mC = Vector3.Lerp(mL, mR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); TriangulateRoadSegment(mL, mC, mR, e.v2, e.v3, e.v4); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt k√∂nnen wir auch die verbleibenden zwei Dreiecke hinzuf√ºgen. </font></font><br><br><pre> <code class="cs hljs"> TriangulateRoadSegment(mL, mC, mR, e.v2, e.v3, e.v4); roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen auch die UV-Koordinaten der Dreiecke hinzuf√ºgen. </font><font style="vertical-align: inherit;">Zwei ihrer Gipfel befinden sich in der Mitte der Stra√üe, der Rest befindet sich am Rande.</font></font><br><br><pre> <code class="cs hljs"> roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beschr√§nken wir uns vorerst auf Zellen, in denen es keine Fl√ºsse gibt. </font><font style="vertical-align: inherit;">In diesen F√§llen wird </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einfach ein Fan von Dreiecken erzeugt. </font><font style="vertical-align: inherit;">Verschieben Sie diesen Code in eine separate Methode. </font><font style="vertical-align: inherit;">Dann f√ºgen wir einen Anruf hinzu, </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn die Stra√üe tats√§chlich ist. </font><font style="vertical-align: inherit;">Der linke und der rechte mittlere Scheitelpunkt k√∂nnen durch Interpolation zwischen dem mittleren und zwei Eckscheitelpunkten gefunden werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithoutRiver(direction, cell, center, e); } ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoadThroughEdge(direction)) { TriangulateRoad( center, Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), e ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29d/ae4/def/29dae4def1f841ae190e64b267f6e4ea.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stra√üen, die durch die Zellen f√ºhren.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stra√üenrippen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir die Stra√üen sehen, aber n√§her an der Mitte der Zellen verengen sie sich. Da wir nicht pr√ºfen, um welche der vierzehn Optionen es sich handelt, k√∂nnen wir die Mitte der Stra√üe nicht verschieben, um sch√∂nere Formen zu erstellen. Stattdessen k√∂nnen wir zus√§tzliche Stra√üenkanten in anderen Teilen der Zelle hinzuf√ºgen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Stra√üen durch die Zelle verlaufen, jedoch nicht in der aktuellen Richtung, f√ºgen wir den Stra√üenr√§ndern ein Dreieck hinzu. Dieses Dreieck wird durch den mittleren, linken und rechten mittleren Eckpunkt definiert. In diesem Fall liegt nur der zentrale Gipfel in der Mitte der Stra√üe. Die anderen beiden liegen auf ihrer Rippe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, Vector3 mL, Vector3 mR</span></span></span><span class="hljs-function">)</span></span> { roads.AddTriangle(center, mL, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/293/6ec/bd12936ec0833f7d7da4e038158bb167.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Teil des Stra√üenrandes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir eine volle Stra√üe oder nur eine Kante triangulieren m√ºssen, m√ºssen wir sie verlassen </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zu diesem Zweck muss diese Methode wissen, ob die Stra√üe durch die Richtung der aktuellen Zellenkante verl√§uft. </font><font style="vertical-align: inherit;">Deshalb f√ºgen wir hierf√ºr einen Parameter hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoadThroughCellEdge </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoadThroughCellEdge) { Vector3 mC = Vector3.Lerp(mL, mR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); TriangulateRoadSegment(mL, mC, mR, e.v2, e.v3, e.v4); roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateRoadEdge(center, mL, mR); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt muss </font></font><code>TriangulateWithoutRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es anrufen, </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn Stra√üen durch die Zelle f√ºhren. </font><font style="vertical-align: inherit;">Und er muss Informationen dar√ºber √ºbermitteln, ob die Stra√üe durch die aktuelle Kante f√ºhrt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { TriangulateRoad( center, Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), e, cell.HasRoadThroughEdge(direction) ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/89e/f99/1a0/89ef991a0790911d140b68b1457fb9df.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stra√üen mit fertigen Rippen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stra√üengl√§ttung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Stra√üen sind jetzt fertig. </font><font style="vertical-align: inherit;">Leider erzeugt dieser Ansatz Ausbuchtungen in der Mitte der Zellen. </font><font style="vertical-align: inherit;">Das Platzieren der linken und rechten Spitze in der Mitte zwischen der Mitte und den Ecken passt zu uns, wenn sich neben ihnen eine Stra√üe befindet. </font><font style="vertical-align: inherit;">Wenn dies nicht der Fall ist, liegt eine Ausbuchtung vor. </font><font style="vertical-align: inherit;">Um dies zu vermeiden, k√∂nnen wir in solchen F√§llen die Eckpunkte n√§her an der Mitte platzieren. </font><font style="vertical-align: inherit;">Genauer gesagt, dann interpolieren mit ¬º, nicht mit ¬Ω. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen wir eine separate Methode, um herauszufinden, welche Interpolatoren verwendet werden sollen. </font><font style="vertical-align: inherit;">Da es zwei davon gibt, k√∂nnen wir das Ergebnis eingeben </font></font><code>Vector2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seine Komponente X ist der Interpolator des linken Punktes und seine Komponente Y ist der Interpolator des rechten Punktes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRoadInterpolators</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector2 interpolators; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interpolators; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn eine Stra√üe in die aktuelle Richtung f√ºhrt, k√∂nnen wir die Punkte in der Mitte platzieren. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRoadInterpolators</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector2 interpolators; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoadThroughEdge(direction)) { interpolators.x = interpolators.y = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interpolators; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andernfalls k√∂nnen die Optionen unterschiedlich sein. </font><font style="vertical-align: inherit;">F√ºr den linken Punkt k√∂nnen wir ¬Ω verwenden, wenn eine Stra√üe in die vorherige Richtung f√ºhrt. </font><font style="vertical-align: inherit;">Wenn dies nicht der Fall ist, m√ºssen wir ¬º verwenden. </font><font style="vertical-align: inherit;">Gleiches gilt f√ºr den richtigen Punkt, jedoch unter Ber√ºcksichtigung der folgenden Richtung.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRoadInterpolators</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector2 interpolators; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoadThroughEdge(direction)) { interpolators.x = interpolators.y = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { interpolators.x = cell.HasRoadThroughEdge(direction.Previous()) ? <span class="hljs-number"><span class="hljs-number">0.5f</span></span> : <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; interpolators.y = cell.HasRoadThroughEdge(direction.Next()) ? <span class="hljs-number"><span class="hljs-number">0.5f</span></span> : <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interpolators; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dieser neuen Methode k√∂nnen Sie jetzt bestimmen, welche Interpolatoren verwendet werden. </font><font style="vertical-align: inherit;">Dank dessen werden die Stra√üen gegl√§ttet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { Vector2 interpolators = GetRoadInterpolators(direction, cell); TriangulateRoad( center, Vector3.Lerp(center, e.v1, interpolators.x), Vector3.Lerp(center, e.v5, interpolators.y), e, cell.HasRoadThroughEdge(direction) ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c9/d0b/d12/3c9d0bd1262c2d47a3efc2d300212efd.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84c/5fa/4f8/84c5fa4f8ef27bd4f6d294d0bf50acf6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Glatte Stra√üen. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Kombination von Fl√ºssen und Stra√üen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gegenw√§rtig haben wir funktionierende Stra√üen, aber nur, wenn es keine Fl√ºsse gibt. </font><font style="vertical-align: inherit;">Wenn sich in der Zelle ein Fluss befindet, werden die Stra√üen nicht trianguliert.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5e/76f/814/f5e76f814407359057d0c1bb1688988c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der N√§he der Fl√ºsse gibt es keine Stra√üen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns eine Methode erstellen, </font></font><code>TriangulateRoadAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um mit dieser Situation umzugehen. </font><font style="vertical-align: inherit;">Wir stellen es auf die √ºblichen Parameter ein. </font><font style="vertical-align: inherit;">Wir werden es am Anfang der Methode aufrufen </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { TriangulateRoadAdjacentToRiver(direction, cell, center, e); } ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zun√§chst werden wir das Gleiche tun wie f√ºr Stra√üen ohne Fl√ºsse. </font><font style="vertical-align: inherit;">Wir werden pr√ºfen, ob die Stra√üe durch die aktuelle Kante f√ºhrt, Interpolatoren erhalten, Mittelspitzen erstellen und anrufen </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da jedoch Fl√ºsse auf dem Weg erscheinen, m√ºssen wir die Stra√üen von ihnen wegbewegen. </font><font style="vertical-align: inherit;">Infolgedessen befindet sich die Mitte der Stra√üe in einer anderen Position. </font><font style="vertical-align: inherit;">Wir verwenden eine Variable, um diese neue Position zu speichern </font></font><code>roadCenter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Anfangs ist es gleich der Mitte der Zelle.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoadThroughEdge = cell.HasRoadThroughEdge(direction); Vector2 interpolators = GetRoadInterpolators(direction, cell); Vector3 roadCenter = center; Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also werden wir Teilstra√üen in Zellen mit Fl√ºssen erstellen. </font><font style="vertical-align: inherit;">Die Richtungen, durch die die Fl√ºsse flie√üen, werden die L√ºcken in den Stra√üen durchschneiden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95e/029/595/95e0295954967415965a3992ffd91882.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stra√üen mit R√§umen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anfang oder Ende des Flusses </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns zun√§chst Zellen an, die entweder den Anfang oder das Ende eines Flusses enthalten. </font><font style="vertical-align: inherit;">Damit sich die Stra√üen nicht mit Wasser √ºberschneiden, verschieben wir die Stra√üenmitte vom Fluss. </font><font style="vertical-align: inherit;">F√ºgen Sie die </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft </font><font style="vertical-align: inherit;">hinzu, um die Richtung des ein- oder ausgehenden Flusses zu ermitteln </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection RiverBeginOrEndDirection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver ? incomingRiver : outgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir diese Eigenschaft verwenden </font></font><code>HexGridChunk.TriangulateRoadAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Stra√üenmitte in die entgegengesetzte Richtung zu verschieben. </font><font style="vertical-align: inherit;">Es reicht aus, ein Drittel in diese Richtung zur Mittelrippe zu bewegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoadThroughEdge = cell.HasRoadThroughEdge(direction); Vector2 interpolators = GetRoadInterpolators(direction, cell); Vector3 roadCenter = center; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { roadCenter += HexMetrics.GetSolidEdgeMiddle( cell.RiverBeginOrEndDirection.Opposite() ) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f18/12b/280/f1812b2807add77e4d173b85ad65e4da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ge√§nderte Stra√üen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als n√§chstes m√ºssen wir die L√ºcken schlie√üen. </font><font style="vertical-align: inherit;">Wir werden dies tun, indem wir zus√§tzliche Dreiecke an den Stra√üenr√§ndern hinzuf√ºgen, wenn wir uns in der N√§he des Flusses befinden. </font><font style="vertical-align: inherit;">Wenn es in der vorherigen Richtung einen Fluss gibt, f√ºgen wir ein Dreieck zwischen der Mitte der Stra√üe, der Mitte der Zelle und dem mittleren linken Punkt hinzu. </font><font style="vertical-align: inherit;">Und wenn der Fluss in die n√§chste Richtung geht, f√ºgen wir ein Dreieck zwischen der Mitte der Stra√üe, dem mittleren rechten Punkt und der Mitte der Zelle hinzu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden dies unabh√§ngig von der Konfiguration des Flusses tun, also setzen Sie diesen Code am Ende der Methode.</font></font><br><br><pre> <code class="cs hljs"> Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { TriangulateRoadEdge(roadCenter, center, mL); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { TriangulateRoadEdge(roadCenter, mR, center); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K√∂nnen Sie die else-Anweisung nicht verwenden?</font></font></b> <div class="spoiler_text">      .   ,     . </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93d/485/bc8/93d485bc8072e6fa8471fb98d084467a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bereit Stra√üen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gerade Fl√ºsse </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zellen mit geraden Fl√ºssen sind besonders schwierig, da sie das Zentrum der Zelle im Wesentlichen in zwei Teile teilen. </font><font style="vertical-align: inherit;">Wir f√ºgen bereits zus√§tzliche Dreiecke hinzu, um die L√ºcken zwischen den Fl√ºssen zu f√ºllen, aber wir m√ºssen auch die Stra√üen auf gegen√ºberliegenden Seiten des Flusses trennen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab6/203/055/ab62030558305530ed4aed038669ba9c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stra√üen, die einen geraden Fluss √ºberlappen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Zelle nicht den Anfang oder das Ende des Flusses hat, k√∂nnen wir pr√ºfen, ob die ein- und ausgehenden Fl√ºsse in entgegengesetzte Richtungen flie√üen. </font><font style="vertical-align: inherit;">Wenn ja, dann haben wir einen direkten Fluss.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { roadCenter += HexMetrics.GetSolidEdgeMiddle( cell.RiverBeginOrEndDirection.Opposite() ) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um festzustellen, wo sich der Fluss relativ zur aktuellen Richtung befindet, m√ºssen wir die benachbarten Richtungen √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Der Fluss ist entweder links oder rechts. </font><font style="vertical-align: inherit;">Da wir dies am Ende der Methode tun, werden diese Anforderungen in booleschen Variablen zwischengespeichert. </font><font style="vertical-align: inherit;">Dies vereinfacht auch das Lesen unseres Codes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoadThroughEdge = cell.HasRoadThroughEdge(direction); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> previousHasRiver = cell.HasRiverThroughEdge(direction.Previous()); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> nextHasRiver = cell.HasRiverThroughEdge(direction.Next()); Vector2 interpolators = GetRoadInterpolators(direction, cell); Vector3 roadCenter = center; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { roadCenter += HexMetrics.GetSolidEdgeMiddle( cell.RiverBeginOrEndDirection.Opposite() ) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { } } Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { TriangulateRoadEdge(roadCenter, center, mL); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { TriangulateRoadEdge(roadCenter, mR, center); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen die Mitte der Stra√üe auf einen Winkelvektor verschieben, der in die entgegengesetzte Richtung vom Fluss zeigt. </font><font style="vertical-align: inherit;">Wenn der Fluss durch die vorherige Richtung flie√üt, ist dies der zweite Raumwinkel. </font><font style="vertical-align: inherit;">Ansonsten ist dies der erste Raumwinkel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { Vector3 corner; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { corner = HexMetrics.GetSecondSolidCorner(direction); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { corner = HexMetrics.GetFirstSolidCorner(direction); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Stra√üe so zu bewegen, dass sie an den Fluss angrenzt, m√ºssen wir die Mitte der Stra√üe um den halben Abstand zu dieser Ecke verschieben. </font><font style="vertical-align: inherit;">Dann m√ºssen wir auch die Mitte der Zelle um ein Viertel der Entfernung in diese Richtung bewegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { Vector3 corner; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { corner = HexMetrics.GetSecondSolidCorner(direction); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { corner = HexMetrics.GetFirstSolidCorner(direction); } roadCenter += corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; center += corner * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4c/6bf/85b/e4c6bf85b3120697996ad75a3256a3a0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geteilte Stra√üen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben ein Stra√üennetz in dieser Zelle geteilt. </font><font style="vertical-align: inherit;">Dies ist normal, wenn sich die Stra√üen auf beiden Seiten des Flusses befinden. </font><font style="vertical-align: inherit;">Aber wenn es auf einer Seite keine Stra√üe gibt, haben wir ein kleines St√ºck einer abgelegenen Stra√üe. </font><font style="vertical-align: inherit;">Das ist unlogisch, also lasst uns solche Teile loswerden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sicher, dass eine Stra√üe in die aktuelle Richtung f√ºhrt. </font><font style="vertical-align: inherit;">Ist dies nicht der Fall, √ºberpr√ºfen Sie die andere Richtung derselben Flussseite auf das Vorhandensein der Stra√üe. </font><font style="vertical-align: inherit;">Wenn es dort oder dort keine vorbeifahrende Stra√üe gibt, verlassen wir die Methode vor dem Triangulieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !hasRoadThroughEdge &amp;&amp; !cell.HasRoadThroughEdge(direction.Next()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } corner = HexMetrics.GetSecondSolidCorner(direction); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !hasRoadThroughEdge &amp;&amp; !cell.HasRoadThroughEdge(direction.Previous()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } corner = HexMetrics.GetFirstSolidCorner(direction); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09e/398/532/09e398532543dcd7f78987c23e012571.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verk√ºrzte Stra√üen.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist mit Br√ºcken?</font></font></b> <div class="spoiler_text">     .         . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zick-Zack-Fl√ºsse </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die n√§chste Art von Fluss ist Zickzack. </font><font style="vertical-align: inherit;">Solche Fl√ºsse teilen sich nicht das Stra√üennetz, daher m√ºssen wir nur die Mitte der Stra√üe verschieben.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/851/29b/f56/85129bf56e4948296b17916094fd9d8b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zickzack durch die Stra√üen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der einfachste Weg, um nach Zickzack zu suchen, besteht darin, die Richtungen der ein- und ausgehenden Fl√ºsse zu vergleichen. </font><font style="vertical-align: inherit;">Wenn sie benachbart sind, haben wir einen Zickzack. </font><font style="vertical-align: inherit;">Dies f√ºhrt je nach Str√∂mungsrichtung zu zwei m√∂glichen Optionen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Previous()) { } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Next()) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen die Mitte der Stra√üe mit einer der Ecken der Richtung des ankommenden Flusses verschieben. </font><font style="vertical-align: inherit;">Der von Ihnen gew√§hlte Winkel h√§ngt von der Str√∂mungsrichtung ab. </font><font style="vertical-align: inherit;">Bewegen Sie die Stra√üenmitte aus diesem Winkel um den Faktor 0,2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Previous()) { roadCenter -= HexMetrics.GetSecondCorner(cell.IncomingRiver) * <span class="hljs-number"><span class="hljs-number">0.2f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Next()) { roadCenter -= HexMetrics.GetFirstCorner(cell.IncomingRiver) * <span class="hljs-number"><span class="hljs-number">0.2f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fa/3c6/f27/1fa3c6f277079e277491027207f9398f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Stra√üe schob sich von den Zickzacklinien weg.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In den krummen Fl√ºssen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die letzte Flusskonfiguration ist eine glatte Kurve. </font><font style="vertical-align: inherit;">Wie beim direkten Fluss kann auch dieser Stra√üen trennen. </font><font style="vertical-align: inherit;">In diesem Fall sind die Parteien jedoch unterschiedlich. </font><font style="vertical-align: inherit;">Zuerst m√ºssen wir mit der Innenseite der Kurve arbeiten.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/566/b8f/3db/566b8f3dbffec4cdc91556abe0f2bf5e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein geschwungener Fluss mit asphaltierten Stra√üen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir auf beiden Seiten der aktuellen Richtung einen Fluss haben, befinden wir uns innerhalb der Kurve.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Next()) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen die Stra√üenmitte zum aktuellen Rand der Zelle bewegen und die Stra√üe etwas verk√ºrzen. </font><font style="vertical-align: inherit;">Ein Koeffizient von 0,7 reicht aus. </font><font style="vertical-align: inherit;">Das Zellzentrum sollte sich ebenfalls mit einem Koeffizienten von 0,5 verschieben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { Vector3 offset = HexMetrics.GetSolidEdgeMiddle(direction) * HexMetrics.innerToOuter; roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>; center += offset * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2d/64f/a82/a2d64fa828544540d43856bf94e34f9d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verk√ºrzte Stra√üen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bei geraden Fl√ºssen m√ºssen wir die isolierten Teile der Stra√üen abschneiden. </font><font style="vertical-align: inherit;">In diesem Fall reicht es aus, nur die aktuelle Richtung zu √ºberpr√ºfen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasRoadThroughEdge) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 offset = HexMetrics.GetSolidEdgeMiddle(direction) * HexMetrics.innerToOuter; roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>; center += offset * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30b/6a0/d9d/30b6a0d9db5fe0960265713c62ef2ae5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stra√üen abschneiden.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Au√üerhalb der krummen Fl√ºsse </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach √úberpr√ºfung aller vorherigen F√§lle war die einzige verbleibende Option der √§u√üere Teil des gekr√ºmmten Flusses. </font><font style="vertical-align: inherit;">Drau√üen gibt es drei Teile der Zelle. </font><font style="vertical-align: inherit;">Wir m√ºssen die mittlere Richtung finden. </font><font style="vertical-align: inherit;">Nachdem wir es erhalten haben, k√∂nnen wir die Mitte der Stra√üe um den Faktor 0,25 in Richtung dieser Rippe bewegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { HexDirection middle; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { middle = direction.Next(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { middle = direction.Previous(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { middle = direction; } roadCenter += HexMetrics.GetSolidEdgeMiddle(middle) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b8/84c/a29/8b884ca29118c36e522674cd00ab8613.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Au√üenseite der Stra√üe wurde ge√§ndert. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als letzten Schritt m√ºssen wir die Stra√üen auf dieser Seite des Flusses abschneiden. </font><font style="vertical-align: inherit;">Am einfachsten ist es, alle drei Stra√üenrichtungen relativ zur Mitte zu √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Wenn es keine Stra√üen gibt, h√∂ren wir auf zu arbeiten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { HexDirection middle; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { middle = direction.Next(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { middle = direction.Previous(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { middle = direction; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !cell.HasRoadThroughEdge(middle) &amp;&amp; !cell.HasRoadThroughEdge(middle.Previous()) &amp;&amp; !cell.HasRoadThroughEdge(middle.Next()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } roadCenter += HexMetrics.GetSolidEdgeMiddle(middle) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56d/69a/d1b/56d69ad1b8d6ffdf74e9adb1c4800695.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/8c3/178/a9a8c3178c8a44738b4bbd01ef5f221d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stra√üen vor und nach dem Abschneiden. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem alle Flussoptionen verarbeitet wurden, k√∂nnen unsere Fl√ºsse und Stra√üen nebeneinander existieren. </font><font style="vertical-align: inherit;">Fl√ºsse ignorieren Stra√üen und Stra√üen passen sich an Fl√ºsse an.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b32/6e4/28b/b326e428b45df027cac2f99a336e71e9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kombination von Fl√ºssen und Stra√üen. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Aussehen der Stra√üen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bis zu diesem Moment haben wir ihre UV-Koordinaten als Stra√üenfarben verwendet. </font><font style="vertical-align: inherit;">Da sich nur die U-Koordinate ge√§ndert hat, haben wir tats√§chlich den √úbergang zwischen der Mitte und dem Stra√üenrand angezeigt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/cb2/8ac/084cb28ac448ddb258846c09d8b3b83a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anzeige von UV-Koordinaten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt, da die Stra√üen genau richtig trianguliert sind, k√∂nnen wir den Road Shader so √§ndern, dass er eher Stra√üen √§hnelt. </font><font style="vertical-align: inherit;">Wie bei Fl√ºssen ist dies eine einfache Visualisierung ohne Schnickschnack. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir beginnen mit der Verwendung von Volltonfarben f√ºr Stra√üen. </font><font style="vertical-align: inherit;">Verwenden Sie einfach die Farbe des Materials. </font><font style="vertical-align: inherit;">Ich habe es rot gemacht.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = _Color; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/304/2e4/ab4/3042e4ab4b01b3389822072244208cb6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rote Stra√üen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und es sieht schon viel besser aus! </font><font style="vertical-align: inherit;">Aber lassen Sie uns fortfahren und die Stra√üe mit dem Gel√§nde mischen, wobei wir die U-Koordinate als Mischfaktor verwenden.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = _Color; <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = blend; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es scheint, dass dies nichts ge√§ndert hat. </font><font style="vertical-align: inherit;">Es ist passiert, weil unser Shader undurchsichtig ist. </font><font style="vertical-align: inherit;">Jetzt braucht er Alpha-Blending. </font><font style="vertical-align: inherit;">Insbesondere ben√∂tigen wir einen Shader f√ºr eine passende Aufkleberoberfl√§che. </font><font style="vertical-align: inherit;">Wir k√∂nnen den erforderlichen Shader erhalten, indem wir der Direktive eine </font></font><code>#pragma surface</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeile </font><font style="vertical-align: inherit;">hinzuf√ºgen </font></font><code>decal:blend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Standard fullforwardshadows decal:blend</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/66c/501/7a066c5015ea14533f1b9ed881469323.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Mischung der Stra√üen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also haben wir eine glatte lineare Mischung von der Mitte bis zur Kante erstellt, die nicht sehr h√ºbsch aussieht. </font><font style="vertical-align: inherit;">Damit es wie eine Stra√üe aussieht, ben√∂tigen wir einen festen Bereich, gefolgt von einem schnellen √úbergang zu einem undurchsichtigen Bereich. </font><font style="vertical-align: inherit;">Sie k√∂nnen die Funktion daf√ºr verwenden </font></font><code>smoothstep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es wandelt einen linearen Verlauf von 0 nach 1 in eine S-f√∂rmige Kurve um.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b0/030/f57/2b0030f57819183470fc7fae72ea18bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lineare Progression und sanfter Schritt. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Funktion </font></font><code>smoothstep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verf√ºgt √ºber einen minimalen und einen maximalen Parameter, um die Kurve in einem beliebigen Intervall anzupassen. </font><font style="vertical-align: inherit;">Eingabewerte au√üerhalb des Bereichs sind begrenzt, um die Kurve flach zu halten. </font><font style="vertical-align: inherit;">Verwenden wir 0,4 am Anfang der Kurve und 0,7 am Ende. </font><font style="vertical-align: inherit;">Dies bedeutet, dass die U-Koordinate von 0 bis 0,4 vollst√§ndig transparent ist. </font><font style="vertical-align: inherit;">Und U-Koordinaten von 0,7 bis 1 sind vollst√§ndig undurchsichtig. </font><font style="vertical-align: inherit;">Der √úbergang erfolgt zwischen 0,4 und 0,7.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x; blend = smoothstep(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, blend);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/543/fe1/4b4/543fe14b4d760b820ec106626230876f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schneller √úbergang zwischen undurchsichtigen und transparenten Bereichen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stra√üe mit L√§rm </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da das Stra√üennetz verzerrt wird, haben die Stra√üen unterschiedliche Breiten. </font><font style="vertical-align: inherit;">Daher ist auch die Breite des √úbergangs an den Kanten variabel. </font><font style="vertical-align: inherit;">Manchmal ist es verschwommen, manchmal hart. </font><font style="vertical-align: inherit;">Eine solche Variabilit√§t passt zu uns, wenn wir die Stra√üen als sandig oder erdig wahrnehmen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Machen wir den n√§chsten Schritt und f√ºgen Sie den Stra√üenr√§ndern L√§rm hinzu. </font><font style="vertical-align: inherit;">Dadurch werden sie ungleichm√§√üiger und weniger polygonal. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies tun, indem wir die Rauschtextur abtasten. </font><font style="vertical-align: inherit;">F√ºr die Abtastung k√∂nnen Sie die Koordinaten der XZ-Welt verwenden, genau wie beim Verzerren der Eckpunkte der Zellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie der Eingabestruktur hinzu, um Zugriff auf die Position der Welt im Surface Shader zu erhalten </font></font><code>float3 worldPos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float2 uv_MainTex; float3 worldPos; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir diese Position verwenden </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Haupttextur abzutasten. </font><font style="vertical-align: inherit;">Verkleinern Sie auch, sonst wiederholt sich die Textur zu oft.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); fixed4 c = _Color; <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verzerren den √úbergang, indem wir die Koordinate U mit multiplizieren </font></font><code>noise.x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da die Ger√§uschwerte jedoch durchschnittlich 0,5 betragen, verschwinden die meisten Stra√üen. </font><font style="vertical-align: inherit;">Um dies zu vermeiden, addieren Sie vor der Multiplikation 0,5 zum Rauschen.</font></font><br><br><pre> <code class="hljs mel"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blend = IN.uv_MainTex.x; blend *= <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>.x + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; blend = <span class="hljs-keyword"><span class="hljs-keyword">smoothstep</span></span>(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, blend);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/b7d/e28/c08b7de2879b84c816286530871b6a6f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4be/bdf/28f/4bebdf28fc519b3f186f119b6e501261.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verzerrte Stra√üenr√§nder. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dies zu beenden, werden wir auch die Farbe der Stra√üen verzerren. </font><font style="vertical-align: inherit;">Dies gibt den Stra√üen ein Gef√ºhl von Schmutz, der unscharfen Kanten entspricht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multiplizieren Sie die Farbe mit einem anderen Rauschkanal, z </font></font><code>noise.y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">B. mit </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir erhalten also durchschnittlich die H√§lfte des Farbwerts. </font><font style="vertical-align: inherit;">Da dies zu viel ist, werden wir die Rauschskala leicht reduzieren und eine Konstante hinzuf√ºgen, damit die Summe 1 erreichen kann.</font></font><br><br><pre> <code class="hljs swift"> fixed4 <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = _Color * (noise.y * <span class="hljs-number"><span class="hljs-number">0.75</span></span> + <span class="hljs-number"><span class="hljs-number">0.25</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d2/a25/d49/6d2a25d4929cf56f7c4059352b4ed70a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raue Stra√üen. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424491/">https://habr.com/ru/post/de424491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424475/index.html">Bericht des Informationssicherheits-√úberwachungszentrums f√ºr das erste Halbjahr 2018</a></li>
<li><a href="../de424477/index.html">Die Verf√ºgbarkeit von Spielen auf Pygame</a></li>
<li><a href="../de424481/index.html">Die ganze Wahrheit √ºber RTOS. Artikel 11. Aufgaben: Konfiguration und Einf√ºhrung in die API</a></li>
<li><a href="../de424483/index.html">38-Milliarden-Dollar-Deal und seine Auswirkungen: Wie Comcast und Disney Amazon und Netflix mit Investitionen bek√§mpfen</a></li>
<li><a href="../de424485/index.html">SSL-Pinning-Bypass in der iOS-App</a></li>
<li><a href="../de424495/index.html">Google Chrome bietet die M√∂glichkeit, die automatische Profilsynchronisierung bei der Anmeldung bei den Diensten des Unternehmens abzulehnen. *</a></li>
<li><a href="../de424497/index.html">H√∂ren Sie auf, die Entwickler von Betrug zu verd√§chtigen. Lerne besser zu interviewen</a></li>
<li><a href="../de424499/index.html">Nun er, dein Pentest</a></li>
<li><a href="../de424501/index.html">Diagnoseterminals f√ºr echte Schwei√üer</a></li>
<li><a href="../de424503/index.html">Boot dich selbst, der Fr√ºhling kommt (Teil 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>