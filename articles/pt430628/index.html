<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👴🏻 ⚽️ 🔆 Algoritmo da Fortune, detalhes de implementação 🧑🏿‍🤝‍🧑🏾 😫 🤜🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nas últimas semanas, tenho trabalhado na implementação do algoritmo da Fortune em C ++. Esse algoritmo usa muitos pontos 2D e constrói um diagrama de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algoritmo da Fortune, detalhes de implementação</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430628/"> Nas últimas semanas, tenho trabalhado na implementação <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do algoritmo da Fortune</a> em C ++.  Esse algoritmo usa muitos pontos 2D e constrói <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um diagrama de Voronoi a</a> partir deles.  Se você não sabe o que é um diagrama de Voronoi, dê uma olhada na figura: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/df1/56c/50cdf156cb6f5ce5e73ad6308be52dfb.png"></div><br>  Para cada ponto de entrada, chamado de "site", precisamos encontrar muitos pontos mais próximos deste local do que de todos os outros.  Esses conjuntos de pontos formam as células mostradas na imagem acima. <br><br>  É notável no algoritmo da Fortune que ele construa esses diagramas com o tempo <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.89ex" height="2.66ex" viewBox="0 -832 4258 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMATHI-6E" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMATHI-6C" x="2003" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMATHI-6F" x="2302" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMATHI-67" x="2787" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMATHI-6E" x="3268" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-29" x="3868" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-1"> O (n \ log n) </script>  (ideal para um algoritmo de comparação), em que <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMATHI-6E" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> n </script>  É o número de lugares. <br><br>  Estou escrevendo este artigo porque considero a implementação desse algoritmo uma tarefa muito difícil.  No momento, esse é o algoritmo mais complicado que eu tive que implementar.  Portanto, quero compartilhar os problemas que encontrei e como resolvê-los. <br><br>  Como de costume, o código é publicado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> e todos os materiais de referência que usei estão listados no final do artigo. <br><a name="habracut"></a><br><h1>  Descrição do algoritmo da sorte </h1><br>  Não vou explicar como o algoritmo funciona, porque outras pessoas já o fizeram bem.  Posso recomendar o estudo desses dois artigos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  O segundo é muito interessante - o autor escreveu uma demonstração interativa em Javascript, que é útil para entender a operação do algoritmo.  Se você precisar de uma abordagem mais formal com todas as evidências, recomendo a leitura do Capítulo 7 da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Geometria Computacional, 3ª edição</em></a> . <br><br>  Além disso, prefiro lidar com detalhes de implementação que não estão bem documentados.  E são eles que tornam a implementação do algoritmo tão complexa.  Em particular, vou me concentrar nas estruturas de dados usadas. <br><br>  Acabei de escrever um pseudo-código do algoritmo para que você tenha uma idéia da estrutura global: <br><br><blockquote><pre>  adicione um evento de local à fila de eventos para cada local
 até que a fila de eventos esteja vazia
     recuperar o evento principal
     se o evento for um evento de local
         insira um novo arco no litoral
         verifique se há novos eventos de círculo
     caso contrário
         crie um vértice no diagrama
         removemos do litoral um arco apertado
         excluir eventos inválidos
         verifique se há novos eventos de círculo </pre></blockquote><br><h1>  Estrutura de dados do gráfico </h1><br>  O primeiro problema que encontrei foi escolher a maneira de armazenar o diagrama Voronoi. <br><br>  Decidi usar uma estrutura de dados amplamente usada em geometria computacional chamada lista de arestas duplamente conectadas (DCEL). <br><br>  Minha classe <code>VoronoiDiagram</code> usa quatro contêineres como campos: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VoronoiDiagram</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ... private: std::vector&lt;Site&gt; mSites; std::vector&lt;Face&gt; mFaces; std::list&lt;Vertex&gt; mVertices; std::list&lt;HalfEdge&gt; mHalfEdges; }</span></span></code> </pre> <br>  Vou falar em detalhes sobre cada um deles. <br><br>  A classe <code>Site</code> descreve o ponto de entrada.  Cada local possui um índice, útil para colocá-lo na fila, coordenadas e um ponteiro para a célula ( <code>face</code> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Site</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index; Vector2 point; Face* face; };</code> </pre> <br>  Os vértices da célula são representados pela classe <code>Vertex</code> , eles possuem apenas um campo de coordenadas: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vertex</span></span></span><span class="hljs-class"> {</span></span> Vector2 point; };</code> </pre> <br>  Aqui está a implementação das meias arestas: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HalfEdge</span></span></span><span class="hljs-class"> {</span></span> Vertex* origin; Vertex* destination; HalfEdge* twin; Face* incidentFace; HalfEdge* prev; HalfEdge* next; };</code> </pre> <br>  Você pode se perguntar, o que é meia costela?  Uma aresta no diagrama de Voronoi é comum a duas células vizinhas.  Na estrutura de dados do DCEL, dividimos essas arestas em duas meias arestas, uma para cada célula, e elas são vinculadas por um ponteiro <code>twin</code> .  Além disso, a meia borda tem um ponto inicial e final.  O campo <code>incidentFace</code> indica a face à qual a meia borda pertence.  As células no DCEL são implementadas como uma lista cíclica de meias arestas duplamente ligada, na qual as meias arestas adjacentes são conectadas.  Portanto, os campos <code>prev</code> e <code>next</code> indicam as meias-arestas anteriores e seguintes na célula. <br><br>  A figura abaixo mostra todos esses campos para a meia borda vermelha: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/459/a46/ac3/459a46ac330ea630a58cb69d083a2a61.svg"></div><br>  Finalmente, a classe <code>Face</code> define a célula.  Ele simplesmente contém um ponteiro para o seu lugar e outro para uma de suas meias costelas.  Não importa qual das meias arestas está selecionada, porque a célula é um polígono fechado.  Assim, temos acesso a todas as meias-arestas enquanto percorremos uma lista vinculada cíclica. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Face</span></span></span><span class="hljs-class"> {</span></span> Site* site; HalfEdge* outerComponent; };</code> </pre> <br><h1>  Fila de eventos </h1><br>  A maneira padrão de implementar uma fila de eventos é com uma fila prioritária.  No processo de processamento de eventos de local e círculo, talvez seja necessário remover eventos de círculo da fila porque eles não são mais válidos.  Mas a maioria das implementações de fila de prioridade padrão não permite excluir um item que não está no topo.  Isso se aplica em particular ao <code>std::priority_queue</code> . <br><br>  Existem duas maneiras de resolver esse problema.  O primeiro, mais simples, é adicionar um sinalizador <code>valid</code> aos eventos.  <code>valid</code> é inicialmente definido como <code>true</code> .  Em seguida, em vez de remover o evento circle da fila, podemos simplesmente definir seu sinalizador como <code>false</code> .  Finalmente, ao processar todos os eventos no loop principal, verificamos se o valor do sinalizador <code>valid</code> do evento é <code>false</code> e, nesse caso, simplesmente pule e processe o próximo. <br><br>  O segundo método que apliquei não era usar <code>std::priority_queue</code> .  Em vez disso, implementei minha própria fila de prioridades, que suporta a remoção de qualquer elemento contido nela.  A implementação dessa fila é bastante simples.  Eu escolhi esse método porque torna o código do algoritmo mais limpo. <br><br><h1>  Costa </h1><br>  A estrutura de dados da linha de costa é uma parte complexa do algoritmo.  No caso de implementação incorreta, não há garantias de que o algoritmo será executado em <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.89ex" height="2.66ex" viewBox="0 -832 4258 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMATHI-6E" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMATHI-6C" x="2003" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMATHI-6F" x="2302" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMATHI-67" x="2787" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMATHI-6E" x="3268" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-29" x="3868" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-3"> O (n \ log n) </script>  .  A chave para obter essa complexidade de tempo é usar uma árvore de auto-equilíbrio.  Mas é mais fácil falar do que fazer! <br><br>  A maioria dos recursos que estudei (os dois artigos mencionados acima e o livro <em>Geometria Computacional</em> ) são aconselhados a implementar o litoral como uma árvore na qual os nós internos indicam pontos de interrupção e as folhas indicam arcos.  Mas eles não dizem nada sobre como equilibrar uma árvore.  Eu acho que esse modelo não é o melhor, e aqui está o porquê: <br><br><ul><li>  há informações redundantes: sabemos que existe um ponto de interrupção entre dois arcos adjacentes; portanto, não é necessário representar esses pontos como nós </li><li>  é inadequado para o auto-equilíbrio: somente a subárvore formada por pontos de interrupção pode ser equilibrada.  Realmente não podemos equilibrar a árvore inteira, porque, caso contrário, os arcos podem se tornar nós internos e folhas de pontos de interrupção.  Escrever um algoritmo para equilibrar apenas a subárvore formada por nós internos parece um pesadelo para mim. </li></ul><br>  Por isso, decidi apresentar o litoral de maneira diferente.  Na minha implementação, o litoral também é uma árvore, mas todos os nós são arcos.  Esse modelo não possui nenhuma das desvantagens listadas. <br><br>  Aqui está a definição do <code>Arc</code> arco na minha implementação: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arc</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span><span class="hljs-class">{</span></span>RED, BLACK}; <span class="hljs-comment"><span class="hljs-comment">// Hierarchy Arc* parent; Arc* left; Arc* right; // Diagram VoronoiDiagram::Site* site; VoronoiDiagram::HalfEdge* leftHalfEdge; VoronoiDiagram::HalfEdge* rightHalfEdge; Event* event; // Optimizations Arc* prev; Arc* next; // Only for balancing Color color; };</span></span></code> </pre> <br>  Os três primeiros campos são usados ​​para estruturar a árvore.  O campo <code>leftHalfEdge</code> indica a meia aresta desenhada pelo ponto mais à esquerda do arco.  E <code>rightHalfEdge</code> está na meia-borda desenhada pelo ponto extremo direito.  Dois ponteiros, <code>prev</code> e <code>next</code> são usados ​​para obter acesso direto ao arco anterior e próximo do litoral.  Além disso, eles também permitem que você ignore o litoral como uma lista duplamente vinculada.  Finalmente, cada arco tem uma cor usada para equilibrar a costa. <br><br>  Para equilibrar a costa, decidi usar um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esquema vermelho-preto</a> .  Ao escrever código, fui inspirado pelo livro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Introdução aos algoritmos</a> .  O capítulo 13 descreve dois algoritmos interessantes, <code>insertFixup</code> e <code>deleteFixup</code> , que equilibram a árvore após a inserção ou exclusão. <br><br>  No entanto, não posso usar o método de <code>insert</code> mostrado no livro, porque as chaves são usadas para encontrar o ponto de inserção do nó.  Não há chaves no algoritmo da Fortune, apenas sabemos que precisamos inserir um arco antes ou depois de outro no litoral.  Para implementar isso, criei os <code>insertAfter</code> <code>insertBefore</code> e <code>insertAfter</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Beachline::insertBefore(Arc* x, Arc* y) { <span class="hljs-comment"><span class="hljs-comment">// Find the right place if (isNil(x-&gt;left)) { x-&gt;left = y; y-&gt;parent = x; } else { x-&gt;prev-&gt;right = y; y-&gt;parent = x-&gt;prev; } // Set the pointers y-&gt;prev = x-&gt;prev; if (!isNil(y-&gt;prev)) y-&gt;prev-&gt;next = y; y-&gt;next = x; x-&gt;prev = y; // Balance the tree insertFixup(y); }</span></span></code> </pre> <br>  A inserção de <code>y</code> antes de <code>x</code> é realizada em três etapas: <br><br><ol><li>  Encontre um local para inserir um novo nó.  Para fazer isso, usei a seguinte observação: o filho esquerdo <code>x</code> ou o filho direito <code>x-&gt;prev</code> é <code>Nil</code> , e o que é <code>Nil</code> é anterior a <code>x</code> e depois de <code>x-&gt;prev</code> . </li><li>  Dentro do litoral, mantemos a estrutura de uma lista duplamente vinculada, portanto, devemos atualizar os ponteiros <code>prev</code> e <code>next</code> dos elementos <code>x-&gt;prev</code> , <code>y</code> <code>x</code> . </li><li>  Finalmente, chamamos simplesmente o método <code>insertFixup</code> descrito no livro para equilibrar a árvore. </li></ol><br>  <code>insertAfter</code> é implementado da mesma forma. <br><br>  O método de remoção retirado do livro pode ser implementado sem alterações. <br><br><h1>  Limite de gráfico </h1><br>  Aqui está a saída do algoritmo da Fortune descrito acima: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/c3f/443/ed5c3f4438b59de6c99e1645effe0be6.png"></div><br>  Há um pequeno problema com algumas bordas das células na borda da imagem: elas não são desenhadas porque são infinitas. <br><br>  Pior, uma célula pode não ser um único fragmento.  Por exemplo, se pegarmos três pontos que estão na mesma linha, o ponto médio terá duas meias arestas infinitas que não estão conectadas.  Isso não nos serve muito, porque não conseguiremos acessar uma das meias arestas, porque a célula é uma lista vinculada de arestas. <br><br>  Para resolver esses problemas, limitaremos o diagrama.  Com isso, quero dizer que limitaremos cada célula do diagrama para que elas não tenham mais arestas infinitas e cada célula seja um polígono fechado. <br><br>  Felizmente, o algoritmo da Fortune nos permite encontrar rapidamente arestas infinitas: elas correspondem a meias arestas ainda no litoral no final do algoritmo. <br><br>  Meu algoritmo de restrição recebe uma caixa como entrada e consiste em três etapas: <br><br><ol><li>  Ele fornece o posicionamento de cada vértice do diagrama dentro do retângulo. </li><li>  Corte todas as arestas infinitas. </li><li>  Fecha células. </li></ol><br>  O estágio 1 é trivial - basta expandir o retângulo se ele não contiver um vértice. <br><br>  O estágio 2 também é bastante simples - consiste em calcular as interseções entre os raios e o retângulo. <br><br>  O estágio 3 também não é muito complicado, apenas requer atenção.  Eu o faço em duas etapas.  Primeiro, adiciono os pontos de canto do retângulo às células nos vértices dos quais deveriam estar.  Então, asseguro-me de que todos os vértices da célula estejam conectados por meia-arestas. <br><br>  Eu recomendo que você estude o código e faça perguntas se precisar de detalhes sobre esta parte. <br><br>  Aqui está o diagrama de saída do algoritmo delimitador: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33f/910/a79/33f910a79c155bd8a395fca1fd590a72.png"></div><br>  Agora vemos que todas as arestas são desenhadas.  E se você diminuir o zoom, verifique se todas as células estão fechadas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f08/402/6a6/f084026a6afbf57b142a60e5cbc49edc.png"></div><br><h1>  Interseção com retângulo </h1><br>  Ótimo!  Mas a primeira imagem do começo do artigo é melhor, certo? <br><br>  Em muitas aplicações, é útil ter a interseção entre o diagrama de Voronoi e o retângulo, como mostrado na primeira imagem. <br><br>  O bom é que, depois de restringir o gráfico, é muito mais fácil fazer isso.  A má notícia é que, embora o algoritmo não seja muito complicado, precisamos ter cuidado. <br><br>  A idéia é a seguinte: contornamos a meia aresta de cada célula e verificamos a interseção entre a meia aresta e o retângulo.  São possíveis cinco casos: <br><br><ol><li>  A meia costela está completamente dentro do retângulo: economizamos uma meia costela </li><li>  A meia costela está completamente fora do retângulo: descartamos essa meia costela </li><li>  A meia costela sai do retângulo: nós truncamos a meia costela e a salvamos como a <em>última meia costela que sai</em> . </li><li>  A meia costela vai para dentro do retângulo: nós truncamos a meia costela para conectá-la à <em>última meia costela que saiu</em> (nós a salvamos no caso 3 ou 5) </li><li>  A meia costela cruza o retângulo duas vezes: truncamos a meia costela e adicionamos uma meia costela para conectá-la à <em>última meia costela que saiu</em> e, em seguida, salvamos como a nova <em>última meia costela que saiu</em> . </li></ol><br>  Sim, houve muitos casos.  Criei uma imagem para mostrar a todos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/412/368/3f1/4123683f10d59989d879315f2f83ae17.svg"></div><br>  O polígono laranja é a célula original e o vermelho é a célula truncada.  As meias costelas truncadas estão marcadas em vermelho.  Costelas verdes foram adicionadas para conectar as meias costelas que entram no retângulo com as meias costelas saindo. <br><br>  Aplicando esse algoritmo a um diagrama delimitado, obtemos o resultado esperado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/df1/56c/50cdf156cb6f5ce5e73ad6308be52dfb.png"></div><br><h1>  Conclusão </h1><br>  O artigo acabou sendo bastante longo.  E tenho certeza de que muitos aspectos ainda não estão claros para você.  No entanto, espero que seja útil para você.  Examine o código para obter detalhes. <br><br>  Para resumir e garantir que não perdemos tempo em vão, medi no meu laptop (barato) o tempo para calcular o diagrama de Voronoi para um número diferente de locais: <br><br><ul><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>=</mo><mn>1000</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.143ex" height="1.937ex" viewBox="0 -728.2 3936.6 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-3D" x="878" y="0"></use><g transform="translate(1934,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-30" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-30" x="1501" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>=</mo><mn>1000</mn></math></span></span><script type="math/tex" id="MathJax-Element-4"> n = 1000 </script>  : 2 ms </li><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>=</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>$</mo></mrow><mn>10.00</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.952ex" height="2.298ex" viewBox="0 -832 4715.6 989.6" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-3D" x="878" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-24" x="1934" y="0"></use><g transform="translate(2435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-2E" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-30" x="1279" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-30" x="1780" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>=</mo><mrow class="MJX-TeXAtom-ORD"><mo>$</mo></mrow><mn>10.00</mn></math></span></span><script type="math/tex" id="MathJax-Element-5"> n = $ 10.00</script>  : 33 ms </li><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>=</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>$</mo></mrow><mn>100.00</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.115ex" height="2.298ex" viewBox="0 -832 5216.1 989.6" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-3D" x="878" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-24" x="1934" y="0"></use><g transform="translate(2435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-30" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-2E" x="1501" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-30" x="1780" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-30" x="2280" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>=</mo><mrow class="MJX-TeXAtom-ORD"><mo>$</mo></mrow><mn>100.00</mn></math></span></span><script type="math/tex" id="MathJax-Element-6"> n = $ 100.00</script>  : 450 ms </li><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>=</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>$</mo></mrow><mn>1.000.00</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.924ex" height="2.298ex" viewBox="0 -832 5995.1 989.6" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-3D" x="878" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-24" x="1934" y="0"></use><g transform="translate(2435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-2E" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-30" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-30" x="1279" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-30" x="1780" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-2E" x="2280" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-30" x="2559" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhi3okNWiCqZurEx4WFRHrVEosDWew#MJMAIN-30" x="3059" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>=</mo><mrow class="MJX-TeXAtom-ORD"><mo>$</mo></mrow><mn>1.000.00</mn></math></span></span><script type="math/tex" id="MathJax-Element-7"> n = $ 1.000.00</script>  : 6600 ms </li></ul><br>  Não tenho nada para comparar esses indicadores, mas parece que é incrivelmente rápido! <br><br><h1>  Referências </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo original de Stephen Fortune</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Geometria Computacional, 3ª edição</em></a> de Mark de Berg, Otfried Cheong, Marc van Kreveld e Mark Overmars </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Algoritmo da sorte: uma explicação intuitiva</a> em jacquesheunis.com </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Algoritmo e implementação da Fortune</a> no blog.ivank.net </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Introdução aos Algoritmos, 3ª edição</em></a> de Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest e Clifford Stein </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430628/">https://habr.com/ru/post/pt430628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430616/index.html">Seminário "Testes e Monitoramento", 27 de novembro de Moscou</a></li>
<li><a href="../pt430618/index.html">Vue.js SSR e Mobile Safari: um problema óbvio com software muito inteligente</a></li>
<li><a href="../pt430620/index.html">Pensamento funcional. Parte 4</a></li>
<li><a href="../pt430622/index.html">Pensamento funcional. Parte 5</a></li>
<li><a href="../pt430626/index.html">Anúncio do Meetup de Moscow GraphQL</a></li>
<li><a href="../pt430632/index.html">Serviços nos negócios: como varejistas estrangeiros abrem lojas prontas na Rússia</a></li>
<li><a href="../pt430634/index.html">Criando um módulo de software para o programador XELTEK SuperPro 6100</a></li>
<li><a href="../pt430636/index.html">Cerebelo e núcleos basais em vez da bola de cristal: como o cérebro prediz o futuro</a></li>
<li><a href="../pt430640/index.html">Mar Vermelho: por que as ações da Apple e outras empresas de tecnologia estão caindo</a></li>
<li><a href="../pt430642/index.html">Direção "Fotônica" nas Olimpíadas "Eu sou um profissional", ou como se inscrever em uma magistratura sem exames</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>