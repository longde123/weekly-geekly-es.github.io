<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏠 😜 🧑🏼‍🤝‍🧑🏻 JSON API - wir arbeiten gemäß der Spezifikation 🕴🏾 ✌️ 👩🏼‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor kurzem wurde die Webentwicklung geteilt. Jetzt sind wir nicht alle Full-Stack-Programmierer - wir sind Front-End und Back-End. Und das Schwierigst...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JSON API - wir arbeiten gemäß der Spezifikation</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433322/">  Vor kurzem wurde die Webentwicklung geteilt.  Jetzt sind wir nicht alle Full-Stack-Programmierer - wir sind Front-End und Back-End.  Und das Schwierigste daran ist, wie auch anderswo, das Problem der Interaktion und Integration. <br><br>  Das Frontend mit dem Backend interagieren über die API.  Das gesamte Entwicklungsergebnis hängt davon ab, um welche API es sich handelt, wie gut oder schlecht sich Backend und Frontend einig sind.  Wenn wir alle gemeinsam darüber diskutieren, wie das Upgrade durchgeführt werden soll, und den ganzen Tag damit verbringen, es zu überarbeiten, kommen wir möglicherweise nicht zu den Geschäftsaufgaben. <br><br>  Um keine Holivars über die Namen von Variablen zu schleudern und zu züchten, benötigen Sie eine gute Spezifikation.  Sprechen wir darüber, wie es sein sollte, allen das Leben zu erleichtern.  Gleichzeitig werden wir Experten für Fahrradschuppen. <br><br><img src="https://habrastorage.org/webt/o4/me/1u/o4me1uwmahvlwsnvqxyf_rzwa1i.jpeg"><br><a name="habracut"></a><br>  Beginnen wir von weitem - mit dem Problem, das wir lösen. <br><br>  Vor langer Zeit, im Jahr 1959, hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cyril Parkinson</a> (nicht zu verwechseln mit der Krankheit, er ist Schriftsteller und eine Wirtschaftsfigur) mehrere interessante Gesetze ausgearbeitet.  Zum Beispiel wachsen diese Ausgaben mit dem Einkommen usw.  Eines davon heißt Gesetz der Trivialität: <br><br><blockquote>  Die Zeit, die für die Erörterung des Artikels aufgewendet wird, ist umgekehrt proportional zum betrachteten Betrag. <br></blockquote><br>  Parkinson war ein Ökonom, also erklärte er seine Gesetze in wirtschaftlicher Hinsicht, so ähnlich.  Wenn Sie in den Verwaltungsrat kommen und sagen, dass Sie 10 Millionen US-Dollar für den Bau eines Kernkraftwerks benötigen, wird dieses Problem höchstwahrscheinlich viel weniger diskutiert als die Zuweisung von 100 Pfund für einen Fahrradschuppen für Mitarbeiter.  Weil jeder weiß, wie man einen Fahrradschuppen baut, jeder seine eigene Meinung hat, jeder sich wichtig fühlt und teilnehmen möchte und das Kernkraftwerk etwas Abstraktes und Fernes ist, 10 Millionen wurden auch nie gesehen - es gibt weniger Fragen. <br><br>  1999 erschien das Parkinsonsche Trivialitätsgesetz in der Programmierung, die dann aktiv weiterentwickelt wurde.  In der Programmierung wurde dieses Gesetz hauptsächlich in der englischsprachigen Literatur gefunden und klang wie eine Metapher.  Es wurde <strong>der Bikeshed-Effekt genannt</strong> (der Effekt eines Fahrradschuppens), aber das Wesentliche ist dasselbe - wir sind bereit für einen Fahrradschuppen und möchten viel länger als den Bau eines Kraftwerks diskutieren. <br><br>  Dieser Begriff wurde vom dänischen Entwickler Poul-Henning Kamp geprägt, der an der Erstellung von FreeBSD beteiligt war.  Während des Designprozesses diskutierte das Team sehr lange darüber, wie die Schlaffunktion funktionieren sollte.  Dies ist ein Zitat aus einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Brief von</a> Poul-Henning Kamp (Entwicklung wurde dann in E-Mail-Korrespondenz durchgeführt): <br><br><blockquote>  Es war ein Vorschlag, Schlaf zu machen (1) DTRT Wenn ein nicht ganzzahliges Argument gegeben wird, das dieses bestimmte Grasfeuer auslöst, werde ich nicht mehr darüber sagen, da es ein viel kleineres Element ist als eines Erwarten Sie von der Länge des Threads, und es hat bereits weit mehr Aufmerksamkeit erhalten als einige der * Probleme *, die wir hier haben. <br></blockquote><br>  In diesem Brief sagt er, dass es viele viel wichtigere ungelöste Probleme gibt: "Lasst uns nicht mit dem Fahrradschuppen umgehen, wir werden etwas dagegen tun und weitermachen!" <br><br>  So führte Poul-Henning Kamp 1999 den Begriff Bikeshed-Effekt in die englischsprachige Literatur ein, der wie folgt umformuliert werden kann: <br><br><blockquote>  Die Menge an Rauschen, die durch die Änderung des Codes erzeugt wird, ist umgekehrt proportional zur Komplexität der Änderung. <br></blockquote><br>  Je einfacher die Hinzufügung oder Änderung ist, desto mehr Meinungen müssen wir darüber hören.  Ich denke, viele haben das getroffen.  Wenn wir eine einfache Frage lösen, zum Beispiel, wie man Variablen benennt, spielt es für eine Maschine keine Rolle - diese Frage verursacht eine große Anzahl von Holivars.  Aber ernsthafte, wirklich wichtige für geschäftliche Probleme werden nicht diskutiert und treten in den Hintergrund. <br><br>  Was ist Ihrer Meinung nach wichtiger: Wie kommunizieren wir zwischen dem Backend und dem Frontend oder den Geschäftsaufgaben, die wir erledigen?  Jeder denkt anders, aber jeder Kunde, der erwartet, dass Sie ihm Geld bringen, wird sagen: "Machen Sie mir schon unsere Geschäftsaufgaben!"  Es ist ihm absolut egal, wie Sie Daten zwischen dem Backend und dem Frontend übertragen.  Vielleicht weiß er nicht einmal, was ein Backend und ein Frontend sind. <br><br>  Um die Einführung zusammenzufassen, möchte ich sagen: <strong>API ist ein Fahrradschuppen.</strong> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1cJVwn44iSc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <em>Präsentationslink</em> <br><br>  <strong>Über den Sprecher:</strong> Alexey Avdeev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Avdeev</a> ) arbeitet für die Firma Neuron.Digital, die sich mit Neuronen befasst und ein cooles Frontend für sie macht.  Alex achtet auch auf OpenSource und berät alle.  Er war lange Zeit in der Entwicklung tätig - seit 2002 fand er das alte Internet, als Computer groß waren, das Internet klein war und der Mangel an JS niemanden störte und jeder Websites auf den Tischen erstellte. <br><br><h2>  Wie gehe ich mit Fahrradschuppen um? <br></h2><br>  Nachdem der angesehene Cyril Parkinson das Gesetz der Trivialität abgeleitet hatte, wurde er viel diskutiert.  Es stellt sich heraus, dass die Wirkung eines Fahrradschuppens hier leicht vermieden werden kann: <br><br><ol><li>  <strong>Hören Sie nicht auf Ratschläge.</strong>  Ich denke, die Idee ist mittelmäßig. Wenn Sie sich die Tipps nicht anhören, können Sie so etwas tun, insbesondere beim Programmieren und insbesondere, wenn Sie ein unerfahrener Entwickler sind. <br></li><li>  <strong>Mach was du willst.</strong>  "Ich bin ein Künstler, ich sehe so!"  - Kein Bikeshed-Effekt, alles, was Sie brauchen, ist erledigt, aber auf dem Ausgang erscheinen sehr seltsame Dinge.  Dies ist häufig in freiberuflichen Tätigkeiten zu finden.  Sicherlich sind Sie auf Aufgaben gestoßen, die Sie für andere Entwickler erledigen mussten und deren Implementierung Sie verwirrt hat. <br></li><li>  <strong>Ist es wichtig, sich zu fragen?</strong>  Wenn nicht, können Sie es einfach nicht diskutieren, aber es ist eine Frage des persönlichen Bewusstseins. <br></li><li>  <strong>Verwenden Sie objektive Kriterien.</strong>  Ich werde im Bericht über diesen Punkt sprechen.  Um die Auswirkungen eines Fahrradschuppens zu vermeiden, können Sie Kriterien verwenden, die objektiv angeben, welche besser sind.  Sie existieren. <br></li><li>  <strong>Sprechen Sie nicht darüber, was Sie nicht hören möchten.</strong>  In unserem Unternehmen sind Backend-Entwickler introvertiert. Es kommt also vor, dass sie etwas tun, von dem sie anderen nichts erzählen.  Infolgedessen stoßen wir auf Überraschungen.  Diese Methode funktioniert, ist aber bei der Programmierung nicht die beste Option. <br></li><li>  Wenn Sie sich nicht für das Problem interessieren, können Sie es einfach <strong>loslassen oder eine der vorgeschlagenen Optionen auswählen</strong> , die sich im Verlauf von holivarov ergeben haben. <br></li></ol><br><h2>  Anti-Bikeshedding-Tool <br></h2><br>  Ich möchte über <strong>objektive Werkzeuge</strong> sprechen, um das Problem eines Fahrradschuppens zu lösen.  Um zu demonstrieren, was ein Anti-Bikeshedding-Tool ist, erzähle ich Ihnen eine kleine Geschichte. <br><br>  Stellen Sie sich vor, wir haben einen unerfahrenen Backend-Entwickler.  Er kam kürzlich in die Firma und wurde angewiesen, einen kleinen Dienst zu entwerfen, zum Beispiel einen Blog, für den Sie ein REST-Protokoll schreiben müssen. <br><br><img src="https://habrastorage.org/webt/zn/9m/uk/zn9muk80uvsd_yuragws16ms70c.png">  <em>Roy Fielding, Autor von REST</em> <br><br>  Auf dem Foto verteidigte Roy Fielding, der im Jahr 2000 seine These "Architekturstile und Design von Netzwerksoftware-Architekturen" verteidigte und damit den Begriff REST einführte.  Darüber hinaus hat er HTTP erfunden und ist einer der Begründer des Internets. <br><br>  REST ist eine Reihe von Architekturprinzipien, die festlegen, wie REST-Protokolle, REST-APIs und RESTful-Services entworfen werden.  Dies sind ziemlich abstrakte und komplexe architektonische Prinzipien.  Ich bin sicher, dass keiner von Ihnen jemals eine API gesehen hat, die vollständig nach allen RESTful-Prinzipien erstellt wurde. <br><br><h2>  Anforderungen an die REST-Architektur <br></h2><br>  Ich werde einige Anforderungen für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">REST-</a> Protokolle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angeben</a> , auf die ich mich dann beziehen und auf die ich mich verlassen werde.  Es gibt ziemlich viele von ihnen, Sie können mehr darüber auf Wikipedia lesen. <br><br>  1. <strong>Das Client-Server-Modell.</strong> <br>  Das wichtigste Prinzip von REST ist unsere Interaktion mit dem Backend.  Laut REST ist das Backend ein Server, das Frontend ein Client und wir kommunizieren in einem Client-Server-Format.  Mobile Geräte sind auch ein Client.  Entwickler für Uhren, für Kühlschränke, andere Dienstleistungen - entwickeln auch den Client-Teil.  Die RESTful-API ist der Server, auf den der Client zugreift. <br><br>  2. <strong>Mangel an Zustand.</strong> <br>  Auf dem Server darf kein Status vorhanden sein, dh alles, was für eine Antwort benötigt wird, ist in der Anfrage enthalten.  Wenn eine Sitzung auf dem Server gespeichert ist und je nach Sitzung unterschiedliche Antworten eingehen, verstößt dies gegen das REST-Prinzip. <br><br>  3. <strong>Einheitlichkeit der Schnittstelle.</strong> <br>  Dies ist eines der wichtigsten Grundprinzipien, auf denen die REST-API aufbauen sollte.  Es enthält Folgendes: <br><br><ul><li>  Mit der Ressourcenidentifikation sollten wir eine URL erstellen.  Bei REST wenden wir uns an den Server, um eine Ressource zu erhalten. </li><li>  Manipulation von Ressourcen durch Präsentation.  Der Server gibt uns eine Ansicht zurück, die sich von der Ansicht in der Datenbank unterscheidet.  Es spielt keine Rolle, ob Sie die Informationen in MySQL oder PostgreSQL speichern - wir haben eine Ansicht. </li><li>  Selbstbeschreibende Nachrichten - das heißt, die Nachricht enthält ID, Links, über die Sie diese Nachricht erneut erhalten können - alles, was erforderlich ist, um wieder mit dieser Ressource zu arbeiten. </li><li>  Hypermedia ist eine Verknüpfung zu den folgenden Aktionen mit einer Ressource.  Es scheint mir, dass keine einzige REST-API dies tut, aber es wird von Roy Fielding beschrieben. </li></ul><br>  Es gibt drei weitere Prinzipien, die ich nicht zitiere, weil sie für meine Geschichte nicht wichtig sind. <br><br><h2>  RESTful Blog <br></h2><br>  Zurück zum Anfang Backend-Entwickler, der gebeten wurde, einen Service für den Blog auf RESTful zu erstellen.  Unten sehen Sie ein Beispiel für einen Prototyp. <br><br><img src="https://habrastorage.org/webt/op/wi/6l/opwi6l_tbihj0tvef8tu4feyoo4.png"><br><br>  Dies ist eine Seite, auf der es Artikel gibt, die Sie kommentieren können. Der Artikel und die Kommentare haben einen Autor - eine Standardgeschichte.  Unser unerfahrener Backend-Entwickler wird eine RESTful-API für diesen Blog erstellen. <br><br>  Wir arbeiten mit allen Blogdaten auf Basis von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CRUD</a> . <br><img src="https://habrastorage.org/webt/4i/rk/hm/4irkhm7dcicexgmqomprfdraisu.png"><br>  Es sollte möglich sein, Ressourcen zu erstellen, zu lesen, zu aktualisieren und zu löschen.  Versuchen wir, unseren Backend-Entwickler zu bitten, einen RESTful-AP zu erstellen, der auf dem CRUD-Prinzip basiert.  Schreiben Sie also Methoden, um Artikel zu erstellen, eine Liste von Artikeln oder einen einzelnen Artikel abzurufen, zu aktualisieren und zu löschen. <br><br>  Mal sehen, wie er es schaffen konnte. <br><img src="https://habrastorage.org/webt/m2/i2/ua/m2i2uadak8sdzbge_pvqlnpu55s.png"><br><br>  <strong>In Bezug auf alle REST-Prinzipien ist hier alles falsch</strong> .  Das Interessanteste ist, dass es funktioniert.  Ich habe tatsächlich APIs, die ungefähr so ​​aussahen.  Für den Kunden ist es ein Fahrradschuppen, für Entwickler eine Gelegenheit zum Entspannen und Streiten, und für einen unerfahrenen Entwickler ist es nur eine riesige, schöne neue Welt, über die er jedes Mal stolpert, fällt und sich den Kopf zerschmettert.  Er muss es immer und immer wieder wiederholen. <br><img src="https://habrastorage.org/webt/k1/nj/lm/k1njlm8egbrcguim8am6juym76s.png"><br><br>  Dies ist eine REST-Option.  Basierend auf den Prinzipien der Identifizierung von Ressourcen arbeiten wir mit Ressourcen - mit Artikeln und verwenden die von Roy Fielding vorgeschlagenen HTTP-Methoden.  Er konnte nicht anders, als seine vorherige Arbeit in seiner nächsten Arbeit zu verwenden. <br><br>  Um Artikel zu aktualisieren, verwenden viele die PUT-Methode, die eine etwas andere Semantik aufweist.  Die PATCH-Methode aktualisiert die übergebenen Felder, und der PUT ersetzt einfach einen Artikel durch einen anderen.  Durch die Semantik wird PATCH zusammengeführt und PUT ersetzt. <br><br>  Unser unerfahrener Backend-Entwickler fiel, sie nahmen es auf und sagten: "Alles ist in Ordnung, mach es so", und er überarbeitete es ehrlich.  Aber dann wird er einen großen langen Weg durch die Dornen finden. <br><br>  <strong>Warum ist es so richtig?</strong> <br><br><ul><li>  weil Roy Fielding es sagte; </li><li>  weil es REST ist; </li><li>  denn das sind die architektonischen Prinzipien, auf denen unser Beruf jetzt basiert. </li></ul><br>  Dies ist jedoch ein "Fahrradschuppen", und die vorherige Methode wird funktionieren.  Computer kommunizierten vor REST und alles funktionierte.  Aber jetzt ist ein Standard in der Branche erschienen. <br><br><h2>  Artikel löschen <br></h2><br>  Betrachten Sie das Beispiel zum Löschen eines Artikels.  Angenommen, es gibt eine normale Ressourcenmethode DELETE / articles, mit der der Artikel anhand der ID entfernt wird.  HTTP enthält Header.  Der Accept-Header akzeptiert den Datentyp, den der Client als Antwort erhalten möchte.  Unser Junior hat einen Server geschrieben, der 200 OK, Inhaltstyp: application / json, zurückgibt und einen leeren Text übergibt: <br><br> <code>01. <b><font color="#c6e90e">DELETE /articles/</font></b> 1 /1.1 <br> 02. Accept: <b><font color="#c6e90e">application/json</font></b></code> <br> <br> <code>01. HTTP/1.1 200 OK <br> 02. Content-Type: <b><font color="#c6e90e">application/json</font></b> <br> 03. null <br></code> <br>  Hier wurde ein sehr <strong>häufiger Fehler gemacht - ein leerer Körper</strong> .  Alles scheint logisch zu sein - der Artikel wurde gelöscht, 200 OK, der Anwendungs- / JSON-Header ist vorhanden, aber der Client wird höchstwahrscheinlich fallen.  Es wird ein Fehler ausgegeben, da ein leerer Körper nicht gültig ist.  Wenn Sie jemals versucht haben, eine leere Zeichenfolge zu analysieren, sind Sie mit der Tatsache konfrontiert, dass jeder JSON-Parser darüber stolpert und abstürzt. <br><br>  Wie kann diese Situation behoben werden?  Wahrscheinlich ist die beste Option, json zu übergeben.  Wenn wir sagten: "Akzeptiere, gib uns json", sagt der Server: "Inhaltstyp, ich gebe dir json", gib json.  Ein leeres Objekt, ein leeres Array - legen Sie etwas dort ab - dies wird die Lösung sein und es wird funktionieren. <br><br>  Es gibt noch eine Lösung.  Zusätzlich zu 200 OK gibt es einen Antwortcode 204 - kein Inhalt.  Damit kann man den Körper nicht übertragen.  Nicht jeder weiß davon. <br><br>  Also habe ich zu den Medientypen geführt. <br><br><h3>  Pantomimenarten <br></h3><br>  Medientypen sind wie eine Dateierweiterung, nur im Web.  Wenn wir Daten übertragen, müssen wir informieren oder anfordern, welchen Typ wir als Antwort erhalten möchten. <br><br><ul><li>  Standardmäßig ist dies Text / Nur-Text. </li><li>  Wenn nichts angegeben ist, bedeutet der Browser höchstwahrscheinlich Anwendung / Oktett-Stream - nur ein Bit-Stream. </li></ul><br>  Sie können nur einen bestimmten Typ angeben: <br><br><ul><li>  Anwendung / pdf; </li><li>  image / png; </li><li>  Anwendung / json; </li><li>  application / xml; </li><li>  application / vnd.ms-excel. </li></ul><br>  Content-Type- und Accept-Header sind und sind wichtig. <br><br><blockquote>  Die API und der Client müssen die Header Content-Type und Accept übergeben. <br></blockquote><br>  Wenn Ihre API auf JSON basiert, übergeben Sie immer Accept: application / json und Content-Type application / json. <br><br>  Beispieldateitypen. <br><img src="https://habrastorage.org/webt/jd/v_/aa/jdv_aarpo9qnevtro5ddqbgw5ic.png"><br><br>  Medientypen ähneln diesen Dateitypen nur im Internet. <br><br><h3>  Antwortcodes <br></h3><br>  Das nächste Beispiel für die Abenteuer unseres Nachwuchsentwicklers sind die Antwortcodes. <br><br><img src="https://habrastorage.org/webt/o4/tc/ci/o4tcci6wnmokubjjdecsy5vwclm.png"><br><br>  Die lustigste Antwortrate ist 200 OK.  Jeder liebt ihn - es bedeutet, dass alles richtig gelaufen ist.  Ich hatte sogar einen Fall - ich habe <strong>Fehler 200 OK erhalten</strong> .  Es ist tatsächlich etwas auf den Server gefallen. Als Antwort auf die Antwort kommt eine HTML-Seite, auf der ein HTML-Fehler kompiliert wurde.  Ich habe eine Anwendung json mit dem Code 200 OK angefordert und mir überlegt, wie ich damit arbeiten soll.  Sie gehen nach Antwort, suchen nach dem Wort "Fehler", Sie denken, dass dies ein Fehler ist. <br><br>  Dies funktioniert jedoch in HTTP. Es gibt viele andere Codes, die Sie verwenden können, und REST empfiehlt, dass Sie sie in REST verwenden.  Zum Beispiel kann die Erstellung einer Entität (eines Artikels) beantwortet werden: <br><br><ul><li>  <strong>201 Erstellt</strong> ist ein erfolgreicher Code.  Der Artikel wird erstellt. Als Antwort müssen Sie den erstellten Artikel zurückgeben. </li><li>  <strong>202 Akzeptiert</strong> bedeutet, dass die Anforderung akzeptiert wurde, das Ergebnis jedoch später angezeigt wird.  Dies sind lang laufende Operationen.  Bei Akzeptiert kann kein Körper zurückgegeben werden.  Das heißt, wenn Sie in der Antwort nicht den Inhaltstyp angeben, ist dies möglicherweise auch nicht der Fall.  Oder Inhaltstyp Text / Ebene - das ist alles, keine Fragen.  Eine leere Zeichenfolge ist ein gültiger Text / eine gültige Ebene. </li><li>  <strong>204 Kein Inhalt</strong> - der Körper kann vollständig fehlen. </li><li>  <strong>403 Verboten</strong> - Sie dürfen diesen Artikel nicht erstellen. </li><li>  <strong>404 Nicht gefunden</strong> - Sie sind irgendwo falsch geklettert, es gibt zum Beispiel keinen solchen Weg. </li><li>  <strong>409 Konflikt</strong> ist ein Extremfall, den nur wenige Menschen verwenden.  Es ist manchmal erforderlich, wenn Sie eine ID auf dem Client und nicht im Backend generieren und zu diesem Zeitpunkt bereits jemand diesen Artikel erstellt hat.  Konflikt ist in diesem Fall die richtige Antwort. </li></ul><br><h3>  Entitätserstellung <br></h3><br>  Das folgende Beispiel: Wir erstellen eine Entität, z. B. Inhaltstyp: application / json, und übergeben diese Anwendung / json.  Das macht den Kunden zu unserem Frontend.  Lassen Sie uns genau diesen Artikel erstellen: <br><br> <code>01. POST /articles /1.1 <br> 02. Content-Type: application/json <br> 03. { "id": 1, "title": " JSON API"}</code> <br> <br>  Der Code kann als Antwort kommen: <br><br><ul><li>  422 Nicht verarbeitbare Entität - Eine nicht verarbeitete Entität.  Alles scheint großartig zu sein - Semantik, es gibt Code; </li><li>  403 Verboten </li><li>  500 Interner Serverfehler. </li></ul><br>  Aber es ist absolut unverständlich, was genau passiert ist: Welche Art von Entität wird nicht verarbeitet, warum sollte ich nicht dorthin gehen und was ist schließlich mit dem Server passiert? <br><br><h3>  Fehler zurückgeben <br></h3><br>  Stellen Sie sicher, dass (und die Junioren wissen nichts davon) als Antwort Fehler zurückgeben.  Das ist semantisch und richtig.  Fielding hat übrigens nicht darüber geschrieben, das heißt, es wurde später erfunden und auf REST aufgebaut. <br><br>  Das Backend kann ein Array mit Fehlern in der Antwort zurückgeben, es kann mehrere geben. <br><br> <code>01. HTTP/1.1 422 Unprocessable Entity <br> 02. Content-Type: application/json <br> 03. <br> 04. { "errors": [{ <br> 05.   "status": "422", <br> 06. <b><font color="#c6e90e">"title": "Title already exist",</font></b> <br> 07. }]}</code> <br> <br>  Jeder Fehler kann einen eigenen Status und Titel haben.  Das ist großartig, aber es geht bereits auf Konventionsebene über REST.  Dies könnte unser Anti-Bikeshedding-Tool sein, um das Streiten zu beenden und sofort eine gute, richtige API zu erstellen. <br><br><h2>  Paginierung hinzufügen <br></h2><br>  Das folgende Beispiel: Designer kommen zu unserem ersten Backend-Entwickler und sagen: „Wir haben viele Artikel, wir brauchen Paginierung.  Wir haben diesen gezeichnet. “ <br><img src="https://habrastorage.org/webt/fn/6l/9t/fn6l9tjzotvgzehwpbezkd0vcf4.png"><br><br>  Betrachten wir es genauer.  Zunächst fallen 336 Seiten auf.  Als ich das sah, dachte ich darüber nach, wie ich diese Figur bekommen könnte.  Wo bekomme ich 336, denn wenn ich eine Liste von Artikeln anfordere, bekomme ich eine Liste von Artikeln.  Zum Beispiel gibt es 10 Tausend davon, das heißt, ich muss alle Artikel herunterladen, durch die Anzahl der Seiten dividieren und diese Anzahl herausfinden.  Für eine sehr lange Zeit werde ich diese Artikel laden, ich brauche eine Möglichkeit, um die Anzahl der Einträge schnell zu erhalten.  Wenn unsere API jedoch eine Liste zurückgibt, wo diese Anzahl von Datensätzen im Allgemeinen abgelegt werden soll, da eine Reihe von Artikeln als Antwort kommt.  Es stellt sich heraus, dass die Anzahl der Datensätze, da sie nirgendwo platziert wird, zu jedem Artikel hinzugefügt werden muss, damit in jedem Artikel steht: „Und es gibt so viele von uns allen!“ <br><br>  Über der REST-API gibt es jedoch eine Konvention, die dieses Problem löst. <br><br><h3>  Listenanfrage <br></h3><br>  Um die API erweiterbar zu machen, können Sie sofort die GET-Parameter für die Paginierung verwenden: die Größe der aktuellen Seite und ihre Nummer, sodass genau der von uns angeforderte Teil der Seite an uns zurückgegeben wird.  Das ist bequem.  Als Antwort können Sie nicht sofort ein Array angeben, sondern zusätzliche Verschachtelungen hinzufügen.  Beispielsweise enthält der Datenschlüssel ein Array, die von uns angeforderten Daten und der Metaschlüssel, der zuvor nicht vorhanden war, die Gesamtsumme. <br><br> <code>01. GET /articles? <b><font color="#c6e90e">page[size]=30&amp;page[number]=2</font></b> <br> 02. Content-Type: application/json <br></code> <br> <code>01. HTTP/1.1 200 OK <br> 02. { <br> 03.   "data": [{ "id": 1, "title": "JSONAPI"}, ...], <br> 04.   "meta": { <b><font color="#c6e90e">"count": 10080</font></b> } <br> 05. } <br></code> <br>  Auf diese Weise kann die API zusätzliche Informationen zurückgeben.  Zusätzlich zum Zählen kann es einige andere Informationen geben - es ist erweiterbar.  Wenn der Junior es nicht sofort tat und erst nachdem er gebeten wurde, die Pyjinisierung durchzuführen, nahm er <strong>die rückwärts inkompatible Änderung vor</strong> , brach die API und alle Clients mussten sie wiederholen - normalerweise tut es sehr weh. <br><br>  Pajinisierung ist anders.  Ich biete mehrere Life-Hacks an, die Sie verwenden können. <br><br><h4>  [Offset] ... [Limit] <br></h4><br> <code>01. GET /articles? <b><font color="#c6e90e">page[offset]=30&amp;page[limit]=30</font></b> <br> 02. Content-Type: application/json <br></code> <br> <code>01. HTTP/1.1 200 OK <br> 02. { <br> 03.   "data": [{ "id": 1, "title": "JSONAPI"}, ...], <br> 04.   "meta": { "count": 10080 } <br> 05. } <br></code> <br>  Diejenigen, die mit Datenbanken arbeiten, haben möglicherweise bereits einen Subkortex [Offset] ... [Limit].  Die Verwendung anstelle von Seite [Größe] ... Seite [Nummer] wird einfacher.  Dies ist ein etwas anderer Ansatz. <br><br><h4>  Cursorpositionierung <br></h4><br> <code>01. GET /articles? <b><font color="#c6e90e">page[published_at]=1538332156</font></b> <br> 02. Content-Type: application/json</code> <br> <br> <code>01. HTTP/1.1 200 OK <br> 02. { <br> 03.    "data": [{ "id": 1, "title": "JSONAPI"}, ...], <br> 04.    "meta": { "count": 10080 } <br> 05. }</code> <br> <br>  Die Cursorposition verwendet einen Zeiger auf die Entität, mit der das Laden von Datensätzen gestartet werden soll.  Dies ist beispielsweise sehr praktisch, wenn Sie die Paginierung oder das Laden in Listen verwenden, die sich häufig ändern.  Nehmen wir an, in unserem Blog werden ständig neue Artikel geschrieben.  Die dritte Seite ist jetzt nicht dieselbe dritte Seite, die in einer Minute erstellt wird. Wenn wir jedoch zur vierten Seite wechseln, erhalten wir einige Datensätze von der dritten Seite, da sich die gesamte Liste verschiebt. <br><br>  Dieses Problem wird durch Cursor-Paginierung gelöst.  Wir sagen: "Laden Sie die Artikel, die nach dem zu diesem Zeitpunkt veröffentlichten Artikel kommen" - rein technologisch kann es keine Verschiebung mehr geben, und das ist cool. <br><br><h2>  Problem N +1 <br></h2><br>  Das nächste Problem, auf das unser Junior-Entwickler definitiv stoßen wird, ist das N + 1-Problem (Backender werden es verstehen).  Angenommen, Sie möchten eine Liste mit 10 Artikeln auflisten.  Wir laden eine Liste von Artikeln hoch, jeder Artikel hat einen Autor und für jeden müssen Sie einen Autor herunterladen.  Wir versenden: <br><br><ul><li>  1 Anfrage für eine Liste von Artikeln; </li><li>  10 Anfragen für die Autoren jedes Artikels. </li></ul><br>  Insgesamt: 11 Abfragen, um eine kleine Liste anzuzeigen. <br><br><h3>  Links hinzufügen <br></h3><br>  Im Backend ist dieses Problem in allen ORMs gelöst. Sie müssen nur daran denken, diese Verbindung hinzuzufügen.  Diese Verbindungen können auch am Frontend verwendet werden.  Dies geschieht wie folgt: <br><br> <code>01. GET /articles? <b><font color="#c6e90e">include =author</font></b> <br> 02. Content-Type: application/json <br></code> <br>  Sie können einen speziellen GET-Parameter verwenden, ihn include nennen (wie im Backend) und angeben, welche Links wir zusammen mit den Artikeln laden müssen.  Angenommen, wir laden Artikel hoch und möchten den Autor sofort mit den Artikeln zusammenbringen.  Die Antwort sieht so aus: <br><br> <code>01. /1.1 200  <br> 02. { "data": [{ <br> 03.  { attributes: { "id": 1, "title": "JSON API" }, <br> 04.  { relationships: { <br> 05. <b><font color="#c6e90e">"author": { "id": 1, "name": "Avdeev" } }</font></b> <br> 06.  }, ... <br> 07. }]}</code> <br> <br>  Eigene Artikelattribute wurden auf Daten übertragen und die Schlüsselbeziehungen hinzugefügt.  Wir setzen alle Verbindungen in diesen Schlüssel.  Somit haben wir mit einer Anfrage alle Daten erhalten, die zuvor 11 Anfragen erhalten haben.  Dies ist ein cooler Life-Hack, der das Problem mit N + 1 am Frontend gut löst. <br><br><h2>  Das Problem der Datenvervielfältigung <br></h2><br>  Angenommen, Sie möchten 10 Artikel anzeigen, die den Autor angeben. Alle Artikel haben einen Autor, aber das Objekt mit dem Autor ist sehr groß (z. B. ein sehr langer Nachname, der ein Megabyte benötigt).  Ein Autor ist 10 Mal in der Antwort enthalten, und 10 Einschlüsse desselben Autors in die Antwort benötigen 10 MB. <br><br>  Da alle Objekte gleich sind, wird das Problem, dass ein Autor 10 Mal (10 MB) enthalten ist, mithilfe der Normalisierung gelöst, die in Datenbanken verwendet wird.  Am Frontend können Sie auch die Normalisierung bei der Arbeit mit der API verwenden - das ist sehr cool. <br><br> <code>01. /1.1 200  <br> 02. { "data": [{ <br> 03. "id": "1″, <b><font color="#c6e90e">"type": "article",</font></b> <br> 04. "attributes": { "title": "JSON API" }, <br> 05. "relationships": { ... } <br> 06.  "author": { "id": 1, <b><font color="#c6e90e">"type": "people"</font></b> } } <br> 07. }, ... ] <br> 08. }</code> <br> <br>  Wir markieren alle Entitäten mit einem Typ (dies ist ein Darstellungstyp, ein Ressourcentyp).  Roy Fielding führte das Konzept einer Ressource ein, dh sie forderten Artikel an - erhielten einen „Artikel“.  In Beziehungen setzen wir einen Link zu den Typ-Personen, dh wir haben die Personen-Ressource immer noch woanders.  Und die Ressource selbst nehmen wir in einem separaten Schlüssel auf, der auf der gleichen Ebene wie Daten liegt. <br><br> <code>01. /1.1 200  <br> 02. { <br> 03. "data": [ ... ], <br> 04. <b><font color="#c6e90e">"included":</font></b> [{ <br> 05.  "id": 1, "type": "people", <br> 06.  "attributes": { "name": "Avdeev" } <br> 07. }] <br> 08. }</code> <br> <br>  Somit fallen alle verbundenen Entitäten in einer einzelnen Instanz in den enthaltenen Sonderschlüssel.  Wir speichern nur Links und die Entitäten selbst werden in eingeschlossen gespeichert. <br><br>  Anforderungsgröße verringert.  Dies ist ein Life-Hack, von dem das anfängliche Back-End nichts weiß.  Er wird später herausfinden, wann er die API brechen muss. <br><br><h3>  Es werden nicht alle Ressourcenfelder benötigt <br></h3><br>  Der folgende Life-Hack kann angewendet werden, wenn nicht alle Ressourcenfelder benötigt werden.  Dies erfolgt mithilfe eines speziellen GET-Parameters, der die zurückzugebenden Attribute durch Kommas getrennt auflistet.  Zum Beispiel ist der Artikel groß und das Inhaltsfeld kann Megabyte enthalten. Wir müssen nur die Liste der Header anzeigen. Der Inhalt in der Antwort wird nicht benötigt. <br><br> <code>GET /articles <b><font color="#c6e90e">?fields[article]=title /1.1</font></b></code> <br> <br> <code>01. /1.1 200 OK <br> 02. { "data": [{ <br> 03.  "id": "1″, "type": "article", <br> 04.  "attributes": { <b><font color="#c6e90e">"title": " JSON API"</font></b> }, <br> 05.  }, ... ] <br> 06. }</code> <br> <br>  Wenn Sie beispielsweise auch das Veröffentlichungsdatum benötigen, können Sie ein durch Kommas getrenntes „Veröffentlichungsdatum“ schreiben.  Als Antwort werden zwei Felder in Attributen angezeigt.  Dies ist eine Konvention, die als Anti-Bikeshedding-Tool verwendet werden kann. <br><br><h3>  Suche nach Artikeln <br></h3><br>  Oft brauchen wir Suchen und Filter.  Hierfür gibt es Konventionen - spezielle Filter GET-Parameter: <br><br>  ● <code>GET /articles <b><font color="#c6e90e">?filters[search]=api</font></b> HTTP/1.1</code> - Suche; <br>  ● <code>GET /articles <b><font color="#c6e90e">?fiIters[from_date]=1538332156</font></b> HTTP/1.1</code> - Artikel von einem bestimmten Datum herunterladen; <br>  ● <code>GET /articles <b><font color="#c6e90e">?filters[is_published]=true</font></b> HTTP/1.1</code> - Laden Sie Artikel herunter, die gerade veröffentlicht wurden. <br>  ● <code>GET /articles <b><font color="#c6e90e">?fiIters[author]=1</font></b> HTTP/1.1</code> - Artikel mit dem Erstautor herunterladen. <br><br><h3>  Artikel sortieren <br></h3><br>  ● <code>GET /articles <b><font color="#c6e90e">?sort=title</font></b> /1.1</code> - nach Titel; <br>  ● <code>GET /articles <b><font color="#c6e90e">?sort=published_at</font></b> HTTP/1.1</code> - nach Veröffentlichungsdatum; <br>  ● <code>GET /articles <b><font color="#c6e90e">?sort=-published_at</font></b> HTTP/1.1</code> - nach Veröffentlichungsdatum in die entgegengesetzte Richtung; <br>  ● <code>GET /articles <b><font color="#c6e90e">?sort=author,-publisbed_at</font></b> HTTP/1.1</code> - zuerst nach Autor, dann nach Veröffentlichungsdatum in die entgegengesetzte Richtung, wenn die Artikel vom selben Autor stammen. <br><br><h2>  URLs müssen geändert werden <br></h2><br>  Lösung: Hypermedia, die ich bereits erwähnt habe, kann wie folgt durchgeführt werden.  Wenn das Objekt (die Ressource) sich selbst beschreiben soll, kann der Client durch Hypermedia verstehen, was damit gemacht werden kann, und der Server kann sich unabhängig vom Client entwickeln. Anschließend können wir mithilfe spezieller Linkschlüssel Links zur Artikelliste zum Artikel selbst hinzufügen :: <br><br> <code><code>01. GET /articles /1.1 <br> 02. { <br> 03. "data": [{ <br> 04.  ... <br> 05. <b><font color="#c6e90e">"links": { "self": "http://localhost/articles/1"</font></b></code> }, <br> 06.  "relationships": { ... } <br> 07. }], <br> 08. <b><font color="#c6e90e">"links": { "self": " <code>http://localhost/articles</code> " }</font></b> <br> 09. } <br></code> <br>  Oder verwandt, wenn wir dem Kunden mitteilen möchten, wie er einen Kommentar zu diesem Artikel hochladen soll: <br><br> <code><code>01. ... <br> 02. "relationships": { <br> 03. "comments": { <br> 04.  "links": { <br> 05. <b><font color="#c6e90e">"self": "http://localhost/articles/l/relationships/comments</font></b></code> ", <br> 06. <b><font color="#c6e90e">"related": " <code>http://localhost/articles/l/comments</code> "</font></b> <br> 07.  } <br> 08. } <br> 09. }</code> <br>  Der Client sieht, dass es einen Link gibt, folgt ihm und lädt einen Kommentar.  Wenn es keinen Link gibt, gibt es keine Kommentare.  Das ist praktisch, aber so wenige tun es.  Fielding hat die Prinzipien von REST entwickelt, aber nicht alle sind in unsere Branche eingetreten.  Wir verwenden hauptsächlich zwei oder drei. <br><br>  Im Jahr 2013 wurden alle Life-Hacks, von denen ich Ihnen erzählt habe, von Steve Klabnik in die JSON-API-Spezifikation integriert und zusätzlich zu JSON als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neuer Medientyp</a> registriert.  So kam unser Junior-Backend-Entwickler, der sich allmählich weiterentwickelte, zur JSON-API. <br><br><h2>  JSON-API <br></h2><br>  Alles wird ausführlich auf der Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://jsonapi.org/implementations/ beschrieben</a> : Es gibt sogar eine Liste von 170 verschiedenen Implementierungen von Spezifikationen für 32 Programmiersprachen - und diese werden nur dem Katalog hinzugefügt.  Bibliotheken, Parser, Serialisierer usw. wurden bereits geschrieben. <br><br>  Da diese Spezifikation Open Source ist, investieren alle in sie.  Ich habe unter anderem selbst etwas geschrieben.  Ich bin sicher, dass es viele solcher Leute gibt.  Sie können diesem Projekt selbst beitreten. <br><br><h4>  JSON API-Vorteile <br></h4><br>  Die JSON-API-Spezifikation löst eine Reihe von Problemen - eine <strong>gemeinsame Vereinbarung für alle</strong> .  Da es eine allgemeine Vereinbarung gibt, <strong>streiten</strong> wir <strong>uns nicht im Team</strong> - der Fahrradschuppen ist dokumentiert.  Wir haben eine Vereinbarung darüber getroffen, aus welchen Materialien ein Fahrradschuppen hergestellt und wie er lackiert werden soll. <br><br>  Wenn der Entwickler etwas falsch macht und ich es sehe, beginne ich nicht mit der Diskussion, sondern sage: "Nicht über die JSON-API!"  und in der Spezifikation an Ort und Stelle zeigen.  Sie hassen mich in der Firma, gewöhnen sich aber allmählich daran und alle mochten die JSON-API.  Wir stellen neue Standarddienste gemäß dieser Spezifikation her.  Wir haben einen Datumsschlüssel, wir sind bereit, Meta hinzuzufügen, Schlüssel einzuschließen.  Es gibt einen reservierten GET-Parameterfilter für Filter.  Wir streiten uns nicht darüber, wie man einen Filter nennt - wir verwenden diese Spezifikation.  Es wird beschrieben, wie Sie eine URL erstellen. <br><br>  Da wir nicht streiten, sondern Geschäftsaufgaben erledigen, ist die <strong>Entwicklungsproduktivität höher</strong> .  Wir haben die beschriebenen Spezifikationen, der Entwickler hat das Backend gelesen, die API erstellt, wir haben sie angeschraubt - der Kunde ist zufrieden. <br><br>  <strong>Beliebte Probleme wurden</strong> beispielsweise mit der Paginierung <strong>bereits gelöst</strong> .  Es gibt viele Hinweise in der Spezifikation. <br><br>  Da dies JSON ist (danke an Douglas Crockford für dieses Format), ist es prägnanter als XML und <strong>leicht zu lesen und zu verstehen</strong> . <br><br>  Die Tatsache, dass dies <strong>Open Source ist,</strong> kann sowohl ein Plus als auch ein Minus sein, aber ich liebe Open Source. <br><br><h4>  Nachteile JSON API <br></h4><br>  Das Objekt ist gewachsen (Datum, Attribute, eingeschlossen usw.) - das <strong>Frontend muss die Antworten analysieren: Sie</strong> können über Arrays iterieren, um das Objekt herumgehen und wissen, wie Reduzieren funktioniert.  Nicht alle unerfahrenen Entwickler kennen diese komplexen Dinge.  Es gibt Bibliotheken von Serializern / Deserialisierern, die Sie verwenden können.  Im Allgemeinen funktioniert dies nur mit Daten, aber die Objekte sind groß. <br><br>  Und das <strong>Backend hat</strong> Schmerzen: <br><br><ul><li>  Nesting Control - Include kann sehr weit geklettert werden; </li><li>  Die Komplexität von Datenbankabfragen - sie werden manchmal automatisch erstellt und erweisen sich als sehr schwierig. </li><li>  Sicherheit - Sie können in den Dschungel klettern, besonders wenn Sie eine Art Bibliothek verbinden. </li><li>  Die Spezifikation ist schwer zu lesen.  Sie ist auf Englisch, und es erschreckte einige, aber allmählich gewöhnten sich alle daran; </li><li>  Nicht alle Bibliotheken implementieren die Spezifikation gut - dies ist ein Open Source-Problem. </li></ul><br><h4>  Fallstricke JSON API <br></h4><br>  Ein bisschen Hardcore. <br><br>  <strong>Die Anzahl der Beziehungen in der Ausgabe ist nicht begrenzt.</strong>  Wenn wir Artikel einschließen, anfordern und Kommentare hinzufügen, erhalten wir als Antwort alle Kommentare zu diesem Artikel.  Es gibt 10.000 Kommentare - alle 10.000 Kommentare erhalten: <br><br> <code>GET /articles/1?include=comments /1.1</code> <br> <br> <code>01. ... <br> 02. "relationships": { <br> 03. "comments": { <br> 04.  "data": <b><font color="#c6e90e">[0 ... ∞]</font></b> <br> 05. } <br> 06. }</code> <br> <br>  Somit kamen tatsächlich 5 MB zu unserer Anfrage als Antwort: „Es ist in der Spezifikation geschrieben - es ist notwendig, die Anfrage korrekt neu zu formulieren: <br><br> <code>GET /comments? <b><font color="#c6e90e">filters[article]=1&amp;</font></b> page[size]=30 HTTP/1.1</code> <br> <br> <code>01. { <br> 02. "data": <b><font color="#c6e90e">[0 ... 29]</font></b> <br> 03. }</code> <br> <br>  Wir bitten um Kommentare mit einem Filter nach Artikel, sagen: "30 Stück, bitte" und erhalten 30 Kommentare.  Das ist Mehrdeutigkeit. <br><br>  <strong>Die gleichen Dinge können mehrdeutig formuliert werden</strong> : <br><br>  ● <code>GET /articles/1 <b><font color="#c6e90e">?include=comments</font></b> HTTP/1.1</code> - Artikel mit Kommentaren anfordern; <br>  ● <code>GET /articles/1/comments HTTP/1.1</code> - Kommentare zum Artikel anfordern; <br>  ● <code>GET /comments <b><font color="#c6e90e">?filters[article]=1</font></b> HTTP/1.1</code> - Fordern Sie Kommentare mit einem Filter nach Artikel an. <br><br>  Dies ist ein und dasselbe - die gleichen Daten, die auf unterschiedliche Weise erhalten werden, es gibt einige Unklarheiten.  Diese Falle ist nicht sofort sichtbar. <br><br>  <strong>Eins-zu-viele polymorphe Beziehungen</strong> schleichen sich sehr schnell in REST ein. <br><br> <code>01. GET /comments?include=commentable /1.1 <br> 02. <br> 03. ... <br> 04. "relationships": { <br> 05. <b><font color="#c6e90e">"commentable"</font></b> : { <br> 06.  "data": { "type": "article", "id": "1″ } <br> 07. } <br> 08. }</code> <br> <br>  Es gibt eine kommentierbare polymorphe Verbindung im Backend - sie kriecht in REST.  So sollte es passieren, aber es kann getarnt werden.  Sie können es nicht in der JSON-API verschleiern - es wird herauskommen. <br><br>  <strong>Komplexe Viele-zu-Viele-Beziehungen mit erweiterten Optionen</strong> .  Außerdem kommen alle Verbindungstische heraus: <br><br> <code>01. GET /users?include <b><font color="#c6e90e">=users_comments</font></b> /1.1 <br> 02. <br> 03. ... <br> 04. "relationships": { <br> 05. "users_comments": { <br> 06.  "data": [{ "type": "users_comments", "id": "1″ }, ...] <br> 07. }, <br> 08. }</code> <br> <br><h2>  Prahlerei <br></h2><br>  Swagger ist ein Online-Tool zum Schreiben von Dokumentationen. <br><br>  Angenommen, unser Backend-Entwickler wurde gebeten, eine Dokumentation für seine API zu schreiben, und er hat sie geschrieben.  Dies ist einfach, wenn die API einfach ist.  Wenn dies eine JSON-API ist, kann Swagger nicht so einfach geschrieben werden. <br><br>  <strong>Beispiel:</strong> Swagger Tierhandlung.  Jede Methode kann geöffnet werden, siehe Antwort und Beispiele. <br><br><img src="https://habrastorage.org/webt/ul/lj/yk/ulljykpo7bhyw85r9ru69k2nuxe.png"><br><br>  Dies ist ein Beispiel für ein Haustiermodell.  Hier ist eine coole Oberfläche, alles ist leicht zu lesen. <br><br><img src="https://habrastorage.org/webt/i9/rg/ir/i9rgirjcdxgm16ogmtopu6dnjrq.png"><br><br>  Und so sieht die Erstellung des JSON-API-Modells aus: <br><br><img src="https://habrastorage.org/webt/ty/14/kn/ty14knt_laxzsr2ozusbo0xkk0c.png"><br><br>  Das ist nicht so toll.  Wir brauchen Daten, in Daten etwas mit Beziehungen, enthalten enthält 5 Arten von Modellen, etc.  Sie können Swagger schreiben, die Open API ist eine mächtige Sache, aber kompliziert. <br><br><h2>  Alternative <br></h2><br>  Es gibt eine OData-Spezifikation, die etwas später erschien - im Jahr 2015.  Dies ist „der beste Weg zum RESTEN“, wie die offizielle Website versichert.  Es sieht so aus: <br><br>  <code>01. GET http://services.odata.org/v4/TripRW/People HTTP/1.1</code> - GET-Anforderung; <br>  <code>02. OData-Version: 4.0</code> - spezieller Header mit Version; <br>  <code>03. OData-MaxVersion: 4.0</code> - Zweiter spezieller Versionsheader <br><br>  Die Antwort sieht so aus: <br><br> <code>01. HTTP/1.1 200 OK <br> 02. Content-Type: application/json; odata.metadata=minimal <br> 03. OData-Version: 4.0 <br> 04. { <br> 05. '@odata.context': 'http://services.odata.org/V4/ <br> 06. '@odata.nextLink' : 'http://services.odata.org/V4/ <br> 07. 'value': [{ <br> 08.  '@odata.etag': 1W/108D1D5BD423E51581′, <br> 09.  'UserName': 'russellwhyte', <br> 10.  ... <br></code> <br>  Hier ist die erweiterte Anwendung / json und das Objekt. <br><br>  Erstens haben wir OData nicht verwendet, da es mit der JSON-API identisch ist, aber nicht präzise.  Es gibt riesige Objekte und es scheint mir, dass alles viel schlechter gelesen ist.  OData wurde auch in Open Source veröffentlicht, ist aber komplizierter. <br><br><h2>  Was ist mit GraphQL? <br></h2><br>  Als wir nach einem neuen API-Format suchten, stießen wir natürlich auf diesen Hype. <br><br>  ● <strong>Hohe Eintrittsschwelle.</strong> <br><br>  Aus Sicht des Frontends sieht alles cool aus, aber Sie können den neuen Entwickler nicht dazu bringen, GraphQL zu schreiben, da Sie es zuerst studieren müssen.  Es ist wie bei SQL - Sie können SQL nicht sofort schreiben, Sie müssen zumindest lesen, was es ist, die Tutorials durchgehen, dh der Einstiegsschwellenwert erhöht sich. <br><br>  ● <strong>Die Wirkung des Urknalls.</strong> <br><br>  Wenn das Projekt keine API enthielt und wir anfingen, GraphQL zu verwenden, stellten wir nach einem Monat fest, dass es nicht zu uns passt, es wird zu spät sein.  Ich muss Krücken schreiben.  Sie können sich mit der JSON-API oder OData weiterentwickeln - das einfachste RESTful, das sich schrittweise verbessert, wird zu einer JSON-API. <br><br>  ● <strong>Hölle im Backend.</strong> <br><br>  GraphQL ruft im Backend die Hölle auf - eins zu eins, genau wie die vollständig implementierte JSON-API, da GraphQL die volle Kontrolle über Abfragen erhält und dies eine Bibliothek ist und Sie viele Probleme lösen müssen: <br><br><ul><li>  Verschachtelungskontrolle; </li><li>  Rekursion </li><li>  Frequenzbegrenzung; </li><li>  Zugangskontrolle. </li></ul><br><h2>  Anstelle von Schlussfolgerungen <br></h2><br>  Ich empfehle, nicht mehr über den Fahrradschuppen zu streiten, sondern das Anti-Bikeshedding-Tool als Spezifikation zu verwenden und einfach eine API mit einer guten Spezifikation zu erstellen. <br><br>  Unter den folgenden Links finden Sie Ihren Standard zur Lösung des Problems eines Fahrradschuppens: <br><br>  ● <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://jsonapi.org</a> <br>  ● <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://www.odata.org</a> <br>  ● <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://graphgl.org</a> <br>  ● <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://xmlrpc.scripting.com</a> <br> ● <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.jsonrpc.org</a> <br><br> <strong>   :</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">alexey-avdeev.com</a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github</a> . <br><br><blockquote> ,  <strong>  </strong>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frontend Conf</a> ,   27  28    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">++</a> .     ,        . <br><br> <strong>   ?</strong>      ?        ?    ,        ? <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ! <br><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,  ,   ,    ,      . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433322/">https://habr.com/ru/post/de433322/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433306/index.html">Visual Studio 2019</a></li>
<li><a href="../de433308/index.html">Übertragen der PBX-Konfiguration an den 3CX PBX Express-Dienst</a></li>
<li><a href="../de433316/index.html">Design Digest: Onboarding, Feedback, Suche nach Ideen und Entscheidungsfindung</a></li>
<li><a href="../de433318/index.html">garbage.collect ()</a></li>
<li><a href="../de433320/index.html">Rasterlayout als Basis moderner Layouts</a></li>
<li><a href="../de433324/index.html">Mit Webpack das Traumbündel sammeln</a></li>
<li><a href="../de433326/index.html">Codequalität</a></li>
<li><a href="../de433328/index.html">Besser einen Tag verlieren</a></li>
<li><a href="../de433330/index.html">Lösen Sie japanische Kreuzworträtsel mit SAT Solver</a></li>
<li><a href="../de433332/index.html">Python-Unterstützung in Azure-Funktionen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>