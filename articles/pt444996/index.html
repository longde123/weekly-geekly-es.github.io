<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüè≠ üéá üßõüèæ Redis Streams como uma estrutura de dados limpa üèÇüèª üë®üèæ‚Äçüåæ üòÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A nova estrutura de dados do Redis 5, chamada de fluxos, despertou grande interesse na comunidade. De alguma forma, conversarei com quem usa fluxos na...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Redis Streams como uma estrutura de dados limpa</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444996/">  A nova estrutura de dados do Redis 5, chamada de fluxos, despertou grande interesse na comunidade.  De alguma forma, conversarei com quem usa fluxos na produ√ß√£o e escreverei sobre isso.  Mas agora eu quero considerar um t√≥pico um pouco diferente.  Parece-me que muitas pessoas pensam nos fluxos como uma esp√©cie de ferramenta surreal para resolver tarefas terrivelmente dif√≠ceis.  De fato, essa estrutura de dados * tamb√©m * fornece mensagens, mas ser√° uma simplifica√ß√£o incr√≠vel supor que a funcionalidade do Redis Streams seja limitada apenas por isso. <br><br>  Os fluxos s√£o um excelente modelo e "modelo mental" que podem ser usados ‚Äã‚Äãcom grande sucesso no design do sistema, mas, na realidade, os fluxos, como a maioria das estruturas de dados Redis, s√£o uma estrutura mais geral e podem ser usados ‚Äã‚Äãpara v√°rias outras tarefas.  Neste artigo, apresentaremos os fluxos como uma estrutura de dados pura, ignorando completamente as opera√ß√µes de bloqueio, grupos de destinat√°rios e todas as outras funcionalidades de mensagens. <br><a name="habracut"></a><br><h1>  Streams - este √© CSV em ester√≥ides </h1><br>  Se voc√™ deseja registrar v√°rios elementos de dados estruturados e considerar que o banco de dados ser√° um excesso aqui, basta abrir o arquivo no modo <code>append only</code> e escrever cada linha como um CSV (valor separado por v√≠rgula): <br><br><pre> <code class="plaintext hljs">(open data.csv in append only) time=1553096724033,cpu_temp=23.4,load=2.3 time=1553096725029,cpu_temp=23.2,load=2.1</code> </pre> <br>  Parece simples.  As pessoas j√° fizeram isso h√° muito tempo e ainda o fazem: √© um modelo confi√°vel, se voc√™ sabe o que √© o qu√™.  Mas qual ser√° o equivalente na mem√≥ria?  Na mem√≥ria, o processamento de dados muito mais avan√ßado se torna poss√≠vel e muitas restri√ß√µes de arquivos CSV s√£o removidas automaticamente, como: <br><br><ol><li>  √â dif√≠cil (ineficiente) atender √†s solicita√ß√µes de intervalo. <br></li><li>  Muitas informa√ß√µes redundantes: cada registro tem quase o mesmo tempo e os campos s√£o duplicados.  Ao mesmo tempo, a exclus√£o de dados tornar√° o formato menos flex√≠vel se eu quiser mudar para um conjunto diferente de campos. <br></li><li>  As compensa√ß√µes de elementos s√£o simplesmente compensa√ß√µes de bytes no arquivo: se alterarmos a estrutura do arquivo, as compensa√ß√µes ficar√£o erradas, portanto n√£o h√° um conceito real de um identificador prim√°rio.  As entradas em ess√™ncia n√£o podem ser apresentadas sem ambiguidade. <br></li><li>  Sem a capacidade de coletar lixo e sem reescrever o log, voc√™ n√£o pode excluir entradas, mas apenas marc√°-las como inv√°lidas.  Reescrever logs geralmente √© p√©ssimo por v√°rios motivos, √© aconselh√°vel evit√°-lo. </li></ol><br>  Ao mesmo tempo, esse registro CSV √© bom √† sua maneira: n√£o h√° estrutura fixa, os campos podem mudar, √© trivial ger√°-lo e √© bastante compacto.  A id√©ia com os fluxos Redis era preservar virtudes, mas superar limita√ß√µes.  O resultado √© uma estrutura de dados h√≠brida muito semelhante aos conjuntos classificados Redis: eles * se parecem com * a estrutura de dados fundamental, mas usam v√°rias representa√ß√µes internas para obter esse efeito. <br><br><h1>  Introdu√ß√£o aos threads (voc√™ pode pular se j√° estiver familiarizado com o b√°sico) </h1><br>  Os fluxos Redis s√£o representados como n√≥s de macro compactados em delta conectados por uma √°rvore base.  Como resultado, voc√™ pode procurar rapidamente registros aleat√≥rios, obter intervalos, excluir elementos antigos, etc. Ao mesmo tempo, a interface do programador √© muito semelhante a um arquivo CSV: <br><br><pre> <code class="plaintext hljs">&gt; XADD mystream * cpu-temp 23.4 load 2.3 "1553097561402-0" &gt; XADD mystream * cpu-temp 23.2 load 2.1 "1553097568315-0"</code> </pre> <br>  Como voc√™ pode ver no exemplo, o comando XADD gera e retorna automaticamente o identificador do registro, que aumenta monotonicamente e consiste em duas partes: &lt;time&gt; - &lt;counter&gt;.  Tempo em milissegundos e o contador √© incrementado para registros com o mesmo tempo. <br><br>  Portanto, a primeira nova abstra√ß√£o para a id√©ia de um arquivo CSV no modo <code>append only</code> √© usar o asterisco como o argumento de ID para o XADD: √© assim que obtemos o identificador de registro do servidor gratuitamente.  Esse identificador √© √∫til n√£o apenas para indicar um elemento espec√≠fico no fluxo, mas tamb√©m est√° associado √† hora em que o registro foi adicionado ao fluxo.  De fato, com o XRANGE, voc√™ pode executar consultas de intervalo ou recuperar elementos individuais: <br><br><pre> <code class="plaintext hljs">&gt; XRANGE mystream 1553097561402-0 1553097561402-0 1) 1) "1553097561402-0" 2) 1) "cpu-temp" 2) "23.4" 3) "load" 4) "2.3"</code> </pre> <br>  Nesse caso, usei o mesmo ID para iniciar e finalizar o intervalo para identificar um item.  No entanto, eu posso usar qualquer argumento range e COUNT para limitar o n√∫mero de resultados.  Da mesma forma, n√£o h√° necessidade de especificar identificadores completos para um intervalo, posso simplesmente usar apenas o tempo unix para obter elementos em um determinado intervalo de tempo: <br><br><pre> <code class="plaintext hljs">&gt; XRANGE mystream 1553097560000 1553097570000 1) 1) "1553097561402-0" 2) 1) "cpu-temp" 2) "23.4" 3) "load" 4) "2.3" 2) 1) "1553097568315-0" 2) 1) "cpu-temp" 2) "23.2" 3) "load" 4) "2.1"</code> </pre> <br>  No momento, n√£o h√° necessidade de mostrar outros recursos da API, h√° documenta√ß√£o para isso.  Por enquanto, vamos nos concentrar neste padr√£o de uso: XADD para adicionar, XRANGE (e tamb√©m XREAD) para extrair intervalos (dependendo do que voc√™ deseja fazer) e vamos ver por que os fluxos s√£o t√£o poderosos que os chamam de estruturas de dados. <br><br>  Se voc√™ quiser saber mais sobre fluxos e APIs, leia o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tutorial</a> . <br><br><h1>  Tenistas </h1><br>  Alguns dias atr√°s, um amigo meu que come√ßou a estudar Redis e eu simulamos um aplicativo para rastrear quadras de t√™nis, jogadores e partidas locais.  A maneira de modelar jogadores √© √≥bvia, o jogador √© um objeto pequeno, por isso precisamos apenas de um hash com teclas como o <code>player:&lt;id&gt;</code> .  Ent√£o voc√™ perceber√° imediatamente que precisa de uma maneira de acompanhar jogos em clubes de t√™nis espec√≠ficos.  Se o <code>player:1</code> e o <code>player:2</code> jogaram entre si e o <code>player:1</code> venceu, podemos enviar o seguinte registro para o stream: <br><br><pre> <code class="plaintext hljs">&gt; XADD club:1234.matches * player-a 1 player-b 2 winner 1 "1553254144387-0"</code> </pre> <br>  Uma opera√ß√£o t√£o simples nos d√°: <br><br><ol><li>  Identificador de correspond√™ncia exclusivo: ID no fluxo. <br></li><li>  N√£o h√° necessidade de criar um objeto para identifica√ß√£o de correspond√™ncia. <br></li><li>  Solicita√ß√µes de intervalo livre para correspond√™ncias de pagina√ß√£o ou assistindo correspond√™ncias para uma data e hora espec√≠ficas. </li></ol><br>  Antes que os fluxos aparecessem, ter√≠amos que criar um conjunto classificado por tempo: os elementos do conjunto classificado seriam identificadores de correspond√™ncia, que s√£o armazenados em uma chave diferente como um valor de hash.  N√£o √© apenas mais trabalho, mas tamb√©m mais mem√≥ria.  Muito, muito mais mem√≥ria (veja abaixo). <br><br>  Agora, nosso objetivo √© mostrar que os fluxos Redis s√£o uma esp√©cie de conjunto classificado no modo <code>append only</code> , com chaves por tempo, em que cada elemento √© um pequeno hash.  E, por sua simplicidade, √© uma verdadeira revolu√ß√£o no contexto da modelagem. <br><br><h1>  A mem√≥ria </h1><br>  O caso de uso acima n√£o √© apenas um padr√£o de programa√ß√£o mais coeso.  O consumo de mem√≥ria nos encadeamentos √© t√£o diferente da abordagem antiga com um conjunto ordenado + hash para cada objeto que agora come√ßam a funcionar algumas coisas que antes eram imposs√≠veis de implementar. <br><br>  Aqui est√£o as estat√≠sticas sobre a quantidade de mem√≥ria para armazenar um milh√£o de correspond√™ncias na configura√ß√£o apresentada anteriormente: <br><br><pre> <code class="plaintext hljs">  +  = 220  (242 RSS)  = 16,8  (18.11 RSS)</code> </pre> <br>  A diferen√ßa √© mais do que uma ordem de magnitude (13 vezes).  Isso significa poder trabalhar com tarefas que antes eram muito caras para serem executadas na mem√≥ria.  Agora eles s√£o bastante vi√°veis.  A m√°gica √© introduzir fluxos Redis: os n√≥s de macro podem conter v√°rios elementos que s√£o codificados de maneira muito compacta em uma estrutura de dados chamada listpack.  Essa estrutura cuidar√°, por exemplo, da codifica√ß√£o de n√∫meros inteiros na forma bin√°ria, mesmo que sejam cadeias semanticamente.  Al√©m disso, aplicamos a compacta√ß√£o delta e compactamos os mesmos campos.  No entanto, ainda √© poss√≠vel pesquisar por ID ou hora, porque esses n√≥s de macro est√£o vinculados em uma √°rvore base, que tamb√©m √© projetada com otimiza√ß√£o de mem√≥ria.  Juntos, isso explica o uso econ√¥mico da mem√≥ria, mas a parte interessante √© que, semanticamente, o usu√°rio n√£o v√™ nenhum detalhe de implementa√ß√£o que torne os threads t√£o eficientes. <br><br>  Agora vamos contar.  Se eu posso armazenar 1 milh√£o de registros em aproximadamente 18 MB de mem√≥ria, posso armazenar 10 milh√µes em 180 MB e 100 milh√µes em 1,8 GB.  Com apenas 18 GB de mem√≥ria, posso ter 1 bilh√£o de itens. <br><br><h1>  S√©ries temporais </h1><br>  √â importante observar que o exemplo acima com partidas de t√™nis √© semanticamente * muito diferente * do uso de fluxos Redis para s√©ries temporais.  Sim, logicamente ainda estamos registrando algum tipo de evento, mas h√° uma diferen√ßa fundamental.  No primeiro caso, registramos e criamos registros para renderizar objetos.  E nas s√©ries temporais, simplesmente medimos algo que acontece fora, que na verdade n√£o representa o objeto.  Voc√™ pode dizer que essa distin√ß√£o √© trivial, mas n√£o √©.  √â importante entender a id√©ia de que os threads Redis podem ser usados ‚Äã‚Äãpara criar objetos pequenos com uma ordem comum e atribuir identificadores a esses objetos. <br><br>  Mas mesmo a maneira mais simples de usar s√©ries temporais √© obviamente uma grande inova√ß√£o, porque antes do advento dos threads, Redis era praticamente impotente para fazer qualquer coisa aqui.  Caracter√≠sticas de mem√≥ria e flexibilidade de fluxos, bem como a capacidade de limitar fluxos limitados (consulte os par√¢metros XADD) s√£o ferramentas muito importantes nas m√£os do desenvolvedor. <br><br><h1>  Conclus√µes </h1><br>  Os fluxos s√£o flex√≠veis e oferecem muitos casos de uso, mas eu queria escrever um artigo muito curto para mostrar claramente exemplos e consumo de mem√≥ria.  Talvez para muitos leitores esse uso de threads fosse √≥bvio.  No entanto, conversas com desenvolvedores nos √∫ltimos meses me deixaram com a impress√£o de que muitos t√™m uma forte associa√ß√£o entre fluxos e dados de streaming, como se a estrutura de dados fosse boa apenas l√°.  Isto n√£o √© verdade.  :-) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt444996/">https://habr.com/ru/post/pt444996/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt444982/index.html">Mockito e como cozinh√°-lo</a></li>
<li><a href="../pt444984/index.html">De onde v√™m as fotos para testar os sistemas de reconhecimento facial?</a></li>
<li><a href="../pt444986/index.html">IETF aprova ACME - este √© o padr√£o para trabalhar com certificados SSL</a></li>
<li><a href="../pt444992/index.html">Erros incorporados no sistema: seu papel nas estat√≠sticas</a></li>
<li><a href="../pt444994/index.html">Sobre unidades e seu uso em computadores modernos</a></li>
<li><a href="../pt444998/index.html">A vulnerabilidade cr√≠tica dos dispositivos de suporte √† vida implantados permite que os invasores os controlem</a></li>
<li><a href="../pt445002/index.html">Como se preparar rapidamente para uma entrevista de emprego com perguntas sobre algoritmos e tecnologias</a></li>
<li><a href="../pt445004/index.html">O SQL Profiler √© perigoso?</a></li>
<li><a href="../pt445006/index.html">Microeletr√¥nica para estudantes da pr√≥pria fonte</a></li>
<li><a href="../pt445008/index.html">Exames do Azure (vers√£o revisada e revisada)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>