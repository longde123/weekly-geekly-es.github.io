<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöü üì∏ ‚èÆÔ∏è Estat√≠sticas de coment√°rios em linha do Confluence üç¢ üòÆ ü§ûüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como coletar estat√≠sticas de coment√°rios da p√°gina no Confluence? 

 Sim, e por que isso pode ser necess√°rio? 



 Porque e porque 
 No projeto em que...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estat√≠sticas de coment√°rios em linha do Confluence</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485652/">  Como coletar estat√≠sticas de coment√°rios da p√°gina no Confluence? <br><br>  Sim, e por que isso pode ser necess√°rio? <br><br><img src="https://habrastorage.org/webt/c6/7x/uo/c67xuo6sop9dd7mpzxty_i7wj7s.png"><br><a name="habracut"></a><br><h2>  Porque e porque </h2><br>  No projeto em que trabalhei, nasceu o seguinte processo de prepara√ß√£o e aprova√ß√£o de requisitos: <br><br><ul><li>  Conflu√™ncia foi usada para documenta√ß√£o. </li><li>  A equipe do fornecedor preparou descri√ß√µes dos processos de neg√≥cios e suas etapas na forma de p√°ginas separadas, de acordo com o modelo. </li><li>  Uma vez por semana, um lote de descri√ß√µes preparadas era entregue ao cliente para revis√£o. </li><li>  A equipe do cliente deixou todas as perguntas e complementos na p√°gina correspondente na forma de coment√°rios internos. </li><li>  E a equipe do fornecedor complementou o conte√∫do, respondeu a coment√°rios, corrigiu perguntas para estudos adicionais. </li><li>  Se a pergunta for respondida e o conte√∫do for atualizado ou a tarefa de estudo for corrigida, a equipe do cliente deve fechar o coment√°rio. </li><li>  As perguntas sobre um lote de documentos da semana atual devem ser encerradas quando o pr√≥ximo lote for transferido na pr√≥xima semana. </li></ul><br>  A cada semana, os gerentes de projeto t√™m a tarefa de entender o quanto o lote de documentos entregue deu certo e o que pode ser considerado condicionalmente pronto.  E os participantes da equipe de fornecedores periodicamente precisam verificar o status dos coment√°rios em seus documentos e trabalhar propositadamente com o restante.  Mas como encontr√°-los?  Voc√™ pode abrir cada p√°gina, procurar o primeiro coment√°rio com seus olhos (ou com a ajuda de um <a href="https://community.atlassian.com/t5/Confluence-questions/Search-for-unresolved-inline-comments/qaq-p/971424">pequeno truque</a> ) e clicar em todos os coment√°rios, porque  a equipe do cliente n√£o tem pressa em fech√°-los, pense em cada um e verifique se h√° uma resposta. <br><br>  O lote semanal cont√©m de 50 a 100 p√°ginas separadas, e fazer isso com as m√£os √© uma quantidade significativa de trabalho.  E se voc√™ ainda tenta coletar argumentos para convencer o outro lado, fica muito triste.  E tamb√©m h√° coment√°rios pendentes que resultam da edi√ß√£o imprecisa da p√°gina quando o texto de origem √© exclu√≠do acidentalmente.  Esse coment√°rio √© vis√≠vel nos resolvidos, mas n√£o pode ser reaberto (voc√™ pode, se recriar um marcador invis√≠vel no texto da p√°gina). <br><br>  A busca por ferramentas n√£o teve √™xito.  Al√©m disso, o Confluence √© implantado no lado do cliente, voc√™ n√£o pode instalar plug-ins, para n√£o mencionar a compra.  Nenhuma experi√™ncia em desenvolvimento de macro. <br><br>  Em algum momento, lembrei-me da <a href="https://docs.atlassian.com/ConfluenceServer/rest/7.1.0/">API REST</a> do Confluence e da experi√™ncia anterior com o uso da <a href="https://docs.atlassian.com/software/jira/docs/api/REST/7.6.1/">API Jira</a> semelhante.  Pesquisa e experimentos com fun√ß√µes de chamada no navegador mostraram que voc√™ pode acessar os coment√°rios e suas propriedades.  Em seguida, voc√™ teve que escolher uma ferramenta para automa√ß√£o e pode come√ßar a resolver.  Tenho alguma experi√™ncia na cria√ß√£o de scripts em ferramentas com maior probabilidade de estarem mais pr√≥ximas de administradores como Bash, Perl, JScript.  N√£o sou desenvolvedor, n√£o tenho ferramentas familiares ou familiares.  Eu queria tentar algo mais comum ou adequado.  Descobri um <a href="https://atlassian-python-api.readthedocs.io/en/latest/">wrapper para a API Python</a> e decidi tentar com ele. <br><br><h2>  Princ√≠pio geral </h2><br>  O problema foi formulado da seguinte maneira.  Voc√™ precisa encontrar todas as p√°ginas relacionadas a uma entrega semanal espec√≠fica.  Colete coment√°rios sobre eles em uma lista: p√°gina, link para comentar, autor e data do coment√°rio, texto-fonte na p√°gina, coment√°rio e respostas, autor e data da √∫ltima resposta, status do coment√°rio.  Al√©m disso, colete estat√≠sticas para cada p√°gina, quantos coment√°rios no total, quantos perigos, quantos est√£o abertos.  Salve tudo em uma p√°gina de estat√≠sticas especiais. <br><br>  Coloquei o Python, analise o b√°sico de como trabalhar com ele e vamos l√°.  Primeiro, crie uma conex√£o: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> atlassian <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Confluence UserLogin = <span class="hljs-string"><span class="hljs-string">'xxxxxx'</span></span> <span class="hljs-comment"><span class="hljs-comment"># input("Login: ") UserPwd = 'xxxxxx' # input("Password: ") confluenceURL = 'http://wiki.xxxxxx' confluence = Confluence( url=confluenceURL, username=UserLogin, password=UserPwd)</span></span></code> </pre> <br>  Para procurar p√°ginas de um lote semanal, decidi usar tags.  Como entreg√°-los em massa √© uma tarefa separada. <br><br><pre> <code class="python hljs">page_label = <span class="hljs-string"><span class="hljs-string">'week123'</span></span> cql = <span class="hljs-string"><span class="hljs-string">'space.key={} and label = "{}" and type = page '</span></span> <span class="hljs-string"><span class="hljs-string">'ORDER BY title '</span></span>.format(<span class="hljs-string"><span class="hljs-string">'YYY'</span></span>, page_label) pages = confluence.cql(cql, expand=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, start=<span class="hljs-number"><span class="hljs-number">0</span></span>, limit=<span class="hljs-number"><span class="hljs-number">200</span></span>)</code> </pre><br>  Ent√£o, temos uma lista de p√°ginas para verificar.  Em seguida, come√ßamos a processar cada p√°gina individual.  Coletamos a partir dos dados dela nos coment√°rios com seus par√¢metros.  Com base nesses dados, criamos estat√≠sticas sobre quantos coment√°rios existem na p√°gina e em que condi√ß√µes.  Em seguida, eliminamos o resultado de todas as p√°ginas e come√ßamos a formatar o resultado.  Criamos o corpo da p√°gina com o resultado na forma de uma tabela de estat√≠sticas e uma lista detalhada de coment√°rios abertos. <br><br><div class="spoiler">  <b class="spoiler_title">Processamento da lista de p√°ginas</b> <div class="spoiler_text"><pre> <code class="python hljs">statistics = [] open_comments = [] <span class="hljs-comment"><span class="hljs-comment">#  - ? if pages is not None: #    ? if pages['size'] &gt; 0: for page in pages['results']: print(page['title']) #       , #  page_comments = page_comments_data(page['content']['id']) #     statistics.append(page_statistics(page_comments)) #        #    . for comment in page_comments: if comment['Result'] not in ['resolved', 'nocomment']: if not (comment['Result'] == 'dangling' and comment['Author'] in excludeNames): open_comments.append(comment) #       . statistics.append(total_statistics(statistics)) #     page_id = confluence.get_page_id(space='YYY', title=page_title) #     ,    . page_body = ('&lt;p&gt;&lt;ac:structured-macro ac:name="toc" ac:schema-version="1"' '/&gt;&lt;/p&gt;' '&lt;h1&gt;Comments Statistics&lt;/h1&gt;{}' '&lt;h1&gt;Open Comments List&lt;/h1&gt;{}' ).format(create_table(statistics), create_table(open_comments)) #  if page_id is not None: status = confluence.update_page( page_id=page_id, title=page_title, body=page_body, representation='storage' )</span></span></code> </pre></div></div><br><h2>  Recursos da API </h2><br>  Agora vamos descobrir como processar a p√°gina.  Por padr√£o, a API retorna apenas informa√ß√µes b√°sicas, como um identificador ou nome da p√°gina.  Todas as propriedades adicionais devem ser especificadas explicitamente.  Eles podem ser vistos analisando o resultado da chamada.  Dados adicionais podem ser encontrados em se√ß√µes ou subse√ß√µes de _expandable.  Adicionamos o item desejado para expandir e procurar mais at√© encontrarmos os dados necess√°rios. <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de problema</b> <div class="spoiler_text"><pre> <code class="json hljs">http://wiki.xxxxxx/rest/api/content/<span class="hljs-number"><span class="hljs-number">101743895</span></span>?expand=body,children.comment { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"97517865"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"page"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"status"</span></span>: <span class="hljs-string"><span class="hljs-string">"current"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"w2019-47 comments status"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"children"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"comment"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"results"</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"limit"</span></span>: <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-attr"><span class="hljs-attr">"_links"</span></span>: {} }, <span class="hljs-attr"><span class="hljs-attr">"_links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"_expandable"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"attachment"</span></span>: <span class="hljs-string"><span class="hljs-string">"/rest/api/content/97517865/child/attachment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"page"</span></span>: <span class="hljs-string"><span class="hljs-string">"/rest/api/content/97517865/child/page"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"body"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"_expandable"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"view"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"export_view"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"styled_view"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"storage"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"anonymous_export_view"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"extensions"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"position"</span></span>: <span class="hljs-string"><span class="hljs-string">"none"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"_links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"_expandable"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"metadata"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"operations"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"restrictions"</span></span>: <span class="hljs-string"><span class="hljs-string">"/rest/api/content/97517865/restriction/byOperation"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"history"</span></span>: <span class="hljs-string"><span class="hljs-string">"/rest/api/content/97517865/history"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ancestors"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"descendants"</span></span>: <span class="hljs-string"><span class="hljs-string">"/rest/api/content/97517865/descendant"</span></span>, } }</code> </pre></div></div><br>  E h√° tamb√©m uma restri√ß√£o no n√∫mero de resultados emitidos, pagina√ß√£o.  Ele est√° configurado no lado do servidor (API?) E, no nosso caso, √© 25. Para algumas solicita√ß√µes, pode ser alterado especificando explicitamente, mas funcionar√° apenas para o n√≠vel superior.  E revelando coment√°rios para a p√°gina, obtemos todos os mesmos apenas 25, enquanto o tamanho tamb√©m √© falso.  No exemplo, havia 29 na realidade.  Conseguimos contornar a pagina√ß√£o dos coment√°rios usando uma fun√ß√£o separada no m√≥dulo Confluence - get_page_comments com a capacidade de especificar o tamanho da p√°gina. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    import re #      XML def replace_chars2(in_text): text = re.sub(r'&amp;', '&amp;', in_text) text = re.sub(r'\'', ''', text) text = re.sub(r'&lt;', '&lt;', text) text = re.sub(r'&gt;', '&gt;', text) text = re.sub(r'"', '"', text) return text</span></span></code> </pre><br>  A pr√≥xima armadilha estava esperando nas caracter√≠sticas da preserva√ß√£o e emiss√£o de caracteres especiais.  O corpo de uma p√°gina ou coment√°rio pode ser obtido em v√°rias visualiza√ß√µes: XML interno - armazenamento, HTML intermedi√°rio sem sa√≠da de macro - exibi√ß√£o e HTML com sa√≠da de macro - export_view.  Mas o t√≠tulo do t√≠tulo da p√°gina e o texto original comentado originalSelection sempre s√£o publicados em um formato adequado para leitura.  Porque  no futuro, esses dados caem no corpo da p√°gina com estat√≠sticas e, em seguida, alguns caracteres levam a erros de convers√£o.  Eu tive que escrever um procedimento de substitui√ß√£o acima. <br><br><h2>  Coment√°rios da p√°gina </h2><br>  Agora, para analisar a p√°gina.  Esse √© um procedimento que carrega uma p√°gina, coleta seus dados, extrai uma lista de coment√°rios com respostas e os coleta em correspond√™ncia.  O resultado √© uma lista de dicion√°rios, em que cada elemento da lista corresponde a um coment√°rio com respostas.  E todos os atributos deste coment√°rio est√£o nos campos correspondentes do dicion√°rio. <br><br><div class="spoiler">  <b class="spoiler_title">Processamento de p√°gina √∫nica</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">page_comments_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(page_identifier)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#,      ,  , #   , #  ,    ,    #   (). expand_text = ('body.storage,extensions.inlineProperties' ',extensions.resolution,version,children.comment' ',children.comment.version,children.comment.body.storage' ) #    .     . conf_page = confluence.get_page_by_id(page_identifier, expand='body.storage') page_title = replace_chars2(conf_page['title']) #   . link_base = conf_page['_links']['base'] page_link = link_base + conf_page['_links']['webui'] page_code = '&lt;a href="{}"&gt;{}&lt;/a&gt;'.format(page_link, page_title) #   page_comments = confluence.get_page_comments(content_id=page_identifier, start=0, limit=1000, comments = [] #    for comment in page_comments['results']: #      - . if comment['extensions']['location'] == 'footer': continue #  comment_text = comment['body']['storage']['value'] comment_result = comment['extensions']['resolution']['status'] comment_link = '&lt;a href="{}"&gt;{}&lt;/a&gt;'\ .format(link_base + comment['_links']['webui'], 'link') #  comment_link = re.sub(r'&amp;focusedCommentId=', '&amp;focusedCommentId=', comment_link) #  created_when = re.sub(r'\.000\+', ' GMT+', re.sub(r'T', ' ', comment['version']['when'])) created_by = comment['version']['by']['displayName'] orig_text = replace_chars2(comment['extensions'] ['inlineProperties']['originalSelection']) #    /. thread = '&lt;b&gt;To text: &lt;/b&gt;{}&lt;br/&gt;&lt;b&gt;At: &lt;/b&gt;{}&lt;br/&gt;&lt;b&gt;By: ' '&lt;/b&gt;{}&lt;br/&gt;{}'.format(orig_text, created_when, created_by, comment_text) last_by = '' last_when = '' #  answers = comment['children']['comment']['size'] if answers &gt; 0: for message in comment['children']['comment']['results']: #  last_when = re.sub(r'\.000\+', ' GMT+', re.sub(r'T', ' ', message['version']['when'])) last_by = message['version']['by']['displayName'] #  thread += ('&lt;br/&gt;===next===&lt;br/&gt;&lt;b&gt;At: &lt;/b&gt;{}&lt;br/&gt;&lt;b&gt;By: ' '&lt;/b&gt;{}&lt;br/&gt;{}'.format(last_when, last_by, message['body']['storage']['value']) ) #  . row_comm = {"Page": page_code, "Comment": comment_link, "Thread": thread, "Result": comment_result, "Answers count": answers, "Creation Date": created_when, "Author": created_by, "Last Date": last_when, "Last Author": last_by} comments.append(row_comm) #   ,   , #     . if len(comments) == 0: row_comm = {"Page": page_code, "Comment": 'nolink', "Thread": 'nocomment', "Result": 'nocomment', "Answers count": 0, "Creation Date": 'never', "Author": 'nobody', "Last Date": 'never', "Last Author": 'nobody'} comments.append(row_comm) return comments</span></span></code> </pre></div></div><br><h2>  Estat√≠sticas e tabelas </h2><br>  Para maior clareza da apresenta√ß√£o dos dados, coletamos estat√≠sticas sobre elas e as organizamos na forma de tabelas. <br><br><div class="spoiler">  <b class="spoiler_title">N√≥s processamos estat√≠sticas</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">page_statistics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(comments_data)</span></span></span><span class="hljs-function">:</span></span> open_count = <span class="hljs-number"><span class="hljs-number">0</span></span> dang_count = <span class="hljs-number"><span class="hljs-number">0</span></span> comment_count = len(comments_data) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> comment_count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> comment <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> comments_data: <span class="hljs-comment"><span class="hljs-comment">#     if comment['Result'] not in ['resolved', 'nocomment']: if comment['Result'] in ['open', 'reopened']: open_count += 1 if comment['Result'] == 'dangling' and comment['Author'] not in excludeNames: dang_count += 1 res_dict = {'Page': comments_data[0]['Page'], 'Total': comment_count, 'Resolved': comment_count - open_count - dang_count, 'Dangling': dang_count, 'Open': open_count} return res_dict #   def total_statistics(stat_data): total_comment = 0 total_resolved = 0 total_open = 0 total_dangling = 0 for statRow in stat_data: total_comment += statRow['Total'] total_resolved += statRow['Resolved'] total_open += statRow['Open'] total_dangling += statRow['Dangling'] res_dict = {'Page': 'All Pages Total', 'Type': '', 'Jira': '', 'Status': '', 'Total': total_comment, 'Resolved': total_resolved, 'Dangling': total_dangling, 'Open': total_open} return res_dict</span></span></code> </pre></div></div><br>  Para tornar os dados na forma de tabelas, faremos mais um procedimento.  Ele forma o c√≥digo HTML da tabela a partir da lista de dicion√°rios; como t√≠tulos, ele adiciona uma linha dos nomes das chaves do dicion√°rio e adiciona uma coluna com n√∫meros de linha. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_table</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tab_data)</span></span></span><span class="hljs-function">:</span></span> tab_start = <span class="hljs-string"><span class="hljs-string">'&lt;table style="width: 100.00%;"&gt;&lt;colgroup&gt;&lt;col /&gt;'</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;col /&gt;&lt;/colgroup&gt;&lt;tbody&gt;'</span></span> tab_end = <span class="hljs-string"><span class="hljs-string">'&lt;/tbody&gt;&lt;/table&gt;'</span></span> tab_code = tab_start + <span class="hljs-string"><span class="hljs-string">'&lt;tr&gt;'</span></span> row_num = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(tab_data) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;th&gt;Num&lt;/th&gt;'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tab_data[<span class="hljs-number"><span class="hljs-number">0</span></span>].keys(): tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;th&gt;{}&lt;/th&gt;'</span></span>.format(key) tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;/tr&gt;'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tab_data: tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;tr&gt;&lt;td&gt;{}&lt;/td&gt;'</span></span>.format(row_num) row_num += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> field <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> row.values(): tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;td&gt;{}&lt;/td&gt;'</span></span>.format(field) tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;/tr&gt;'</span></span> tab_code += tab_end + <span class="hljs-string"><span class="hljs-string">'\n'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tab_code</code> </pre><br>  Agora est√° tudo pronto.  Ap√≥s rotular e executar o script, obtemos uma p√°gina parecida com esta: <br><br><img src="https://habrastorage.org/webt/-1/if/af/-1ifafmgt3mqvbayphkq7opy4mq.png"><br><br><h2>  PS </h2>  Obviamente, isso n√£o foi tudo o que aconteceu no final.  Houve uma an√°lise de p√°ginas e uma pesquisa por uma macro com o n√∫mero da tarefa em Jira.  Havia uma marca√ß√£o autom√°tica por n√∫meros de tarefas em Jira e links deles para o Confluence.  Houve uma compara√ß√£o e verifica√ß√£o das listas de entrega semanais.  Houve uma economia de coment√°rios no Excel e a coleta de dados comuns de v√°rios arquivos semanais do Excel.  E recentemente analisando coment√°rios do Word foi adicionado. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt485652/">https://habr.com/ru/post/pt485652/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt485636/index.html">Os v√≠rus resistentes ao CRISPR constroem abrigos para proteger os genomas das enzimas que penetram no DNA</a></li>
<li><a href="../pt485640/index.html">M√©todos de oculta√ß√£o de p√°ginas da Web</a></li>
<li><a href="../pt485646/index.html">Dicas √∫teis sobre Python que voc√™ nunca conheceu antes. Parte 2</a></li>
<li><a href="../pt485648/index.html">A abordagem pit√¥nica para loops range () e enumerate ()</a></li>
<li><a href="../pt485650/index.html">T√©cnicas de redu√ß√£o de imagem do Docker</a></li>
<li><a href="../pt485654/index.html">Uma ideia tirada da f√≠sica ajuda a IA a trabalhar em dimens√µes mais altas.</a></li>
<li><a href="../pt485660/index.html">A pr√≥pria empresa de prote√ß√£o contra DDoS lan√ßou ataques DDoS, admitiu seu fundador</a></li>
<li><a href="../pt485664/index.html">Criando par√¢metros din√¢micos em um trabalho Jenkins ou como tornar sua tarefa f√°cil de usar</a></li>
<li><a href="../pt485672/index.html">Melhores pr√°ticas do Redis, parte 1</a></li>
<li><a href="../pt485682/index.html">A administra√ß√£o do tempo n√£o ajudar√°: a procrastina√ß√£o √© o problema de regular emo√ß√µes, n√£o o tempo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>