<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🏭 👸🏽 🔭 Enterprise DevOps: Wie ein großes Unternehmen Microservices sammelt 👨🏻‍🎓 💟 🤳🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 


 Netracker entwickelt und liefert seit vielen Jahren Unternehmensanwendungen für den globalen Markt von Telekommunikationsbetreib...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Enterprise DevOps: Wie ein großes Unternehmen Microservices sammelt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/netcracker/blog/421423/"><p>  Hallo allerseits! </p><br><p>  Netracker entwickelt und liefert seit vielen Jahren Unternehmensanwendungen für den globalen Markt von Telekommunikationsbetreibern.  Die Entwicklung solcher Lösungen ist ziemlich kompliziert: Hunderte von Menschen beteiligen sich an Projekten, und die Anzahl der aktiven Projekte liegt bei zehn. </p><br><p>  Früher waren die Produkte monolithisch, aber jetzt bewegen wir uns zuversichtlich in Richtung Mikroservice-Anwendungen.  DevOps stand vor einer ziemlich ehrgeizigen Aufgabe - diesen Technologiesprung zu schaffen. </p><br><p>  Als Ergebnis haben wir ein erfolgreiches Montagekonzept erhalten, das wir als Best Practice teilen möchten.  Die Beschreibung der Implementierung mit technischen Details wird sehr umfangreich sein, wir werden dies nicht im Rahmen dieses Artikels tun. </p><a name="habracut"></a><br><p>  <i>Im allgemeinen Fall ist Assemblierung die Umwandlung einiger Artefakte in andere.</i> <i><br></i> </p><br><h2>  Wer wird interessiert sein </h2><br><p>  Unternehmen, die fertige Software an eine vollständig Drittanbieterorganisation liefern und dafür bezahlt werden. </p><br><p>  So könnte eine Entwicklung ohne externe Lieferung aussehen: </p><br><ul><li>  Die IT-Abteilung des Werks entwickelt Software für ihr Unternehmen. </li><li>  Das Unternehmen ist im Outsourcing für einen ausländischen Kunden tätig.  Der Kunde kompiliert und betreibt diesen Code unabhängig auf seinem eigenen Webserver. </li><li> Das Unternehmen liefert Software an externe Kunden, jedoch unter einer Open Source-Lizenz.  Der größte Teil der Verantwortung wird dadurch entlastet. </li></ul><br><p>  Wenn Sie nicht mit externer Versorgung konfrontiert sind, erscheint vieles, was unten geschrieben steht, überflüssig oder sogar paranoid. </p><br><p>  In der Praxis muss alles in Übereinstimmung mit den internationalen Anforderungen für die verwendeten Lizenzen und Verschlüsselungen erfolgen, da sonst zumindest rechtliche Konsequenzen entstehen. </p><br><p>  Ein Beispiel für einen Verstoß besteht darin, Code aus einer Bibliothek mit einer GPL3-Lizenz zu entnehmen und in eine kommerzielle Anwendung einzubetten. </p><br><h2>  Die Entstehung von Mikrodiensten erfordert Veränderungen </h2><br><p>  Wir haben umfangreiche Erfahrungen in der Montage und Lieferung von monolithischen Anwendungen gesammelt. </p><br><p>  Mehrere Jenkins-Server, Tausende von CI-Jobs, mehrere vollautomatische Montagelinien basierend auf Jenkins, Dutzende engagierter Release-Ingenieure, eine eigene Expertengruppe für Konfigurationsmanagement. </p><br><p>  In der Vergangenheit war der Ansatz im Unternehmen folgender: Entwickler schreiben den Quellcode, und DevOps erfindet und schreibt die Konfiguration des Assembly-Systems. </p><br><p>  Als Ergebnis hatten wir zwei oder drei typische Baugruppenkonfigurationen, die für den Betrieb im Unternehmensökosystem ausgelegt waren.  Schematisch sieht es so aus: </p><br><img src="https://habrastorage.org/webt/pr/hi/rm/prhirmtpwufl-vfhheebwfaujpg.png"><br><p>  Das Build-Tool ist normalerweise Ant oder Maven, und etwas wird durch öffentlich verfügbare Plug-Ins implementiert, etwas wird selbst geschrieben.  Dies funktioniert gut, wenn ein Unternehmen einen engen Satz von Technologien verwendet. </p><br><p>  <i>Microservices unterscheiden sich von monolithischen Anwendungen hauptsächlich durch die Vielfalt der Technologien.</i> </p><br><p>  Es stellt sich heraus, dass für jede Programmiersprache viele Assembly-Konfigurationen vorhanden sind.  Eine zentrale Steuerung wird unmöglich. </p><br><p>  Es ist erforderlich, Assembly-Skripte so weit wie möglich zu vereinfachen und Entwicklern die Möglichkeit zu geben, sie unabhängig voneinander zu bearbeiten. </p><br><p>  Neben der einfachen Kompilierung und Verpackung (im Diagramm in <font color="green">Grün</font> ) enthalten diese Skripte viel Code für die Integration in das Unternehmensökosystem (im Diagramm in <font color="red">Rot</font> ). </p><br><p>  Daher wurde beschlossen, die Baugruppe als "Black Box" zu betrachten, in der eine "intelligente" Baugruppenumgebung alle Probleme außer der Kompilierung und Verpackung selbst lösen kann. </p><br><p>  Zu Beginn der Arbeit war nicht klar, wie man ein solches System bekommt.  Architekturentscheidungen für DevOps-Aufgaben zu treffen, erfordert Erfahrung und Wissen.  Wie bekomme ich sie?  Mögliche Optionen sind unten: </p><br><ul><li>  Suchen Sie im Internet nach Informationen. </li><li>  Eigene Erfahrung und Kenntnisse des DevOps-Teams.  Um dies zu erreichen, ist es gut, dieses Team von Programmierern mit vielseitiger Erfahrung zu machen. </li><li>  Erfahrungen und Kenntnisse außerhalb des DevOps-Teams.  Viele Entwickler im Unternehmen haben gute Ideen - Sie müssen sie hören.  Kommunikation ist hilfreich. </li><li>  Wir erfinden und experimentieren! </li></ul><br><h2>  Benötige ich Automatisierung? </h2><br><p>  Um diese Frage zu beantworten, müssen Sie verstehen, in welchem ​​Entwicklungsstadium sich unsere Montageansätze befinden.  Im Allgemeinen durchläuft eine Aufgabe die folgenden Ebenen. </p><br><ol><li>  Unbewusste Ebene <br><br><img width="150" src="https://habrastorage.org/webt/an/e2/uv/ane2uvhcdznwqj-bncv49oo58p8.jpeg"><br><br><p>  Wir müssen eine Versammlung pro Woche veröffentlichen, unseren Jungs geht es gut.  Das ist natürlich, warum darüber reden? </p></li><li>  Das Level des "Handwerkers", das sich schließlich in das Level des "Dodgers" verwandelt. <br><br><img width="150" src="https://habrastorage.org/webt/ck/mc/-a/ckmc-a4-76nvtsanjjwf4ilsf-i.gif"><br><br><p>  Es ist notwendig, zwei Baugruppen pro Tag stabil und fehlerfrei herzustellen.  Wir haben Vasya, er macht es cool und niemand außer ihm verbringt diese Zeit. </p></li><li>  Manufakturebene <br><br><img width="150" src="https://habrastorage.org/webt/hw/_x/57/hw_x572z1bstsfv4gcp9ntekdho.jpeg"><br><br><p>  Die Dinge sind weit gegangen.  Sie benötigen 20 Versammlungen pro Tag, Vasya kann das nicht bewältigen, und jetzt sitzt bereits ein Team von zehn Personen.  Sie haben einen Chef, Pläne, Urlaub, Krankheitstage, Motivation, Teambildung, Schulungen, Traditionen und Regeln.  Dies ist eine Spezialisierung, ihre Arbeit muss studiert werden. <br></p><br><p>  Auf dieser Ebene wird die Aufgabe vom konkreten Executor getrennt und wird so zu einem Prozess. </p><br><p>  Das Ergebnis ist eine klare, ausgearbeitete, eingeführte und hunderte Male korrigierte Beschreibung des Prozesses mit Text. </p></li><li>  Das Niveau der "automatisierten Produktion" <br><br><img width="150" src="https://habrastorage.org/webt/mw/2c/pt/mw2cptkfee3fmatsj6aw-21eka4.jpeg"><br><br><p>  Die modernen Anforderungen an Baugruppen steigen: Alles sollte schnell und zuverlässig sein, 800 Baugruppen müssen pro Tag bereitgestellt werden.  Dies ist von entscheidender Bedeutung, da das Unternehmen ohne solche Mengen Wettbewerbsvorteile verlieren wird. </p><br><p>  Es findet eine kostspielige Automatisierung statt, und einige qualifizierte DevOps können den Prozess am Laufen halten.  Eine weitere Skalierung ist kein Problem mehr. </p></li></ol><br><p>  <i>Nicht jede Aufgabe sollte die letzte Stufe der Automatisierung erreichen.</i> </p><br><p>  Oft löst ein Handwerker mit einer Befehlszeile Probleme einfach und effektiv. </p><br><p>  Die Automatisierung „friert“ den Prozess ein, senkt die Betriebskosten und erhöht die Änderungskosten. </p><br><p>  Sie können direkt zur Fahrzeugbaugruppe gehen, aber das System ist unpraktisch, hält nicht mit den Anforderungen des Unternehmens Schritt und ist infolgedessen veraltet. </p><br><h2>  Was sind die Baugruppen und warum wird das Problem nicht durch vorgefertigte Montagesysteme gelöst? <br></h2><br><img src="https://habrastorage.org/webt/0s/s1/dk/0ss1dkrnmpubpcllntnzuuwofw0.png"><br><p>  Wir verwenden die folgende Klassifizierung, um die Aggregationsebenen von Baugruppen zu bestimmen. <br><br></p><ul><li><p>  L1.  Ein kleiner unabhängiger Teil einer großen Anwendung.  Dies kann eine Komponente, ein Mikroservice oder eine Hilfsbibliothek sein.  Die L1-Assembly ist eine Lösung für lineare technische Probleme: Kompilieren, Packen, Arbeiten mit Abhängigkeiten.  Maven, Gradle, Npm, Grunzen und andere Build-Systeme leisten hier hervorragende Arbeit.  Es gibt Hunderte von ihnen. </p><p>  <i>Die L1-Montage muss mit vorgefertigten Werkzeugen von Drittanbietern erfolgen.</i> </p></li><li><p>  L2 +.  Integrationseinheiten.  L1-Entitäten werden zu größeren Formationen zusammengefasst, beispielsweise zu vollwertigen Microservice-Anwendungen.  Mehrere dieser Anwendungen können als eine einzige Lösung gebündelt werden.  Wir verwenden das Pluszeichen, da je nach Ebene der Baugruppenaggregation eine Ebene von L3 oder sogar L4 zugewiesen werden kann. </p><br><p>  Ein Beispiel für solche Assemblys in der Welt von Drittanbietern ist die Vorbereitung von Linux-Distributionen.  Metapakete dort. </p><br><p>  Neben recht komplexen technischen Aufgaben (wie dieser: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ru.wikipedia.org/wiki/Dependency_hell</a> ).  L2 + -Baugruppen sind häufig das Endprodukt und stellen daher viele Prozessanforderungen: ein System von Rechten, die Festlegung verantwortlicher Personen, das Fehlen von Rechtsfehlern, die Bereitstellung verschiedener Dokumentationen. </p><br><p>  <i>Bei L2 + werden Prozessanforderungen durch Automatisierung priorisiert.</i> </p><br><p>  Wenn die automatische Lösung nicht funktioniert, wie es für interessierte Personen bequem ist, wird sie nicht implementiert. </p><br><p>  L2 + -Baugruppen werden höchstwahrscheinlich von einem proprietären Tool ausgeführt, das speziell auf die Prozesse des Unternehmens zugeschnitten ist.  Denken Sie, Linux-Paketmanager haben sich das gerade ausgedacht? </p></li></ul><br><br><h2>  Unsere Best Practices </h2><br><h3>  Die Infrastruktur </h3><br><h4>  Permanente Verfügbarkeit von Eisen </h4><br><p>  Die gesamte Assembly-Infrastruktur befindet sich auf geschlossenen Servern im Unternehmensnetzwerk.  In einigen Fällen sind kommerzielle Cloud-Dienste möglich. <br></p><br><h4>  Autonomie </h4><br><p>  In allen CI-Prozessen ist das Internet nicht verfügbar.  Alle erforderlichen Ressourcen werden intern gespiegelt und zwischengespeichert.  Teilweise sogar github.com (danke, npm!) Die meisten dieser Probleme werden von Artifactory behoben. </p><br><p>  Daher sind wir ruhig, wenn wir Artefakte aus Maven Central löschen oder beliebte Repositories schließen.  Es gibt ein Beispiel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">community.oracle.com/community/java/javanet-forge-sunset</a> . </p><br><p>  Durch das Spiegeln wird die Montagezeit erheblich verkürzt und der Unternehmens-Internetkanal freigegeben.  Weniger kritische Netzwerkressourcen erhöhen die Build-Stabilität. </p><br><h4>  Drei Repositories für jeden Artefakttyp </h4><br><ol><li>  Dev ist ein Repository, in dem jeder Artefakte beliebigen Ursprungs veröffentlichen kann.  Hier können Sie mit grundlegend neuen Ansätzen experimentieren, ohne sie vom ersten Tag an an Unternehmensstandards anzupassen. </li><li>  Staging ist ein Repository, das nur mit einer Assembly-Pipeline gefüllt ist. </li><li>  Release - Einzelbaugruppen, bereit zur externen Lieferung.  Es ist mit einem speziellen Übertragungsvorgang mit manueller Bestätigung gefüllt. </li></ol><br><h4>  30 Tage Regel <br></h4><br><p>  Aus Dev- und Staging-Repositorys löschen wir alles, was älter als 30 Tage ist.  Dies trägt dazu bei, dass alle die gleichen Veröffentlichungsmöglichkeiten haben, indem eine begrenzte Menge an Server-Speicherplatz aufgewendet wird. </p><br><p>  Die Freigabe wird für immer gespeichert, die Archivierung erfolgt bei Bedarf. </p><br><h4>  Montageumgebung reinigen <br></h4><br><p>  Oft verbleiben nach Baugruppen Hilfsdateien im System, was sich auf andere Baugruppenprozesse auswirken kann.  Typische Beispiele: </p><br><ul><li>  Das häufigste Problem ist ein Cache, der durch eine falsche Assembly beschädigt wurde (wie mit Caches umgegangen wird, siehe unten). </li><li>  Einige Dienstprogramme, wie z. B. npm, belassen Dienstdateien im Verzeichnis $ HOME, die sich auf alle nachfolgenden Starts dieser Dienstprogramme auswirken. </li><li>  Eine bestimmte Assembly kann den gesamten Speicherplatz in einer / tmp-Partition belegen, was zu einer allgemeinen Nichtverfügbarkeit der Umgebung führt. </li></ul><br><p>  Daher ist es besser, die einheitliche Umgebung zugunsten von Docker-Containern aufzugeben.  Container sollten nur die erforderliche Software für eine bestimmte Baugruppe mit festen Versionen enthalten. </p><br><p>  DevOps verwaltet eine Sammlung von Assembly Docker-Images, die ständig aktualisiert wird.  Zuerst waren es ungefähr sechs, dann war es unter 30, dann haben wir die automatische Bilderzeugung aus der Softwareliste eingerichtet.  Geben Sie jetzt einfach Anforderungen wie require ('maven 3.3.9', 'python') an - und die Umgebung ist bereit. </p><br><h4>  Selbstdiagnose </h4><br><p>  Es ist nicht nur notwendig, die Benutzerunterstützung für Anfragen zu organisieren, sondern wir müssen das Verhalten unseres eigenen Systems selbst analysieren.  Wir sammeln ständig Protokolle und suchen in ihnen nach Stichwörtern, die Probleme anzeigen. </p><br><p>  Auf einem "Live" -System reicht es aus, 20 bis 30 reguläre Ausdrücke zu schreiben, damit Sie für jede Assembly den Grund für den Rückgang auf der Ebene angeben können: </p><br><ul><li>  Git Server Absturz </li><li>  Der Speicherplatz ist dort aufgebraucht. </li><li>  Build-Fehler aufgrund des Fehlers des Entwicklers; </li><li>  Bekannter Fehler in Docker. </li></ul><br><p>  Wenn etwas gefallen ist, aber kein einziges bekanntes Problem festgestellt wurde, ist dies eine Gelegenheit, die Sammlung von Masken aufzufüllen. </p><br><p>  Dann gehen wir zum Benutzer und sagen, dass er einen Build hat und dies kann auf diese Weise behoben werden. </p><br><p>  Sie werden überrascht sein, wie viele Probleme Benutzer nicht im Support melden.  Es ist besser, sie im Voraus und zu einem geeigneten Zeitpunkt zu reparieren.  Oft wird ein kleiner Veröffentlichungsfehler zwei Wochen lang ignoriert, und am Freitagabend stellt sich heraus, dass dies die externe Ausgabe blockiert. </p><br><h4>  Wir wählen sorgfältig aus, von welchen Systemen die Baugruppe abhängt <br></h4><br><p>  Idealerweise im Allgemeinen, um eine vollständige Autonomie der Baugruppe zu gewährleisten. Meistens ist dies jedoch unmöglich.  Für Java-basierte Assemblys benötigen Sie mindestens Artifactory zum Spiegeln - siehe oben für Autonomie.  Jedes integrierte System erhöht das Ausfallrisiko.  Es ist wünschenswert, dass alle Systeme im anständigen HA-Modus arbeiten. </p><br><h3>  Fließbandschnittstelle </h3><br><h4>  Einzelne Schnittstelle zum Aufrufen der Assembly </h4><br><p>  Wir machen jede Art von Montage mit einem System.  Baugruppen aller Ebenen (L1, L2 +) werden durch Programmcode beschrieben und über einen Jenkins-Job aufgerufen. </p><br><p>  Dieser Ansatz ist jedoch nicht ideal.  Es ist besser, die automatischen Generierungsmechanismen für Jenkins-Jobs zu verwenden: Zum Beispiel 1 Job = 1 Git-Repository oder 1 Job = 1 Git-Zweig.  Dadurch wird Folgendes erreicht: </p><br><ul><li>  Protokolle von heterogenen Baugruppen werden in einer Story auf der Jenkins-Jobseite nicht verwechselt. </li><li>  Tatsächlich erhalten Sie bequem zugewiesene Jobs für ein Team oder einen Entwickler.  Das Gefühl des Komforts kann durch Anpassen der Diagramme der Ergebnisse von Junit, Cobertura und Sonar verbessert werden. </li></ul><br><h4>  Freiheit, Technologie zu wählen <br></h4><br><p>  Das Starten des Builds ist ein Aufruf des Bash-Skripts "./build.sh".  Und dann - alle Montagesysteme, Programmiersprachen und alles andere, was zur Erfüllung einer Geschäftsaufgabe benötigt wird.  Dies bietet einen Ansatz für die Montage als Black Box. </p><br><h4>  Smart Post </h4><br><p>  Das Fließband fängt Veröffentlichungen aus der Black Box ab und legt sie bereits im Unternehmensspeicher ab.  Langweilige Probleme wie das Generieren von Docker-Image-Namen und die Auswahl des richtigen Repositorys für die Veröffentlichung werden automatisch behoben. </p><br><p>  Staging- und Release-Repositorys haben immer Ordnung.  Es ist erforderlich, die Besonderheiten von Veröffentlichungen verschiedener Typen zu unterstützen: maven, npm, file, docker. </p><br><h4>  Baugruppendeskriptor <br></h4><br><p>  Build.sh beschreibt das Kompilieren von Code, dies reicht jedoch für einen Assemblycontainer nicht aus. </p><br><p>  Sie müssen auch wissen: </p><br><ol><li>  welche Montageumgebung verwendet werden soll; </li><li>  Umgebungsvariablen in build.sh verfügbar; </li><li>  Welche Veröffentlichungen werden durchgeführt? </li><li>  andere spezifische Optionen. </li></ol><br><p>  Wir haben einen bequemen Weg gewählt, um diese Informationen in Form einer Yaml-Datei zu beschreiben, die .gitlab-ci.yaml ähnelt. </p><br><h4>  Baugruppenparametrierung <br></h4><br><p>  Der Benutzer kann beliebige Parameter angeben, ohne den Befehl git commit direkt zu Beginn der Assembly auszuführen. </p><br><p>  Wir haben dies implementiert, indem wir Umgebungsvariablen direkt über die Jenkins-Jobschnittstelle definiert haben. </p><br><p>  Zum Beispiel übertragen wir die Version der abhängigen Bibliothek in einen solchen Assembly-Parameter und definieren diese Version in einigen Fällen neu in eine experimentelle.  Ohne einen solchen Mechanismus müsste der Benutzer jedes Mal den Befehl "git commit" ausführen. </p><br><h4>  Systemportabilität <br></h4><br><p>  Sie müssen in der Lage sein, den Assemblierungsprozess nicht nur auf dem Haupt-CI-Server, sondern auch auf dem Computer des Entwicklers zu reproduzieren.  Dies hilft beim Debuggen komplexer Build-Skripte.  Außerdem ist es manchmal bequemer, Gitlab CI anstelle von Jenkins zu verwenden.  Daher muss das Build-System eine unabhängige Java-Anwendung sein.  Wir haben es als Gradle-Plugin implementiert. </p><br><h4>  Ein Artefakt kann unter verschiedenen Namen veröffentlicht werden. <br></h4><br><p>  Es gibt zwei gegensätzliche Anforderungen für die Veröffentlichung, die gleichzeitig auftreten können. </p><br><p>  Einerseits ist es für die langfristige Speicherung und Freigabeverwaltung erforderlich, die Eindeutigkeit der Namen veröffentlichter Artefakte sicherzustellen.  Dies schützt zumindest Artefakte vor dem Überschreiben. </p><br><p>  Andererseits ist es manchmal praktisch, ein tatsächliches Artefakt mit einem festen Namen wie dem neuesten zu haben.  Beispielsweise muss der Entwickler nicht jedes Mal die genaue Version der Abhängigkeit kennen, sondern kann nur mit der neuesten Version arbeiten. </p><br><p>  Das Artefakt wird in diesem Fall unter zwei oder mehr Namen veröffentlicht, da es für jeden geeignet ist. </p><br><p>  Zum Beispiel: </p><br><ol><li>  ein eindeutiger Name mit Zeitstempel oder UUID - für diejenigen, die Genauigkeit benötigen; </li><li>  der Name "neueste" - für ihre Entwickler, die immer den neuesten Code abholen; </li><li>  Der Name "&lt;Hauptversion&gt; .x-neueste" steht für ein benachbartes Team, das bereit ist, die neuesten Versionen aufzunehmen, jedoch nur im Rahmen eines bestimmten Hauptfachs. </li></ol><br><p>  Maven macht etwas Ähnliches in seiner Herangehensweise an SNAPSHOT. </p><br><h4>  Weniger Sicherheitsbeschränkungen <br></h4><br><p>  Jeder kann mit der Montage beginnen.  Dies schadet niemandem, da die Baugruppe nur Artefakte erstellt. </p><br><h3>  Einhaltung gesetzlicher Bestimmungen </h3><br><h4>  Kontrolle der externen Interaktionen des Montageprozesses </h4><br><p>  Die Baugruppe kann während ihrer Arbeit nichts Verbotenes verwenden. </p><br><p>  Zu diesem Zweck wird die Aufzeichnung des Netzwerkverkehrs und der Zugriff auf Datei-Caches implementiert.  Wir erhalten das Protokoll der Netzwerkaktivität der Assembly in Form einer URL-Liste mit sha256-Hashes der empfangenen Daten.  Außerdem wird jede URL validiert: </p><br><ol><li>  statische Whitelist; </li><li>  dynamische Datenbank zulässiger Artefakte (z. B. für Maven-, RPM-, Npm-Abhängigkeiten).  Jede Sucht wird individuell betrachtet.  Eine automatische Genehmigung oder ein Nutzungsverbot kann funktionieren, und es kann auch eine lange Diskussion mit Anwälten beginnen. </li></ol><br><h4>  Transparenter Inhalt veröffentlichter Artefakte <br></h4><br><p>  Manchmal besteht die Aufgabe darin, eine Liste von Software von Drittanbietern in jeder Baugruppe bereitzustellen.  Zu diesem Zweck haben sie einen einfachen Kompositionsanalysator erstellt, der alle Dateien und Archive in der Baugruppe analysiert, den Drittanbieter anhand von Hashes erkennt und einen Bericht erstellt. </p><br><h4>  Der ausgegebene Quellcode kann nicht aus GIT entfernt werden <br></h4><br><p>  Manchmal müssen Sie den Quellcode finden, indem Sie sich das vor zwei Jahren kompilierte binäre Artefakt ansehen.  Dazu ist es notwendig, Tags in Git automatisch mit externer Ausgabe zuzuweisen und deren Entfernung zu verbieten. </p><br><h3>  Logistik und Buchhaltung <br></h3><br><h4>  Alle Baugruppen werden in der Datenbank gespeichert. </h4><br><p>  Für diese Zwecke verwenden wir das Datei-Repository in Artifactory.  Es enthält alle unterstützenden Informationen: Wer hat es gestartet, was waren die Ergebnisse der Überprüfungen, welche Artefakte wurden veröffentlicht, welcher Git-Hash wurde verwendet usw. </p><br><h4>  Wir wissen, wie wir die Baugruppe so genau wie möglich reproduzieren können </h4><br><p>  Nach den Ergebnissen der Montage speichern wir folgende Informationen: </p><br><ul><li>  den genauen Status des gesammelten Codes; </li><li>  Mit welchen Parametern wurde der Start durchgeführt? </li><li>  welche Befehle wurden genannt; </li><li>  Welcher Zugriff auf externe Ressourcen erfolgte? </li><li>  gebrauchte Montageumgebung. </li></ul><br><p>  Bei Bedarf können wir die Frage, wie es zusammengebaut wurde, genau beantworten. </p><br><h4>  Zweiwege-Kommunikation der Versammlung mit dem JIRA-Ticket <br></h4><br><p>  Stellen Sie sicher, dass Sie die folgenden Probleme lösen können: </p><br><ol><li>  Erstellen Sie für die Montage eine Liste der darin enthaltenen JIRA-Tickets. </li><li>  Schreiben Sie in das JIRA-Ticket, in welchen Baugruppen es enthalten ist. </li></ol><br><p>  Eine enge bidirektionale Kommunikation zwischen der Assembly und dem Git-Commit wird bereitgestellt.  Und dann können Sie aus dem Text der Kommentare bereits alle Links zu JIRA herausfinden. </p><br><h3>  Geschwindigkeit </h3><br><h4>  Caches des Assembly-Systems </h4><br><p>  Das Fehlen eines Maven-Cache kann die Erstellungszeit um eine Stunde verlängern. </p><br><p>  Der Cache verletzt die Isolation der Assembly-Umgebung und die Sauberkeit der Assembly.  Dieses Problem kann gelöst werden, indem der Ursprung für jedes zwischengespeicherte Artefakt bestimmt wird.  Wir haben jede Cache-Datei mit einem https-Link verknüpft, von dem sie einmal heruntergeladen wurde.  Weiterhin verarbeiten wir das Lesen eines Caches als Netzwerkadresse. </p><br><h4>  Netzwerkressourcen-Caches </h4><br><p>  Das geografische Wachstum des Unternehmens führt dazu, dass Dateien mit einer Größe von 300 MB zwischen Kontinenten übertragen werden müssen.  Es wird viel Zeit aufgewendet, insbesondere wenn Sie dies häufig tun müssen. </p><br><p>  Git-Repositorys, Docker-Images von Assembly-Umgebungen, Dateispeicher - alles muss sorgfältig zwischengespeichert werden.  Na ja, natürlich regelmäßig sauber. </p><br><h4>  Montage - so schnell wie möglich, alles andere - dann </h4><br><p>  Die erste Phase: Wir machen die Montage und geben sofort, ohne unnötige Gesten, das Ergebnis. </p><br><p>  Die zweite Stufe: Validierung, Analyse, Buchhaltung und andere Bürokratie.  Dies kann bereits in einem separaten Jenkins-Job und ohne strenge Fristen erfolgen. </p><br><h2>  Was ist das Ergebnis? </h2><br><ol><li>  Die Hauptsache ist, dass die <i>Baugruppe den Entwicklern klar geworden ist</i> , sie können sie selbst entwickeln und optimieren. </li><li>  Die Grundlage für die Erstellung von Geschäftsprozessen wurde geschaffen, die von der Baugruppe abhängen: Installation, Issue-Management, Test, Release-Management usw. </li><li>  Das DevOps-Team schreibt keine Assembly-Skripte mehr: Entwickler tun es. </li><li>  Aus komplexen Unternehmensanforderungen wurde ein transparenter Bericht mit einer endgültigen Liste von Prüfungen. </li><li>  Jeder kann ein beliebiges Repository erstellen, indem er build.sh über eine einzige Schnittstelle aufruft.  Es reicht ihm, einfach die Git-Koordinaten des Quellcodes anzugeben.  Diese Person kann ein Teammanager, ein QA / IT-Ingenieur usw. sein. </li></ol><br><p>  Und ein paar Zahlen </p><br><ol><li>  Zeitkosten.  Vom Aufrufen des Jenkins-Jobs bis zur sofortigen Arbeit von build.sh sind weitere 15 Sekunden erforderlich.   15    docker-,   ,  .      .        . </li><li>  .         .      2200 .   —  on-commit-. </li><li>      300 git-,     . </li><li>      30   ,   (25 ) —  docker. </li><li>      ,     : <br><ol><li> glide, golang, promu; </li><li> maven, gradle; </li><li> python &amp; pip; </li><li> ruby; </li><li> nodejs &amp; npm; </li><li> docker; </li><li> rpm build tools &amp; gcc; </li><li>  Android   ADT; </li><li>  ; </li><li>    legacy-; </li><li>   . </li></ol><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421423/">https://habr.com/ru/post/de421423/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421413/index.html">Richtiger Zugriff auf Standardschnittstellenmethoden durch Reflektion in Java 8, 9, 10</a></li>
<li><a href="../de421415/index.html">Magischer Sprung - trauriger Müll</a></li>
<li><a href="../de421417/index.html">Kaffeemaschine für Kaffeesüchtige oder mobile Wacaco-Kaffeemaschine</a></li>
<li><a href="../de421419/index.html">Ode an „geschäumtes“ Nickel, nicht existierende Saphire und den stellvertretenden sowjetischen Minister: die Ikone OTTO SX-P1 in Japan, den USA und der UdSSR</a></li>
<li><a href="../de421421/index.html">LAppS: Eine halbe Million 1 KB WebSocket-Nachrichten pro Sekunde mit TLS auf einer CPU</a></li>
<li><a href="../de421425/index.html">Zähmen und konsolidieren: Die Geschichte des Wechsels zu Oracle Supercluster</a></li>
<li><a href="../de421429/index.html">LSTM - ANN Dynamische Preisgestaltung im Haushaltswareneinzelhandel</a></li>
<li><a href="../de421431/index.html">Zeitmanagement oder effektives Chaosmanagement</a></li>
<li><a href="../de421433/index.html">Es dauerte genau einen Tag, bis der Server gestartet wurde.</a></li>
<li><a href="../de421435/index.html">"Warum machen wir das alle?" - Prisma-Schöpfer und ehemaliger VK-Projektleiter über sein neues geheimes Projekt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>