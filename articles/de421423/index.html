<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüè≠ üë∏üèΩ üî≠ Enterprise DevOps: Wie ein gro√ües Unternehmen Microservices sammelt üë®üèª‚Äçüéì üíü ü§≥üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 


 Netracker entwickelt und liefert seit vielen Jahren Unternehmensanwendungen f√ºr den globalen Markt von Telekommunikationsbetreib...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Enterprise DevOps: Wie ein gro√ües Unternehmen Microservices sammelt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/netcracker/blog/421423/"><p>  Hallo allerseits! </p><br><p>  Netracker entwickelt und liefert seit vielen Jahren Unternehmensanwendungen f√ºr den globalen Markt von Telekommunikationsbetreibern.  Die Entwicklung solcher L√∂sungen ist ziemlich kompliziert: Hunderte von Menschen beteiligen sich an Projekten, und die Anzahl der aktiven Projekte liegt bei zehn. </p><br><p>  Fr√ºher waren die Produkte monolithisch, aber jetzt bewegen wir uns zuversichtlich in Richtung Mikroservice-Anwendungen.  DevOps stand vor einer ziemlich ehrgeizigen Aufgabe - diesen Technologiesprung zu schaffen. </p><br><p>  Als Ergebnis haben wir ein erfolgreiches Montagekonzept erhalten, das wir als Best Practice teilen m√∂chten.  Die Beschreibung der Implementierung mit technischen Details wird sehr umfangreich sein, wir werden dies nicht im Rahmen dieses Artikels tun. </p><a name="habracut"></a><br><p>  <i>Im allgemeinen Fall ist Assemblierung die Umwandlung einiger Artefakte in andere.</i> <i><br></i> </p><br><h2>  Wer wird interessiert sein </h2><br><p>  Unternehmen, die fertige Software an eine vollst√§ndig Drittanbieterorganisation liefern und daf√ºr bezahlt werden. </p><br><p>  So k√∂nnte eine Entwicklung ohne externe Lieferung aussehen: </p><br><ul><li>  Die IT-Abteilung des Werks entwickelt Software f√ºr ihr Unternehmen. </li><li>  Das Unternehmen ist im Outsourcing f√ºr einen ausl√§ndischen Kunden t√§tig.  Der Kunde kompiliert und betreibt diesen Code unabh√§ngig auf seinem eigenen Webserver. </li><li> Das Unternehmen liefert Software an externe Kunden, jedoch unter einer Open Source-Lizenz.  Der gr√∂√üte Teil der Verantwortung wird dadurch entlastet. </li></ul><br><p>  Wenn Sie nicht mit externer Versorgung konfrontiert sind, erscheint vieles, was unten geschrieben steht, √ºberfl√ºssig oder sogar paranoid. </p><br><p>  In der Praxis muss alles in √úbereinstimmung mit den internationalen Anforderungen f√ºr die verwendeten Lizenzen und Verschl√ºsselungen erfolgen, da sonst zumindest rechtliche Konsequenzen entstehen. </p><br><p>  Ein Beispiel f√ºr einen Versto√ü besteht darin, Code aus einer Bibliothek mit einer GPL3-Lizenz zu entnehmen und in eine kommerzielle Anwendung einzubetten. </p><br><h2>  Die Entstehung von Mikrodiensten erfordert Ver√§nderungen </h2><br><p>  Wir haben umfangreiche Erfahrungen in der Montage und Lieferung von monolithischen Anwendungen gesammelt. </p><br><p>  Mehrere Jenkins-Server, Tausende von CI-Jobs, mehrere vollautomatische Montagelinien basierend auf Jenkins, Dutzende engagierter Release-Ingenieure, eine eigene Expertengruppe f√ºr Konfigurationsmanagement. </p><br><p>  In der Vergangenheit war der Ansatz im Unternehmen folgender: Entwickler schreiben den Quellcode, und DevOps erfindet und schreibt die Konfiguration des Assembly-Systems. </p><br><p>  Als Ergebnis hatten wir zwei oder drei typische Baugruppenkonfigurationen, die f√ºr den Betrieb im Unternehmens√∂kosystem ausgelegt waren.  Schematisch sieht es so aus: </p><br><img src="https://habrastorage.org/webt/pr/hi/rm/prhirmtpwufl-vfhheebwfaujpg.png"><br><p>  Das Build-Tool ist normalerweise Ant oder Maven, und etwas wird durch √∂ffentlich verf√ºgbare Plug-Ins implementiert, etwas wird selbst geschrieben.  Dies funktioniert gut, wenn ein Unternehmen einen engen Satz von Technologien verwendet. </p><br><p>  <i>Microservices unterscheiden sich von monolithischen Anwendungen haupts√§chlich durch die Vielfalt der Technologien.</i> </p><br><p>  Es stellt sich heraus, dass f√ºr jede Programmiersprache viele Assembly-Konfigurationen vorhanden sind.  Eine zentrale Steuerung wird unm√∂glich. </p><br><p>  Es ist erforderlich, Assembly-Skripte so weit wie m√∂glich zu vereinfachen und Entwicklern die M√∂glichkeit zu geben, sie unabh√§ngig voneinander zu bearbeiten. </p><br><p>  Neben der einfachen Kompilierung und Verpackung (im Diagramm in <font color="green">Gr√ºn</font> ) enthalten diese Skripte viel Code f√ºr die Integration in das Unternehmens√∂kosystem (im Diagramm in <font color="red">Rot</font> ). </p><br><p>  Daher wurde beschlossen, die Baugruppe als "Black Box" zu betrachten, in der eine "intelligente" Baugruppenumgebung alle Probleme au√üer der Kompilierung und Verpackung selbst l√∂sen kann. </p><br><p>  Zu Beginn der Arbeit war nicht klar, wie man ein solches System bekommt.  Architekturentscheidungen f√ºr DevOps-Aufgaben zu treffen, erfordert Erfahrung und Wissen.  Wie bekomme ich sie?  M√∂gliche Optionen sind unten: </p><br><ul><li>  Suchen Sie im Internet nach Informationen. </li><li>  Eigene Erfahrung und Kenntnisse des DevOps-Teams.  Um dies zu erreichen, ist es gut, dieses Team von Programmierern mit vielseitiger Erfahrung zu machen. </li><li>  Erfahrungen und Kenntnisse au√üerhalb des DevOps-Teams.  Viele Entwickler im Unternehmen haben gute Ideen - Sie m√ºssen sie h√∂ren.  Kommunikation ist hilfreich. </li><li>  Wir erfinden und experimentieren! </li></ul><br><h2>  Ben√∂tige ich Automatisierung? </h2><br><p>  Um diese Frage zu beantworten, m√ºssen Sie verstehen, in welchem ‚Äã‚ÄãEntwicklungsstadium sich unsere Montageans√§tze befinden.  Im Allgemeinen durchl√§uft eine Aufgabe die folgenden Ebenen. </p><br><ol><li>  Unbewusste Ebene <br><br><img width="150" src="https://habrastorage.org/webt/an/e2/uv/ane2uvhcdznwqj-bncv49oo58p8.jpeg"><br><br><p>  Wir m√ºssen eine Versammlung pro Woche ver√∂ffentlichen, unseren Jungs geht es gut.  Das ist nat√ºrlich, warum dar√ºber reden? </p></li><li>  Das Level des "Handwerkers", das sich schlie√ülich in das Level des "Dodgers" verwandelt. <br><br><img width="150" src="https://habrastorage.org/webt/ck/mc/-a/ckmc-a4-76nvtsanjjwf4ilsf-i.gif"><br><br><p>  Es ist notwendig, zwei Baugruppen pro Tag stabil und fehlerfrei herzustellen.  Wir haben Vasya, er macht es cool und niemand au√üer ihm verbringt diese Zeit. </p></li><li>  Manufakturebene <br><br><img width="150" src="https://habrastorage.org/webt/hw/_x/57/hw_x572z1bstsfv4gcp9ntekdho.jpeg"><br><br><p>  Die Dinge sind weit gegangen.  Sie ben√∂tigen 20 Versammlungen pro Tag, Vasya kann das nicht bew√§ltigen, und jetzt sitzt bereits ein Team von zehn Personen.  Sie haben einen Chef, Pl√§ne, Urlaub, Krankheitstage, Motivation, Teambildung, Schulungen, Traditionen und Regeln.  Dies ist eine Spezialisierung, ihre Arbeit muss studiert werden. <br></p><br><p>  Auf dieser Ebene wird die Aufgabe vom konkreten Executor getrennt und wird so zu einem Prozess. </p><br><p>  Das Ergebnis ist eine klare, ausgearbeitete, eingef√ºhrte und hunderte Male korrigierte Beschreibung des Prozesses mit Text. </p></li><li>  Das Niveau der "automatisierten Produktion" <br><br><img width="150" src="https://habrastorage.org/webt/mw/2c/pt/mw2cptkfee3fmatsj6aw-21eka4.jpeg"><br><br><p>  Die modernen Anforderungen an Baugruppen steigen: Alles sollte schnell und zuverl√§ssig sein, 800 Baugruppen m√ºssen pro Tag bereitgestellt werden.  Dies ist von entscheidender Bedeutung, da das Unternehmen ohne solche Mengen Wettbewerbsvorteile verlieren wird. </p><br><p>  Es findet eine kostspielige Automatisierung statt, und einige qualifizierte DevOps k√∂nnen den Prozess am Laufen halten.  Eine weitere Skalierung ist kein Problem mehr. </p></li></ol><br><p>  <i>Nicht jede Aufgabe sollte die letzte Stufe der Automatisierung erreichen.</i> </p><br><p>  Oft l√∂st ein Handwerker mit einer Befehlszeile Probleme einfach und effektiv. </p><br><p>  Die Automatisierung ‚Äûfriert‚Äú den Prozess ein, senkt die Betriebskosten und erh√∂ht die √Ñnderungskosten. </p><br><p>  Sie k√∂nnen direkt zur Fahrzeugbaugruppe gehen, aber das System ist unpraktisch, h√§lt nicht mit den Anforderungen des Unternehmens Schritt und ist infolgedessen veraltet. </p><br><h2>  Was sind die Baugruppen und warum wird das Problem nicht durch vorgefertigte Montagesysteme gel√∂st? <br></h2><br><img src="https://habrastorage.org/webt/0s/s1/dk/0ss1dkrnmpubpcllntnzuuwofw0.png"><br><p>  Wir verwenden die folgende Klassifizierung, um die Aggregationsebenen von Baugruppen zu bestimmen. <br><br></p><ul><li><p>  L1.  Ein kleiner unabh√§ngiger Teil einer gro√üen Anwendung.  Dies kann eine Komponente, ein Mikroservice oder eine Hilfsbibliothek sein.  Die L1-Assembly ist eine L√∂sung f√ºr lineare technische Probleme: Kompilieren, Packen, Arbeiten mit Abh√§ngigkeiten.  Maven, Gradle, Npm, Grunzen und andere Build-Systeme leisten hier hervorragende Arbeit.  Es gibt Hunderte von ihnen. </p><p>  <i>Die L1-Montage muss mit vorgefertigten Werkzeugen von Drittanbietern erfolgen.</i> </p></li><li><p>  L2 +.  Integrationseinheiten.  L1-Entit√§ten werden zu gr√∂√üeren Formationen zusammengefasst, beispielsweise zu vollwertigen Microservice-Anwendungen.  Mehrere dieser Anwendungen k√∂nnen als eine einzige L√∂sung geb√ºndelt werden.  Wir verwenden das Pluszeichen, da je nach Ebene der Baugruppenaggregation eine Ebene von L3 oder sogar L4 zugewiesen werden kann. </p><br><p>  Ein Beispiel f√ºr solche Assemblys in der Welt von Drittanbietern ist die Vorbereitung von Linux-Distributionen.  Metapakete dort. </p><br><p>  Neben recht komplexen technischen Aufgaben (wie dieser: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ru.wikipedia.org/wiki/Dependency_hell</a> ).  L2 + -Baugruppen sind h√§ufig das Endprodukt und stellen daher viele Prozessanforderungen: ein System von Rechten, die Festlegung verantwortlicher Personen, das Fehlen von Rechtsfehlern, die Bereitstellung verschiedener Dokumentationen. </p><br><p>  <i>Bei L2 + werden Prozessanforderungen durch Automatisierung priorisiert.</i> </p><br><p>  Wenn die automatische L√∂sung nicht funktioniert, wie es f√ºr interessierte Personen bequem ist, wird sie nicht implementiert. </p><br><p>  L2 + -Baugruppen werden h√∂chstwahrscheinlich von einem propriet√§ren Tool ausgef√ºhrt, das speziell auf die Prozesse des Unternehmens zugeschnitten ist.  Denken Sie, Linux-Paketmanager haben sich das gerade ausgedacht? </p></li></ul><br><br><h2>  Unsere Best Practices </h2><br><h3>  Die Infrastruktur </h3><br><h4>  Permanente Verf√ºgbarkeit von Eisen </h4><br><p>  Die gesamte Assembly-Infrastruktur befindet sich auf geschlossenen Servern im Unternehmensnetzwerk.  In einigen F√§llen sind kommerzielle Cloud-Dienste m√∂glich. <br></p><br><h4>  Autonomie </h4><br><p>  In allen CI-Prozessen ist das Internet nicht verf√ºgbar.  Alle erforderlichen Ressourcen werden intern gespiegelt und zwischengespeichert.  Teilweise sogar github.com (danke, npm!) Die meisten dieser Probleme werden von Artifactory behoben. </p><br><p>  Daher sind wir ruhig, wenn wir Artefakte aus Maven Central l√∂schen oder beliebte Repositories schlie√üen.  Es gibt ein Beispiel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">community.oracle.com/community/java/javanet-forge-sunset</a> . </p><br><p>  Durch das Spiegeln wird die Montagezeit erheblich verk√ºrzt und der Unternehmens-Internetkanal freigegeben.  Weniger kritische Netzwerkressourcen erh√∂hen die Build-Stabilit√§t. </p><br><h4>  Drei Repositories f√ºr jeden Artefakttyp </h4><br><ol><li>  Dev ist ein Repository, in dem jeder Artefakte beliebigen Ursprungs ver√∂ffentlichen kann.  Hier k√∂nnen Sie mit grundlegend neuen Ans√§tzen experimentieren, ohne sie vom ersten Tag an an Unternehmensstandards anzupassen. </li><li>  Staging ist ein Repository, das nur mit einer Assembly-Pipeline gef√ºllt ist. </li><li>  Release - Einzelbaugruppen, bereit zur externen Lieferung.  Es ist mit einem speziellen √úbertragungsvorgang mit manueller Best√§tigung gef√ºllt. </li></ol><br><h4>  30 Tage Regel <br></h4><br><p>  Aus Dev- und Staging-Repositorys l√∂schen wir alles, was √§lter als 30 Tage ist.  Dies tr√§gt dazu bei, dass alle die gleichen Ver√∂ffentlichungsm√∂glichkeiten haben, indem eine begrenzte Menge an Server-Speicherplatz aufgewendet wird. </p><br><p>  Die Freigabe wird f√ºr immer gespeichert, die Archivierung erfolgt bei Bedarf. </p><br><h4>  Montageumgebung reinigen <br></h4><br><p>  Oft verbleiben nach Baugruppen Hilfsdateien im System, was sich auf andere Baugruppenprozesse auswirken kann.  Typische Beispiele: </p><br><ul><li>  Das h√§ufigste Problem ist ein Cache, der durch eine falsche Assembly besch√§digt wurde (wie mit Caches umgegangen wird, siehe unten). </li><li>  Einige Dienstprogramme, wie z. B. npm, belassen Dienstdateien im Verzeichnis $ HOME, die sich auf alle nachfolgenden Starts dieser Dienstprogramme auswirken. </li><li>  Eine bestimmte Assembly kann den gesamten Speicherplatz in einer / tmp-Partition belegen, was zu einer allgemeinen Nichtverf√ºgbarkeit der Umgebung f√ºhrt. </li></ul><br><p>  Daher ist es besser, die einheitliche Umgebung zugunsten von Docker-Containern aufzugeben.  Container sollten nur die erforderliche Software f√ºr eine bestimmte Baugruppe mit festen Versionen enthalten. </p><br><p>  DevOps verwaltet eine Sammlung von Assembly Docker-Images, die st√§ndig aktualisiert wird.  Zuerst waren es ungef√§hr sechs, dann war es unter 30, dann haben wir die automatische Bilderzeugung aus der Softwareliste eingerichtet.  Geben Sie jetzt einfach Anforderungen wie require ('maven 3.3.9', 'python') an - und die Umgebung ist bereit. </p><br><h4>  Selbstdiagnose </h4><br><p>  Es ist nicht nur notwendig, die Benutzerunterst√ºtzung f√ºr Anfragen zu organisieren, sondern wir m√ºssen das Verhalten unseres eigenen Systems selbst analysieren.  Wir sammeln st√§ndig Protokolle und suchen in ihnen nach Stichw√∂rtern, die Probleme anzeigen. </p><br><p>  Auf einem "Live" -System reicht es aus, 20 bis 30 regul√§re Ausdr√ºcke zu schreiben, damit Sie f√ºr jede Assembly den Grund f√ºr den R√ºckgang auf der Ebene angeben k√∂nnen: </p><br><ul><li>  Git Server Absturz </li><li>  Der Speicherplatz ist dort aufgebraucht. </li><li>  Build-Fehler aufgrund des Fehlers des Entwicklers; </li><li>  Bekannter Fehler in Docker. </li></ul><br><p>  Wenn etwas gefallen ist, aber kein einziges bekanntes Problem festgestellt wurde, ist dies eine Gelegenheit, die Sammlung von Masken aufzuf√ºllen. </p><br><p>  Dann gehen wir zum Benutzer und sagen, dass er einen Build hat und dies kann auf diese Weise behoben werden. </p><br><p>  Sie werden √ºberrascht sein, wie viele Probleme Benutzer nicht im Support melden.  Es ist besser, sie im Voraus und zu einem geeigneten Zeitpunkt zu reparieren.  Oft wird ein kleiner Ver√∂ffentlichungsfehler zwei Wochen lang ignoriert, und am Freitagabend stellt sich heraus, dass dies die externe Ausgabe blockiert. </p><br><h4>  Wir w√§hlen sorgf√§ltig aus, von welchen Systemen die Baugruppe abh√§ngt <br></h4><br><p>  Idealerweise im Allgemeinen, um eine vollst√§ndige Autonomie der Baugruppe zu gew√§hrleisten. Meistens ist dies jedoch unm√∂glich.  F√ºr Java-basierte Assemblys ben√∂tigen Sie mindestens Artifactory zum Spiegeln - siehe oben f√ºr Autonomie.  Jedes integrierte System erh√∂ht das Ausfallrisiko.  Es ist w√ºnschenswert, dass alle Systeme im anst√§ndigen HA-Modus arbeiten. </p><br><h3>  Flie√übandschnittstelle </h3><br><h4>  Einzelne Schnittstelle zum Aufrufen der Assembly </h4><br><p>  Wir machen jede Art von Montage mit einem System.  Baugruppen aller Ebenen (L1, L2 +) werden durch Programmcode beschrieben und √ºber einen Jenkins-Job aufgerufen. </p><br><p>  Dieser Ansatz ist jedoch nicht ideal.  Es ist besser, die automatischen Generierungsmechanismen f√ºr Jenkins-Jobs zu verwenden: Zum Beispiel 1 Job = 1 Git-Repository oder 1 Job = 1 Git-Zweig.  Dadurch wird Folgendes erreicht: </p><br><ul><li>  Protokolle von heterogenen Baugruppen werden in einer Story auf der Jenkins-Jobseite nicht verwechselt. </li><li>  Tats√§chlich erhalten Sie bequem zugewiesene Jobs f√ºr ein Team oder einen Entwickler.  Das Gef√ºhl des Komforts kann durch Anpassen der Diagramme der Ergebnisse von Junit, Cobertura und Sonar verbessert werden. </li></ul><br><h4>  Freiheit, Technologie zu w√§hlen <br></h4><br><p>  Das Starten des Builds ist ein Aufruf des Bash-Skripts "./build.sh".  Und dann - alle Montagesysteme, Programmiersprachen und alles andere, was zur Erf√ºllung einer Gesch√§ftsaufgabe ben√∂tigt wird.  Dies bietet einen Ansatz f√ºr die Montage als Black Box. </p><br><h4>  Smart Post </h4><br><p>  Das Flie√üband f√§ngt Ver√∂ffentlichungen aus der Black Box ab und legt sie bereits im Unternehmensspeicher ab.  Langweilige Probleme wie das Generieren von Docker-Image-Namen und die Auswahl des richtigen Repositorys f√ºr die Ver√∂ffentlichung werden automatisch behoben. </p><br><p>  Staging- und Release-Repositorys haben immer Ordnung.  Es ist erforderlich, die Besonderheiten von Ver√∂ffentlichungen verschiedener Typen zu unterst√ºtzen: maven, npm, file, docker. </p><br><h4>  Baugruppendeskriptor <br></h4><br><p>  Build.sh beschreibt das Kompilieren von Code, dies reicht jedoch f√ºr einen Assemblycontainer nicht aus. </p><br><p>  Sie m√ºssen auch wissen: </p><br><ol><li>  welche Montageumgebung verwendet werden soll; </li><li>  Umgebungsvariablen in build.sh verf√ºgbar; </li><li>  Welche Ver√∂ffentlichungen werden durchgef√ºhrt? </li><li>  andere spezifische Optionen. </li></ol><br><p>  Wir haben einen bequemen Weg gew√§hlt, um diese Informationen in Form einer Yaml-Datei zu beschreiben, die .gitlab-ci.yaml √§hnelt. </p><br><h4>  Baugruppenparametrierung <br></h4><br><p>  Der Benutzer kann beliebige Parameter angeben, ohne den Befehl git commit direkt zu Beginn der Assembly auszuf√ºhren. </p><br><p>  Wir haben dies implementiert, indem wir Umgebungsvariablen direkt √ºber die Jenkins-Jobschnittstelle definiert haben. </p><br><p>  Zum Beispiel √ºbertragen wir die Version der abh√§ngigen Bibliothek in einen solchen Assembly-Parameter und definieren diese Version in einigen F√§llen neu in eine experimentelle.  Ohne einen solchen Mechanismus m√ºsste der Benutzer jedes Mal den Befehl "git commit" ausf√ºhren. </p><br><h4>  Systemportabilit√§t <br></h4><br><p>  Sie m√ºssen in der Lage sein, den Assemblierungsprozess nicht nur auf dem Haupt-CI-Server, sondern auch auf dem Computer des Entwicklers zu reproduzieren.  Dies hilft beim Debuggen komplexer Build-Skripte.  Au√üerdem ist es manchmal bequemer, Gitlab CI anstelle von Jenkins zu verwenden.  Daher muss das Build-System eine unabh√§ngige Java-Anwendung sein.  Wir haben es als Gradle-Plugin implementiert. </p><br><h4>  Ein Artefakt kann unter verschiedenen Namen ver√∂ffentlicht werden. <br></h4><br><p>  Es gibt zwei gegens√§tzliche Anforderungen f√ºr die Ver√∂ffentlichung, die gleichzeitig auftreten k√∂nnen. </p><br><p>  Einerseits ist es f√ºr die langfristige Speicherung und Freigabeverwaltung erforderlich, die Eindeutigkeit der Namen ver√∂ffentlichter Artefakte sicherzustellen.  Dies sch√ºtzt zumindest Artefakte vor dem √úberschreiben. </p><br><p>  Andererseits ist es manchmal praktisch, ein tats√§chliches Artefakt mit einem festen Namen wie dem neuesten zu haben.  Beispielsweise muss der Entwickler nicht jedes Mal die genaue Version der Abh√§ngigkeit kennen, sondern kann nur mit der neuesten Version arbeiten. </p><br><p>  Das Artefakt wird in diesem Fall unter zwei oder mehr Namen ver√∂ffentlicht, da es f√ºr jeden geeignet ist. </p><br><p>  Zum Beispiel: </p><br><ol><li>  ein eindeutiger Name mit Zeitstempel oder UUID - f√ºr diejenigen, die Genauigkeit ben√∂tigen; </li><li>  der Name "neueste" - f√ºr ihre Entwickler, die immer den neuesten Code abholen; </li><li>  Der Name "&lt;Hauptversion&gt; .x-neueste" steht f√ºr ein benachbartes Team, das bereit ist, die neuesten Versionen aufzunehmen, jedoch nur im Rahmen eines bestimmten Hauptfachs. </li></ol><br><p>  Maven macht etwas √Ñhnliches in seiner Herangehensweise an SNAPSHOT. </p><br><h4>  Weniger Sicherheitsbeschr√§nkungen <br></h4><br><p>  Jeder kann mit der Montage beginnen.  Dies schadet niemandem, da die Baugruppe nur Artefakte erstellt. </p><br><h3>  Einhaltung gesetzlicher Bestimmungen </h3><br><h4>  Kontrolle der externen Interaktionen des Montageprozesses </h4><br><p>  Die Baugruppe kann w√§hrend ihrer Arbeit nichts Verbotenes verwenden. </p><br><p>  Zu diesem Zweck wird die Aufzeichnung des Netzwerkverkehrs und der Zugriff auf Datei-Caches implementiert.  Wir erhalten das Protokoll der Netzwerkaktivit√§t der Assembly in Form einer URL-Liste mit sha256-Hashes der empfangenen Daten.  Au√üerdem wird jede URL validiert: </p><br><ol><li>  statische Whitelist; </li><li>  dynamische Datenbank zul√§ssiger Artefakte (z. B. f√ºr Maven-, RPM-, Npm-Abh√§ngigkeiten).  Jede Sucht wird individuell betrachtet.  Eine automatische Genehmigung oder ein Nutzungsverbot kann funktionieren, und es kann auch eine lange Diskussion mit Anw√§lten beginnen. </li></ol><br><h4>  Transparenter Inhalt ver√∂ffentlichter Artefakte <br></h4><br><p>  Manchmal besteht die Aufgabe darin, eine Liste von Software von Drittanbietern in jeder Baugruppe bereitzustellen.  Zu diesem Zweck haben sie einen einfachen Kompositionsanalysator erstellt, der alle Dateien und Archive in der Baugruppe analysiert, den Drittanbieter anhand von Hashes erkennt und einen Bericht erstellt. </p><br><h4>  Der ausgegebene Quellcode kann nicht aus GIT entfernt werden <br></h4><br><p>  Manchmal m√ºssen Sie den Quellcode finden, indem Sie sich das vor zwei Jahren kompilierte bin√§re Artefakt ansehen.  Dazu ist es notwendig, Tags in Git automatisch mit externer Ausgabe zuzuweisen und deren Entfernung zu verbieten. </p><br><h3>  Logistik und Buchhaltung <br></h3><br><h4>  Alle Baugruppen werden in der Datenbank gespeichert. </h4><br><p>  F√ºr diese Zwecke verwenden wir das Datei-Repository in Artifactory.  Es enth√§lt alle unterst√ºtzenden Informationen: Wer hat es gestartet, was waren die Ergebnisse der √úberpr√ºfungen, welche Artefakte wurden ver√∂ffentlicht, welcher Git-Hash wurde verwendet usw. </p><br><h4>  Wir wissen, wie wir die Baugruppe so genau wie m√∂glich reproduzieren k√∂nnen </h4><br><p>  Nach den Ergebnissen der Montage speichern wir folgende Informationen: </p><br><ul><li>  den genauen Status des gesammelten Codes; </li><li>  Mit welchen Parametern wurde der Start durchgef√ºhrt? </li><li>  welche Befehle wurden genannt; </li><li>  Welcher Zugriff auf externe Ressourcen erfolgte? </li><li>  gebrauchte Montageumgebung. </li></ul><br><p>  Bei Bedarf k√∂nnen wir die Frage, wie es zusammengebaut wurde, genau beantworten. </p><br><h4>  Zweiwege-Kommunikation der Versammlung mit dem JIRA-Ticket <br></h4><br><p>  Stellen Sie sicher, dass Sie die folgenden Probleme l√∂sen k√∂nnen: </p><br><ol><li>  Erstellen Sie f√ºr die Montage eine Liste der darin enthaltenen JIRA-Tickets. </li><li>  Schreiben Sie in das JIRA-Ticket, in welchen Baugruppen es enthalten ist. </li></ol><br><p>  Eine enge bidirektionale Kommunikation zwischen der Assembly und dem Git-Commit wird bereitgestellt.  Und dann k√∂nnen Sie aus dem Text der Kommentare bereits alle Links zu JIRA herausfinden. </p><br><h3>  Geschwindigkeit </h3><br><h4>  Caches des Assembly-Systems </h4><br><p>  Das Fehlen eines Maven-Cache kann die Erstellungszeit um eine Stunde verl√§ngern. </p><br><p>  Der Cache verletzt die Isolation der Assembly-Umgebung und die Sauberkeit der Assembly.  Dieses Problem kann gel√∂st werden, indem der Ursprung f√ºr jedes zwischengespeicherte Artefakt bestimmt wird.  Wir haben jede Cache-Datei mit einem https-Link verkn√ºpft, von dem sie einmal heruntergeladen wurde.  Weiterhin verarbeiten wir das Lesen eines Caches als Netzwerkadresse. </p><br><h4>  Netzwerkressourcen-Caches </h4><br><p>  Das geografische Wachstum des Unternehmens f√ºhrt dazu, dass Dateien mit einer Gr√∂√üe von 300 MB zwischen Kontinenten √ºbertragen werden m√ºssen.  Es wird viel Zeit aufgewendet, insbesondere wenn Sie dies h√§ufig tun m√ºssen. </p><br><p>  Git-Repositorys, Docker-Images von Assembly-Umgebungen, Dateispeicher - alles muss sorgf√§ltig zwischengespeichert werden.  Na ja, nat√ºrlich regelm√§√üig sauber. </p><br><h4>  Montage - so schnell wie m√∂glich, alles andere - dann </h4><br><p>  Die erste Phase: Wir machen die Montage und geben sofort, ohne unn√∂tige Gesten, das Ergebnis. </p><br><p>  Die zweite Stufe: Validierung, Analyse, Buchhaltung und andere B√ºrokratie.  Dies kann bereits in einem separaten Jenkins-Job und ohne strenge Fristen erfolgen. </p><br><h2>  Was ist das Ergebnis? </h2><br><ol><li>  Die Hauptsache ist, dass die <i>Baugruppe den Entwicklern klar geworden ist</i> , sie k√∂nnen sie selbst entwickeln und optimieren. </li><li>  Die Grundlage f√ºr die Erstellung von Gesch√§ftsprozessen wurde geschaffen, die von der Baugruppe abh√§ngen: Installation, Issue-Management, Test, Release-Management usw. </li><li>  Das DevOps-Team schreibt keine Assembly-Skripte mehr: Entwickler tun es. </li><li>  Aus komplexen Unternehmensanforderungen wurde ein transparenter Bericht mit einer endg√ºltigen Liste von Pr√ºfungen. </li><li>  Jeder kann ein beliebiges Repository erstellen, indem er build.sh √ºber eine einzige Schnittstelle aufruft.  Es reicht ihm, einfach die Git-Koordinaten des Quellcodes anzugeben.  Diese Person kann ein Teammanager, ein QA / IT-Ingenieur usw. sein. </li></ol><br><p>  Und ein paar Zahlen </p><br><ol><li>  Zeitkosten.  Vom Aufrufen des Jenkins-Jobs bis zur sofortigen Arbeit von build.sh sind weitere 15 Sekunden erforderlich.   15    docker-,   ,  .      .        . </li><li>  .         .      2200 .   ‚Äî  on-commit-. </li><li>      300 git-,     . </li><li>      30   ,   (25 ) ‚Äî  docker. </li><li>      ,     : <br><ol><li> glide, golang, promu; </li><li> maven, gradle; </li><li> python &amp; pip; </li><li> ruby; </li><li> nodejs &amp; npm; </li><li> docker; </li><li> rpm build tools &amp; gcc; </li><li>  Android   ADT; </li><li>  ; </li><li>    legacy-; </li><li>   . </li></ol><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421423/">https://habr.com/ru/post/de421423/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421413/index.html">Richtiger Zugriff auf Standardschnittstellenmethoden durch Reflektion in Java 8, 9, 10</a></li>
<li><a href="../de421415/index.html">Magischer Sprung - trauriger M√ºll</a></li>
<li><a href="../de421417/index.html">Kaffeemaschine f√ºr Kaffees√ºchtige oder mobile Wacaco-Kaffeemaschine</a></li>
<li><a href="../de421419/index.html">Ode an ‚Äûgesch√§umtes‚Äú Nickel, nicht existierende Saphire und den stellvertretenden sowjetischen Minister: die Ikone OTTO SX-P1 in Japan, den USA und der UdSSR</a></li>
<li><a href="../de421421/index.html">LAppS: Eine halbe Million 1 KB WebSocket-Nachrichten pro Sekunde mit TLS auf einer CPU</a></li>
<li><a href="../de421425/index.html">Z√§hmen und konsolidieren: Die Geschichte des Wechsels zu Oracle Supercluster</a></li>
<li><a href="../de421429/index.html">LSTM - ANN Dynamische Preisgestaltung im Haushaltswareneinzelhandel</a></li>
<li><a href="../de421431/index.html">Zeitmanagement oder effektives Chaosmanagement</a></li>
<li><a href="../de421433/index.html">Es dauerte genau einen Tag, bis der Server gestartet wurde.</a></li>
<li><a href="../de421435/index.html">"Warum machen wir das alle?" - Prisma-Sch√∂pfer und ehemaliger VK-Projektleiter √ºber sein neues geheimes Projekt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>