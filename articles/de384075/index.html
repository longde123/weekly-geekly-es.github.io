<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòå üóëÔ∏è ü§≠ Kalibrierung des Ausgangspositionssensors Hinweis üèΩ üß• üîô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einige Beschleunigungssensoren erfordern nach der Montage auf der Platine eine zus√§tzliche Nullkalibrierung. Als ich mehrere Quellen mit der Kalibrier...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kalibrierung des Ausgangspositionssensors Hinweis</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/384075/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige Beschleunigungssensoren erfordern nach der Montage auf der Platine eine zus√§tzliche Nullkalibrierung. </font><font style="vertical-align: inherit;">Als ich mehrere Quellen mit der Kalibrierung von Beschleunigungssensoren sah, bei denen die G-Komponente einfach durch Subtrahieren des Wertes = 9,8 m / s2 von der Z-Achse ber√ºcksichtigt wurde, kam die Idee auf, diese Notiz zu schreiben.</font></font><br>
<br>
<img src="https://habrastorage.org/files/b4d/dcb/c3b/b4ddcbc3ba4d4e2dbd467eeab056db2d.jpg"><br>
<a name="habracut"></a><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Publikationsstruktur</font></font></h4><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problem</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erkl√§rung des Problems und der L√∂sungsmethode</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bekomme ich die Punkte?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie berechnet man die Mitte des Balls?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie kann die Suche nach der Mitte des Balls beschleunigt werden?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie kann man sonst die Suche nach der Mitte des Balls beschleunigen?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úber Messfehler</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesamt</font></font></li>
</ul><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problem</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist das Problem? MEMS-Sensoren unterliegen nach dem Einbau in die Platine geringf√ºgigen Verformungen, die Folgendes betreffen:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nullposition;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skalierung von Messwerten;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Rechtwinkligkeit der Achsen zueinander.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wenn Skalierung und Rechtwinkligkeit nicht so merklich verletzt werden, verwickelt sich die Position Null sp√ºrbar. Wenn Sie beispielsweise den typischen Wert des Nullpunktversatzes f√ºr den Beschleunigungsmesser des MPU9250-Sensors in m / s </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 √ºbersetzen</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wird dieser im Bereich von 0,2 m / s </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 erhalten</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Das hei√üt, der Sensor ist station√§r, zeigt jedoch eine Beschleunigung an und nach 5 Sekunden erhalten wir eine Geschwindigkeit von 1 m / s. Einerseits werden alle Sensordaten immer durch eine Art Filter geleitet (z. B. einen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solchen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Warum sollte der Filter diese Vorspannung jedoch st√§ndig ausgleichen? Immerhin zeigt der Sensor eine Bewegung an, wo sie nicht ist. Dies verringert die Genauigkeit des Ergebnisses. Alles in allem m√ºssen Sie den Versatzwert einmal finden und diesen Wert dann w√§hrend des Sensorbetriebs von seinen Messwerten abziehen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einfachste L√∂sung zum Ermitteln des Werts des Nullpunktversatzes, die sofort in den Sinn kommt, besteht darin, die Bedingungen zu erstellen, unter denen der Sensor genau Null anzeigen muss. Der auf dem Sensor aufgezeichnete Wert ist der Wert des Nullpunktversatzes! Damit? Aber auf den Beschleunigungsmesser wirkt st√§ndig keine Schwerkraft. Um dies zu vermeiden, ist Schwerelosigkeit erforderlich (das Werfen funktioniert nicht). Das Erdmagnetfeld wirkt auf den Kompass und seine Rotation auf das Gyroskop. Wenn Sie also kein pers√∂nliches Raumschiff haben, m√ºssen Sie sich etwas einfallen lassen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zweite L√∂sung, die sofort in den Sinn kommt, besteht darin, den Sensor (oder vielmehr seine Achse) in eine Position zu bringen, in der wir genau wissen, was der Sensor anzeigen soll. Der Unterschied zwischen dem, was der Sensor anzeigt und dem, was er anzeigen sollte - und es wird einen Nullpunktversatz geben! Damit? Zum Beispiel wissen wir, dass, wenn der Beschleunigungsmesser in einer H√∂he mit dem Horizont platziert wird, der Gravitationsbeschleunigungsvektor theoretisch genau entlang der Z-Achse des Sensors gerichtet ist. Die Gr√∂√üe des Beschleunigungsvektors, den wir kennen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt jedoch ein Problem. </font><font style="vertical-align: inherit;">Es besteht darin, dass wir die Achse des Sensors nicht genau auf eine H√∂he mit dem Horizont einstellen k√∂nnen. </font><font style="vertical-align: inherit;">Tatsache ist, dass die Oberfl√§che, auf die wir uns verlassen werden, nicht parallel zur Leiterplatte ist. </font><font style="vertical-align: inherit;">Dies ist wiederum nicht parallel zu der Stelle, an der sich der Sensor befindet. </font><font style="vertical-align: inherit;">Der Sensor selbst steht nicht genau an seiner Stelle und die Achsen im Sensor sind nicht parallel zum Sensork√∂rper. </font><font style="vertical-align: inherit;">Der Fehler beim Einstellen der Achse relativ zum Horizont um 1 Grad ergibt eine Projektion, deren Gr√∂√üe mit dem Wert des Nullpunktversatzes selbst vergleichbar ist, den wir finden m√∂chten. </font><font style="vertical-align: inherit;">Im Fall eines Magnetometers wissen wir auch nicht, wohin der Magnetfeldvektor gerichtet ist. </font><font style="vertical-align: inherit;">Theoretisch nach Norden. </font><font style="vertical-align: inherit;">In der Praxis ist das Erdmagnetfeld selbst in Intensit√§t und Richtung heterogen. </font><font style="vertical-align: inherit;">Au√üerdem nehmen Metallobjekte in der N√§he ihre Anpassungen vor.</font></font><br>
<img src="https://habrastorage.org/files/62a/4e5/7e2/62a4e57e29a24a389b1fddf12a652219.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erkl√§rung des Problems und der L√∂sungsmethode</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Aufgabe lautet wie folgt: Wir m√ºssen den Nullpunktverschiebungsvektor anhand der Sensorwerte bestimmen, die immer den Verschiebungsvektor + den konstanten externen Einflussvektor (Gravitationsbeschleunigung, Erdrotation, Erdmagnetfeld) aufzeichnen, dessen Gr√∂√üe und Richtung wir nicht kennen (im Fall des Beschleunigungsmessers) Wir kennen den Wert, aber auch hier ist die Skala des Sensors m√∂glicherweise nicht gleich 1). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Weg zu l√∂sen. </font><font style="vertical-align: inherit;">In diesem Artikel wird vorgeschlagen, den Verschiebungsvektor wie folgt zu bestimmen. </font><font style="vertical-align: inherit;">Wir nehmen und drehen den Sensor in jeder Hinsicht und registrieren die Sensorwerte. </font><font style="vertical-align: inherit;">Nach N Messungen sind die vom Sensor entnommenen und im Diagramm befindlichen Werte eine Kugel, deren Radius die Gr√∂√üe des √§u√üeren Aufpralls ist und deren Mittelpunkt der exakte gew√ºnschte Nullpunktversatz ist.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bekomme ich die Punkte?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Messvorgang selbst zu vereinfachen, k√∂nnen Sie ein einfaches Programm schreiben. </font><font style="vertical-align: inherit;">Es sollte die Sensoren aufzeichnen, wenn das Ger√§t station√§r ist. </font><font style="vertical-align: inherit;">Wir m√ºssen das Ger√§t nur in die gew√ºnschte Position drehen. </font><font style="vertical-align: inherit;">Um einen station√§ren Zustand zu bestimmen, ist auch ein nicht kalibrierter Beschleunigungsmesser geeignet - nehmen Sie einfach die Differenz zwischen dem aktuellen und dem vorherigen Wert. </font><font style="vertical-align: inherit;">Und wenn es mehr Ger√§usche gibt, korrigieren wir die Bewegung. </font><font style="vertical-align: inherit;">Mein Schwellenwert liegt im Bereich von 0,07 G. </font><font style="vertical-align: inherit;">Wenn Sie mit Ihren H√§nden halten, wird sich mehr als dieser Wert herausstellen. </font><font style="vertical-align: inherit;">Ich habe Klebeband verwendet, um die Position zu fixieren. </font><font style="vertical-align: inherit;">Wenn es immer noch nicht funktioniert, √ºberpr√ºfen Sie, ob sich in der N√§he ein K√ºhlschrank, ein Ventilator oder √§hnliches befindet.</font></font><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie kann es im Code sein</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">//       </span>
<span class="hljs-keyword">static</span> TSumSensorsData 	g_sens_data[<span class="hljs-number">2</span>];
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int32_t</span>   	g_sens_data_sum_cnt[<span class="hljs-number">2</span>];
<span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span>		g_sens_data_num;<font></font>
<font></font>
<span class="hljs-comment">//  - ,     </span>
<span class="hljs-function">IS_INTERRUPT <span class="hljs-keyword">void</span> <span class="hljs-title">on_dma_raw_ready_calibrate_step1</span><span class="hljs-params">()</span>
</span>{<font></font>
	SensorRawBuffer *raw = sensor_get_raw_buffer();<font></font>
	g_sens_data[g_sens_data_num].acc_x += swap_i16(raw-&gt;accell_x_unswap);<font></font>
	g_sens_data[g_sens_data_num].acc_y += swap_i16(raw-&gt;accell_y_unswap);<font></font>
	g_sens_data[g_sens_data_num].acc_z += swap_i16(raw-&gt;accell_z_unswap);<font></font>
	g_sens_data[g_sens_data_num].gyro_x += swap_i16(raw-&gt;gyro_x_unswap);<font></font>
	g_sens_data[g_sens_data_num].gyro_y += swap_i16(raw-&gt;gyro_y_unswap);<font></font>
	g_sens_data[g_sens_data_num].gyro_z += swap_i16(raw-&gt;gyro_z_unswap);<font></font>
	g_sens_data[g_sens_data_num].mag_x += raw-&gt;mag_x_raw * g_mag_calibrate.kx;<font></font>
	g_sens_data[g_sens_data_num].mag_y += raw-&gt;mag_y_raw * g_mag_calibrate.ky;<font></font>
	g_sens_data[g_sens_data_num].mag_z += raw-&gt;mag_z_raw * g_mag_calibrate.kz;<font></font>
	g_sens_data_sum_cnt[g_sens_data_num]++;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//   main</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sensors_calibrate_program</span><span class="hljs-params">(FlashROM *flash_ptr)</span>
</span>{
	<span class="hljs-keyword">double</span> calibrate_result_error[<span class="hljs-number">3</span>];<font></font>
	TVector16 calibrate_result[<span class="hljs-number">3</span>];
	<span class="hljs-keyword">int32_t</span> radius[ACCEL_NO_MOTION_DETECT_COUNT];
	<span class="hljs-keyword">uint8_t</span> raw_is_deleted[ACCEL_NO_MOTION_DETECT_COUNT];<font></font>
	TVector16 raw[<span class="hljs-number">3</span>][ACCEL_NO_MOTION_DETECT_COUNT];<font></font>
	<font></font>
        . . .<font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	g_sens_data_sum_cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<font></font>
	g_sens_data_num = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int16_t</span> prev_avg_x = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int16_t</span> prev_avg_y = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int16_t</span> prev_avg_z = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int8_t</span> low_motion_cnt = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">while</span>(low_motion_cnt &lt; ACCEL_NO_MOTION_DETECT_COUNT)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (g_sens_data_sum_cnt[g_sens_data_num] &gt;= ACCEL_NO_MOTION_DETECT_SAMPLES)<font></font>
		{<font></font>
			<span class="hljs-keyword">uint8_t</span> new_data_num = (g_sens_data_num + <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span>;<font></font>
			g_sens_data[new_data_num].acc_x = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].acc_y = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].acc_z = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].gyro_x = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].gyro_y = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].gyro_z = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].mag_x = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].mag_y = <span class="hljs-number">0</span>;<font></font>
			g_sens_data[new_data_num].mag_z = <span class="hljs-number">0</span>;<font></font>
			g_sens_data_sum_cnt[new_data_num] = <span class="hljs-number">0</span>;<font></font>
<font></font>
			<span class="hljs-keyword">uint8_t</span> old_data_num = g_sens_data_num;<font></font>
			g_sens_data_num = new_data_num; <span class="hljs-comment">//           </span>
			<span class="hljs-comment">// ( -    ,   )</span><font></font>
<font></font>
			<span class="hljs-comment">//     -  </span>
			<span class="hljs-keyword">int16_t</span> avg_x = g_sens_data[old_data_num].acc_x / g_sens_data_sum_cnt[old_data_num];
			<span class="hljs-keyword">int16_t</span> avg_y = g_sens_data[old_data_num].acc_y / g_sens_data_sum_cnt[old_data_num];
			<span class="hljs-keyword">int16_t</span> avg_z = g_sens_data[old_data_num].acc_z / g_sens_data_sum_cnt[old_data_num];<font></font>
<font></font>
			<span class="hljs-comment">//      </span>
			<span class="hljs-keyword">int16_t</span> dx = avg_x - prev_avg_x;
			<span class="hljs-keyword">int16_t</span> dy = avg_y - prev_avg_y;
			<span class="hljs-keyword">int16_t</span> dz = avg_z - prev_avg_z;<font></font>
			prev_avg_x = avg_x;<font></font>
			prev_avg_y = avg_y;<font></font>
			prev_avg_z = avg_z;<font></font>
<font></font>
			<span class="hljs-comment">//     </span>
			<span class="hljs-keyword">if</span> ((abs_i16(dx) &lt;= ACCEL_NO_MOTION_DETECT_AVG_VALUE)&amp;&amp;(abs_i16(dy) &lt;= ACCEL_NO_MOTION_DETECT_AVG_VALUE)&amp;&amp;(abs_i16(dz) &lt;= ACCEL_NO_MOTION_DETECT_AVG_VALUE))<font></font>
			{<font></font>
				<span class="hljs-comment">//    </span><font></font>
				raw[RAW_ACC][low_motion_cnt].x = avg_x;<font></font>
				raw[RAW_ACC][low_motion_cnt].y = avg_y;<font></font>
				raw[RAW_ACC][low_motion_cnt].z = avg_z;<font></font>
				raw[RAW_GYRO][low_motion_cnt].x = g_sens_data[old_data_num].gyro_x / g_sens_data_sum_cnt[old_data_num];<font></font>
				raw[RAW_GYRO][low_motion_cnt].y = g_sens_data[old_data_num].gyro_y / g_sens_data_sum_cnt[old_data_num];<font></font>
				raw[RAW_GYRO][low_motion_cnt].z = g_sens_data[old_data_num].gyro_z / g_sens_data_sum_cnt[old_data_num];<font></font>
				raw[RAW_MAG][low_motion_cnt].x = g_sens_data[old_data_num].mag_x / g_sens_data_sum_cnt[old_data_num];<font></font>
				raw[RAW_MAG][low_motion_cnt].y = g_sens_data[old_data_num].mag_y / g_sens_data_sum_cnt[old_data_num];<font></font>
				raw[RAW_MAG][low_motion_cnt].z = g_sens_data[old_data_num].mag_z / g_sens_data_sum_cnt[old_data_num];<font></font>
<font></font>
				low_motion_cnt++;<font></font>
<font></font>
				<span class="hljs-comment">//   </span><font></font>
				beep();<font></font>
<font></font>
				<span class="hljs-comment">//     2   ,     -   </span>
				<span class="hljs-comment">//  -  </span>
				<span class="hljs-comment">//      </span>
				delay_ms(<span class="hljs-number">2000</span>);<font></font>
			}<font></font>
		}<font></font>
	}<font></font>
. . .<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Ball in die Grafik zu bringen, m√ºssen Sie das Ger√§t mit dem Sensor nach einem bestimmten Schema drehen. </font><font style="vertical-align: inherit;">F√ºr diese Zwecke ist der Globus gut geeignet, da er einen Aufschlag hat. </font><font style="vertical-align: inherit;">Sie k√∂nnten denken, dass Sie auf der ganzen Welt formen m√ºssen. </font><font style="vertical-align: inherit;">Aber das ist nicht so.</font></font><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel f√ºr ein falsches Ergebnis</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/files/3b4/db9/bdf/3b4db9bdff434974b8616d24153755a1.png"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Sensor muss nicht auf der gesamten Erdoberfl√§che, sondern auf einem Meridian geformt werden. </font><font style="vertical-align: inherit;">Nehmen wir an, wir nehmen sieben Punkte auf dem Meridian (der erste und der letzte am Nord- und S√ºdpol). </font><font style="vertical-align: inherit;">An jedem Punkt des Meridians befestigen wir Ihr Ger√§t am Globus und drehen das Ger√§t dennoch mit einem bestimmten Schritt um seine Achse, z. B. 30-35 Grad. </font><font style="vertical-align: inherit;">Es stellt sich heraus, dass bei 12-maliger Drehung um die Achse an 7 Punkten insgesamt 84 Messungen erhalten werden. </font></font><br>
<br>
<img src="https://habrastorage.org/files/dfb/5df/1e5/dfb5df1e5107458e8560d939b6a5cd9a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Sch√∂ne an der Methode ist, dass alles ‚Äûam Knie‚Äú gemacht werden kann. </font><font style="vertical-align: inherit;">Die Positioniergenauigkeit spielt keine besondere Rolle. Sie m√ºssen sich nur gem√§√ü dem Schema drehen, damit der Vektor des externen Einflusses auf das Diagramm eine Kugel zeichnet. </font><font style="vertical-align: inherit;">Das richtige sieht ungef√§hr so ‚Äã‚Äãaus - siehe Abbildung (die Mitte ist mit einer Markierung markiert).</font></font><br>
<br>
<img src="https://habrastorage.org/files/2d4/8e8/3a3/2d48e83a3c784bdb8736b86e4b3f6d87.gif"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie berechnet man die Mitte des Balls?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist eine interessante Aufgabe und hat mehrere L√∂sungen. Es mag scheinen, dass es f√ºr die Suche nach dem Zentrum ausreicht, den arithmetischen Durchschnitt der Koordinaten der erhaltenen Punkte zu nehmen. Dies ist jedoch nicht der Fall - die Punkte k√∂nnen ungleichm√§√üig auf dem Ball liegen (siehe Abb.). </font></font><br>
<br>
<img src="https://habrastorage.org/files/eda/0cd/9d2/eda0cd9d222e401ca3898d108182fbd8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Gleichung des Balls sieht folgenderma√üen aus: (X - A) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + (Y - B) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + (Z - C) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = R </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wobei X, Y, Z die Koordinaten des auf dem Ball liegenden Punktes sind. A, B, C sind die Koordinaten des Zentrums auf der x-, y- und z-Achse. R ist der Radius der Kugel. Sie k√∂nnen ein Gleichungssystem erstellen und versuchen, dieses System einfacher mit einer Methode zu l√∂sen. Oder Sie k√∂nnen einfach pleite gehen, um das Zentrum zu finden (dies ist wie eine Methode aufeinanderfolgender Approximationen). Die Bedeutung der Methode ist einfach: der Fehlerwert (X - A) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + (Y - B) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ (Z - C) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - R </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sollte gegen Null tendieren. Dies bedeutet, dass die Summe dieser Gr√∂√üen f√ºr alle Punkte der Kugel ebenfalls gegen Null tendieren sollte. Wenn wir dies wissen, k√∂nnen wir die Werte A, B und C w√§hlen, f√ºr die der Fehler f√ºr alle Punkte minimal ist. Der Suchbereich ist durch die Gr√∂√üe des Balls (bedingter W√ºrfel) begrenzt. Das hei√üt, wir m√ºssen die Mitte des Balls nacheinander an allen Punkten des W√ºrfels platzieren und den Fehler berechnen. Wo es nur minimale Fehler gibt, gibt es das Zentrum. </font></font><br>
<br>
<img src="https://habrastorage.org/files/d53/d46/4d5/d53d464d57c0411790594a6df5a45ca1.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als R m√ºssen wir den theoretischen Wert des Vektors des √§u√üeren Einflusses nehmen - f√ºr den Beschleunigungsmesser ist dies die Beschleunigung der Schwerkraft, f√ºr den Kompass - dies ist die durchschnittliche Gr√∂√üe des Erdmagnetfeldes, f√ºr das Gyroskop - die Rotationsgeschwindigkeit der Erde. Nat√ºrlich sollte die Formel Werte einer Dimension enthalten (herk√∂mmliche Einheiten des Sensors oder m / s </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2)</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Grad / s usw.). </font><font style="vertical-align: inherit;">Es ist bequemer, in beliebige Einheiten des entsprechenden Sensors umzurechnen.</font></font><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie berechnet man einen bestimmten Wert in den Standardeinheiten des Sensors?</font></font></b><div class="spoiler_text">   =  *   / (   ‚Äî   )<br>
:      16-      ¬±2g        ?: <br>
9,8 /<sup>2</sup> * 65536 / (2g + 2g) = 9,8 /<sup>2</sup> * 65536 / (2 * 9,8 /<sup>2</sup> + 2 * 9,8 /<sup>2</sup>) = 16384 . . .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie den Radius des Balls genau kennen, k√∂nnen Sie das Zentrum √ºbrigens nur anhand seines ‚ÄûKeils‚Äú berechnen. </font><font style="vertical-align: inherit;">Das hei√üt, an Punkten, die sich nur auf einem St√ºck der Oberfl√§che der Kugel befinden. </font><font style="vertical-align: inherit;">Dies ist jedoch nicht unser Fall.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie kann die Suche nach der Mitte des Balls beschleunigt werden?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist notwendig, das Zentrum nicht im gesamten W√ºrfel (den Abmessungen der Kugel) zu suchen, sondern entlang der Linie, deren Anfang beliebig ist, wobei jeder n√§chste Punkt n√§her am realen Zentrum liegt und das Ende in der Mitte liegt. </font><font style="vertical-align: inherit;">Angenommen, wir beginnen am Punkt (0; 0; 0) ... Wir bewegen uns immer mit einem konstanten Schritt. </font><font style="vertical-align: inherit;">Wenn wir uns also einen Satz von 3x3x3-W√ºrfeln vorstellen, bei denen jede Fl√§che der Schrittgr√∂√üe entspricht, und uns auch vorstellen, dass die aktuelle Position der mittlere W√ºrfel ist, haben wir 9 + 8 + 9 Optionen, wo der n√§chste Punkt platziert werden soll. </font><font style="vertical-align: inherit;">Wir m√ºssen nur an jedem Punkt sein, um zu berechnen, in welchem ‚Äã‚Äãder benachbarten 26 Punkte der Fehler geringer sein wird. </font><font style="vertical-align: inherit;">Wenn sich herausstellt, dass der Fehler am aktuellen Punkt geringer ist und nicht an einem der benachbarten, bedeutet dies, dass er sich in der Mitte befindet und die Suche beendet ist.</font></font><br>
<br>
<img src="https://habrastorage.org/files/ba5/4dd/8d4/ba54dd8d423e4323a643cb4653361f1a.bmp"><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie kann es im Code sein</font></font></b><div class="spoiler_text"><pre><code class="vbscript hljs"><span class="hljs-keyword">Public</span> <span class="hljs-keyword">Function</span> get_err(A As Double, B As Double, C As Double, R As Double) As Double
<span class="hljs-keyword">Dim</span> x, y, z As Double
<span class="hljs-keyword">Dim</span> sigma As Double
<span class="hljs-keyword">Dim</span> row_n As Long<font></font>
get_err = <span class="hljs-number">0</span>
<span class="hljs-keyword">For</span> row_n = <span class="hljs-number">1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">15</span>
    x = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number">1</span>).Value<font></font>
    y = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number">2</span>).Value<font></font>
    z = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number">3</span>).Value<font></font>
    get_err = get_err + <span class="hljs-built_in">abs</span>( (A - x) ^ <span class="hljs-number">2</span> + (B - y) ^ <span class="hljs-number">2</span> + (C - z) ^ <span class="hljs-number">2</span> - R ^ <span class="hljs-number">2</span> )
<span class="hljs-keyword">Next</span>
<span class="hljs-keyword">End</span> <span class="hljs-keyword">Function</span><font></font>
<font></font>
. . .<font></font>
A = <span class="hljs-number">0</span>
B = <span class="hljs-number">0</span>
C = <span class="hljs-number">0</span><font></font>
<font></font>
<span class="hljs-keyword">Do</span> <span class="hljs-keyword">While</span> <span class="hljs-literal">True</span>
   min_sigma = <span class="hljs-number">0</span>
    <span class="hljs-keyword">For</span> ai = <span class="hljs-number">-1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">1</span>
        <span class="hljs-keyword">For</span> bi = <span class="hljs-number">-1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">1</span>
            <span class="hljs-keyword">For</span> ci = <span class="hljs-number">-1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">1</span>
                sigma = get_err(A + ai, B + bi, C + ci, <span class="hljs-number">16384</span>)
                <span class="hljs-keyword">If</span> sigma &lt; min_sigma <span class="hljs-keyword">Or</span> min_sigma = <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span><font></font>
                    ai_min = ai<font></font>
                    bi_min = bi<font></font>
                    ci_min = ci<font></font>
                    min_sigma = sigma<font></font>
                <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
            <span class="hljs-keyword">Next</span>
        <span class="hljs-keyword">Next</span>
    <span class="hljs-keyword">Next</span><font></font>
    <font></font>
    <span class="hljs-keyword">If</span> ai_min = <span class="hljs-number">0</span> <span class="hljs-keyword">And</span> bi_min = <span class="hljs-number">0</span> <span class="hljs-keyword">And</span> ci_min = <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span>
        <span class="hljs-keyword">Exit</span> <span class="hljs-keyword">Do</span>
    <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span><font></font>
    <font></font>
    A = A + ai_min<font></font>
    B = B + bi_min<font></font>
    C = C + ci_min<font></font>
<span class="hljs-keyword">Loop</span><font></font>
. . .<font></font>
</code></pre><br>
</div></div><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie kann man sonst die Suche nach der Mitte des Balls beschleunigen?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
M√ºssen mit variabler Tonh√∂he suchen. </font><font style="vertical-align: inherit;">Zuerst suchen wir das Zentrum in gro√üen Schritten. </font><font style="vertical-align: inherit;">Wir haben das Zentrum gefunden, wir reduzieren den Schritt und von dort aus beginnen wir weiter zu suchen. </font><font style="vertical-align: inherit;">Und so weiter, bis Sie das Ergebnis der erforderlichen Genauigkeit erhalten.</font></font><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie kann es im Code sein</font></font></b><div class="spoiler_text"><pre><code class="vbscript hljs"><span class="hljs-keyword">Public</span> <span class="hljs-keyword">Function</span> get_err(A As Double, B As Double, C As Double, R As Double) As Double
<span class="hljs-keyword">Dim</span> x, y, z As Double
<span class="hljs-keyword">Dim</span> sigma As Double
<span class="hljs-keyword">Dim</span> row_n As Long<font></font>
get_err = <span class="hljs-number">0</span>
<span class="hljs-keyword">For</span> row_n = <span class="hljs-number">1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">15</span>
    x = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number">1</span>).Value<font></font>
    y = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number">2</span>).Value<font></font>
    z = Application.ActiveWorkbook.ActiveSheet.Cells(row_n, <span class="hljs-number">3</span>).Value<font></font>
    get_err = get_err + <span class="hljs-built_in">abs</span>( (A - x) ^ <span class="hljs-number">2</span> + (B - y) ^ <span class="hljs-number">2</span> + (C - z) ^ <span class="hljs-number">2</span> - R ^ <span class="hljs-number">2</span> )
<span class="hljs-keyword">Next</span>
<span class="hljs-keyword">End</span> <span class="hljs-keyword">Function</span><font></font>
. . .<font></font>
A = <span class="hljs-number">0</span>
B = <span class="hljs-number">0</span>
C = <span class="hljs-number">0</span>
<span class="hljs-keyword">step</span> = <span class="hljs-number">1000</span>
<span class="hljs-keyword">Do</span> <span class="hljs-keyword">While</span> <span class="hljs-literal">True</span>
   min_sigma = <span class="hljs-number">0</span>
    <span class="hljs-keyword">For</span> ai = <span class="hljs-number">-1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">1</span>
        <span class="hljs-keyword">For</span> bi = <span class="hljs-number">-1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">1</span>
            <span class="hljs-keyword">For</span> ci = <span class="hljs-number">-1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">1</span>
                sigma = get_err(A + ai * <span class="hljs-keyword">step</span>, B + bi * <span class="hljs-keyword">step</span>, C + ci * <span class="hljs-keyword">step</span>, <span class="hljs-number">16384</span>)
                <span class="hljs-keyword">If</span> sigma &lt; min_sigma <span class="hljs-keyword">Or</span> min_sigma = <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span><font></font>
                    ai_min = ai<font></font>
                    bi_min = bi<font></font>
                    ci_min = ci<font></font>
                    min_sigma = sigma<font></font>
                <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
            <span class="hljs-keyword">Next</span>
        <span class="hljs-keyword">Next</span>
    <span class="hljs-keyword">Next</span>
    <span class="hljs-keyword">If</span> ai_min = <span class="hljs-number">0</span> <span class="hljs-keyword">And</span> bi_min = <span class="hljs-number">0</span> <span class="hljs-keyword">And</span> ci_min = <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span>        
        <span class="hljs-keyword">step</span> = <span class="hljs-keyword">step</span> / <span class="hljs-number">10</span>
        <span class="hljs-keyword">If</span> <span class="hljs-keyword">step</span> &lt; <span class="hljs-number">0.01</span> <span class="hljs-keyword">Then</span>
            <span class="hljs-keyword">Exit</span> <span class="hljs-keyword">Do</span>
        <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
    <span class="hljs-keyword">Else</span>
    A = A + ai_min * <span class="hljs-keyword">step</span>
    B = B + bi_min * <span class="hljs-keyword">step</span>
    C = C + ci_min * <span class="hljs-keyword">step</span>
    <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
<span class="hljs-keyword">Loop</span><font></font>
. . .<font></font>
</code></pre><br>
</div></div><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úber Messfehler</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
W√§hrend der Messungen kann es Situationen geben, in denen das Messergebnis aus irgendeinem Grund viel weiter von der Oberfl√§che der Kugel entfernt ist. Oder es k√∂nnten viele Punkte sein. Oder im Allgemeinen ist das Ergebnis von Messungen m√∂glicherweise kein Ball, sondern ein ‚ÄûEi‚Äú oder ein ‚ÄûLuftschiff‚Äú. In diesem Fall m√ºssen Sie nat√ºrlich alle Messungen wiederholen und die m√∂glichen Fehlerursachen identifizieren. Bei einem Magnetometer kann es sich beispielsweise um einen Bolzen oder einen Nagel in einem Tisch handeln, und Sie messen direkt dar√ºber. Und je tiefer Sie den Sensor entlang des Meridians absenken, desto st√§rker wirkt sich das Metall auf das Ergebnis aus. Daher ist es notwendig, den Schwellenwert des zul√§ssigen Fehlerwerts zu bestimmen. Um die Messungen aufgrund mehrerer eindeutig fehlerhafter Punkte nicht zu wiederholen, k√∂nnen Sie einen Filter anwenden. Das Prinzip des Filters ist sehr einfach: Nachdem Sie das Zentrum zum ersten Mal berechnet haben, sortieren Sie die Punkte nach der Fehlerstufe in jedem von ihnen.Einige der Punkte mit dem gr√∂√üten Fehler k√∂nnen einfach weggeworfen werden (z. B. 10%). Dann m√ºssen Sie die Suche nach dem Zentrum wiederholen.</font></font><br>
<img src="https://habrastorage.org/files/e22/c6f/b13/e22c6fb1385e4d678aabf7f1d879bc02.png"> <img src="https://habrastorage.org/files/569/40f/d17/56940fd17eef42cba93f590606bbe9e7.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesamt</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Methode hat eine ziemlich gute Genauigkeit. </font><font style="vertical-align: inherit;">Die Methode erm√∂glicht es Ihnen, mit einfachen improvisierten Mitteln (Ball, Bank usw.) zu arbeiten. </font><font style="vertical-align: inherit;">Es funktioniert schnell genug. </font><font style="vertical-align: inherit;">Einfacher Code. </font><font style="vertical-align: inherit;">Viele Sensoren haben spezielle Register, in die Sie den gefundenen Wert schreiben k√∂nnen, und der Sensor subtrahiert ihn im laufenden Betrieb. </font><font style="vertical-align: inherit;">Solche Register haben normalerweise das Pr√§fix "TRIM" wie beim MPU9260 oder "OFFSET" wie beim LSM303. </font><font style="vertical-align: inherit;">Das bekannte LIS302DL verf√ºgt jedoch nicht √ºber solche Register. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vergessen Sie nicht, ein Pluszeichen anzubringen, wenn es Ihnen gefallen hat. </font><font style="vertical-align: inherit;">Schreiben Sie in die Kommentare Ihre Methoden zur Kalibrierung von Sensoren.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de384075/">https://habr.com/ru/post/de384075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de384063/index.html">Wie Sie nicht ein paar Gigabyte Datenverkehr unbemerkt f√ºr sich selbst ausgeben, wenn Sie nicht auf Windows 10 aktualisieren m√∂chten</a></li>
<li><a href="../de384067/index.html">Mozilla verschiebt die Signaturfrist f√ºr die Firefox-Erweiterung auf den 26. Januar</a></li>
<li><a href="../de384069/index.html">Forschung: Helfen Sport√ºbungen beim Burnout?</a></li>
<li><a href="../de384071/index.html">Sony Pictures erwog den Kauf von BitTorrent im Jahr 2006</a></li>
<li><a href="../de384073/index.html">Magma Underground Ocean erkl√§rt die vulkanische Aktivit√§t auf Io</a></li>
<li><a href="../de384079/index.html">Breites Panorama des Sharpe Mountain</a></li>
<li><a href="../de384081/index.html">Weltraumfotos f√ºr die Woche (09/07/13/09)</a></li>
<li><a href="../de384083/index.html">Krieg der Welten von Stephen Hawking. Was sind die Aliens, die f√ºr Erdbewohner gef√§hrlich sind?</a></li>
<li><a href="../de384085/index.html">SpaceX hat ein Foto des Innenraums des Raumschiffs Crew Dragon gepostet</a></li>
<li><a href="../de384087/index.html">Tesla Model S P85D Auto bricht das Bewertungssystem f√ºr Verbraucherberichte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>