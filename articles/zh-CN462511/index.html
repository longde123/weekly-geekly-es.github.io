<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗣️ ⌛️ 🎸 Google Play即搜即得。 终生重构 🤲 👰 🗽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="当您参与“抢先体验计划”时，您永远不会事先知道最终会发生什么。 当然，您希望该技术能够腾飞，您的应用程序将领先于市场，并在Google I / O上获得一定的PR。 这是在初始阶段阅读源代码而不是文档的良好动机，此外，还必须从机密档案中下载文档。 

 在AppsConf上， Evgeny Satu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Google Play即搜即得。 终生重构</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/462511/"> 当您参与“抢先体验计划”时，您永远不会事先知道最终会发生什么。 当然，您希望该技术能够腾飞，您的应用程序将领先于市场，并在Google I / O上获得一定的PR。 这是在初始阶段阅读源代码而不是文档的良好动机，此外，还必须从机密档案中下载文档。 <br><br> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AppsConf上，</a> Evgeny Saturov展示了通过开发具有即时启动功能的应用程序可以导致参与Early Access，并解释了Google Play Instant的所有功能。 在解读他的报告时，我们将弄清Android App Bundle来自何处，以及Dynamic Delivery与它有什么关系，了解新的Gradle插件，并了解如何处理SDK开发人员为我们准备的惊喜。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-KUj_Kp_Xcg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  <strong>关于演讲者：</strong> Evgeny Saturov（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">saturovv</a> ）在Surf公司工作，该公司<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">专门从事</a>自定义Android和iOS开发，最近是Flutter的开发。  Eugene Flutter是FlutterDevPodcast的爱好者和创始人。 <br><br><h2> 短暂的历史之旅 </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/nw/zr/lonwzrpjzpi7m-nosk3wy3gndzw.png" width="300"></div><br> 两年前，一个很棒的人到Surf来找我们，他说：“我们拥有的技术到目前为止还很少有人知道。 并且您有客户和有趣的案例。 让我们为您提供我们的技术，将其集成到某个地方，您会得到很酷的共生。 我们将在Google I / O上推广这一做法，每个人都会没事的。” <br><br> 实际上， <b>与“抢先体验计划”一起工作真是无济于事</b> 。 您必须使用原始代码，而原始代码当然并不总是按预期和描述的方式工作。 在我们的情况下： <br><br><ul><li>所有工件均以ZIP存档的形式提供，必须每隔几天从超级秘密存储中下载一次，并只能在本地计算机上手动进行更新。 </li><li> 您只能在“金丝雀”中工作。 </li><li> 几乎没有文档，只有分散的非结构化Google文档，通常类似于开发人员的思想流程。 </li><li> 当然，不可能在食品中进行部署-只有在技术公开发布后才有可能。 也就是说，整个部署仅在alpha轨道中。 </li><li> 公开发布后，可能会发现该SDK已完全重写，而没有向后兼容性支持。 您将获得完全不同的接口和API-您需要重新做所有事情。 </li></ul><br> 这是我们如何参与“抢先体验计划”的简短摘要。 <br><br> 这一切都归功于我们的常规合作伙伴-Labyrinth公司-俄罗斯最大的书籍和文具在线商店。 他们加入了该项目，甚至不确定最终是否会有任何好处。 而且，在2017年，Surf作为工作室成为Google认证代理计划的一部分。 不幸的是，该计划于今年关闭。 <br><br><h3>  Android Instant Apps </h3><br> 在2017年，为了使该应用程序无需安装即可运行，必须正确地将其锯成模块。 <br><br><img src="https://habrastorage.org/webt/fq/qz/d7/fqqzd7dexvnj3d6ojcpi7nunhrw.png"><br><br> 我们有新的Gradle插件来生成相应的工件： <br><br><ul><li>  Instant App Module-一个应用程序插件，生成带有APK的ZIP存档，每个应用程序功能模块一个； </li><li> 可安装的应用模块-生成的APK。 </li></ul><br> 来自功能模块的两级层次结构已经出现。 永远只能有一个基本功能模块，并且包含可用于所有功能，资源，依赖项等的所有基本代码。 顶级功能模块包含特定屏幕的实现。 <br><br> 但这<strong>又长又昂贵</strong> ，原因有很多： <br><br><ul><li> 刚性模块化结构本身是一个很大的限制。 很难想象，任何大型公司都将在数年之内将其正在开发且运行良好的应用程序变成一堆吸烟模块，只是为了支持一项尚不为人所知的新技术。 </li><li> 对程序集大小的严格限制，即一项功能不应超过4 MB。 这是一个客观上很小的限制，有时甚至是完全无法达到的限制，例如，由于严重的依赖性或类似原因。 </li><li> 确保使用AppLink，因为这是进入Instant App的唯一方法。 用户单击邮件，信使，搜索结果中的链接，并通过拦截链接进入您的屏幕。 </li><li> 最后，大量的技术限制。 最初，甚至不可能使用NDK。 您无法发送推送通知，接收敏感数据，更改设备设置以及启动后台进程。 无法使用服务，广播接收器和内容提供者。 仅活动。 </li></ul><br>  Instant App的主要任务只是UI的演示，仅此而已。 重构非常痛苦，因此在生产中仍然几乎找不到这个故事。 <br><br> 但公平地说，在迷宫中实施Instant App后，通过移动客户端购买的商品增加了5％。 <br><br><h2>  2019. Google Play即时 </h2><br> 两年过去了，在2019年-即时应用程序仍然存在，但还不属于独立技术。 它在生产中仍然很少见，我没有故意找它，但我只知道几个例子：Sports.ru，Vimeo。  Google宣布这项技术时，不太可能指望这种结果。 <br><br> 现在，即时应用的名称有所不同-Google Play即时。 名称的更改有助于清除不相关的文档。 如果您看到了Android Instant App，则可以立即清楚这不再相关。 <br><br> 除了名称之外，其他所有内容都发生了变化，包括模块化结构。  <strong>需求变得更加忠诚</strong> 。 该技术以完全不同的方式集成到项目中，不需要繁琐的重构，这当然是很好的。 <blockquote> 但是，不那么明显，在我看来，更重要的是，这项技术仍然非常小众和稀有，已经成为整个技术家族的先驱，而现在它已成为其中的一部分。 </blockquote> 最初，Google将Instant App定位为一种吸引人们业务而不是应用程序的技术。 有一个设计指南仅用一个按钮“下载完整的应用程序”就禁止着陆应用程序。 但是另一个根本性的问题得到了侧面解决，我怀疑这是偶然发生的。 <br><br> 今年2月，机载1 TB内存的非凡设备Samsung Galaxy S10 +亮了起来。 只需考虑一下-1 TB！ 为什么你需要那么多？ <br><br> 根据Google的官方统计，过去7年中，APK的平均大小增加了5.5倍。 <br><br><img src="https://habrastorage.org/webt/n1/fj/gi/n1fjgis20pkxen7kpz7h1mqavte.png"><br><br> 构建规模确实很重要， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对</a>这些统计数据的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">研究</a>表明： <br><br><ul><li> 每增加6 Mb的组件，安装转换率就会降低1％； </li><li>  70％的用户在下载前检查应用程序的大小； </li><li>  50％的用户对应用程序在安装后将在设备上占用多少空间感兴趣。 </li></ul><br> 如果您的目标受众是年龄较大或收入不高的人群，或者这些人群是新兴市场，这一点就显得尤为重要。 <br><br> 后者越来越难以忽视，因为在2018年，印度的安装量激增。 <br><br><img src="https://habrastorage.org/webt/w8/l5/sc/w8l5sclkeutjcit1oweqt3t4n1q.jpeg"><br><br> 请注意，iOS很少，Android应用程序的安装总数超过了美国，巴西和印度尼西亚的总和。 <br><br> 现在很清楚，Google Play Instant可以解决什么问题。 您可以使用难以理解的条款。 <br><br><h2>  Android应用程式套件 </h2><br>  Android App Bundle-一种在Google Play上发布应用程序的新格式。 在内部，所有内容与APK并没有太大区别：所有相同的dex文件，清单，资源，资产等。 等 但是，还有元数据，它不会到达用户的设备。 <br><br><img src="https://habrastorage.org/webt/bb/ut/jt/bbutjtxukmhiiflwbngb_ivjae0.png"><br><br> 元数据由三个文件表示：resources.pb，assets.pb，native.pb。 实际上，这些是设备的组装和配置设置中的资源对应表。 <br><br><h2>  Android动态交付 </h2><br> 所有人都知道Google Play存在应用签名功能。 但是并不是每个人都准备好将其应用程序的发行密钥存储在Google Play上，因为不会回头。  <b>无法通过Google Play下达App Signing。</b> <br><br> 一旦将释放密钥提供给Google Play，您就再也无法像以前那样对应用程序进行签名。 但是，为此，您可以充分利用Android App Bundle作为一种格式。 现在，程序集签名过程看起来会有所不同。 <br><br><img src="https://habrastorage.org/webt/bc/lx/mw/bclxmwzyamlhlisvggnyrori7gk.png"><br><br> 在Google Play上发布该程序集之前，您仍将对其进行签名，但是您将使用不唯一的上载密钥对其进行签名。 可以从控制台中调用它，如果它被破坏或丢失，则可以重新发布。 您将释放密钥交给控制台，然后告别它-Google现在将为您签名程序集并发誓它将确保密钥安全。 <br><br> 但是，如果您不将发布密钥提供给Google Play，那么您将无法在项目中使用任何将进一步讨论的内容。  Google拧紧了螺丝，即使在不放弃密钥的情况下，即时应用程序现在也将无法部署。 <br><br> 实际上，这一点都不好笑，因为购买了Instant App促销并了解整个故事的人们重构了他们的应用程序，但是由于某些原因，他们无法将其密钥提供给Google Play（或者安全部门坚决反对或出于其他客观原因）发现自己无法再支持该决定。 实际上，数百小时的工作被扔进了垃圾箱。 <br><br><h3>  2014.拆分APK支持出现在Android Lollipop中 </h3><br> 由于我们今天怀旧，因此我们将更早回到过去-2014年。 <br><br> 我仍然记得在世界上最好的手机NEXUS 5上，Android Lollipop组件是如何以令人难以置信的材料设计飞来飞去的。 但是有些更改并未引起很多人的注意-这是对Split APK的支持。 <br><br> 拆分APK-一种机制，可让您将应用程序拆分为多个小APK，并在一个设备上安装后，使其表现为单个应用程序。 <br><br> 记住这一点，继续前进。 <br><br>  Android Dynamic Delivery是Google Play上的一种新的应用程序分发格式。 <br><br><img src="https://habrastorage.org/webt/pg/yk/85/pgyk85hx5b1ymk2ryhbek8ssmhi.png"><br><br> 我们曾经有一个APK，现在出现了Android App Bundle，以作为替代。  AAB充当了这些非常拆分的APK的孵化器生成器。  AAB推出了APK的包子，然后通过并行安装将其用作常规应用程序。 <br><br> 让我们看看它是哪种APK。 <br><br><img src="https://habrastorage.org/webt/ku/7k/e5/ku7ke5ykakq3mewuawg5jrcnf-k.png"><br><br> 至少，这是基本的APK，它与Instant App中的角色相同：这是在所有功能之间翻阅的基本代码，基本资源和业务逻辑。 <br><br> 同时出现： <br><br><ul><li>  APK，其名称可疑地类似于图形资源修饰符前缀（图中的第一行）。 </li><li> 另一个APK系列使我们想起了处理器架构。 </li><li> 本地化APK。 </li></ul><br> 大约两年前，当矢量图形不那么普及时，许多应用程序主要包含光栅资源，这些光栅资源被切割为屏幕上不同的像素密度。 组装可能会变得很重。 用户下载了所有这些资源，其中大部分资源都以无负担的方式存储在设备上。 <br><br> 现在，这种机制允许用户仅接收专门为其设备所需的资源集。 一个人来到Google Play，选择应用程序，Google Play会了解用户设备的特征，并提供所需的一组拆分APK-每个类别中都有一个APK。 <br><br> 动态投放类型APK： <br><br><ul><li> 一个且只有一个Base APK。 </li><li> 配置APK最多有以下三种类型： <em>res * x，资源* y，lib * z。</em> 此处：x是使用的资源修饰符的数量；  y是所使用的体系结构类型的数量；  z是语言本地化的数量。 例如，如果项目不使用本机代码和本机库，则将没有与本机代码相关联的类别，并且将保留两个APK。 </li><li> 无限动态功能APK。 </li></ul><br> 动态功能APK将在下面更详细地讨论。 但首先，我们将告别Split区块。 <br><br><h3> 再见拆分 </h3><br> 您可能会争辩说，以前可以做类似的事情，只用正确的资源手动生成一堆APK，然后全部手动部署到Google Play。 <br><br><pre><code class="java hljs">android { splits { density { enable <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> exclude <span class="hljs-string"><span class="hljs-string">"ldpi"</span></span>, <span class="hljs-string"><span class="hljs-string">"xxhdpi"</span></span>, <span class="hljs-string"><span class="hljs-string">"xxxhdpi"</span></span> compatibleScreens <span class="hljs-string"><span class="hljs-string">'small'</span></span>, <span class="hljs-string"><span class="hljs-string">'normal'</span></span>, <span class="hljs-string"><span class="hljs-string">'large'</span></span>, <span class="hljs-string"><span class="hljs-string">'xlarge'</span></span> } } }</code> </pre> <br> 这种冒险本身是相当可疑的，现在所有这些都被忽略了。 如果您构建Android App Bundle，则会出现Bundle块，该块可让您手动禁用拆分为类别之一的项目。 <br><br><pre> <code class="java hljs">android { bundle { language { enableSplit = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> } density { enableSplit = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } abi { enableSplit = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } } }</code> </pre> <br> 您可以指定应用程序仅支持例如俄语或仅英语，并在组装过程中跳过此步骤。 <br><br> 现在，最细心的人可能正在考虑如何使用preLollipops。 仅在Android 5中出现了对Split APK的支持。 我们必须以某种方式摆脱这种局面，因为Min SDK绝不是全部21。 <br><br> 对于preLollipops，情况相当笨拙，但只有可能。  Google Play为preLollipops收集了多个APK，其中包括配置APK的各种组合。 只有一个APK，但有很多选项。 <br><br><h3>  Android App Bundle改变了我们的生活 </h3><br> 而且非常重要。 首先，构建项目可能会容易得多，尤其是如果您曾经手动构建Split APK。 但是根据我的观察，这样的人并不多。 <br><br> 其次，您不再承担丢失或破坏发布密钥的风险。 不会有大的悲剧，如果您丢失了上传密钥，则可以撤回并重新发行它。 <br><br> 我们不会指责-在w3bsit3-dns.com上，俄语Google Play的顶部有很长一段时间具有释放密钥的应用程序，所有自定义程序集都用释放密钥签名，并且在接下来的五年中将无法进行任何操作。 它仍然等待着到只有28个API出现的Signing V3过渡。 <br><blockquote>  Android App Bundle的优势无疑是：用户停止在不需要的资源上花费流量和磁盘空间。 这大大提高了应用程序的保留率。 </blockquote> 但是，如果您在矢量中拥有所有图形，两个本地化并且没有本地库，那么好处将是微不足道的。 <br><br><h2> 动态功能模块 </h2><br> 动态功能模块是在安装应用程序时不提供的功能模块，而是从Google Play下载并仅按需安装的功能模块。 <br><br> 此类模块与基本APK相当。 <br><br><img src="https://habrastorage.org/webt/hp/ho/2v/hpho2vlpy2bawtztyql8r58aruu.png"><br><br> 这些功能模块本身每个都还包含一组配置拆分APK，这一点很重要。 因此，APK的总数可能会增加而无法衡量。 但这不是您所关心的，Google Play正在这样做。 <br><br><h3> 动态功能模块的应用： </h3><br>  <strong>极少数观众使用的功能</strong> ，但对您的产品而言仍然很重要。 例如，这是一个内容娱乐应用程序，其95％的用户消费内容。 但是，只有极少数的编辑器生成内容。 对于他们来说，有一个很酷的视频编辑器，它的确占了很大的比重，工作起来非常酷。 然后，为每个人和每个人加权装配都是没有意义的，您可以将此功能放入动态功能模块中，并仅将其提供给需要的人，然后再下载。 <br><br>  <strong>与主要应用程序使用情况无关的重要功能。</strong> 例如，地图服务中的AR导航。 任何AR功能最多都可以放在动态功能模块中。 <br><br>  <strong>用户无需安装应用程序本身即可使用的功能</strong> （例如，在目录中选择产品并下订单）。 没错，这是所有事物的可疑之处。 <br><blockquote>  Android Instant Apps现在是即时启用的动态功能模块。 <br></blockquote> 因此，事实证明有两种类型的动态功能模块： <br><br><ul><li> 通用动态功能模块是与主要应用程序分开下载并安装在设备上的功能模块。 只要应用程序本身存在，它们就一直在那里。 在删除它之前，将使用动态功能模块。 </li><li> 即时启用的动态功能模块-无需安装在设备上即可运行的功能模块。 该模块的寿命有限。 </li></ul><br>  Google Play上的第二种应用程序可以通过“尝试”按钮的存在来区分。 当您单击它时，将替换默认URL，并且至少可以看到该应用程序的外观作为一个主要功能的示例。 <br><br> 通常可以在游戏部分找到它。 这比应用程序更方便，甚至更适用于应用程序，因为您可以下载游戏的一小部分作为演示并查看其全部内容，无论是否值得花费您的流量和时间。 <br><br><h2> 模块化结构 </h2><br> 我已经说过，模块化结构已经简化。 让我们看看如何。 <br><br> 最初，我们有一个相当可怕的结构。 除其他外，它具有空模块，例如，Instant App模块始终为空，没有代码，没有资源，只有build.gradle文件，仅此而已。 <br><br> 开发人员认为，为什么随后仅为了收集某种类型的工件而产生额外的模块。 他们看到了，功能转移到了App Module。 <br><br> 但是随后他们走得更远，开始思考-为什么我们需要基本功能模块？ 他有一些问题，因为我们在那里初始化了所有东西，并且他的应用程序ID不同。 拐杖来自这里，例如，将应用程序ID从应用程序模块传输到基本功能模块，并将其替换为应用程序的真实应用程序ID，以便所有内容都能在Crashlytics中进行跟踪等。 <br><br> 结果，事实证明是这样。 <br><br><img src="https://habrastorage.org/webt/s5/ld/ys/s5ldysjxqmlmuqm8axqd70lxyq0.png"><br><br> 他们离开了附加在其功能模块顶部的应用模块-就是这样！ <br><br> 当我发现这一点时，不要表达自己的情感。 大舞台上的家伙说，他们拥有一项很酷的技术：“让我们将所有应用程序都削减到这种结构！” 但这不能在5分钟内起作用，但是会带来很大的后果。 <br><br> 在2017年，拥有整体应用程序还不是一件可耻的事情。 迷宫就是这样，然后它甚至还没有达到公开发布，而是处于测试阶段。 在我们参与“抢先体验计划”时，那里已经有大约90个屏幕。 我们花了另外两个月的时间来重构，测试并确保所有内容都能正常运行。 <br><br> 然后他们说： <strong>“我们太聪明了，可以做得容易得多</strong> 。 <strong>”</strong> <br><br> 但是回到散文。 <br><br><h3> 摇篮配置 </h3><br> 为了支持新配置，我们首先需要在Android模块中的app模块的build.gradle文件中列出所有Dynamic Feature Modules： <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  build.gradle app- android { dynamicFeatures = [":dynamic_feature", M:dynamic_feature2M] }</span></span></code> </pre> <br> 之后，在每个动态功能模块的build.gradle文件中，将依赖关系写入应用模块： <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  build.gradle  dynamic feature- dependencies { implementation project(':app') }</span></span></code> </pre> <br> 原则上，没有什么复杂的。 但是，还有清单的配置。 <br><br><h3> 清单配置 </h3><br> 在应用程序模块清单中，我们可以设置true标志，以指示此应用程序中至少有一个即时启用的功能： <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   app- &lt;dist:module dist:instant="true|false" /&gt;</span></span></code> </pre> <br> 如果不存在此标志，则无法将其嵌入Google Play上的相应曲目中。 <br><br> 此外，每个动态功能模块还分别具有清单配置，其中有更多设置： <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    dynamic feature- &lt;dist:module dist:instant="true|false" // Instant-Enabled  dist:onDemand="false|true" // ,         dist:title="@string/feature_modulejnstall_name"&gt; //   &lt;dist:fusing dist:include="true |false" /&gt; //,      APK  preLollipop &lt;/dist:module&gt;</span></span></code> </pre> <br> 前两个标志是互斥的，因为<code>onDemand</code>是通常的基本功能，而<code>instant</code>是相同的Installable功能。 <br><br> 标题-模块的技术名称，稍后在我们的应用程序中对其进行硬编码后，根据该名称，我们将从Google Play中抽取该模块。 <br><br>  <code>include</code>参数是preLollipops的参数。 如果将其设置为false，则preLollipops用户将永远不会看到此功能，也将无法使用它。 <br><br><h3>  Gradle项目配置 </h3><br>  Instantapp插件和功能插件的寿命很短，但充满活力。 他们持续了不到两年。 自今年三月以来，不再支持它们。 <br><br> 现在我们只使用一个动态功能模块： <br><pre> <code class="java hljs">apply plugin: <span class="hljs-string"><span class="hljs-string">'com.android.dynamic-feature'</span></span></code> </pre> <br><h3> 仅在应用程序模块中进行项目配置 </h3><br><blockquote> 重要一点：有关签名（签名配置），程序集（ProGuard配置），versionCode和versionName的所有设置仅需在build.gradle应用程序模块中进行。 </blockquote> 否则，它们将被忽略。 避免在动态功能模块的build.gradle文件中指定任何这些配置块。 <br><br><h2>  Google即时播放 </h2><br> 现在我们有以下内容。 <br><br>  <strong>模块化结构的要求已尽可能简化。</strong> 对于那些尚未参与的人来说，这确实是个好消息。 即使您的应用程序具有自己的结构，现在也可以尝试。 这完全不会影响您，您只需将模块附加在顶部，一切就可以正常工作。 <br><br>  <strong>对装配尺寸的限制变得更加忠诚。</strong> 如果之前是4 MB，现在： <br><br><ul><li> 动态功能模块的大小通常不受限制； </li><li> 即时启用的动态功能模块最多可能占用10 MB。 </li></ul><br> 但是现在有了一个渐进的规模。 <br><br><img src="https://habrastorage.org/webt/hn/xq/rg/hnxqrghmprre_roahys7gkwquhu.png"><br><br> 如果您的功能： <br><br><ul><li> 超过10 MB，对不起； </li><li> 从4到10 Mb-仅可通过Google Play中的“尝试”按钮进行访问；仅此而已； </li><li> 少于4 MB-可以使用所有将用户吸引到Instant-Enabled模块的方法（通过广告，链接，消息等启动）。 </li></ul><br>  <strong>出现了一种用于加载模块的机制-Play Core API。</strong> 很少有人知道Instant App以前是通过Chrome安装的。 <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maybeLaunchInstantApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Tab tab, String url, String referrerUrl, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isIncomingRedirect)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tab == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || tab.getWebContents() == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; InstantAppsHandler handler = InstantAppsHandler.getInstance(); Intent intent = tab.getTabRedirectHandler() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? tab.getTabRedirectHandler().getInitialIntent() : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isIncomingRedirect &amp;&amp; intent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; intent.getAction() == Intent.ACTION_VIEW) { Intent resolvedIntent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(intent); resolvedIntent.setData(Uri.parse(url)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> handler.handleIncomingIntent(getAvailableContext(), resolvedIntent, ChromeLauncherActivity.isCustomTabIntent(resolvedIntent)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br> 这是来自Android版Chrome的真实代码，它拦截了指向您的Instant App的链接，转到了Google Play并从那里替换了Instant Apps。 如果检测到Instant App，它将以某种方式打开活动，然后从中启动Instant App。 <br><br> 因此，滚动此功能存在很大的问题。 对于三星，这是一个完全不同的故事，我怀疑他们的内置浏览器具有比Chrome稍微更多的特权。  Instant App直到最后一个都没有在那里工作。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>Play Core Library</strong></a> <strong>让您无需担心传送问题。</strong> 您只需将其作为包装插入： <br><br><pre> <code class="java hljs">implementation <span class="hljs-string"><span class="hljs-string">'com.google.android.play:core:1.4.0'</span></span></code> </pre> <br> 并从Google Play下载所需的功能模块。 <br><br> 该库具有相当实用的语法，可让您一次下载一个模块： <br><br><pre> <code class="java hljs">val splitInstallManager = SplitInstallManagerFactory.create(context)</code> </pre> <br> 或立即打包几包： <br><br><pre> <code class="java hljs">val request = SplitInstallRequest .newBuilder() .addModule(<span class="hljs-string"><span class="hljs-string">"feature1"</span></span>) .addModule(<span class="hljs-string"><span class="hljs-string">"feature2"</span></span>) .build()</code> </pre> <br> 挂断听众： <br><br><pre> <code class="java hljs">splitInstallManager .startInstall(request) .addOnSuccessListener { sessionId -&gt; ... } .addOnFailureListener { exception -&gt; ... }</code> </pre> <br><br> 在用户界面中显示此内容，并对已安装模块的事实做出反应。 <br><br>  Play Core Library是一个不错的开始： <br><br><ul><li> 最后，您可以停止面对Google Chrome浏览器。 </li><li> 您可以按照自己的方式演示如何在UI上加载模块。 </li><li> 可以批量加载功能模块。 </li><li> 有一种方法可以灵活地处理在下载和安装功能模块时发生的错误。 </li><li> 安装该功能后，您甚至不需要重新启动应用程序，因为有<code>SplitCompat.install()</code> -对其进行调用，您可以立即从新安装的功能中立即访问类。 </li></ul><br> 但是，如果我说Play Core Library不会让您受苦，我会欺骗您： <br><br><ul><li> 代码被混淆，没有任何形式的文档记录。 </li><li> 来自所有活动加载会话的事件都到达一个<code>SplitInstallStateUpdatedListener</code>您需要对其进行手动排序。 必须将会话ID提前保存在某个地方，这最终会导致代码不是很漂亮。 </li><li> 笨拙的冗余状态管理和错误处理：9个可能的状态，10个可能的错误。 这些错误和状态的组合可以用不同的方式解释，所有状态和错误都以int返回。 </li><li> 无法在本地设备上正常测试下载和安装功能的可能性-这根本是不可能的。 </li></ul><br> 唯一的选择是将您在Google Play上的版本嵌入到内部测试频道中，然后尝试一下。 如果发现某种错误，请重新开始整个过程​​，部署更新，然后再尝试。 如果要检查它在没有构建的情况下是如何工作的，则会出现错误“ -2”，并且只能猜测它的含义。 这是Google动态功能的官方示例在存储库中最常见的问题。 <br><br>  <strong>在功能模块之间导航没有良好的实践。</strong> 在官方示例中，它们显示了功能模块之间如何发生交互，它们建议解决问题的方法非常简单：打开从一个模块到另一个模块的依赖关系。 每个方向都有自己的依赖性，为什么要回来？ <br><br><img src="https://habrastorage.org/webt/yr/xh/vx/yrxhvxc_6mdbpre9ppka5-telrq.png"><br><br> 但是，随后拆分为模块的所有好处就消失了。 在解决此类问题的需求很久之前，我们就切换到了模块。 他们这样做的部分原因是，它为缺乏经验的开发人员简化了代码库的工作，由于缺乏经验，开发人员可以将signing-activity和base-activity一起使用-然后寻找它进行代码审查。 <br><br> 如果您将所有具有上下依赖关系的模块连接起来，那么只有Google可以从中受益，而不必考虑导航方面的任何问题。 <br><br> 我们考虑了很长一段时间后，终于找到了解决方案，但仍然让我不寒而栗。 它称为<code>Class.forName</code>使用完整的<code>ClassPath</code>实例化一个类，该类通过从其路径中重命名任何包的类等来中断。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActivityCrossFeatureRoute</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareIntent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: Context)</span></span></span><span class="hljs-function">: Intent? </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Intent(context, Class.forName(targetClassPath())) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: ClassNotFoundException) { Logger.e(<span class="hljs-string"><span class="hljs-string">"Activity with the following classpath was not found in the current "</span></span> + <span class="hljs-string"><span class="hljs-string">"application: ${targetClassPath()}. If this activity is the part of Dynamic Feature, "</span></span> + <span class="hljs-string"><span class="hljs-string">"please check if this Dynamic Feature is downloaded and installed on the device"</span></span> + <span class="hljs-string"><span class="hljs-string">"successfully."</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } }</code> </pre> <br> 在我进入<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Plaid</a>应用程序存储库并看到他们以相同的方式解决了导航问题并建议每个人都在Stack Overflow上解决该问题之前，我感到很ham愧。 <br><br> 格子是最酷的展示案例之一，Google会尝试使用它们的所有最新趋势，出色的动画，设计技巧，最新的UI组件，尤其是模块化。 <br><br>  <strong>很多，实际上是很多错误，工程不足，粗糙。</strong> 您无需长时间搜索错误。 <br><br><ul><li> 只有沿着完整路径，才可以从app模块访问资源。 </li></ul><br> 无需像这样写<code>R.string.primaryColor</code> ，而每次在代码<code>ru.appname.package.R.string.primaryColor</code>都需要这样写。 以另一种方式，该构建将无法正常工作，这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">指向</a>官方问题跟踪器的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接</a> 。 <br><br><ul><li> 在O +设备上运行JobScheduler的问题。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方的解决方法</a>是手动启动<code>TestJobSchedulerService</code> ： </li></ul><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) { Intent serviceIntent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, TestJobSchedulerService.class); startService(serviceIntent); }</code> </pre> <br><ul><li> 连接第三方库（例如Firebase，Fabric，AndroidX-packages等）时冻结冻结错误。 </li></ul><br> 它们都在清单中使用占位符应用程序ID。 应用程序ID错误地插入在那里，因此清单不会冻结，Android Studio无法找到默认活动，并且您一直在寻找问题，直到您在官方问题跟踪器中找到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">建议</a>为止-重新定义所有提供程序并在此处指定您的应用程序ID。 <br><br><pre> <code class="java hljs">&lt;provider android:name=<span class="hljs-string"><span class="hljs-string">"com.crashlytics.android.CrashlyticsInitProvider"</span></span> android:authorities=<span class="hljs-string"><span class="hljs-string">"ru.app.name.crashlyticsinitprovider"</span></span> tools:replace=<span class="hljs-string"><span class="hljs-string">"android:authorities"</span></span> /&gt; &lt;provider android:name=<span class="hljs-string"><span class="hljs-string">"com.google.firebase.provider.FirebaseInitProvider"</span></span> android:authorities=<span class="hljs-string"><span class="hljs-string">"ru.app.name.firebaseinitprovider"</span></span> tools:replace=<span class="hljs-string"><span class="hljs-string">"android:authorities"</span></span> /&gt; &lt;provider android:name=<span class="hljs-string"><span class="hljs-string">"androidx.core.content.FileProvider"</span></span> android:authorities=<span class="hljs-string"><span class="hljs-string">"ru.app.name.fileprovide"</span></span> tools:replace=<span class="hljs-string"><span class="hljs-string">"android:authorities"</span></span> /&gt;</code> </pre> <br><ul><li> 我最喜欢的观点之一是不可能依赖第三方软件包。 </li></ul><br> 假设两个功能模块依赖于一个第三方库。 但是您不能建立直接依赖关系，因为您得到： <code>org.gradle.api.GradleException: [:feature1, :feature2] all package the same library [com.lib.Name:VeryGoodLib]</code> 。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方回答</a> ：如果在这些模块中指示不同版本的库，该怎么办？ <br><br> 开发人员建议：将功能模块添加到层次结构中，其中仅依赖第三方库，而使其依赖于两个源功能模块。 <br><br><ul><li>  attachBaseContext（）中的InstantApps.isInstantApp（上下文）的调用缓存。 </li></ul><br>  Android开发人员文档中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的代码示例</a>崩溃，仅仅是因为它们提供了<code>attachBaseContext()</code>来通过<code>this</code>访问上下文，如果<code>context==null</code> ，您甚至无法检查InstantApps是否正在运行。 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attachBaseContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(base: Context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.attachBaseContext(base) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!InstantApps.isInstantApp(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) { SplitCompat.install(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } }</code> </pre> <br><ul><li> 使用<code>Groups</code>和<code>Barriers</code>时， <code>ConstraintLayout</code>显示<code>ConstraintLayout</code> 。 </li></ul><br> 想象您经历了所有事情：组装了程序集，猜测它需要嵌入到Google Play的测试通道中，而Google Play并未显示红色对话框。 用颤抖的手，将此装配件安装到设备上，安装功能部件，然后转到屏幕-您会看到整个布局都聚集在左上角的一堆中。 这是因为，如果您使用<code>Groups</code>和<code>Barriers</code> ，则有一个很棒的<code>getPackageName</code>方法，由于某种原因它会错误地出现。 结果，您的所有视图都无法定位。 所有的约束飞散，一切都随意地放在屏幕上。 <br><br> 最后，克服这些困难后，您会发现... <br><br>  <strong>动态功能仍处于测试阶段！</strong> 您不会陷入生产困境-一直以来一直是Google的免费测试人员！ <br><br><img src="https://habrastorage.org/webt/ry/ct/i6/rycti6op3z_5tkbmn0b5dv77psk.png"><br><br> 但谷歌却没有。 如果您想成为一个人，则可以填写<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">兴趣表</a> ，也许您会很幸运，并且可以进入制作流程。 <br><blockquote>  <em>相信</em> Instant Apps输掉了这场战斗。 未来几年不太可能宣布这一消息，但是围绕AMP的越来越多的信息活动秘密证实了这一点。 </blockquote> 我想提醒你和我自己的思想- <strong>为人写信</strong> 。 在做出任何决定之前，请三思而后行，尤其是在开发其他开发人员将使用的工具时。 您的每项决定和行动都会影响某人，并有可能使他有点鲜血。  <strong>我不想让某人崩溃。</strong> <br><br><h3> 有用的链接 </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://developer.android.com/topic/google-play-instant/overview</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://developer.android.com/guide/app-bundle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://developer.android.com/studio/proiects/dvnamic-delivery</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://developer.android.com/guide/app-bundle/playcore</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">即时捆绑应用程序（Android Dev Summit '18）</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/googlesamples/android-instant-apps</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/googlesamples/android-dynamic-features</a> </li></ul><br><blockquote> 我们制作了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Saint AppsConf</a>程序，该程序已于10月21日至22日在圣彼得堡举行，与春季相比，活动更加丰富多彩。 看看吧！ <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或订阅</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时事通讯</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电报</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fb-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此我们讨论会议的个人报告和准备工作。</font></font><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN462511/">https://habr.com/ru/post/zh-CN462511/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN462501/index.html">为什么我需要自己的证书颁发机构</a></li>
<li><a href="../zh-CN462503/index.html">监视和SRE的“黄金信号”是什么？</a></li>
<li><a href="../zh-CN462505/index.html">不要骗我函数式编程</a></li>
<li><a href="../zh-CN462507/index.html">邮件传递时：与iOS中的推送通知丢失作斗争</a></li>
<li><a href="../zh-CN462509/index.html">产品盛会-您要参加的IT产品管理会议</a></li>
<li><a href="../zh-CN462513/index.html">搬迁：准备，选择，开发领域</a></li>
<li><a href="../zh-CN462515/index.html">使用系统键盘时的错误</a></li>
<li><a href="../zh-CN462519/index.html">《微服务》一书。 开发和重构模式»</a></li>
<li><a href="../zh-CN462523/index.html">LinOTP两因素授权服务器</a></li>
<li><a href="../zh-CN462525/index.html">3CX推出具有端到端语音加密功能的适用于iOS和Android的新型SIP软电话</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>