<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÆ üíÑ üëâüèº ReactiveX Redux ‚òùüèΩ üëù üë®üèæ‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jeder, der mit Redux arbeitet, wird fr√ºher oder sp√§ter auf das Problem asynchroner Aktionen sto√üen. Eine moderne Anwendung kann jedoch nicht ohne sie ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ReactiveX Redux</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alfa/blog/460155/">  Jeder, der mit Redux arbeitet, wird fr√ºher oder sp√§ter auf das Problem asynchroner Aktionen sto√üen.  Eine moderne Anwendung kann jedoch nicht ohne sie entwickelt werden.  Dies sind http-Anfragen an das Backend und alle Arten von Timern / Verz√∂gerungen.  Die Redux-Ersteller selbst sprechen eindeutig - standardm√§√üig wird nur der synchrone Datenfluss unterst√ºtzt, alle asynchronen Aktionen m√ºssen in der Middleware platziert werden. <br><br>  Dies ist nat√ºrlich zu ausf√ºhrlich und unpraktisch, sodass es schwierig ist, einen Entwickler zu finden, der nur die "native" Middleware verwendet.  Bibliotheken und Frameworks wie Thunk, Saga und dergleichen helfen immer. <br><br>  F√ºr die meisten Aufgaben reichen sie aus.  Was aber, wenn eine etwas komplexere Logik erforderlich ist, als eine Anfrage zu senden oder einen Timer zu erstellen?  Hier ist ein kleines Beispiel: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> dispatch =&gt; { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> .all([fetchOne, fetchTwo]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[respOne, respTwo]</span></span></span><span class="hljs-function">) =&gt;</span></span> { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'SUCCESS'</span></span>, respOne, respTwo }); }); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FAILED'</span></span>, error }); } }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }</code> </pre> <br>  Es ist schmerzhaft, sich solchen Code anzusehen, aber es ist einfach unm√∂glich, ihn zu pflegen und zu erweitern.  Was tun, wenn eine komplexere Fehlerbehandlung erforderlich ist?  Was ist, wenn Sie eine Wiederholungsanfrage ben√∂tigen?  Und wenn ich diese Funktion wiederverwenden m√∂chte? <br><br>  Mein Name ist Dmitry Samokhvalov, und in diesem Beitrag werde ich Ihnen erkl√§ren, was das Konzept von Observable ist und wie es in Verbindung mit Redux in die Praxis umgesetzt werden kann, und all dies mit den F√§higkeiten von Redux-Saga vergleichen. <br><a name="habracut"></a><br>  Nehmen Sie in solchen F√§llen in der Regel die Redux-Saga.  OK, wir schreiben die Sagen neu: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> call(delay, <span class="hljs-number"><span class="hljs-number">2000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [respOne, respTwo] = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> [ call(fetchOne), call(fetchTwo) ]; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> put({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'SUCCESS'</span></span>, respOne, respTwo }); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> put({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FAILED'</span></span>, error }); }</code> </pre><br>  Es ist sp√ºrbar besser geworden - der Code ist fast linear, sieht besser aus und liest sich besser.  Das Erweitern und Wiederverwenden ist jedoch immer noch schwierig, da die Saga genauso wichtig ist wie der Thunk. <br><br>  Es gibt einen anderen Ansatz.  Dies ist genau der Ansatz und nicht nur eine andere Bibliothek zum Schreiben von asynchronem Code.  Es hei√üt Rx (es handelt sich auch um Observables, Reactive Streams usw.).  Wir werden es verwenden und das Beispiel auf Observable neu schreiben: <br><br><pre> <code class="javascript hljs">action$ .delay(<span class="hljs-number"><span class="hljs-number">2000</span></span>) .switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> Observable.merge(fetchOne, fetchTwo) .map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[respOne, respTwo]</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'SUCCESS'</span></span>, respOne, respTwo })) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FAILED'</span></span>, error }))</code> </pre> <br>  Der Code wurde nicht nur flach und nahm an Volumen ab, auch das Prinzip der Beschreibung asynchroner Aktionen hat sich ge√§ndert.  Jetzt arbeiten wir nicht direkt mit Abfragen, sondern f√ºhren Operationen an speziellen Objekten aus, die als Observable bezeichnet werden. <br><br>  Es ist zweckm√§√üig, Observable als eine Funktion darzustellen, die einen Strom (eine Folge) von Werten ergibt.  Observable hat drei Hauptzust√§nde - next ("Geben Sie den n√§chsten Wert"), error ("ein Fehler ist aufgetreten") und complete ("die Werte sind vorbei, es gibt nichts mehr zu geben").  In dieser Hinsicht ist es ein bisschen wie Promise, unterscheidet sich jedoch darin, dass es m√∂glich ist, √ºber diese Werte zu iterieren (und dies ist eine der beobachtbaren Superm√§chte).  Sie k√∂nnen alles in Observable einschlie√üen - Timeouts, http-Anforderungen, DOM-Ereignisse, nur js-Objekte. <br><br><img src="https://habrastorage.org/webt/be/qu/yr/bequyrg-gjvichysgtzom-c0mju.png" width="540"><br><br>  Die zweite beobachtbare Supermacht sind Betreiber.  Ein Operator ist eine Funktion, die eine Observable akzeptiert und zur√ºckgibt, jedoch eine Aktion f√ºr den Wertestrom ausf√ºhrt.  Die n√§chste Analogie ist Map und Filter aus Javascript (solche Operatoren sind √ºbrigens in Rx). <br><br><img src="https://habrastorage.org/webt/bu/hi/mc/buhimcdgpjmngscttymdt1rzsqk.png" width="540"><br><br>  Am n√ºtzlichsten f√ºr mich pers√∂nlich waren die Operatoren zip, forkJoin und flatMap.  Anhand ihres Beispiels ist es am einfachsten, die Arbeit der Bediener zu erkl√§ren. <br><br>  Der Zip-Operator funktioniert sehr einfach - er ben√∂tigt einige Observable (nicht mehr als 9) und gibt in einem Array die von ihnen ausgegebenen Werte zur√ºck. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = fromEvent(<span class="hljs-string"><span class="hljs-string">"mousedown"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = fromEvent(<span class="hljs-string"><span class="hljs-string">"mouseup"</span></span>); zip(first, second) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${e[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">0</span></span></span></span><span class="hljs-string"><span class="hljs-subst">].x}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${e[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst">].x}</span></span></span><span class="hljs-string">`</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//output [119,120] [120,233] ‚Ä¶</span></span></code> </pre><br>  Im Allgemeinen kann die Arbeit von zip durch das Schema dargestellt werden: <br><br><img src="https://habrastorage.org/webt/zu/4j/in/zu4jinxmtwpt4vs3azoy81a6xpc.png" width="540"><br><br>  Zip wird verwendet, wenn Sie mehrere Observable haben und konsistent Werte von ihnen empfangen m√ºssen (trotz der Tatsache, dass sie in unterschiedlichen Intervallen synchron oder nicht synchron ausgegeben werden k√∂nnen).  Dies ist sehr n√ºtzlich, wenn Sie mit DOM-Ereignissen arbeiten. <br><br>  Die forkJoin-Anweisung √§hnelt zip mit einer Ausnahme: Sie gibt nur die neuesten Werte von jedem Observable zur√ºck. <br><br><img src="https://habrastorage.org/webt/3p/mb/s6/3pmbs6uzqz4w9c3fklfhslw6j6k.png" width="540"><br><br>  Dementsprechend ist es sinnvoll, es zu verwenden, wenn nur endliche Werte aus dem Stream ben√∂tigt werden. <br>  Etwas komplizierter ist der flatMap-Operator.  Es nimmt ein Observable als Eingabe und gibt ein neues Observable zur√ºck und ordnet die Werte daraus dem neuen Observable zu, wobei entweder eine Auswahlfunktion oder ein anderes Observable verwendet wird.  Es klingt verwirrend, aber das Diagramm ist ziemlich einfach: <br><br><img src="https://habrastorage.org/webt/kz/7t/fn/kz7tfnjuhklblx5czaxhbs06_mi.png" width="540"><br><br>  Noch klarer im Code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${value}</span></span></span><span class="hljs-string"> World`</span></span>); observable .flatMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> promise(value)) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result)); <span class="hljs-comment"><span class="hljs-comment">//output "Hello World"</span></span></code> </pre> <br>  In den meisten F√§llen wird flatMap zusammen mit switchMap und concatMap in Backend-Anforderungen verwendet. <br>  Wie kann ich Rx in Redux verwenden?  Daf√ºr gibt es eine wunderbare Redux-beobachtbare Bibliothek.  Die Architektur sieht folgenderma√üen aus: <br><br><img src="https://habrastorage.org/webt/9p/y1/kv/9py1kvsgrpqjaovs3zrukrghbwc.png" width="540"><br><br>  Alle Observable-Operatoren und Aktionen auf ihnen werden in Form einer speziellen Middleware namens Epic ausgef√ºhrt.  Jedes Epos nimmt eine Aktion als Eingabe, verpackt sie in ein Observable und sollte eine Aktion zur√ºckgeben, auch als Observable.  Sie k√∂nnen keine regul√§re Aktion zur√ºckgeben, dies erzeugt eine Endlosschleife.  Lassen Sie uns ein kleines Epos schreiben, das eine Anfrage an api stellt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fetchEpic = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action$</span></span></span><span class="hljs-function"> =&gt;</span></span> action$ .ofType(<span class="hljs-string"><span class="hljs-string">'FETCH_INFO'</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FETCH_START'</span></span> })) .flatMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> Observable .from(apiRequest) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FETCH_SUCCESS'</span></span>, data })) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FETCH_ERROR'</span></span>, error })) )</code> </pre><br>  Es ist unm√∂glich, auf den Vergleich von Redux-Observable und Redux-Saga zu verzichten.  Vielen scheint es, dass sie in Funktionalit√§t und F√§higkeiten nahe beieinander liegen, aber dies ist √ºberhaupt nicht der Fall.  Sagas sind ein absolut zwingendes Werkzeug, im Wesentlichen eine Reihe von Methoden zum Arbeiten mit Nebenwirkungen.  Observable ist eine grundlegend andere Art, asynchronen Code zu schreiben, wenn Sie m√∂chten, eine andere Philosophie. <br><br>  Ich habe mehrere Beispiele geschrieben, um die M√∂glichkeiten und den Ansatz zur L√∂sung von Problemen zu veranschaulichen. <br><br>  Angenommen, wir m√ºssen einen Timer implementieren, der durch Aktion stoppt.  So sieht es in den Sagen aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> race({ <span class="hljs-attr"><span class="hljs-attr">stopped</span></span>: take(<span class="hljs-string"><span class="hljs-string">'STOP'</span></span>), <span class="hljs-attr"><span class="hljs-attr">tick</span></span>: call(wait, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!timer.stopped) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> put(actions.tick()) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } }</code> </pre> <br>  Verwenden Sie jetzt Rx: <br><br><pre> <code class="javascript hljs">interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>) .takeUntil(action$.ofType(<span class="hljs-string"><span class="hljs-string">'STOP'</span></span>))</code> </pre> <br><br>  Angenommen, es gibt eine Aufgabe zum Implementieren einer Anforderung mit Stornierung in Sagen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchSaga</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> call(fetchUser); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> take(<span class="hljs-string"><span class="hljs-string">'FETCH'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fetchSaga = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fork(fetchSaga); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> take(<span class="hljs-string"><span class="hljs-string">'FETCH_CANCEL'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> cancel(fetchSaga); }</code> </pre> <br>  Bei Rx ist alles einfacher: <br><br><pre> <code class="javascript hljs">switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchUser()) .takeUntil(action$.ofType(<span class="hljs-string"><span class="hljs-string">'FETCH_CANCEL'</span></span>))</code> </pre> <br>  Endlich mein Favorit.  Implementieren Sie eine API-Anfrage. Stellen Sie im Fehlerfall nicht mehr als 5 wiederholte Anfragen mit einer Verz√∂gerung von 2 Sekunden.  Folgendes haben wir in den Sagen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> apiResponse = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> call(apiRequest); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apiResponse; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">2000</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(); }</code> </pre> <br>  Was passiert auf Rx: <br><br><pre> <code class="javascript hljs">.retryWhen(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">errors</span></span></span><span class="hljs-function"> =&gt;</span></span> errors .delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>) .take(<span class="hljs-number"><span class="hljs-number">5</span></span>))</code> </pre><br>  Wenn Sie die Vor- und Nachteile der Saga zusammenfassen, erhalten Sie das folgende Bild: <br><br><img src="https://habrastorage.org/webt/y6/bs/un/y6bsun3cbbwp4tayqhuuhwpudyc.png" width="540"><br><br>  Sagas sind leicht zu erlernen und sehr beliebt, sodass Sie in der Community Rezepte f√ºr fast alle Gelegenheiten finden k√∂nnen.  Leider verhindert der imperative Stil die Verwendung der Sagen wirklich flexibel. <br><br>  Rx hat eine ganz andere Situation: <br><br><img src="https://habrastorage.org/webt/mc/5a/wx/mc5awxjs7lszbo9jcq-qzrzg2qa.png" width="540"><br><br>  Es scheint, dass Rx ein magischer Hammer und eine Silberkugel ist.  Dies ist leider nicht so.  Der Schwellenwert f√ºr die Eingabe von Rx ist viel h√∂her, daher ist es schwieriger, eine neue Person in ein Projekt einzuf√ºhren, das Rx aktiv nutzt. <br><br>  Dar√ºber hinaus ist es bei der Arbeit mit Observable besonders wichtig, vorsichtig zu sein und immer gut zu verstehen, was passiert.  Andernfalls k√∂nnen Sie auf nicht offensichtliche Fehler oder undefiniertes Verhalten sto√üen. <br><br><pre> <code class="javascript hljs">action$ .ofType(<span class="hljs-string"><span class="hljs-string">'DELETE'</span></span>) .switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> Observable .fromPromise(deleteRequest) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'DELETE_SUCCESS'</span></span>})))</code> </pre> <br>  Nachdem ich ein Epos geschrieben hatte, das einen ziemlich einfachen Job machte - mit jeder Aktion vom Typ 'DELETE' wurde eine API-Methode aufgerufen, die das Element entfernte.  Beim Testen traten jedoch Probleme auf.  Der Tester beschwerte sich √ºber seltsames Verhalten - manchmal passierte nichts, wenn Sie auf die Schaltfl√§che L√∂schen klickten.  Es stellte sich heraus, dass der switchMap-Operator die Ausf√ºhrung von jeweils nur einem Observable unterst√ºtzt, eine Art Schutz gegen Race-Bedingungen. <br><br>  Infolgedessen gebe ich einige Empfehlungen, denen ich folge, und fordere alle, die mit Rx arbeiten, auf, zu folgen: <br><br><ul><li>  Seien Sie aufmerksam. </li><li>  √úberpr√ºfen Sie die Dokumentation. </li><li>  Checken Sie den Sandkasten ein. </li><li>  Schreiben Sie Tests. </li><li>  Schie√üe keine Spatzen aus der Kanone. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460155/">https://habr.com/ru/post/de460155/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460143/index.html">Pythons Dis-Modul und Faltung von Konstanten</a></li>
<li><a href="../de460147/index.html">PHP Microservices Framework - Swoft 2.0.3 ver√∂ffentlicht</a></li>
<li><a href="../de460149/index.html">Richtige Eingabe: Der untersch√§tzte Aspekt von sauberem Code</a></li>
<li><a href="../de460151/index.html">Modellorientiertes Design. B√ºrstenloser Gleichstrommotor</a></li>
<li><a href="../de460153/index.html">Die Abenteuer elektronischer Signaturen in Russland</a></li>
<li><a href="../de460157/index.html">Wie die ‚Äûrichtigen‚Äú Antworten der Befragten die Ergebnisse der Umfrage bis zur Unkenntlichkeit verf√§lschen k√∂nnen</a></li>
<li><a href="../de460159/index.html">Methode zur √úberwachung des aktuellen Zustands russischer Stra√üen mit den Smartphones der Benutzer</a></li>
<li><a href="../de460161/index.html">FusionPBX und ACL</a></li>
<li><a href="../de460163/index.html">Wie es schien</a></li>
<li><a href="../de460165/index.html">Hintergrund: Quantenfinger-Kryptographie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>