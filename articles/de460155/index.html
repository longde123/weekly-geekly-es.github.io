<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💮 💄 👉🏼 ReactiveX Redux ☝🏽 👝 👨🏾‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jeder, der mit Redux arbeitet, wird früher oder später auf das Problem asynchroner Aktionen stoßen. Eine moderne Anwendung kann jedoch nicht ohne sie ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ReactiveX Redux</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alfa/blog/460155/">  Jeder, der mit Redux arbeitet, wird früher oder später auf das Problem asynchroner Aktionen stoßen.  Eine moderne Anwendung kann jedoch nicht ohne sie entwickelt werden.  Dies sind http-Anfragen an das Backend und alle Arten von Timern / Verzögerungen.  Die Redux-Ersteller selbst sprechen eindeutig - standardmäßig wird nur der synchrone Datenfluss unterstützt, alle asynchronen Aktionen müssen in der Middleware platziert werden. <br><br>  Dies ist natürlich zu ausführlich und unpraktisch, sodass es schwierig ist, einen Entwickler zu finden, der nur die "native" Middleware verwendet.  Bibliotheken und Frameworks wie Thunk, Saga und dergleichen helfen immer. <br><br>  Für die meisten Aufgaben reichen sie aus.  Was aber, wenn eine etwas komplexere Logik erforderlich ist, als eine Anfrage zu senden oder einen Timer zu erstellen?  Hier ist ein kleines Beispiel: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> dispatch =&gt; { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> .all([fetchOne, fetchTwo]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[respOne, respTwo]</span></span></span><span class="hljs-function">) =&gt;</span></span> { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'SUCCESS'</span></span>, respOne, respTwo }); }); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FAILED'</span></span>, error }); } }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }</code> </pre> <br>  Es ist schmerzhaft, sich solchen Code anzusehen, aber es ist einfach unmöglich, ihn zu pflegen und zu erweitern.  Was tun, wenn eine komplexere Fehlerbehandlung erforderlich ist?  Was ist, wenn Sie eine Wiederholungsanfrage benötigen?  Und wenn ich diese Funktion wiederverwenden möchte? <br><br>  Mein Name ist Dmitry Samokhvalov, und in diesem Beitrag werde ich Ihnen erklären, was das Konzept von Observable ist und wie es in Verbindung mit Redux in die Praxis umgesetzt werden kann, und all dies mit den Fähigkeiten von Redux-Saga vergleichen. <br><a name="habracut"></a><br>  Nehmen Sie in solchen Fällen in der Regel die Redux-Saga.  OK, wir schreiben die Sagen neu: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> call(delay, <span class="hljs-number"><span class="hljs-number">2000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [respOne, respTwo] = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> [ call(fetchOne), call(fetchTwo) ]; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> put({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'SUCCESS'</span></span>, respOne, respTwo }); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> put({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FAILED'</span></span>, error }); }</code> </pre><br>  Es ist spürbar besser geworden - der Code ist fast linear, sieht besser aus und liest sich besser.  Das Erweitern und Wiederverwenden ist jedoch immer noch schwierig, da die Saga genauso wichtig ist wie der Thunk. <br><br>  Es gibt einen anderen Ansatz.  Dies ist genau der Ansatz und nicht nur eine andere Bibliothek zum Schreiben von asynchronem Code.  Es heißt Rx (es handelt sich auch um Observables, Reactive Streams usw.).  Wir werden es verwenden und das Beispiel auf Observable neu schreiben: <br><br><pre> <code class="javascript hljs">action$ .delay(<span class="hljs-number"><span class="hljs-number">2000</span></span>) .switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> Observable.merge(fetchOne, fetchTwo) .map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[respOne, respTwo]</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'SUCCESS'</span></span>, respOne, respTwo })) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FAILED'</span></span>, error }))</code> </pre> <br>  Der Code wurde nicht nur flach und nahm an Volumen ab, auch das Prinzip der Beschreibung asynchroner Aktionen hat sich geändert.  Jetzt arbeiten wir nicht direkt mit Abfragen, sondern führen Operationen an speziellen Objekten aus, die als Observable bezeichnet werden. <br><br>  Es ist zweckmäßig, Observable als eine Funktion darzustellen, die einen Strom (eine Folge) von Werten ergibt.  Observable hat drei Hauptzustände - next ("Geben Sie den nächsten Wert"), error ("ein Fehler ist aufgetreten") und complete ("die Werte sind vorbei, es gibt nichts mehr zu geben").  In dieser Hinsicht ist es ein bisschen wie Promise, unterscheidet sich jedoch darin, dass es möglich ist, über diese Werte zu iterieren (und dies ist eine der beobachtbaren Supermächte).  Sie können alles in Observable einschließen - Timeouts, http-Anforderungen, DOM-Ereignisse, nur js-Objekte. <br><br><img src="https://habrastorage.org/webt/be/qu/yr/bequyrg-gjvichysgtzom-c0mju.png" width="540"><br><br>  Die zweite beobachtbare Supermacht sind Betreiber.  Ein Operator ist eine Funktion, die eine Observable akzeptiert und zurückgibt, jedoch eine Aktion für den Wertestrom ausführt.  Die nächste Analogie ist Map und Filter aus Javascript (solche Operatoren sind übrigens in Rx). <br><br><img src="https://habrastorage.org/webt/bu/hi/mc/buhimcdgpjmngscttymdt1rzsqk.png" width="540"><br><br>  Am nützlichsten für mich persönlich waren die Operatoren zip, forkJoin und flatMap.  Anhand ihres Beispiels ist es am einfachsten, die Arbeit der Bediener zu erklären. <br><br>  Der Zip-Operator funktioniert sehr einfach - er benötigt einige Observable (nicht mehr als 9) und gibt in einem Array die von ihnen ausgegebenen Werte zurück. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = fromEvent(<span class="hljs-string"><span class="hljs-string">"mousedown"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = fromEvent(<span class="hljs-string"><span class="hljs-string">"mouseup"</span></span>); zip(first, second) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${e[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">0</span></span></span></span><span class="hljs-string"><span class="hljs-subst">].x}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${e[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst">].x}</span></span></span><span class="hljs-string">`</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//output [119,120] [120,233] …</span></span></code> </pre><br>  Im Allgemeinen kann die Arbeit von zip durch das Schema dargestellt werden: <br><br><img src="https://habrastorage.org/webt/zu/4j/in/zu4jinxmtwpt4vs3azoy81a6xpc.png" width="540"><br><br>  Zip wird verwendet, wenn Sie mehrere Observable haben und konsistent Werte von ihnen empfangen müssen (trotz der Tatsache, dass sie in unterschiedlichen Intervallen synchron oder nicht synchron ausgegeben werden können).  Dies ist sehr nützlich, wenn Sie mit DOM-Ereignissen arbeiten. <br><br>  Die forkJoin-Anweisung ähnelt zip mit einer Ausnahme: Sie gibt nur die neuesten Werte von jedem Observable zurück. <br><br><img src="https://habrastorage.org/webt/3p/mb/s6/3pmbs6uzqz4w9c3fklfhslw6j6k.png" width="540"><br><br>  Dementsprechend ist es sinnvoll, es zu verwenden, wenn nur endliche Werte aus dem Stream benötigt werden. <br>  Etwas komplizierter ist der flatMap-Operator.  Es nimmt ein Observable als Eingabe und gibt ein neues Observable zurück und ordnet die Werte daraus dem neuen Observable zu, wobei entweder eine Auswahlfunktion oder ein anderes Observable verwendet wird.  Es klingt verwirrend, aber das Diagramm ist ziemlich einfach: <br><br><img src="https://habrastorage.org/webt/kz/7t/fn/kz7tfnjuhklblx5czaxhbs06_mi.png" width="540"><br><br>  Noch klarer im Code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${value}</span></span></span><span class="hljs-string"> World`</span></span>); observable .flatMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> promise(value)) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result)); <span class="hljs-comment"><span class="hljs-comment">//output "Hello World"</span></span></code> </pre> <br>  In den meisten Fällen wird flatMap zusammen mit switchMap und concatMap in Backend-Anforderungen verwendet. <br>  Wie kann ich Rx in Redux verwenden?  Dafür gibt es eine wunderbare Redux-beobachtbare Bibliothek.  Die Architektur sieht folgendermaßen aus: <br><br><img src="https://habrastorage.org/webt/9p/y1/kv/9py1kvsgrpqjaovs3zrukrghbwc.png" width="540"><br><br>  Alle Observable-Operatoren und Aktionen auf ihnen werden in Form einer speziellen Middleware namens Epic ausgeführt.  Jedes Epos nimmt eine Aktion als Eingabe, verpackt sie in ein Observable und sollte eine Aktion zurückgeben, auch als Observable.  Sie können keine reguläre Aktion zurückgeben, dies erzeugt eine Endlosschleife.  Lassen Sie uns ein kleines Epos schreiben, das eine Anfrage an api stellt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fetchEpic = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action$</span></span></span><span class="hljs-function"> =&gt;</span></span> action$ .ofType(<span class="hljs-string"><span class="hljs-string">'FETCH_INFO'</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FETCH_START'</span></span> })) .flatMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> Observable .from(apiRequest) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FETCH_SUCCESS'</span></span>, data })) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FETCH_ERROR'</span></span>, error })) )</code> </pre><br>  Es ist unmöglich, auf den Vergleich von Redux-Observable und Redux-Saga zu verzichten.  Vielen scheint es, dass sie in Funktionalität und Fähigkeiten nahe beieinander liegen, aber dies ist überhaupt nicht der Fall.  Sagas sind ein absolut zwingendes Werkzeug, im Wesentlichen eine Reihe von Methoden zum Arbeiten mit Nebenwirkungen.  Observable ist eine grundlegend andere Art, asynchronen Code zu schreiben, wenn Sie möchten, eine andere Philosophie. <br><br>  Ich habe mehrere Beispiele geschrieben, um die Möglichkeiten und den Ansatz zur Lösung von Problemen zu veranschaulichen. <br><br>  Angenommen, wir müssen einen Timer implementieren, der durch Aktion stoppt.  So sieht es in den Sagen aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> race({ <span class="hljs-attr"><span class="hljs-attr">stopped</span></span>: take(<span class="hljs-string"><span class="hljs-string">'STOP'</span></span>), <span class="hljs-attr"><span class="hljs-attr">tick</span></span>: call(wait, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!timer.stopped) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> put(actions.tick()) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } }</code> </pre> <br>  Verwenden Sie jetzt Rx: <br><br><pre> <code class="javascript hljs">interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>) .takeUntil(action$.ofType(<span class="hljs-string"><span class="hljs-string">'STOP'</span></span>))</code> </pre> <br><br>  Angenommen, es gibt eine Aufgabe zum Implementieren einer Anforderung mit Stornierung in Sagen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchSaga</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> call(fetchUser); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> take(<span class="hljs-string"><span class="hljs-string">'FETCH'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fetchSaga = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fork(fetchSaga); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> take(<span class="hljs-string"><span class="hljs-string">'FETCH_CANCEL'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> cancel(fetchSaga); }</code> </pre> <br>  Bei Rx ist alles einfacher: <br><br><pre> <code class="javascript hljs">switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchUser()) .takeUntil(action$.ofType(<span class="hljs-string"><span class="hljs-string">'FETCH_CANCEL'</span></span>))</code> </pre> <br>  Endlich mein Favorit.  Implementieren Sie eine API-Anfrage. Stellen Sie im Fehlerfall nicht mehr als 5 wiederholte Anfragen mit einer Verzögerung von 2 Sekunden.  Folgendes haben wir in den Sagen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> apiResponse = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> call(apiRequest); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apiResponse; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">2000</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(); }</code> </pre> <br>  Was passiert auf Rx: <br><br><pre> <code class="javascript hljs">.retryWhen(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">errors</span></span></span><span class="hljs-function"> =&gt;</span></span> errors .delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>) .take(<span class="hljs-number"><span class="hljs-number">5</span></span>))</code> </pre><br>  Wenn Sie die Vor- und Nachteile der Saga zusammenfassen, erhalten Sie das folgende Bild: <br><br><img src="https://habrastorage.org/webt/y6/bs/un/y6bsun3cbbwp4tayqhuuhwpudyc.png" width="540"><br><br>  Sagas sind leicht zu erlernen und sehr beliebt, sodass Sie in der Community Rezepte für fast alle Gelegenheiten finden können.  Leider verhindert der imperative Stil die Verwendung der Sagen wirklich flexibel. <br><br>  Rx hat eine ganz andere Situation: <br><br><img src="https://habrastorage.org/webt/mc/5a/wx/mc5awxjs7lszbo9jcq-qzrzg2qa.png" width="540"><br><br>  Es scheint, dass Rx ein magischer Hammer und eine Silberkugel ist.  Dies ist leider nicht so.  Der Schwellenwert für die Eingabe von Rx ist viel höher, daher ist es schwieriger, eine neue Person in ein Projekt einzuführen, das Rx aktiv nutzt. <br><br>  Darüber hinaus ist es bei der Arbeit mit Observable besonders wichtig, vorsichtig zu sein und immer gut zu verstehen, was passiert.  Andernfalls können Sie auf nicht offensichtliche Fehler oder undefiniertes Verhalten stoßen. <br><br><pre> <code class="javascript hljs">action$ .ofType(<span class="hljs-string"><span class="hljs-string">'DELETE'</span></span>) .switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> Observable .fromPromise(deleteRequest) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'DELETE_SUCCESS'</span></span>})))</code> </pre> <br>  Nachdem ich ein Epos geschrieben hatte, das einen ziemlich einfachen Job machte - mit jeder Aktion vom Typ 'DELETE' wurde eine API-Methode aufgerufen, die das Element entfernte.  Beim Testen traten jedoch Probleme auf.  Der Tester beschwerte sich über seltsames Verhalten - manchmal passierte nichts, wenn Sie auf die Schaltfläche Löschen klickten.  Es stellte sich heraus, dass der switchMap-Operator die Ausführung von jeweils nur einem Observable unterstützt, eine Art Schutz gegen Race-Bedingungen. <br><br>  Infolgedessen gebe ich einige Empfehlungen, denen ich folge, und fordere alle, die mit Rx arbeiten, auf, zu folgen: <br><br><ul><li>  Seien Sie aufmerksam. </li><li>  Überprüfen Sie die Dokumentation. </li><li>  Checken Sie den Sandkasten ein. </li><li>  Schreiben Sie Tests. </li><li>  Schieße keine Spatzen aus der Kanone. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460155/">https://habr.com/ru/post/de460155/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460143/index.html">Pythons Dis-Modul und Faltung von Konstanten</a></li>
<li><a href="../de460147/index.html">PHP Microservices Framework - Swoft 2.0.3 veröffentlicht</a></li>
<li><a href="../de460149/index.html">Richtige Eingabe: Der unterschätzte Aspekt von sauberem Code</a></li>
<li><a href="../de460151/index.html">Modellorientiertes Design. Bürstenloser Gleichstrommotor</a></li>
<li><a href="../de460153/index.html">Die Abenteuer elektronischer Signaturen in Russland</a></li>
<li><a href="../de460157/index.html">Wie die „richtigen“ Antworten der Befragten die Ergebnisse der Umfrage bis zur Unkenntlichkeit verfälschen können</a></li>
<li><a href="../de460159/index.html">Methode zur Überwachung des aktuellen Zustands russischer Straßen mit den Smartphones der Benutzer</a></li>
<li><a href="../de460161/index.html">FusionPBX und ACL</a></li>
<li><a href="../de460163/index.html">Wie es schien</a></li>
<li><a href="../de460165/index.html">Hintergrund: Quantenfinger-Kryptographie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>