<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐲 🌀 😥 Unit Testing in Laravel 📐 🤳🏽 👩🏽‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unter den Diskussionen in der Community höre ich oft die Meinung, dass Unit-Tests in Laravel falsch und kompliziert sind und die Tests selbst lang sin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unit Testing in Laravel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457866/"><p>  Unter den Diskussionen in der Community höre ich oft die Meinung, dass Unit-Tests in Laravel falsch und kompliziert sind und die Tests selbst lang sind und keinen Nutzen bringen.  Aus diesem Grund schreiben nur wenige diese Tests und beschränken sich nur auf Funktionstests, und die Verwendung von Komponententests tendiert zu 0. <br>  Das habe ich auch einmal gedacht, aber einmal habe ich darüber nachgedacht und mich gefragt - vielleicht weiß ich nicht, wie ich sie kochen soll? </p><br><p>  Für einige Zeit verstand ich und am Ausgang hatte ich ein neues Verständnis für Unit-Tests, und die Tests wurden klar, freundlich, schnell und begannen mir zu helfen. <br>  Ich möchte mein Verständnis mit der Community teilen und dieses Thema noch besser verstehen, um meine Tests noch besser zu machen. </p><a name="habracut"></a><br><h2 id="nemnogo-filosofii-i-ogranicheniy">  Ein bisschen Philosophie und Grenzen </h2><br><p>  Laravel ist an einigen Stellen eine Art Rahmen.  Besonders in Bezug auf Fassaden und Eloquent.  Ich werde nicht auf Diskussionen oder Verurteilungen dieser Punkte eingehen, aber ich werde zeigen, wie ich sie mit Unit-Tests kombiniere. <br>  Ich schreibe Tests, nachdem ich (oder gleichzeitig) den Hauptcode geschrieben habe.  Möglicherweise ist mein Ansatz nicht mit dem TDD-Ansatz kompatibel oder erfordert teilweise Anpassungen. </p><br><p> Die wichtigste Frage, die ich mir vor dem Schreiben eines Tests stelle, lautet: „Was genau möchte ich testen?“.  Dies ist ein wichtiges Thema.  Es war diese Idee, die es mir ermöglichte, meine Ansichten zum Schreiben von Komponententests und zum Projektcode selbst zu überdenken. </p><br><p>  Die Tests sollten stabil und minimal von der Umgebung abhängig sein.  Wenn Ihre Tests bei Mutationen fehlschlagen, sind sie höchstwahrscheinlich gut.  Umgekehrt sind sie wahrscheinlich nicht sehr gut, wenn sie nicht fallen. </p><br><p>  Standardmäßig unterstützt Laravel drei Arten von Tests: </p><br><ul><li>  Browser </li><li>  Funktion </li><li>  Einheit </li></ul><br><p>  Ich werde hauptsächlich über Unit-Tests sprechen. </p><br><p>  Ich teste nicht den gesamten Code durch Unit-Tests (möglicherweise ist dies nicht korrekt).  Ich teste überhaupt keinen Code (mehr dazu weiter unten). </p><br><p>  Wenn in den Tests Moques verwendet werden, vergessen Sie nicht, Mockery :: close () für tearDown auszuführen. </p><br><p>  Einige Beispieltests werden "aus dem Internet entnommen". </p><br><h2 id="kak-ya-testiruyu">  Wie ich teste </h2><br><p>  Im Folgenden werde ich Testbeispiele nach Klassengruppen gruppieren und versuchen, Testbeispiele für jede Klassengruppe anzugeben.  Für die meisten Klassengruppen werde ich keine Beispiele für den Code selbst geben. </p><br><h3 id="middleware">  Middleware </h3><br><p>  Für den Middleware-Unit-Test erstelle ich ein Objekt der Request-Klasse, ein Objekt der gewünschten Middleware, rufe dann die Handle-Methode auf und führe die erforderlichen Asserts aus.  Middleware kann entsprechend den durchgeführten Aktionen in 3 Gruppen unterteilt werden: </p><br><ul><li>  Ändern des Anforderungsobjekts (Ändern der Textanforderung oder der Sitzungen) </li><li>  Weiterleiten (Ändern des Antwortstatus) </li><li>  nichts mit dem Anforderungsobjekt tun <br>  Versuchen wir, für jede Gruppe ein Beispiel für einen Test zu geben: </li></ul><br><p>  Angenommen, wir haben die folgende Middleware, deren Aufgabe es ist, das Titelfeld zu ändern: </p><br><pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TitlecaseMiddleware</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($request, Closure $next)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($request-&gt;title) { $request-&gt;merge([ <span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; title_case($request-&gt;title) ]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $next($request); } }</code> </pre> <br><p>  Ein Test für eine ähnliche Middleware könnte folgendermaßen aussehen: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testChangeTitleToTitlecase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request; $request-&gt;merge([ <span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'Title is in mixed CASE'</span></span> ]); $middleware = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TitlecaseMiddleware; $middleware-&gt;handle($request, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals(<span class="hljs-string"><span class="hljs-string">'Title Is In Mixed Case'</span></span>, $req-&gt;title); }); }</code> </pre> <br><p>  Tests für die Gruppen 2 und 3 werden von einem solchen Plan sein: </p><br><pre> <code class="php hljs">$response = $middleware-&gt;handle($request, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{}); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals($response-&gt;getStatusCode(), <span class="hljs-number"><span class="hljs-number">302</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   $this-&gt;assertEquals($response, null); //      request</span></span></code> </pre> <br><h3 id="request-class">  Klasse anfordern </h3><br><p>  Die Hauptaufgabe dieser Klassengruppe ist die Autorisierung und Validierung von Anforderungen. </p><br><p>  Ich teste diese Klassen nicht durch Komponententests (ich gebe zu, dass dies möglicherweise nicht der Fall ist), sondern nur durch Funktionstests.  Meiner Meinung nach sind Unit-Tests für diese Klassen überflüssig, aber ich habe einige interessante Beispiele dafür gefunden, wie dies getan werden kann.  Vielleicht helfen sie Ihnen, wenn Sie sich entscheiden, Ihre Anforderungseinheitsklasse mit Tests zu testen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://medium.com/@daaaan/a-guide-to-unit-testing-laravel-form-requests-in-a-different-way-f1bdb6d86053</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://stackoverflow.com/questions/36978147/unit-test-laravels-formrequest</a> </li></ul><br><h3 id="controller">  Controller </h3><br><p>  Ich teste Controller auch nicht durch Unit-Tests.  Beim Testen verwende ich jedoch eine Funktion, über die ich sprechen möchte. </p><br><p>  Controller sollten meiner Meinung nach leicht sein.  Ihre Aufgabe ist es, die richtige Anfrage zu erhalten, die erforderlichen Dienste und Repositories aufzurufen (da diese beiden Begriffe für Laravel „fremd“ sind, werde ich meine Terminologie unten erläutern) und die Antwort zurückzugeben.  Lösen Sie manchmal ein Ereignis, einen Job usw. aus. <br>  Dementsprechend müssen wir beim Testen durch Funktionstests nicht nur den Controller mit den erforderlichen Parametern aufrufen und die Antwort überprüfen, sondern auch die erforderlichen Dienste sperren und überprüfen, ob sie tatsächlich aufgerufen werden (oder nicht aufgerufen werden).  Manchmal - erstellen Sie einen Datensatz in der Datenbank. </p><br><p>  Ein Beispiel für einen Controller-Test mit einem Serviceklassen-Mock: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testProductCategorySync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $service = Mockery::mock(\App\Services\Product::class); app()-&gt;instance(\App\Services\Product::class, $service); $service-&gt;shouldReceive(<span class="hljs-string"><span class="hljs-string">'sync'</span></span>)-&gt;once(); $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post(<span class="hljs-string"><span class="hljs-string">'/api/v1/sync/eventsCallback'</span></span>, [ <span class="hljs-string"><span class="hljs-string">"eventType"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"PRODUCT_SYNC"</span></span> ]); $response-&gt;assertStatus(<span class="hljs-number"><span class="hljs-number">200</span></span>); }</code> </pre> <br><p>  Ein Beispiel für einen Controller-Test mit einem Fassadenmodell (in unserem Fall ein Ereignis, das jedoch analog für andere Laravel-Fassaden durchgeführt wird): </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testChangeCart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Event::fake(); $user = factory(User::class)-&gt;create(); Passport::actingAs( $user ); $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post(<span class="hljs-string"><span class="hljs-string">'/api/v1/cart/update'</span></span>, [ <span class="hljs-string"><span class="hljs-string">'products'</span></span> =&gt; [ [ <span class="hljs-comment"><span class="hljs-comment">// our changed data ] ], ]); $data = json_decode($response-&gt;getContent()); $response-&gt;assertStatus(200); $this-&gt;assertEquals($user-&gt;id, $data-&gt;data-&gt;userId); // and assert other data from response Event::assertDispatched(CartChanged::class); }</span></span></code> </pre> <br><h3 id="service-i-repositories">  Service und Repositories </h3><br><p>  Diese Arten von Klassen sind sofort einsatzbereit.  Ich versuche, die Controller dünn zu halten, also stelle ich die ganze zusätzliche Arbeit in eine dieser Klassengruppen. </p><br><p>  Ich habe den Unterschied zwischen ihnen wie folgt festgestellt: </p><br><ul><li>  Wenn ich eine Geschäftslogik implementieren muss, füge ich diese in die entsprechende Service-Schicht (Klasse) ein. </li><li>  In allen anderen Fällen habe ich dies in die Repository-Klassengruppe eingefügt.  In der Regel geht die Funktion mit Eloquent dorthin.  Ich verstehe, dass dies nicht ganz die richtige Definition der Repository-Ebene ist.  Ich habe auch gehört, dass einige alles aushalten, was mit Eloquent im Modell zu tun hat.  Mein Ansatz ist meiner Meinung nach eine Art Kompromiss, obwohl "akademisch" nicht ganz richtig ist. </li></ul><br><p>  Für Repository-Klassen schreibe ich fast keine Tests. </p><br><p>  Testbeispiel für Serviceklassen unten: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testUpdateCart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Event::fake(); $cartService = resolve(CartService::class); $cartRepo = resolve(CartRepository::class); $user = factory(User::class)-&gt;make(); $cart = $cartRepo-&gt;getCart($user); <span class="hljs-comment"><span class="hljs-comment">// set data $data = [ ]; $newCart = $cartService-&gt;updateForUser($user, $data); $this-&gt;assertEquals($data, $newCart-&gt;toArray()); Event::assertDispatched(CartChanged::class, 1); }</span></span></code> </pre> <br><h3 id="event-listener-jobs">  Event-Listener, Jobs </h3><br><p>  Diese Klassen werden fast nach dem allgemeinen Prinzip getestet - wir bereiten die zum Testen erforderlichen Daten vor;  Wir rufen die gewünschte Klasse aus dem Framework auf und überprüfen das Ergebnis. <br>  Beispiel für Listener: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testHandle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $user = factory(User::class)-&gt;create(); $cart = Cart::create([ <span class="hljs-string"><span class="hljs-string">'userId'</span></span> =&gt; $user-&gt;id, <span class="hljs-comment"><span class="hljs-comment">// other needed data ]); $listener = new CreateTaskForSyncCart(); $listener-&gt;handle(new CartChanged($cart)); $job = // get our job $this-&gt;assertSame(json_encode($cart-&gt;products), $job-&gt;payload); $this-&gt;assertSame($user-&gt;id, $job-&gt;user_id); // some additional asserts. Work with this data simplest for example $this-&gt;assertTrue($updatedAt-&gt;equalTo($job-&gt;last_updated_at)); }</span></span></code> </pre> <br><h3 id="console-commands">  Konsole Konsole </h3><br><p>  Ich betrachte Konsolenbefehle als eine Art Controller, der zusätzlich Daten ausgeben (und komplexere Manipulationen mit den in der Dokumentation beschriebenen Konsolen-Eingabe / Ausgabe durchführen kann).  Dementsprechend ähneln die Tests dem Controller: Wir überprüfen, ob die erforderlichen Servicemethoden aufgerufen werden, Ereignisse ausgelöst werden (oder nicht) und wir überprüfen auch die Interaktion mit der Konsole (Ausgabe oder Datenanforderung). </p><br><p>  Ein Beispiel für einen ähnlichen Test: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSendCartSyncDataEmptyJobs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $service = m::mock(CartJobsRepository::class); app()-&gt;instance(CartJobsRepository::class, $service); $service-&gt;shouldReceive(<span class="hljs-string"><span class="hljs-string">'getAll'</span></span>) -&gt;once()-&gt;andReturn(collect([])); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;artisan(<span class="hljs-string"><span class="hljs-string">'sync:cart'</span></span>) -&gt;expectsOutput(<span class="hljs-string"><span class="hljs-string">'Get all jobs for sending...'</span></span>) -&gt;expectsOutput(<span class="hljs-string"><span class="hljs-string">'All count for sending: 0'</span></span>) -&gt;expectsOutput(<span class="hljs-string"><span class="hljs-string">'Empty jobs'</span></span>) -&gt;assertExitCode(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><h3 id="otdelnye-vneshnie-biblioteki">  Separate externe Bibliotheken </h3><br><p>  Wenn separate Bibliotheken über Funktionen für Komponententests verfügen, werden diese in der Regel in der Dokumentation beschrieben.  In anderen Fällen wird die Arbeit mit diesem Code ähnlich wie auf der Serviceschicht getestet.  Es macht keinen Sinn, die Bibliotheken selbst mit Tests abzudecken (nur wenn Sie PR an diese Bibliothek senden möchten), und Sie sollten sie als eine Art Black Box betrachten. </p><br><p>  Bei vielen Projekten muss ich über die API mit anderen Diensten interagieren.  Laravel verwendet häufig die Guzzle-Bibliothek für diese Zwecke.  Es erschien mir zweckmäßig, die gesamte Arbeit mit anderen Diensten in eine separate Klasse des NetworkService-Dienstes einzuteilen.  Dies erleichterte mir das Schreiben und Testen des Hauptcodes und half, die Antworten und die Fehlerbehandlung zu standardisieren. </p><br><p>  Ich gebe Beispiele für verschiedene Tests für meine NetworkService-Klasse: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSuccessfulSendNetworkService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $mockHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MockHandler([ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response(<span class="hljs-number"><span class="hljs-number">200</span></span>), ]); $handler = HandlerStack::create($mockHandler); $client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Client([<span class="hljs-string"><span class="hljs-string">'handler'</span></span> =&gt; $handler]); app()-&gt;instance(\GuzzleHttp\Client::class, $client); $networkService = resolve(NetworkService::class); $response = $networkService-&gt;sendRequestToSite(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals(<span class="hljs-string"><span class="hljs-string">'200'</span></span>, $response-&gt;getStatusCode()); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testUnsupportedMethodSendNetworkService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $networkService = resolve(NetworkService::class); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;expectException(<span class="hljs-string"><span class="hljs-string">'\InvalidArgumentException'</span></span>); $networkService-&gt;sendRequestToSite(<span class="hljs-string"><span class="hljs-string">'PUT'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testUnsetConfigUrlNetworkService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $networkService = resolve(NetworkService::class); Config::shouldReceive(<span class="hljs-string"><span class="hljs-string">'get'</span></span>) -&gt;once() -&gt;with(<span class="hljs-string"><span class="hljs-string">'app.api_url'</span></span>) -&gt;andReturn(<span class="hljs-string"><span class="hljs-string">''</span></span>); Config::shouldReceive(<span class="hljs-string"><span class="hljs-string">'get'</span></span>) -&gt;once() -&gt;with(<span class="hljs-string"><span class="hljs-string">'app.api_token'</span></span>) -&gt;andReturn(<span class="hljs-string"><span class="hljs-string">'token'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;expectException(<span class="hljs-string"><span class="hljs-string">'\InvalidArgumentException'</span></span>); $networkService-&gt;sendRequestToApi(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); }</code> </pre> <br><h2 id="vyvody">  Schlussfolgerungen </h2><br><p>  Dieser Ansatz ermöglicht es mir, besseren und verständlicheren Code zu schreiben, um beim Schreiben von Code die Vorteile von SOLID- und SRP-Ansätzen zu nutzen.  Meine Tests wurden schneller und vor allem - sie kamen mir zugute. </p><br><p>  Durch aktives Refactoring beim Erweitern oder Ändern der Funktionalität sehen wir sofort, was genau abfällt, und können Fehler schnell und genau korrigieren, ohne sie aus der lokalen Umgebung freizugeben.  Dies macht die Fehlerkorrektur so billig wie möglich. </p><br><p>  Ich hoffe, dass die von mir beschriebenen Prinzipien und Ansätze Ihnen helfen werden, mit Unit-Tests in Laravel umzugehen und Unit-Tests zu Ihren Assistenten bei der Code-Entwicklung zu machen. </p><br><p>  Schreiben Sie Ihre Ergänzungen und Kommentare. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457866/">https://habr.com/ru/post/de457866/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457852/index.html">Analyse: Wie sich Probleme mit den US-Behörden auf das Huawei- und IT-Geschäft auswirken werden</a></li>
<li><a href="../de457854/index.html">Hallo von den Programmierern der 80er Jahre</a></li>
<li><a href="../de457860/index.html">Entwicklung einer Anwendung für das Streaming mit Node.js und React</a></li>
<li><a href="../de457862/index.html">iOS Digest Nr. 8 (14. - 27. Juni)</a></li>
<li><a href="../de457864/index.html">Mythen und Legenden der Systemanalyse oder was ein Analyst bei einer Bank tut</a></li>
<li><a href="../de457870/index.html">Projekterstellungsinfrastruktur mit Docker</a></li>
<li><a href="../de457872/index.html">Wie man Zeit verwaltet und aufhört zu zögern?</a></li>
<li><a href="../de457874/index.html">Warum kommen Mitarbeiter zurück? Geschichten von Abreise und Rückkehr</a></li>
<li><a href="../de457876/index.html">Übersetzung: IEEE 802.15.4z Standard. Was erwartet uns in Zukunft?</a></li>
<li><a href="../de457884/index.html">Souveränes Internet - Klärung von Befehlen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>