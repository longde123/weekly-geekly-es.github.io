<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê≤ üåÄ üò• Unit Testing in Laravel üìê ü§≥üèΩ üë©üèΩ‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unter den Diskussionen in der Community h√∂re ich oft die Meinung, dass Unit-Tests in Laravel falsch und kompliziert sind und die Tests selbst lang sin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unit Testing in Laravel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457866/"><p>  Unter den Diskussionen in der Community h√∂re ich oft die Meinung, dass Unit-Tests in Laravel falsch und kompliziert sind und die Tests selbst lang sind und keinen Nutzen bringen.  Aus diesem Grund schreiben nur wenige diese Tests und beschr√§nken sich nur auf Funktionstests, und die Verwendung von Komponententests tendiert zu 0. <br>  Das habe ich auch einmal gedacht, aber einmal habe ich dar√ºber nachgedacht und mich gefragt - vielleicht wei√ü ich nicht, wie ich sie kochen soll? </p><br><p>  F√ºr einige Zeit verstand ich und am Ausgang hatte ich ein neues Verst√§ndnis f√ºr Unit-Tests, und die Tests wurden klar, freundlich, schnell und begannen mir zu helfen. <br>  Ich m√∂chte mein Verst√§ndnis mit der Community teilen und dieses Thema noch besser verstehen, um meine Tests noch besser zu machen. </p><a name="habracut"></a><br><h2 id="nemnogo-filosofii-i-ogranicheniy">  Ein bisschen Philosophie und Grenzen </h2><br><p>  Laravel ist an einigen Stellen eine Art Rahmen.  Besonders in Bezug auf Fassaden und Eloquent.  Ich werde nicht auf Diskussionen oder Verurteilungen dieser Punkte eingehen, aber ich werde zeigen, wie ich sie mit Unit-Tests kombiniere. <br>  Ich schreibe Tests, nachdem ich (oder gleichzeitig) den Hauptcode geschrieben habe.  M√∂glicherweise ist mein Ansatz nicht mit dem TDD-Ansatz kompatibel oder erfordert teilweise Anpassungen. </p><br><p> Die wichtigste Frage, die ich mir vor dem Schreiben eines Tests stelle, lautet: ‚ÄûWas genau m√∂chte ich testen?‚Äú.  Dies ist ein wichtiges Thema.  Es war diese Idee, die es mir erm√∂glichte, meine Ansichten zum Schreiben von Komponententests und zum Projektcode selbst zu √ºberdenken. </p><br><p>  Die Tests sollten stabil und minimal von der Umgebung abh√§ngig sein.  Wenn Ihre Tests bei Mutationen fehlschlagen, sind sie h√∂chstwahrscheinlich gut.  Umgekehrt sind sie wahrscheinlich nicht sehr gut, wenn sie nicht fallen. </p><br><p>  Standardm√§√üig unterst√ºtzt Laravel drei Arten von Tests: </p><br><ul><li>  Browser </li><li>  Funktion </li><li>  Einheit </li></ul><br><p>  Ich werde haupts√§chlich √ºber Unit-Tests sprechen. </p><br><p>  Ich teste nicht den gesamten Code durch Unit-Tests (m√∂glicherweise ist dies nicht korrekt).  Ich teste √ºberhaupt keinen Code (mehr dazu weiter unten). </p><br><p>  Wenn in den Tests Moques verwendet werden, vergessen Sie nicht, Mockery :: close () f√ºr tearDown auszuf√ºhren. </p><br><p>  Einige Beispieltests werden "aus dem Internet entnommen". </p><br><h2 id="kak-ya-testiruyu">  Wie ich teste </h2><br><p>  Im Folgenden werde ich Testbeispiele nach Klassengruppen gruppieren und versuchen, Testbeispiele f√ºr jede Klassengruppe anzugeben.  F√ºr die meisten Klassengruppen werde ich keine Beispiele f√ºr den Code selbst geben. </p><br><h3 id="middleware">  Middleware </h3><br><p>  F√ºr den Middleware-Unit-Test erstelle ich ein Objekt der Request-Klasse, ein Objekt der gew√ºnschten Middleware, rufe dann die Handle-Methode auf und f√ºhre die erforderlichen Asserts aus.  Middleware kann entsprechend den durchgef√ºhrten Aktionen in 3 Gruppen unterteilt werden: </p><br><ul><li>  √Ñndern des Anforderungsobjekts (√Ñndern der Textanforderung oder der Sitzungen) </li><li>  Weiterleiten (√Ñndern des Antwortstatus) </li><li>  nichts mit dem Anforderungsobjekt tun <br>  Versuchen wir, f√ºr jede Gruppe ein Beispiel f√ºr einen Test zu geben: </li></ul><br><p>  Angenommen, wir haben die folgende Middleware, deren Aufgabe es ist, das Titelfeld zu √§ndern: </p><br><pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TitlecaseMiddleware</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($request, Closure $next)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($request-&gt;title) { $request-&gt;merge([ <span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; title_case($request-&gt;title) ]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $next($request); } }</code> </pre> <br><p>  Ein Test f√ºr eine √§hnliche Middleware k√∂nnte folgenderma√üen aussehen: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testChangeTitleToTitlecase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request; $request-&gt;merge([ <span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'Title is in mixed CASE'</span></span> ]); $middleware = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TitlecaseMiddleware; $middleware-&gt;handle($request, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals(<span class="hljs-string"><span class="hljs-string">'Title Is In Mixed Case'</span></span>, $req-&gt;title); }); }</code> </pre> <br><p>  Tests f√ºr die Gruppen 2 und 3 werden von einem solchen Plan sein: </p><br><pre> <code class="php hljs">$response = $middleware-&gt;handle($request, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{}); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals($response-&gt;getStatusCode(), <span class="hljs-number"><span class="hljs-number">302</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   $this-&gt;assertEquals($response, null); //      request</span></span></code> </pre> <br><h3 id="request-class">  Klasse anfordern </h3><br><p>  Die Hauptaufgabe dieser Klassengruppe ist die Autorisierung und Validierung von Anforderungen. </p><br><p>  Ich teste diese Klassen nicht durch Komponententests (ich gebe zu, dass dies m√∂glicherweise nicht der Fall ist), sondern nur durch Funktionstests.  Meiner Meinung nach sind Unit-Tests f√ºr diese Klassen √ºberfl√ºssig, aber ich habe einige interessante Beispiele daf√ºr gefunden, wie dies getan werden kann.  Vielleicht helfen sie Ihnen, wenn Sie sich entscheiden, Ihre Anforderungseinheitsklasse mit Tests zu testen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://medium.com/@daaaan/a-guide-to-unit-testing-laravel-form-requests-in-a-different-way-f1bdb6d86053</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://stackoverflow.com/questions/36978147/unit-test-laravels-formrequest</a> </li></ul><br><h3 id="controller">  Controller </h3><br><p>  Ich teste Controller auch nicht durch Unit-Tests.  Beim Testen verwende ich jedoch eine Funktion, √ºber die ich sprechen m√∂chte. </p><br><p>  Controller sollten meiner Meinung nach leicht sein.  Ihre Aufgabe ist es, die richtige Anfrage zu erhalten, die erforderlichen Dienste und Repositories aufzurufen (da diese beiden Begriffe f√ºr Laravel ‚Äûfremd‚Äú sind, werde ich meine Terminologie unten erl√§utern) und die Antwort zur√ºckzugeben.  L√∂sen Sie manchmal ein Ereignis, einen Job usw. aus. <br>  Dementsprechend m√ºssen wir beim Testen durch Funktionstests nicht nur den Controller mit den erforderlichen Parametern aufrufen und die Antwort √ºberpr√ºfen, sondern auch die erforderlichen Dienste sperren und √ºberpr√ºfen, ob sie tats√§chlich aufgerufen werden (oder nicht aufgerufen werden).  Manchmal - erstellen Sie einen Datensatz in der Datenbank. </p><br><p>  Ein Beispiel f√ºr einen Controller-Test mit einem Serviceklassen-Mock: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testProductCategorySync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $service = Mockery::mock(\App\Services\Product::class); app()-&gt;instance(\App\Services\Product::class, $service); $service-&gt;shouldReceive(<span class="hljs-string"><span class="hljs-string">'sync'</span></span>)-&gt;once(); $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post(<span class="hljs-string"><span class="hljs-string">'/api/v1/sync/eventsCallback'</span></span>, [ <span class="hljs-string"><span class="hljs-string">"eventType"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"PRODUCT_SYNC"</span></span> ]); $response-&gt;assertStatus(<span class="hljs-number"><span class="hljs-number">200</span></span>); }</code> </pre> <br><p>  Ein Beispiel f√ºr einen Controller-Test mit einem Fassadenmodell (in unserem Fall ein Ereignis, das jedoch analog f√ºr andere Laravel-Fassaden durchgef√ºhrt wird): </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testChangeCart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Event::fake(); $user = factory(User::class)-&gt;create(); Passport::actingAs( $user ); $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post(<span class="hljs-string"><span class="hljs-string">'/api/v1/cart/update'</span></span>, [ <span class="hljs-string"><span class="hljs-string">'products'</span></span> =&gt; [ [ <span class="hljs-comment"><span class="hljs-comment">// our changed data ] ], ]); $data = json_decode($response-&gt;getContent()); $response-&gt;assertStatus(200); $this-&gt;assertEquals($user-&gt;id, $data-&gt;data-&gt;userId); // and assert other data from response Event::assertDispatched(CartChanged::class); }</span></span></code> </pre> <br><h3 id="service-i-repositories">  Service und Repositories </h3><br><p>  Diese Arten von Klassen sind sofort einsatzbereit.  Ich versuche, die Controller d√ºnn zu halten, also stelle ich die ganze zus√§tzliche Arbeit in eine dieser Klassengruppen. </p><br><p>  Ich habe den Unterschied zwischen ihnen wie folgt festgestellt: </p><br><ul><li>  Wenn ich eine Gesch√§ftslogik implementieren muss, f√ºge ich diese in die entsprechende Service-Schicht (Klasse) ein. </li><li>  In allen anderen F√§llen habe ich dies in die Repository-Klassengruppe eingef√ºgt.  In der Regel geht die Funktion mit Eloquent dorthin.  Ich verstehe, dass dies nicht ganz die richtige Definition der Repository-Ebene ist.  Ich habe auch geh√∂rt, dass einige alles aushalten, was mit Eloquent im Modell zu tun hat.  Mein Ansatz ist meiner Meinung nach eine Art Kompromiss, obwohl "akademisch" nicht ganz richtig ist. </li></ul><br><p>  F√ºr Repository-Klassen schreibe ich fast keine Tests. </p><br><p>  Testbeispiel f√ºr Serviceklassen unten: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testUpdateCart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Event::fake(); $cartService = resolve(CartService::class); $cartRepo = resolve(CartRepository::class); $user = factory(User::class)-&gt;make(); $cart = $cartRepo-&gt;getCart($user); <span class="hljs-comment"><span class="hljs-comment">// set data $data = [ ]; $newCart = $cartService-&gt;updateForUser($user, $data); $this-&gt;assertEquals($data, $newCart-&gt;toArray()); Event::assertDispatched(CartChanged::class, 1); }</span></span></code> </pre> <br><h3 id="event-listener-jobs">  Event-Listener, Jobs </h3><br><p>  Diese Klassen werden fast nach dem allgemeinen Prinzip getestet - wir bereiten die zum Testen erforderlichen Daten vor;  Wir rufen die gew√ºnschte Klasse aus dem Framework auf und √ºberpr√ºfen das Ergebnis. <br>  Beispiel f√ºr Listener: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testHandle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $user = factory(User::class)-&gt;create(); $cart = Cart::create([ <span class="hljs-string"><span class="hljs-string">'userId'</span></span> =&gt; $user-&gt;id, <span class="hljs-comment"><span class="hljs-comment">// other needed data ]); $listener = new CreateTaskForSyncCart(); $listener-&gt;handle(new CartChanged($cart)); $job = // get our job $this-&gt;assertSame(json_encode($cart-&gt;products), $job-&gt;payload); $this-&gt;assertSame($user-&gt;id, $job-&gt;user_id); // some additional asserts. Work with this data simplest for example $this-&gt;assertTrue($updatedAt-&gt;equalTo($job-&gt;last_updated_at)); }</span></span></code> </pre> <br><h3 id="console-commands">  Konsole Konsole </h3><br><p>  Ich betrachte Konsolenbefehle als eine Art Controller, der zus√§tzlich Daten ausgeben (und komplexere Manipulationen mit den in der Dokumentation beschriebenen Konsolen-Eingabe / Ausgabe durchf√ºhren kann).  Dementsprechend √§hneln die Tests dem Controller: Wir √ºberpr√ºfen, ob die erforderlichen Servicemethoden aufgerufen werden, Ereignisse ausgel√∂st werden (oder nicht) und wir √ºberpr√ºfen auch die Interaktion mit der Konsole (Ausgabe oder Datenanforderung). </p><br><p>  Ein Beispiel f√ºr einen √§hnlichen Test: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSendCartSyncDataEmptyJobs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $service = m::mock(CartJobsRepository::class); app()-&gt;instance(CartJobsRepository::class, $service); $service-&gt;shouldReceive(<span class="hljs-string"><span class="hljs-string">'getAll'</span></span>) -&gt;once()-&gt;andReturn(collect([])); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;artisan(<span class="hljs-string"><span class="hljs-string">'sync:cart'</span></span>) -&gt;expectsOutput(<span class="hljs-string"><span class="hljs-string">'Get all jobs for sending...'</span></span>) -&gt;expectsOutput(<span class="hljs-string"><span class="hljs-string">'All count for sending: 0'</span></span>) -&gt;expectsOutput(<span class="hljs-string"><span class="hljs-string">'Empty jobs'</span></span>) -&gt;assertExitCode(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><h3 id="otdelnye-vneshnie-biblioteki">  Separate externe Bibliotheken </h3><br><p>  Wenn separate Bibliotheken √ºber Funktionen f√ºr Komponententests verf√ºgen, werden diese in der Regel in der Dokumentation beschrieben.  In anderen F√§llen wird die Arbeit mit diesem Code √§hnlich wie auf der Serviceschicht getestet.  Es macht keinen Sinn, die Bibliotheken selbst mit Tests abzudecken (nur wenn Sie PR an diese Bibliothek senden m√∂chten), und Sie sollten sie als eine Art Black Box betrachten. </p><br><p>  Bei vielen Projekten muss ich √ºber die API mit anderen Diensten interagieren.  Laravel verwendet h√§ufig die Guzzle-Bibliothek f√ºr diese Zwecke.  Es erschien mir zweckm√§√üig, die gesamte Arbeit mit anderen Diensten in eine separate Klasse des NetworkService-Dienstes einzuteilen.  Dies erleichterte mir das Schreiben und Testen des Hauptcodes und half, die Antworten und die Fehlerbehandlung zu standardisieren. </p><br><p>  Ich gebe Beispiele f√ºr verschiedene Tests f√ºr meine NetworkService-Klasse: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSuccessfulSendNetworkService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $mockHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MockHandler([ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response(<span class="hljs-number"><span class="hljs-number">200</span></span>), ]); $handler = HandlerStack::create($mockHandler); $client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Client([<span class="hljs-string"><span class="hljs-string">'handler'</span></span> =&gt; $handler]); app()-&gt;instance(\GuzzleHttp\Client::class, $client); $networkService = resolve(NetworkService::class); $response = $networkService-&gt;sendRequestToSite(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals(<span class="hljs-string"><span class="hljs-string">'200'</span></span>, $response-&gt;getStatusCode()); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testUnsupportedMethodSendNetworkService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $networkService = resolve(NetworkService::class); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;expectException(<span class="hljs-string"><span class="hljs-string">'\InvalidArgumentException'</span></span>); $networkService-&gt;sendRequestToSite(<span class="hljs-string"><span class="hljs-string">'PUT'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testUnsetConfigUrlNetworkService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $networkService = resolve(NetworkService::class); Config::shouldReceive(<span class="hljs-string"><span class="hljs-string">'get'</span></span>) -&gt;once() -&gt;with(<span class="hljs-string"><span class="hljs-string">'app.api_url'</span></span>) -&gt;andReturn(<span class="hljs-string"><span class="hljs-string">''</span></span>); Config::shouldReceive(<span class="hljs-string"><span class="hljs-string">'get'</span></span>) -&gt;once() -&gt;with(<span class="hljs-string"><span class="hljs-string">'app.api_token'</span></span>) -&gt;andReturn(<span class="hljs-string"><span class="hljs-string">'token'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;expectException(<span class="hljs-string"><span class="hljs-string">'\InvalidArgumentException'</span></span>); $networkService-&gt;sendRequestToApi(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); }</code> </pre> <br><h2 id="vyvody">  Schlussfolgerungen </h2><br><p>  Dieser Ansatz erm√∂glicht es mir, besseren und verst√§ndlicheren Code zu schreiben, um beim Schreiben von Code die Vorteile von SOLID- und SRP-Ans√§tzen zu nutzen.  Meine Tests wurden schneller und vor allem - sie kamen mir zugute. </p><br><p>  Durch aktives Refactoring beim Erweitern oder √Ñndern der Funktionalit√§t sehen wir sofort, was genau abf√§llt, und k√∂nnen Fehler schnell und genau korrigieren, ohne sie aus der lokalen Umgebung freizugeben.  Dies macht die Fehlerkorrektur so billig wie m√∂glich. </p><br><p>  Ich hoffe, dass die von mir beschriebenen Prinzipien und Ans√§tze Ihnen helfen werden, mit Unit-Tests in Laravel umzugehen und Unit-Tests zu Ihren Assistenten bei der Code-Entwicklung zu machen. </p><br><p>  Schreiben Sie Ihre Erg√§nzungen und Kommentare. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457866/">https://habr.com/ru/post/de457866/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457852/index.html">Analyse: Wie sich Probleme mit den US-Beh√∂rden auf das Huawei- und IT-Gesch√§ft auswirken werden</a></li>
<li><a href="../de457854/index.html">Hallo von den Programmierern der 80er Jahre</a></li>
<li><a href="../de457860/index.html">Entwicklung einer Anwendung f√ºr das Streaming mit Node.js und React</a></li>
<li><a href="../de457862/index.html">iOS Digest Nr. 8 (14. - 27. Juni)</a></li>
<li><a href="../de457864/index.html">Mythen und Legenden der Systemanalyse oder was ein Analyst bei einer Bank tut</a></li>
<li><a href="../de457870/index.html">Projekterstellungsinfrastruktur mit Docker</a></li>
<li><a href="../de457872/index.html">Wie man Zeit verwaltet und aufh√∂rt zu z√∂gern?</a></li>
<li><a href="../de457874/index.html">Warum kommen Mitarbeiter zur√ºck? Geschichten von Abreise und R√ºckkehr</a></li>
<li><a href="../de457876/index.html">√úbersetzung: IEEE 802.15.4z Standard. Was erwartet uns in Zukunft?</a></li>
<li><a href="../de457884/index.html">Souver√§nes Internet - Kl√§rung von Befehlen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>