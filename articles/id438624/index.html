<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐓 🏇🏼 ↔️ Kami memprogram peralihan melalui bagian. MicroPython pada esp8266 (sonoff) dengan OTA. Bagian 1 👸🏽 🕎 😑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya. 


 Dalam proses perbaikan, tugas muncul untuk membuat peralihan bagian. Tentu saja, saya ingin melakukannya dengan cara yang paling se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami memprogram peralihan melalui bagian. MicroPython pada esp8266 (sonoff) dengan OTA. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438624/"><p>  Halo semuanya. </p><br><p>  Dalam proses perbaikan, tugas muncul untuk membuat peralihan bagian.  Tentu saja, saya ingin melakukannya dengan cara yang paling sederhana dan paling nyaman, menambahkan fungsi kontrol dasar dari telepon.  Saya memilih teknologi paling sederhana dan paling nyaman untuk ini (tentu saja, menurut saya) - MicroPython, dan mulai melakukannya.  Saya mengambil papan selesai pada esp8266 dan mengalokasikan satu jam waktu luang untuk ini.  Tapi, seperti yang terjadi dengan proyek yang tidak terlalu populer dan tidak berjalan, tugas sedikit berlarut-larut. </p><br><p>  Ternyata, desain yang saya temukan paling nyaman, ternyata, tidak berfungsi sama sekali.  Saya harus meluangkan waktu menganalisis hal ini, selain itu saya memutuskan untuk menggambarkan keseluruhan proses dengan cukup detail.  Volume artikel mulai meningkat dengan cepat, jadi saya memutuskan untuk membaginya menjadi beberapa bagian dan membuang semua detail yang tidak perlu menurut pendapat saya. </p><a name="habracut"></a><br><p>  Bagian pertama terdiri dari tiga bagian: </p><br><ol><li>  Pertimbangan teoretis tentang pemilihan media paling sederhana untuk pengembangan saklar peralihan, </li><li>  Peluncuran praktis dari firmware dasar yang dipilih pada peralatan yang dipilih, perangkap, </li><li>  Pengembangan firmware </li></ol><br><h1>  Memilih lingkungan pengembangan yang paling mudah </h1><br><p>  Untuk rumah pintar seperti "lakukan sendiri jika Anda punya waktu luang sebentar", selain barang-barang klasik (misalnya, stabilitas), daftar persyaratan peralatan wajib juga menambah kemudahan pengembangan, pemasangan, dan dukungan.  Perangkat tersebut diperlukan untuk dengan mudah menghubungkan sensor yang diperlukan atau perangkat kontrol ke mereka.  Bahwa ada cara yang nyaman dan mudah untuk berkomunikasi dengan seluruh sistem.  Penting untuk memastikan kemudahan penulisan firmware ke perangkat ini, dengan mempertimbangkan bahwa perangkat tersebut dapat ditemukan di tempat yang sulit dijangkau.  Dan tentu saja, kemudahan pengembangan, ini sangat penting untuk DIY, ketika, misalnya, 2 tahun setelah bekerja tanpa kegagalan seluruh sistem <br>  tiba-tiba saya ingin menambahkan beberapa penyesuaian pada firmware.  Untuk melakukan koreksi ini, Anda perlu mengingat cara kerja sistem ini, yang terkadang membutuhkan waktu lebih lama daripada penyesuaian itu sendiri. </p><br><p>  Pertimbangkan contoh biasa: Anda perlu membuat sakelar pass-through sederhana dengan kemampuan untuk mengendalikannya, termasuk dari PC.  Belakangan ini, tugas ini cukup rumit, perlu mengambil beberapa jenis mikrokontroler (yang paling populer adalah avr atau pic), dan untuk menulis firmware, sebagai aturan, Anda harus membaca dokumentasi untuk itu.  Jika Anda ingin melakukan semuanya di luar kotak, Anda harus membuat papan tempat meletakkan AC / DC, mikrokontroler, dan antarmuka komunikasi.  Setelah LUT (atau memesan papan sirkuit cetak), solder semuanya, beli programmer, dan firmware flash.  Dan kemudian setelah 2-3 tahun, jika perlu, untuk memperbaiki sesuatu, cari semua peralatan dan pelajari semuanya dari awal ... </p><br><p>  Untuk menyederhanakan proses ini, solusi siap pakai mulai muncul di pasar.  Solusi paling sukses adalah Arduino.  Solusi ini disediakan oleh IDE, bootloader dengan fungsi pembaruan, yang memungkinkan Anda untuk bekerja dengan perangkat secara eksklusif melalui antarmuka standar tanpa menggunakan programmer.  Itu memungkinkan untuk membuat firmware, hanya memiliki <br>  pemahaman yang sangat dangkal tentang bagaimana semuanya diatur di sana.  Satu set modul eksternal memungkinkan untuk menghubungkan perangkat tanpa setrika.  Tapi bagaimanapun, untuk mengedit Anda perlu menginstal perangkat lunak Arduino, simpan firmware di suatu tempat. </p><br><p>  Sakelar pass-through kami akan menjadi cukup besar, itu akan berisi modul papan Arduino + AC / DC +.  Dan jika Anda perlu melakukan penyesuaian, Anda harus mengingat dengan susah payah di mana letak kode, dan menginstal ulang perangkat lunak Arduino. </p><br><p>  Untuk menyelamatkan diri Anda dari kebutuhan untuk mengkompilasi kode sumber (mis., Menginstal perangkat lunak tambahan dan menyimpannya), solusi yang paling logis tampaknya menggunakan penerjemah atau langsung mengkompilasi kode pada mikrokontroler itu sendiri.  Untungnya, sekarang telah muncul proyek yang memungkinkan ini dilakukan.  Misalnya, NodeMCU, juru bahasa lua untuk mikrokontroler esp8266: firmware itu sendiri memiliki dukungan bawaan untuk sistem file, yang memungkinkan Anda memuat / membaca skrip ke / dari perangkat.  Proyek lain yang cukup serius adalah Micropython, versi python yang dilucuti yang secara khusus dirancang untuk mikrokontroler.  Itu akan dibahas. </p><br><p>  MicroPython adalah implementasi dari salah satu bahasa pemrograman python paling populer saat ini.  Ini mendukung sejumlah besar arsitektur dan SoC (bare-arm, CC3200, esp8266, esp32, nRF, pic16bit, stm32).  Proyek ini secara aktif mengembangkan dan memiliki sejumlah besar modul tambahan. </p><br><p>  Mikroprosesor esp8266 sangat cocok sebagai bagian perangkat keras, karena fakta bahwa modul switch wifi murah yang dibangun di atasnya dijual di pasaran.  Mereka berisi semua yang kita butuhkan: AC / DC, mikrokontroler dengan antarmuka komunikasi bawaan (wifi).  Tersedia dengan nama merek Sonoff.  Mikroprosesor esp8266 tidak mengandung memori, ia disolder secara terpisah dan dapat memiliki ukuran yang berbeda.  Untuk Sonoff Basic mereka menempatkan modul 1Mb. </p><br><h1>  Mulai firmware dasar pada esp8266.  Sonoff Basic. </h1><br><p>  Dengan tidak adanya jebakan, akan mungkin untuk segera melanjutkan pemrograman ke python.  Namun, sayangnya, ada sejumlah masalah yang perlu dipecahkan, agar program dan modifikasi firmware itu sangat mudah dan sederhana.  Tentu saja, kami tertarik melakukan ini melalui wifi, tanpa menggunakan perangkat tambahan apa pun kecuali laptop. </p><br><p>  Jebakan pertama, tentu saja, adalah firmware dasar yang direkam di papan Anda.  Jika Anda membeli papan debug, kemungkinan besar Anda akan menemukan NodeMCU di atasnya, jika Sonoff Basic, maka firmware milik.  Untuk mempersiapkan board ini untuk Anda sendiri, Anda perlu menuliskan firmware yang diperlukan di sana.  Dalam beberapa mikrokontroler, perlu untuk membeli <br>  seorang programmer khusus, dalam kasus kami kami beruntung, Anda hanya perlu mendapatkan konverter UART USB.  Jika Anda bekerja dengan mikrokontroler, itu akan berguna lebih dari sekali, dan harganya biasanya di kisaran $ 3. </p><br><p>  Tidak ada sisir untuk Sonoff Basic yang memungkinkan Anda terhubung melalui UART, dan kami membutuhkan ini untuk memprogram perangkat.  Untuk hanya memprogram perangkat, tidak perlu mengambil solder besi di tangan Anda, cukup mencondongkan kontak dan menuliskan firmware.  Mempertimbangkan bahwa pekerjaan lebih lanjut akan melalui wifi, kita tidak perlu lagi kontak ini.  Tapi kami menerapkan saklar melalui bagian, yang berarti kita perlu disolder, <br>  setidaknya tiga kaki. </p><br><p>  Untuk Sonoff Basic, hanya ada 1 konektor GPIO gratis, dan 2 konektor RX, TX.  Mengingat bahwa kita perlu RX, TX sendiri sekali (untuk mem-flash firmware), di masa depan mereka dapat diprogram ulang ke GPIO, karena esp8266 memungkinkan ini.  Tetapi dalam hal ini, kita perlu meninggalkan debugging melalui UART, untungnya kita sudah merencanakan untuk melakukan ini, karena debugging melalui wifi, dari sudut pandang kenyamanan, jauh lebih sederhana. </p><br><p>  Karena versi MicroPython dapat berubah dalam proses, kami tertarik untuk debugging metode pembaruan melalui wifi.  OTA datang untuk menyelamatkan.  OTA adalah firmware yang memungkinkan Anda memprogram ulang perangkat.  Ini bekerja cukup sederhana.  Setelah menyalakan perangkat, firmware menentukan apakah perlu diprogram ulang, jika perlu, meluncurkan spesial <br>  wifi updater, jika tidak, meluncurkan firmware pengguna.  Implementasinya mungkin berbeda, firmware mungkin menimpa dirinya sendiri atau menulis ke area bebas memori.  Anda juga dapat menentukan apakah akan menjalankan program dubbing dengan cara yang berbeda.  Misalnya, pertimbangkan cxumma firmware khusus jika tidak konvergen, <br>  kemudian secara paksa pergi ke flashing.  Anda dapat membaca data dari GPIO atau menulis informasi tentang perlunya memulai pembaruan di tempat lain. </p><br><p>  Sebagai pembaru, proyek MicroPython merujuk ke proyek yaota8266.  Yaota8266 mengklaim akan menginstal perangkat dan menandatangani setiap paket.  Perlu dicatat bahwa kunci publik tertanam di dalam firmware itu sendiri, itulah sebabnya mengapa tidak masuk akal untuk mengunggah firmware yang sudah terpasang, karena perlu untuk menjahit kunci Anda di sana. <br>  Tidak ada fungsi untuk memodifikasi kunci pribadi di gambar yang dirakit, jadi dalam kasus kami lebih mudah untuk merakit firmware sendiri.  Fitur yang menarik adalah bahwa fungsi verifikasi tanda tangan adalah, tetapi dikomentari dalam kode, mis.  pada kenyataannya, kita mendapatkan kesulitan tanpa keuntungan keamanan apa pun.  Versi dasar yaota8266 tidak akan, <br>  Untungnya, ada fork pada github yang menyelesaikan masalah ini, ditambah lagi mereka menambahkan kemampuan untuk menentukan apakah flashing harus dilakukan berdasarkan penulisan ke area RTC, yang memungkinkan untuk beralih MicroPython ke mode bootloader. </p><br><p>  Bahkan setelah menyertakan semua koreksi, firmware OTA kami akan menulis dengan kesalahan, tetapi akan bekerja dengan sukses pada papan debug NodeMCU.  Ini karena batas waktu.  Saat memperbarui dari mesin host, paket UDP dikirim dan respons diharapkan jika perekaman blitz memakan waktu lebih lama dari biasanya, batas waktu habis, dan paket dikirim lagi.  Manfaatnya mudah diperbaiki, <br>  hanya menambah batas waktu dalam kode ota-client. </p><br><p>  Bundel OTA + MicroPython di Sonoff juga memiliki keanehan menarik.  Salah satunya terkait dengan fakta bahwa fungsi standar untuk bekerja dengan SPI Flash di esp-sdk beroperasi dengan blok 4k, dan ukuran blok ini dipilih untuk menerapkan sistem file FAT.  Pada gilirannya, karena fakta bahwa SPI Flash hanya 1Mb, yang ~ 300Kb adalah firmware OTA, ~ 500Kb adalah firmware MicroPython, kurang dari 200Kb tersisa untuk sistem file, mis.  kurang dari 50 blok.  Namun, perpustakaan yang dipilih yang mengimplementasikan fatfs tidak dapat membuat FS di mana terdapat kurang dari 50 blok.Ada beberapa cara untuk menyelesaikan masalah: kurangi ukuran blok (FAT memungkinkan Anda untuk mengatur 512), perbaiki perpustakaan FatFs, gunakan SPI FS (berharap tidak ada keanehan seperti itu).  Saya mengambil jalan mengurangi blok ke 512. </p><br><p>  Mikrokontroler menggunakan SPI Flash - ini adalah memori NOR dan / atau NAND.  Yang luar biasa dari memori ini adalah bahwa tidak ada konsep "tulis data apa pun".  Anda hanya dapat mereset nilai (pada 0xff), atau mengatur bit yang diinginkan ke "0".  SPI Flash biasanya memori NOR, memiliki fungsi mengatur ulang byte ke 0xff, sementara NAND hanya dapat mengatur ulang dengan blok.  Yaitu  jika ukuran minimum blok reset adalah 4k, untuk menulis <br>  Memori 1 byte, perlu membaca seluruh blok, mengatur ulang ke 0xFF, dan kemudian menulis blok dengan mengatur byte yang diinginkan ke nilai yang diinginkan.  Pembuat SPI Flash memiliki kira-kira set API yang sama untuk bekerja, tetapi, seperti yang telah ditunjukkan oleh praktik, perintah untuk menulis satu byte SPI Flash mungkin berbeda.  Di suatu tempat ia akan diatur ulang secara otomatis sebelum menulis ke 0xFF, di suatu tempat tidak. </p><br><p>  Jika Anda mengubah bagian FAT menjadi 512 byte, ada peluang untuk mendapatkan sistem yang rusak jika SPI Flash tertentu tidak mendukung reset byte otomatis saat merekam.  Dan itu hanya kenangan yang saya temukan di Sonoff Basic.  Rumor mengatakan bahwa mereka dulu menginstal Winbond 25q80bv di sana, tetapi sekarang PUYA 25q80h, yang memiliki blok pembersih minimum 256 byte.  Tampaknya solusi <br>  sederhana, Anda hanya perlu menghapus dua halaman di mana ia akan ditulis sebelum menulis blok FAT, tetapi implementasinya rumit oleh fakta bahwa sdk-esp hanya mendukung penghapusan dalam blok 4k.  Karena menulis ke FAT akan sangat jarang untuk pergantian kami, <br>  hanya ketika memperbarui skrip firmware, Anda dapat melakukan yang buruk dan memperbarui blok 512 byte dalam blok 4k.  Dokumentasi untuk memori ini mengatakan bahwa memori dapat menahan 100.000 siklus penulisan ulang, yaitu  pengelakan masalah yang serupa akan mengurangi nilai ini sebanyak 4 kali, yaitu  hingga 25.000. </p><br><p>  MicroPython memiliki konsol secara default, itu disebut REPL dan bekerja melalui port COM.  Kami tidak terlalu senang dengan keadaan ini, karena kami ingin berkomunikasi dengan perangkat melalui wifi.  Untungnya dalam MicroPython, WebRepl juga datang standar, tetapi tidak memulai secara otomatis.  Anda dapat mendaftarkan autorun di boot.py, tetapi saya memutuskan untuk menjalankannya langsung dari _boot.py, file sistem, itu dijahit ke dalam file firmware itu sendiri. </p><br><p>  Setelah mulai pertama, firmware kami akan membuat sistem file, meluncurkan webrepl dan membuat jalur akses.  Anda dapat menghubungkannya dan meresepkan parameter untuk menghubungkan ke jaringan lokal Anda, atau, seperti yang saya lakukan, mengkonfigurasi jaringan menggunakan port com, setelah itu hanya wifi yang harus digunakan. </p><br><p>  Untuk pekerjaan percobaan, Anda dapat menggunakan klien webrepl yang ditulis dalam javascript.  Klien dapat diluncurkan di browser pada halaman proyek yang sesuai.  Pilihan lain adalah menggunakan proyek mpfshell, ini menyediakan fungsi yang lebih nyaman untuk bekerja dengan perangkat. </p><br><p>  Jadi, setelah mengatasi semua jebakan ini, Anda dapat langsung memprogram sakelar. </p><br><h1>  Pengembangan firmware </h1><br><p>  Untuk mengembangkan firmware, kita perlu memiliki gagasan kasar tentang cara kerja GPIO.  Secara umum, ini dapat dipahami sepenuhnya secara intuitif: </p><br><ol><li>  Jika kita mengatur mode output (OUT), maka leg menghasilkan GND atau Vcc. </li><li>  Jika kita mengatur mode input (IN), maka kaki "menggantung di udara", dalam hal ini mikrokontroler dapat memberikan apa pun </li><li>  Agar mikrokontroler tidak memberikan apa-apa, kaki dapat ditarik ke nilai yang diinginkan menggunakan mikrokontroler bawaan <br>  resistor pull-up PULL_UP atau PULL_DOWN. </li></ol><br><p>  Anda juga perlu memiliki gagasan tentang apa interupsi itu: dalam kasus kami, ini adalah kode yang perlu dijalankan jika beberapa jenis peristiwa terjadi: tombol ditekan / dilepaskan atau pesan datang dari jaringan lokal bahwa perangkat harus dimatikan / dihidupkan. </p><br><p>  Untuk memulai, mari kita menulis program saklar sederhana (tidak lewat) dengan Python. </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> machine <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Pin <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SW</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, portin, portout)</span></span></span><span class="hljs-function">:</span></span> self.pin = Pin(portin , Pin.PULL_UP) <span class="hljs-comment"><span class="hljs-comment">#  self.pout = Pin(portout, Pin.OUT) #  #  self._auto(),       self.pin.irq(trigger=Pin.IRQ_RISING|Pin.IRQ_FALLING, handler=self._auto) self.value = 0 def _auto(self, _=0): if self.value: res = self.pin.value() else: res = not self.pin.value() self.pout.value(res) def change(self, val=2): """   0, ,  1, ,  2  """ if val == 2: self.value = not self.value else: self.value = val self._auto() sw = SW(14, 12)</span></span></code> </pre> <br><p>  Saya menamai file switch.py ​​ini dan memerintahkannya untuk berjalan di boot.py: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> switch <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sw</code> </pre> <br><p>  Setelah memulai firmware, saya mendapat objek sw, jika saya menjalankan sw.change (), program akan muncul <br>  beralih ke posisi lain.  Ketika pin gratis disingkat menjadi Vcc di mikrokontroler <br>  relai masing-masing menyala atau mati. </p><br><p>  Langkah selanjutnya adalah peluncuran klien MQTT dan kemampuan untuk beralih dari telepon. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438624/">https://habr.com/ru/post/id438624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438610/index.html">Templat Figma Responsif: Membuat Komponen Desain yang Fleksibel untuk Navigasi Seluler iOS</a></li>
<li><a href="../id438614/index.html">Apa itu animasi idle berkualitas? Pengembang membagikan contoh favorit mereka.</a></li>
<li><a href="../id438618/index.html">Membuat proyektor laser teks DIY</a></li>
<li><a href="../id438620/index.html">Path saya sebagai Pemula</a></li>
<li><a href="../id438622/index.html">Bonsai: mesin wiki keluarga</a></li>
<li><a href="../id438626/index.html">Intisari materi menarik untuk pengembang seluler # 284 (28 Januari - 3 Februari)</a></li>
<li><a href="../id438628/index.html">SharedState Component Change Status Notification</a></li>
<li><a href="../id438630/index.html">Google+ Sic transit gloria mundi ...</a></li>
<li><a href="../id438632/index.html">Hardcore 2D RPG Gamedev Diaries, vol.0 - INTRO, atau "How I Got Here"</a></li>
<li><a href="../id438634/index.html">Di kantor, terlalu panas atau terlalu dingin: apakah ada cara yang lebih baik untuk menyesuaikan suhu?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>