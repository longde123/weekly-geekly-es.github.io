<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüíº ü§´ üî£ Lassen Sie uns versuchen, √ºber hierarchische Zustandsmaschinen im Allgemeinen und deren Unterst√ºtzung in SObjectizer-5 im Besonderen zu sprechen üìü üõåüèº ü§ôüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Finite-State-Maschinen sind vielleicht eines der grundlegendsten und am weitesten verbreiteten Konzepte in der Programmierung. Finite-State-Maschinen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lassen Sie uns versuchen, √ºber hierarchische Zustandsmaschinen im Allgemeinen und deren Unterst√ºtzung in SObjectizer-5 im Besonderen zu sprechen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423497/">  Finite-State-Maschinen sind vielleicht eines der grundlegendsten und am weitesten verbreiteten Konzepte in der Programmierung.  Finite-State-Maschinen (KA) werden in vielen angewandten Nischen aktiv eingesetzt.  Insbesondere in Nischen wie APCS und Telekommunikation, mit denen man sich befassen konnte, sind Raumfahrzeuge etwas seltener anzutreffen als bei jedem Schritt. <br><br>  Daher werden wir in diesem Artikel versuchen, √ºber Raumfahrzeuge zu sprechen, haupts√§chlich √ºber hierarchische endliche Zustandsmaschinen und ihre erweiterten F√§higkeiten.  Und erz√§hlen Sie ein wenig √ºber die Unterst√ºtzung von Raumfahrzeugen in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SObjectizer-5</a> , dem "Actor" -Framework f√ºr C ++.  Eine der <s>beiden</s> wenigen, die offen, frei, plattform√ºbergreifend und noch am Leben sind. <br><br>  Selbst wenn Sie nicht an SObjectizer interessiert sind, aber noch nie von hierarchischen Finite-State-Maschinen geh√∂rt haben oder wie n√ºtzlich solche erweiterten Funktionen eines Raumfahrzeugs wie Eingabe- / Ausgabehandler f√ºr Zust√§nde oder Statusverlauf sind, sind Sie m√∂glicherweise daran interessiert, unter die Katze und zu schauen Lesen Sie mindestens den ersten Teil des Artikels. <br><a name="habracut"></a><br><h1>  Allgemeine Worte zu endlichen Zustandsmaschinen </h1><br>  Wir werden nicht versuchen, ein vollst√§ndiges Bildungsprogramm in dem Artikel zum Thema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Automaten</a> und einer solchen Vielfalt wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">endlichen Zustandsmaschinen</a> durchzuf√ºhren.  Der Leser muss mindestens ein grundlegendes Verst√§ndnis f√ºr diese Art von Entit√§ten haben. <br><br><h2>  Erweiterte Finite-State-Maschinen und ihre F√§higkeiten </h2><br>  Das Raumschiff verf√ºgt √ºber mehrere "erweiterte" Funktionen, die die Benutzerfreundlichkeit des Raumfahrzeugs im Programm erheblich verbessern.  Werfen wir einen kurzen Blick auf diese "erweiterten" Funktionen. <br><br>  Haftungsausschluss: Wenn der Leser mit Zustandsdiagrammen von UML gut vertraut ist, findet er hier nichts Neues f√ºr sich. <br><br><h3>  Hierarchische Zustandsmaschinen </h3><br>  Die vielleicht wichtigste und wertvollste Gelegenheit ist die Organisation einer Hierarchie / Verschachtelung von Staaten.  Denn gerade die F√§higkeit, Zust√§nde ineinander zu versetzen, eliminiert die ‚ÄûExplosion‚Äú der Anzahl der √úberg√§nge von Zustand zu Zustand, wenn die Komplexit√§t des Raumfahrzeugs zunimmt. <br><br>  Es ist schwieriger, dies in Worten zu erkl√§ren, als es anhand eines Beispiels zu zeigen.  Stellen wir uns daher vor, wir haben einen Infokiosk, auf dessen Bildschirm zuerst eine Begr√º√üungsnachricht angezeigt wird.  Der Benutzer kann das Element "Dienste" ausw√§hlen und in den Abschnitt zur Auswahl der Dienste gehen, die er ben√∂tigt.  Oder er kann den Eintrag "Pers√∂nliches Konto" ausw√§hlen und zum Abschnitt √ºber die Arbeit mit seinen pers√∂nlichen Daten und Diensten gehen.  Oder er kann den Abschnitt Hilfe ausw√§hlen.  Bisher scheint alles einfach zu sein und kann durch das folgende Zustandsdiagramm (so vereinfacht wie m√∂glich) dargestellt werden: <br><br><img src="https://habrastorage.org/webt/6e/lv/bm/6elvbm4wcsbmfbjaasp8zynjmtw.png"><br><br>  Versuchen wir jedoch sicherzustellen, dass der Benutzer durch Klicken auf die Schaltfl√§che "Abbrechen" mit einer Begr√º√üungsnachricht von jedem Abschnitt zur Startseite zur√ºckkehren kann: <br><br><img src="https://habrastorage.org/webt/ok/hn/u3/okhnu3xrsjiss8u1fl1gygirn9u.png"><br><br>  Das Schema wird kompliziert, aber immer noch unter Kontrolle.  Wir m√∂chten jedoch daran erinnern, dass wir im Abschnitt "Dienste" m√∂glicherweise mehrere weitere Unterabschnitte haben, z. B. "Beliebte Dienste", "Neue Dienste" und "Vollst√§ndige Liste".  Und von jedem dieser Abschnitte m√ºssen Sie auch zur Startseite zur√ºckkehren.  Unser einfaches Raumschiff wird immer schwieriger: <br><br><img src="https://habrastorage.org/webt/ic/zx/hu/iczxhus-j_5ohrzwdxpbdf5n2qi.png"><br><br>  Aber das ist noch lange nicht alles.  Wir haben den "Zur√ºck" -Button noch nicht ber√ºcksichtigt, mit dem wir zum vorherigen Abschnitt zur√ºckkehren m√ºssen.  F√ºgen wir eine Reaktion auf die Schaltfl√§che "Zur√ºck" hinzu und sehen, was wir erhalten: <br><br><img src="https://habrastorage.org/webt/mn/rq/t7/mnrqt7zjk8kyq6e3i1-jb9fgwya.png"><br><br>  Ja, jetzt sehen wir den Weg zu echtem Spa√ü.  Aber wir haben noch nicht einmal die Unterabschnitte in den Abschnitten "Mein Konto" und "Hilfe" ber√ºcksichtigt ... Wenn wir anfangen, wird unser einfaches Raumschiff fast sofort zu etwas Unvorstellbarem. <br><br>  Hier hilft uns die Verschachtelung von Staaten.  Stellen wir uns vor, wir haben nur zwei Zust√§nde der obersten Ebene: WelcomeScreen und UserSelection.  Alle unsere Abschnitte (dh "Dienste", "Mein Konto" und "Hilfe") werden im UserSelection-Status "verschachtelt".  Sie k√∂nnen sagen, dass die Status ServicesScreen, ProfileScreen und HelpScreen untergeordnete Elemente der UserSelection sind.  Und da sie Kinder sind, erben sie die Reaktion auf einige Signale aus ihrem elterlichen Zustand.  Daher k√∂nnen wir die Antwort auf die Schaltfl√§che Abbrechen in UserSelection definieren.  Wir m√ºssen diese Reaktion jedoch nicht in allen Nebengebieten bestimmen.  Was macht unser Raumschiff pr√§gnanter und verst√§ndlicher: <br><br><img src="https://habrastorage.org/webt/lx/nb/qn/lxnbqn3kqv9rst-fbebmx1kxhi8.png"><br><br>  Hier k√∂nnen Sie feststellen, dass die Reaktion f√ºr "Abbrechen" und "Zur√ºck" wir in UserSelection definiert haben.  Diese Reaktion auf die Schaltfl√§che Abbrechen funktioniert ausnahmslos f√ºr alle UserSelection-Unterzust√§nde (einschlie√ülich eines weiteren zusammengesetzten ServicesSelection-Unterzustands).  Im Unterzustand ServicesSelection ist die Reaktion auf die Schaltfl√§che Zur√ºck bereits anders - die R√ºckgabe erfolgt nicht in WelcomScreen, sondern in ServicesScreen. <br><br>  Zertifizierungsstellen, die eine Hierarchie / Verschachtelung von Zust√§nden verwenden, werden als hierarchische endliche Zustandsmaschinen (ICA) bezeichnet. <br><br><h3>  Reaktion auf Ein- / Ausstieg in / aus dem Staat </h3><br>  Eine sehr n√ºtzliche Funktion ist die M√∂glichkeit, eine Antwort auf das Eintreten in einen bestimmten Zustand sowie eine Reaktion auf das Verlassen eines Zustands zuzuweisen.  Im obigen Beispiel mit einem Infokiosk kann ein Handler aufgeh√§ngt werden, um in jeden der Zust√§nde einzutreten, wodurch der Inhalt des Infokioskbildschirms ge√§ndert wird. <br><br>  Das vorige Beispiel kann etwas erweitert werden.  Angenommen, wir haben zwei Unterzust√§nde in WelcomScreen: BrightWelcomScreen, in dem der Bildschirm normal hervorgehoben wird, und DarkWelcomScreen, in dem die Bildschirmhelligkeit verringert wird.  Wir k√∂nnen einen DarkWelcomScreen-Eingabehandler erstellen, der den Bildschirm dimmt.  Und ein DarkWelcomScreen-Exit-Handler, der die normale Helligkeit wiederherstellt. <br><br><img src="https://habrastorage.org/webt/qm/n0/2y/qmn02yrt9xxxmmawcpzufiexrpg.png"><br><br><h3>  Automatische Zustands√§nderung nach einer festgelegten Zeit </h3><br>  Manchmal kann es erforderlich sein, den Aufenthalt des Raumfahrzeugs in einem bestimmten Zustand zu begrenzen.  Im obigen Beispiel k√∂nnen wir die Zeit, in der unser ICA im BrightWelcomScreen-Status bleibt, auf eine Minute beschr√§nken.  Sobald die Minute abgelaufen ist, wechselt der ICA automatisch in den DarkWelcomScreen-Status. <br><br><h3>  Raumfahrzeuggeschichte </h3><br>  Ein weiteres sehr n√ºtzliches Merkmal von ICA ist die Geschichte des Zustands des Raumfahrzeugs. <br><br>  Stellen wir uns vor, wir haben eine Art abstrakte ICA dieser Art: <br><br><img src="https://habrastorage.org/webt/6i/6n/bl/6i6nblfh7l89fzaulpzsa3mo4a4.png"><br><br>  Dies kann unser ICA von TopLevelState1 zu TopLevelState2 und umgekehrt gehen.  In TopLevelState1 gibt es jedoch mehrere verschachtelte Zust√§nde.  Wenn der ICA einfach von TopLevelState2 zu TopLevelState1 wechselt, werden sofort zwei Status aktiviert: TopLevelState1 und NestedState1.  NestedState1 ist aktiviert, da es sich um den anf√§nglichen Unterzustand des Status TopLevelState1 handelt. <br><br>  Stellen Sie sich nun vor, dass unser ICA seinen Status weiter von NestedState1 in NestedState2 ge√§ndert hat.  In NestedState2 wurde der SubState InternalState1 aktiviert (da dies der urspr√ºngliche Unterzustand f√ºr NestedState2 ist).  Und von InternalState1 gingen wir zu InternalState2.  Somit sind gleichzeitig die folgenden Zust√§nde aktiv: TopLevelState1, NestedState2 und InternalState2.  Und hier gehen wir zu TopLevelState2 (d. H. Wir haben TopLevelState1 im Allgemeinen verlassen). <br><br>  Aktiv wird zu TopLevelState2.  Danach wollen wir zu TopLevelState1 zur√ºckkehren.  Es befindet sich in TopLevelState1 und nicht in einem bestimmten Unterzustand in TopLevelState1. <br><br>  Also, von TopLevelState2 gehen wir zu TopLevelState1 und wo kommen wir hin? <br><br>  Wenn TopLevelState1 keinen Verlauf hat, kommen wir zu TopLevelState1 und NestedState1 (da NestedState1 der anf√§ngliche Unterzustand f√ºr TopLevelState1 ist).  Das hei√üt,  Die ganze Geschichte √ºber die √úberg√§nge in TopLevelState1, die vor dem Verlassen von TopLevelState2 stattfanden, ging vollst√§ndig verloren. <br><br>  Wenn TopLevelState1 eine sogenannte hat  flacher Verlauf, dann kommen wir bei der R√ºckkehr von TopLevelState2 zu TopLevelState1 zu NestedState2 und InternalState1.  Wir gelangen in NestedState2, weil es im Statusverlauf von TopLevelState1 aufgezeichnet ist.  Und wir kommen zu InternalState1, weil es der Start f√ºr NestedState2 ist.  Es stellt sich heraus, dass in der oberfl√§chlichen Historie f√ºr TopLevelState1 Informationen nur √ºber die Unterzust√§nde der allerersten Ebene gespeichert werden.  Die Geschichte der eingebetteten Zust√§nde in diesen Unterzust√§nden bleibt nicht erhalten. <br><br>  Wenn TopLevelState1 jedoch eine lange Geschichte hat, gelangen wir bei der R√ºckkehr von TopLevelState2 zu TopLevelState1 in NestedState2 und InternalState2.  Denn in einer tiefen Geschichte werden vollst√§ndige Informationen √ºber aktive Unterzust√§nde gespeichert, unabh√§ngig von ihrer Tiefe. <br><br><h3>  Orthogonale Zust√§nde </h3><br>  Bisher haben wir ICA untersucht, bei der nur einer der Unterzust√§nde innerhalb des Staates aktiv sein konnte.  Manchmal kann es jedoch Situationen geben, in denen in einem bestimmten ICA-Zustand mehrere gleichzeitig aktive Unterzust√§nde vorhanden sein sollten.  Solche Unterzust√§nde werden orthogonale Zust√§nde genannt. <br><br>  Ein klassisches Beispiel, das orthogonale Zust√§nde demonstriert, ist die bekannte Computertastatur und ihre Modi NumLock, CapsLock und ScrollLock.  Wir k√∂nnen sagen, dass die Arbeit mit NumLock / CapsLock / ScrollLock durch orthogonale Unterzust√§nde im aktiven Zustand beschrieben wird: <br><br><img src="https://habrastorage.org/webt/hv/kf/8p/hvkf8p_gqijakghmndndhlileag.png"><br><br><h3>  Alles, was Sie √ºber endliche Zustandsmaschinen wissen wollten, aber ... </h3><br>  Im Allgemeinen gibt es einen grundlegenden Artikel √ºber formale Notation f√ºr Zustandsdiagramme von David Harel: Zustandsdiagramme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">: Ein visueller Formalismus f√ºr komplexe Systeme (1987)</a> . <br><br>  Dort werden am Beispiel der Steuerung einer gew√∂hnlichen elektronischen Uhr verschiedene Situationen untersucht, die beim Arbeiten mit Finite-State-Maschinen auftreten k√∂nnen.  Wenn jemand es nicht gelesen hat, kann ich es nur empfehlen.  Grunds√§tzlich ging alles, was Harel beschrieb, in die UML-Notation.  Wenn Sie jedoch die Beschreibung von Zustandsdiagrammen aus der UML lesen, verstehen Sie nicht immer, was, warum und wann Sie sie ben√∂tigen.  In dem Artikel von Harel geht die Pr√§sentation jedoch von einfachen zu komplexeren Situationen √ºber.  Und Sie sind sich der Macht bewusst, die endliche Zustandsmaschinen in sich selbst verbergen. <br><br><h1>  Finite-State-Maschinen in SObjectizer </h1><br>  Weiter werden wir √ºber SObjectizer und seine Besonderheiten sprechen.  Wenn Sie die folgenden Beispiele nicht ganz verstehen, ist es m√∂glicherweise sinnvoll, mehr √ºber SObjectizer zu erfahren.  Zum Beispiel aus unserem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersichtsartikel √ºber SObjecizer</a> und mehreren nachfolgenden Artikeln, in denen Leser SObjectizer kennenlernen und von einfach zu komplex wechseln ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erster</a> Artikel, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiter</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dritter</a> ). <br><br><h2>  Agenten in SObjectizer sind Zustandsautomaten </h2><br>  Agenten in SObjectizer waren von Anfang an Zustandsautomaten mit expliziten Zust√§nden.  Selbst wenn der Entwickler des Agenten keinen seiner eigenen Status in seiner Agentenklasse beschrieben hat, hatte der Agent immer noch einen Standardstatus, der standardm√§√üig verwendet wurde.  Wenn ein Entwickler beispielsweise einen so trivialen Agenten erstellt hat: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simple_demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//   ,       . struct how_are_you final : public so_5::signal_t {}; //   ,     . struct quit final : public so_5::signal_t {}; // ..   ,      . simple_demo(context_t ctx) : so_5::agent_t{std::move(ctx)} { so_subscribe_self() .event&lt;how_are_you&gt;([]{ std::cout &lt;&lt; "I'm fine!" &lt;&lt; std::endl; }) .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); } };</span></span></code> </pre> <br>  dann kann er nicht einmal vermuten, dass in Wirklichkeit alle Abonnements, die er gemacht hat, f√ºr den Standardzustand gemacht wurden.  Wenn der Entwickler dem Agenten jedoch seine eigenen Status hinzuf√ºgt, m√ºssen Sie bereits dar√ºber nachdenken, den Agenten ordnungsgem√§√ü im richtigen Status zu signieren.  Hier beispielsweise eine einfache (und wie √ºblich) falsche Modifikation des oben gezeigten Agenten: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simple_demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,  ,   . state_t st_free{this}; // ,  ,   . state_t st_busy{this}; public: //   ,       . struct how_are_you final : public so_5::signal_t {}; //   ,     . struct quit final : public so_5::signal_t {}; // ..   ,      . simple_demo(context_t ctx) : so_5::agent_t{std::move(ctx)} { so_subscribe_self() .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); //   how_are_you   ,    . st_free.event([]{ std::cout &lt;&lt; "I'm free" &lt;&lt; std::endl; }); st_busy.event([]{ std::cout &lt;&lt; "I'm busy" &lt;&lt; std::endl; }); //     st_free. this &gt;&gt;= st_free; } };</span></span></code> </pre> <br>  Wir setzen zwei verschiedene Handler f√ºr das how_are_you-Signal, jeder f√ºr seinen eigenen Status. <br><br>  Und der Fehler bei dieser Modifikation des Agenten "simple_demo" besteht darin, dass der Agent in st_free oder st_busy √ºberhaupt nicht auf das Beenden reagiert, weil  Wir haben das Beendigungsabonnement im Standardzustand belassen, aber die entsprechenden Abonnements f√ºr st_free und st_busy nicht erstellt.  Eine einfache und offensichtliche M√∂glichkeit, dieses Problem zu beheben, besteht darin, st_free und st_busy die entsprechenden Abonnements hinzuzuf√ºgen: <br><pre> <code class="cpp hljs"> simple_demo(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { <span class="hljs-comment"><span class="hljs-comment">//   how_are_you   ,    . st_free .event([]{ std::cout &lt;&lt; "I'm free" &lt;&lt; std::endl; }) .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); st_busy .event([]{ std::cout &lt;&lt; "I'm busy" &lt;&lt; std::endl; }) .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); //     st_free. this &gt;&gt;= st_free; }</span></span></code> </pre> <br>  Richtig, diese Methode riecht nach Kopieren und Einf√ºgen, was nicht gut ist.  Sie k√∂nnen das Kopieren und Einf√ºgen entfernen, indem Sie einen gemeinsamen √ºbergeordneten Status f√ºr st_free und st_busy eingeben: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simple_demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      . state_t st_basic{this}; // ,  ,   . //      st_basic. state_t st_free{initial_substate_of{st_basic}}; // ,  ,   . //     st_basic. state_t st_busy{substate_of{st_basic}}; public: //   ,       . struct how_are_you final : public so_5::signal_t {}; //   ,     . struct quit final : public so_5::signal_t {}; // ..   ,      . simple_demo(context_t ctx) : so_5::agent_t{std::move(ctx)} { //   quit   st_basic    //  ""  . st_basic.event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); //   how_are_you   ,    . st_free.event([]{ std::cout &lt;&lt; "I'm free" &lt;&lt; std::endl; }); st_busy.event([]{ std::cout &lt;&lt; "I'm busy" &lt;&lt; std::endl; }); //     st_free. this &gt;&gt;= st_free; } };</span></span></code> </pre> <br>  Aus Gr√ºnden der Gerechtigkeit sollte hinzugef√ºgt werden, dass Agenten in SObjectizer zun√§chst nur einfache Zustandsmaschinen sein konnten.  Die Unterst√ºtzung f√ºr hierarchische Raumfahrzeuge erschien vor relativ kurzer Zeit im Januar 2016. <br><br><h2>  Warum sind SObjectizer-Agenten Finite-State-Maschinen? </h2><br>  Diese Frage hat eine sehr einfache Antwort: So kam es <s>, dass die</s> Wurzeln von SObjectizer aus der Welt der Prozessleitsysteme stammen und dort sehr oft Finite-State-Maschinen verwendet werden.  Daher hielten wir es f√ºr notwendig, dass die Agenten in SObjectizer auch Zustandsmaschinen sind.  Dies ist sehr praktisch, wenn in der Anwendung, f√ºr die SObjectizer angewendet werden soll, Zertifizierungsstellen verwendet werden.  Und der Standardzustand, den alle Agenten haben, erlaubt es uns, nicht an Raumfahrzeuge zu denken, wenn die Verwendung von Raumfahrzeugen nicht erforderlich ist. <br><br>  Wenn Sie sich das Actors-Modell selbst und die Prinzipien ansehen, auf denen dieses Modell basiert, gilt im Prinzip Folgendes: <br><br><ul><li>  Ein Schauspieler ist eine Einheit mit Verhalten. </li><li>  Akteure reagieren auf eingehende Nachrichten; </li><li>  Nach Erhalt der Nachricht kann der Schauspieler: <br><ul><li>  eine bestimmte Anzahl von Nachrichten an andere Akteure senden; </li><li>  eine Reihe neuer Akteure schaffen; </li><li>  Definieren Sie ein neues Verhalten f√ºr die Verarbeitung nachfolgender Nachrichten. </li></ul></li></ul><br>  Man kann eine starke √Ñhnlichkeit zwischen einfachen Raumfahrzeugen und Schauspielern finden.  Man k√∂nnte sogar sagen, dass Schauspieler einfache endliche Zustandsmaschinen sind. <br><br><h2>  Welche Funktionen von Advanced State Machines unterst√ºtzt SObjectizer? </h2><br>  Von den oben genannten Funktionen fortschrittlicher Finite-State-Maschinen unterst√ºtzt SObjectizer alles au√üer orthogonalen Zust√§nden.  Andere Extras wie verschachtelte Status, Eingabe- / Ausgabehandler, Einschr√§nkungen f√ºr die im Status verbrachte Zeit und der Verlauf f√ºr die Status werden unterst√ºtzt. <br><br>  Mit der Unterst√ºtzung orthogonaler Zust√§nde ist das erste Mal nicht zusammengewachsen.  Einerseits sollte die interne Architektur von SObjectizer nicht mehrere unabh√§ngige und gleichzeitig aktive Zust√§nde des Agenten unterst√ºtzen.  Andererseits gibt es ideologische Fragen, wie sich ein Agent mit orthogonalen Zust√§nden verhalten sollte.  Das Gewirr dieser Fragen erwies sich als zu kompliziert, und der n√ºtzliche Auspuff war zu klein, um dieses Problem zu l√∂sen.  Ja, und in unserer Praxis gab es noch keine Situationen, in denen orthogonale Zust√§nde erforderlich w√§ren, aber es w√§re beispielsweise unm√∂glich, die Arbeit auf mehrere Agenten aufzuteilen, die an einen gemeinsamen Arbeitskontext gebunden sind. <br><br>  Wenn jedoch jemand eine Funktion wie orthogonale Zust√§nde ben√∂tigt und Sie Beispiele aus der Praxis f√ºr Aufgaben haben, bei denen dies erforderlich ist, lassen Sie uns sprechen.  Wenn wir konkrete Beispiele vor Augen haben, k√∂nnen wir diese Funktion m√∂glicherweise zu SObjectizer hinzuf√ºgen. <br><br><h2>  Wie die Unterst√ºtzung f√ºr erweiterte Funktionen von ICA im Code aussieht </h2><br>  In diesem Teil der Geschichte werden wir versuchen, die SObjectizer-5-API schnell zu √ºberpr√ºfen, um mit ICA zu arbeiten.  Ohne tief in die Details zu gehen, nur damit der Leser eine Vorstellung davon hat, was ist und wie es aussieht.  Weitere Informationen finden Sie auf Wunsch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der offiziellen Dokumentation</a> . <br><br><h3>  Verschachtelte Staaten </h3><br>  Um einen verschachtelten Status zu deklarieren, m√ºssen Sie den Ausdruck initial_substate_of oder substate_of an den Konstruktor des entsprechenden state_t-Objekts √ºbergeben: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_parent{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  . state_t st_first_child{initial_substate_of{st_parent}}; //   . //    . state_t st_second_child{substate_of{st_parent}}; //   . state_t st_third_child{substate_of{st_parent}}; //   . state_t st_first_grandchild{initial_substate_of{st_third_child}}; //    . state_t st_second_grandchild{substate_of{st_third_child]}; ... };</span></span></code> </pre> <br>  Wenn der Zustand S mehrere Unterzust√§nde C1, C2, ..., Cn hat, sollte einer von ihnen (und nur einer) als initial_substate_of markiert werden.  Verst√∂√üe gegen diese Regel werden zur Laufzeit diagnostiziert. <br><br>  Die maximale Verschachtelungstiefe in SObjectizer-5 ist begrenzt.  In Version 5.5 sind dies 16 Ebenen.  Verst√∂√üe gegen diese Regel werden zur Laufzeit diagnostiziert. <br><br>  Der wichtigste Trick bei verschachtelten Zust√§nden besteht darin, dass bei Aktivierung eines Zustands mit verschachtelten Zust√§nden mehrere Zust√§nde gleichzeitig aktiviert werden.  Angenommen, es gibt einen Zustand A mit den Unterzust√§nden B und C, und in Unterzustand B gibt es die Unterzust√§nde D und E: <br><br><img src="https://habrastorage.org/webt/pf/1n/gb/pf1ngbtknzrf5qxlluht3yfiraq.png"><br><br>  Wenn Zustand A aktiviert ist, werden tats√§chlich sofort drei Zust√§nde aktiviert: A, AB und ABD <br><br>  Die Tatsache, dass mehrere Staaten gleichzeitig aktiv sein k√∂nnen, hat die schwerwiegendste Auswirkung auf zwei Archivierungssachen.  Erstens, um nach einem Handler f√ºr die n√§chste eingehende Nachricht zu suchen.  In dem gerade gezeigten Beispiel wird der Nachrichtenhandler zuerst im ABD-Zustand durchsucht. Wenn dort kein geeigneter Handler vorhanden ist, wird die Suche in seinem √ºbergeordneten Zustand fortgesetzt, d. H.  in AB Und bei Bedarf bereits verletzt, wird die Suche in Zustand A fortgesetzt. <br><br>  Zweitens beeinflusst das Vorhandensein mehrerer aktiver Zust√§nde die Reihenfolge des Aufrufs von Eingabe- / Ausgabehandlern f√ºr Zust√§nde.  Dies wird jedoch weiter unten er√∂rtert. <br><br><h3>  Status-E / A-Handler </h3><br>  F√ºr einen Status k√∂nnen Status-Handler f√ºr den Statusein- und -ausgang angegeben werden.  Dies erfolgt mit den Methoden state_t :: on_enter und state_t :: on_exit.  In der Regel werden diese Methoden in der Methode so_define_agent () aufgerufen (oder direkt im Agentenkonstruktor, wenn der Agent trivial ist und keine Vererbung von ihm bereitgestellt wird). <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_free{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_busy{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// :       , //     . st_free.on_enter([]{ ... }); st_busy.on_exit([]{ ...}); ... this &gt;&gt;= st_free; } ... };</span></span></code> </pre> <br>  Der wahrscheinlich schwierigste Moment mit on_enter / on_exit-Handlern besteht darin, sie f√ºr verschachtelte Zust√§nde zu verwenden.  Kehren wir zum Beispiel mit den Zust√§nden A, B, C, D und E zur√ºck. <br><br><img src="https://habrastorage.org/webt/pf/1n/gb/pf1ngbtknzrf5qxlluht3yfiraq.png"><br><br>  Angenommen, jeder Status verf√ºgt √ºber einen Handler on_enter und on_exit. <br><br>  Lassen Sie A. zum aktuellen Status des Agenten werden.  Zust√§nde A, AB und ABD werden aktiviert W√§hrend der Zustands√§nderung eines Agenten werden A.on_enter, ABon_enter und ABDon_enter aufgerufen.  Und in dieser Reihenfolge. <br><br>  Angenommen, es gibt einen √úbergang zu ABE. ABDon_exit und ABEon_enter werden aufgerufen. <br><br>  Wenn wir dann den Agenten in den AC-Status versetzen, wird ABEon_exit, ABon_exit, ACon_enter aufgerufen. <br><br>  Wenn sich der Agent im AC-Status abmeldet, werden unmittelbar nach Abschluss der Methode so_evt_finish () die Handler ACon_exit und A.on_exit aufgerufen. <br><br><h3>  Fristen </h3><br>  Das Zeitlimit f√ºr den Agenten, um in einem bestimmten Status zu bleiben, wird mithilfe der Methode state_t :: time_limit festgelegt.  Wie bei on_enter / on_exit werden die Methoden time_limit normalerweise aufgerufen, wenn der Agent f√ºr die Arbeit im SObjectizer konfiguriert ist: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">led_indicator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> inactive{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> active{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        15s. //        inactive. active.time_limit(15s, inactive); ... } ... };</span></span></code> </pre> <br>  Wenn das Zeitlimit f√ºr den Status festgelegt ist, beginnt SObjectizer, sobald der Agent in diesen Status eintritt, die im Status verbrachte Zeit zu z√§hlen.  Wenn der Agent den Status verl√§sst und dann wieder in diesen Status zur√ºckkehrt, beginnt der Countdown erneut. <br><br>  Wenn f√ºr eingebettete Zust√§nde Zeitlimits festgelegt sind, m√ºssen Sie vorsichtig sein, weil  neugierige Tricks sind m√∂glich: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   . state_t A{this}, B{this}; //   first . state_t C{initial_substate_of{A}}, st_D{substate_of{A}}; ... void so_define_agent() override { A.time_limit(15s, B); C.time_limit(10s, D); D.time_limit(20s, C); ... } ... };</span></span></code> </pre> <br>  Angenommen, ein Agent tritt in den Zustand A ein.  Die Zust√§nde A und C sind sowohl f√ºr A als auch f√ºr C aktiviert.  Zuvor wird es f√ºr Status C beendet und der Agent wechselt zu Status D. Dies startet den Countdown f√ºr den Aufenthalt in Status D. Der Countdown f√ºr den Aufenthalt in A wird jedoch fortgesetzt!  Da der Agent w√§hrend des √úbergangs von C nach D weiterhin in Zustand A blieb. Und f√ºnf Sekunden nach dem erzwungenen √úbergang von C nach D geht der Agent in Zustand B √ºber. <br><br><h3>  Geschichte f√ºr das Gl√ºck </h3><br>  Standardm√§√üig haben Agentenstatus keinen Verlauf.  Um das Speichern des Verlaufs f√ºr einen Status zu aktivieren, √ºbergeben Sie die Konstante flat_history (der Status hat einen flachen Verlauf) oder deep_history (der Status hat einen tiefen Verlauf) an den Konstruktor state_t.  Zum Beispiel: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> A{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, shallow_history}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> B{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, deep_history}; ... };</code> </pre> <br>  Die Geschichte f√ºr Staaten ist ein schwieriges Thema, insbesondere wenn eine anst√§ndige Verschachtelungstiefe von Staaten verwendet wird und die Unterzust√§nde ihre eigene Geschichte haben.  Ausf√ºhrlichere Informationen zu diesem Thema finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der Dokumentation</a> .  Nun, um uns zu fragen, ob Sie es nicht selbst herausfinden k√∂nnen;) <br><br><h3>  just_switch_to, transfer_to_state, unterdr√ºcken </h3><br>  Die Klasse state_t verf√ºgt √ºber eine Reihe der am h√§ufigsten verwendeten Methoden, die oben bereits gezeigt wurden: event () zum Abonnieren von Ereignissen f√ºr eine Nachricht, on_enter () und on_exit () zum Festlegen von Eingabe- / Ausgabehandlern, time_limit () zum Festlegen eines Grenzwerts f√ºr die in einem Status verbrachte Zeit. <br><br>  Neben diesen Methoden sind bei der Arbeit mit ICA die folgenden Methoden der Klasse state_t sehr n√ºtzlich: <br><br>  Methode just_switch_to (), die f√ºr den Fall entwickelt wurde, dass die einzige Reaktion auf eine eingehende Nachricht darin besteht, den Agenten in einen neuen Zustand zu versetzen.  Sie k√∂nnen schreiben: <br><pre> <code class="cpp hljs">some_state.just_switch_to&lt;some_msg&gt;(another_state);</code> </pre> <br>  statt: <br><pre> <code class="cpp hljs">some_state.event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;some_msg&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= another_state; });</code> </pre> <br>  Die Methode transfer_to_state () ist sehr n√ºtzlich, wenn eine Nachricht M in zwei oder mehr Zust√§nden S1, S2, ..., Sn auf dieselbe Weise verarbeitet wird.  Wenn wir uns jedoch in den Zust√§nden S2, ..., Sn befinden, m√ºssen wir zuerst zu S1 zur√ºckkehren und erst dann die Verarbeitung M durchf√ºhren. <br><br>  Wenn dies schwierig klingt, wird diese Situation in einem Codebeispiel m√∂glicherweise besser verstanden: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> S1{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, S2{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, ..., Sn{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actual_M_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; cmd)</span></span></span><span class="hljs-function"> </span></span>{...} ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ S1.event(&amp;demo::actual_M_handler); ... <span class="hljs-comment"><span class="hljs-comment">//           S1, //      M  . S2.event([this](mhood_t&lt;M&gt; cmd) { this &gt;&gt;= S1; actual_M_handler(cmd); }); ... //      . Sn.event([this](mhood_t&lt;M&gt; cmd) { this &gt;&gt;= S1; actual_M_handler(cmd); }); } ... };</span></span></code> </pre> <br>  Verwenden Sie transfer_to_state, anstatt sehr √§hnliche Ereignishandler f√ºr S2, ..., Sn zu definieren: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> S1{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, S2{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, ..., Sn{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actual_M_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; cmd)</span></span></span><span class="hljs-function"> </span></span>{...} ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ S1.event(&amp;demo::actual_M_handler); ... <span class="hljs-comment"><span class="hljs-comment">//           S1, //      M  . S2.transfer_to_state&lt;M&gt;(S1); ... //      . Sn.transfer_to_state&lt;M&gt;(Sn); } ... };</span></span></code> </pre> <br>  Die Methode replace () unterdr√ºckt eine Ereignishandlersuche nach dem aktuellen Unterzustand und allen √ºbergeordneten Unterzust√§nden.  Angenommen, wir haben einen √ºbergeordneten Status A, in dem std :: abort () f√ºr Nachricht M aufgerufen wird.  Und es gibt einen untergeordneten Zustand von B, in dem M sicher ignoriert werden kann.  Wir m√ºssen die Reaktion auf M in Unterzustand B bestimmen, denn wenn wir dies nicht tun, wird der Handler f√ºr B in A gefunden. Daher m√ºssen wir etwas schreiben wie: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ A.event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;M&gt;) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); }); ... B.event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;M&gt;) {}); <span class="hljs-comment"><span class="hljs-comment">//    ,      //   M   . ... }</span></span></code> </pre> <br>  Mit der Methode suppress () k√∂nnen Sie diese Situation expliziter und grafischer in Code schreiben: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ A.event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;M&gt;) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); }); ... B.suppress&lt;M&gt;(); <span class="hljs-comment"><span class="hljs-comment">//    ,      //   M   . ... }</span></span></code> </pre> <br><h2>  Sehr einfaches Beispiel </h2><br>  Zu den Standardbeispielen von SObjectizer v.5.5 geh√∂rt ein einfaches Beispiel, <a href="">blinking_led</a> , das den Betrieb einer blinkenden LED-Anzeige simuliert.  Das Agentenstatusdiagramm aus diesem Beispiel lautet wie folgt: <br><br><img src="https://habrastorage.org/webt/9d/yt/ms/9dytmskalbsypsg9xjjzkwupl5k.png"><br><br>  Und hier ist der vollst√§ndige Agentencode aus diesem Beispiel: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blinking_led</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> off{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }, blinking{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }, blink_on{ initial_substate_of{ blinking } }, blink_off{ substate_of{ blinking } }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn_on_off</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; blinking_led( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ ctx } { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= off; off.just_switch_to&lt; turn_on_off &gt;( blinking ); blinking.just_switch_to&lt; turn_on_off &gt;( off ); blink_on .on_enter( []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ON"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ) .on_exit( []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"off"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ) .time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{<span class="hljs-number"><span class="hljs-number">1250</span></span>}, blink_off ); blink_off .time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{<span class="hljs-number"><span class="hljs-number">750</span></span>}, blink_on ); } };</code> </pre> <br>  Hier wird die gesamte eigentliche Arbeit in den E / A-Handlern f√ºr den Unterzustand blink_on ausgef√ºhrt.  Au√üerdem sind die Aufenthaltsdauer in den Unterzust√§nden blink_on und blink_off begrenzt. <br><br><h2>  Kein sehr einfaches Beispiel </h2><br>  Zu den Standardbeispielen von SObjectizer v.5.5 geh√∂rt auch ein viel komplexeres Beispiel, <a href="">intercom_statechart</a> , das das Verhalten der T√ºrsprechanlage nachahmt.  Das Zustandsdiagramm des Hauptagenten in diesem Beispiel sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><img src="https://habrastorage.org/webt/o-/i6/7d/o-i67dswwms9rkutntnvd-hrx7e.jpeg"><br><br>  Alles ist so hart, weil diese Nachahmung nicht nur das Anrufen einer Wohnung nach Nummer unterst√ºtzt, sondern auch Dinge wie einen eindeutigen Geheimcode f√ºr jede Wohnung sowie einen speziellen Servicecode.  Mit diesen Codes k√∂nnen Sie das T√ºrschloss √∂ffnen, ohne irgendwo zu w√§hlen. <br><br>  In diesem Beispiel gibt es noch interessante Dinge.  Es ist jedoch zu gro√ü, um im Detail beschrieben zu werden (selbst ein separater Artikel reicht m√∂glicherweise nicht aus).  Wenn Sie also daran interessiert sind, wie wirklich komplexe ICAs in SObjectizer aussehen, k√∂nnen Sie dies in diesem Beispiel sehen.  Und wenn etwas nicht klar ist, k√∂nnen Sie uns eine Frage stellen.  Zum Beispiel in den Kommentaren zu diesem Artikel. <br><br><h1>  Ist es m√∂glich, die Unterst√ºtzung f√ºr in SObjectizer-5 integrierte Raumfahrzeuge nicht zu verwenden? </h1><br>  Daher bietet SObjectizer-5 eine integrierte Unterst√ºtzung f√ºr ICA mit einer Vielzahl von unterst√ºtzten Funktionen.  Diese Unterst√ºtzung wird nat√ºrlich gemacht, um sie zu nutzen.  Insbesondere die Debugging-Mechanismen von SObjectizer, wie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ablaufverfolgung der Nachrichten√ºbermittlung</a> , kennen den Status des Agenten und zeigen den aktuellen Status in ihren jeweiligen Debug-Nachrichten an. <br><br>  Wenn der Entwickler jedoch aus irgendeinem Grund die integrierten SObjectizer-5-Tools nicht verwenden m√∂chte, kann er dies m√∂glicherweise nicht tun. <br><br>  Sie k√∂nnen beispielsweise die Verwendung von SObjectizer state_t und √§hnlichen Programmen ablehnen, da state_t ein ziemlich schweres Objekt mit einem inneren std :: string, einigen std :: -Funktionen und mehreren Z√§hlern wie std :: size_t ist. f√ºnf Zeiger auf verschiedene Objekte und eine andere Kleinigkeit.  Zusammen ergibt dies unter 64-Bit-Linux und GCC-5.5 beispielsweise 160 Bytes pro state_t (abgesehen von dem, was im dynamischen Speicher zugewiesen werden kann). <br><br>  Wenn Sie beispielsweise eine Million Agenten in der Anwendung ben√∂tigen, von denen jeder 10 Status hat, ist der Overhead von SObjectizer state_t m√∂glicherweise nicht akzeptabel.  In diesem Fall k√∂nnen Sie einen anderen Mechanismus f√ºr die Arbeit mit Zustandsautomaten verwenden und die Nachrichtenverarbeitung manuell an diesen Mechanismus delegieren.  So etwas wie: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">external_fsm_demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { some_fsm_type my_fsm_; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ so_subscribe_self() .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_one&gt; cmd) { my_fsm_.handle(*cmd); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_two&gt; cmd) { my_fsm_.handle(*cmd); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_three&gt; cmd) { my_fsm_.handle(*cmd); }); ... } ... };</code> </pre> <br>  In diesem Fall zahlen Sie f√ºr die Effizienz, indem Sie den manuellen Arbeitsaufwand und den Mangel an Hilfe durch die Debugging-Mechanismen von SObjectizer erh√∂hen.  Aber hier ist es Sache des Entwicklers, zu entscheiden. <br><br><h1>  Fazit </h1><br>  Der Artikel erwies sich als umfangreich, viel mehr als urspr√ºnglich geplant.  Vielen Dank an alle, die diesen Ort gelesen haben.  Wenn einer der Leser es f√ºr m√∂glich h√§lt, Ihr Feedback in den Kommentaren zum Artikel zu hinterlassen, ist es gro√üartig. <br><br>  Wenn etwas unklar bleibt, dann stellen Sie Fragen, wir werden gerne antworten. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei dieser Gelegenheit m√∂chte ich auch diejenigen, die sich f√ºr SObjectizer interessieren, darauf aufmerksam machen, dass die Arbeit an der n√§chsten Version von SObjectizer im Rahmen von Zweig 5.5 begonnen hat. </font><font style="vertical-align: inherit;">Kurz dar√ºber, was f√ºr die Implementierung in 5.5.23 in Betracht gezogen wird, wird </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beschrieben </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ausf√ºhrlicher, aber auf Englisch, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sie k√∂nnen Ihre Meinung zu den f√ºr die Implementierung vorgeschlagenen Funktionen abgeben oder etwas anderes anbieten.</font></font> Das hei√üt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt eine echte Chance, die Entwicklung von SObjectizer zu beeinflussen. </font><font style="vertical-align: inherit;">Dar√ºber hinaus kann es nach der Ver√∂ffentlichung von Version 5.5.23 zu einer Unterbrechung der Arbeit am SObjectizer kommen, und die n√§chste M√∂glichkeit, etwas N√ºtzliches in den SObjectizer 2018 aufzunehmen, ist m√∂glicherweise nicht m√∂glich.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423497/">https://habr.com/ru/post/de423497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423487/index.html">Node.js ohne node_modules</a></li>
<li><a href="../de423489/index.html">Ich bin Notarzt und m√∂chte √ºber das neue Apple Watch-Elektrokardiogramm sprechen</a></li>
<li><a href="../de423491/index.html">PHP Digest Nr. 139 (3. - 17. September 2018)</a></li>
<li><a href="../de423493/index.html">Android Go ist die zuk√ºnftige Milliarde Ger√§te und ein Limit von 50 MB. Yandex Vortrag</a></li>
<li><a href="../de423495/index.html">Was ist in XGBoost enthalten und was hat Go damit zu tun?</a></li>
<li><a href="../de423499/index.html">DevBoy - wie ich ein Open Source-Ger√§teprojekt erstellt und ein Projekt auf Kickstarter gestartet habe</a></li>
<li><a href="../de423503/index.html">Meine Erfahrung in Deutschland zu bewegen, zu leben und zu studieren</a></li>
<li><a href="../de423505/index.html">Zuckerberg verkauft Facebook-Aktien f√ºr 13 Milliarden US-Dollar, damit ‚Äûunsere Kinder nie krank werden m√ºssen‚Äú</a></li>
<li><a href="../de423507/index.html">So speichern Sie Speicher auf Browser-Registerkarten, ohne deren Inhalt zu verlieren. Die Erfahrung des Yandex.Browser-Teams</a></li>
<li><a href="../de423511/index.html">Abfangen der Installation von Firefox und Chrome unter Windows 10</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>