<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õèÔ∏è üéå üí™üèΩ C√≥mo dejar de escribir firmware para microcontroladores y comenzar a vivir üë∏üèª üìì ü¶ï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola, mi nombre es Eugene y estoy cansado de escribir firmware para microcontroladores. C√≥mo sucedi√≥ esto y qu√© hacer con √©l, vamos a resolverlo. 


 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo dejar de escribir firmware para microcontroladores y comenzar a vivir</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433504/"><img src="https://habrastorage.org/webt/nd/sn/hu/ndsnhuqdxwhktmaafqwsluk-iia.png"><br><p>  Hola, mi nombre es Eugene y estoy cansado de escribir firmware para microcontroladores.  C√≥mo sucedi√≥ esto y qu√© hacer con √©l, vamos a resolverlo. </p><a name="habracut"></a><br><p>  Despu√©s de trabajar en programaci√≥n grande C ++, Java, Python, etc., no tiene ganas de volver a los microcontroladores peque√±os y panzudos.  A sus escasas herramientas y bibliotecas.  Pero a veces no hay nada que hacer, las tareas en tiempo real y la autonom√≠a no dejan elecci√≥n.  Pero hay algunos tipos de tareas que simplemente se vuelven locos en esta √°rea para resolver. </p><br><p>  Por ejemplo, pruebas de equipos, algo m√°s aburrido y lecciones aburridas en programaci√≥n integrada, dif√≠cilmente se pueden imaginar.  En general, as√≠ como herramientas convenientes para esto.  Usted escribe ... parpadea ... parpadea ... un LED (a veces se conecta a UART).  Todos los bol√≠grafos, sin herramientas de prueba especializadas. </p><br><p>  Tambi√©n es deprimente que no haya pruebas instrumentales para nuestros peque√±os microcontroladores.  Todo es solo a trav√©s del firmware y a trav√©s del depurador para probar. </p><br><p> Y el estudio de trabajar con nuevos dispositivos y perif√©ricos requiere mucho esfuerzo y tiempo.  Un error y el programa se debe volver a compilar y volver a ejecutar cada vez. </p><br><p>  Para tales experimentos, algo como REPL es m√°s adecuado, para que pueda hacer estas cosas, al menos triviales, de manera simple y sin dolor: </p><br><p><img src="https://habrastorage.org/webt/cl/rb/oh/clrbohl9g4mkgs_l2z-mf4wmjde.gif">  \ </p><br><p>  C√≥mo llegar a esto, esta serie de art√≠culos est√° dedicada. </p><br><p>  Y esta vez me encontr√© con un proyecto en el que era necesario probar un dispositivo bastante complicado, con muchos tipos de sensores y otros chips desconocidos para m√≠ anteriormente, que usaban muchos perif√©ricos MK y un mont√≥n de interfaces diferentes.  La diversi√≥n especial fue que no ten√≠a los c√≥digos fuente de firmware para la placa, por lo que todas las pruebas tendr√≠an que escribirse desde cero, sin usar el tiempo de operaci√≥n del c√≥digo fuente. </p><br><p>  El proyecto prometi√≥ un buen maestro de brindis y las competiciones son interesantes durante dos meses m√°s o menos (y muy probablemente m√°s). </p><br><p>  Vale, aqu√≠ no vamos a llorar.  Uno debe sumergirse nuevamente en la naturaleza de C y el firmware infinito, o rechazar o inventar algo para facilitar esta lecci√≥n.  Al final, la pereza y la curiosidad son el motor del progreso. </p><br><p>  La √∫ltima vez, cuando entend√≠ OpenOCD, encontr√© un punto tan interesante en la documentaci√≥n como </p><br><pre><code class="plaintext hljs">http://openocd.org/doc/html/General-Commands.html 15.4 Memory access commands mdw, mdh, mdb ‚Äî         mww, mwh, mwb ‚Äî       </code> </pre> <br><p>  Interesante ...  Y es posible leer y escribir registros perif√©ricos con ellos ... resulta posible, y adem√°s, estos comandos se pueden ejecutar de forma remota a trav√©s del servidor TCL, que se inicia cuando se inicia openOCD. </p><br><p>  Aqu√≠ hay un ejemplo de un LED parpadeante para stm32f103C8T6 </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Step 1: Enable the clock to PORT B RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPCEN; // Step 2: Change PB0's mode to 0x3 (output) and cfg to 0x0 (push-pull) GPIOC-&gt;CRH = GPIO_CRH_MODE13_0 | GPIO_CRH_MODE13_1; // Step 3: Set PB0 high GPIOC-&gt;BSRR = GPIO_BSRR_BS13; // Step 4: Reset PB0 low GPIOC-&gt;BSRR = GPIO_BSRR_BR13;</span></span></code> </pre> <br><p>  y una secuencia similar de comandos openOCD </p><br><pre> <code class="plaintext hljs">mww 0x40021018 0x10 mww 0x40011004 0x300000 mww 0x40011010 0x2000 mww 0x40011010 0x20000000</code> </pre> <br><p>  Y ahora, si piensa en lo eterno y considera el firmware para MK ... entonces el prop√≥sito principal de estos programas es escribir en los registros del chip;  ¬°el firmware que solo har√° algo y funcionar√° solo con el n√∫cleo del procesador no tiene un uso pr√°ctico! </p><br><div class="spoiler">  <b class="spoiler_title">Nota</b> <div class="spoiler_text"><p>  Aunque, por supuesto, puedes considerar la cripta (= </p></div></div><br><p>  Muchos recordar√°n m√°s sobre trabajar con interrupciones.  Pero no siempre son obligatorios, y en mi caso, puedes prescindir de ellos. </p><br><p>  Y as√≠, la vida est√° mejorando.  En la fuente openOCD, incluso puede encontrar un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejemplo</a> interesante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de</a> uso de esta interfaz. </p><br><p>  Muy bien en blanco en python. </p><br><p>  Es bastante posible convertir direcciones de registro de archivos de encabezado y comenzar a escribir en un lenguaje de script kosher.  Ya puedes preparar champ√°n, pero me pareci√≥ que no era suficiente, porque quiero usar la Biblioteca de perif√©ricos est√°ndar o el nuevo HAL para trabajar con perif√©ricos en lugar de preocuparme por los registros. </p><br><p>  Portando bibliotecas a Python ... en alguna pesadilla lo haremos.  Por lo tanto, debe usar estas bibliotecas en C o ... C ++.  Y en los profesionales, puede anular a casi todos los operadores ... para sus clases. </p><br><p>  Y las direcciones base en los archivos de encabezado, se reemplazan con objetos de sus clases. </p><br><p>  Por ejemplo, en el archivo stm32f10x.h </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BB_BASE ((uint32_t)0x42000000) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Peripheral base address in the bit-band region */</span></span></span></span></code> </pre> <br><p>  Reemplazar con </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InterceptAddr</span></span></span><span class="hljs-class">;</span></span> InterceptAddr addr; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BB_BASE (addr) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Peripheral base address in the bit-band region */</span></span></span></span></code> </pre> <br><p>  Pero los juegos con punteros en la biblioteca cortan esta idea de ra√≠z ... </p><br><p>  Aqu√≠ hay un ejemplo de archivo stm32f10x_i2c.c: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FlagStatus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">I2C_GetFlagStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(I2C_TypeDef* I2Cx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I2C_FLAG)</span></span></span><span class="hljs-function"> </span></span>{ __IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i2creg = <span class="hljs-number"><span class="hljs-number">0</span></span>, i2cxbase = <span class="hljs-number"><span class="hljs-number">0</span></span>; ‚Ä¶. <span class="hljs-comment"><span class="hljs-comment">/* Get the I2Cx peripheral base address */</span></span> i2cxbase = (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)I2Cx; ‚Ä¶.</code> </pre> <br><p>  Por lo tanto, es necesario interceptar direcciones a direcciones de alguna manera diferente.  Probablemente valga la pena echarle un vistazo a Valgrind, no en vano, tiene un memchecker.  Bueno, realmente deber√≠a saber c√≥mo interceptar direcciones. </p><br><p>  Mirando hacia el futuro, dir√© que es mejor no mirar all√≠ ... Casi logr√© interceptar llamadas a direcciones.  Para casi todos los casos excepto este </p><br><pre> <code class="cpp hljs">Int * p = ... *p = <span class="hljs-number"><span class="hljs-number">0x123</span></span>;</code> </pre> <br><p>  Es posible interceptar la direcci√≥n, pero ya no fue posible interceptar los datos grabados.  Solo el nombre del registro interno en el que se encuentra este valor, pero que no se puede alcanzar desde memcheck. </p><br><p>  De hecho, Valgrind me sorprendi√≥, dentro del antiguo monstruo se usa libVEX, sobre el cual no encontr√© ninguna informaci√≥n en Internet.  Es bueno que se haya encontrado un poco de documentaci√≥n en los archivos de encabezado. </p><br><p>  Luego hab√≠a otras herramientas DBI. </p><br><p>  Frida, Dynamic RIO, un poco m√°s, y finalmente obtuve Pintool. </p><br><p>  PinTool ten√≠a bastante buena documentaci√≥n y ejemplos.  Aunque todav√≠a no ten√≠a suficientes, tuve que hacer experimentos con algunas cosas.  La herramienta result√≥ ser muy poderosa, solo altera el c√≥digo cerrado y la restricci√≥n solo a la plataforma de inteligencia (aunque en el futuro esto se puede eludir) </p><br><p>  Entonces, necesitamos interceptar escribir y leer en direcciones espec√≠ficas.  Veamos qu√© instrucciones son responsables de este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://godbolt.org/z/nJS9ci</a> . </p><br><p>  Para x64, este ser√° un MOV para ambas operaciones. </p><br><p>  Y para x86 ser√° MOV para escribir y MOVZ para leer. </p><br><p>  Nota: es mejor no habilitar la optimizaci√≥n, de lo contrario pueden aparecer otras instrucciones. </p><br><div class="spoiler">  <b class="spoiler_title">Encabezado de spoiler</b> <div class="spoiler_text"><pre> <code class="cpp hljs">INS_AddInstrumentFunction(EmulateLoad, <span class="hljs-number"><span class="hljs-number">0</span></span>); INS_AddInstrumentFunction(EmulateStore, <span class="hljs-number"><span class="hljs-number">0</span></span>); ..... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> VOID </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmulateLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(INS ins, VOID *v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Find the instructions that move a value from memory to a register if ((INS_Opcode(ins) == XED_ICLASS_MOV || INS_Opcode(ins) == XED_ICLASS_MOVZX) &amp;&amp; INS_IsMemoryRead(ins) &amp;&amp; INS_OperandIsReg(ins, 0) &amp;&amp; INS_OperandIsMemory(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(loadAddr2Reg), IARG_MEMORYREAD_EA, IARG_MEMORYREAD_SIZE, IARG_RETURN_REGS, INS_OperandReg(ins, 0), IARG_END); // Delete the instruction INS_Delete(ins); } } static VOID EmulateStore(INS ins, VOID *v) { if (INS_Opcode(ins) == XED_ICLASS_MOV &amp;&amp; INS_IsMemoryWrite(ins) &amp;&amp; INS_OperandIsMemory(ins, 0)) { if (INS_hasKnownMemorySize(ins)) { if (INS_OperandIsReg(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(multiMemAccessStore), IARG_MULTI_MEMORYACCESS_EA, IARG_REG_VALUE, INS_OperandReg(ins, 1), IARG_END); } else if (INS_OperandIsImmediate(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)multiMemAccessStore, IARG_MULTI_MEMORYACCESS_EA, IARG_UINT64, INS_OperandImmediate(ins, 1), IARG_END); } } else { if (INS_OperandIsReg(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(storeReg2Addr), IARG_MEMORYWRITE_EA, IARG_REG_VALUE, INS_OperandReg(ins, 1), IARG_MEMORYWRITE_SIZE, IARG_END); } else if (INS_OperandIsImmediate(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(storeReg2Addr), IARG_MEMORYWRITE_EA, IARG_UINT64, INS_OperandImmediate(ins, 1), IARG_UINT32, IARG_MEMORYWRITE_SIZE, IARG_END); } } } }</span></span></code> </pre> </div></div><br><p>  En el caso de leer desde la direcci√≥n, llamamos a la funci√≥n loadAddr2Reg y eliminamos la instrucci√≥n original.  En base a esto, loadAddr2Reg deber√≠a devolvernos el valor necesario. </p><br><p>  Con un registro, es cada vez m√°s dif√≠cil ... los argumentos pueden ser de diferentes tipos y tambi√©n pueden transmitirse de diferentes maneras, por lo que debe llamar a diferentes funciones antes del comando.  En una plataforma de 32 bits, se llamar√° a multiMemAccessStore y en 64 storeReg2Addr.  Y aqu√≠ no eliminamos las instrucciones de la l√≠nea de ensamblaje.  No hay problemas para eliminarlo, pero en algunos casos no es posible imitar su acci√≥n.  El programa por alguna raz√≥n a veces se bloquea en sigfault.  Para nosotros, esto no es cr√≠tico, dej√©moslo escrito, lo principal es que existe la posibilidad de interceptar argumentos. </p><br><p>  A continuaci√≥n, necesitamos ver qu√© direcciones necesitamos interceptar, mira el Mapa de Memoria para nuestro chip stm32f103C8T6: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f59/014/f32/f59014f32867a45837c7609bc74a89b3.png" alt="imagen"><br>  Estamos interesados ‚Äã‚Äãen direcciones con SRAM y PERIPH_BASE, es decir, de 0x20000000 a 0x20000000 + 128 * 1024 y de 0x40000000 a 0x40030000.  Bueno, o mejor dicho, no del todo, ya que recordamos las instrucciones de grabaci√≥n, no pudimos eliminarlas.  Por lo tanto, el registro en estas direcciones se caer√° en sigfault.  Adem√°s, existe una probabilidad poco probable de que estas direcciones tengan datos de nuestro programa, no que este chip tenga otro.  Por lo tanto, definitivamente necesitamos arreglarlos en alguna parte.  Digamos en alg√∫n tipo de matriz. </p><br><p>  Creamos matrices del tama√±o requerido, y luego sustituimos sus punteros en la direcci√≥n base definida. </p><br><p>  En nuestro programa, en los titulares </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SRAM_BASE ((uint32_t)0x20000000) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; SRAM base address in the alias region */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BASE ((uint32_t)0x40000000) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Peripheral base address in the alias region */</span></span></span></span></code> </pre> <br><p>  Hacer </p><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SRAM_BASE ((AddrType)pAddrSRAM) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BASE ((AddrType)pAddrPERIPH)</span></span></code> </pre> <br><p>  y donde pAddrSRAM y pAddrPERIPH son punteros a matrices preasignadas. </p><br><p>  Ahora, nuestro cliente PinTool necesita transmitir de alguna manera c√≥mo reparamos las direcciones necesarias. <br>  Lo m√°s simple que me pareci√≥ c√≥mo hacer esto fue interceptar una funci√≥n que devuelve una estructura de matriz de este formato: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">addr_t</span></span> start_addr; <span class="hljs-comment"><span class="hljs-comment">//      addr_t end_addr; //   addr_t reference_addr; //   } memoryTranslate;</span></span></code> </pre> <br><p>  Por ejemplo, para nuestro chip estar√° tan lleno </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">map</span></span>-&gt;start_addr = (<span class="hljs-keyword"><span class="hljs-keyword">addr_t</span></span>)pAddrSRAM; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>-&gt;end_addr = <span class="hljs-number"><span class="hljs-number">96</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>-&gt;reference_addr = (<span class="hljs-keyword"><span class="hljs-keyword">addr_t</span></span>)<span class="hljs-number"><span class="hljs-number">0x20000000</span></span>U;</code> </pre> <br><p>  No es dif√≠cil interceptar la funci√≥n y tomar los valores requeridos de ella: </p><br><pre> <code class="cpp hljs">IMG_AddInstrumentFunction(ImageReplace, <span class="hljs-number"><span class="hljs-number">0</span></span>); .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> memoryTranslate *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replaceMemoryMapFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CONTEXT *context, AFUNPTR orgFuncptr, sizeMemoryTranslate_t *size)</span></span></span><span class="hljs-function"> </span></span>{ PIN_CallApplicationFunction(context, PIN_ThreadId(), CALLINGSTD_DEFAULT, orgFuncptr, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, PIN_PARG(memoryTranslate *), &amp;addrMap, PIN_PARG(sizeMemoryTranslate_t *), size, PIN_PARG_END()); sizeMap = *size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addrMap; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> VOID </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ImageReplace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IMG img, VOID *v)</span></span></span><span class="hljs-function"> </span></span>{ RTN freeRtn = RTN_FindByName(img, NAME_MEMORY_MAP_FUNCTION); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RTN_Valid(freeRtn)) { PROTO proto_free = PROTO_Allocate(PIN_PARG(memoryTranslate *), CALLINGSTD_DEFAULT, NAME_MEMORY_MAP_FUNCTION, PIN_PARG(sizeMemoryTranslate_t *), PIN_PARG_END()); RTN_ReplaceSignature(freeRtn, AFUNPTR(replaceMemoryMapFun), IARG_PROTOTYPE, proto_free, IARG_CONTEXT, IARG_ORIG_FUNCPTR, IARG_FUNCARG_ENTRYPOINT_VALUE, <span class="hljs-number"><span class="hljs-number">0</span></span>, IARG_END); } }</code> </pre> <br><p>  Y haga que nuestra funci√≥n interceptada se vea as√≠: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">memoryTranslate * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMemoryMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sizeMemoryTranslate_t * size)</span></span></span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memoryMap; }</code> </pre> <br><p>  Cu√°l es el trabajo m√°s trivial realizado, queda por hacer que el cliente abra OpenOCD, en el cliente PinTool no quer√≠a implementarlo, as√≠ que hice una aplicaci√≥n separada con la cual nuestro cliente PinTool se comunica a trav√©s de named fifo. </p><br><p>  Por lo tanto, el esquema de interfaces y comunicaciones es el siguiente: <br><img src="https://habrastorage.org/getpro/habr/post_images/a0e/a54/e2b/a0ea54e2b4e3b849ed205cb0879b4e23.png" alt="imagen"><br>  Un flujo de trabajo simplificado en el ejemplo de interceptar la direcci√≥n 0x123: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/00a/65d/4d3/00a65d4d32607e0510e8abddf86382fb.png" alt="imagen"><br>  Echemos un vistazo a lo que sucede aqu√≠: </p><br><p>  se inicia el cliente PinTool, inicializa nuestros interceptores, inicia el programa <br>  El programa se inicia, necesita direccionar las direcciones de los registros en una matriz de subprocesos, se llama a la funci√≥n getMemoryMap, que intercepta nuestra PinTool.  Por ejemplo, uno de los registros ha cambiado a la direcci√≥n 0x123, lo rastrearemos <br>  El cliente PinTool guarda los valores de las direcciones disociadas <br>  Transfiera el control a nuestro programa <br>  Adem√°s, en alg√∫n lugar hay una grabaci√≥n en nuestra direcci√≥n rastreada 0x123.  La funci√≥n StoreReg2Addr realiza un seguimiento de esto <br>  Y env√≠a la solicitud de escritura al cliente OpenOCD <br>  El cliente devuelve la respuesta, que se analiza.  Si todo est√° bien, entonces el control del programa regresa <br>  Adem√°s, en alg√∫n lugar del programa, la lectura ocurre en la direcci√≥n rastreada 0x123. <br>  loadAddr2Reg realiza un seguimiento de esto y env√≠a una solicitud OpenOCD al cliente. <br>  El cliente OpenOCD lo procesa y devuelve una respuesta <br>  Si todo est√° bien, pero el valor del registro MK se devuelve al programa <br>  El programa contin√∫a. <br>  Eso es todo por ahora, los c√≥digos fuente completos y ejemplos estar√°n en las siguientes partes. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433504/">https://habr.com/ru/post/es433504/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433494/index.html">10 modismos ingleses que nunca sabr√°s</a></li>
<li><a href="../es433496/index.html">Las empresas estatales obligan a cambiar a software nacional para 2022</a></li>
<li><a href="../es433498/index.html">Sberbank: tienes un "paquete" para m√≠, pero no lo tomar√© ...</a></li>
<li><a href="../es433500/index.html">El robot de mensajer√≠a Berkeley se quem√≥ debido a la falta de estado del sistema de monitoreo</a></li>
<li><a href="../es433502/index.html">Tecnolog√≠a de audio inal√°mbrica Bluetooth: ¬øcu√°l es mejor?</a></li>
<li><a href="../es433506/index.html">La UE busca el derecho a reparar electrodom√©sticos grandes</a></li>
<li><a href="../es433508/index.html">El propietario de la arquitectura MIPS tiene la intenci√≥n de abrir su conjunto de instrucciones (ISA) en 2019</a></li>
<li><a href="../es433510/index.html">Diferencia intercultural en juegos</a></li>
<li><a href="../es433512/index.html">Teor√≠a de la felicidad. El vertiginoso vuelo de un s√°ndwich con mantequilla</a></li>
<li><a href="../es433514/index.html">H√°galo usted mismo el infierno</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>