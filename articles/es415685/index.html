<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ù üßëüèø‚Äçü§ù‚Äçüßëüèæ ü§§ Divulgaci√≥n de memoria del kernel en el sistema operativo moderno üí± üéöÔ∏è üî∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Debajo del cortador se encuentra la traducci√≥n de la parte inicial del documento Detecci√≥n de la divulgaci√≥n de la memoria del n√∫cleo con emulaci√≥n x8...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Divulgaci√≥n de memoria del kernel en el sistema operativo moderno</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415685/"><p> Debajo del cortador se encuentra la traducci√≥n de la <strong>parte inicial del</strong> documento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Detecci√≥n de la divulgaci√≥n de la memoria del n√∫cleo con emulaci√≥n x86 y seguimiento de manchas</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo Proyecto Cero</a> ) por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mateusz Jurczyk</a> . </p><br><p>  En la parte traducida del documento: </p><br><ul><li>  Espec√≠ficos del lenguaje de programaci√≥n C (como parte del problema de expansi√≥n de memoria) </li><li>  Los detalles del funcionamiento de los n√∫cleos de Windows y Linux (como parte del problema de expansi√≥n de memoria) </li><li>  importancia de la divulgaci√≥n de la memoria del n√∫cleo y el impacto en la seguridad del sistema operativo </li><li>  M√©todos y t√©cnicas existentes para detectar y contrarrestar la divulgaci√≥n de la memoria del n√∫cleo. </li></ul><br><p>  Aunque el documento se centra en los mecanismos de comunicaci√≥n entre el n√∫cleo privilegiado del sistema operativo y las aplicaciones de usuario, la esencia del problema puede generalizarse para cualquier transferencia de datos entre diferentes dominios de seguridad: el hipervisor es la m√°quina invitada, el servicio del sistema privilegiado (daemon) es la aplicaci√≥n GUI, el cliente de red es el servidor, etc. . </p><br><p><img src="https://habrastorage.org/webt/ne/uy/1q/neuy1q8npc2ba-y3vcaycx9kqxe.jpeg" alt="KDPV"></p><a name="habracut"></a><br><h2 id="vvedenie">  Introduccion </h2><br><p>  Una de las tareas de los sistemas operativos modernos es garantizar la separaci√≥n de privilegios entre las aplicaciones del usuario y el n√∫cleo del sistema operativo.  En primer lugar, esto incluye el hecho de que la influencia de cada programa en el tiempo de ejecuci√≥n debe estar limitada por una determinada pol√≠tica de seguridad y, en segundo lugar, que los programas solo pueden acceder a la informaci√≥n que se les permite leer.  El segundo es dif√≠cil de proporcionar, dadas las propiedades del lenguaje C (el lenguaje de programaci√≥n principal utilizado en el desarrollo del n√∫cleo), lo que hace que sea extremadamente dif√≠cil transferir datos de forma segura entre diferentes dominios de seguridad. </p><br><p>  Los sistemas operativos modernos que operan en plataformas x86 / x86-64 son multiproceso y utilizan un modelo cliente-servidor en el que las aplicaciones en modo de usuario (clientes) se ejecutan de forma independiente y llaman al kernel (servidor) del sistema operativo con la intenci√≥n de trabajar con un recurso administrado por el sistema.  El mecanismo utilizado por el c√≥digo de modo de usuario ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anillo 3</a> ) para llamar a un conjunto predefinido de funciones del n√∫cleo (anillo 0) se llama llamadas del sistema o (brevemente) llamadas al sistema.  Una llamada t√≠pica del sistema se muestra en la Figura 1: <br><img src="https://habrastorage.org/webt/dh/p3/hr/dhp3hruaqmh7onhd0mweycvv4bg.png" alt="Figura 1: Llamada del sistema"><br>  <em>Figura 1: Ciclo de vida de la llamada al sistema.</em> </p><br><p>  Es muy importante evitar la p√©rdida inadvertida de contenido de la memoria del n√∫cleo al interactuar con los programas en modo de usuario.  Existe un riesgo significativo de revelar datos sensibles del n√∫cleo.  Los datos pueden transmitirse impl√≠citamente en los par√°metros de salida de las llamadas seguras (desde otros puntos de vista) del sistema. </p><br><p>  La divulgaci√≥n de la memoria del sistema privilegiado se produce cuando el n√∫cleo del sistema operativo devuelve una regi√≥n de memoria mayor (exceso) de lo necesario para almacenar la informaci√≥n correspondiente (contenida en el interior).  A menudo, los bytes redundantes contienen datos que se poblaron en un contexto diferente, y luego la memoria no se inicializ√≥ previamente, lo que evitar√≠a la propagaci√≥n de informaci√≥n en nuevas estructuras de datos. </p><br><h2 id="specifika-yazyka-programmirovaniya-c">  Espec√≠ficos del lenguaje de programaci√≥n C </h2><br><p>  En esta secci√≥n, veremos varios aspectos del lenguaje C que son m√°s importantes para el problema de expansi√≥n de memoria. </p><br><h4 id="neopredelennoe-sostoyanie-neinicializirovannyh-peremennyh">  Estado indefinido de variables no inicializadas </h4><br><p>  Las variables individuales de tipos simples (como char o int), as√≠ como los miembros de estructuras de datos (matrices, estructuras y uniones) permanecen en un estado indefinido hasta la primera inicializaci√≥n (independientemente de si se colocan en la pila o en el mont√≥n).  Citas relevantes de la especificaci√≥n C11 (ISO / IEC 9899: 201x Comit√© Draft N1570, abril de 2011): </p><br><blockquote>  6.7.9 Inicializaci√≥n <br>  ... <br>  10 Si un objeto que tiene una duraci√≥n de almacenamiento autom√°tico no se inicializa expl√≠citamente, <u>su valor es indeterminado</u> . <br><br>  7.22.3.4 La funci√≥n malloc <br>  ... <br>  2 La funci√≥n malloc asigna espacio para un objeto cuyo tama√±o se especifica por tama√±o y <u>cuyo valor es indeterminado</u> . <br><br>  7.22.3.5 La funci√≥n realloc <br>  ... <br>  2 La funci√≥n realloc desasigna el objeto antiguo al que apunta ptr y devuelve un puntero a un nuevo objeto que tiene el tama√±o especificado por tama√±o.  El contenido del nuevo objeto ser√° el mismo que el del objeto anterior antes de la desasignaci√≥n, hasta el menor de los tama√±os nuevos y antiguos.  Cualquier byte en el nuevo objeto m√°s all√° del tama√±o del objeto antiguo <u>tiene valores indeterminados</u> . </blockquote><p>  La parte que se aplica al c√≥digo del sistema es m√°s relevante para los objetos ubicados en la pila, ya que el n√∫cleo del sistema operativo generalmente tiene interfaces de asignaci√≥n din√°mica con su propia sem√°ntica (no necesariamente compatible con la biblioteca C est√°ndar, como se describir√° m√°s adelante). </p><br><p>  Hasta donde sabemos, ninguno de los tres compiladores de C m√°s populares para Windows y Linux (compilador C / C ++ de Microsoft, gcc, LLVM) crea c√≥digo que preinicializa las variables no inicializadas por el programador en la pila en modo Release-build (o su equivalente).  Hay opciones de compilaci√≥n para marcar marcos de pila con bytes especiales - marcadores (/ RTC en Microsoft Visual Studio, por ejemplo) pero no se usan en versiones de lanzamiento por razones de rendimiento.  Como resultado, las variables no inicializadas en la pila <em>heredan los</em> valores antiguos de las √°reas de memoria correspondientes. </p><br><p>  Considere un ejemplo de una implementaci√≥n est√°ndar de una llamada ficticia del sistema de Windows que multiplica un entero de entrada por dos y devuelve el resultado de la multiplicaci√≥n (Listado 1).  Obviamente, en el caso especial (InputValue == 0), la variable OutputValue permanece sin inicializar y se copia de nuevo al cliente.  Este error le permite abrir cuatro bytes de memoria de la pila del n√∫cleo para cada llamada. </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtMultiplyByTwo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD InputValue, LPDWORD OutputPointer)</span></span></span><span class="hljs-function"> </span></span>{ DWORD OutputValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InputValue != <span class="hljs-number"><span class="hljs-number">0</span></span>) { OutputValue = InputValue * <span class="hljs-number"><span class="hljs-number">2</span></span>; } *OutputPointer = OutputValue; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Listado de C√≥digo 1: Expandiendo la memoria a trav√©s de una variable local no inicializada.</em> </p><br><p>  Las fugas a trav√©s de una variable local no inicializada no son muy comunes en la pr√°ctica: por un lado, los compiladores modernos a menudo detectan y advierten sobre tales problemas, por otro lado, tales fugas son errores funcionales que pueden detectarse durante el desarrollo o las pruebas.  Sin embargo, el segundo ejemplo (en el Listado 2) muestra que una fuga tambi√©n puede ocurrir a trav√©s del campo de estructura. </p><br><p>  En este caso, el campo de estructura reservada nunca se usa expl√≠citamente en el c√≥digo, pero todav√≠a se copia de nuevo al modo de usuario y, por lo tanto, tambi√©n expone cuatro bytes de memoria del n√∫cleo al c√≥digo de llamada.  Este ejemplo muestra claramente que inicializar cada campo de cada estructura devuelta al cliente para todas las ramas de ejecuci√≥n de c√≥digo no es una tarea f√°cil.  En muchos casos, la inicializaci√≥n forzada parece il√≥gica, especialmente si este campo no juega ning√∫n papel pr√°ctico.  Pero es el hecho de que una variable no inicializada (o campo de estructura) en la pila (o en el mont√≥n) acepta el contenido de los datos previamente almacenados en esta √°rea de memoria (en el contexto de otra operaci√≥n), se encuentra en el coraz√≥n del problema de expansi√≥n de la memoria del n√∫cleo. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SYSCALL_OUTPUT</span></span></span><span class="hljs-class"> {</span></span> DWORD Sum; DWORD Product; DWORD Reserved; } SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; <span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtArithOperations</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD InputValue, PSYSCALL_OUTPUT OutputPointer )</span></span></span><span class="hljs-function"> </span></span>{ SYSCALL_OUTPUT OutputStruct; OutputStruct.Sum = InputValue + <span class="hljs-number"><span class="hljs-number">2</span></span>; OutputStruct.Product = InputValue * <span class="hljs-number"><span class="hljs-number">2</span></span>; RtlCopyMemory(OutputPointer, &amp;OutputStruct, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SYSCALL_OUTPUT)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Listado 2: Memoria expansible a trav√©s de un campo de estructura reservada.</em> </p><br><h4 id="vyravnivanie-struktur-i-zapolnyayuschie-padding-bayty">  Alineaci√≥n de estructuras y bytes de relleno. </h4><br><p>  Inicializar todos los campos de la estructura de salida es un buen comienzo para evitar expandir la memoria.  Pero esto no es suficiente para garantizar que en la representaci√≥n de bajo nivel no haya bytes sin inicializar.  Volvamos a la especificaci√≥n C11: </p><br><blockquote>  6.5.3.4 Los operadores sizeof y Alignof <br>  ... <br>  4 [...] Cuando se aplica a un operando que tiene estructura o tipo de uni√≥n, el resultado es el n√∫mero total de bytes en dicho objeto, <u>incluidos los rellenos internos y finales</u> . <br><br>  6.2.8 Alineaci√≥n de objetos <br>  1 Los tipos de objetos completos tienen requisitos de alineaci√≥n que <u>imponen restricciones a las direcciones en las que se pueden asignar objetos de ese tipo</u> .  Una alineaci√≥n es un valor entero integrado definido por la implementaci√≥n que representa el n√∫mero de bytes entre direcciones sucesivas a las que se puede asignar un objeto dado.  [...] <br><br>  6.7.2.1 Especificadores de estructura y uni√≥n <br>  ... <br>  17 <u>Puede haber relleno no identificado en el extremo</u> de una estructura o uni√≥n. </blockquote><p>  Es decir, los compiladores de lenguaje C para arquitecturas x86 (-64) utilizan la alineaci√≥n natural de campos de estructuras (que tienen un tipo primitivo): cada uno de estos campos est√° alineado por N bytes, donde N es el tama√±o del campo.  Adem√°s, las estructuras y combinaciones completas tambi√©n se alinean cuando se declaran en una matriz, y se cumple el requisito de alineaci√≥n de campos anidados.  Para garantizar la alineaci√≥n, los bytes de relleno impl√≠citos se insertan en las estructuras cuando es necesario.  Aunque no son accesibles directamente en el c√≥digo fuente, estos bytes tambi√©n heredan valores antiguos de las √°reas de memoria y pueden transmitir informaci√≥n al modo de usuario. </p><br><p>  En el ejemplo del Listado 3, la estructura SYSCALL_OUTPUT se devuelve al c√≥digo de llamada.  Contiene campos de 4 y 8 bytes, separados por 4 bytes de relleno, necesarios para que la direcci√≥n del campo LargeSum se convierta en un m√∫ltiplo de 8.  A pesar de que ambos campos se inicializan correctamente, los bytes de relleno no se configuran expl√≠citamente, lo que nuevamente conduce a la expansi√≥n de la memoria de la pila del n√∫cleo.  La ubicaci√≥n espec√≠fica de la estructura en la memoria se muestra en la Figura 2. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SYSCALL_OUTPUT</span></span></span><span class="hljs-class"> {</span></span> DWORD Sum; QWORD LargeSum; } SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; <span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtSmallSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD InputValue, PSYSCALL_OUTPUT OutputPointer )</span></span></span><span class="hljs-function"> </span></span>{ SYSCALL_OUTPUT OutputStruct; OutputStruct.Sum = InputValue + <span class="hljs-number"><span class="hljs-number">2</span></span>; OutputStruct.LargeSum = <span class="hljs-number"><span class="hljs-number">0</span></span>; RtlCopyMemory(OutputPointer, &amp;OutputStruct, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SYSCALL_OUTPUT)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Listado 3: Expandiendo la memoria alineando la estructura.</em> </p><br><p><img src="https://habrastorage.org/webt/pw/i1/1a/pwi11anmkjf_ujlkogv2bjmbsuo.png" alt="Figura 2: Alineando la estructura"><br>  Figura 2: Representaci√≥n de la estructura en la memoria con la alineaci√≥n en mente. </p><br><p>  Las fugas a trav√©s de las alineaciones son relativamente comunes, ya que muchos par√°metros de salida de las llamadas al sistema est√°n representados por estructuras.  El problema es especialmente grave para las plataformas de 64 bits, donde el tama√±o de los punteros, size_t y tipos similares aumenta de 4 a 8 bytes, lo que lleva a la aparici√≥n del relleno necesario para alinear los campos de tales estructuras. </p><br><p>  Dado que los bytes de relleno no se pueden direccionar en el c√≥digo fuente, es necesario usar memset o una funci√≥n similar para restablecer el √°rea de memoria completa de la estructura antes de inicializar cualquiera de sus campos y copiarlo en modo de usuario, por ejemplo: </p><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;OutputStruct, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(OutputStruct));</code> </pre> <br><p>  Sin embargo, Seacord RC en su libro "The CERT C Coding Standard, Second Edition: 98 Rules for Development Safe, Reliable and Secure Systems. Addison-Wesley Professional" 2014 afirma que esta no es una soluci√≥n ideal porque los bytes de relleno ) a√∫n puede ser <em>derribado</em> despu√©s de llamar a memset, por ejemplo, como un efecto secundario de las operaciones con campos adyacentes.  La preocupaci√≥n puede justificarse mediante la siguiente declaraci√≥n en la especificaci√≥n C: </p><br><blockquote>  6.2.6 Representaciones de tipos <br>  6.2.6.1 General <br>  ... <br>  6 <u>Cuando un valor se almacena en un objeto de estructura o tipo de uni√≥n</u> , incluso en un objeto miembro, los bytes de la representaci√≥n del objeto que corresponden a <u>los bytes de relleno toman valores no especificados</u> .  [...] </blockquote><p>  Sin embargo, en la pr√°ctica, ninguno de los compiladores de C que probamos ley√≥ o escribi√≥ fuera de las √°reas de memoria de los campos declarados expl√≠citamente.  Parece que esta opini√≥n es compartida por los desarrolladores de sistemas operativos que usan memset. </p><br><h4 id="obedineniya-unions-i-polya-raznogo-razmera">  Uniones y campos de diferentes tama√±os. </h4><br><p>  Las uniones son otra construcci√≥n compleja del lenguaje C en el contexto de la comunicaci√≥n con un c√≥digo de llamada menos privilegiado.  Considere c√≥mo la especificaci√≥n C11 describe la representaci√≥n de uniones en la memoria: </p><br><blockquote>  6.2.5 Tipos <br>  ... <br>  20 Se puede construir cualquier n√∫mero de tipos derivados a partir de los tipos de objeto y funci√≥n, de la siguiente manera: [...] <u>Un tipo de uni√≥n describe un conjunto superpuesto de objetos miembros no vac√≠os</u> , cada uno de los cuales tiene un nombre opcionalmente especificado y posiblemente un tipo distinto. <br><br>  6.7.2.1 Especificadores de estructura y uni√≥n <br>  ... <br>  6 Como se discuti√≥ en 6.2.5, una estructura es un tipo que consiste en una secuencia de miembros, cuyo almacenamiento se asigna en una secuencia ordenada, y <u>una uni√≥n es un tipo que consiste en una secuencia de miembros cuyo almacenamiento se superpone</u> . <br>  ... <br>  16 <u>El tama√±o de un sindicato es suficiente para contener al mayor de sus miembros</u> .  El valor de como m√°ximo uno de los miembros se puede almacenar en un objeto de uni√≥n en cualquier momento. </blockquote><p>  El problema es que si la uni√≥n consta de varios campos de diferentes tama√±os y solo se inicializa expl√≠citamente un campo de menor tama√±o, los bytes restantes asignados para acomodar campos grandes permanecen sin inicializar.  Veamos un ejemplo de un manejador de llamadas de sistema hipot√©tico, que se muestra en el Listado 4, junto con la asignaci√≥n de memoria de uni√≥n SYSCALL_OUTPUT que se muestra en la Figura 3. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _SYSCALL_OUTPUT { DWORD Sum; QWORD LargeSum; } SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; <span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtSmallSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD InputValue, PSYSCALL_OUTPUT OutputPointer )</span></span></span><span class="hljs-function"> </span></span>{ SYSCALL_OUTPUT OutputStruct; OutputStruct.Sum = InputValue + <span class="hljs-number"><span class="hljs-number">2</span></span>; RtlCopyMemory(OutputPointer, &amp;OutputStruct, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SYSCALL_OUTPUT)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Listado de C√≥digo 4: Expandiendo la memoria inicializando parcialmente una uni√≥n.</em> </p><br><p><img src="https://habrastorage.org/webt/pa/8y/ck/pa8yckhciassiwm9yc19nssczwo.png" alt="Figura 3: Alinear una uni√≥n"><br>  <em>Figura 3: Representaci√≥n de la uni√≥n en memoria con alineaci√≥n.</em> </p><br><p>  Resulta que el tama√±o total de la uni√≥n SYSCALL_OUTPUT es de 8 bytes (debido al tama√±o del campo LargeSum m√°s grande).  Sin embargo, la funci√≥n establece solo el valor del campo m√°s peque√±o, dejando 4 bytes finales sin inicializar, lo que posteriormente conduce a una fuga en su aplicaci√≥n cliente. </p><br><p>  Una implementaci√≥n segura solo debe establecer el campo Suma en el espacio de direcciones del usuario, y no copiar todo el objeto con √°reas de memoria potencialmente no utilizadas.  Otra soluci√≥n de trabajo es llamar a la funci√≥n memset para anular una copia de la uni√≥n en la memoria del kernel antes de configurar cualquiera de sus campos y transferirlo nuevamente al modo de usuario. </p><br><h4 id="nebezopasnyy-sizeof">  Tama√±o inseguro de </h4><br><p>  Como se muestra en las dos secciones anteriores, el uso del operador sizeof puede contribuir directa o indirectamente a revelar la memoria del n√∫cleo, haciendo que se copien m√°s datos de los que se inicializaron previamente. </p><br><p>  C no tiene el aparato necesario para transferir datos de forma segura desde el n√∫cleo al espacio del usuario, o, m√°s generalmente, entre contextos de seguridad diferentes.  El lenguaje no contiene metadatos de tiempo de ejecuci√≥n que pueden indicar expl√≠citamente qu√© bytes se configuraron en cada estructura de datos que se utiliza para interactuar con el n√∫cleo del sistema operativo.  Como resultado, la responsabilidad recae en el programador, quien debe determinar qu√© partes de cada objeto deben pasarse al c√≥digo de llamada.  Si se hace correctamente, debe escribir una funci√≥n de copia segura separada para cada estructura de salida utilizada en las llamadas al sistema.  Lo que a su vez dar√° lugar a un aumento en el tama√±o del c√≥digo, un deterioro en su legibilidad y, en general, ser√° una tarea tediosa y lenta. </p><br><p>  Por otro lado, es conveniente y simple copiar toda el √°rea de memoria del n√∫cleo con una sola llamada de memoria y el argumento sizeof, y dejar que el cliente determine qu√© partes de la salida se utilizar√°n.  Resulta que este enfoque se usa hoy en Windows y Linux.  Y cuando se detecta un caso espec√≠fico de fuga de informaci√≥n, el fabricante del sistema operativo proporciona y distribuye de inmediato un parche con una llamada de memset.  Desafortunadamente, esto no resuelve el problema en el caso general. </p><br><h2 id="specifika-konkretnyh-os">  Detalles del sistema operativo </h2><br><p>  Existen ciertas soluciones de dise√±o de kernel, m√©todos de programaci√≥n y patrones de c√≥digo que afectan la propensi√≥n del sistema operativo a las vulnerabilidades de expansi√≥n de memoria.  Se consideran en las siguientes subsecciones. </p><br><h4 id="pereispolzovanie-dinamicheskoy-pamyati">  Reutilizando memoria din√°mica </h4><br><p>  Los asignadores actuales de memoria din√°mica (tanto en modo de usuario como en modo de n√∫cleo) est√°n altamente optimizados, ya que su rendimiento tiene un impacto significativo en el rendimiento de todo el sistema.  Una de las optimizaciones m√°s importantes es la reutilizaci√≥n de la memoria: cuando se libera, la memoria correspondiente rara vez se descarta por completo, en cambio, se guarda en la lista de regiones listas para ser devueltas la pr√≥xima vez que se asigne.  Para guardar los ciclos de la CPU, las √°reas de memoria predeterminadas no se borran entre la desasignaci√≥n y la nueva asignaci√≥n.  Como resultado de esto, resulta que dos partes no conectadas del n√∫cleo funcionan con el mismo rango de memoria por un corto tiempo.  Esto significa que la p√©rdida del contenido de la memoria din√°mica del n√∫cleo le permite revelar los datos de varios componentes del sistema operativo. </p><br><p>  En los siguientes p√°rrafos, damos una breve descripci√≥n de los asignadores utilizados en los n√∫cleos de Windows y Linux, y sus cualidades m√°s notables. </p><br><p>  <strong>Ventanas</strong> <br>  La funci√≥n clave del administrador del grupo de kernel de Windows es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ExAllocatePoolWithTag</a> , que se puede llamar directamente o mediante uno de los shells disponibles: ExAllocatePool {‚àÖ, Ex, WithQuotaTag, WithTagPriority}.  Ninguna de estas funciones vac√≠a el contenido de la memoria devuelta, ya sea de forma predeterminada o mediante cualquier indicador de entrada.  Por el contrario, todos tienen la siguiente advertencia en su respectiva documentaci√≥n de MSDN: </p><br><blockquote>  Nota La memoria que asigna la funci√≥n no est√° inicializada.  Un controlador en modo kernel primero debe poner a cero esta memoria si va a hacerla visible para el software en modo usuario (para evitar fugas de contenido potencialmente privilegiado). </blockquote><p>  El c√≥digo de llamada puede seleccionar uno de los seis tipos principales de grupos: NonPagedPool, NonPagedPoolNx, NonPagedPoolSession, NonPagedPoolSessionNx, PagedPool y PagedPoolSession.  Cada uno de ellos tiene una regi√≥n separada en el espacio de direcciones virtuales y, por lo tanto, las √°reas de memoria asignadas solo se pueden reutilizar dentro del mismo tipo de grupo.  La frecuencia de reutilizaci√≥n de piezas de memoria es muy alta, y las √°reas cerradas generalmente se devuelven solo si no se encuentra un registro adecuado en las listas de b√∫squeda, o si la solicitud es tan grande que se requieren nuevas p√°ginas de memoria.  En otras palabras, actualmente no existen pr√°cticamente factores que impidan la divulgaci√≥n de la memoria de la agrupaci√≥n en Windows, y casi todos estos errores se pueden utilizar para filtrar datos confidenciales de diferentes partes del n√∫cleo. </p><br><p>  <strong>Linux</strong> <br>  El kernel de Linux tiene tres interfaces principales para asignar memoria din√°micamente: </p><br><ul><li>  <strong>kmalloc</strong> : una funci√≥n com√∫n utilizada para asignar bloques de memoria de tama√±o arbitrario (continuo en el espacio de direcciones virtual y f√≠sico), utiliza <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la asignaci√≥n de memoria de losa</a> . </li><li>  <strong>kmem_cache_create</strong> y <strong>kmem_cache_alloc</strong> : un mecanismo especializado para asignar objetos de un tama√±o fijo (estructuras, por ejemplo), tambi√©n utiliza <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la asignaci√≥n de memoria de losa</a> . </li><li>  <strong>vmalloc</strong> es una funci√≥n de asignaci√≥n raramente utilizada que devuelve regiones cuya continuidad no est√° garantizada en el nivel de memoria f√≠sica. </li></ul><br><p>  Estas funciones (por s√≠ mismas) no garantizan que las regiones seleccionadas no contendr√°n datos antiguos (potencialmente confidenciales), lo que hace posible abrir la memoria del mont√≥n del n√∫cleo.  Sin embargo, hay varias formas en que el c√≥digo de llamada puede solicitar memoria anulada: </p><br><ul><li>  <strong>kmalloc</strong> tiene una funci√≥n <strong>kzalloc anal√≥gico,</strong> lo que asegura que se borre la memoria devuelta. </li><li>  El indicador opcional __GFP_ZERO se puede pasar a <strong>kmalloc</strong> , <strong>kmem_cache_alloc</strong> y algunas otras funciones para lograr el mismo resultado. </li><li>  <strong>kmem_cache_create</strong> acepta un puntero a una funci√≥n constructora opcional que se llama para preinicializar cada objeto antes de devolverlo al c√≥digo de llamada.  El constructor se puede implementar como una envoltura alrededor de un conjunto de memorias para poner a cero un √°rea de memoria determinada. </li></ul><br><p>  Vemos la disponibilidad de estas opciones como condiciones favorables para la seguridad del kernel, ya que alientan a los desarrolladores a tomar decisiones informadas y les permiten simplemente trabajar con las funciones de asignaci√≥n de memoria existentes en lugar de agregar llamadas de memoria adicionales despu√©s de cada asignaci√≥n de memoria din√°mica. </p><br><h4 id="massivy-fiksirovannogo-razmera">  Matrices de tama√±o fijo </h4><br><p>  El acceso a varios recursos del sistema operativo se puede obtener por sus nombres de prueba.  La variedad de recursos con nombre en Windows es muy grande, por ejemplo: archivos y directorios, claves y valores de claves de registro, ventanas, fuentes y mucho m√°s.  Para algunos de ellos, la longitud del nombre es limitada y se expresa mediante una constante, como MAX_PATH (260) o LF_FACESIZE (32).  En tales casos, los desarrolladores de kernel a menudo simplifican el c√≥digo declarando los buffers de tama√±o m√°ximo y copi√°ndolos como un todo (por ejemplo, usando la palabra clave sizeof) en lugar de trabajar solo con la parte correspondiente de la l√≠nea.  Esto es especialmente √∫til si las cadenas son miembros de estructuras m√°s grandes.  Dichos objetos se pueden mover libremente en la memoria sin preocuparse por administrar punteros a la memoria din√°mica. </p><br><p>  Como era de esperar, las memorias intermedias grandes rara vez se usan por completo, y el espacio de almacenamiento restante a menudo no se vac√≠a.  Esto puede conducir a fugas particularmente graves de largas √°reas contiguas de memoria del n√∫cleo.  En el ejemplo del Listado 5, la llamada del sistema usa la funci√≥n RtlGetSystemPath para cargar la ruta del sistema en el b√∫fer local, y si la llamada tiene √©xito, los 260 bytes se pasan al llamante, independientemente de la longitud real de la l√≠nea. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtGetSystemPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PCHAR OutputPath)</span></span></span><span class="hljs-function"> </span></span>{ CHAR SystemPath[MAX_PATH]; NTSTATUS Status; Status = RtlGetSystemPath(SystemPath, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SystemPath)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NT_SUCCESS(Status)) { RtlCopyMemory(OutputPath, SystemPath, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SystemPath)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status; }</code> </pre> <br><p>  <em>Listado 5: Expandiendo la memoria inicializando parcialmente el buffer de cadena.</em> </p><br><p>  La regi√≥n de memoria copiada de nuevo al espacio de usuario en este ejemplo se muestra en la Figura 4. </p><br><p><img src="https://habrastorage.org/webt/ki/8j/5z/ki8j5zyo73i5k4o12grlolwsrhk.png" alt="Figura 4: Memoria de b√∫fer de cadena parcialmente inicializada"><br>  <em>Figura 4: Memoria de un b√∫fer de l√≠nea parcialmente inicializado.</em> </p><br><p>  Una implementaci√≥n segura solo debe devolver la ruta solicitada, y no todo el b√∫fer utilizado para el almacenamiento.  Este ejemplo demuestra una vez m√°s c√≥mo la estimaci√≥n del tama√±o de los datos con el operador sizeof (utilizado como par√°metro para RtlCopyMemory) puede ser completamente incorrecta con respecto a la cantidad real de datos que el n√∫cleo debe pasar al √°rea de usuario. </p><br><h4 id="proizvolnyy-razmer-vyhodnyh-dannyh-sistemnogo-vyzova">  Tama√±o de salida de llamada del sistema arbitrario </h4><br><p>  La mayor√≠a de las llamadas al sistema aceptan punteros a la salida en modo de usuario junto con el tama√±o del b√∫fer.  En la mayor√≠a de los casos, la informaci√≥n de tama√±o solo debe usarse para determinar si el b√∫fer proporcionado es suficiente para recibir la salida de la llamada del sistema.  No utilice el tama√±o completo del b√∫fer de salida proporcionado para especificar la cantidad de memoria que se copiar√°.  Sin embargo, vemos casos en los que el n√∫cleo intentar√° utilizar cada byte del b√∫fer de salida del usuario, sin contar la cantidad de datos reales que deben copiarse.  Un ejemplo de este comportamiento se muestra en el Listado 6. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtMagicValues</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LPDWORD OutputPointer, DWORD OutputLength)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (OutputLength &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(DWORD)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_BUFFER_TOO_SMALL; } LPDWORD KernelBuffer = Allocate(OutputLength); KernelBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0xdeadbeef</span></span>; KernelBuffer[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0xbadc0ffe</span></span>; KernelBuffer[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0xcafed00d</span></span>; RtlCopyMemory(OutputPointer, KernelBuffer, OutputLength); Free(KernelBuffer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Listado 6: Expandiendo la memoria a trav√©s de un buffer de salida de tama√±o arbitrario.</em> </p><br><p>  El prop√≥sito de una llamada al sistema es proporcionar el c√≥digo de llamada con tres valores especiales de 32 bits, que ocupan un total de 12 bytes.  Aunque verificar el tama√±o correcto del b√∫fer al comienzo de la funci√≥n es correcto, el uso del argumento OutputLength deber√≠a terminar all√≠.  Sabiendo que el b√∫fer de salida es lo suficientemente grande como para guardar el resultado, el n√∫cleo puede asignar 12 bytes de memoria, llenarlo y copiar el contenido nuevamente al b√∫fer en modo usuario proporcionado.  En cambio, una llamada al sistema asigna un bloque de grupo (adem√°s, con una longitud controlada por el usuario) y copia toda la memoria asignada al espacio del usuario.  Resulta que todos los bytes, excepto los primeros 12, no se inicializan y se abren por error al usuario, como se muestra en la Figura 5. </p><br><p><img src="https://habrastorage.org/webt/m7/hy/dj/m7hydjfgkhaqgizxuhr2xcmv8jw.png" alt="Figura 5: Memoria de b√∫fer arbitraria"><br>  <em>Figura 5: Memoria de b√∫fer de tama√±o arbitrario.</em> </p><br><p>  El esquema discutido en esta secci√≥n es especialmente com√∫n para Windows.           : </p><br><ul><li> ,      Windows,                  .            ,       . </li><li>              .   ,     ,                .      ,    (   ‚Äî  )  . </li></ul><br><p>  ,        .      ,     ,       . </p><br><h2 id="faktory-sposobstvuyuschie-poyavleniyu-oshibok-raskrytiya-pamyati"> ,      </h2><br><p>     ,           .         ,          Windows    . </p><br><p> <strong>  </strong> <br>  ,       ,   .        ,      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AddressSanitizer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PageHeap</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Special Pool</a> .  , ,   -          .         ,         .   ,         ,       ,           ,        ,       .       <em></em>     ,      (   ). </p><br><p>  ,             ,  ,       .               ,                  . </p><br><p> <strong>,    API</strong> <br>           API,   Windows (Win32/User32 API). API         ,   ,          ,     .     ,  ,        , ,      .              <em></em>  . </p><br><h2 id="znachimost-i-vliyanie-na-bezopasnost-sistemy">       </h2><br><p>   ,             .          ,            .      ,     <em></em>       ,       ,      .        ,         ,    . </p><br><p>  ,      ,          .     ,       KASLR (Kernel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Address Space Layout Randomization</a> ),                .  :   Windows,    Hacking Team   2015  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Juan Vazquez. Revisiting an Info Leak</a> )         (derandomize)     win32k.sys,       . ,         Matt Tait'  Google Project Zero ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kernel-mode ASLR leak via uninitialized memory returned to usermode by NtGdiGetTextMetrics</a> )     MS15-080 (CVE-2015-2433). </p><br><p> <strong></strong> <br>       (/)   ,      ,      (control Ô¨Çow),  :   ,   ,   ,   ,   StackGuard  Linux  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">/GS  Windows</a> .    ,             .        ,   ,            . </p><br><p> <strong>  (/)</strong> <br>    (/)    ,    ,      ,    :  ,   ,  ,     .               ,     ,      .         .  ,         ( ,    )   ,  ,      . </p><br><h2 id="drugie-suschestvuyuschie-issledovaniya">    </h2><br><p><img src="https://habrastorage.org/webt/wp/ky/ap/wpkyap5uiyz52hrghshrxxve1v0.jpeg" alt="KDPV # 2"></p><br><h4 id="microsoft-windows"> Microsoft Windows </h4><br><p> <strong></strong> <br>  2015            Windows.   2015  Matt Tait           win32k!NtGdiGetTextMetrics.          Windows   Hacking Team.   ,      ,       ,    0-day       Windows. </p><br><p>    2015, WanderingGlitch (HP Zero Day Initiative)          ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Acknowledgments ‚Äì 2015</a> ).           Ruxcon 2016 (  )    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Leaking Windows Kernel Pointers"</a> . </p><br><p>  ,   2017 fanxiaocao  pjf  IceSword Lab (Qihoo 360)   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Automatically Discovering Windows Kernel Information Leak Vulnerabilities"</a> ,    ,      14   2017  (8      ).        Bochspwn Reloaded,             ,            .        VMware     (Bochs)         .   ,  Bochspwn Reloaded,                . </p><br><p>         ,  ,    2010-2011          ,     win32k: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Challenge: On 32bit Windows7, explain where the upper 16bits of eax come from after a call to NtUserRegisterClassExWOW()"</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Subtle information disclosure in WIN32K.SYS syscall return values"</a> .          Windows 8,   2015  Matt Tait ,           : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Google Project Zero Bug Tracker</a> . </p><br><p> <strong></strong> <br>       (   ),  ,    2017   - Windows        -,   : Joseph Bialek ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Anyone notice my change to the Windows IO Manager to generically kill a class of info disclosure? BuÔ¨ÄeredIO output buÔ¨Äer is always zero'd"</a> .      ,  IOCTL-          . </p><br><p>        ,   Visual Studio 15.5   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">POD-</a> ,       "= {0}",   .       ,      padding- ()   . </p><br><h4 id="linux"> Linux </h4><br><p>    Windows,   Linux        ,         2010 .        ,             (  )   (    ) .  ,        Windows  Linux         ,        ‚Äî ,    . </p><br><p> <strong></strong> <br>    ,   Linux       .   "Linux kernel vulnerabilities: State-of-the-art defenses and open problems"   2010    2011   28    .   2017-  "Securing software systems by preventing information leaks" Lu K.    59  ,    2013-   2016-.          . : Rosenberg  Oberheide    25 ,     Linux  2009-2010 ,     .          Linux c <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">grsecurity</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PaX-hardened</a> . Vasiliy Kulikov   25   2010-2011 ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   Coccinelle</a> .  , Mathias Krause <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   21      2013 </a>   50      . </p><br><p>    ,      ,           Linux.     ‚Äî   -Wuninitialized (  gcc,   LLVM),          .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  kmemcheck</a> ,      Valgrind'   .        ,        .         ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">KernelAddressSANitizer</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">KernelMemorySANitizer</a> .      KMSAN    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">syzkaller</a> (   ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> 19    </a> ,        . </p><br><p>               Linux.  2014 ‚Äî 2016  Peir¬¥o      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Coccinelle</a>     ,      Linux  3.12: "Detecting stack based kernel information leaks" International Joint Conference SOCO14-CISIS14-ICEUTE14, pages 321‚Äì331 (Springer, 2014)  "An analysis on the impact and detection of kernel stack infoleaks" Logic Journal of the IGPL.         ,          .  2016- Lu       UniSan ‚Äî   ,    ,                 :   ,   .            ,        20%     (350   1800),      19     Linux  Android. </p><br><p>             ‚Äî    (multi-variant program execution),            ,      .           ,             .     ,  KASLR,   -,         .         ,  2006    DieHard: probabilistic memory safety for unsafe languages,   2017  ‚Äî BUDDY: Securing software systems by preventing information leaks.     John North   "Identifying Memory Address Disclosures" 2015- . ,  SafeInit (Comprehensive and Practical Mitigation of Uninitialized Read Vulnerabilities)  ,          ,            .       , ,   ,        Linux. </p><br><p> <strong></strong> <br>                  ,   .      ,       :     ,        .     ,  , -    ,             .                   . </p><br><p>        CONFIG_PAGE_POISONING  CONFIG_DEBUG_SLAB,       -.       -,      .        , ,  ,       Linux. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">grsecurity</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PaX</a>    .  ,   PAX_MEMORY_SANITIZE   ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">slab</a> ,    (        ‚Äî   ).  ,  PAX_MEMORY_STRUCTLEAK     ,    (  ),       .         padding- (),          100% .  ,      ‚Äî PAX_MEMORY_STACKLEAK,            .      ,      ,        .       (Kernel Self Protection Project)   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> STACKLEAK</a>   . </p><br><p>               Linux: </p><br><div class="spoiler"> <b class="spoiler_title">Secure deallocation, Chow  , 2005</b> <div class="spoiler_text"><p> Chow, Jim and PfaÔ¨Ä, Ben and GarÔ¨Ånkel, Tal and Rosenblum, Mendel. Shredding Your Garbage: Reducing Data Lifetime Through Secure Deallocation. In USENIX Security Symposium, pages 22‚Äì22, 2005. </p></div></div><br><p>  ,       ,          ( )  .         Linux     . </p><br><div class="spoiler"> <b class="spoiler_title">Split Kernel, Kurmus  Zippel, 2014</b> <div class="spoiler_text"><p> Kurmus, Anil and Zippel, Robby. A tale of two kernels: Towards ending kernel hardening wars with split kernel. In Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security, pages 1366‚Äì1377. ACM, 2014. </p></div></div><br><p>      ,           . </p><br><div class="spoiler"> <b class="spoiler_title">SafeInit, Milburn  , 2017</b> <div class="spoiler_text"><p> Milburn, Alyssa and Bos, Herbert and GiuÔ¨Ärida, Cristiano. SafeInit: Comprehensive and Practical Mitigation of Uninitialized Read Vulnerabilities. In Proceedings of the 2017 Annual Network and Distributed System Security Symposium (NDSS)(San Diego, CA), 2017. </p></div></div><br><p>         ,      ,         . </p><br><div class="spoiler"> <b class="spoiler_title">UniSan, Lu  , 2016</b> <div class="spoiler_text"><p> Lu, Kangjie and Song, Chengyu and Kim, Taesoo and Lee, Wenke. UniSan: Proactive kernel memory initialization to eliminate data leakages. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, pages 920‚Äì932. ACM, 2016. </p></div></div><br><p>    SafeInit         ,  ,       ,      ,      . </p><br><p>       ,  Linux             . </p><br><h2 id="vmesto-epiloga-ot-perevodchika">   ( ) </h2><br><p>        ,    ,          (      ).  :  (),     , ,    ,   ( - )     .   ,          . , ,        . </p><br><p>     ,             : </p><br><ul><li> Bochspwn Reloaded ‚Äì detection with software x86 emulation </li><li> Windows bug reproduction techniques </li><li> Alternative detection methods </li><li> Other data sinks </li><li> Future work </li><li> Other system instrumentation schemes </li></ul><br><p>  ,     :)          ,       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es415685/">https://habr.com/ru/post/es415685/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es415675/index.html">Resumen de noticias de PostgreSQL. N√∫mero 8</a></li>
<li><a href="../es415677/index.html">Las ciudades en crecimiento tienen dificultades para mover a las masas de personas verticalmente y en la superficie</a></li>
<li><a href="../es415679/index.html">¬øPor qu√© los ni√±os ricos muestran buenos resultados en un experimento de malvavisco?</a></li>
<li><a href="../es415681/index.html">La historia de la creaci√≥n del int√©rprete de lenguaje de se√±as.</a></li>
<li><a href="../es415683/index.html">Pru√©balo en la programaci√≥n Q #</a></li>
<li><a href="../es415687/index.html">Fintech Digest: el Banco Central obliga a los bancos a verificar los dispositivos de los clientes desde los que se transfiere dinero</a></li>
<li><a href="../es415689/index.html">Jugamos batalla naval en BGP</a></li>
<li><a href="../es415693/index.html">Oumuamua Lleg√≥, perplejo, se fue volando (y no prometi√≥ regresar). Y uno de estos d√≠as, una vez m√°s, perplejo</a></li>
<li><a href="../es415697/index.html">Rhino IoT</a></li>
<li><a href="../es415699/index.html">Tres historias cortas del registro de Windows</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>