<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚵🏽 🥚 🧓🏽 آلة حاسبة قائمة على المكدس على لوحة Cyclone IV FPGA 📛 ⚜️ ♑️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="مقدمة 
 كطلاب في السنة الأولى من جامعة Innopolis ، أتيحت لنا الفرصة لعمل مشروعنا الخاص في هندسة الكمبيوتر. اقترحت علينا الجامعة العديد من المشاريع واخ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>آلة حاسبة قائمة على المكدس على لوحة Cyclone IV FPGA</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429888/" style=";text-align:right;direction:rtl"><h2 style=";text-align:right;direction:rtl">  مقدمة </h2><br>  كطلاب في السنة الأولى من جامعة Innopolis ، أتيحت لنا الفرصة لعمل مشروعنا الخاص في هندسة الكمبيوتر.  اقترحت علينا الجامعة العديد من المشاريع واخترنا عمل آلة حاسبة قائمة على المكدس مع تدوين عكسي.  أحد متطلبات المشروع هو استخدام لوحة FPGA المقدمة من الجامعة. <br><br><img src="https://habrastorage.org/webt/c2/qu/2i/c2qu2ixnazu7mac6eghy6bka4j0.jpeg"><br><br>  بصفتنا مجلسنا ، اخترنا Cyclon IV.  لذلك ، كان علينا كتابة رمز على لغة وصف الأجهزة.  في الدورة درسنا فيريلوج ، لذلك اخترناها.  أيضا ، لدى الجامعة وحدات إضافية لـ FPGA ، مثل numpad ، لذلك قررنا استخدامها في مشروعنا. <br><br>  في هذه المقالة ، نريد مشاركة معرفتنا حول FPGA و Verilog ، كما نقدم لك برنامجًا تعليميًا لتكرار مشروعنا. <br><a name="habracut"></a><br><h2 style=";text-align:right;direction:rtl">  التصميم الأساسي </h2><br>  شكلنا مجموعة من شخصين ونظمنا اجتماعنا الأول.  هناك ناقشنا التصميم الأساسي ، وتقسيم مسؤولياتنا ووضعنا خطة قصيرة مع المواعيد النهائية.  هذا ما توصلنا إليه.  نحن بحاجة إلى: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  تنفيذ المكدس في Verilog </li><li style=";text-align:right;direction:rtl">  تعلم كيفية العمل مع اللوحة </li><li style=";text-align:right;direction:rtl">  نفذ الإخراج من خلال شاشة عرض مكونة من 8 أجزاء موجودة على لوحة FPGA </li><li style=";text-align:right;direction:rtl">  اصنع وحدة رئيسية تربط جميع الوحدات معًا </li></ul><br><img src="https://habrastorage.org/webt/oj/iq/cy/ojiqcysqck8cqbhyx73hcdh1hwo.png"><br><br>  لقد اختار كل عضو من أعضاء الفريق نفسه وحدة للكتابة.  كانت مهمة الترتيب الأول هي تنفيذ التكديس والإخراج والإدخال.  كما تم تحديده ، بدأنا العمل. <br><br><h2 style=";text-align:right;direction:rtl">  المكدس </h2><br>  في المكدس ، نقوم بتخزين جميع المعاملات لدينا.  لتخزينها ، خصصنا 32 كلمة من الذاكرة. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">كود وحدة المكدس</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"><code class="plaintext hljs">module stack( //Just 50 MHz clock input clock, //Reset signal input reset, //PUSH operation control signal input push, //POP operation control signal input pop, //SWAP operation control signal input swap, //UPDATE operation control signal input write, //Value to write input [31:0] value, //Top element output [31:0] top, //Second element from stack top output [31:0] next, //Total elements count output [5:0] count, //Stack overflow error output error ); //Stack memory for 32 words reg [31:0] memory [0:31]; //Stack pointer on top element, indexing from 0 reg [5:0] pointer = 0; //First element by default is 0 initial memory[0] = 0; //Top stack element assign top = memory[pointer]; //Second element if such exists, 0 otherwise assign next = pointer == 0 ? 0 : memory[pointer - 1]; //Stack elements count assign count = pointer[4:0] + 1; //Stack overflow signal assign error = pointer[5]; always @(posedge clock) begin //Reseting if (reset) begin memory[0] &lt;= 0; pointer &lt;= 0; end //Remove one element form stack if (pop) pointer &lt;= pointer - 1; //Swaps top and next elements if (swap) begin memory[pointer] &lt;= memory[pointer - 1]; memory[pointer - 1] &lt;= memory[pointer]; end //Update top element if (write) memory[pointer - pop] &lt;= value; //Push new zero element on top if (push) begin pointer &lt;= pointer + 1; //Here pointer is still not updated, so +1 memory[pointer + 1] &lt;= 0; end end endmodule</code> </pre> <br></div></div><br>  إنها مجرد كومة عادية.  إذا تم دفع قيمة جديدة إليه ، فإنه يزيد المؤشر ويضع هذه القيمة في أعلى المكدس.  إذا ظهرت قيمة من المكدس ، فإنه يقلل المؤشر ويحدث العنصر العلوي. <br><br><img src="https://habrastorage.org/webt/78/ld/r1/78ldr1cqr4k5oa8-si_25tpxy5o.png"><br><br>  من أجل الراحة ، أضفنا زر إعادة تعيين ، من أجل الحصول على فرصة لإعادة تشغيل برنامجنا أثناء التنفيذ.  أيضا ، لتصحيح الأخطاء تمت إضافة فرصة لالتقاط خطأ تجاوز سعة المكدس. <br><br><h2 style=";text-align:right;direction:rtl">  العرض </h2><br>  في هذه الوحدة ، قمنا بتنفيذ جميع وظائف الشاشة.  إنه قادر على إظهار نتائج حساباتنا ديناميكيًا وكذلك قيم الإدخال. <br><br><img src="https://habrastorage.org/webt/2a/br/rl/2abrrlowazjts_uygpqxcyrrlno.png"><br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">هنا هو رمز العرض</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">module display_bcd ( //Just 50 MHz clock input clock, //Switching hexademical and decimal representations input show_in_hex, //Asserted if something is going wrong, displaing error message input error, //Value to be displayed in binary format input [31:0] value, //Segments of display output [7:0] control, //LEDs of one segment output [7:0] leds ); // ###0### // # # // # # // 5 1 // # # // # # // ###6### // # # // # # // 4 2 // # # ### // # # #7# // ###3### ### //All representation of used symbols parameter D_0 = 8'b00111111; parameter D_1 = 8'b00000110; parameter D_2 = 8'b01011011; parameter D_3 = 8'b01001111; parameter D_4 = 8'b01100110; parameter D_5 = 8'b01101101; parameter D_6 = 8'b01111101; parameter D_7 = 8'b00000111; parameter D_8 = 8'b01111111; parameter D_9 = 8'b01101111; parameter D_DOT = 8'b10000000; parameter D_A = 8'b01110111; parameter D_B = 8'b01111100; parameter D_C = 8'b01011000; parameter D_D = 8'b01011110; parameter D_E = 8'b01111001; parameter D_F = 8'b01110001; parameter D_R = 8'b01010000; parameter D_O = 8'b01011100; parameter D_MINUS = 8'b01000000; parameter D_EMPTY = 8'b00000000; parameter D_E_CODE = 14; parameter D_R_CODE = 16; parameter D_O_CODE = 17; parameter D_MINUS_CODE = 18; parameter D_EMPTY_CODE = 31; //Delay counter, delaying 8192 clock cycles ~ 0.16 ms reg [12:0] counter = 0; //Saved Binary-Coded Decimal reg [31:0] r_bcd; //Number of segment that is active on current iteration reg [2:0] ctrl = 0; //Current digit shown on the current segment reg [4:0] digit; //Asserted for 1 cycle when conversion to Binary-Coded Decimal is done wire converted; //Intermediate Binary-Coded decimal value wire [31:0] bcd; //Decoded number digits wire [31:0] digits; //Number sign wire sign; //Digits from unsigned numbers wire [31:0] unsigned_number; bcd_convert #(32, 8) bcd_convert( .i_Clock(clock), .i_Binary(unsigned_number), .i_Start(1'b1), .o_BCD(bcd), .o_DV(converted)); //Get number sign assign sign = value[31]; //Get unsigned number assign unsigned_number = sign ? -value : value; //Switching final number representation assign digits = show_in_hex ? unsigned_number : r_bcd; //Constolling segments assign control = ~(1 &lt;&lt; ctrl); reg [7:0] r_leds; //Controlling LEDs assign leds = ~r_leds; always @(posedge clock) begin case (digit) 0: r_leds &lt;= D_0; 1: r_leds &lt;= D_1; 2: r_leds &lt;= D_2; 3: r_leds &lt;= D_3; 4: r_leds &lt;= D_4; 5: r_leds &lt;= D_5; 6: r_leds &lt;= D_6; 7: r_leds &lt;= D_7; 8: r_leds &lt;= D_8; 9: r_leds &lt;= D_9; 10: r_leds &lt;= D_A; 11: r_leds &lt;= D_B; 12: r_leds &lt;= D_C; 13: r_leds &lt;= D_D; 14: r_leds &lt;= D_E; 15: r_leds &lt;= D_F; 16: r_leds &lt;= D_R; 17: r_leds &lt;= D_O; 18: r_leds &lt;= D_MINUS; default: r_leds &lt;= D_EMPTY; endcase if (error) //Display error message case(ctrl) 0: digit &lt;= D_R_CODE; 1: digit &lt;= D_O_CODE; 2: digit &lt;= D_R_CODE; 3: digit &lt;= D_R_CODE; 4: digit &lt;= D_E_CODE; 5: digit &lt;= D_EMPTY_CODE; 6: digit &lt;= D_EMPTY_CODE; 7: digit &lt;= D_EMPTY_CODE; endcase else //Select current digit case(ctrl) 0: digit &lt;= digits[3:0]; 1: digit &lt;= digits[31:4] ? digits[7:4] : D_EMPTY_CODE; 2: digit &lt;= digits[31:8] ? digits[11:8] : D_EMPTY_CODE; 3: digit &lt;= digits[31:12] ? digits[15:12] : D_EMPTY_CODE; 4: digit &lt;= digits[31:16] ? digits[19:16] : D_EMPTY_CODE; 5: digit &lt;= digits[31:20] ? digits[23:20] : D_EMPTY_CODE; 6: digit &lt;= digits[31:24] ? digits[27:24] : D_EMPTY_CODE; 7: digit &lt;= sign ? D_MINUS_CODE : (digits[31:28] ? digits[31:28] : D_EMPTY_CODE); endcase //Increase current delay counter &lt;= counter + 1; //Delay is done, increase segment number if (counter == 13'b1000000000000) ctrl &lt;= ctrl + 1; //Save converted Binary-Coded Decimal if (converted) r_bcd &lt;= bcd; end endmodule</code> </pre><br></div></div><br>  يحتوي Cyclone IV على ثماني شاشات عرض من ثمانية أجزاء.  يتم التحكم فيها بواسطة 16 دبابيس.  تتحكم ثماني دبابيس في أجزاء في كل شاشة عرض (لنطلق عليها اسم LED) وثمانية دبابيس أخرى تتحكم في أي شاشة ستكون نشطة (فقط اتصل بها بالتحكم).  على سبيل المثال ، إذا احتجنا إلى إظهار الرقم 5 على الشاشة الثالثة ، فيجب أن يكون عنصر التحكم 00000100 وأن يكون LED 01101101 (وفقًا للمخطط في الرمز).  لعرض عدة أرقام مختلفة على شاشات عرض مختلفة ، نحتاج إلى إضاءة كل شاشة بشكل دوري.  لذلك ، كل 8192 دورة ساعة ، نتحرك يسارًا منطقيًا بمقدار 1 بت من ناتج التحكم الخاص بنا ، والذي يساوي مبدئيًا 00000001. عندما نقوم بتحريكه ، نغير الرقم الذي سيتم عرضه حاليًا.  يحدث ذلك بسرعة كبيرة ، بحيث لا يمكن لعيننا رؤية التغييرات ، وبالتالي ، يمكننا إظهار أرقام مختلفة في كل شاشة. <br><br><img src="https://habrastorage.org/webt/ig/kj/7r/igkj7rrnyqmnsbhlovybm1nilmq.png"><br><br>  بينما ننتقل إلى هذا الرقم الثنائي للوحدة النمطية ، نحتاج إلى تمثيله بطريقة أو بأخرى كأرقام منفصلة.  لهذا الغرض ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وجدنا</a> وحدة نمطية تستخدمها ، باستخدام خوارزمية dabble مزدوجة.  يأخذ كمدخل رقمنا الثنائي ويعيده على شكل عشري مشفر ثنائي (4 بت لكل رقم). <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">هنا هو رمز لها</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">module bcd_convert #(parameter INPUT_WIDTH, parameter DECIMAL_DIGITS) ( input i_Clock, input [INPUT_WIDTH-1:0] i_Binary, input i_Start, // output [DECIMAL_DIGITS*4-1:0] o_BCD, output o_DV ); parameter s_IDLE = 3'b000; parameter s_SHIFT = 3'b001; parameter s_CHECK_SHIFT_INDEX = 3'b010; parameter s_ADD = 3'b011; parameter s_CHECK_DIGIT_INDEX = 3'b100; parameter s_BCD_DONE = 3'b101; reg [2:0] r_SM_Main = s_IDLE; // The vector that contains the output BCD reg [DECIMAL_DIGITS*4-1:0] r_BCD = 0; // The vector that contains the input binary value being shifted. reg [INPUT_WIDTH-1:0] r_Binary = 0; // Keeps track of which Decimal Digit we are indexing reg [DECIMAL_DIGITS-1:0] r_Digit_Index = 0; // Keeps track of which loop iteration we are on. // Number of loops performed = INPUT_WIDTH reg [7:0] r_Loop_Count = 0; wire [3:0] w_BCD_Digit; reg r_DV = 1'b0; always @(posedge i_Clock) begin case (r_SM_Main) // Stay in this state until i_Start comes along s_IDLE : begin r_DV &lt;= 1'b0; if (i_Start == 1'b1) begin r_Binary &lt;= i_Binary; r_SM_Main &lt;= s_SHIFT; r_BCD &lt;= 0; end else r_SM_Main &lt;= s_IDLE; end // Always shift the BCD Vector until we have shifted all bits through // Shift the most significant bit of r_Binary into r_BCD lowest bit. s_SHIFT : begin r_BCD &lt;= r_BCD &lt;&lt; 1; r_BCD[0] &lt;= r_Binary[INPUT_WIDTH-1]; r_Binary &lt;= r_Binary &lt;&lt; 1; r_SM_Main &lt;= s_CHECK_SHIFT_INDEX; end // Check if we are done with shifting in r_Binary vector s_CHECK_SHIFT_INDEX : begin if (r_Loop_Count == INPUT_WIDTH-1) begin r_Loop_Count &lt;= 0; r_SM_Main &lt;= s_BCD_DONE; end else begin r_Loop_Count &lt;= r_Loop_Count + 1; r_SM_Main &lt;= s_ADD; end end // Break down each BCD Digit individually. Check them one-by-one to // see if they are greater than 4. If they are, increment by 3. // Put the result back into r_BCD Vector. s_ADD : begin if (w_BCD_Digit &gt; 4) begin r_BCD[(r_Digit_Index*4)+:4] &lt;= w_BCD_Digit + 3; end r_SM_Main &lt;= s_CHECK_DIGIT_INDEX; end // Check if we are done incrementing all of the BCD Digits s_CHECK_DIGIT_INDEX : begin if (r_Digit_Index == DECIMAL_DIGITS-1) begin r_Digit_Index &lt;= 0; r_SM_Main &lt;= s_SHIFT; end else begin r_Digit_Index &lt;= r_Digit_Index + 1; r_SM_Main &lt;= s_ADD; end end s_BCD_DONE : begin r_DV &lt;= 1'b1; r_SM_Main &lt;= s_IDLE; end default : r_SM_Main &lt;= s_IDLE; endcase end // always @ (posedge i_Clock) assign w_BCD_Digit = r_BCD[r_Digit_Index*4 +: 4]; assign o_BCD = r_BCD; assign o_DV = r_DV; endmodule // Binary_to_BCD</code> </pre> <br></div></div><br>  تعمل هذه الوحدة مع خوارزمية مثيرة للاهتمام للغاية.  ينقل كل البتات في الرقم إلى اليسار واحدًا تلو الآخر ، وإذا كانت أول 4 بتات أكبر من 4 بتدوينًا عشريًا ، فإنها تضيف العلامة العشرية 3 إليها. <br><br><img src="https://habrastorage.org/webt/hu/so/xu/husoxuhrlym4_ug5oydgc6dxvhs.png"><br><br><h2 style=";text-align:right;direction:rtl">  لوحة </h2><br>  تعمل هذه الوحدة مع اللوحة.  يقرأ القيمة من لوحة المفاتيح ويمررها إلى الوحدة الرئيسية.  لدينا حالتان من لوحة المفاتيح.  يمكن تبديلها بالضغط على أحد الأزرار الموجودة في fpga. <br><br>  تبدو لوحة المفاتيح الرئيسية كما يلي: <br><br><img src="https://habrastorage.org/webt/wa/js/7g/wajs7gjogc7lsvrgraritwe1sdq.png"><br><br>  والبديل من هذا القبيل: <br><br><img src="https://habrastorage.org/webt/js/yv/rx/jsyvrx09ssqm7-sorcbrglxovj4.png"><br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">كود numpad</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">module numpad ( //Just 50 MHz clock input clock, //Alternative keyboard input alt_key, //Alternative keyboard indicator output alt_led, //Numpad rows input [3:0] rows, //Numpad columns output [3:0] columns, //State change description [5:5] - is_changed, [4:4] - keyboard, [3:0] - button output [5:0] value ); // col 0 col 1 col 2 col 3 // // ############################# // # # # # # // # 1(0) # 2(4) # 3(8) # A(12)# row 0 // # # # # # // ############################# // # # # # # // # 4(1) # 5(5) # 6(9) # B(13)# row 1 // # # # # # // ############################# // # # # # # // # 7(2) # 8(6) # 9(10)# C(14)# row 2 // # # # # # // ############################# // # # # # # // # 0(3) # F(7) # E(11)# D(15)# row 3 // # # # # # // ############################# parameter BTN_EMPTY = 6'b000000; //Previous pressed button reg [5:0] prev = 0; //Current pressed button reg [5:0] cur = 0; //Current column number reg [1:0] col = 0; //Counter for delay reg [8:0] counter = 0; //Rows pressed flags reg [3:0] pressed = 0; //Is alternative keyboard reg is_alt = 0; //Alt key on prev clock cycle reg prev_alt_key = 0; //Controlling column assign columns = ~(1 &lt;&lt; col); assign alt_led = ~is_alt; always @(posedge clock) begin //Increase counter counter &lt;= counter + 1; //Evaluating alternative keyboard signal if (value != BTN_EMPTY) is_alt &lt;= 0; else is_alt &lt;= (alt_key == 1 &amp;&amp; prev_alt_key == 0) ? ~is_alt : is_alt; prev_alt_key &lt;= alt_key; if (counter == 9'b1111111111) begin //Evaluating current button case(~rows) 4'b0001: begin pressed[col] &lt;= 1; cur &lt;= {1'b1, ~is_alt, col, 2'b00}; end 4'b0010: begin pressed[col] &lt;= 1; cur &lt;= {1'b1, ~is_alt, col, 2'b01}; end 4'b0100: begin pressed[col] &lt;= 1; cur &lt;= {1'b1, ~is_alt, col, 2'b10}; end 4'b1000: begin pressed[col] &lt;= 1; cur &lt;= {1'b1, ~is_alt, col, 2'b11}; end default: begin pressed[col] &lt;= 0; cur &lt;= pressed ? cur : BTN_EMPTY; end endcase end //increase column number when counter is 9'011111111, using different edges of counter[8] to let counter pass through zero, to assert wire value if need if (counter == 9'b011111111) begin //Saving previous button every 4 iterations if (&amp;col) prev &lt;= cur; col &lt;= col + 1; end end //Evaluating state change //Comparing current and previous states without keyboard bit assign value = (counter == 9'b000000000 &amp;&amp; col == 2'b11 &amp;&amp; {prev[5], prev[3:0]} != {cur[5], cur[3:0]}) ? cur : BTN_EMPTY; endmodule</code> </pre><br></div></div><br>  لذا ، فإن اللوحة الرقمية عبارة عن مخطط يحتوي على 16 زرًا (4 صفوف و 4 أعمدة).  للحصول على رقم الزر الذي تم الضغط عليه ، نحتاج إلى 4 مخرجات (فليكن أعمدة) و 4 مدخلات (صفوف).  نقوم بتمرير الجهد لكل عمود بشكل دوري ، وإذا تم الضغط على الزر ، يتم إغلاق الدائرة وتحقق صف معين كمدخل.  الجمع بين رقم العمود وعدد الصف يحدد زرنا بشكل فريد. <br><br><img src="https://habrastorage.org/webt/9u/oq/i8/9uoqi8mnzmhqqfff2w3-4vd5kra.png"><br><br>  إذا استخدمنا لوحة المفاتيح الرئيسية في المثال أعلاه ، فسوف نحصل على الرقم 5 كمدخل. <br><br><h2 style=";text-align:right;direction:rtl">  الوحدة الرئيسية </h2><br>  تربط الوحدة الرئيسية جميع الأجزاء معًا وتقوم بإجراء الحسابات. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">الوحدة الرئيسية هنا</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">module main( //Just 50 MHz clock input clock, //Reset signal input reset, //Representation switch input show_in_hex, //Show stack elements count switch input show_count, //Button, switches to operations keyboard input alt_numpad_key, //Alternative keyboard indicator output alt_numpad_led, //Numpad rows and columns input [3:0] numpad_rows, output [3:0] numpad_columns, //Display and display control output [7:0] display_leds, output [7:0] display_control ); // 1 2 3 C // 4 5 6 PUSH // 7 8 9 POP // 0 +- CE SWAP parameter BTN_0 = 6'b110011; parameter BTN_1 = 6'b110000; parameter BTN_2 = 6'b110100; parameter BTN_3 = 6'b111000; parameter BTN_4 = 6'b110001; parameter BTN_5 = 6'b110101; parameter BTN_6 = 6'b111001; parameter BTN_7 = 6'b110010; parameter BTN_8 = 6'b110110; parameter BTN_9 = 6'b111010; parameter BTN_CLEAR_DIGIT = 6'b111100; parameter BTN_PUSH = 6'b111101; parameter BTN_POP = 6'b111110; parameter BTN_SWAP = 6'b111111; parameter BTN_CLEAR_NUMBER = 6'b111011; parameter BTN_UNARY_MINUS = 6'b110111; // + - * / // sqr cbe inc dec parameter BTN_ADDITION = 6'b100000; parameter BTN_SUBTRACTION = 6'b100100; parameter BTN_MULTIPLICATION = 6'b101000; parameter BTN_DIVISION = 6'b101100; parameter BTN_SQUARE = 6'b100001; parameter BTN_CUBE = 6'b100101; parameter BTN_INCREMENT = 6'b101001; parameter BTN_DECREMENT = 6'b101101; //Numpad state wire [5:0] pressed; //Stack elements count wire [5:0] count; //First and second stack elements wire [31:0] top, next; wire stack_error; //Evaluated new value reg [31:0] new_value; //Stack control signals reg write, push, pop, swap; reg arithmetic_error = 0; numpad numpad( .clock (clock), .alt_key (~alt_numpad_key), .alt_led (alt_numpad_led), .rows (numpad_rows), .columns (numpad_columns), .value (pressed) ); stack stack( .clock (clock), .reset (~reset), .push (push), .pop (pop), .swap (swap), .write (write), .value (new_value), .top (top), .next (next), .count (count), .error (stack_error) ); display_bcd display( .clock (clock), .error (stack_error || arithmetic_error), .show_in_hex (show_in_hex), .value (show_count ? count : top), .control (display_control), .leds (display_leds) ); // Division result wire [31:0] res; assign res = ((next[31] ? -next : next) / (top[31] ? -top : top)); always @(posedge clock) begin //Reseting arithmetic error if (~reset) arithmetic_error &lt;= 0; case (pressed) BTN_0: begin write &lt;= 1; new_value &lt;= top * 10; end BTN_1: begin write &lt;= 1; new_value &lt;= top * 10 + (top[31] ? -1 : 1); end BTN_2: begin write &lt;= 1; new_value &lt;= top * 10 + (top[31] ? -2 : 2); end BTN_3: begin write &lt;= 1; new_value &lt;= top * 10 + (top[31] ? -3 : 3); end BTN_4: begin write &lt;= 1; new_value &lt;= top * 10 + (top[31] ? -4 : 4); end BTN_5: begin write &lt;= 1; new_value &lt;= top * 10 + (top[31] ? -5 : 5); end BTN_6: begin write &lt;= 1; new_value &lt;= top * 10 + (top[31] ? -6 : 6); end BTN_7: begin write &lt;= 1; new_value &lt;= top * 10 + (top[31] ? -7 : 7); end BTN_8: begin write &lt;= 1; new_value &lt;= top * 10 + (top[31] ? -8 : 8); end BTN_9: begin write &lt;= 1; new_value &lt;= top * 10 + (top[31] ? -9 : 9); end BTN_CLEAR_DIGIT: begin write &lt;= 1; new_value &lt;= top / 10; end BTN_CLEAR_NUMBER: begin write &lt;= 1; new_value &lt;= 0; end BTN_PUSH: begin push &lt;= 1; end BTN_POP: begin pop &lt;= 1; end BTN_SWAP: begin swap &lt;= 1; end BTN_UNARY_MINUS: begin write &lt;= 1; new_value &lt;= -top; end BTN_ADDITION: begin pop &lt;= 1; write &lt;= 1; new_value &lt;= next + top; end BTN_SUBTRACTION: begin pop &lt;= 1; write &lt;= 1; new_value &lt;= next - top; end BTN_MULTIPLICATION: begin pop &lt;= 1; write &lt;= 1; new_value &lt;= next * top; end BTN_DIVISION: begin pop &lt;= 1; write &lt;= 1; new_value &lt;= (next[31] ^ top[31] ? -res : res); arithmetic_error &lt;= ~(|top); end BTN_SQUARE: begin write &lt;= 1; new_value &lt;= top * top; end BTN_CUBE: begin write &lt;= 1; new_value &lt;= top * top * top; end BTN_INCREMENT: begin write &lt;= 1; new_value &lt;= top + 1; end BTN_DECREMENT: begin write &lt;= 1; new_value &lt;= top - 1; end default: // Nothing usefull is pressed begin write &lt;= 0; push &lt;= 0; pop &lt;= 0; swap &lt;= 0; end endcase end endmodule</code> </pre> <br></div></div><br>  تحتوي الكتلة "دائما" على بيان الحالة الذي يختار العملية اعتمادًا على زر اللوحة.  إذا تم الضغط على زر مع الرقم ، فإن هذا الرقم ينتقل إلى الجزء العلوي من المكدس.  إذا احتجنا إلى إدخال الرقم الذي يحتوي على أكثر من رقم ، فسيتم ضرب الرقم العلوي في المكدس في 10 وتنتقل هذه القيمة المضروبة إلى أعلى المكدس.  إذا تم الضغط على الزر الذي يحتوي على عملية ، يتم تطبيق هذه العملية على أول رقمين في المكدس. <br><br><img src="https://habrastorage.org/webt/95/kg/d0/95kgd0wwrkcwswl6m7cnpdu8xui.png"><br><br>  أثناء الاختبار ، وجدنا شيئًا مثيرًا للاهتمام حول الانقسام في Verilog.  لسبب غريب إذا حاولنا تقسيم رقمين سالبين ، ستؤدي العملية إلى صفر نتيجة لذلك.  لذلك ، من أجل إصلاحه ، كان علينا إضافة فرع لمعالجة هذه الحالة بشكل صريح. <br><br><h2 style=";text-align:right;direction:rtl">  الخلاصة </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هذا</a> هو الفيديو الذي يوضح عمل الآلة الحاسبة.  أيضا ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا</a> هو جوهر مشروعنا. <br><br>  زادت دراسة Verilog بشكل كبير من فهمنا لهندسة الكمبيوتر.  إلى جانب ذلك ، ساعدنا العمل في فريق على تطوير المهارات الأساسية الأساسية للعمل الجماعي. <br><br>  المؤلف: Fedoseev Kirill، Yuloskov Artem. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar429888/">https://habr.com/ru/post/ar429888/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar429876/index.html">تغلب الباحثون على أقوى حاصرات الإعلانات ، وشكل الحرب قادم</a></li>
<li><a href="../ar429878/index.html">لماذا مع نمو الشركة ، وجد المطورون الذين كانوا في الطليعة أنفسهم "مبالغ فيه"</a></li>
<li><a href="../ar429880/index.html">Pix4D - من الصور إلى القياسات</a></li>
<li><a href="../ar429882/index.html">التحكم في مصابيح LED RGB عبر Cypress UDB Microcontrollers PSoC</a></li>
<li><a href="../ar429884/index.html">مؤتمر PROSTOR 2018: أسئلة وأجوبة حول مستقبل التخزين</a></li>
<li><a href="../ar429890/index.html">ندوة مفتوحة على شبكة الإنترنت "شبكات الخصومة التوليدية"</a></li>
<li><a href="../ar429892/index.html">xonsh - python كبديل عن غلاف</a></li>
<li><a href="../ar429894/index.html">استخدام عين السمكة على راسبيري باي 3 مع روس - الجزء 2</a></li>
<li><a href="../ar429898/index.html">DMS (نظام إدارة الوكلاء) - تنفيذ نظم المعلومات البيئية لإدارة شبكات الوكلاء</a></li>
<li><a href="../ar429902/index.html">ترتيب الصفحة في عصر الويب 2.0 - الجزء الأول</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>