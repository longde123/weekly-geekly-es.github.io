<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤˜ğŸ¾ ğŸ¥¨ ğŸ¥ Evolusi rantai pasokan, atau refleksi pada Docker, deb, toples dan banyak lagi ğŸ¡ ğŸ¤¶ğŸ¼ ğŸ¥˜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Suatu hari, saya memutuskan untuk menulis artikel tentang pengiriman paket buruh pelabuhan dan deb dalam bentuk wadah, tetapi ketika saya mulai, untuk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Evolusi rantai pasokan, atau refleksi pada Docker, deb, toples dan banyak lagi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/srg/blog/444102/"><img src="https://habrastorage.org/webt/qw/2q/om/qw2qompuzuhjjxjf2cxycsx4q2u.jpeg"><br><br>  Suatu hari, saya memutuskan untuk menulis artikel tentang pengiriman paket buruh pelabuhan dan deb dalam bentuk wadah, tetapi ketika saya mulai, untuk beberapa alasan saya menderita di hari-hari yang jauh dari komputer pribadi pertama dan bahkan kalkulator.  Secara umum, alih-alih perbandingan kering antara buruh pelabuhan dan deb, ini adalah pemikiran tentang evolusi, yang saya sajikan di pengadilan Anda. <br><a name="habracut"></a><br>  Produk apa pun, apa pun itu, entah bagaimana harus sampai ke server produk, harus dikonfigurasi dan diluncurkan.  Artikel ini akan membahas tentang ini. <br><br>  Saya akan merefleksikan dalam konteks sejarah, "apa yang saya lihat - bahwa saya bernyanyi", apa yang saya lihat ketika saya mulai menulis kode dan apa yang saya amati sekarang, apa yang kita sendiri gunakan saat ini dan mengapa.  Artikel itu tidak berpura-pura menjadi studi penuh, beberapa poin hilang, ini adalah pandangan pribadi saya tentang apa yang dulu dan apa yang sekarang. <br><br>  Jadi, di masa lalu yang indah ... metode pengiriman paling awal yang saya temukan adalah dengan kaset.  Saya punya komputer BK-0010.01 ... <br><br><h2>  Zaman Kalkulator </h2><br>  Tidak, ada titik yang lebih awal, ada juga kalkulator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MK-61</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MK-52</a> . <br><br><img src="https://habrastorage.org/webt/ve/iz/aa/veizaapgi5rwfkezhjkcyw4qow4.jpeg" align="left">  Jadi, ketika saya memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MK-61</a> , cara untuk mentransfer program adalah dengan menggunakan selembar kertas biasa dalam kotak di mana program dicatat, yang, jika perlu, ditulis secara manual ke kalkulator.  Jika Anda ingin bermain (ya, bahkan ada permainan di kalkulator kuno ini), Anda duduk dan masukkan program dalam kalkulator.  Tentu saja, ketika kalkulator dimatikan, program dilupakan.  Selain kode kalkulator yang ditulis di atas kertas secara pribadi, program-program tersebut diterbitkan di majalah Radio dan Teknik Pemuda, serta dalam buku-buku pada waktu itu. <br><br>  Modifikasi berikutnya adalah kalkulator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MK-52</a> , sudah muncul semacam penyimpanan data yang tidak mudah menguap.  Sekarang game atau program tidak harus didorong secara manual, tetapi, setelah melakukan beberapa lintasan ajaib dengan tombol, itu dimuat sendiri. <br><br>  Volume program terbesar di kalkulator adalah 105 langkah, dan ukuran memori permanen di MK-52 adalah 512 langkah. <br><br>  Omong-omong, jika ada penggemar kalkulator ini yang membaca artikel ini - dalam proses penulisan artikel, saya menemukan emulator kalkulator untuk android dan program untuk itu.  Maju ke masa lalu! <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Emulator MK-61 untuk Android</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Katalog program untuk MK-61</a> </li></ul><br><blockquote> <b>Penyimpangan kecil tentang MK-52</b> <i>(dari Wikipedia)</i> <br><br>  MK-52 terbang ke angkasa menggunakan pesawat ruang angkasa Soyuz TM-7.  Itu seharusnya digunakan untuk menghitung lintasan pendaratan jika komputer on-board gagal. <br><br>  MK-52 dengan unit ekspansi memori "Electronics-Astro" sejak 1988 dipasok ke kapal Angkatan Laut sebagai bagian dari kit komputasi navigasi. </blockquote><br><br><h2>  Komputer pribadi pertama </h2><br><br><img src="https://habrastorage.org/webt/vg/5-/fj/vg5-fjiyjylbwuc3b7ldjh-dwgi.jpeg" align="left">  Mari kita kembali ke zaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BK-0010</a> .  Jelas bahwa ada lebih banyak memori di sana, dan tidak ada lagi pilihan untuk mendorong kode dari selembar kertas (walaupun pada awalnya saya melakukan hal itu, karena tidak ada media lain).  Sarana utama penyimpanan dan pengiriman perangkat lunak adalah kaset audio untuk tape recorder. <br><br><br clear="all"><br clear="all"><img src="https://habrastorage.org/webt/un/dx/vi/undxvicotyb3ghussyo4l08ykry.jpeg" align="right">  Penyimpanan pada kaset biasanya dalam bentuk satu atau dua file biner, semua yang lain ada di dalamnya.  Keandalan sangat rendah, saya harus menyimpan 2-3 salinan program.  Waktu buka juga tidak menyenangkan, penggemar bereksperimen dengan pengkodean frekuensi yang berbeda untuk mengatasi kekurangan ini.  Pada saat itu, saya sendiri belum terlibat dalam pengembangan profesional perangkat lunak (terlepas dari program dasar sederhana), oleh karena itu, sayangnya, saya tidak akan memberi tahu Anda secara terperinci bagaimana semuanya diatur di dalam.  Fakta hanya memiliki RAM di komputer untuk sebagian besar menentukan kesederhanaan skema penyimpanan data. <br><br><h2>  Munculnya media penyimpanan yang besar dan andal </h2><br>  Kemudian, floppy disk muncul, proses penyalinan disederhanakan, dan keandalan tumbuh. <br>  Tetapi situasinya berubah secara dramatis hanya ketika penyimpanan lokal yang cukup besar muncul dalam bentuk HDD. <br><br>  Jenis pengiriman berubah secara mendasar: muncul penginstal yang mengontrol proses konfigurasi sistem, serta pembersihan setelah penghapusan, karena program tidak hanya dibaca ke dalam memori, tetapi sudah disalin ke penyimpanan lokal, yang darinya Anda harus dapat menghapus dan tidak perlu jika perlu. <br><br>  Pada saat yang sama, kompleksitas perangkat lunak yang disediakan meningkat. <br>  Jumlah file dalam pengiriman meningkat dari unit menjadi ratusan dan ribuan, konflik versi perpustakaan dan kesenangan lainnya dimulai ketika program yang berbeda menggunakan data yang sama. <br><br><img src="https://habrastorage.org/webt/dh/rd/-z/dhrd-zolamvx8yfrrsodu5ylibg.jpeg" align="left">  Pada masa itu, keberadaan Linux belum terbuka untuk saya, saya tinggal di dunia MS DOS dan, kemudian, Windows, dan menulis di Borland Pascal dan Delphi, terkadang melirik ke arah C ++.  Untuk memasok produk pada masa itu, banyak yang menggunakan InstallShield <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ru.wikipedia.org/wiki/InstallShield</a> , yang cukup berhasil menyelesaikan semua tugas penggunaan dan konfigurasi perangkat lunak. <br><br><br clear="all"><br clear="all"><h2>  Era Internet </h2><br>  Secara bertahap, kompleksitas sistem perangkat lunak menjadi semakin rumit, dari aplikasi monolith dan desktop ada transisi ke sistem terdistribusi, thin client dan layanan mikro.  Sekarang Anda perlu mengkonfigurasi tidak hanya satu program, tetapi set mereka, dan agar mereka semua menjadi teman. <br><br>  Konsepnya telah sepenuhnya berubah, Internet telah datang, era layanan cloud telah datang.  Sejauh ini, hanya ditafsirkan pada tahap awal, dalam bentuk situs, tidak ada yang memimpikan layanan.  tetapi ini adalah titik balik dalam industri pengembangan dan pengiriman aplikasi yang sebenarnya. <br><br>  Bagi saya sendiri, saya mencatat bahwa pada saat ini ada perubahan dalam generasi pengembang (atau hanya di lingkungan saya), dan saya merasa bahwa semua metode pengiriman lama yang baik dilupakan pada satu saat dan semuanya dimulai dari awal: mereka mulai membuat seluruh pengiriman dengan skrip setinggi lutut dan dengan bangga menyebutnya "Pengiriman berkelanjutan".  Bahkan, periode kekacauan dimulai, ketika yang lama dilupakan dan tidak digunakan, tetapi tidak ada yang baru. <br><br>  Saya ingat saat-saat ketika di perusahaan kami, di mana saya bekerja saat itu (saya tidak akan menelepon), alih-alih membangun melalui semut (maven belum populer atau tidak sama sekali), orang-orang hanya mengumpulkan stoples dalam IDE dan berkomitmen. dia di svn.  Dengan demikian, penyebarannya adalah untuk mendapatkan file dari SVN dan menyalinnya melalui SSH ke mesin yang diinginkan.  Sangat sederhana dan canggung. <br><br>  Pada saat yang sama, pengiriman situs sederhana ke PHP dibuat cukup primitif dengan hanya menyalin file yang diperbaiki melalui FTP ke mesin target.  Kadang-kadang tidak ada hal seperti itu - kode diedit langsung di server produk, dan itu sangat menarik jika ada cadangan di suatu tempat. <br><br><br clear="all"><h4>  Paket RPM dan DEB </h4><br><img src="https://habrastorage.org/webt/2x/05/di/2x05didl55rli_ripn5rwowwtju.png" align="right">  Di sisi lain, dengan perkembangan Internet, sistem mirip UNIX mulai mendapatkan popularitas yang semakin meningkat, khususnya, pada saat itulah saya menemukan RedHat Linux 6 untuk saya sendiri, sekitar tahun 2000.  Secara alami, ada alat tertentu untuk pengiriman perangkat lunak di sana, menurut Wikipedia, RPM sebagai manajer paket utama sudah muncul pada tahun 1995, dalam versi RedHat Linux 2.0.  Dan sejak saat itu hingga sekarang, sistem telah dikirim dalam bentuk paket RPM dan cukup berhasil ada dan dikembangkan. <br><br>  Distribusi keluarga Debian juga melakukan hal serupa dan mengimplementasikan pengiriman dalam bentuk paket deb, yang juga tidak berubah hingga hari ini. <br><br>  Manajer paket memungkinkan Anda untuk mengirimkan sendiri produk perangkat lunak, mengkonfigurasinya selama proses instalasi, mengelola dependensi antara paket yang berbeda, menghapus produk, dan membersihkan kelebihan selama penghapusan instalasi.  Yaitu  sebagian besar, inilah yang diperlukan, itulah sebabnya mereka bertahan beberapa dekade dengan sedikit atau tanpa perubahan. <br><br>  Awan ditambahkan ke instalasi manajer paket tidak hanya dari media fisik, tetapi juga dari repositori cloud, tetapi pada dasarnya sedikit yang berubah. <br><br>  Perlu dicatat bahwa saat ini ada beberapa creep menuju menghindari deb dan beralih ke paket snap, tetapi lebih pada nanti. <br><br>  Jadi, generasi baru pengembang cloud ini, yang tidak mengenal DEB atau RPM, juga tumbuh lambat, mendapatkan pengalaman, produk menjadi lebih rumit, dan beberapa metode pengiriman yang lebih masuk akal diperlukan daripada FTP, skrip bash, dan kerajinan siswa serupa. <br>  Dan di sini Docker memasuki lokasi, semacam campuran virtualisasi, alokasi sumber daya, dan metode pengiriman.  Sekarang modis, awet muda, tetapi apakah itu diperlukan untuk semuanya?  Apakah itu obat mujarab? <br><br>  Menurut pengamatan saya, sangat sering Docker ditawarkan bukan sebagai pilihan yang masuk akal, tetapi hanya karena itu, di satu sisi, dibicarakan di masyarakat, dan mereka yang menawarkannya hanya mengetahuinya.  Di sisi lain, sebagian besar mereka diam tentang sistem pengemasan lama yang baik - mereka sedang dan sedang, mereka melakukan pekerjaan mereka dengan tenang dan tak terlihat.  Dalam situasi seperti itu, tidak ada pilihan lain - pilihannya jelas - Docker. <br><br>  Saya akan mencoba berbagi pengalaman tentang bagaimana kami menerapkan Docker, dan apa yang terjadi sebagai hasilnya. <br><br><br clear="all"><h4>  Skrip yang ditulis sendiri </h4><br>  Awalnya, ada skrip bash yang menyebarkan arsip jar ke mesin yang diperlukan.  Dikelola proses ini oleh Jenkins.  Ini berhasil, karena arsip jar itu sendiri sudah merupakan kumpulan yang berisi kelas, sumber daya, dan bahkan konfigurasi.  Jika Anda meletakkan semuanya di dalamnya secara maksimal - kemudian perluas dengan skrip - ini bukan hal yang paling sulit yang Anda butuhkan <br><br>  Tetapi skrip memiliki beberapa kelemahan: <br><br><ul><li>  skrip biasanya ditulis dengan tergesa-gesa dan karenanya sangat primitif sehingga hanya berisi satu skrip yang paling sukses.  Ini difasilitasi oleh fakta bahwa pengembang tertarik pada pengiriman cepat, dan skrip normal membutuhkan sumber daya yang layak. </li><li>  sebagai konsekuensi dari paragraf sebelumnya, skrip tidak mengandung prosedur uninstall </li><li>  tidak ada prosedur peningkatan yang ditetapkan </li><li>  ketika produk baru muncul, Anda perlu menulis skrip baru </li><li>  tidak ada dukungan ketergantungan </li></ul><br>  Tentu saja, Anda dapat menulis skrip mewah, tetapi, seperti yang saya tulis di atas, ini adalah waktu pengembangan, dan bukan yang terkecil, tetapi, seperti yang Anda tahu, selalu tidak ada cukup waktu. <br><br>  Ini semua jelas membatasi ruang lingkup metode penyebaran ini ke sistem yang paling sederhana.  Waktunya telah tiba untuk mengubah ini. <br><br><br clear="all"><h4>  Docker </h4><br><img src="https://habrastorage.org/webt/kw/he/dz/kwhedzdiytfkvockures3cqm66i.jpeg" align="left">  Pada titik tertentu, middle yang baru dipanggang mulai mendatangi kami, penuh dengan ide dan mengoceh dengan buruh pelabuhan.  Nah, bendera di tangan - lakukanlah!  Ada dua upaya.  Keduanya tidak berhasil - katakanlah demikian, karena ambisi besar, tetapi kurangnya pengalaman nyata.  Apakah perlu untuk memaksa dan menyelesaikan dengan cara apa pun?  Tidak mungkin - tim harus secara evolusioner tumbuh ke level yang diinginkan sebelum dapat menggunakan alat yang sesuai.  Selain itu, dengan menggunakan gambar-gambar yang sudah jadi dari buruh pelabuhan, kami sering menemukan fakta bahwa jaringan bekerja secara tidak benar di sana (yang, mungkin, juga terhubung dengan kelembaban buruh pelabuhan itu sendiri) atau sulit untuk memperluas wadah orang lain. <br><br>  Ketidaknyamanan apa yang kami temui? <br><br><ul><li>  Masalah jaringan dalam mode jembatan </li><li>  Sangat tidak nyaman untuk melihat log di wadah (jika mereka tidak dibawa ke mana pun secara terpisah ke sistem file dari mesin host) </li><li>  ElasticSearch yang aneh secara berkala menggantung di dalam wadah, alasannya belum ditetapkan, wadah itu resmi </li><li>  Canggung menggunakan cangkang di dalam wadah - semuanya sangat terpangkas, tidak ada alat yang dikenal </li><li>  Wadah besar untuk dikumpulkan - mahal untuk disimpan </li><li>  Karena ukuran wadah yang besar, sulit untuk mendukung beberapa versi </li><li>  Membangun lebih lama, tidak seperti metode lain (skrip atau paket deb) </li></ul><br>  Di sisi lain, apakah lebih buruk untuk menggunakan layanan Spring dalam bentuk arsip jar melalui deb yang sama?  Apakah isolasi sumber daya benar-benar diperlukan?  Apakah layak kehilangan alat yang mudah digunakan dari sistem operasi, memasukkan layanan ke dalam wadah yang sangat terpangkas? <br><br>  Seperti yang telah ditunjukkan oleh praktik, pada kenyataannya ini tidak perlu, paket deb cukup dalam 90% kasus. <br><br>  Kapan deb lama yang baik masih gagal dan kapan kita benar-benar membutuhkan buruh pelabuhan? <br><br>  Bagi kami, ini adalah penyebaran layanan dengan python.  Banyak perpustakaan yang diperlukan untuk pembelajaran mesin dan tidak tersedia dalam pengiriman standar sistem operasi (dan apa yang ada dari versi yang salah), peretasan dengan pengaturan, kebutuhan untuk versi berbeda untuk berbagai layanan yang hidup pada sistem host yang sama menyebabkan bahwa satu-satunya cara yang masuk akal untuk memasok campuran nuklir ini adalah buruh pelabuhan.  Kompleksitas merakit kontainer buruh pelabuhan ternyata lebih rendah daripada gagasan untuk mengemasnya semua dalam paket deb terpisah dengan dependensi, dan tidak ada orang waras yang akan mengambilnya. <br><br>  Poin kedua di mana Anda berencana untuk menggunakan buruh pelabuhan adalah untuk menggunakan layanan menggunakan skema penyebaran biru-hijau.  Tapi di sini saya ingin mendapatkan peningkatan kompleksitas secara bertahap: pertama, paket deb dikumpulkan, dan kemudian sebuah buruh pelabuhan dikumpulkan dari mereka. <br><br><br clear="all"><h4>  Paket snap </h4><br><img src="https://habrastorage.org/webt/tx/gf/dx/txgfdxgq-kdxvmmqc8hin30g_re.jpeg" align="left">  Kembali ke paket snap.  Mereka pertama kali secara resmi muncul di Ubuntu 16.04.  Berbeda dengan paket deb dan paket rpm biasa, snap membawa semua dependensi.  Di satu sisi, ini menghindari konflik perpustakaan, di sisi lain, itu berarti ukuran yang lebih signifikan dari paket yang dihasilkan.  Selain itu, hal yang sama dapat mempengaruhi keamanan sistem: dalam hal pengiriman cepat, semua perubahan pada perpustakaan yang disertakan harus dipantau oleh pengembang yang membuat paket.  Secara umum, tidak semuanya begitu sederhana dan kebahagiaan umum dari penggunaannya tidak datang.  Namun, bagaimanapun, ini adalah alternatif yang cukup masuk akal, jika Docker yang sama hanya digunakan sebagai alat pengemasan, dan bukan virtualisasi. <br><br><br clear="all">  Sebagai hasilnya, kami sekarang menggunakan paket deb dan buruh pelabuhan dalam kombinasi yang masuk akal, yang, mungkin, dalam beberapa kasus kami akan mengganti dengan paket snap. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444102/">https://habr.com/ru/post/id444102/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444090/index.html">Metode pengolahan data dari eksperimen fisik</a></li>
<li><a href="../id444094/index.html">Metode isolasi suara telah dikembangkan yang meredam hingga 94% kebisingan - kami memberi tahu cara kerjanya</a></li>
<li><a href="../id444096/index.html">Pembatalan teleskop WFIRST dan Rusia di orbit bulan</a></li>
<li><a href="../id444098/index.html">Pustaka asinkron untuk bekerja dengan Mikrotik API</a></li>
<li><a href="../id444100/index.html">1. Periksa Titik Memulai R80.20. Pendahuluan</a></li>
<li><a href="../id444104/index.html">Bagaimana cara memaksimalkan portofolio investasi Anda?</a></li>
<li><a href="../id444106/index.html">Kuda-kuda untuk programmer mikrokontroler</a></li>
<li><a href="../id444108/index.html">Frontend Weekly Digest (11 - 17 Mar 2019)</a></li>
<li><a href="../id444110/index.html">Serial, UART, dan Android, sebagai koneksi dengan mikrokontroler</a></li>
<li><a href="../id444112/index.html">Menghitung angka nol dari bilangan faktorial dalam sistem bilangan apa pun</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>