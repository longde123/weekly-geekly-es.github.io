<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖖🏻 🕴️ 🎒 Fehlerbehandlung in Express 🤙🏻 🙆🏻 👨🏻‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als ich anfing, mit Express zu arbeiten und herauszufinden, wie ich mit Fehlern umgehen sollte, hatte ich es schwer. Es gab das Gefühl, dass niemand d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fehlerbehandlung in Express</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/476290/">  Als ich anfing, mit Express zu arbeiten und herauszufinden, wie ich mit Fehlern umgehen sollte, hatte ich es schwer.  Es gab das Gefühl, dass niemand darüber schrieb, was ich brauchte.  Infolgedessen musste ich selbst nach Antworten auf meine Fragen suchen.  Heute möchte ich alles erzählen, was ich über die Fehlerbehandlung in Express-Anwendungen weiß.  Beginnen wir mit synchronen Fehlern. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/pt/dq/0q/ptdq0qx0qz7ob2gd1qf0xptr_me.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Synchrone Fehlerbehandlung</font> </h2><br>  Wenn Sie einen synchronen Fehler behandeln müssen, können Sie <code>throw</code> mithilfe der <code>throw</code> Anweisung <code>throw</code> solchen Fehler im Express-Request-Handler auslösen.  Bitte beachten Sie, dass Request-Handler auch als "Controller" bezeichnet werden. Ich bevorzuge jedoch die Verwendung des Begriffs "Request-Handler", da mir dies klarer erscheint. <br><br>  So sieht es aus: <br><br><pre> <code class="javascript hljs">app.post(<span class="hljs-string"><span class="hljs-string">'/testing'</span></span>, (req, res) =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Something broke! '</span></span>) })</code> </pre> <br>  Solche Fehler können mit dem Express Error Handler abgefangen werden.  Wenn Sie keinen eigenen Fehlerbehandler geschrieben haben (wir werden weiter unten darauf eingehen), behandelt Express den Fehler mit dem Standardhandler. <br><br>  Die Standard-Express-Fehlerbehandlungsroutine führt folgende Aktionen aus: <br><br><ol><li>  Legt den HTTP-Antwortstatuscode auf 500 fest. </li><li>  Sendet eine Textantwort an die Entität, die die Anforderung ausführt. </li><li>  Protokolliert eine Textantwort an die Konsole. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc0/177/d75/fc0177d75573acf04474fe8488806e74.png"></div><br>  <i><font color="#999999">Fehlermeldung in der Konsole angezeigt</font></i> <br><br><h2>  <font color="#3AC1EF">Asynchrone Fehlerbehandlung</font> </h2><br>  Um asynchrone Fehler zu behandeln, müssen Sie über das <code>next</code> Argument einen Fehler an den Express-Fehlerbehandler senden: <br><br><pre> <code class="javascript hljs">app.post(<span class="hljs-string"><span class="hljs-string">'/testing'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (req, res, next) =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Something broke again! '</span></span>)) })</code> </pre> <br>  Dies ist, was auf die Konsole gelangt, wenn dieser Fehler protokolliert wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9b/abd/8d8/b9babd8d81180f790746e847e1d3796e.png"></div><br>  <i><font color="#999999">Fehlermeldung in der Konsole angezeigt</font></i> <br><br>  Wenn Sie das Konstrukt async / await in einer Express-Anwendung verwenden, müssen Sie eine Wrapper-Funktion wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">express-async-handler verwenden</a> .  Auf diese Weise können Sie asynchronen Code ohne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Try / Catch-</a> Blöcke schreiben.  Weitere Informationen zu async / await in Express finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> asyncHandler = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express-async-handler'</span></span>) app.post(<span class="hljs-string"><span class="hljs-string">'/testing'</span></span>, asyncHandler(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (req, res, next) =&gt; {  <span class="hljs-comment"><span class="hljs-comment">//  - }))</span></span></code> </pre> <br>  Nachdem der Anforderungshandler in den <code>express-async-handler</code> , können Sie wie oben beschrieben mit der <code>throw</code> Anweisung einen Fehler <code>throw</code> .  Dieser Fehler wird an den Express-Fehlerbehandler weitergeleitet. <br><br><pre> <code class="javascript hljs">app.post(<span class="hljs-string"><span class="hljs-string">'/testing'</span></span>, asyncHandler(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (req, res, next) =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Something broke yet again! '</span></span>) }))</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/89b/505/6c0/89b5056c0c376e95a6e03cbde3fe7dd9.png"></div><br>  <i><font color="#999999">Fehlermeldung in der Konsole angezeigt</font></i> <br><br><h2>  <font color="#3AC1EF">Schreiben Sie Ihren eigenen Fehlerbehandler</font> </h2><br>  Express-Fehlerbehandlungsroutinen verwenden vier Argumente: <br><br><ol><li>  Fehler </li><li>  req </li><li>  res </li><li>  als nächstes </li></ol><br>  Sie müssen nach Zwischenhandlern und Routen platziert werden. <br><br><pre> <code class="javascript hljs">app.use(<span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>) app.get(<span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>) app.post(<span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>) app.put(<span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>) app.delete(<span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>) <span class="hljs-comment"><span class="hljs-comment">//           app.use((error, req, res, next) =&gt; { /* ... */ })</span></span></code> </pre> <br>  Wenn Sie eine eigene Fehlerbehandlungsroutine erstellen, verwendet Express die Standard-Fehlerbehandlungsroutine nicht mehr.  Um den Fehler zu behandeln, müssen Sie eine Antwort für die Front-End-Anwendung generieren, die den Endpunkt adressiert hat, an dem der Fehler aufgetreten ist.  Dies bedeutet, dass Sie Folgendes tun müssen: <br><br><ol><li>  Generieren und senden Sie einen geeigneten Antwortstatuscode. </li><li>  Bilden und senden Sie eine passende Antwort. </li></ol><br>  Welcher Statuscode im Einzelfall angemessen ist, hängt davon ab, was genau passiert ist.  Hier ist eine Liste der häufigsten Fehler, auf die Sie vorbereitet sein sollten: <br><br><ol><li>  Fehler <code>400 Bad Request</code> Fehlerhafte <code>400 Bad Request</code> .  Wird in zwei Situationen verwendet.  Erstens, wenn der Benutzer das erforderliche Feld nicht in die Anforderung aufgenommen hat (z. B. wurde das Feld mit den Kreditkarteninformationen in dem gesendeten Zahlungsformular nicht ausgefüllt).  Zweitens, wenn die Anfrage falsche Daten enthält (z. B. unterschiedliche Passwörter in das Passwortfeld und in das Passwortbestätigungsfeld eingeben). </li><li>  Fehler <code>401 Unauthorized</code> .  Dieser Antwortstatuscode wird angewendet, wenn der Benutzer falsche Anmeldeinformationen eingegeben hat (z. B. Benutzername, E-Mail-Adresse oder Kennwort). </li><li>  Fehler <code>403 Forbidden</code> .  Wird verwendet, wenn der Benutzer keinen Zugriff auf den Endpunkt hat. </li><li>  Fehler <code>404 Not Found</code> .  Es wird in Fällen verwendet, in denen der Endpunkt nicht erkannt werden kann. </li><li>  Fehler <code>500 Internal Server Error</code> .  Es wird angewendet, wenn die vom Front-End gesendete Anforderung korrekt generiert wurde, im Back-End jedoch ein Fehler aufgetreten ist. </li></ol><br>  Nachdem der entsprechende Antwortstatuscode definiert wurde, muss er mit <code>res.status</code> : <br><br><pre> <code class="javascript hljs">app.use(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> {  <span class="hljs-comment"><span class="hljs-comment">// ,         res.status(400)  res.json(/* ... */) })</span></span></code> </pre> <br>  Der Antwortstatuscode sollte der Fehlermeldung entsprechen.  Senden Sie dazu den Statuscode zusammen mit dem Fehler. <br><br>  Am einfachsten geht das mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://www.npmjs.com/package/">http-errors-</a> Paket.  Es können drei fehlerhafte Informationen gesendet werden: <br><br><ol><li>  Der Antwortstatuscode. </li><li>  Die mit dem Fehler verknüpfte Nachricht. </li><li>  Alle Daten, die gesendet werden müssen (dies ist optional). </li></ol><br>  So installieren Sie das <code>http-errors</code> : <br><br><pre> <code class="javascript hljs">npm install http-errors --save</code> </pre> <br>  So verwenden Sie dieses Paket: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createError = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http-errors'</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   throw createError(status, message, properties)</span></span></code> </pre> <br>  Betrachten Sie ein Beispiel, mit dem Sie dies alles richtig verstehen können. <br><br>  Stellen Sie sich vor, wir versuchen, einen Benutzer unter seiner E-Mail-Adresse zu finden.  Dieser Benutzer kann jedoch nicht gefunden werden.  Infolgedessen entscheiden wir uns, als Antwort auf die entsprechende Anforderung einen Fehler " <code>User not found</code> zu senden, um den Anrufer zu informieren, dass der Benutzer nicht gefunden wurde. <br><br>  Folgendes müssen wir tun, um den Fehler zu erstellen: <br><br><ol><li>  Setzen Sie den Antwortstatuscode auf <code>400 Bad Request</code> (schließlich hat der Benutzer falsche Daten eingegeben).  Dies wird unser erster Parameter sein. </li><li>  Senden Sie eine Nachricht an den Anrufer wie <code>User not found</code> .  Dies wird der zweite Parameter sein. </li></ol><br><pre> <code class="javascript hljs">app.put(<span class="hljs-string"><span class="hljs-string">'/testing'</span></span>, asyncHandler(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (req, res) =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { email } = req.body  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> User.findOne({ email })  <span class="hljs-comment"><span class="hljs-comment">//     -    if (!user) throw createError(400, `User '${email}' not found`) }))</span></span></code> </pre> <br>  Sie können den Statuscode mit dem Konstrukt <code>error.status</code> und die Fehlermeldung mit <code>error.message</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   app.use((error, req, res, next) =&gt; {  console.log('Error status: ', error.status)  console.log('Message: ', error.message) })</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb6/200/6e5/fb62006e5a36863e7bf82ce460867f05.png"></div><br>  <i><font color="#999999">Das Ergebnis von Protokollierungsfehlern in der Konsole</font></i> <br><br>  Anschließend wird der Antwortstatus mit <code>res.status</code> und die Nachricht in <code>res.json</code> : <br><br><pre> <code class="javascript hljs">app.use(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> {  <span class="hljs-comment"><span class="hljs-comment">//      res.status(error.status)  //    res.json({ message: error.message }) })</span></span></code> </pre> <br>  Persönlich bevorzuge ich das Senden eines Statuscodes, einer Nachricht und eines Stack-Trace-Ergebnisses für solche Antworten.  Dies erleichtert das Debuggen. <br><br><pre> <code class="javascript hljs">app.use(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> {  <span class="hljs-comment"><span class="hljs-comment">//      res.status(error.status)  //    res.json({    status: error.status,    message: error.message,    stack: error.stack  }) })</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Standardantwortstatuscode</font> </h3><br>  Wenn die Fehlerquelle nicht <code>createError</code> , verfügt sie nicht über die Eigenschaft <code>status</code> .  Hier ist ein Beispiel, in dem versucht wurde, eine nicht vorhandene Datei mit <code>fs.readFile</code> zu lesen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> util = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'util'</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  readFile  ,  ,  async/await-. //     : https://zellwk.com/blog/callbacks-to-promises const readFilePromise = util.promisify(fs.readFile) app.get('/testing', asyncHandler(async (req, res, next) =&gt; {  const data = await readFilePromise('some-file') })</span></span></code> </pre> <br>  Ein solches Fehlerobjekt hat nicht die Eigenschaft <code>status</code> : <br><br><pre> <code class="javascript hljs">app.use(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> {  <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Error status: '</span></span>, error.status)  <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Message: '</span></span>, error.message) })</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b78/187/6a3/b781876a373eba2a5ad6effe597c2e3e.png"></div><br>  <i><font color="#999999">Das Ergebnis von Protokollierungsfehlern in der Konsole</font></i> <br><br>  In solchen Fällen können Sie den Standardfehlercode festlegen.  Wir sprechen nämlich über den <code>500 Internal Server Error</code> : <br><br><pre> <code class="javascript hljs">app.use(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> {  res.status(error.status || <span class="hljs-number"><span class="hljs-number">500</span></span>)  res.json({    <span class="hljs-attr"><span class="hljs-attr">status</span></span>: error.status,    <span class="hljs-attr"><span class="hljs-attr">message</span></span>: error.message,    <span class="hljs-attr"><span class="hljs-attr">stack</span></span>: error.stack  }) })</code> </pre> <br><h3>  <font color="#3AC1EF">▍Ändern des Fehlerstatuscodes</font> </h3><br>  Angenommen, wir lesen eine bestimmte Datei anhand der vom Benutzer bereitgestellten Daten.  Wenn eine solche Datei nicht existiert, müssen wir einen <code>400 Bad Request</code> Fehler <code>400 Bad Request</code> .  Immerhin kann der Server nicht gefunden werden, da die Datei nicht gefunden werden kann. <br><br>  In diesem Fall müssen Sie das try / catch-Konstrukt verwenden, um den ursprünglichen Fehler abzufangen.  Dann müssen Sie das <code>createError</code> mit <code>createError</code> neu <code>createError</code> : <br><br><pre> <code class="javascript hljs">app.get(<span class="hljs-string"><span class="hljs-string">'/testing'</span></span>, asyncHandler(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (req, res, next) =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { file } = req.body    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> contents = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> readFilePromise(path.join(__dirname, file))  } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) {    <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> createError(<span class="hljs-number"><span class="hljs-number">400</span></span>, <span class="hljs-string"><span class="hljs-string">`File </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${file}</span></span></span><span class="hljs-string"> does not exist`</span></span>)  } })</code> </pre> <br><h3>  <font color="#3AC1EF">▍ 404 Fehlerbehandlung</font> </h3><br>  Wenn die Anforderung alle Intermediate-Handler und -Routen durchlaufen hat, aber nicht verarbeitet wurde, bedeutet dies, dass der einer solchen Anforderung entsprechende Endpunkt nicht gefunden wurde. <br><br>  Um <code>404 Not Found</code> Fehler zu behandeln, müssen Sie zwischen den Routen und der Fehlerbehandlungsroutine eine zusätzliche Behandlungsroutine hinzufügen.  So sieht die Erstellung des 404-Fehlerobjekts aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ... // ... app.use((req, res, next) =&gt; {  next(createError(404)) }) //  ...</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/462/bc6/5c2462bc6a3767ca349c3c49f12ac033.png"></div><br>  <i><font color="#999999">Fehlerdetails</font></i> <br><br><h3>  <font color="#3AC1EF">▍ ERR_HTTP_HEADERS_SENT Fehlerhinweise</font> </h3><br>  Keine Panik, wenn die Fehlermeldung <code>ERR_HTTP_HEADERS_SENT: Cannot set headers after they are sent to the client</code> .  Es entsteht, weil im selben Handler die Methode, die die Antwortheader setzt, wiederholt aufgerufen wird.  Mit den folgenden Methoden werden die Antwortheader automatisch festgelegt: <br><br><ol><li>  res.send </li><li>  res.json </li><li>  res.render </li><li>  res.sendFile </li><li>  res.sendStatus </li><li>  res.end </li><li>  res.redirect </li></ol><br>  Wenn Sie <code>res.json</code> <code>res.render</code> und <code>res.json</code> im selben <code>res.render</code> <code>res.json</code> , wird der Fehler <code>ERR_HTTP_HEADERS_SENT</code> : <br><br><pre> <code class="javascript hljs">app.get(<span class="hljs-string"><span class="hljs-string">'/testing'</span></span>, (req, res) =&gt; {  res.render(<span class="hljs-string"><span class="hljs-string">'new-page'</span></span>)  res.json({ <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'¯\_(ツ)_/¯'</span></span> }) })</code> </pre> <br>  Wenn dieser Fehler auftritt, überprüfen Sie den Code des Antworthandlers sorgfältig und stellen Sie sicher, dass es keine Situationen gibt, in denen mehrere der oben beschriebenen Methoden aufgerufen werden. <br><br><h3>  <font color="#3AC1EF">▍ Fehlerbehandlung und Datenstreaming</font> </h3><br>  Wenn beim Streamen der Antwort auf das Frontend ein Fehler <code>ERR_HTTP_HEADERS_SENT</code> , tritt möglicherweise derselbe <code>ERR_HTTP_HEADERS_SENT</code> Fehler auf. <br><br>  In diesem Fall muss die Fehlerbehandlung an Standardhandler übergeben werden.  Ein solcher Handler sendet einen Fehler und beendet die Verbindung automatisch. <br><br><pre> <code class="javascript hljs">app.use(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> {  <span class="hljs-comment"><span class="hljs-comment">//       ,        if (res.headersSent) {    return next(error)  }  //     })</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Heute habe ich Ihnen alles gesagt, was ich über die Fehlerbehandlung in Express weiß.  Ich hoffe, dies hilft Ihnen beim Schreiben zuverlässigerer Express-Anwendungen. <br><br>  <b>Sehr geehrte Leser!</b>  Wie gehen Sie mit Fehlern in Ihren Node.js-Projekten um? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476290/">https://habr.com/ru/post/de476290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476278/index.html">BLACK HAT USA Konferenz. Reich werden oder sterben: Mit Black Hat Geld im Internet verdienen. Teil 3</a></li>
<li><a href="../de476280/index.html">Durch Dornen zu DOS: Vier Disketten, die die Welt veränderten</a></li>
<li><a href="../de476284/index.html">Wir formulieren eine Strategie für die Arbeit mit Fehlern in React</a></li>
<li><a href="../de476286/index.html">Top 5 JS-Frameworks für die Front-End-Entwicklung im Jahr 2020. Teil 1</a></li>
<li><a href="../de476288/index.html">Top 5 JS-Frameworks für die Front-End-Entwicklung im Jahr 2020. Teil 2</a></li>
<li><a href="../de476292/index.html">SVG oder Leinwand?</a></li>
<li><a href="../de476294/index.html">Distributed Gaming Network als Alternative zu GFN: Wie und warum kann es abheben, wo es in der Russischen Föderation bereits funktioniert</a></li>
<li><a href="../de476296/index.html">21. November, Product Engineering MeetUp: Wer ist ein Produktingenieur?</a></li>
<li><a href="../de476298/index.html">Machen Sie sich mit dem Fahrrad vertraut, Teil 1: Lernen Sie die Grundlagen zum Anpassen des Visual Studio-Debuggers mithilfe von Plugins</a></li>
<li><a href="../de476300/index.html">Das Tram-Magazin ist ein hell erleuchteter und schnell verblassender Star der russischen Kinderavantgarde</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>