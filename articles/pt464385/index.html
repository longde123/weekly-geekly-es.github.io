<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂 👩🏾‍🎓 👩🏿‍🎤 Python como o caso final de C ++. Parte 1/2 👩🏾‍🤝‍👨🏽 🏙️ 🤹🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Do tradutor 

 Brandon Rhodes é uma pessoa muito modesta que se apresenta no Twitter como "um programador Python que paga um empréstimo à comunidade n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python como o caso final de C ++. Parte 1/2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464385/"><div class="spoiler">  <b class="spoiler_title">Do tradutor</b> <div class="spoiler_text"><p>  Brandon Rhodes é uma pessoa muito modesta que se apresenta no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Twitter</a> como "um programador Python que paga um empréstimo à comunidade na forma de relatórios ou ensaios".  O número desses "relatórios e ensaios" é impressionante, assim como o número de projetos gratuitos dos quais Brandon foi ou contribui.  E Brandon publicou dois livros e está escrevendo um terceiro. </p><br><p>  Muitas vezes encontro nos comentários sobre Habré um equívoco ou rejeição fundamental de linguagens dinâmicas, tipagem dinâmica, programação generalizada e outros paradigmas.  Estou publicando esta tradução (transcrição) autorizada (abreviada) de um dos relatórios de Brandon, na esperança de que ajude os programadores existentes nos paradigmas das linguagens estáticas a entender melhor as linguagens dinâmicas, em particular o Python. </p><br><p>  Como é habitual comigo, peço que me informe no PM sobre meus erros e erros de digitação. </p></div></div><br><p> O que a frase "caso marginal" significa no título do meu relatório?  O caso limite surge quando você itera uma sequência de opções até atingir o valor extremo.  Por exemplo, um polígono de n lados.  Se n = 3, então este é um triângulo, n = 4 é um quadrângulo, n = 5 é um pentágono etc. À medida que n se aproxima do infinito, os lados se tornam menores e maiores, e o contorno do polígono se torna como um círculo.  Assim, o círculo é o caso limitante para polígonos regulares.  É o que acontece quando uma certa idéia é levada ao limite. </p><br><p>  Eu quero falar sobre Python como um caso extremo de C ++.  Se você pegar todas as boas idéias do C ++ e limpá-las até a conclusão lógica, tenho certeza de que você terminará no Python tão naturalmente quanto uma série de polígonos chega a um círculo. </p><a name="habracut"></a><br><h1>  Ativos não essenciais </h1><br><p> Fiquei interessado em Python nos anos 90: foi um período na minha vida em que me livrei de "ativos não essenciais", como eu o chamo.  Muitas coisas começaram a me aborrecer.  Interrupções, por exemplo.  Lembre-se, uma vez em muitas placas de computador, houve contatos com jumpers?  E você define esses jumpers nos manuais para que a placa de vídeo receba uma interrupção de prioridade mais alta, para que seu jogo corra mais rápido?  Então, eu estava cansado de alocar e liberar memória usando <code>malloc()</code> e <code>free()</code> ao mesmo tempo em que parei de ajustar o desempenho do meu computador com jumpers.  Era 1997 mais ou menos. </p><br><p>  Quero dizer, quando estudamos um processo, geralmente nos esforçamos para obter controle completo sobre ele, para ter em mãos todas as alavancas e botões possíveis.  Então algumas pessoas ainda estão fascinadas por essa possibilidade de controle.  Mas meu personagem é que, assim que me acostumo à gerência e entendo o que é isso, começo imediatamente a procurar a oportunidade de abrir mão de alguns dos meus poderes, transferir alavancas e botões para alguma máquina, para que isso atribua interrupções para mim. </p><br><p>  Portanto, no final dos anos 90, eu estava procurando uma linguagem de programação que me permitisse focar na área de assunto e na modelagem de tarefas, em vez de me preocupar com a área da memória do meu computador armazenada.  Como podemos simplificar o C ++ sem repetir os pecados das famosas linguagens de script? </p><br><p>  Por exemplo, eu não poderia usar Perl, e você sabe por quê?  Este cifrão!  Ele imediatamente deixou claro que o criador do Perl não entendia como as linguagens de programação funcionavam.  Você usa o dólar no Bash para separar nomes de variáveis ​​do restante da cadeia, porque um programa Bash consiste em comandos literalmente percebidos e seus parâmetros.  Mas depois de conhecer essas linguagens de programação, nas quais as seqüências de caracteres são colocadas entre pares de caracteres pequenos chamados aspas e não em todo o texto do programa, você começa a perceber <code>$</code> como lixo visual.  O cifrão é inútil, é feio, deve desaparecer!  Se você deseja criar uma linguagem para programação séria, não use caracteres especiais para indicar variáveis. </p><br><h1>  Sintaxe </h1><br><p>  E a sintaxe?  Tome C como base!  Funciona muito bem.  Permita que a atribuição seja indicada por um sinal de igual.  Essa designação não é aceita em todos os idiomas, mas, de uma maneira ou de outra, muitos estão acostumados.  Mas não vamos fazer da atribuição uma expressão.  Os usuários de nossa linguagem serão não apenas programadores profissionais, mas também crianças em idade escolar, cientistas ou cientistas de dados (se você não souber qual dessas categorias de usuários escreve o pior código, sugerirei que não são crianças em idade escolar).  Não daremos aos usuários a oportunidade de alterar o estado das variáveis ​​em locais inesperados e tornaremos a atribuição um operador. </p><br><p>  O que então deve ser usado para denotar igualdade se o sinal de igual já tiver sido usado para atribuição?  Claro, dupla atribuição, como é feito em C!  Muitos já estão acostumados.  Também emprestaremos de C a notação para todas as operações aritméticas e bit a bit, porque essas notações funcionam e muitas estão felizes com elas. </p><br><p>  Claro, podemos melhorar alguma coisa.  O que você pensa quando vê o sinal de porcentagem no texto do programa?  Sobre interpolação de strings, é claro!  Embora o <code>%</code> seja principalmente um operador de captura de módulo, ele era simplesmente indefinido para seqüências de caracteres.  E se sim, por que não reutilizá-lo? </p><br><p>  Literais numéricos e de cadeias que controlam seqüências com barras invertidas - tudo isso será semelhante a C. </p><br><p>  Controle de fluxo de execução?  O mesmo <code>if</code> , <code>else</code> , <code>while</code> , <code>break</code> e <code>continue</code> .  Obviamente, adicionaremos um pouco de diversão ao cooptar os bons e velhos <code>for</code> iterar sobre estruturas de dados e intervalos de valores.  Isso será proposto posteriormente no C ++ 11, mas no Python, o operador <code>for</code> encapsulou todas as operações para calcular tamanhos, atravessar links, incrementar o contador etc., ou seja, fazer tudo o que era necessário para fornecer ao usuário um elemento da estrutura de dados.  Que tipo de estruturas?  Não importa, basta passá-lo <code>for</code> , ele vai descobrir. </p><br><p>  Também tomaremos emprestadas exceções do C ++, mas as tornaremos tão baratas em termos de consumo de recursos que elas podem ser usadas não apenas para lidar com erros, mas também para controlar o fluxo de execução.  Tornaremos a indexação mais interessante adicionando o fatiamento - a capacidade de indexar não apenas elementos individuais de estruturas de dados sequenciais, mas também seus intervalos. </p><br><p>  Ah sim!  Corrigiremos a falha de design original em C - adicione uma vírgula pendente! </p><br><p>  Essa história começou com Pascal, uma linguagem terrível na qual um ponto e vírgula é usado como <em>delimitador de</em> expressão.  Isso significa que o usuário deve colocar um ponto e vírgula no final de <em>cada</em> expressão no bloco, <em>exceto a última</em> .  Portanto, toda vez que você altera a ordem das expressões em um programa no Pascal, corre o risco de receber um erro de sintaxe se não remover o ponto-e-vírgula da última linha e adicioná-lo ao final da linha que costumava ser a última. </p><br><pre> <code class="plaintext hljs">If (n = 0) then begin writeln('N is now zero'); func := 1 end</code> </pre> <br><p>  Kernigan e Ritchie fizeram a coisa certa quando definiram o ponto-e-vírgula em C como o <em>terminador da</em> expressão, e não o delimitador, criando essa maravilhosa simetria quando cada linha do programa, incluindo a última, termina a mesma e pode ser trocada livremente.  Infelizmente, no futuro, um senso de harmonia mudou para eles, e eles fizeram da vírgula um <em>separador</em> em inicializadores estáticos.  Isso parece bom quando a expressão se encaixa em uma linha: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a[] = {<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>};</code> </pre> <br><p>  mas quando seu inicializador fica mais longo e você o organiza verticalmente, você obtém a mesma assimetria desconfortável que em Pascal: </p><br><pre> <code class="plaintext hljs">int a[] = { 4, 5, 6 };</code> </pre> <br><p>  No estágio inicial de seu desenvolvimento, o Python tornou a vírgula suspensa nas estruturas de dados completamente opcional, independentemente de como os elementos dessa estrutura são organizados: horizontal ou verticalmente.  A propósito, isso é muito conveniente para a geração automática de código: você não precisa tratar o último elemento como um caso especial. </p><br><p>  Posteriormente, os padrões C99 e C ++ 11 também corrigiram o mal-entendido inicial, permitindo adicionar uma vírgula após o último literal no inicializador. </p><br><h1>  Namespaces </h1><br><p>  Também precisamos implementar em nossa linguagem de programação algo como namespaces ou namespaces.  Esta é uma parte crítica da linguagem que deve nos salvar de erros como conflitos de nome.  Seremos mais fáceis que o C ++: em vez de dar ao usuário a capacidade de nomear arbitrariamente o espaço para nome, criaremos um espaço para nome por módulo (arquivo) e os designaremos com nomes de arquivo.  Por exemplo, se você criar o módulo <code>foo.py</code> , ele receberá o espaço de nomes <code>foo</code> . </p><br><p>  Para trabalhar com um modelo simplificado de namespaces, um usuário precisa de apenas um operador. </p><br><p>  Crie o diretório <code>my_package</code> , coloque o arquivo <code>my_module.py</code> e declare a classe no arquivo: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> READ = <span class="hljs-number"><span class="hljs-number">1</span></span> WRITE = <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><p>  o acesso aos atributos da classe será o seguinte: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> my_package.my_module my_package.my_module.C.READ</code> </pre> <br><p>  Não se preocupe, não forçaremos o usuário a imprimir o nome completo toda vez.  Daremos a ele a oportunidade de usar várias versões da declaração de <code>import</code> para variar o grau de "proximidade" do espaço para nome: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> my_package.my_module my_package.my_module.C.READ <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_package <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> my_module my_module.C.READ <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_package.my_module <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> C C.READ</code> </pre> <br><p>  Assim, os mesmos nomes dados em pacotes diferentes nunca entrarão em conflito: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json j = json.load(file) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle p = pickle.load(file)</code> </pre> <br><p>  O fato de cada módulo ter seu próprio espaço para nome também significa que não precisamos de um modificador <code>static</code> .  No entanto, lembramos de uma função executada <code>static</code> - encapsulando variáveis ​​internas.  Para mostrar aos colegas que um determinado nome (variável, classe ou módulo) não é público, iniciamos com um sublinhado, por exemplo, <code>_ignore_this</code> .  Também pode ser um sinal para o IDE não usar esse nome no preenchimento automático. </p><br><h1>  Sobrecarga de função </h1><br><p>  Não implementaremos sobrecarga de funções em nosso idioma.  O mecanismo de sobrecarga é muito complicado.  Em vez disso, usaremos argumentos opcionais com valores padrão que podem ser omitidos da chamada, bem como argumentos nomeados para “pular” sobre os argumentos opcionais com padrões válidos e definir apenas os valores que diferem dos padrões.  É importante ressaltar que a falta de sobrecarga nos poupará da necessidade de determinar qual função do conjunto de funções sobrecarregadas acabou de ser chamada, como o gerenciador de chamadas funcionava: a função é sempre uma neste módulo, é fácil encontrar pelo nome. </p><br><h1>  APIs do sistema </h1><br><p>  Daremos ao usuário acesso total a muitas APIs do sistema, incluindo soquetes.  Não entendo por que os autores de linguagens de script sempre oferecem suas próprias maneiras engenhosas de abrir um soquete.  No entanto, eles nunca realizam a API do Unix Socket completa.  Eles implementam 5-6 funções que entendem e jogam fora todo o resto.  O Python, diferentemente deles, possui módulos padrão para interagir com o sistema operacional que implementam cada chamada de sistema padrão.  Isso significa que você pode abrir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o livro de Stevens</a> agora e começar a escrever o código.  E todos os seus soquetes, processos e garfos funcionarão exatamente como ele diz.  Sim, é possível que Guido ou os primeiros colaboradores do Python tenham feito exatamente isso, porque estavam com preguiça de escrever sua implementação das bibliotecas do sistema, com preguiça de explicar aos usuários novamente como os soquetes funcionam.  Mas, como resultado, eles obtiveram um efeito maravilhoso: você pode transferir todo o seu conhecimento UNIX adquirido em C e C ++ para o ambiente Python. </p><br><p>  Portanto, decidimos quais recursos “emprestaremos” do C ++ para criar nossa linguagem de script simples.  Agora precisamos decidir o que queremos consertar. </p><br><h1>  Comportamento indefinido </h1><br><p>  Comportamento desconhecido, comportamento indefinido, comportamento definido pela implementação ... Todas essas são idéias ruins para a linguagem que será usada por crianças em idade escolar, cientistas e cientistas de dados.  E o ganho de desempenho para o qual essas coisas são permitidas geralmente é insignificante em comparação com os inconvenientes.  Em vez disso, anunciaremos que qualquer programa sintaticamente correto produz o mesmo resultado em qualquer plataforma.  Vamos descrever o padrão da linguagem com frases como “Python avalia todas as expressões da esquerda para a direita” em vez de tentar reorganizar os cálculos, dependendo do processador, sistema operacional ou fase da lua.  Se o usuário tem certeza de que a ordem dos cálculos é importante, ele tem o direito de reescrever o código corretamente: no final, o usuário é o principal. </p><br><h1>  Prioridades de operação </h1><br><p>  Você deve ter encontrado erros semelhantes: expressão </p><br><pre> <code class="cpp hljs">oflags &amp; <span class="hljs-number"><span class="hljs-number">0x80</span></span> == nflags &amp; <span class="hljs-number"><span class="hljs-number">0x80</span></span></code> </pre> <br><p>  sempre retorna 0, porque as comparações em C têm precedência sobre operações bit a bit.  Em outras palavras, essa expressão avalia como </p><br><pre> <code class="cpp hljs">oflags &amp; (<span class="hljs-number"><span class="hljs-number">0x80</span></span> == nflags) &amp; <span class="hljs-number"><span class="hljs-number">0x80</span></span></code> </pre> <br><p>  Oh, esse C! </p><br><p>  Eliminaremos a causa potencial de tais erros em nossa linguagem de script simples, colocando a prioridade das operações de comparação atrás da aritmética e da manipulação de bits, para que a expressão do nosso exemplo seja calculada de maneira mais intuitiva: </p><br><pre> <code class="cpp hljs">(oflags &amp; <span class="hljs-number"><span class="hljs-number">0x80</span></span>) == (nflags &amp; <span class="hljs-number"><span class="hljs-number">0x80</span></span>)</code> </pre> <br><h1>  Outras melhorias </h1><br><p>  A legibilidade do código é importante para nós.  Se as operações aritméticas da linguagem C são familiares ao usuário, mesmo pela aritmética da escola, a confusão entre operações lógicas e bit a bit é uma fonte clara de erros.  Substituiremos o duplo e comercial pela palavra ee a dupla linha vertical pela palavra <code>or</code> , para que nossa linguagem se pareça mais com a fala humana do que com o piquete de caracteres de “computador”. </p><br><p>  Vamos deixar a possibilidade de computação abreviada para nossos operadores lógicos ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://en.wikipedia.org/wiki/Short-circuit_evaluation</a> ), mas também damos a eles a capacidade de retornar o valor final de qualquer tipo, não apenas booleano.  Então expressões como </p><br><pre> <code class="python hljs">s = error.message <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'Error'</span></span></code> </pre> <br><p>  Neste exemplo, a variável será configurada como <code>error.message</code> se não for vazia, caso contrário, a string 'Error'. </p><br><p>  Estendemos a ideia de C de que 0 é equivalente a false para objetos que não sejam números inteiros.  Por exemplo, em linhas e contêineres vazios. </p><br><p>  Destruiremos o excesso de número inteiro.  Nossa linguagem será consistente na implementação e fácil de usar; portanto, nossos usuários não precisarão lembrar de um valor especial suspeito, próximo a dois bilhões, após o qual o todo, aumentado em um, muda repentinamente de sinal.  Implementamos números inteiros que se comportam como números inteiros até esgotar toda a memória disponível. </p><br><h1>  Digitação estrita vs fraca </h1><br><p>  Outra questão importante no design da linguagem de script: o rigor da digitação.  Muitos na platéia estão familiarizados com JavaScript?  O que acontece se o número 3 for subtraído da sequência '4'? </p><br><pre> <code class="javascript hljs">js&gt; <span class="hljs-string"><span class="hljs-string">'4'</span></span> - <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  Ótimo!  E se você adicionar o número 3 à sequência '4'? </p><br><pre> <code class="javascript hljs">js&gt; <span class="hljs-string"><span class="hljs-string">'4'</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-string"><span class="hljs-string">"43"</span></span></code> </pre> <br><p>  Isso é chamado de digitação frouxa (ou fraca).  Isso é algo como um complexo de inferioridade quando uma linguagem de programação pensa que um programador a condenará se não puder retornar o resultado de qualquer expressão, mesmo obviamente sem sentido, por tipos de conversão repetidos.  O problema é que a conversão de tipo, que uma linguagem de tipo fraco produz automaticamente, muito raramente leva a um resultado significativo.  Vamos tentar conversões um pouco mais complexas: </p><br><pre> <code class="javascript hljs">js&gt; [] + [] <span class="hljs-string"><span class="hljs-string">""</span></span> js&gt; [] + {} <span class="hljs-string"><span class="hljs-string">"[object Object]"</span></span></code> </pre> <br><p>  Esperamos que a operação de adição seja comutativa, mas o que acontece se mudarmos os termos no último caso? </p><br><pre> <code class="javascript hljs">js&gt; {} + [] <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>  JavaScript não está sozinho em seus problemas.  Perl em uma situação semelhante também tenta retornar pelo menos algo: </p><br><pre> <code class="perl hljs">perl&gt; <span class="hljs-string"><span class="hljs-string">"3"</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br><p>  E o awk fará algo assim: </p><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> | awk <span class="hljs-string"><span class="hljs-string">'{print "3" + 1}'</span></span> 4</code> </pre> <br><p>  Os criadores de linguagens de script tradicionalmente acreditam que a digitação solta é <em>conveniente</em> .  Eles estavam enganados: a digitação solta é <em>terrível</em> !  Viola o princípio da localidade.  Se houver um erro no código, a linguagem de programação deverá informar o usuário sobre isso, causando uma exceção o mais próximo possível do local problemático no código.  Mas em todas essas linguagens, que lançam tipos infinitamente, até que algo seja resolvido, o controle geralmente chega ao fim e obtemos o resultado, julgando pelo qual, em nosso programa, algo está errado em algum lugar.  E temos que depurar todo o nosso programa, uma linha após a outra, para encontrar esse erro. </p><br><p>  A digitação solta também diminui a legibilidade do código, porque, mesmo que usemos corretamente a conversão implícita de tipos em um programa, isso acontece inesperadamente para outro programador. </p><br><p>  No Python, como no C ++, essas expressões retornarão um erro. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">'4'</span></span> - <span class="hljs-number"><span class="hljs-number">3</span></span> TypeError &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">'4'</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> TypeError</code> </pre> <br><p>  Como a conversão de tipo, se realmente necessário, é fácil de escrever explicitamente: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>int(<span class="hljs-string"><span class="hljs-string">'4'</span></span>) + <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">'4'</span></span> + str(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-string"><span class="hljs-string">'43'</span></span></code> </pre> <br><p>  Esse código é fácil de ler e manter, deixa claro o que exatamente acontece no programa, o que leva a esse resultado.  Isso ocorre porque os programadores Python acreditam que explícito é melhor que implícito, e o erro não deve passar despercebido. </p><br><p>  Python é uma linguagem fortemente tipada e a única conversão implícita de tipo ocorre durante operações aritméticas em números inteiros, cujo resultado deve ser expresso como um número fracionário.  Talvez isso também não deva ser permitido no programa, mas nesse caso muitos usuários precisariam explicar imediatamente a diferença entre números inteiros e números de ponto flutuante, o que complicaria seus primeiros passos no Python. </p><br><p>  Continuação: “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Python como o caso final de C ++.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2/2</a> . " </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt464385/">https://habr.com/ru/post/pt464385/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt464373/index.html">Edge-to-edge no Android: fazendo certo</a></li>
<li><a href="../pt464375/index.html">Como os mecanismos de pesquisa funcionam</a></li>
<li><a href="../pt464377/index.html">Montador sujo hacks 6502</a></li>
<li><a href="../pt464381/index.html">Viagem ao Alasca ou KDD'19 através dos olhos de uma testemunha ocular</a></li>
<li><a href="../pt464383/index.html">Como eu coloco as coisas em ordem em um projeto em que há uma floresta de mãos diretas (configurações tslint, mais bonitas, etc.)</a></li>
<li><a href="../pt464387/index.html">Pegada russa na saga escandinava dos videogames, terminando</a></li>
<li><a href="../pt464391/index.html">10 relatórios interessantes de conferências de hackers</a></li>
<li><a href="../pt464393/index.html">Como encontrar cursos de programação e quais são as garantias de emprego</a></li>
<li><a href="../pt464395/index.html">Aleatório baseado em blockchain RSA</a></li>
<li><a href="../pt464399/index.html">Raspagem da Web no R, Parte 2. Acelerando o processo com computação paralela e usando o pacote Rcrawler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>