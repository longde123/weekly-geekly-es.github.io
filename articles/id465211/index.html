<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™‡ğŸ¾ ğŸ‘©ğŸ¿â€ğŸš€ ğŸ‘©â€ğŸ‘©â€ğŸ‘§ Melarikan Diri dari Tes: Membangun Jalan Pintas dari Fixture ke Pernyataan ğŸ§‘ğŸ¼â€ğŸ¤â€ğŸ§‘ğŸ¼ ğŸ‘ ğŸ’Š</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini, saya ingin mengusulkan alternatif untuk gaya desain tes tradisional menggunakan konsep pemrograman fungsional di Scala. Pendekatan i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Melarikan Diri dari Tes: Membangun Jalan Pintas dari Fixture ke Pernyataan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/2gis/blog/465211/"><p><img src="https://habrastorage.org/webt/mu/ll/ar/mullaroquhqtdb05ygvb82nmghu.jpeg"></p><br><p>  Pada artikel ini, saya ingin mengusulkan alternatif untuk gaya desain tes tradisional menggunakan konsep pemrograman fungsional di Scala.  Pendekatan ini diilhami oleh rasa sakit selama berbulan-bulan karena mempertahankan puluhan tes yang gagal dan keinginan yang membara untuk menjadikannya lebih mudah dan lebih mudah dipahami. </p><br><p>  Meskipun kodenya ada di Scala, ide-ide yang diusulkan cocok untuk pengembang dan insinyur QA yang menggunakan bahasa yang mendukung pemrograman fungsional.  Anda dapat menemukan tautan Github dengan solusi lengkap dan contoh di akhir artikel. </p><a name="habracut"></a><br><h2 id="the-problem">  Masalah </h2><br><p>  Jika Anda pernah harus berurusan dengan tes (tidak masalah yang mana: tes unit, integrational atau fungsional), mereka kemungkinan besar ditulis sebagai serangkaian instruksi berurutan.  Misalnya: </p><br><pre><code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">// The following tests describe a simple internet store. // Depending on their role, bonus amount and the order's // subtotal, users may receive a discount of some size. "If user's role is 'customer'" - { import TestHelper._ "And if subtotal &lt; 250 after bonuses - no discount" in { val db: Database = Database.forURL(TestConfig.generateNewUrl()) migrateDb(db) insertUser(db, id = 1, name = "test", role = "customer") insertPackage(db, id = 1, name = "test", userId = 1, status = "new") insertPackageItems(db, id = 1, packageId = 1, name = "test", price = 30) insertPackageItems(db, id = 2, packageId = 1, name = "test", price = 20) insertPackageItems(db, id = 3, packageId = 1, name = "test", price = 40) val svc = new SomeProductionLogic(db) val result = svc.calculatePrice(packageId = 1) result shouldBe 90 } "And if subtotal &gt;= 250 after bonuses - 10% off" in { val db: Database = Database.forURL(TestConfig.generateNewUrl()) migrateDb(db) insertUser(db, id = 1, name = "test", role = "customer") insertPackage(db, id = 1, name = "test", userId = 1, status = "new") insertPackageItems(db, id = 1, packageId = 1, name = "test", price = 100) insertPackageItems(db, id = 2, packageId = 1, name = "test", price = 120) insertPackageItems(db, id = 3, packageId = 1, name = "test", price = 130) insertBonus(db, id = 1, packageId = 1, bonusAmount = 40) val svc = new SomeProductionLogic(db) val result = svc.calculatePrice(packageId = 1) result shouldBe 279 } } "If user's role is 'vip'" - {/*...*/}</span></span></code> </pre> <br><p>  Dalam pengalaman saya, cara penulisan tes ini lebih disukai oleh kebanyakan pengembang.  Proyek kami memiliki sekitar seribu tes pada berbagai tingkat isolasi, dan semuanya ditulis dengan gaya seperti itu hingga baru-baru ini.  Ketika proyek tumbuh, kami mulai melihat masalah parah dan perlambatan dalam mempertahankan tes tersebut: memperbaikinya akan memakan waktu setidaknya sama dengan waktu menulis kode produksi. </p><br><p>  Saat menulis tes baru, kami selalu harus menemukan cara untuk menyiapkan data dari awal, biasanya dengan menyalin dan menempelkan langkah-langkah dari tes tetangga.  Akibatnya, ketika model data aplikasi akan berubah, rumah kartu akan runtuh, dan kami harus memperbaiki setiap tes gagal: dalam skenario terburuk - dengan menyelam jauh ke dalam setiap tes dan menulis ulang. </p><br><p>  Ketika sebuah tes akan gagal "jujur" - yaitu karena bug aktual dalam logika bisnis - memahami apa yang salah tanpa debugging tidak mungkin.  Karena tes itu sangat sulit untuk dipahami, tidak ada yang memiliki pengetahuan penuh selalu tentang bagaimana sistem seharusnya berperilaku. </p><br><p>  Semua rasa sakit ini, menurut pendapat saya, adalah gejala dari dua masalah yang lebih dalam dari desain tes tersebut: </p><br><ol><li>  Tidak ada struktur yang jelas dan praktis untuk tes.  Setiap tes adalah kepingan salju yang unik.  Kurangnya struktur menyebabkan verbositas, yang memakan banyak waktu dan kehilangan motivasi.  Detail tidak penting mengalihkan perhatian dari apa yang paling penting - persyaratan yang ditegaskan oleh tes ini.  Menyalin dan menempel menjadi pendekatan utama untuk menulis kasus uji baru. </li><li>  Tes tidak membantu pengembang dalam melokalisasi cacat;  mereka hanya memberi sinyal bahwa ada semacam masalah.  Untuk memahami keadaan di mana tes dijalankan, Anda harus merencanakannya di kepala Anda atau menggunakan debugger. </li></ol><br><h2 id="modeling">  Pemodelan </h2><br><p>  Bisakah kita berbuat lebih baik?  (Peringatan spoiler: kami bisa.) Mari kita pertimbangkan seperti apa struktur tes ini. </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> db: <span class="hljs-type"><span class="hljs-type">Database</span></span> = <span class="hljs-type"><span class="hljs-type">Database</span></span>.forURL(<span class="hljs-type"><span class="hljs-type">TestConfig</span></span>.generateNewUrl()) migrateDb(db) insertUser(db, id = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, role = <span class="hljs-string"><span class="hljs-string">"customer"</span></span>) insertPackage(db, id = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, userId = <span class="hljs-number"><span class="hljs-number">1</span></span>, status = <span class="hljs-string"><span class="hljs-string">"new"</span></span>) insertPackageItems(db, id = <span class="hljs-number"><span class="hljs-number">1</span></span>, packageId = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, price = <span class="hljs-number"><span class="hljs-number">30</span></span>) insertPackageItems(db, id = <span class="hljs-number"><span class="hljs-number">2</span></span>, packageId = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, price = <span class="hljs-number"><span class="hljs-number">20</span></span>) insertPackageItems(db, id = <span class="hljs-number"><span class="hljs-number">3</span></span>, packageId = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, price = <span class="hljs-number"><span class="hljs-number">40</span></span>)</code> </pre> <br><p>  Sebagai aturan praktis, kode yang sedang diuji mengharapkan beberapa parameter eksplisit (pengidentifikasi, ukuran, jumlah, filter, untuk beberapa nama), serta beberapa data eksternal (dari database, antrian atau layanan dunia nyata lainnya).  Agar pengujian kami dapat berjalan dengan andal, diperlukan <em>fixture</em> - keadaan untuk menempatkan sistem, penyedia data, atau keduanya. </p><br><p>  Dengan fixture ini, kami menyiapkan <em>dependensi</em> untuk menginisialisasi kode yang sedang diuji - isi database, buat antrian dari tipe tertentu, dll. </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> svc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">SomeProductionLogic</span></span>(db) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = svc.calculatePrice(packageId = <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Setelah menjalankan kode yang sedang diuji pada beberapa parameter input, kami menerima <em>output</em> - baik eksplisit (dikembalikan oleh kode yang diuji) dan implisit (perubahan di negara bagian). </p><br><pre> <code class="scala hljs">result shouldBe <span class="hljs-number"><span class="hljs-number">90</span></span></code> </pre> <br><p>  Akhirnya, kami memeriksa bahwa hasilnya seperti yang diharapkan, menyelesaikan tes dengan satu atau lebih <em>pernyataan</em> . </p><br><p><img src="https://habrastorage.org/webt/em/aa/rb/emaarb5ltmnme4-wpda0ebakueq.jpeg"></p><br><p>  Seseorang dapat menyimpulkan bahwa tes umumnya terdiri dari tahapan yang sama: persiapan input, eksekusi kode, dan pernyataan hasil.  Kita dapat menggunakan fakta ini untuk menyingkirkan <strong>masalah pertama dari tes kami</strong> , mis. Bentuk yang terlalu liberal, dengan secara eksplisit membagi tubuh tes menjadi beberapa tahap.  Gagasan semacam itu bukanlah hal baru, karena dapat dilihat dalam tes gaya BDD ( <em>pengembangan yang didorong oleh perilaku</em> ). </p><br><p>  Bagaimana dengan perpanjangan?  Setiap langkah dari proses pengujian dapat, pada gilirannya, mengandung jumlah jumlah sedang.  Sebagai contoh, kita dapat mengambil langkah besar dan rumit, seperti membangun fixture, dan membaginya menjadi beberapa, dirantai satu demi satu.  Dengan cara ini, proses pengujian dapat diperpanjang tanpa batas, tetapi pada akhirnya selalu terdiri dari beberapa langkah umum yang sama. </p><br><p><img src="https://habrastorage.org/webt/55/qf/zl/55qfzlhkl99txyyhizbvzg48yhs.jpeg"></p><br><h2 id="running-tests">  Menjalankan tes </h2><br><p>  Mari kita coba menerapkan gagasan membagi tes menjadi beberapa tahap, tetapi pertama-tama, kita harus menentukan hasil seperti apa yang ingin kita lihat. </p><br><p>  Secara keseluruhan, kami ingin menulis dan mempertahankan tes menjadi kurang padat karya dan lebih menyenangkan.  Semakin sedikit instruksi unik dan unik yang dimiliki tes, semakin sedikit perubahan yang harus dilakukan setelah mengubah kontrak atau refactoring, dan semakin sedikit waktu yang dibutuhkan untuk membaca tes.  Desain tes harus mempromosikan penggunaan ulang potongan kode umum dan mencegah penyalinan dan menempelkan yang tidak berpikir.  Akan lebih baik jika tes akan memiliki bentuk yang seragam.  Prediktabilitas meningkatkan keterbacaan dan menghemat waktu.  Sebagai contoh, bayangkan berapa banyak waktu yang dibutuhkan para ilmuwan yang bercita-cita untuk mempelajari semua formula jika buku teks akan membuatnya ditulis secara bebas dalam bahasa umum sebagai lawan dari matematika. </p><br><p>  Dengan demikian, tujuan kami adalah menyembunyikan apa pun yang mengganggu dan tidak perlu, hanya menyisakan apa yang sangat penting untuk dipahami: apa yang sedang diuji, apa input dan output yang diharapkan. </p><br><p>  Mari kita kembali ke model struktur pengujian kita. </p><br><p><img src="https://habrastorage.org/webt/em/aa/rb/emaarb5ltmnme4-wpda0ebakueq.jpeg"></p><br><p>  Secara teknis, setiap langkah dapat diwakili oleh tipe data, dan setiap transisi - oleh suatu fungsi.  Untuk mendapatkan dari tipe data awal ke yang terakhir dimungkinkan dengan menerapkan masing-masing fungsi ke hasil yang sebelumnya.  Dengan kata lain, dengan menggunakan komposisi fungsi persiapan data (sebut saja <code>prepare</code> ), eksekusi kode ( <code>execute</code> ) dan pengecekan hasil yang diharapkan ( <code>check</code> ).  Input untuk komposisi ini akan menjadi langkah pertama - fixture.  Mari kita sebut fungsi orde tinggi yang dihasilkan sebagai fungsi <strong>siklus uji</strong> . </p><br><div class="spoiler">  <b class="spoiler_title">Uji fungsi siklus hidup</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runTestCycle</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">FX</span></span>, <span class="hljs-type"><span class="hljs-type">DEP</span></span>, <span class="hljs-type"><span class="hljs-type">OUT</span></span>, <span class="hljs-type"><span class="hljs-type">F</span></span>[_]]( fixture: <span class="hljs-type"><span class="hljs-type">FX</span></span>, prepare: <span class="hljs-type"><span class="hljs-type">FX</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">DEP</span></span>, execute: <span class="hljs-type"><span class="hljs-type">DEP</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">OUT</span></span>, check: <span class="hljs-type"><span class="hljs-type">OUT</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">Assertion</span></span>] ): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">Assertion</span></span>] = <span class="hljs-comment"><span class="hljs-comment">// In Scala instead of writing check(execute(prepare(fixture))) // one can use a more readable version using the andThen function: (prepare andThen execute andThen check) (fixture)</span></span></code> </pre> </div></div><br><p>  Muncul pertanyaan, dari mana fungsi-fungsi tertentu ini berasal?  Nah, untuk persiapan data, hanya ada sejumlah cara untuk melakukannya - mengisi basis data, mengejek, dll.  Dengan demikian, sangat berguna untuk menulis varian khusus fungsi <code>prepare</code> dibagikan di semua tes.  Akibatnya, akan lebih mudah untuk membuat fungsi siklus hidup tes khusus untuk setiap kasus, yang akan menyembunyikan implementasi konkret persiapan data.  Karena eksekusi kode dan pernyataan lebih atau kurang unik untuk setiap tes (atau kelompok tes), <code>execute</code> dan <code>check</code> harus ditulis setiap waktu secara eksplisit. </p><br><div class="spoiler">  <b class="spoiler_title">Fungsi siklus hidup tes diadaptasi untuk pengujian integrasi pada DB</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">// Sets up the fixture â€” implemented separately def prepareDatabase[DB](db: Database): DbFixture =&gt; DB def testInDb[DB, OUT]( fixture: DbFixture, execute: DB =&gt; OUT, check: OUT =&gt; Future[Assertion], db: Database = getDatabaseHandleFromSomewhere(), ): Future[Assertion] = runTestCycle(fixture, prepareDatabase(db), execute, check)</span></span></code> </pre> </div></div><br><p>  Dengan mendelegasikan semua nuansa administratif ke fungsi siklus hidup pengujian, kami mendapatkan kemampuan untuk memperpanjang proses pengujian tanpa menyentuh tes yang diberikan.  Dengan memanfaatkan komposisi fungsi, kita dapat mengganggu setiap langkah proses dan mengekstraksi atau menambahkan data. </p><br><p>  Untuk lebih menggambarkan kemampuan dari pendekatan semacam itu, mari kita selesaikan <strong>masalah kedua dari tes awal kami</strong> - kurangnya informasi tambahan untuk menunjukkan masalah dengan tepat.  Mari kita tambahkan logging dari eksekusi kode apa pun yang telah dikembalikan.  Pencatatan kami tidak akan mengubah tipe data;  itu hanya menghasilkan <em>efek samping</em> - mengeluarkan pesan ke konsol.  Setelah efek samping, kami mengembalikannya apa adanya. </p><br><div class="spoiler">  <b class="spoiler_title">Uji fungsi siklus hidup dengan pencatatan</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logged</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> loggedT: <span class="hljs-type"><span class="hljs-type">Logged</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = (that: <span class="hljs-type"><span class="hljs-type">T</span></span>) =&gt; { <span class="hljs-comment"><span class="hljs-comment">// By passing an instance of the Logged typeclass for T as an argument, // we get an ability to â€œaddâ€ behavior log() to the abstract â€œthatâ€ member. // More on typeclasses later on. loggedT.log(that) // We could even do: that.log() that // The object gets returned unaltered } def runTestCycle[FX, DEP, OUT, F[_]]( fixture: FX, prepare: FX =&gt; DEP, execute: DEP =&gt; OUT, check: OUT =&gt; F[Assertion] )(implicit loggedOut: Logged[OUT]): F[Assertion] = // Insert logged right after receiving the result - after execute() (prepare andThen execute andThen logged andThen check) (fixture)</span></span></code> </pre> </div></div><br><p>  Dengan perubahan sederhana ini, kami telah menambahkan pencatatan output kode yang dieksekusi <strong>di setiap pengujian</strong> .  Keuntungan dari fungsi sekecil itu adalah mudah dipahami, disusun, dan dihilangkan saat dibutuhkan. </p><br><p><img src="https://habrastorage.org/webt/ti/2t/l9/ti2tl9pk8wkd4hp8pqevf74hdn4.jpeg"></p><br><p>  Hasilnya, pengujian kami sekarang terlihat seperti ini: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fixture: <span class="hljs-type"><span class="hljs-type">SomeMagicalFixture</span></span> = ??? <span class="hljs-comment"><span class="hljs-comment">// Comes from somewhere else def runProductionCode(id: Int): Database =&gt; Double = (db: Database) =&gt; new SomeProductionLogic(db).calculatePrice(id) def checkResult(expected: Double): Double =&gt; Future[Assertion] = (result: Double) =&gt; result shouldBe expected // The creation and filling of Database is hidden in testInDb "If user's role is 'customer'" in testInDb( state = fixture, execute = runProductionCode(id = 1), check = checkResult(90) )</span></span></code> </pre> <br><p>  Tubuh tes menjadi singkat, fixture dan cek dapat digunakan kembali dalam tes lain, dan kami tidak menyiapkan database secara manual di mana pun lagi.  Hanya satu masalah kecil yang tersisa ... </p><br><h2 id="fixture-preparation">  Persiapan perlengkapan </h2><br><p>  Dalam kode di atas kami bekerja dengan asumsi bahwa fixture akan diberikan kepada kami dari suatu tempat.  Karena data merupakan unsur penting dari pengujian yang dapat dipertahankan dan langsung, kami harus menyentuh cara membuatnya dengan mudah. </p><br><p>  Misalkan toko kami sedang diuji memiliki basis data relasional berukuran sedang (untuk kesederhanaan, dalam contoh ini hanya memiliki 4 tabel, tetapi dalam kenyataannya, dapat memiliki ratusan).  Beberapa tabel memiliki data referensial, beberapa - data bisnis, dan semua itu dapat secara logis dikelompokkan menjadi satu atau lebih entitas yang kompleks.  Hubungan terkait dengan <em>kunci asing</em> , untuk membuat <code>Bonus</code> , <code>Package</code> diperlukan, yang pada gilirannya membutuhkan <code>User</code> , dan sebagainya. </p><br><p><img src="https://habrastorage.org/webt/3z/of/sy/3zofsyjoygierusjtmlu_okrmh0.png"></p><br><p>  Penanganan masalah dan peretasan hanya menyebabkan inkonsistensi data dan, sebagai akibatnya, berjam-jam berjam-jam melakukan debugging.  Karena alasan ini, kami tidak akan mengubah skema dengan cara apa pun. </p><br><p>  Kita dapat menggunakan beberapa metode produksi untuk mengisinya, tetapi bahkan di bawah pengawasan yang dangkal, ini menimbulkan banyak pertanyaan sulit.  Apa yang akan menyiapkan data dalam pengujian untuk kode produksi itu?  Apakah kita harus menulis ulang tes jika kontrak kode itu berubah?  Bagaimana jika data sepenuhnya berasal dari tempat lain, dan tidak ada metode untuk digunakan?  Berapa banyak permintaan yang diperlukan untuk membuat entitas yang bergantung pada banyak lainnya? </p><br><div class="spoiler">  <b class="spoiler_title">Database mengisi tes awal</b> <div class="spoiler_text"><pre> <code class="scala hljs">insertUser(db, id = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, role = <span class="hljs-string"><span class="hljs-string">"customer"</span></span>) insertPackage(db, id = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, userId = <span class="hljs-number"><span class="hljs-number">1</span></span>, status = <span class="hljs-string"><span class="hljs-string">"new"</span></span>) insertPackageItems(db, id = <span class="hljs-number"><span class="hljs-number">1</span></span>, packageId = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, price = <span class="hljs-number"><span class="hljs-number">30</span></span>) insertPackageItems(db, id = <span class="hljs-number"><span class="hljs-number">2</span></span>, packageId = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, price = <span class="hljs-number"><span class="hljs-number">20</span></span>) insertPackageItems(db, id = <span class="hljs-number"><span class="hljs-number">3</span></span>, packageId = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, price = <span class="hljs-number"><span class="hljs-number">40</span></span>)</code> </pre> </div></div><br><p>  Metode pembantu yang tersebar, seperti yang ada dalam contoh pertama kita, adalah masalah yang sama dengan kedok yang berbeda.  Mereka menempatkan tanggung jawab mengelola ketergantungan pada diri kita sendiri yang kita coba hindari. </p><br><p>  Idealnya, kami ingin beberapa struktur data yang akan menyajikan keadaan seluruh sistem hanya dalam sekejap.  Kandidat yang tepat adalah tabel (atau <em>dataset</em> , seperti dalam PHP atau Python) yang tidak memiliki apa-apa selain bidang yang penting untuk logika bisnis.  Jika itu berubah, mempertahankan tes akan mudah: kami hanya mengubah bidang dalam dataset.  Contoh: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataTable: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">DataRow</span></span>] = <span class="hljs-type"><span class="hljs-type">Table</span></span>( (<span class="hljs-string"><span class="hljs-string">"Package ID"</span></span>, <span class="hljs-string"><span class="hljs-string">"Customer's role"</span></span>, <span class="hljs-string"><span class="hljs-string">"Item prices"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bonus value"</span></span>, <span class="hljs-string"><span class="hljs-string">"Expected final price"</span></span>) , (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"customer"</span></span>, <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>) , <span class="hljs-type"><span class="hljs-type">Vector</span></span>.empty , <span class="hljs-number"><span class="hljs-number">90.0</span></span>) , (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"customer"</span></span>, <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">250</span></span>) , <span class="hljs-type"><span class="hljs-type">Vector</span></span>.empty , <span class="hljs-number"><span class="hljs-number">225.0</span></span>) , (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"customer"</span></span>, <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>) , <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">40</span></span>) , <span class="hljs-number"><span class="hljs-number">210.0</span></span>) , (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"customer"</span></span>, <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>) , <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>) , <span class="hljs-number"><span class="hljs-number">279.0</span></span>) , (<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">"vip"</span></span> , <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>), <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>), <span class="hljs-number"><span class="hljs-number">252.0</span></span>) )</code> </pre> <br><p><img src="https://habrastorage.org/webt/5j/dt/2p/5jdt2pdn7hdzhepaut_bhukkcgm.jpeg"></p><br><p>  Dari tabel kami, kami membuat <em>kunci</em> - tautan entitas dengan ID.  Jika suatu entitas bergantung pada entitas lain, kunci untuk entitas lain itu juga akan dibuat.  Mungkin saja terjadi bahwa dua entitas yang berbeda membuat ketergantungan dengan ID yang sama, yang dapat menyebabkan <em>pelanggaran kunci utama</em> .  Namun, pada tahap ini sangat murah untuk mendeduplikasi kunci - karena semua yang dikandungnya adalah ID, kita dapat menempatkannya dalam koleksi yang melakukan deduplikasi bagi kita, misalnya, <code>Set</code> .  Jika ternyata tidak cukup, kami selalu dapat menerapkan deduplikasi yang lebih cerdas sebagai fungsi terpisah dan menyusunnya menjadi fungsi siklus hidup pengujian. </p><br><div class="spoiler">  <b class="spoiler_title">Kunci (contoh)</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Key</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PackageKey</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, userId: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Key</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PackageItemKey</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, packageId: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Key</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserKey</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Key</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BonusKey</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, packageId: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Key</span></span></span></span></code> </pre> </div></div><br><p>  Membuat data palsu untuk bidang (mis., Nama) didelegasikan ke kelas yang terpisah.  Setelah itu, dengan menggunakan kelas itu dan aturan konversi untuk kunci, kita mendapatkan objek Row yang dimaksudkan untuk dimasukkan ke dalam database. </p><br><div class="spoiler">  <b class="spoiler_title">Baris (contoh)</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SampleData</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">"test name"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">role</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">"customer"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">price</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bonusAmount</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">status</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">"new"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Row</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PackageRow</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, userId: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, status: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Row</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PackageItemRow</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, packageId: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, price: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Row</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRow</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, role: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Row</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BonusRow</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, packageId: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, bonusAmount: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Row</span></span></span></span></code> </pre> </div></div><br><p>  Data palsu biasanya tidak cukup, jadi kita perlu cara untuk menimpa bidang tertentu.  Untungnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lensa</a> hanyalah yang kita butuhkan - kita dapat menggunakannya untuk beralih ke semua baris yang dibuat dan hanya mengubah bidang yang kita butuhkan.  Karena lensa adalah fungsi yang menyamar, kita dapat menyusunnya seperti biasa, yang merupakan titik terkuat mereka. </p><br><div class="spoiler">  <b class="spoiler_title">Lense (contoh)</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changeUserRole</span></span></span></span>(userId: <span class="hljs-type"><span class="hljs-type">Int</span></span>, newRole: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">Set</span></span>[<span class="hljs-type"><span class="hljs-type">Row</span></span>] =&gt; <span class="hljs-type"><span class="hljs-type">Set</span></span>[<span class="hljs-type"><span class="hljs-type">Row</span></span>] = (rows: <span class="hljs-type"><span class="hljs-type">Set</span></span>[<span class="hljs-type"><span class="hljs-type">Row</span></span>]) =&gt; rows.modifyAll(_.each.when[<span class="hljs-type"><span class="hljs-type">UserRow</span></span>]) .using(r =&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r.id == userId) r.modify(_.role).setTo(newRole) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> r)</code> </pre> </div></div><br><p>  Berkat komposisi, kami dapat menerapkan berbagai optimasi dan peningkatan di dalam proses: misalnya, kami dapat mengelompokkan baris berdasarkan tabel untuk menyisipkannya dengan satu <code>INSERT</code> untuk mengurangi waktu pelaksanaan pengujian atau mencatat seluruh keadaan database. </p><br><div class="spoiler">  <b class="spoiler_title">Fungsi persiapan perlengkapan</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFixture</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">STATE</span></span>, <span class="hljs-type"><span class="hljs-type">FX</span></span>, <span class="hljs-type"><span class="hljs-type">ROW</span></span>, <span class="hljs-type"><span class="hljs-type">F</span></span>[_]]( state: <span class="hljs-type"><span class="hljs-type">STATE</span></span>, applyOverrides: <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">ROW</span></span>] =&gt; <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">ROW</span></span>] = x =&gt; x ): <span class="hljs-type"><span class="hljs-type">FX</span></span> = (extractKeys andThen deduplicateKeys andThen enrichWithSampleData andThen applyOverrides andThen logged andThen buildFixture) (state)</code> </pre> </div></div><br><p>  Akhirnya, semuanya memberi kita perlengkapan.  Dalam tes itu sendiri, tidak ada tambahan yang ditampilkan, kecuali untuk dataset awal - semua detail disembunyikan oleh komposisi fungsi. </p><br><p><img src="https://habrastorage.org/webt/b3/wz/cq/b3wzcqmqj3gomn-s-zycrakuegy.jpeg"></p><br><p>  Test suite kami sekarang terlihat seperti ini: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataTable: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">DataRow</span></span>] = <span class="hljs-type"><span class="hljs-type">Table</span></span>( (<span class="hljs-string"><span class="hljs-string">"Package ID"</span></span>, <span class="hljs-string"><span class="hljs-string">"Customer's role"</span></span>, <span class="hljs-string"><span class="hljs-string">"Item prices"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bonus value"</span></span>, <span class="hljs-string"><span class="hljs-string">"Expected final price"</span></span>) , (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"customer"</span></span>, <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>) , <span class="hljs-type"><span class="hljs-type">Vector</span></span>.empty , <span class="hljs-number"><span class="hljs-number">90.0</span></span>) , (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"customer"</span></span>, <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">250</span></span>) , <span class="hljs-type"><span class="hljs-type">Vector</span></span>.empty , <span class="hljs-number"><span class="hljs-number">225.0</span></span>) , (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"customer"</span></span>, <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>) , <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">40</span></span>) , <span class="hljs-number"><span class="hljs-number">210.0</span></span>) , (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"customer"</span></span>, <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>) , <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>) , <span class="hljs-number"><span class="hljs-number">279.0</span></span>) , (<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">"vip"</span></span> , <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>), <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>), <span class="hljs-number"><span class="hljs-number">252.0</span></span>) ) <span class="hljs-string"><span class="hljs-string">"If the buyer's role is"</span></span> - { <span class="hljs-string"><span class="hljs-string">"a customer"</span></span> - { <span class="hljs-string"><span class="hljs-string">"And the total price of items"</span></span> - { <span class="hljs-string"><span class="hljs-string">"&lt; 250 after applying bonuses - no discount"</span></span> - { <span class="hljs-string"><span class="hljs-string">"(case: no bonuses)"</span></span> in calculatePriceFor(dataTable, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"(case: has bonuses)"</span></span> in calculatePriceFor(dataTable, <span class="hljs-number"><span class="hljs-number">3</span></span>) } <span class="hljs-string"><span class="hljs-string">"&gt;= 250 after applying bonuses"</span></span> - { <span class="hljs-string"><span class="hljs-string">"If there are no bonuses - 10% off on the subtotal"</span></span> in calculatePriceFor(dataTable, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"If there are bonuses - 10% off on the subtotal after applying bonuses"</span></span> in calculatePriceFor(dataTable, <span class="hljs-number"><span class="hljs-number">4</span></span>) } } } <span class="hljs-string"><span class="hljs-string">"a vip - then they get a 20% off before applying bonuses and then all the other rules apply"</span></span> in calculatePriceFor(dataTable, <span class="hljs-number"><span class="hljs-number">5</span></span>) }</code> </pre> <br><p>  Dan kode pembantu: </p><br><div class="spoiler">  <b class="spoiler_title">Kode pembantu</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">// Reusable test's body def calculatePriceFor(table: Seq[DataRow], idx: Int) = testInDb( state = makeState(table.row(idx)), execute = runProductionCode(table.row(idx)._1), check = checkResult(table.row(idx)._5) ) def makeState(row: DataRow): Logger =&gt; DbFixture = { val items: Map[Int, Int] = ((1 to row._3.length) zip row._3).toMap val bonuses: Map[Int, Int] = ((1 to row._4.length) zip row._4).toMap MyFixtures.makeFixture( state = PackageRelationships .minimal(id = row._1, userId = 1) .withItems(items.keys) .withBonuses(bonuses.keys), overrides = changeRole(userId = 1, newRole = row._2) andThen items.map { case (id, newPrice) =&gt; changePrice(id, newPrice) }.foldPls andThen bonuses.map { case (id, newBonus) =&gt; changeBonus(id, newBonus) }.foldPls ) } def runProductionCode(id: Int): Database =&gt; Double = (db: Database) =&gt; new SomeProductionLogic(db).calculatePrice(id) def checkResult(expected: Double): Double =&gt; Future[Assertion] = (result: Double) =&gt; result shouldBe expected</span></span></code> </pre></div></div><br><p>  Menambahkan kasus uji baru ke dalam tabel adalah tugas sepele yang memungkinkan kita berkonsentrasi pada <strong>mencakup lebih banyak kasus pinggiran</strong> dan tidak menulis kode boilerplate. </p><br><h2 id="reusing-fixture-preparation-on-different-projects">  Menggunakan kembali persiapan perlengkapan pada berbagai proyek </h2><br><p>  Oke, jadi kami menulis banyak kode untuk menyiapkan perlengkapan dalam satu proyek tertentu, menghabiskan cukup banyak waktu dalam proses.  Bagaimana jika kita memiliki beberapa proyek?  Apakah kita ditakdirkan untuk menemukan kembali semuanya dari awal setiap saat? </p><br><p>  Kita dapat mengabstraksi persiapan fixture melalui model domain yang konkret.  Di dunia pemrograman fungsional, ada konsep <em>typeclasses</em> .  Tanpa merinci lebih jauh, mereka tidak seperti kelas di OOP, tetapi lebih seperti antarmuka karena mereka mendefinisikan perilaku tertentu dari beberapa kelompok tipe.  Perbedaan mendasar adalah bahwa mereka tidak diwariskan tetapi variabel instantiated seperti.  Namun, mirip dengan warisan, penyelesaian instance typeclass terjadi <em>pada waktu kompilasi</em> .  Dalam pengertian ini, typeclasses dapat dipahami seperti <em>metode ekstensi</em> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotlin</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C #</a> . </p><br><p>  Untuk mencatat suatu objek, kita tidak perlu tahu apa yang ada di dalamnya, bidang apa dan metode yang dimilikinya.  Yang kami pedulikan hanyalah memiliki <code>log()</code> perilaku <code>log()</code> dengan tanda tangan tertentu.  Memperluas setiap kelas tunggal dengan antarmuka <code>Logged</code> akan sangat membosankan dan bahkan tidak mungkin dalam banyak kasus - misalnya, untuk perpustakaan atau kelas standar.  Dengan typeclasses, ini jauh lebih mudah.  Kita dapat membuat instance dari typeclass yang disebut <code>Logged</code> , misalnya, untuk fixture untuk mencatatnya dalam format yang dapat dibaca manusia.  Untuk segala sesuatu yang tidak memiliki instance dari <code>Logged</code> kami dapat memberikan fallback: sebuah instance untuk tipe <code>Any</code> yang menggunakan metode standar <code>toString()</code> untuk mencatat setiap objek dalam representasi internal mereka secara gratis. </p><br><div class="spoiler">  <b class="spoiler_title">Contoh dari typeclass Logged dan instansnya</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logged</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span></span>(a: <span class="hljs-type"><span class="hljs-type">A</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> logger: <span class="hljs-type"><span class="hljs-type">Logger</span></span>): <span class="hljs-type"><span class="hljs-type">A</span></span> } <span class="hljs-comment"><span class="hljs-comment">// For all Futures implicit def futureLogged[T]: Logged[Future[T]] = new Logged[Future[T]] { override def log(futureT: Future[T])(implicit logger: Logger): Future[T] = { futureT.map { t =&gt; // map on a Future lets us modify its result after it finishes logger.info(t.toString()) t } } } // Fallback in case there are no suitable implicits in scope implicit def anyNoLogged[T]: Logged[T] = new Logged[T] { override def log(t: T)(implicit logger: Logger): T = { logger.info(t.toString()) t } }</span></span></code> </pre> </div></div><br><p>  Selain logging, kita bisa menggunakan pendekatan ini di seluruh proses pembuatan fixture.  Solusi kami mengusulkan cara abstrak untuk membuat perlengkapan basis data dan satu set typeclasses untuk pergi dengannya.  Ini adalah proyek yang menggunakan tanggung jawab solusi untuk mengimplementasikan contoh-contoh kacamata ini agar semuanya berfungsi. </p><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">// Fixture preparation function def makeFixture[STATE, FX, ROW, F[_]]( state: STATE, applyOverrides: F[ROW] =&gt; F[ROW] = x =&gt; x ): FX = (extractKeys andThen deduplicateKeys andThen enrichWithSampleData andThen applyOverrides andThen logged andThen buildFixture) (state) override def extractKeys(implicit toKeys: ToKeys[DbState]): DbState =&gt; Set[Key] = (db: DbState) =&gt; db.toKeys() override def enrichWithSampleData(implicit enrich: Enrich[Key]): Key =&gt; Set[Row] = (key: Key) =&gt; key.enrich() override def buildFixture(implicit insert: Insertable[Set[Row]]): Set[Row] =&gt; DbFixture = (rows: Set[Row]) =&gt; rows.insert() // Behavior of splitting something (eg a dataset) into keys trait ToKeys[A] { def toKeys(a: A): Set[Key] // Something =&gt; Set[Key] } // ...converting keys into rows trait Enrich[A] { def enrich(a: A): Set[Row] // Set[Key] =&gt; Set[Row] } // ...and inserting rows into the database trait Insertable[A] { def insert(a: A): DbFixture // Set[Row] =&gt; DbFixture } // To be implemented in our project (see the example at the end of the article) implicit val toKeys: ToKeys[DbState] = ??? implicit val enrich: Enrich[Key] = ??? implicit val insert: Insertable[Set[Row]] = ???</span></span></code> </pre> <br><p>  Saat merancang alat persiapan fixture ini, saya menggunakan <em>prinsip</em> - <em>prinsip SOLID</em> sebagai kompas untuk memastikan itu dapat dipertahankan dan dapat diperpanjang: </p><br><ul><li>  <em>Prinsip Tanggung Jawab Tunggal</em> : setiap typeclass menggambarkan satu dan hanya satu perilaku jenis. </li><li>  <em>Prinsip Terbuka / Tertutup</em> : kami tidak memodifikasi kelas produksi mana pun;  sebagai gantinya, kami memperluas mereka dengan contoh dari typeclasses. </li><li>  <em>Prinsip Pergantian Liskov</em> tidak berlaku di sini karena kami tidak menggunakan warisan. </li><li>  <em>Prinsip Segregasi Antarmuka</em> : kami menggunakan banyak jenis kacamata khusus yang bertentangan dengan kacamata jenis global. </li><li>  <em>Prinsip Ketergantungan Inversi</em> : fungsi persiapan fixture tidak tergantung pada jenis beton, tetapi lebih pada jenis kacamata abstrak. </li></ul><br><p>  Setelah memastikan bahwa semua prinsip terpenuhi, kami dapat dengan aman mengasumsikan bahwa solusi kami dapat dipertahankan dan cukup diperpanjang untuk digunakan dalam berbagai proyek. </p><br><p>  Setelah menulis fungsi siklus hidup tes dan solusi untuk persiapan fixture, yang juga terlepas dari model domain konkret pada aplikasi yang diberikan, kami siap untuk memperbaiki semua tes yang tersisa. </p><br><h2 id="bottom-line">  Intinya </h2><br><p>  Kami telah beralih dari gaya desain uji tradisional (langkah-demi-langkah) ke fungsional.  Gaya selangkah demi selangkah berguna sejak awal dan dalam proyek berukuran lebih kecil, karena tidak membatasi pengembang dan tidak memerlukan pengetahuan khusus.  Namun, ketika jumlah tes menjadi terlalu besar, gaya seperti itu cenderung rontok.  Menulis tes dengan gaya fungsional mungkin tidak akan menyelesaikan semua masalah pengujian Anda, tetapi mungkin secara signifikan meningkatkan penskalaan dan mempertahankan tes dalam proyek, di mana ada ratusan atau ribuan dari mereka.  Tes yang ditulis dengan gaya fungsional ternyata lebih ringkas dan terfokus pada hal-hal penting (seperti data, kode yang diuji, dan hasil yang diharapkan), bukan pada langkah-langkah perantara. </p><br><p>  Selain itu, kami telah mengeksplorasi seberapa kuat komposisi fungsi dan jenis kacamata dalam pemrograman fungsional.  Dengan bantuan mereka, cukup mudah untuk merancang solusi dengan mempertimbangkan kemampuan untuk diperluas dan digunakan kembali. </p><br><p>  Sejak mengadopsi gaya beberapa bulan lalu, tim kami harus meluangkan upaya untuk beradaptasi, tetapi pada akhirnya, kami menikmati hasilnya.  Tes baru ditulis lebih cepat, log membuat hidup lebih nyaman, dan set data berguna untuk memeriksa setiap kali ada pertanyaan tentang seluk-beluk logika tertentu.  Tim kami bertujuan untuk mengalihkan semua tes ke gaya baru ini secara bertahap. </p><br><hr><br><p>  Tautan ke solusi dan contoh lengkap dapat ditemukan di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github</a> .  Bersenang-senang dengan pengujian Anda! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465211/">https://habr.com/ru/post/id465211/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465189/index.html">Workflow Satu Tim Pengembangan Sprint</a></li>
<li><a href="../id465191/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 25. Studi mendalam tentang IPv6</a></li>
<li><a href="../id465193/index.html">Membangun proyek Android dalam wadah buruh pelabuhan</a></li>
<li><a href="../id465203/index.html">Gajah perusahaan</a></li>
<li><a href="../id465209/index.html">Kami mempelajari data paspor seseorang berdasarkan nama (jika ada jaminan)</a></li>
<li><a href="../id465215/index.html">Apa yang harus dibaca pemimpin tim dan stasiun layanan: pilihan 50 buku dengan nilai dan banyak lagi</a></li>
<li><a href="../id465217/index.html">Acronis True Image 2020: Skema Replikasi Baru dan Perlindungan yang Ditingkatkan</a></li>
<li><a href="../id465221/index.html">Seperti apa register dalam 1C di hadapan OOP</a></li>
<li><a href="../id465223/index.html">Bagaimana memanfaatkan keamanan kertas secara praktis, atau mengapa kita perlu kepatuhan dengan 152-Ğ¤Ğ— dan PCI DSS dalam satu cloud</a></li>
<li><a href="../id465227/index.html">Augmented Reality dalam Retail Online</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>