<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç¨ ü§Ω üëáüèΩ Manfaat mengetik kuat di C ++: pengalaman langsung üö¥üèº üëâüèæ üò≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Program kami memproses paket jaringan, khususnya, tajuk TCP / IP / etc. Di dalamnya, nilai numerik - offset, penghitung, alamat - disajikan dalam urut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manfaat mengetik kuat di C ++: pengalaman langsung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471272/"> Program kami memproses paket jaringan, khususnya, tajuk TCP / IP / etc.  Di dalamnya, nilai numerik - offset, penghitung, alamat - disajikan dalam urutan byte jaringan (big-endian);  kami sedang mengerjakan x86 (little-endian).  Dalam struktur standar yang menggambarkan header, bidang ini diwakili oleh tipe integer sederhana ( <code>uint16_t</code> , <code>uint16_t</code> ).  Setelah beberapa bug karena kami lupa mengubah urutan byte, kami memutuskan untuk mengganti tipe bidang dengan kelas yang melarang konversi implisit dan operasi atipikal.  Di bawah cut adalah kode utilitarian dan contoh spesifik kesalahan yang pengetikan ketat terungkap. <br><a name="habracut"></a><br><h2>  Pesanan byte </h2><br>  Likbez bagi mereka yang tidak mengetahui urutan byte (endianness, byte order).  Secara lebih rinci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sudah ada di "Habr√©"</a> . <br><br>  Dalam notasi angka yang biasa, mereka bergerak dari yang tertua (kiri) ke yang termuda (kanan) di sebelah kiri: 432 <sub>10</sub> = 4 √ó 10 <sup>2</sup> + 3 √ó 10 <sup>1</sup> + 2 √ó 10 <sup>0</sup> .  Tipe data integer memiliki ukuran tetap, misalnya, 16 bit (angka dari 0 hingga 65535).  Mereka disimpan dalam memori sebagai dua byte, misalnya, 432 <sub>10</sub> = 01b0 <sub>16</sub> , yaitu, byte 01 dan b0. <br><br>  Cetak byte dari nomor ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdio&gt; // printf() #include &lt;cstdint&gt; // uint8_t, uint16_t int main() { uint16_t value = 0x01b0; printf("%04x\n", value); const auto bytes = reinterpret_cast&lt;const uint8_t*&gt;(&amp;value); for (auto i = 0; i &lt; sizeof(value); i++) { printf("%02x ", bytes[i]); } }</span></span></span></span></code> </pre><br>  Pada prosesor Intel atau AMD (x86) biasa, kami mendapatkan yang berikut: <br><br><pre> <code class="plaintext hljs">01b0 b0 01</code> </pre><br>  Bytes dalam memori terletak dari yang termuda ke yang tertua, dan tidak seperti saat menulis angka.  Pesanan ini disebut <i>little-endian (LE).</i>  Hal yang sama berlaku untuk angka 4-byte.  Urutan byte ditentukan oleh arsitektur prosesor.  Urutan "asli" untuk prosesor juga disebut <i>urutan CPU atau host (urutan byte CPU / host).</i>  Dalam kasus kami, urutan byte host adalah little-endian. <br><br>  Namun, Internet tidak dilahirkan pada x86, dan di sana urutan byte berbeda - <i>dari yang tertua ke yang termuda (big-endian, BE).</i>  Mereka mulai menggunakannya di header protokol jaringan (IP, TCP, UDP), sehingga big-endian juga disebut <i>urutan byte jaringan.</i> <br><br>  Contoh: port 443 (1bb <sub>16</sub> ), yang menggunakan HTTPS, ditulis dalam header TCP bytes bb 01, yang bila dibaca akan menghasilkan bb01 <sub>16</sub> = 47873. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  uint16_t  uint32_t     . struct tcp_hdr { uint16_t th_sport; uint16_t th_dport; uint32_t th_seq; uint32_t th_ack; uint32_t th_flags2 : 4; uint32_t th_off : 4; uint8_t th_flags; uint16_t th_win; uint16_t th_sum; uint16_t th_urp; } __attribute__((__packed__)); tcp_hdr* tcp = ...; //      // : dst_port  BE,  443  LE. if (tcp-&gt;dst_port == 443) { ... } // : ++  LE,  sent_seq  BE. tcp-&gt;sent_seq++;</span></span></code> </pre><br>  Urutan byte angka dapat dikonversi.  Sebagai contoh, untuk <code>uint16_t</code> terdapat fungsi standar <code>htons()</code> (pertama-tama <b>dan</b> selanjutnya untuk <b>s</b> hort integer - dari pesanan host ke pesanan jaringan untuk bilangan bulat pendek) dan sebaliknya <code>ntohs()</code> .  Demikian pula, untuk <code>uint32_t</code> ada <code>htonl()</code> dan <code>ntohl()</code> (panjang adalah bilangan bulat panjang). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// :  BE    BE . if (tcp-&gt;dst_port == htons(443)) { ... } //   BE     LE,   1, //   LE    BE. tcp-&gt;sent_seq = htonl(ntohl(tcp-&gt;sent_seq) + 1);</span></span></code> </pre><br>  Sayangnya, kompiler tidak tahu dari mana nilai tertentu dari variabel tipe <code>uint32_t</code> berasal, dan tidak memperingatkan jika Anda mencampur nilai dengan pesanan byte yang berbeda dan mendapatkan hasil yang salah. <br><br><h2>  Mengetik dengan kuat </h2><br>  Risiko membingungkan pesanan byte jelas, bagaimana menghadapinya? <br><br><ul><li>  <b>Ulasan kode.</b>  Ini adalah prosedur wajib dalam proyek kami.  Sayangnya, penguji setidaknya ingin mempelajari kode yang memanipulasi byte: "Saya melihat <code>htons()</code> - mungkin, penulis memikirkan segalanya". </li><li>  <b>Disiplin,</b> aturan seperti: BE hanya dalam paket, semua variabel di LE.  Ini tidak selalu masuk akal, misalnya, jika Anda perlu memeriksa port terhadap tabel hash, lebih efisien untuk menyimpannya dalam urutan byte jaringan dan mencari "apa adanya". </li><li>  <b>Tes.</b>  Seperti yang Anda tahu, mereka tidak menjamin tidak adanya kesalahan.  Data dapat dicocokkan dengan buruk (1.1.1.1 tidak berubah saat mengubah urutan byte) atau disesuaikan dengan hasilnya. </li></ul><br>  Ketika bekerja dengan jaringan, Anda tidak dapat mengabaikan urutan byte, jadi saya ingin membuatnya tidak mungkin untuk mengabaikannya saat menulis kode.  Selain itu, kami tidak hanya memiliki nomor di BE - itu adalah nomor port, alamat IP, nomor urut TCP, checksum.  Satu tidak dapat ditugaskan ke yang lain, bahkan jika jumlah bit cocok. <br><br>  Solusinya diketahui - pengetikan ketat, yaitu, tipe terpisah untuk port, alamat, angka.  Selain itu, jenis ini harus mendukung konversi BE / LE.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Boost.Endian</a> tidak cocok untuk kita, karena tidak ada Boost dalam proyek ini. <br><br>  Ukuran proyek sekitar 40 ribu baris dalam C ++ 17.  Jika Anda membuat tipe pembungkus yang aman dan menimpa struktur header pada mereka, semua tempat di mana ada pekerjaan dengan BE akan secara otomatis berhenti mengkompilasi.  Anda harus melalui semuanya sekali, tetapi kode baru hanya akan aman. <br><br><div class="spoiler">  <b class="spoiler_title">Nomor kelas big-endian</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdint&gt; #include &lt;iosfwd&gt; #define PACKED __attribute__((packed)) constexpr auto bswap(uint16_t value) noexcept { return __builtin_bswap16(value); } constexpr auto bswap(uint32_t value) noexcept { return __builtin_bswap32(value); } template&lt;typename T&gt; struct Raw { T value; }; template&lt;typename T&gt; Raw(T) -&gt; Raw&lt;T&gt;; template&lt;typename T&gt; struct BigEndian { using Underlying = T; using Native = T; constexpr BigEndian() noexcept = default; constexpr explicit BigEndian(Native value) noexcept : _value{bswap(value)} {} constexpr BigEndian(Raw&lt;Underlying&gt; raw) noexcept : _value{raw.value} {} constexpr Underlying raw() const { return _value; } constexpr Native native() const { return bswap(_value); } explicit operator bool() const { return static_cast&lt;bool&gt;(_value); } bool operator==(const BigEndian&amp; other) const { return raw() == other.raw(); } bool operator!=(const BigEndian&amp; other) const { return raw() != other.raw(); } friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const BigEndian&amp; value) { return out &lt;&lt; value.native(); } private: Underlying _value{}; } PACKED;</span></span></span></span></code> </pre><br></div></div><br><ul><li>  File header dengan tipe ini akan disertakan di mana-mana, jadi alih-alih <code>&lt;iostream&gt;</code> yang ringan <code>&lt;iosfwd&gt;</code> . </li><li>  Alih-alih <code>htons()</code> , dll. - intrinsik kompiler cepat.  Secara khusus, mereka <code>constexpr</code> propagasi konstan, oleh karena itu konstruktor <code>constexpr</code> . </li><li>  Terkadang sudah ada nilai <code>uint16_t</code> / <code>uint16_t</code> terletak di BE.  Struktur <code>Raw&lt;T&gt;</code> dengan panduan deduksi memungkinkan Anda dengan mudah membuat <code>BigEndian&lt;T&gt;</code> darinya. </li></ul><br>  Poin kontroversial di sini adalah <code>PACKED</code> : struktur paket dianggap kurang optimal.  Satu-satunya jawaban adalah mengukur.  Tolok ukur kode kami tidak mengungkapkan adanya pelambatan.  Selain itu, dalam hal paket jaringan, posisi bidang di header masih tetap. <br><br>  Dalam kebanyakan kasus, BE tidak memerlukan operasi selain perbandingan.  Nomor urut harus dilipat dengan benar dengan LE: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BE16 = BigEndian&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BE32 = BigEndian&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Seqnum</span></span></span><span class="hljs-class"> :</span></span> BE32 { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BE32::BE32; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Integral&gt; Seqnum <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(Integral increment) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_integral_v&lt;Integral&gt;); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Seqnum{<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(native() + increment)}; } } PACKED; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IP</span></span></span><span class="hljs-class"> :</span></span> BE32 { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BE32::BE32; } PACKED; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">L4Port</span></span></span><span class="hljs-class"> :</span></span> BE16 { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BE16::BE16; } PACKED;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Struktur TCP Header Aman</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TCPFlag : <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> { TH_FIN = <span class="hljs-number"><span class="hljs-number">0x01</span></span>, TH_SYN = <span class="hljs-number"><span class="hljs-number">0x02</span></span>, TH_RST = <span class="hljs-number"><span class="hljs-number">0x04</span></span>, TH_PUSH = <span class="hljs-number"><span class="hljs-number">0x08</span></span>, TH_ACK = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, TH_URG = <span class="hljs-number"><span class="hljs-number">0x20</span></span>, TH_ECE = <span class="hljs-number"><span class="hljs-number">0x40</span></span>, TH_CWR = <span class="hljs-number"><span class="hljs-number">0x80</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TCPFlags = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">underlying_type_t</span></span>&lt;TCPFlag&gt;; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCPHeader</span></span></span><span class="hljs-class"> {</span></span> L4Port th_sport; L4Port th_dport; Seqnum th_seq; Seqnum th_ack; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> th_flags2 : <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> th_off : <span class="hljs-number"><span class="hljs-number">4</span></span>; TCPFlags th_flags; BE16 th_win; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> th_sum; BE16 th_urp; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> header_length() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> th_off &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_header_length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ th_off = len &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>* payload() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) + header_length(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> uint8_t* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) + header_length(); } }; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(TCPHeader) == <span class="hljs-number"><span class="hljs-number">20</span></span>);</code> </pre></div></div><br><ul><li>  <code>TCPFlag</code> dapat dibuat <code>enum class</code> , tetapi dalam praktiknya hanya dua operasi yang dilakukan pada flag: memeriksa entri ( <code>&amp;</code> ) atau mengganti flag dengan kombinasi ( <code>|</code> ) - tidak ada kebingungan. </li><li>  Bidang bit dibiarkan primitif, tetapi metode akses yang aman dibuat. </li><li>  Nama bidang dibiarkan klasik. </li></ul><br><h2>  Hasil </h2><br>  Sebagian besar pengeditan adalah hal sepele.  Kode lebih bersih: <br><br><pre> <code class="diff hljs"> auto tcp = packet-&gt;tcp_header(); - return make_response(packet, - cookie_make(packet, rte_be_to_cpu_32(tcp-&gt;th_seq)), - rte_cpu_to_be_32(rte_be_to_cpu_32(tcp-&gt;th_seq) + 1), - TH_SYN | TH_ACK); + return make_response(packet, cookie_make(packet, tcp-&gt;th_seq.native()), + tcp-&gt;th_seq + 1, TH_SYN | TH_ACK); }</code> </pre><br>  Pada bagian, tipe mendokumentasikan kode: <br><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- void check_packet(int64_t, int64_t, uint8_t, bool); + void check_packet(std::optional&lt;Seqnum&gt;, std::optional&lt;Seqnum&gt;, TCPFlags, bool);</span></span></code> </pre><br>  Tiba-tiba, ternyata Anda dapat salah membaca ukuran jendela TCP, sementara tes unit akan berlalu dan bahkan lalu lintas akan dikejar: <br><br><pre> <code class="diff hljs"> //  window size auto wscale_ratio = options().wscale_dst - options().wscale_src; if (wscale_ratio &lt; 0) { - auto window_size = header.window_size() / (1 &lt;&lt; (-wscale_ratio)); + auto window_size = header.window_size().native() / (1 &lt;&lt; (-wscale_ratio)); if (header.window_size() &amp;&amp; window_size &lt; 1) { window_size = WINDOW_SIZE_MIN; } header_out.window_size(window_size); } else { - auto window_size = header.window_size() * (1 &lt;&lt; (wscale_ratio)); + auto window_size = header.window_size().native() * (1 &lt;&lt; (wscale_ratio)); if (window_size &gt; WINDOW_SIZE_MAX) { window_size = WINDOW_SIZE_MAX; }</code> </pre><br>  Contoh kesalahan logis: pengembang kode asli berpikir bahwa fungsi menerima BE, meskipun sebenarnya tidak.  Saat mencoba menggunakan <code>Raw{}</code> alih-alih <code>0</code> program tidak kompilasi (untungnya, ini hanya tes unit).  Segera kami melihat pilihan data yang gagal: kesalahan akan ditemukan lebih cepat jika tidak 0 telah digunakan, yang sama dalam urutan byte apa pun. <br><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- auto cookie = cookie_make_inner(tuple, rte_be_to_cpu_32(0)); + auto cookie = cookie_make_inner(tuple, 0);</span></span></code> </pre><br>  Contoh serupa: pertama, kompiler menunjukkan ketidakcocokan antara <code>def_seq</code> dan jenis <code>cookie</code> , kemudian menjadi jelas mengapa tes lulus sebelumnya - konstanta seperti itu. <br><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- const uint32_t def_seq = 0xA7A7A7A7; - const uint32_t def_ack = 0xA8A8A8A8; + const Seqnum def_seq{0x12345678}; + const Seqnum def_ack{0x90abcdef}; ... - auto cookie = rte_be_to_cpu_32(_tcph-&gt;th_ack); + auto cookie = _tcph-&gt;th_ack; ASSERT_NE(def_seq, cookie);</span></span></code> </pre><br><h2>  Ringkasan </h2><br>  Intinya adalah: <br><br><ul><li>  Ditemukan satu bug dan beberapa kesalahan logis dalam unit test. </li><li>  Refactoring membuat saya memilah-milah tempat meragukan, keterbacaan meningkat. </li><li>  Performanya telah dipertahankan, tetapi bisa saja menurun - diperlukan tolok ukur. </li></ul><br>  Ketiga poin itu penting bagi kami, jadi kami pikir refactoring sepadan. <br><br>  Apakah Anda mengasuransikan diri terhadap kesalahan dengan tipe ketat? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471272/">https://habr.com/ru/post/id471272/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471262/index.html">Holivar. Sejarah Runet. Bagian 5. Troll: Belajar, printer panik, Tembaga</a></li>
<li><a href="../id471264/index.html">Memilih alternatif untuk MailChimp: mengapa beralih dan produk mana yang harus dipilih</a></li>
<li><a href="../id471266/index.html">Masa depan ada di sini atau disandikan tepat di browser</a></li>
<li><a href="../id471268/index.html">Memahami broker pesan. Mempelajari mekanisme pengiriman pesan melalui ActiveMQ dan Kafka. Bab 2. ActiveMQ</a></li>
<li><a href="../id471270/index.html">Kami mengotomatiskan penerimaan data pada kecepatan memuat situs dari Google PageSpeed ‚Äã‚ÄãInsights [templat]</a></li>
<li><a href="../id471278/index.html">Pembuatan teks dalam bahasa Rusia berdasarkan templat</a></li>
<li><a href="../id471282/index.html">Mencari pneumonia di rontgen dengan Fast.ai</a></li>
<li><a href="../id471288/index.html">Membuat wajah karakter untuk game "OnAir"</a></li>
<li><a href="../id471294/index.html">Puisi tentang Haskell, C ++ dan programmer</a></li>
<li><a href="../id471296/index.html">Lean Manufacturing - Alat untuk Efisiensi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>