<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ö üë®üèΩ‚Äçü§ù‚Äçüë®üèª üõ∞Ô∏è Erstellen Sie die R√§nder einer prozedural generierten Karte üôåüèª üë©‚Äçüë¶‚Äçüë¶ ‚úåüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Scott Turner arbeitet weiterhin an seinem prozedural generierten Spiel und hat sich nun entschlossen, das Problem der Gestaltung der Kartengrenzen anz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen Sie die R√§nder einer prozedural generierten Karte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444190/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ce/ea0/3df/0ceea03df1f07131e0ad27e6bbd45731.png" alt="Bild"></div><br>  <i>Scott Turner arbeitet weiterhin an seinem prozedural generierten Spiel und hat sich nun entschlossen, das Problem der Gestaltung der Kartengrenzen anzugehen.</i>  <i>Dazu muss er einige schwierige Probleme l√∂sen und sogar eine eigene Sprache zur Beschreibung von Grenzen erstellen.</i> <br><br>  Grenzen blieben ein wichtiges Element von Fantasy-Karten, die schon seit einiger Zeit auf meiner Liste standen.  Funktionale Karten haben normalerweise eine einfache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grenzlinie</a> , aber Fantasy-Karten und mittelalterliche Karten, von denen die ersteren oft Ideen entlehnen, haben ziemlich durchdachte und k√ºnstlerische Grenzen.  Diese Grenzen machen deutlich, dass die Karte absichtlich fantastisch gemacht wurde, und geben dem Betrachter ein Gef√ºhl des Staunens. <br><br>  Derzeit gibt es in meinem Spiel <b>Dragons Abound</b> einige einfache M√∂glichkeiten, Grenzen zu ziehen.  Sie kann eine einfache oder doppelte Linie um den Umfang der Karte ziehen und einfache Elemente in die Ecken einf√ºgen, wie in diesen Abbildungen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aed/9f8/477/aed9f8477ef53b5550b742ea1fde36b2.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/37e/bac/cac37ebac81815955dfc940bacdc2eff.png"></div><br>  Das Spiel kann auch ein Feld am unteren Rand des Rahmens f√ºr den Namen der Karte hinzuf√ºgen.  In <b>Dragons Abound</b> gibt es verschiedene Variationen dieses Feldes, einschlie√ülich so komplexer Elemente wie gef√§lschter Schraubenk√∂pfe: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42f/f6f/c3a/42ff6fc3adae5b40293bb82d5a1be325.png"></div><br>  Diese Namensfelder sind unterschiedlich, werden jedoch alle manuell erstellt. <br><br>  Ein interessanter Aspekt der Grenzen von Fantasy-Karten ist, dass sie sowohl kreativ als auch als Vorlage dienen.  Oft bestehen sie aus einer kleinen Anzahl einfacher Elemente, die auf unterschiedliche Weise kombiniert werden, um ein einzigartiges Ergebnis zu erzielen.  Wie immer besteht der erste Schritt bei der Arbeit mit einem neuen Thema f√ºr mich darin, eine Sammlung von Kartenbeispielen zu studieren, einen Katalog von Randelementtypen zu erstellen und deren Erscheinungsbild zu untersuchen. <br><a name="habracut"></a><br>  Der einfachste Rand ist eine Linie, die entlang der R√§nder der Karte verl√§uft und deren Grenzen angibt.  Wie ich oben sagte, wird es auch als "Rahmenlinie" bezeichnet: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99f/c81/c98/99fc81c98e1092077272081464d28752.png"></div><br>  Es gibt auch eine Variation mit der Position der R√§nder innerhalb der Karte.  In dieser Version erreicht die Karte die Bildr√§nder, aber der Rand erstellt einen virtuellen Rand innerhalb des Bildes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43f/aef/1db/43faef1db7bf3af195c857d7ed673710.png"></div><br>  Dies kann mit jeder Art von Rahmen durchgef√ºhrt werden, wird jedoch normalerweise nur mit einfachen R√§ndern wie dem Rand eines Rahmens verwendet. <br><br>  Ein beliebtes Designkonzept f√ºr Fantasy-Karten besteht darin, zu simulieren, als ob sie auf altem zerrissenem Pergament gezeichnet w√§ren.  Manchmal wird dies durch Zeichnen des Randes als raue Kante des Papiers realisiert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/907/cb2/ff1/907cb2ff125bbd178f9a16717e5e724f.png"></div><br>  Hier ist ein komplexeres Beispiel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/751/860/d6e/751860d6e43ed2e857cf6f3ba7f766e0.png"></div><br>  Nach meiner Erfahrung ist diese Methode weniger popul√§r geworden, weil digitale Werkzeuge zum Einsatz gekommen sind.  Wenn Sie m√∂chten, dass die Karte wie ein altes zerrissenes Pergament aussieht, ist es einfacher, die Textur des Pergaments darauf aufzutragen, als es von Hand zu zeichnen. <br><br>  Das leistungsst√§rkste Werkzeug zum Erstellen von Kartenr√§ndern ist die Wiederholbarkeit.  Im einfachsten Fall reicht es aus, eine einzelne Zeile zu wiederholen, um zwei Zeilen zu erstellen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/139/e12/31d139e129fe513e07937c5a2bd88979.png"></div><br>  Sie k√∂nnen der Karte Interesse hinzuf√ºgen, indem Sie den Stil des wiederholten Elements variieren. In diesem Fall kombinieren Sie eine dicke einzelne Linie mit einer d√ºnnen einzelnen Linie: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/530/ccd/118/530ccd11872f4aa6a32d4b3271cf94f3.png"></div><br>  Je nach Element sind verschiedene Stilvarianten m√∂glich.  In diesem Beispiel wiederholt sich die Linie, aber die Farbe √§ndert sich: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc7/89e/96c/fc789e96ccfba58ac4cb595e5ec33fb7.png"></div><br>  Um komplexere Muster zu erstellen, k√∂nnen Sie die ‚Äûwiederholbare Wiederholbarkeit‚Äú verwenden.  Dieser Rand besteht aus ungef√§hr f√ºnf einzelnen Linien mit unterschiedlichen Breiten und Abst√§nden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/488/ef4/796488ef402e59ed7e092e0e14ff2469.png"></div><br>  Dieser Rand wiederholt die Linien, trennt sie jedoch so, dass sie wie zwei separate d√ºnne R√§nder aussehen.  In diesem Teil des Beitrags werde ich nicht auf die Eckenverarbeitung eingehen, aber unterschiedliche Winkel f√ºr die beiden Linien helfen auch dabei, diesen Unterschied zu erzeugen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/fd8/336/97bfd833697b9278660772c1bd04ee46.png"></div><br>  Sind das zwei Zeilen, vier oder sechs?  Ich denke, es h√§ngt alles davon ab, wie du sie zeichnest! <br><br>  Ein weiteres Element der Stilisierung ist das F√ºllen des Raums zwischen Elementen mit Farbe, Muster oder Textur.  In diesem Beispiel wurde der Rand aufgrund der Akzentfarbe zwischen den beiden Linien interessanter: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d8/ccf/158/1d8ccf158b9ae0378ddaef1031ba15c9.png"></div><br>  Hier ist ein Beispiel, wie der Rand mit einem Muster gef√ºllt wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f87/37d/bb2/f8737dbb215166947e42f0da1b45cfc7.png"></div><br>  Au√üerdem k√∂nnen Elemente so gestaltet werden, dass sie dreidimensional aussehen.  Hier ist eine Karte, in der der Rand so schattiert ist, dass er volumin√∂s aussieht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a80/25b/695/a8025b69549773f8935d2b37680401a3.png"></div><br>  In dieser Karte ist der Rand dreidimensional schattiert und wird mit der Position der R√§nder innerhalb der Kartenr√§nder kombiniert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36c/899/9e7/36c8999e74172c962aef40a4a9e3addc.png"></div><br>  Ein weiteres h√§ufiges Randelement ist die Skala in Form von mehrfarbigen Streifen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ee/f62/0b8/4eef620b830eb0249d019229140e34e6.png"></div><br>  Diese Streifen bilden ein Raster ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kartografisches Raster</a> ).  Auf realen Karten hilft der Ma√üstab bei der Bestimmung von Entfernungen, auf Fantasy-Karten ist er jedoch haupts√§chlich ein dekoratives Element. <br><br>  Diese Streifen werden normalerweise in Schwarzwei√ü gezeichnet, aber manchmal wird Rot oder eine andere Farbe hinzugef√ºgt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/450/f0f/f67/450f0ff67ac1fdf5c5e2ffaf8fbe80c0.png"></div><br>  Dieses Element kann auch mit anderen kombiniert werden, wie in diesem Beispiel mit Linien und Skalierung: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/313/d56/29d/313d5629d6ec8b8d7c7c4c1ead322a09.png"></div><br>  Dieses Beispiel ist etwas ungew√∂hnlich.  Normalerweise ist die Skala (falls vorhanden) das innerste Element der Grenze. <br><br>  Auf dieser Karte gibt es verschiedene Ma√üst√§be mit unterschiedlichen Aufl√∂sungen (sowie seltsame Runennoten!): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/cd6/217/74bcd62173160e440a4ee6cfad2128c1.png"></div><br>  (Auf Reddit teilte mir Benutzer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AbouBenAdhem</a> mit, dass Runenzeichen die Nummern 48 und 47 sind, die in babylonischer Keilschrift geschrieben sind. Au√üerdem haben ‚ÄûSkalen mit unterschiedlichen Aufl√∂sungen‚Äú sechs Unterteilungen, die in zehn kleinere Unterteilungen unterteilt sind, was dem babylonischen Hexadezimalzahlensystem entspricht. Normalerweise Ich gebe die Quellen der Karten an, aber es gibt zu viele kleine St√ºcke in diesem Beitrag, so dass ich mich nicht darum gek√ºmmert habe. Diese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Karte wurde</a> jedoch von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thomas Ray</a> f√ºr den Autor S.E. Boleyn erstellt, sodass die Aktion in seinen B√ºchern m√∂glicherweise im Gefolge Babylons stattfindet.) <br><br>  Neben Linien und Ma√üst√§ben ist das h√§ufigste Element ein sich wiederholendes geometrisches Muster.  Oft besteht es aus Teilen wie Kreisen, Rauten und Rechtecken: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31c/6ba/f61/31c6baf612bf2fa11a13905e4482d82e.png"></div><br>  Geometrische Elemente k√∂nnen wie Linien schattiert werden, damit sie dreidimensional aussehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/cc8/c33/43ecc8c33bbf3143ba32c18b878d16e2.png"></div><br>  Komplexe Grenzen k√∂nnen erstellt werden, indem diese Elemente auf unterschiedliche Weise kombiniert werden.  Hier ist der Rand, der Linien, geometrische Muster und Skalierungen kombiniert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  Die oben gezeigten Beispiele waren digitale Karten, aber das Gleiche kann nat√ºrlich auch mit handgeschriebenen Karten gemacht werden.  Hier ist ein Beispiel f√ºr ein einfaches geometrisches Muster, das von Hand erstellt wurde: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f7/c2d/e3d/6f7c2de3d5db82a9c7e9884d726be98e.png"></div><br>  Diese Elemente k√∂nnen auch auf viele Arten flexibel kombiniert werden.  Hier ist ein geometrisches Muster kombiniert mit einer ‚Äûzerlumpten Kante‚Äú: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fa/f1a/150/0faf1a15052e90a479428c4c495ad44c.png"></div><br>  In den oben gezeigten Beispielen ist das geometrische Muster recht einfach.  Sie k√∂nnen jedoch sehr komplexe Muster erstellen, indem Sie die geometrischen Grundelemente auf andere Weise kombinieren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38e/13f/fc2/38e13ffc2a2aac266aabb291a7d7f0e6.png"></div><br>  Ein weiteres beliebtes Element des Musters ist das Weben oder der keltische Knoten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07e/00e/8d8/07e00e8d868b6ca48be746fbe07e61ca.png"></div><br>  Hier ist ein komplexerer Weidenrand, der Farbe, Skalierung und andere Elemente enth√§lt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e1/580/140/5e158014012fffcbc51e2e3fe71772d6.png"></div><br>  Auf dieser Karte wird das Weben mit einem ausgefransten Kantenelement kombiniert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e95/4df/588/e954df58825bc42d408b61804a1287a9.png"></div><br>  Zus√§tzlich zu geometrischen Mustern und Webereien kann jedes sich wiederholende Muster Teil des Randes der Karte sein.  Hier ist ein Beispiel mit Formen, die Pfeilspitzen √§hneln: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/5ce/64e/7be5ce64eb09de2eeefdb18992978d03.png"></div><br>  Und hier ist ein Beispiel mit einem sich wiederholenden Wellenmuster: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/841/c13/3c2/841c133c2f1c0f724b5d076e5ea415fb.png"></div><br>  Und schlie√ülich werden Runen oder andere Elemente des Fantasy-Alphabets manchmal an den R√§ndern von Fantasy-Karten hinzugef√ºgt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/6dd/3a3/15f6dd3a3e6191da02dc884193b72c82.png"></div><br>  Die obigen Beispiele stammen aus modernen Fantasy-Karten, aber hier ist ein Beispiel einer historischen Karte (18. Jahrhundert) mit Linien und einem handgezeichneten Muster: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d7/b9f/3b8/1d7b9f3b8f0c7eb296079c5f6f6b23aa.png"></div><br>  Nat√ºrlich finden Sie Beispiele f√ºr Karten mit vielen anderen Elementen an den R√§ndern.  Einige der sch√∂nsten sind vollst√§ndig handgezeichnet und so sorgf√§ltig verarbeitet, dass sie die Karte selbst √ºbertreffen k√∂nnen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">World of Alma</a> , Francesca Baerald): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c7/004/e18/1c7004e186e0d2be63b98539375316ff.png"></div><br>  Es lohnt sich auch ein wenig √ºber <i>Symmetrie zu</i> sprechen.  Wie die Wiederholbarkeit ist auch die Symmetrie ein leistungsstarkes Werkzeug, und Kartenr√§nder sind normalerweise symmetrisch oder weisen symmetrische Elemente auf. <br><br>  Viele Kartenr√§nder sind von innen nach au√üen symmetrisch, wie in diesem Beispiel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/488/ef4/796488ef402e59ed7e092e0e14ff2469.png"></div><br>  Hier besteht der Rand aus mehreren Linien mit und ohne F√ºllung, die sich jedoch von au√üen nach innen idealerweise relativ zur Randmitte wiederholen. <br><br>  In diesem komplexeren Beispiel ist der Rand symmetrisch, mit Ausnahme abwechselnder schwarzer und wei√üer Skalenstreifen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e1/580/140/5e158014012fffcbc51e2e3fe71772d6.png"></div><br>  Da das Duplizieren der Skala nicht sinnvoll ist, wird sie h√§ufig als separates Element betrachtet, auch wenn der Rest des Randes symmetrisch ist. <br><br>  Zus√§tzlich zur internen und externen Symmetrie sind R√§nder h√§ufig entlang ihrer L√§nge re-symmetrisch.  Einige abgebildete R√§nder haben m√∂glicherweise ein einfaches Design, das sich √ºber die gesamte L√§nge des Kartenrandes erstreckt. In den meisten F√§llen ist das Muster jedoch recht kurz und wiederholt sich und f√ºllt den Rand von einer Ecke zur anderen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  Beachten Sie, dass in diesem Beispiel das Muster ein Element enth√§lt, das nicht symmetrisch ist (von links nach rechts), das allgemeine Muster jedoch symmetrisch ist und sich wiederholt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/5ce/64e/7be5ce64eb09de2eeefdb18992978d03.png"></div><br>  Eine bemerkenswerte Ausnahme von dieser Regel sind R√§nder, die mit Runen oder alphabetischen Zeichen gef√ºllt sind.  Oft erweisen sie sich als einzigartig, als ob eine lange Nachricht entlang der Grenze geschrieben worden w√§re: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/6dd/3a3/15f6dd3a3e6191da02dc884193b72c82.png"></div><br>  Nat√ºrlich gibt es viele andere Beispiele f√ºr Kartenrandelemente, die ich hier nicht ber√ºcksichtigt habe, aber wir haben bereits einen guten Bezugspunkt.  In den n√§chsten Teilen werde ich in <b>Dragons Abound</b> verschiedene Funktionen zum Beschreiben, Anzeigen und prozeduralen Generieren von Kartenr√§ndern entwickeln, die diesen Beispielen √§hneln.  Im zweiten Teil legen wir zun√§chst die Sprache f√ºr die Beschreibung der Kartenr√§nder fest. <br><br><h2>  Teil 2 </h2><br>  In diesem Teil werde ich die erste Version der Map Border Description Language (MBDL) erstellen. <br><br>  Warum Zeit damit verbringen, eine Beschreibungssprache f√ºr Kartengrenzen zu erstellen?  Erstens wird dies das Ziel meiner prozeduralen Generierung sein.  Sp√§ter werde ich einen Algorithmus zum Erstellen neuer Kartenr√§nder schreiben, und die Ausgabe dieses Algorithmus wird eine Beschreibung des neuen Randes in MBDL sein.  Zweitens dient MBDL als Textdarstellung von Kartengrenzen.  Insbesondere muss ich in der Lage sein, meine Grenzen zu speichern und wiederzuverwenden.  Dazu ben√∂tige ich eine Textnotation, die geschrieben und verwendet werden kann, um den Rand der Karte neu zu erstellen. <br><br>  Ich beginne mit der Erstellung von MBDL, indem ich das einfachste Element definiere: die Zeile.  Die Linie hat Farbe und Breite.  Daher werde ich in MBDL die Zeile in dieser Form pr√§sentieren: <br><br><blockquote><code>L(width, color)</code> </blockquote> <br>  Hier einige Beispiele (Entschuldigung f√ºr meine Photoshop-Kenntnisse): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db2/db8/68e/db2db868ede7282a34c695f8062a691b.png"></div><br>  Die Reihenfolge der Elemente wird von au√üen nach innen gerendert (*), daher nehmen wir an, dass dies der Rand oben auf der Karte ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7c/75e/b3a/b7c75eb3aefb8f77d1915166c0bdd979.png"></div><br>  Schauen Sie sich das zweite Beispiel an - eine Linie mit Rahmen wird als drei separate Linienelemente dargestellt. <br><br>  <i>(* Das Zeichnen von au√üen nach innen war eine willk√ºrliche Entscheidung - es schien mir nur nat√ºrlicher zu sein als das Rendern von innen nach au√üen. Leider gab es, wie sich viel sp√§ter herausstellte, einen guten Grund, in die entgegengesetzte Richtung zu arbeiten. Bald werde ich Ihnen davon erz√§hlen, aber alles bleibt in der Post - alt, weil es viel Zeit in Anspruch nehmen w√ºrde, alle Abbildungen zu wiederholen)</i> <br><br>  Praktischerweise k√∂nnen R√§ume als Linien ohne Farbe dargestellt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ba/1a4/171/0ba1a41719610641d7b5a5e26da0692e.png"></div><br>  Es w√§re jedoch visueller, ein bestimmtes vertikales Raumelement zu haben: <br><br><blockquote>  VS (Breite) </blockquote><br>  Die folgenden einfachen Elemente sind geometrische Formen: Streifen, Rauten und Ellipsen.  Es wird davon ausgegangen, dass die Linien √ºber die gesamte L√§nge des Rahmens gespannt sind, sodass sie keine explizit angegebene L√§nge haben.  Geometrische Figuren k√∂nnen jedoch nicht die gesamte Linie ausf√ºllen. Daher sollte jede zus√§tzlich zur Breite (*) eine L√§nge, eine Umrissfarbe, eine Umrissbreite und eine F√ºllfarbe haben: <br><br><blockquote> <code>B(width, length, outline, outline width, fill) <br> D(width, length, outline, outline width, fill) <br> E(width, length, outline, outline width, fill)</code> </blockquote> <br>  (* Ich habe akzeptiert, dass ich die Breite in der Richtung von au√üen nach innen ber√ºcksichtigen werde und die L√§nge entlang der Grenze gemessen wird.) <br><br>  Hier sind Beispiele f√ºr einfache geometrische Formen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3d/fad/cf6/a3dfadcf6a5a98a9785b0b487a6e17fc.png"></div><br>  Damit diese Elemente die gesamte L√§nge des Rahmens ausf√ºllen, m√ºssen sie wiederholt werden.  Um die Gruppe von Elementen anzugeben, die wiederholt werden, um die L√§nge des Rahmens auszuf√ºllen, verwende ich eckige Klammern: <br><br><blockquote> <code>[ element element element ... ]</code> </blockquote> <br>  Hier ist ein Beispiel f√ºr ein sich wiederholendes Muster von Rechtecken und Rauten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/420/d88/64e/420d8864e72e178252766172dc0320ab.png"></div><br>  Manchmal brauche ich einen (horizontalen) Abstand zwischen Elementen eines sich wiederholenden Musters.  Obwohl Sie ein Element ohne Farben verwenden k√∂nnen, um einen Raum zu erstellen, ist es intelligenter und bequemer, ein horizontales Raumelement zu haben: <br><br><blockquote> <code>HS(length)</code> </blockquote> <br>  Die letzte Funktion, die f√ºr diese erste Iteration von MBDL ben√∂tigt wird, ist die F√§higkeit, Elemente √ºbereinander zu stapeln.  Hier ist ein Beispielrand: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ea/7e9/3f3/8ea7e93f3040563ef7ec2715ca39a14d.png"></div><br>  Der einfachste Weg, dies zu beschreiben, ist eine breite gelbe Linie unter dem oberen Muster.  Sie k√∂nnen dies auf verschiedene Arten implementieren (z. B. in einem negativen vertikalen Raum), aber ich habe mich f√ºr geschweifte Klammern entschieden, um die Reihenfolge der Elemente nach innen anzugeben: <br><br><blockquote> <code>{element element element ...}</code> </blockquote> <br>  Tats√§chlich fordert Sie dieser Eintrag auf, sich beim Betreten der Klammern zu merken, wo sich das Muster von au√üen nach innen befand, und beim Verlassen der Klammern zu diesem Punkt zur√ºckzukehren.  Klammern k√∂nnen auch als Beschreibung von Elementen betrachtet werden, die einen vertikalen Raum einnehmen.  Daher kann der oben gezeigte Rand wie folgt beschrieben werden: <br><br><blockquote> <code><b>L(1, black) <br> {L(20, yellow)} <br> VS(3) <br> [B(5, 10, black, 3, none) <br> D(5, 10, black,3,red)] <br> VS(3) <br> L(1, black)</b></code> </blockquote> <br>  Wir zeichnen eine schwarze Linie, fixieren, wo wir sind, zeichnen eine gelbe Linie und kehren dann zu der zuvor festgelegten Position zur√ºck, lassen uns ein wenig nach unten fallen, zeichnen ein Muster aus Rechtecken und Rauten, lassen ein wenig nach unten fallen und zeichnen dann eine weitere schwarze Linie. <br><br>  In MBDL gibt es noch viel mehr zu tun, aber dies reicht aus, um die vielen Grenzen von Karten zu beschreiben.  Der n√§chste Schritt besteht darin, die Grenzbeschreibung in der MBDL in die Grenze selbst zu konvertieren.  Dies √§hnelt der Konvertierung einer schriftlichen Darstellung eines Computerprogramms (z. B. Javascript) in die Ausf√ºhrung dieses Programms.  Die erste Stufe ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lexikalische Analyse (Analyse) der</a> Sprache - die Umwandlung des Quelltextes in einen realen Rand der Karte oder in eine Zwischenform, die einfacher in einen Rand umzuwandeln ist. <br><br>  Parsing ist ein ziemlich gut untersuchter Bereich der Informatik.  Das Parsen einer Sprache ist nicht sehr einfach, aber in unserem Fall ist es gut (*), dass MBDL eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kontextfreie</a> Grammatik ist.  Kontextfreie Grammatiken lassen sich relativ leicht analysieren, und es gibt viele <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Javascript-Parsing-Tools</a> f√ºr sie.  Ich habe mich f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nearley.js entschieden</a> , das ziemlich ausgereift und (was noch wichtiger ist) ein gut dokumentiertes Tool zu sein scheint. <br><br>  <i>(* Dies ist nicht nur Gl√ºck, ich habe daf√ºr gesorgt, dass die Sprache kontextfrei ist.)</i> <br><br>  Ich werde Sie nicht in kontextfreie Grammatiken einf√ºhren, aber die Nearley-Syntax ist recht einfach und Sie sollten die Bedeutung ohne Probleme verstehen.  Grammatik Nearley besteht aus einer Reihe von Regeln.  Jede Regel hat links ein Symbol, einen Pfeil und den rechten Teil der Regel, der eine Folge von Zeichen und Nichtzeichen sein kann, sowie verschiedene Optionen, die durch das "|" getrennt sind.  (oder): <br><br><blockquote> <code><b>border -&gt; element | element border <br> element -&gt;</b> ‚Äú <b>L"</b></code> </blockquote> <br>  Jede der Regeln besagt, dass die linke Seite durch eine der Optionen auf der rechten Seite ersetzt werden kann.  Das hei√üt, die erste Regel besagt, dass ein Rand ein Element oder ein Element ist, gefolgt von einem anderen Rand.  Welches selbst kann ein Element sein oder ein Element, dem ein Rand folgt, und so weiter.  Die zweite Regel besagt, dass ein Element nur eine Zeichenfolge "L" sein kann.  Das hei√üt, zusammen entsprechen diese Regeln solchen Grenzen: <br><br><blockquote> <code><b>L <br> LLL</b></code> </blockquote> <br>  und entsprechen nicht solchen Grenzen: <br><br><blockquote> <code><b>X <br> L3L</b></code> </blockquote> <br>  √úbrigens, wenn Sie mit dieser (oder einer anderen) Grammatik in Nearley experimentieren m√∂chten, gibt es hier eine Online-Sandbox daf√ºr.  Sie k√∂nnen Grammatik- und Testf√§lle eingeben, um zu sehen, was √ºbereinstimmt und was nicht. <br><br>  Hier ist eine vollst√§ndigere Definition eines Linienprimitivs: <br><br><blockquote> <code><b>@builtin ‚Äúnumber.ne" <br> @builtin ‚Äústring.ne" <br> border -&gt; element | element border <br> element -&gt; ‚ÄúL(" decimal ‚Äú," dqstring ‚Äú)"</b></code> </blockquote> <br>  Nearley hat mehrere gemeinsame eingebaute Elemente, und die Nummer ist eines davon.  Daher kann ich damit die numerische Breite eines Linienprimitivs erkennen.  F√ºr die Farberkennung verwende ich ein anderes integriertes Element und erlaube die Verwendung einer beliebigen Zeichenfolge in doppelten Anf√ºhrungszeichen. <br><br>  Es w√§re sch√∂n, Leerzeichen zwischen verschiedenen Zeichen einzuf√ºgen, also lass es uns tun.  Nearley unterst√ºtzt Zeichenklassen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RBNF</a> f√ºr "null oder mehr" von etwas mit ": *", sodass ich damit "null oder mehr Leerzeichen" angeben und an einer beliebigen Stelle einf√ºgen kann, um Leerzeichen in Beschreibungen zuzulassen: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element border <br> WS -&gt; [\s]:* <br> number -&gt; WS decimal WS <br> color -&gt; WS dqstring WS <br> element -&gt; "L(" number "," color ")"</b></code> </blockquote> <br>  Die Verwendung von WS √ºberall macht es jedoch schwierig, die Grammatik zu lesen, daher werde ich sie aufgeben, aber stellen Sie sich vor, dass sie es sind. <br><br>  Ein Element kann auch ein vertikaler Raum sein: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")"</b></code> </blockquote> <br>  Dies entspricht solchen Grenzen <br><br><blockquote> <code><b>L(3.5,"black") VS(3.5)</b></code> </blockquote> <br>  Als n√§chstes kommen die Grundelemente Streifen, Raute und Ellipse. <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")"</b></code> </blockquote> <br>  Es wird mit solchen Elementen √ºbereinstimmen <br><br><blockquote> <code><b>B(34, 17, "white", 3, "black")</b></code> </blockquote> <br>  (Beachten Sie, dass geometrische Grundelemente keine ‚ÄûElemente‚Äú sind, da sie auf der obersten Ebene nicht allein sein k√∂nnen. Sie m√ºssen in einem Muster eingeschlossen sein.) <br><br>  Ich brauche auch ein horizontales Raumprimitiv: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")"</b></code> </blockquote> <br>  Jetzt werde ich eine Musteroperation (Wiederholung) hinzuf√ºgen.  Dies ist eine Folge von einem oder mehreren Elementen in eckigen Klammern.  Ich werde den RBNF-Operator ": +" verwenden, was hier "einer oder mehrere" bedeutet. <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")" <br> element -&gt; "[" (geometric):+ "]"</b></code> </blockquote> <br>  Beachten Sie, dass das Muster nur mit geometrischen Grundelementen gef√ºllt werden kann.  Wir k√∂nnen zum Beispiel keine Linie innerhalb eines Musters platzieren.  Das Musterelement stimmt jetzt mit so etwas √ºberein. <br><br><blockquote> <code><b>[B(34,17,"white",3,"black")E(13,21,"white",3,"rgb(27,0,0)")]</b></code> </blockquote> <br>  Der letzte Teil der Sprache ist der Overlay-Operator.  Dies ist eine beliebige Anzahl von Elementen in geschweiften Klammern. <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")" <br> element -&gt; "[" (geometric ):+ "]" <br> element -&gt; "{" (element ):+ "}"</b></code> </blockquote> <br>  Damit k√∂nnen wir Folgendes tun: <br><br><blockquote> <code><b>{L(3.5,"rgb(98,76,15)")VS(3.5)}</b></code> </blockquote> <br>  (Beachten Sie, dass der Overlay-Operator im Gegensatz zum Wiederholungsoperator intern verwendet werden kann.) <br><br>  Nachdem wir die Beschreibung bereinigt und den erforderlichen Stellen Leerzeichen hinzugef√ºgt haben, erhalten wir die folgende MBDL-Grammatik: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; (element WS):+ <br> WS -&gt; [\s]:* <br> number -&gt; WS decimal WS <br> color -&gt; WS dqstring WS <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> element -&gt; "(" WS (element WS):+ ")" <br> element -&gt; "[" WS (geometric WS):+ "]" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")"</b></code> </blockquote> <br>  MBDL ist nun definiert und wir haben eine Grammatik der Sprache erstellt.  Es kann mit Nearley verwendet werden, um Sprachzeichenfolgen zu erkennen.  Bevor ich mich mit MBDL / Nearley befasse, m√∂chte ich die in MBDL verwendeten Grundelemente implementieren, damit die in MBDL beschriebene Grenze angezeigt werden kann.  Dies werden wir im n√§chsten Teil tun. <br><br><h2>  Teil 3 </h2><br>  Jetzt werden wir beginnen, die Rendering-Grundelemente selbst zu implementieren.  (Zu diesem Zeitpunkt muss ich den Parser noch nicht an die Rendering-Grundelemente binden. Zum Testen rufe ich sie einfach manuell auf.) <br><br>  Beginnen wir mit der Grundlinie.  Erinnern Sie sich, wie es aussieht: <br><br><blockquote> <code><b>L(width, color)</b></code> </blockquote> <br>  Neben der Breite und Farbe gibt es hier einen impliziten Parameter - den Abstand vom √§u√üeren Rand der Karte.  (Ich zeichne die R√§nder vom Rand der Karte nach au√üen. Beachten Sie, dass wir von einem anderen ausgegangen sind!) Es sollte nicht auf die MBDL zeigen, da dies vom Interpreter verfolgt werden kann, der die MBDL ausf√ºhrt, um den Rand zu zeichnen.  Dies sollte jedoch f√ºr alle Rendering-Grundelemente eingegeben werden, damit sie wissen, wo sie gezeichnet werden sollen.  Ich werde diesen Parameter Offset nennen. <br><br>  Wenn ich nur einen Rand am oberen Rand der Karte zeichnen m√ºsste, w√§re das Linienprimitiv sehr einfach zu implementieren.  Tats√§chlich muss ich jedoch von oben zeichnen.  unten, links und rechts.  (Vielleicht werde ich eines Tages schr√§ge oder gekr√ºmmte R√§nder erkennen, aber im Moment werden wir uns an rechteckige Standardr√§nder halten.) Au√üerdem h√§ngen L√§nge und Position des Linienelements von der Gr√∂√üe der Karte (sowie vom Versatz) ab.  Daher ben√∂tige ich als Parameter all diese Daten. <br><br>  Nachdem Sie alle diese Parameter festgelegt haben, reicht es aus, einfach ein Linienprimitiv zu erstellen und damit eine Linie um die Karte zu zeichnen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a56/74f/785/a5674f78512bef22e569656701203401.png"></div><br>  (Beachten Sie, dass ich verschiedene Funktionen von <b>Dragons Abound verwende,</b> um die ‚Äûhandgeschriebene‚Äú Linie zu zeichnen.) Versuchen wir, einen komplexeren Rand zu erstellen: <br><br><blockquote> <code><b>L(3, black) L(10, gold) L(3, black)</b></code> </blockquote> <br>  Es sieht so aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86a/ad8/849/86aad88494c1c17f993524ef09ef9b2f.png"></div><br>  Ziemlich gut.  Beachten Sie, dass es Stellen gibt, an denen die schwarzen und die goldenen Linien aufgrund von Schwankungen nicht richtig ausgerichtet sind.  Wenn ich diese Stellen entfernen m√∂chte, k√∂nnen Sie einfach die Schwingung reduzieren. <br><br>  Das Implementieren eines vertikalen Raumprimitivs ist recht einfach.  Es wird nur ein Offset-Inkrement ausgef√ºhrt.  F√ºgen wir ein wenig Platz hinzu: <br><br><blockquote> <code><b>L(3, black) L(10, gold) L(3, black) <br> VS(5) <br> L(3, black) L(10, red) L(3, black)</b></code> </blockquote> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eab/471/b90/eab471b902eb44e703f460d700936937.png"></div><br>  Beim Zeichnen von Linien k√∂nnen Winkel realisiert werden, indem zwischen dem Versatz und der Zeichnung entlang der Karte im Uhrzeigersinn gezeichnet wird.  Im Allgemeinen muss ich jedoch auf jeder Seite des Kartenrandes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine K√ºrzung</a> implementieren, um eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Winkelverbindung mit einer Abschr√§gung herzustellen</a> .  Dies ist erforderlich, um R√§nder mit Mustern zu erstellen, die an den Ecken korrekt verbunden sind, und im Allgemeinen entf√§llt die Notwendigkeit, Elemente mit Kanten in einem Winkel zu zeichnen, der sonst erforderlich w√§re.  (*) <br><br>  <i>(Hinweis: Wie in den folgenden Abschnitten erw√§hnt wird, habe ich mich im Laufe der Zeit geweigert, beim Implementieren von Winkeln K√ºrzungsbereiche zu verwenden. Der Hauptgrund ist, dass komplexe Winkel erstellt werden, z. B. quadratische Offsets:</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/fd8/336/97bfd833697b9278660772c1bd04ee46.png"></div><br>  <i>Es werden immer komplexere K√ºrzungsbereiche ben√∂tigt.</i>  <i>Au√üerdem habe ich im Laufe der Zeit einen besseren Weg gefunden, mit Mustern in Ecken zu arbeiten.</i>  <i>Anstatt diesen Teil des Artikels zur√ºckzugeben und neu zu schreiben, habe ich beschlossen, ihn zu belassen, um den Prozess der ‚ÄûKreativit√§t‚Äú zu veranschaulichen.)</i> <br><br>  Die Hauptidee besteht darin, jeden Rand diagonal abzuschneiden und vier abgeschnittene Bereiche zu erstellen, in denen jede Seite des Randes gezeichnet wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9fb/31a/cf9/9fb31acf993cde46b6a7fdc408be6afd.png"></div><br>  Beim Abschneiden wird alles, was im entsprechenden Bereich gezeichnet wurde, im gew√ºnschten Winkel abgeschnitten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/52b/f00/f02/52bf00f026f6979f6425345389fa646a.png"></div><br>  Leider entstehen dadurch kleine L√ºcken entlang der diagonalen Linien, wahrscheinlich weil der Browser die Gl√§ttung entlang der abgeschnittenen Kante nicht perfekt durchf√ºhrt.  Der Test zeigte, dass ein Hintergrund durch die L√ºcke zwischen den beiden Kanten scheint.  Es war m√∂glich, dies zu beheben, indem eine der Masken etwas erweitert wurde (das halbe Pixel scheint ausreichend zu sein), aber dies l√∂st das Problem manchmal nicht. <br><br>  Als n√§chstes m√ºssen Sie geometrische Formen implementieren.  Im Gegensatz zu Linien werden sie im Muster wiederholt und f√ºllen die Seite des Kartenrandes aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/420/d88/64e/420d8864e72e178252766172dc0320ab.png"></div><br>  Eine Person zeichnete dieses Muster von links nach rechts, zeichnete ein Rechteck, eine Raute und wiederholte es dann, bis der gesamte Rand gef√ºllt war.  Daher kann dies auch im Programm implementiert werden, indem ein Muster entlang der Grenze gezeichnet wird.  Es ist jedoch einfacher, zuerst alle Rechtecke und dann alle Rauten zu zeichnen.  Es reicht aus, in Abst√§nden dieselbe geometrische Figur entlang des Randes zu zeichnen.  Und es ist sehr praktisch, dass jedes Element das gleiche Intervall hat.  Nat√ºrlich w√ºrde eine Person das nicht tun, weil es zu schwierig ist, die Elemente an den richtigen Stellen anzuordnen, aber dies ist kein Problem f√ºr das Programm. <br><br>  Das hei√üt, das Verfahren zum Zeichnen einfacher geometrischer Formen erfordert Parameter, in denen alle Abmessungen und Farben der Figur √ºbertragen werden (d. H. Breite, L√§nge, Liniendicke, Linienfarbe und F√ºllung) sowie die Startposition (die aus Gr√ºnden, die bald klar werden, Ich werde die Mitte der Figur betrachten), das horizontale Raumintervall f√ºr den √úbergang zwischen Wiederholungen und die Anzahl der Wiederholungen.  Es ist auch zweckm√§√üig, die Wiederholungsrichtung in Form eines Vektors [dx, dy] anzugeben, damit wir Wiederholungen von links nach rechts, von rechts nach links, nach oben oder unten durchf√ºhren k√∂nnen, indem wir einfach den Vektor und den Startpunkt √§ndern.  Setze alles zusammen und erhalte einen Streifen sich wiederholender Formen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/409/bcd/c33/409bcdc33756610ac6ace2d0fde0a3a4.png"></div><br>  Wenn ich diesen Code mehrmals verwende und mit demselben Versatz rendere, kann ich die schwarzen und wei√üen Streifen kombinieren, um den Kartenma√üstab zu erstellen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/8f5/0d9/b888f50d9f164b9319cc8b3cf8d38588.png"></div><br>  Bevor ich anfange herauszufinden, wie all dies auf den realen Rand der Karte angewendet werden kann, implementieren wir zun√§chst dieselbe Funktionalit√§t f√ºr Ellipsen und Rauten. <br><br>  Rauten sind nur Rechtecke mit gedrehten Eckpunkten, sodass Sie nur eine kleine √Ñnderung am Code vornehmen m√ºssen.  Es stellte sich heraus, dass ich noch keinen vorgefertigten Code zum Rendern der Ellipse habe, aber es ist sehr einfach, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">parametrische Ansicht der Ellipse zu √ºbernehmen</a> und eine Funktion zu erstellen, die mir die Punkte der Ellipse gibt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fa/74e/079/3fa74e079dd2c29afa5acb0135d4092f.png"></div><br>  Hier ist ein Beispiel (manuell erstellt), das die oben implementierten Funktionen verwendet: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf8/bf2/d39/bf8bf2d3992b34bc173622dc86c0d8b5.png"></div><br>  F√ºr so eine kleine Menge Code sieht es ziemlich gut aus! <br><br>  L√∂sen wir nun den komplexen Fall von R√§ndern mit sich wiederholenden Elementen: Ecken. <br><br>  Wenn es einen Rand mit sich wiederholenden Elementen gibt, gibt es verschiedene M√∂glichkeiten, das Problem mit Ecken zu l√∂sen.  Die erste besteht darin, die Wiederholungen so anzupassen, dass sie in den Ecken ausgef√ºhrt werden, ohne dass eine Ehe erkennbar ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  Eine andere M√∂glichkeit besteht darin, die Wiederholung irgendwo in der N√§he der Ecke auf beiden Seiten zu stoppen.  Dies geschieht h√§ufig, wenn das Muster in der Ecke nicht einfach ‚Äûgedreht‚Äú werden kann: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/6dd/3a3/15f6dd3a3e6191da02dc884193b72c82.png"></div><br>  Die letzte M√∂glichkeit besteht darin, das Muster mit einer Eckdekoration zu schlie√üen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/5ce/64e/7be5ce64eb09de2eeefdb18992978d03.png"></div><br>  Eines Tages werde ich zu den Eckdekorationen kommen, aber jetzt werden wir die erste Option verwenden.  Wie kann man ein Muster aus Streifen oder Kreisen in den Ecken der Karte ohne L√ºcken ‚Äûdrehen‚Äú? <br><br>  Die Hauptidee besteht darin, das Musterelement genau in der Ecke zu platzieren, sodass sich eine H√§lfte davon an einer Kante der Karte und die andere an der benachbarten befindet.  In diesem Beispiel befindet sich der Kreis genau in der Ecke und kann aus jeder Richtung gezeichnet werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  In anderen F√§llen wird das Element zur H√§lfte in die eine und zur H√§lfte in die andere Richtung gezeichnet, aber die Kanten fallen zusammen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ee/f62/0b8/4eef620b830eb0249d019229140e34e6.png"></div><br>  In diesem Fall wird auf beiden Seiten ein wei√üer Streifen gezeichnet, der jedoch in der Ecke l√ºckenlos verbunden ist. <br><br>  Beim Platzieren eines Elements in einer Ecke sind zwei Aspekte zu ber√ºcksichtigen. <br><br>  Zun√§chst wird das Eckelement geteilt und relativ zur Diagonale gespiegelt, die durch die Mitte des Elements verl√§uft.  Elemente mit radialer Symmetrie, z. B. Quadrate, Kreise und Sterne, √§ndern ihre Form nicht.  Elemente ohne radiale Symmetrie, z. B. Rechtecke und Rauten, √§ndern beim Spiegeln relativ zur Diagonale ihre Form. <br><br>  Zweitens muss eine ganzzahlige Anzahl von Elementen (*) auf beiden Seiten der Karte vorhanden sein, damit die Eckelemente der beiden Seiten korrekt verbunden sind.  Sie m√ºssen nicht dieselbe Anzahl haben, aber es muss auf beiden Seiten eine ganzzahlige Anzahl von Elementen geben.  Wenn auf einer Seite eine gebrochene Anzahl von Mustern enthalten ist, stimmt das Muster von einer Kante nicht mit der benachbarten Seite √ºberein. <br><br>  <i>(* In einigen F√§llen, z. B. bei langen Streifen, kann es bei vollst√§ndiger Wiederholung zu einer teilweisen Wiederholung kommen, und die Elemente werden trotzdem ausgerichtet. Das resultierende Eckelement ist jedoch asymmetrisch und unterscheidet sich in der L√§nge von demselben Element auf den Seiten der Karte. Ein Beispiel hierf√ºr ist hier zu sehen:</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/418/110/263418110aafe94ef8c62d57e8540371.png"></div><br>  <i>Ein wei√üer Ma√üstabsbalken tritt mit verschiedenen Teilwiederholungen auf, und als Ergebnis wird ein Element erhalten, das relativ zur Mitte verschoben ist.</i>  <i>F√ºr den Kartenma√üstab ist dies nicht immer der Fall, da er den absoluten Abstand anzeigt und nicht symmetrisch sein muss.</i>  <i>Aber f√ºr ein dekoratives Muster sieht das normalerweise schlecht aus.)</i> <br><br>  Hier ist ein Beispiel, das zeigt, wie eine ganzzahlige Anzahl von Wiederholungen genau in der Ecke abgeschnitten wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ab/8de/0a3/8ab8de0a3452332e2813b3771091b165.png"></div><br>  Wenn Sie von allen vier Seiten dasselbe tun, fallen die Ecken zusammen und das Muster wird nahtlos √ºber die gesamte L√§nge des Rahmens platziert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfc/c9a/e46/dfcc9ae46a68807e983705e553aa2ba3.png"></div><br>  Bei sorgf√§ltiger Pr√ºfung werden Sie feststellen, dass das Muster nicht genau in den Ecken auftritt.  Die H√§lfte des Kreises in jeder Ecke wird von jeder Seite genommen, und diese beiden H√§lften werden unabh√§ngig voneinander von Hand gezeichnet, daher sind sie nicht perfekt.  Aber jetzt sind sie nah genug dran. <br><br>  So k√∂nnen wir eine perfekte Verbindung des Musters in den Ecken realisieren, indem wir f√ºr jede Kante eine ganzzahlige Anzahl von Wiederholungen ausw√§hlen.  Die L√∂sung f√ºr dieses Problem ist jedoch nicht trivial. <br><br>  Angenommen, wir wissen, dass die Seite 866 Pixel lang ist, und wir m√∂chten das Element 43 Mal wiederholen.  Dann sollte das Element alle 20,14 Pixel wiederholt werden.  Wie legen wir die spezifische L√§nge eines Elements (und im allgemeinen Fall ein Muster von Elementen) fest?  Im obigen Beispiel habe ich zus√§tzlichen Abstand zwischen den Kreisen hinzugef√ºgt.  Wenn sich die Kreise jedoch anf√§nglich ber√ºhrten, √§ndert dies das Muster.  Vielleicht lohnt es sich, die Kreise so zu dehnen, dass sie sich weiterhin ber√ºhren? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e36/2b0/ebd/e362b0ebd3fd04e5d8b00de5d3aba151.png"></div><br>  Jetzt ber√ºhren sich die Elemente, aber die Kreise haben sich in Ellipsen verwandelt und die Ecken haben eine seltsame Form.  (Denken Sie daran, ich sagte, dass Elemente ohne radiale Symmetrie ihre Form √§ndern, wenn sie relativ zu einem Winkel reflektiert werden. F√ºr Streifen ist dies kein gro√ües Problem.) Oder es lohnt sich vielleicht, alle Elemente so zu komprimieren, dass sie sich ber√ºhren und in eine geeignete L√§nge passen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7c/ba8/0af/d7cba80afb431dc6c9afc52d7ad94b5c.png"></div><br>  Um dies zu realisieren, m√ºssen wir die Elemente jedoch viel kleiner machen als urspr√ºnglich.  Keine dieser Optionen scheint perfekt zu sein. <br><br>  Das zweite Problem tritt auf, wenn die Seiten der Karte unterschiedlich gro√ü sind.  Jetzt m√ºssen wir das Problem l√∂sen, eine ganzzahlige Anzahl von Wiederholungen zu finden, die f√ºr beide Seiten geeignet sind.  Es w√§re ideal, eine L√∂sung zu finden, die zu beiden Seiten passt.  Aber ich m√∂chte dies nicht auf Kosten zu vieler Muster√§nderungen tun.  Es ist m√∂glicherweise besser, auf beiden Seiten leicht unterschiedliche Muster zu erstellen, wenn beide nahe genug am urspr√ºnglichen Muster liegen. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und schlie√ülich tritt das dritte Problem auf, wenn ich die Funktion verwende, mehrere Elemente √ºbereinander zu legen: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d9/4ed/6ac/4d94ed6acf107193f2109bd2b2f07a67.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich m√∂chte keine √Ñnderungen am Muster vornehmen, die die Beziehung zwischen den Elementen zerst√∂ren. </font><font style="vertical-align: inherit;">Ich denke, dass bei richtiger Skalierung die Verh√§ltnisse insgesamt erhalten bleiben, aber ich muss dies testen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interessante Aufgabe, oder? </font><font style="vertical-align: inherit;">Bisher habe ich keine besonders hochwertigen L√∂sungen f√ºr sie. </font><font style="vertical-align: inherit;">Vielleicht erscheinen sie sp√§ter!</font></font><br><br><h2>  Teil 4 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher haben wir Grundelemente zum Zeichnen von Linien und geometrischen Formen implementiert. Ich fing an, sich wiederholende Formen zu verwenden, um die R√§nder zu f√ºllen, und sprach √ºber die Schwierigkeiten, beliebige Muster am Rand der Karte zu platzieren, damit sie perfekt in die Ecken passen. Das Hauptproblem besteht darin, dass Sie das Muster im Allgemeinen l√§nger (oder k√ºrzer) machen m√ºssen, damit es seitlich passt. Optionen zum √Ñndern der L√§nge des Musters - Hinzuf√ºgen oder Entfernen von Leerzeichen, √Ñndern der L√§nge der Elemente der Muster - f√ºhren zu verschiedenen √Ñnderungen im Muster selbst. Es scheint, dass die Auswahl eines Musters aus mehreren Elementen sehr schwierig ist!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn ich auf solche scheinbar kompromisslosen Aufgaben sto√üe, beginne ich gerne mit der Implementierung einer einfachen Version. Nicht erfolgreiche Aufgaben k√∂nnen oft durch wiederholtes L√∂sen "einfacher" Probleme gel√∂st werden, bis das Ergebnis gut genug ist. Und manchmal gibt die Implementierung einer einfachen Version ein Verst√§ndnis, das die L√∂sung eines komplexeren Problems vereinfacht. Wenn es nicht besser wird und das Problem weiterhin unangenehm ist, werden wir zumindest eine vereinfachte Version haben, die immer noch n√ºtzlich sein kann, wenn auch nicht ganz so, wie es sollte.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am einfachsten ist es, die L√§nge des Musters zu √§ndern, indem Sie L√§ngen hinzuf√ºgen, ohne etwas im Muster zu √§ndern. </font><font style="vertical-align: inherit;">Im Wesentlichen wird dadurch am Ende des Musters ein Leerzeichen hinzugef√ºgt. </font><font style="vertical-align: inherit;">(Hinweis: Es ist besser, den leeren Raum auf alle Elemente im Muster zu verteilen.) Es ist zu ber√ºcksichtigen, dass eine solche L√∂sung das Muster nur verl√§ngern kann. </font><font style="vertical-align: inherit;">Wir k√∂nnen dem Muster immer einen leeren Raum hinzuf√ºgen, ihn aber bei Bedarf nicht nehmen - vielleicht gibt es keinen leeren Raum mehr im Muster! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei diesem Ansatz ist der Musterortungsalgorithmus auf der Seite der Karte sehr einfach:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teilen Sie die L√§nge der Seite der Karte durch die L√§nge des Musters und runden Sie sie ab, um die Anzahl der Wiederholungen des Musters zu bestimmen, die auf diese Seite passen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Abstand zwischen den Elementen ist in diesem Fall gleich der L√§nge der Seite geteilt durch die Anzahl der Wiederholungen. </font><font style="vertical-align: inherit;">(Dies ist der n√§chstgelegene Ort, da wir nur Speicherplatz hinzuf√ºgen k√∂nnen.)</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeichnen Sie ein Muster entlang der Seite unter Ber√ºcksichtigung des berechneten Abstands. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es war schwierig, dieses System zu implementieren. </font><font style="vertical-align: inherit;">Die Ecken wollten hartn√§ckig nicht zusammenfallen. </font><font style="vertical-align: inherit;">Ich habe zu viel Zeit gebraucht, um zu erkennen, dass ich, wenn die Karte nicht quadratisch ist, keine K√ºrzungsbereiche f√ºr vier Seiten von der Kartenmitte aus zeichnen kann, da dadurch K√ºrzungswinkel erzeugt werden, die nicht gleich 45 Grad sind. </font><font style="vertical-align: inherit;">In der Tat sollten K√ºrzungsbereiche der R√ºckseite eines Umschlags √§hneln:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b20/29a/beb/b2029abeb54302b5f7d3335a15c95f86.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als ich das herausfand, begann der Algorithmus ohne Probleme zu funktionieren. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Vergessen Sie jedoch nicht den vorherigen Hinweis, dass ich im Laufe der Zeit K√ºrzungsbereiche aufgegeben habe!)</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hier ein Beispiel mit einem Verh√§ltnis von ungef√§hr 2: 1:</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bff/739/d19/bff739d19d76fdb4db63033b970eb241.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf dieser Skala ist es ziemlich schwer zu bemerken, aber die Ecken verbinden sich richtig und es gibt nur einen geringen visuellen Unterschied zwischen den Seiten. </font><font style="vertical-align: inherit;">In diesem Fall muss der Algorithmus zum Ausrichten der Muster nur Bruchpixel einf√ºgen, sodass er f√ºr das Auge unsichtbar ist, insbesondere weil die Konturen der Kreise von einem Pixel √ºberlappt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist ein weiteres Beispiel mit Streifen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa8/852/625/aa8852625e15121ce822cc6ca5fe8742.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist die Spitze der quadratischen Grenze. </font><font style="vertical-align: inherit;">Hier ist derselbe Rand auf einer rechteckigeren Karte:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90d/207/9b1/90d2079b1e869c59ee204f1a75f5dbc7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier k√∂nnen Sie sehen, dass auf der Seite der Karte eine visuell gr√∂√üere L√ºcke zwischen den B√§ndern besteht. </font><font style="vertical-align: inherit;">Der Algorithmus sollte nicht mehr Platz als die L√§nge eines vollst√§ndigen Elements einf√ºgen. </font><font style="vertical-align: inherit;">Daher tritt der schlimmste Fall auf, wenn wir lange Elemente und eine kurze Seite haben, die sich geringf√ºgig von einer geeigneten Gr√∂√üe unterscheidet. </font><font style="vertical-align: inherit;">In den meisten praktischen F√§llen ist die Ausrichtung jedoch nicht sehr sch√§dlich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist ein Beispiel mit einem Muster aus mehreren Elementen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d18/602/4f8/d186024f8ee1e4fbcd5918c63537a024.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hier √ºberlappen die Streifen die Streifen: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c60/af7/ad6/c60af7ad6c71ee4ef1850f0bf194af62.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen sehen, dass die Streifen relativ zueinander zentriert bleiben, da f√ºr jedes Element dieselbe Ausrichtung durchgef√ºhrt wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich schlug vor, dass eine gute L√∂sung zum Platzieren des Musters an der Seite der Karte schwierig w√§re, aber ein sehr einfacher Ansatz mit gleichm√§√üiger Verteilung des Musterelements, um den gew√ºnschten Raum zu f√ºllen, funktioniert f√ºr viele Muster recht gut. Dies ist eine Erinnerung an uns alle: Es besteht keine Notwendigkeit anzunehmen, dass die Entscheidung kompliziert sein muss; es kann einfacher sein als du denkst! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese L√∂sung funktioniert jedoch nicht f√ºr Muster mit ber√ºhrenden Elementen, z. B. f√ºr den Kartenma√üstab. In diesem Fall werden durch Hinzuf√ºgen von Leerzeichen die Elemente verschoben:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cd/d7e/27f/3cdd7e27f8c2d92be26d36e7b4807f5a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere Option zum Verl√§ngern eines Musters, die ich oben erw√§hnt habe, ist das Strecken der einzelnen Elemente des Musters. </font><font style="vertical-align: inherit;">Es ist f√ºr so etwas wie ein Skalenmuster geeignet, sieht aber in einem Muster mit symmetrischen Elementen schlecht aus, da sie durch Dehnen asymmetrisch werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Implementierung der Option mit Dehnung erwies sich als schwieriger als erwartet, haupts√§chlich weil ich die Elemente an verschiedenen Kanten der Karte um verschiedene Gr√∂√üen strecken musste (weil die Karte m√∂glicherweise nicht quadratisch, sondern rechteckig ist) und auch die Anordnung der Elemente basierend auf den neuen gedehnten dynamisch √§ndern musste Gr√∂√üen. </font><font style="vertical-align: inherit;">Aber nach ein paar Stunden habe ich das geschafft:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/552/3c4/d1c5523c43a9828cd9c1c1bee6f4bbde.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt habe ich alle Funktionen, die zum Zeichnen des Rahmens der Karte erforderlich sind (obwohl die Rahmenelemente selbst manuell erstellt werden): </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2b/ccc/326/d2bccc326a0500f92267378e137e2f6e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich habe das Bild in Graustufen konvertiert, weil ich mich nicht um die Auswahl der Farben k√ºmmern wollte und die Karte selbst ziemlich langweilig ist, aber als Proof of Concept sehen die R√§nder ziemlich h√ºbsch aus. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 5 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Teil 2 habe ich die MBDL-Grammatik (Map Border Description Language) entwickelt und in Teil 3 und 4 Prozeduren implementiert, um alle Sprachprimitive auszuf√ºhren. </font><font style="vertical-align: inherit;">Jetzt werde ich daran arbeiten, diese Teile zu verbinden, damit ich den Rand in MBDL beschreiben und auf der Karte zeichnen kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Teil 3 habe ich die MBDL-Grammatik so geschrieben, dass sie mit dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nearley</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Javascript </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Parsing Tool</font></a><font style="vertical-align: inherit;"> funktioniert </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die fertige Grammatik sieht folgenderma√üen aus:</font></font><br><br><blockquote> <code><b>@builtin</b> <b>"</b> <b>number.ne"</b> <br> <b>@builtin</b> <b>"</b> <b>string.ne"</b> <br> <b>border -&gt; (element WS):+ <br> WS -&gt; [\s]:* <br> number -&gt; WS decimal WS <br> color -&gt; WS dqstring WS <br> element -&gt;</b> <b>"</b> <b>L(" number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>element -&gt;</b> <b>"</b> <b>VS(" number</b> <b>"</b> <b>)"</b> <br> <b>element -&gt;</b> <b>"</b> <b>(" WS (element WS):+</b> <b>"</b> <b>)"</b> <br> <b>element -&gt;</b> <b>"</b> <b>[" WS (geometric WS):+</b> <b>"</b> <b>]"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>B(" number</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>E(" number</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>D(" number</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>HS(" number</b> <b>"</b> <b>)"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn eine Regel erfolgreich mit Nearley analysiert wird, gibt die Regel standardm√§√üig ein Array zur√ºck, das alle Elemente enth√§lt, die der rechten Seite der Regel entsprechen. </font><font style="vertical-align: inherit;">Zum Beispiel, wenn die Regel</font></font><br><br><blockquote> <code><b>test -&gt;</b> <b>"</b> <b>A" |</b> <b>"</b> <b>B" |</b> <b>"</b> <b>C"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit Zeichenfolge abgeglichen </font></font><br><br><blockquote> <code><b>A</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dann wird Nearley zur√ºckkehren </font></font><br><br><blockquote> <code><b>[</b> <b>"</b> <b>A" ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Array mit einem einzelnen Wert ist die Zeichenfolge "A", die der rechten Seite der Regel entspricht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was gibt Nearley zur√ºck, wenn ein Element nach dieser Regel analysiert wird?</font></font><br><br><blockquote> <code><b>number -&gt; WS decimal WS</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf der rechten Seite der Regel befinden sich drei Teile, sodass ein Array mit drei Werten zur√ºckgegeben wird. </font><font style="vertical-align: inherit;">Der erste Wert ist derjenige, der die Regel f√ºr WS zur√ºckgibt, der zweite Wert ist derjenige, der die Regel f√ºr Dezimalzahlen zur√ºckgibt, und der dritte Wert ist derjenige, der die Regel f√ºr WS zur√ºckgibt. </font><font style="vertical-align: inherit;">Wenn ich unter Verwendung der obigen Regel "57" analysiere, ist das Ergebnis wie folgt:</font></font><br><br><blockquote> <code><b>[ <br> [ " " ], <br> [ "5", "7" ], <br> [ ] <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Endergebnis der Nearley-Analyse ist ein verschachteltes Array von Arrays, bei dem es sich um einen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntaxbaum handelt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In einigen F√§llen ist der Syntaxbaum eine sehr n√ºtzliche Darstellung, in anderen F√§llen nicht ganz. In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dragons Abound</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zum Beispiel ist ein solcher Baum nicht besonders n√ºtzlich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gl√ºcklicherweise k√∂nnen Nearley-Regeln das Standardverhalten √ºberschreiben und alles zur√ºckgeben, was sie wollen. In der </font><font style="vertical-align: inherit;">Tat, f√ºr die (integrierte) Regel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dezimal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht eine Liste von Zahlen zur√ºckkehrt, gibt es eine entsprechende Anzahl von Javascript ist, dass in den </font><font style="vertical-align: inherit;">meisten F√§llen viel n√ºtzlicher ist, das hei√üt, die R√ºckgabewert Regel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nummer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist:</font></font><br><br><blockquote> <code><b>[ <br> [ " " ], <br> 57, <br> [ ] <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nearley-Regeln definieren das Standardverhalten neu, indem sie der Regel einen Postprozessor hinzuf√ºgen, ein Standardarray verwenden und es durch das ersetzen, was Sie ben√∂tigen. Ein Postprozessor ist nur Javascript-Code in speziellen Klammern am Ende einer Regel. Zum Beispiel Regel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nummer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ich nie in irgendwelchen L√ºcken auf beiden Seiten der Zahl interessierte. Daher w√§re es praktisch, wenn die Regel einfach eine Zahl und kein Array von drei Elementen zur√ºckgeben w√ºrde. Hier ist ein Postprozessor, der diese Aufgabe ausf√ºhrt:</font></font><br><br><blockquote> <code><b>number -&gt; WS decimal WS {% default =&gt; default[1] %}</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Postprozessor nimmt das Standardergebnis (das oben gezeigte Array mit drei Elementen) und ersetzt es durch das zweite Element des Arrays, bei dem es sich um die Javascript-Nummer aus der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dezimalregel handelt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">So , </font><font style="vertical-align: inherit;">jetzt regiert </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zahl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kehrt die reelle Zahl. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dieser Funktion kann eine eingehende Sprache in eine Zwischensprache umgewandelt werden, mit der einfacher gearbeitet werden kann. </font><font style="vertical-align: inherit;">Zum Beispiel kann ich die Nearley-Grammatik verwenden, um eine MBDL-Zeichenfolge in ein Array von Javascript-Strukturen umzuwandeln, von denen jede ein durch ein "op" -Feld gekennzeichnetes Grundelement darstellt. </font><font style="vertical-align: inherit;">Die Regel f√ºr das Zeilenprimitiv sieht ungef√§hr so ‚Äã‚Äãaus:</font></font><br><br><blockquote> <code><b>element -&gt;</b> <b>"</b> <b>L(" number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)" {% data=&gt; {op:</b> <b>"</b> <b>L", width: data[1], color: data[3]} %}</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das hei√üt, das Ergebnis des Parsens von ‚ÄûL (13, schwarz)‚Äú ist die Javascript-Struktur: </font></font><br><br><blockquote> <code><b>{op:</b> <b>"</b> <b>L", width: 13, color:</b> <b>"</b> <b>black"}</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Hinzuf√ºgen der entsprechenden Nachbearbeitung kann das von der Grammatik zur√ºckgegebene Ergebnis eine Folge (Array) von Operationsstrukturen f√ºr die eingehende Zeile sein. </font><font style="vertical-align: inherit;">Das hei√üt, das Ergebnis des Parsens der Zeichenfolge</font></font><br><br><blockquote> <code><b>L( 415, ‚Äúblack") <br> VS(5) <br> [B(1, 2, ‚Äúblack", 3, ‚Äúwhite") HS(5) E(1, 2, ‚Äúblack", 3, ‚Äúwhite")]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird sein </font></font><br><br><blockquote> <code><b>[ <br> {op: "L", width: 415, color: "black"}, <br> {op: "VS", width: 5}, <br> {op: "P", <br> elements: [{op: "B", width: 1, length: 2, <br> olColor: "black", olWidth: 3, <br> fill: "white"}, <br> {op: "HS", width: 5}, <br> {op: "E", width: 1, length: 2, <br> olColor: "black", olWidth: 3, <br> fill: "white"}]} <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist viel einfacher zu verarbeiten, um einen Kartenrand zu erstellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An dieser Stelle haben Sie m√∂glicherweise eine Frage: Wenn die Nachbearbeitungsphase der Nearley-Regel Javascript enthalten kann, √ºberspringen Sie dann die Zwischenansicht und zeichnen Sie einfach den Rand der Karte direkt w√§hrend der Nachbearbeitung. </font><font style="vertical-align: inherit;">F√ºr viele Aufgaben w√§re dieser Ansatz ideal. </font><font style="vertical-align: inherit;">Ich habe mich aus mehreren Gr√ºnden entschieden, es nicht zu verwenden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstens gibt es in MBDL einige (*) Komponenten, die w√§hrend des Analyseprozesses nicht ausgef√ºhrt werden k√∂nnen. Beispielsweise k√∂nnen wir w√§hrend des Analyseprozesses keine sich wiederholenden geometrischen Elemente (Streifen oder Raute) zeichnen, da wir Informationen von anderen Elementen im selben Muster kennen m√ºssen. Insbesondere m√ºssen wir die Gesamtl√§nge des Musters kennen, um zu verstehen, wie weit wir die Wiederholungen jedes einzelnen Elements anordnen m√ºssen. Das hei√üt, das Element des Musters sollte immer noch eine Zwischendarstellung aller geometrischen Elemente erstellen. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(* Es gibt andere Komponenten mit √§hnlichen Einschr√§nkungen, √ºber die ich noch nicht gesprochen habe.)</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens ist Javascript in Nearley in die Regeln eingebettet, sodass wir keine zus√§tzlichen Informationen an Javascript √ºbergeben k√∂nnen, au√üer f√ºr globale Variablen. Um beispielsweise den Rand zu zeichnen, muss ich die Gr√∂√üe der Karte, die vier verwendeten K√ºrzungsbereiche usw. kennen. Obwohl ich Code hinzuf√ºgen kann, der diese Informationen Nearley-Postprozessoren zur Verf√ºgung stellt, ist er etwas chaotisch und es kann schwierig sein, diesen Code zu verwalten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus diesen Gr√ºnden analysiere ich eine Zwischendarstellung, die dann ausgef√ºhrt wird, um den Rand der Karte selbst zu erstellen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der n√§chste Schritt besteht darin, einen Interpreter zu entwickeln, der eine Zwischendarstellung von MBDL empf√§ngt und ausf√ºhrt, um Kartengrenzen zu generieren. Dies ist nicht sehr schwer zu tun. Grunds√§tzlich besteht die Aufgabe darin, die Anfangsbedingungen festzulegen (z. B. K√ºrzungsbereiche f√ºr die vier Seiten der Karte zu generieren) und die Sequenz der Strukturen der Zwischendarstellung zu durchlaufen, wobei jede ausgef√ºhrt wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt ein paar rutschige Momente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst muss ich vom Rendern von innen zum Zeichnen von innen nach au√üen √ºbergehen. Der Grund daf√ºr ist, dass die meisten R√§nder die Karte nicht √ºberlappen sollen. Daher muss ich die R√§nder so zeichnen, dass die Linien des inneren Randes mit den R√§ndern der Karte √ºbereinstimmen. Wenn ich von au√üen nach innen zeichne, muss ich die Breite des Rahmens kennen, bevor ich mit dem Zeichnen beginne, damit der Rand die Karte nicht √ºberlappt. Wenn ich von innen nach au√üen zeichne, beginne ich einfach am Rand der Karte und zeichne heraus. Au√üerdem k√∂nnen Sie der Karte optional einen Rahmen hinzuf√ºgen. Beginnen Sie den Rand einfach mit einem negativen vertikalen Leerzeichen (VS).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiterer schwieriger Punkt sind die sich wiederholenden Muster. </font><font style="vertical-align: inherit;">Um sich wiederholende Muster zu zeichnen, muss ich alle Elemente des Musters betrachten und das breiteste bestimmen, da dadurch die Breite des gesamten Musters festgelegt wird. </font><font style="vertical-align: inherit;">Ich muss auch die L√§nge des Musters betrachten und verfolgen, damit ich wei√ü, wie viel Abstand ich vor jeder Wiederholung lassen muss. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist ein Beispiel f√ºr einen ziemlich komplexen Rand, mit dem ich den Interpreter getestet habe:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c8/88a/2a9/3c888a2a96352845f6165f5eca7f6ab3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich denke, es war m√∂glich (notwendig?), Es zum Testen an den Parser anzuh√§ngen, aber f√ºr diesen Rahmen habe ich nur manuell eine Zwischenansicht erstellt: </font></font><br><br><blockquote> <code><b>[ <br> {op:'P', elements: [ <br> {op:'B', width: 10, length: 37, lineWidth: 2, color: 'black', fill: 'white'}, <br> {op:'B', width: 10, length: 37, lineWidth: 2, color: 'black', fill: 'black'}, <br> ]}, <br> {op:'VS', width: 2}, <br> {op:'L', width:3, color: 'black'}, <br> {op:'PUSH'}, <br> {op:'L', width:10, color: 'rgb(222,183,64)'}, <br> {op:'POP'}, <br> {op:'PUSH'}, <br> {op:'P', elements: [ <br> {op:'E', width: 5, length: 5, lineWidth: 1, color: 'black', fill: 'red'}, <br> {op:'HS', length: 10}, <br> ]}, <br> {op:'L', width:3, color: 'black'}, <br> {op:'POP'}, <br> {op:'VS', width: 2}, <br> {op:'P', elements: [ <br> {op:'E', width: 2, length: 2, lineWidth: 0, color: 'black', fill: 'white'}, <br> {op:'HS', length: 13}, <br> ]}, <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe diese Ansicht durch Ausprobieren erstellt. Wie dem auch sei, der Dolmetscher arbeitet! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie mich als letzten Schritt den Parser verwenden, um eine Zwischenansicht aus der MBDL-Version zu erstellen. Hier gibt es nicht viel zu zeigen: Ich musste ein paar Feldnamen korrigieren, aber ansonsten funktionierte der Code einwandfrei. F√ºr den Rand habe ich eine etwas andere Version von MBDL verwendet:</font></font><br><br><blockquote> <code><b>[B(5,37,"black",2,"white") B(5,37,"black",2,"black")] <br> VS(3) <br> L(3,"black") <br> {L(10,"rgb(222,183,64)")} <br> [E(5,5,"black",1,"red") HS(-5) E(2,2,"none",0,"white") HS(10)] <br> L(3,"black")</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie zeichnet den gleichen Rand, aber auf etwas andere Weise. </font><font style="vertical-align: inherit;">Ich habe auch die Syntax f√ºr das Overlay ge√§ndert und die Klammern durch geschweifte Klammern ersetzt, damit sie sich st√§rker von der anderen Syntax unterscheiden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um zu zeigen, warum ich von innen nach au√üen zeichnen und nicht nur den Rand automatisch au√üerhalb der Karte platzieren wollte, kann ich am Anfang dieses Rahmens einen negativen vertikalen Abstand einf√ºgen, um den Kartenma√üstab innerhalb des Kartenrandes zu verschieben:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ce/ea0/3df/0ceea03df1f07131e0ad27e6bbd45731.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt habe ich den gr√∂√üten Teil der Infrastruktur, die f√ºr die prozedurale Generierung von Kartenr√§ndern erforderlich ist: eine Grenzbeschreibungssprache, einen Sprachparser und Verfahren zum Durchf√ºhren einer Zwischendarstellung. </font><font style="vertical-align: inherit;">Es bleibt nur der schwierige Teil zu behandeln - die prozedurale Generierung!</font></font><br><br><h2>  Teil 6 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem die gesamte MBDL implementiert wurde, wollte ich mit der prozeduralen Generierung von Kartenr√§ndern fortfahren. Ich bin mir jedoch noch nicht sicher, wie ich dies tun m√∂chte, da ich noch ein wenig verweilen und ein paar weitere MBDL-Funktionen implementieren werde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der ersten Diskussion der Eckenverarbeitung mit Mustern habe ich √ºber verschiedene Ans√§tze gesprochen. Am Ende erkannte ich die abgeschr√§gten Ecken, aber es gab eine zweite Option: Stoppen Sie das Muster in der N√§he der Ecke, wie in diesen Beispielen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b7/94d/01b/3b794d01b552c42ed9b8362f5405ff9d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/3a8/159/ee23a8159d81afd1f7c95c16a90bcdf7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine solche L√∂sung wird h√§ufig verwendet, wenn das Randmuster eine Art asymmetrische Figur, Runen oder etwas anderes ist, das nicht um 90 Grad gedreht werden kann, w√§hrend die Ausrichtung beibehalten wird. Es ist jedoch offensichtlich, dass dies mit geometrischen Formen funktioniert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist m√∂glicherweise die Option, die Sie vor dem Generieren des Rahmens ausw√§hlen. Sie k√∂nnen jedoch ein wenig Flexibilit√§t hinzuf√ºgen, wenn Sie sie von einem Teil des Rahmens aus aktivieren und die abgeschr√§gte Ecke auf dem anderen verwenden. Dazu muss ich MBDL einen neuen Befehl hinzuf√ºgen. Ich vermute, dass andere Optionen f√ºr verschiedene Teile der Grenze auftreten k√∂nnen, daher werde ich einen allgemeinen Optionsbefehl hinzuf√ºgen:</font></font><br><br><blockquote> <code><b>element -&gt; "O(MITER)"</b> <br> <b>element -&gt; "O(STOPPED)"</b> <br> <b>element -&gt; "O(STOPPED," number ")"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Auch hier lassen wir aus Gr√ºnden der √úbersichtlichkeit Leerzeichen und einige andere Details weg.) Bisher sind die einzigen Optionen "MITRE" f√ºr abgeschr√§gte Ecken und "STOPPED" zum Anhalten in der N√§he von Ecken. </font><font style="vertical-align: inherit;">Wenn kein Wert STOPPED √ºbertragen wird, stoppt das Programm das Muster in einem angemessenen Abstand von der Ecke. </font><font style="vertical-align: inherit;">Wenn der Wert √ºbertragen wird, stoppt das Muster in diesem Abstand von der Ecke. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn STOPPED-Ecken verwendet werden, h√∂re ich auf, das Eckmuster von den Ecken weg zu zeichnen.</font></font> So sieht es aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8e/5df/49e/a8e5df49eecf2ebc5e94e571cb7d0ff8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier habe ich die MITRE-Option f√ºr das Schwarz-Wei√ü-Skalenmuster verwendet, damit es in Bezug auf den Winkel gespiegelt wird. </font><font style="vertical-align: inherit;">F√ºr ein Muster aus roten Kreisen und schwarzen Quadraten innerhalb einer goldenen Linie (und f√ºr ein Muster aus Kreisen au√üerhalb des Randes) habe ich STOPPED verwendet. </font><font style="vertical-align: inherit;">Sie k√∂nnen sehen, dass diese beiden Muster in der N√§he der Ecke enden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt jedoch einige Probleme. Erstens sehen wir, dass links das der Ecke am n√§chsten liegende Element ein schwarzes Quadrat und oben ein roter Kreis ist. Dies geschah, weil sich die Ecke auf der einen Seite nahe dem Beginn der Wiederholung und auf der anderen Seite nahe dem Ende der Wiederholung befindet. Aber es sieht komisch aus. Es w√§re besser, wenn die Ecken symmetrisch w√§ren, auch wenn wir daf√ºr am Ende des Musters ein weiteres Element hinzuf√ºgen m√ºssten. Zweitens k√∂nnen Sie sehen, dass das Muster au√üerhalb des Randes (Halbkreise und schwarze Punkte) auch in einer Wiederholung bis zur Ecke endet. Da die L√§nge dieser Wiederholung jedoch viel geringer ist als die L√§nge der roten Kreise / schwarzen Quadrate, landen sie an verschiedenen Stellen. Es w√§re wahrscheinlich besser, wenn alle Muster im gleichen Abstand von der Ecke anhalten w√ºrden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das erste Problem zu beheben, m√ºssen Sie am Ende jeder Seite des Rahmens eine weitere Wiederholung des ersten Elements des Musters hinzuf√ºgen. </font><font style="vertical-align: inherit;">Tats√§chlich ist es jedoch etwas komplizierter, da ich einen negativen horizontalen Versatz innerhalb des Musters verwenden k√∂nnte, um mehrere Elemente zu √ºberlappen (wie hier ausgef√ºhrt). </font><font style="vertical-align: inherit;">Sie m√ºssen au√üerdem jedem Element des Musters, das denselben Startpunkt wie das erste Element hat, eine weitere Wiederholung hinzuf√ºgen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/331/6fc/9c43316fcd44d79a0b2374401a46240a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt ist das Muster in Bezug auf den Winkel symmetrisch und sieht viel besser aus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als n√§chstes muss ich das l√§ngste STOPPED-Muster verfolgen und jedes STOPPED-Muster in dieser Entfernung anhalten:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a33/920/c6c/a33920c6cda9072bbda915544f1f4926.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt wird das Muster der wei√üen Kreise mehr beiseite gelegt, aber es ist immer noch nicht mit dem Muster der roten Kreise ausgerichtet. </font></font> Warum?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies geschah, weil das wei√üe Kreismuster weiter vom Rand der Karte entfernt ist und der Rand l√§nger ist als dort, wo das rote Kreismuster gezeichnet wird. </font><font style="vertical-align: inherit;">Um dieses Problem zu beheben, m√ºssen Sie auch die Muster verschieben und ihren Versatz relativ zum Rand der Karte ber√ºcksichtigen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70b/574/2c1/70b5742c1d4f404335b97128f09d6baf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt ist alles sch√∂n ausgerichtet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zweite Option f√ºr Winkel sind die quadratischen Vers√§tze in den Ecken, zum Beispiel diese:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/37e/bac/cac37ebac81815955dfc940bacdc2eff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird viel schwieriger sein, dies umzusetzen! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Grammatik dieser Option ist jedoch einfach und verwendet den Options-Opcode:</font></font><br><br><blockquote> <code><b>element -&gt; "O(SQOFFSET)"</b> <br> <b>element -&gt; "O(SQOFFSET," number ")"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zahl gibt die Gr√∂√üe der quadratischen Verschiebung f√ºr das Element am Rand der Karte an. </font><font style="vertical-align: inherit;">Elemente mit unterschiedlichen Offsets m√ºssen entsprechend ausgerichtet werden. </font><font style="vertical-align: inherit;">Wenn keine Nummer vorhanden ist, w√§hlt das Programm die entsprechende Versatzgr√∂√üe aus. </font><font style="vertical-align: inherit;">Durch Nullstellen der Zahl wird der quadratische Versatz deaktiviert. </font><font style="vertical-align: inherit;">Auf diese Weise k√∂nnen Sie Rahmen erstellen, in denen einige Elemente quadratische Offsets verwenden, w√§hrend andere dies nicht tun, wie in diesem Rahmen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/fd8/336/97bfd833697b9278660772c1bd04ee46.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als erstes wurde mir klar, dass ich zus√§tzliche K√ºrzungsbereiche ben√∂tigen w√ºrde, da ich die K√ºrzung verwende, um Stellen zu verarbeiten, an denen der Rand die Richtung √§ndert. </font><font style="vertical-align: inherit;">SQOFFSET erfordert komplexere K√ºrzungsbereiche. </font><font style="vertical-align: inherit;">Sie ben√∂tigen auch separate Bereiche f√ºr verschiedene Elemente, wenn Sie SQOFFSET aktivieren und deaktivieren. </font><font style="vertical-align: inherit;">Angesichts der Tatsache, dass K√ºrzungsbereiche ohnehin unerw√ºnschte Artefakte hinzuf√ºgen, scheint dies zu viel Arbeit zu sein.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als ich oben an stoppbaren Mustern gearbeitet habe, habe ich das Ausf√ºllen eines asymmetrischen Musters implementiert, um eine weitere Wiederholung von einem Ende des Musters hinzuzuf√ºgen. Ich erkannte auch, dass dies die Notwendigkeit abgeschr√§gter Ecken beseitigen w√ºrde. Ich werde einfach alle Muster entlang des Randes im Uhrzeigersinn zeichnen, wobei das Muster in einer Ecke beginnt und in der N√§he der n√§chsten Ecke endet. Dadurch kann ich K√ºrzungsbereiche entfernen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Wichtigste bei dieser neuen Art der Arbeit mit Ecken war, dass das erste Element des Musters nicht mehr in zwei Seiten ‚Äûunterteilt‚Äú ist. Wenn Sie sich die Schwarz-Wei√ü-Skalenmuster auf den Karten oben ansehen, sehen Sie, dass ein wei√ües Rechteck durch die Ecke verl√§uft. Jetzt st√∂√üt das wei√üe Rechteck an die Ecke:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ead/909/c83/ead909c83fa91ff80af290ab92ca9fae.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karten werden auf beide Arten gezeichnet, aber dies ist kein sehr gro√ües Problem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr den Anfang habe ich Offsets f√ºr Linien implementiert. </font><font style="vertical-align: inherit;">Dazu gen√ºgte es, die Linie relativ zu den entsprechenden Winkeln zu drehen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c2/bf6/2fd/9c2bf62fdfec732f56361f4aa17fc19e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie Sie verstehen k√∂nnen, kann ich Winkel mit Offsets und regul√§ren Winkeln kombinieren, wie in der obigen Karte: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0b/f5b/e02/e0bf5be02606044dd5fba4f82d3dad67.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich ist es schwieriger, die Muster um die Ecke zu drehen. </font><font style="vertical-align: inherit;">Die allgemeine Idee ist, von einer Ecke zur anderen zu ziehen und so weiter entlang der Grenze, bis wir zum Anfang zur√ºckkehren. </font><font style="vertical-align: inherit;">Theoretisch reicht es aus, nur horizontale und vertikale Muster zu zeichnen, und alles sollte sch√∂n ausgerichtet sein. </font><font style="vertical-align: inherit;">Das alles zu verfolgen ist ziemlich trostlos. </font><font style="vertical-align: inherit;">Tats√§chlich musste ich den Code zweimal komplett neu schreiben und ein paar Papiere schreiben, aber ich werde nicht im Detail dar√ºber sprechen. </font><font style="vertical-align: inherit;">Zeigen Sie einfach das Ergebnis:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/35b/889/91235b889603c973fcfe094a1614a993.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In den Ecken entsteht eine st√∂rende optische T√§uschung - das Eckelement scheint n√§her an der Au√üenseite der Ecke nicht zentriert zu sein. </font><font style="vertical-align: inherit;">In der Tat ist dies nicht wahr, aber es scheint so, weil n√§her an der Innenseite der Ecke visuell mehr leerer Raum ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Segmente der Versatzwinkel ziemlich kurz sind, ist es sehr einfach, ein Nichtgleichgewichtsmuster in der Ecke zu erstellen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1b/601/dff/b1b601dffc11782fb8cbe738a906b0e5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manchmal sieht es ziemlich h√§sslich aus. </font><font style="vertical-align: inherit;">Es erinnerte mich an einen alten Witz:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patient: "Doktor, wenn ich das mache, tut es mir weh." </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doktor: "Dann mach das nicht!"</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deshalb werde ich versuchen, dies nicht zu tun. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normalerweise zeichne ich den Kartenma√üstab nicht entlang des Versatzwinkels, aber wenn ich ihn brauche, muss ich die Option verwenden, mit der das Muster so gedehnt wird, dass der Kartenma√üstab ohne L√ºcken zwischen den Rechtecken in die Ecke passt:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26f/a88/0da/26fa880da6d00d380afdae60c489dd9c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen sehen, dass die Gr√∂√üe der Skalierungsrechtecke daher stark variiert. </font><font style="vertical-align: inherit;">Das hei√üt, dies ist keine sehr gute Option. </font><font style="vertical-align: inherit;">(√úbrigens haben die Versatzwinkel auch einen Fehler im Kreismuster. Sp√§ter habe ich ihn behoben, aber wie gesagt, es ist sehr schwierig, dies zu tun.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das Muster zu gro√ü ist, um auf das Segment des Versatzwinkels zu passen, gibt der Algorithmus einfach auf:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4d/044/b2d/b4d044b2dc2bf23cd670113476b9803d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist alles andere als ideal, aber wie ich oben sagte: "Dann tu es nicht." </font><font style="vertical-align: inherit;">(Es ist eigentlich nicht sehr schwierig, eine Komprimierungs- oder Dehnungsfunktion hinzuzuf√ºgen, wenn ich sie ben√∂tige.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was passiert, wenn ich sowohl versetzte Ecken als auch die Option verwende, mit der die Muster vor den Ecken gestoppt werden? </font><font style="vertical-align: inherit;">In diesem Fall halte ich einfach nicht weit von den versetzten Ecken an:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/170/d60/9c1/170d609c1b789359490e35741215ba04.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es scheint mir, dass dies eine logische Entscheidung ist. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444190/">https://habr.com/ru/post/de444190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444178/index.html">9 Tipps zum Erstellen von Indie-Spielen von einem einzelnen Entwickler</a></li>
<li><a href="../de444182/index.html">Gehen Sie Bedingungen und ihre Kuriosit√§ten</a></li>
<li><a href="../de444184/index.html">√úber die Aussichten vormontierter Rechenzentren</a></li>
<li><a href="../de444186/index.html">Flattern 1.2. Was gibt's Neues?</a></li>
<li><a href="../de444188/index.html">CG Pods - TWS-Kopfh√∂rer, die es k√∂nnten</a></li>
<li><a href="../de444192/index.html">API Management Mitap - IBM, Google, Yandex und Leroy Merlin Experience - Datensatz verf√ºgbar</a></li>
<li><a href="../de444198/index.html">Dropbox begrenzt die Synchronisation: jetzt nur noch 3 Ger√§te</a></li>
<li><a href="../de444200/index.html">Probleml√∂sungssitzung</a></li>
<li><a href="../de444204/index.html">Einf√ºhrung in das Testen in Python. Teil 3</a></li>
<li><a href="../de444206/index.html">27. M√§rz, Moskau - JavaScript MeetUP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>