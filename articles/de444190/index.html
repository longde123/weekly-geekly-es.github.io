<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥚 👨🏽‍🤝‍👨🏻 🛰️ Erstellen Sie die Ränder einer prozedural generierten Karte 🙌🏻 👩‍👦‍👦 ✌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Scott Turner arbeitet weiterhin an seinem prozedural generierten Spiel und hat sich nun entschlossen, das Problem der Gestaltung der Kartengrenzen anz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen Sie die Ränder einer prozedural generierten Karte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444190/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ce/ea0/3df/0ceea03df1f07131e0ad27e6bbd45731.png" alt="Bild"></div><br>  <i>Scott Turner arbeitet weiterhin an seinem prozedural generierten Spiel und hat sich nun entschlossen, das Problem der Gestaltung der Kartengrenzen anzugehen.</i>  <i>Dazu muss er einige schwierige Probleme lösen und sogar eine eigene Sprache zur Beschreibung von Grenzen erstellen.</i> <br><br>  Grenzen blieben ein wichtiges Element von Fantasy-Karten, die schon seit einiger Zeit auf meiner Liste standen.  Funktionale Karten haben normalerweise eine einfache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grenzlinie</a> , aber Fantasy-Karten und mittelalterliche Karten, von denen die ersteren oft Ideen entlehnen, haben ziemlich durchdachte und künstlerische Grenzen.  Diese Grenzen machen deutlich, dass die Karte absichtlich fantastisch gemacht wurde, und geben dem Betrachter ein Gefühl des Staunens. <br><br>  Derzeit gibt es in meinem Spiel <b>Dragons Abound</b> einige einfache Möglichkeiten, Grenzen zu ziehen.  Sie kann eine einfache oder doppelte Linie um den Umfang der Karte ziehen und einfache Elemente in die Ecken einfügen, wie in diesen Abbildungen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aed/9f8/477/aed9f8477ef53b5550b742ea1fde36b2.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/37e/bac/cac37ebac81815955dfc940bacdc2eff.png"></div><br>  Das Spiel kann auch ein Feld am unteren Rand des Rahmens für den Namen der Karte hinzufügen.  In <b>Dragons Abound</b> gibt es verschiedene Variationen dieses Feldes, einschließlich so komplexer Elemente wie gefälschter Schraubenköpfe: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42f/f6f/c3a/42ff6fc3adae5b40293bb82d5a1be325.png"></div><br>  Diese Namensfelder sind unterschiedlich, werden jedoch alle manuell erstellt. <br><br>  Ein interessanter Aspekt der Grenzen von Fantasy-Karten ist, dass sie sowohl kreativ als auch als Vorlage dienen.  Oft bestehen sie aus einer kleinen Anzahl einfacher Elemente, die auf unterschiedliche Weise kombiniert werden, um ein einzigartiges Ergebnis zu erzielen.  Wie immer besteht der erste Schritt bei der Arbeit mit einem neuen Thema für mich darin, eine Sammlung von Kartenbeispielen zu studieren, einen Katalog von Randelementtypen zu erstellen und deren Erscheinungsbild zu untersuchen. <br><a name="habracut"></a><br>  Der einfachste Rand ist eine Linie, die entlang der Ränder der Karte verläuft und deren Grenzen angibt.  Wie ich oben sagte, wird es auch als "Rahmenlinie" bezeichnet: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99f/c81/c98/99fc81c98e1092077272081464d28752.png"></div><br>  Es gibt auch eine Variation mit der Position der Ränder innerhalb der Karte.  In dieser Version erreicht die Karte die Bildränder, aber der Rand erstellt einen virtuellen Rand innerhalb des Bildes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43f/aef/1db/43faef1db7bf3af195c857d7ed673710.png"></div><br>  Dies kann mit jeder Art von Rahmen durchgeführt werden, wird jedoch normalerweise nur mit einfachen Rändern wie dem Rand eines Rahmens verwendet. <br><br>  Ein beliebtes Designkonzept für Fantasy-Karten besteht darin, zu simulieren, als ob sie auf altem zerrissenem Pergament gezeichnet wären.  Manchmal wird dies durch Zeichnen des Randes als raue Kante des Papiers realisiert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/907/cb2/ff1/907cb2ff125bbd178f9a16717e5e724f.png"></div><br>  Hier ist ein komplexeres Beispiel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/751/860/d6e/751860d6e43ed2e857cf6f3ba7f766e0.png"></div><br>  Nach meiner Erfahrung ist diese Methode weniger populär geworden, weil digitale Werkzeuge zum Einsatz gekommen sind.  Wenn Sie möchten, dass die Karte wie ein altes zerrissenes Pergament aussieht, ist es einfacher, die Textur des Pergaments darauf aufzutragen, als es von Hand zu zeichnen. <br><br>  Das leistungsstärkste Werkzeug zum Erstellen von Kartenrändern ist die Wiederholbarkeit.  Im einfachsten Fall reicht es aus, eine einzelne Zeile zu wiederholen, um zwei Zeilen zu erstellen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/139/e12/31d139e129fe513e07937c5a2bd88979.png"></div><br>  Sie können der Karte Interesse hinzufügen, indem Sie den Stil des wiederholten Elements variieren. In diesem Fall kombinieren Sie eine dicke einzelne Linie mit einer dünnen einzelnen Linie: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/530/ccd/118/530ccd11872f4aa6a32d4b3271cf94f3.png"></div><br>  Je nach Element sind verschiedene Stilvarianten möglich.  In diesem Beispiel wiederholt sich die Linie, aber die Farbe ändert sich: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc7/89e/96c/fc789e96ccfba58ac4cb595e5ec33fb7.png"></div><br>  Um komplexere Muster zu erstellen, können Sie die „wiederholbare Wiederholbarkeit“ verwenden.  Dieser Rand besteht aus ungefähr fünf einzelnen Linien mit unterschiedlichen Breiten und Abständen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/488/ef4/796488ef402e59ed7e092e0e14ff2469.png"></div><br>  Dieser Rand wiederholt die Linien, trennt sie jedoch so, dass sie wie zwei separate dünne Ränder aussehen.  In diesem Teil des Beitrags werde ich nicht auf die Eckenverarbeitung eingehen, aber unterschiedliche Winkel für die beiden Linien helfen auch dabei, diesen Unterschied zu erzeugen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/fd8/336/97bfd833697b9278660772c1bd04ee46.png"></div><br>  Sind das zwei Zeilen, vier oder sechs?  Ich denke, es hängt alles davon ab, wie du sie zeichnest! <br><br>  Ein weiteres Element der Stilisierung ist das Füllen des Raums zwischen Elementen mit Farbe, Muster oder Textur.  In diesem Beispiel wurde der Rand aufgrund der Akzentfarbe zwischen den beiden Linien interessanter: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d8/ccf/158/1d8ccf158b9ae0378ddaef1031ba15c9.png"></div><br>  Hier ist ein Beispiel, wie der Rand mit einem Muster gefüllt wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f87/37d/bb2/f8737dbb215166947e42f0da1b45cfc7.png"></div><br>  Außerdem können Elemente so gestaltet werden, dass sie dreidimensional aussehen.  Hier ist eine Karte, in der der Rand so schattiert ist, dass er voluminös aussieht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a80/25b/695/a8025b69549773f8935d2b37680401a3.png"></div><br>  In dieser Karte ist der Rand dreidimensional schattiert und wird mit der Position der Ränder innerhalb der Kartenränder kombiniert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36c/899/9e7/36c8999e74172c962aef40a4a9e3addc.png"></div><br>  Ein weiteres häufiges Randelement ist die Skala in Form von mehrfarbigen Streifen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ee/f62/0b8/4eef620b830eb0249d019229140e34e6.png"></div><br>  Diese Streifen bilden ein Raster ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kartografisches Raster</a> ).  Auf realen Karten hilft der Maßstab bei der Bestimmung von Entfernungen, auf Fantasy-Karten ist er jedoch hauptsächlich ein dekoratives Element. <br><br>  Diese Streifen werden normalerweise in Schwarzweiß gezeichnet, aber manchmal wird Rot oder eine andere Farbe hinzugefügt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/450/f0f/f67/450f0ff67ac1fdf5c5e2ffaf8fbe80c0.png"></div><br>  Dieses Element kann auch mit anderen kombiniert werden, wie in diesem Beispiel mit Linien und Skalierung: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/313/d56/29d/313d5629d6ec8b8d7c7c4c1ead322a09.png"></div><br>  Dieses Beispiel ist etwas ungewöhnlich.  Normalerweise ist die Skala (falls vorhanden) das innerste Element der Grenze. <br><br>  Auf dieser Karte gibt es verschiedene Maßstäbe mit unterschiedlichen Auflösungen (sowie seltsame Runennoten!): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/cd6/217/74bcd62173160e440a4ee6cfad2128c1.png"></div><br>  (Auf Reddit teilte mir Benutzer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AbouBenAdhem</a> mit, dass Runenzeichen die Nummern 48 und 47 sind, die in babylonischer Keilschrift geschrieben sind. Außerdem haben „Skalen mit unterschiedlichen Auflösungen“ sechs Unterteilungen, die in zehn kleinere Unterteilungen unterteilt sind, was dem babylonischen Hexadezimalzahlensystem entspricht. Normalerweise Ich gebe die Quellen der Karten an, aber es gibt zu viele kleine Stücke in diesem Beitrag, so dass ich mich nicht darum gekümmert habe. Diese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Karte wurde</a> jedoch von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thomas Ray</a> für den Autor S.E. Boleyn erstellt, sodass die Aktion in seinen Büchern möglicherweise im Gefolge Babylons stattfindet.) <br><br>  Neben Linien und Maßstäben ist das häufigste Element ein sich wiederholendes geometrisches Muster.  Oft besteht es aus Teilen wie Kreisen, Rauten und Rechtecken: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31c/6ba/f61/31c6baf612bf2fa11a13905e4482d82e.png"></div><br>  Geometrische Elemente können wie Linien schattiert werden, damit sie dreidimensional aussehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/cc8/c33/43ecc8c33bbf3143ba32c18b878d16e2.png"></div><br>  Komplexe Grenzen können erstellt werden, indem diese Elemente auf unterschiedliche Weise kombiniert werden.  Hier ist der Rand, der Linien, geometrische Muster und Skalierungen kombiniert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  Die oben gezeigten Beispiele waren digitale Karten, aber das Gleiche kann natürlich auch mit handgeschriebenen Karten gemacht werden.  Hier ist ein Beispiel für ein einfaches geometrisches Muster, das von Hand erstellt wurde: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f7/c2d/e3d/6f7c2de3d5db82a9c7e9884d726be98e.png"></div><br>  Diese Elemente können auch auf viele Arten flexibel kombiniert werden.  Hier ist ein geometrisches Muster kombiniert mit einer „zerlumpten Kante“: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fa/f1a/150/0faf1a15052e90a479428c4c495ad44c.png"></div><br>  In den oben gezeigten Beispielen ist das geometrische Muster recht einfach.  Sie können jedoch sehr komplexe Muster erstellen, indem Sie die geometrischen Grundelemente auf andere Weise kombinieren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38e/13f/fc2/38e13ffc2a2aac266aabb291a7d7f0e6.png"></div><br>  Ein weiteres beliebtes Element des Musters ist das Weben oder der keltische Knoten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07e/00e/8d8/07e00e8d868b6ca48be746fbe07e61ca.png"></div><br>  Hier ist ein komplexerer Weidenrand, der Farbe, Skalierung und andere Elemente enthält: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e1/580/140/5e158014012fffcbc51e2e3fe71772d6.png"></div><br>  Auf dieser Karte wird das Weben mit einem ausgefransten Kantenelement kombiniert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e95/4df/588/e954df58825bc42d408b61804a1287a9.png"></div><br>  Zusätzlich zu geometrischen Mustern und Webereien kann jedes sich wiederholende Muster Teil des Randes der Karte sein.  Hier ist ein Beispiel mit Formen, die Pfeilspitzen ähneln: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/5ce/64e/7be5ce64eb09de2eeefdb18992978d03.png"></div><br>  Und hier ist ein Beispiel mit einem sich wiederholenden Wellenmuster: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/841/c13/3c2/841c133c2f1c0f724b5d076e5ea415fb.png"></div><br>  Und schließlich werden Runen oder andere Elemente des Fantasy-Alphabets manchmal an den Rändern von Fantasy-Karten hinzugefügt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/6dd/3a3/15f6dd3a3e6191da02dc884193b72c82.png"></div><br>  Die obigen Beispiele stammen aus modernen Fantasy-Karten, aber hier ist ein Beispiel einer historischen Karte (18. Jahrhundert) mit Linien und einem handgezeichneten Muster: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d7/b9f/3b8/1d7b9f3b8f0c7eb296079c5f6f6b23aa.png"></div><br>  Natürlich finden Sie Beispiele für Karten mit vielen anderen Elementen an den Rändern.  Einige der schönsten sind vollständig handgezeichnet und so sorgfältig verarbeitet, dass sie die Karte selbst übertreffen können ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">World of Alma</a> , Francesca Baerald): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c7/004/e18/1c7004e186e0d2be63b98539375316ff.png"></div><br>  Es lohnt sich auch ein wenig über <i>Symmetrie zu</i> sprechen.  Wie die Wiederholbarkeit ist auch die Symmetrie ein leistungsstarkes Werkzeug, und Kartenränder sind normalerweise symmetrisch oder weisen symmetrische Elemente auf. <br><br>  Viele Kartenränder sind von innen nach außen symmetrisch, wie in diesem Beispiel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/488/ef4/796488ef402e59ed7e092e0e14ff2469.png"></div><br>  Hier besteht der Rand aus mehreren Linien mit und ohne Füllung, die sich jedoch von außen nach innen idealerweise relativ zur Randmitte wiederholen. <br><br>  In diesem komplexeren Beispiel ist der Rand symmetrisch, mit Ausnahme abwechselnder schwarzer und weißer Skalenstreifen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e1/580/140/5e158014012fffcbc51e2e3fe71772d6.png"></div><br>  Da das Duplizieren der Skala nicht sinnvoll ist, wird sie häufig als separates Element betrachtet, auch wenn der Rest des Randes symmetrisch ist. <br><br>  Zusätzlich zur internen und externen Symmetrie sind Ränder häufig entlang ihrer Länge re-symmetrisch.  Einige abgebildete Ränder haben möglicherweise ein einfaches Design, das sich über die gesamte Länge des Kartenrandes erstreckt. In den meisten Fällen ist das Muster jedoch recht kurz und wiederholt sich und füllt den Rand von einer Ecke zur anderen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  Beachten Sie, dass in diesem Beispiel das Muster ein Element enthält, das nicht symmetrisch ist (von links nach rechts), das allgemeine Muster jedoch symmetrisch ist und sich wiederholt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/5ce/64e/7be5ce64eb09de2eeefdb18992978d03.png"></div><br>  Eine bemerkenswerte Ausnahme von dieser Regel sind Ränder, die mit Runen oder alphabetischen Zeichen gefüllt sind.  Oft erweisen sie sich als einzigartig, als ob eine lange Nachricht entlang der Grenze geschrieben worden wäre: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/6dd/3a3/15f6dd3a3e6191da02dc884193b72c82.png"></div><br>  Natürlich gibt es viele andere Beispiele für Kartenrandelemente, die ich hier nicht berücksichtigt habe, aber wir haben bereits einen guten Bezugspunkt.  In den nächsten Teilen werde ich in <b>Dragons Abound</b> verschiedene Funktionen zum Beschreiben, Anzeigen und prozeduralen Generieren von Kartenrändern entwickeln, die diesen Beispielen ähneln.  Im zweiten Teil legen wir zunächst die Sprache für die Beschreibung der Kartenränder fest. <br><br><h2>  Teil 2 </h2><br>  In diesem Teil werde ich die erste Version der Map Border Description Language (MBDL) erstellen. <br><br>  Warum Zeit damit verbringen, eine Beschreibungssprache für Kartengrenzen zu erstellen?  Erstens wird dies das Ziel meiner prozeduralen Generierung sein.  Später werde ich einen Algorithmus zum Erstellen neuer Kartenränder schreiben, und die Ausgabe dieses Algorithmus wird eine Beschreibung des neuen Randes in MBDL sein.  Zweitens dient MBDL als Textdarstellung von Kartengrenzen.  Insbesondere muss ich in der Lage sein, meine Grenzen zu speichern und wiederzuverwenden.  Dazu benötige ich eine Textnotation, die geschrieben und verwendet werden kann, um den Rand der Karte neu zu erstellen. <br><br>  Ich beginne mit der Erstellung von MBDL, indem ich das einfachste Element definiere: die Zeile.  Die Linie hat Farbe und Breite.  Daher werde ich in MBDL die Zeile in dieser Form präsentieren: <br><br><blockquote><code>L(width, color)</code> </blockquote> <br>  Hier einige Beispiele (Entschuldigung für meine Photoshop-Kenntnisse): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db2/db8/68e/db2db868ede7282a34c695f8062a691b.png"></div><br>  Die Reihenfolge der Elemente wird von außen nach innen gerendert (*), daher nehmen wir an, dass dies der Rand oben auf der Karte ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7c/75e/b3a/b7c75eb3aefb8f77d1915166c0bdd979.png"></div><br>  Schauen Sie sich das zweite Beispiel an - eine Linie mit Rahmen wird als drei separate Linienelemente dargestellt. <br><br>  <i>(* Das Zeichnen von außen nach innen war eine willkürliche Entscheidung - es schien mir nur natürlicher zu sein als das Rendern von innen nach außen. Leider gab es, wie sich viel später herausstellte, einen guten Grund, in die entgegengesetzte Richtung zu arbeiten. Bald werde ich Ihnen davon erzählen, aber alles bleibt in der Post - alt, weil es viel Zeit in Anspruch nehmen würde, alle Abbildungen zu wiederholen)</i> <br><br>  Praktischerweise können Räume als Linien ohne Farbe dargestellt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ba/1a4/171/0ba1a41719610641d7b5a5e26da0692e.png"></div><br>  Es wäre jedoch visueller, ein bestimmtes vertikales Raumelement zu haben: <br><br><blockquote>  VS (Breite) </blockquote><br>  Die folgenden einfachen Elemente sind geometrische Formen: Streifen, Rauten und Ellipsen.  Es wird davon ausgegangen, dass die Linien über die gesamte Länge des Rahmens gespannt sind, sodass sie keine explizit angegebene Länge haben.  Geometrische Figuren können jedoch nicht die gesamte Linie ausfüllen. Daher sollte jede zusätzlich zur Breite (*) eine Länge, eine Umrissfarbe, eine Umrissbreite und eine Füllfarbe haben: <br><br><blockquote> <code>B(width, length, outline, outline width, fill) <br> D(width, length, outline, outline width, fill) <br> E(width, length, outline, outline width, fill)</code> </blockquote> <br>  (* Ich habe akzeptiert, dass ich die Breite in der Richtung von außen nach innen berücksichtigen werde und die Länge entlang der Grenze gemessen wird.) <br><br>  Hier sind Beispiele für einfache geometrische Formen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3d/fad/cf6/a3dfadcf6a5a98a9785b0b487a6e17fc.png"></div><br>  Damit diese Elemente die gesamte Länge des Rahmens ausfüllen, müssen sie wiederholt werden.  Um die Gruppe von Elementen anzugeben, die wiederholt werden, um die Länge des Rahmens auszufüllen, verwende ich eckige Klammern: <br><br><blockquote> <code>[ element element element ... ]</code> </blockquote> <br>  Hier ist ein Beispiel für ein sich wiederholendes Muster von Rechtecken und Rauten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/420/d88/64e/420d8864e72e178252766172dc0320ab.png"></div><br>  Manchmal brauche ich einen (horizontalen) Abstand zwischen Elementen eines sich wiederholenden Musters.  Obwohl Sie ein Element ohne Farben verwenden können, um einen Raum zu erstellen, ist es intelligenter und bequemer, ein horizontales Raumelement zu haben: <br><br><blockquote> <code>HS(length)</code> </blockquote> <br>  Die letzte Funktion, die für diese erste Iteration von MBDL benötigt wird, ist die Fähigkeit, Elemente übereinander zu stapeln.  Hier ist ein Beispielrand: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ea/7e9/3f3/8ea7e93f3040563ef7ec2715ca39a14d.png"></div><br>  Der einfachste Weg, dies zu beschreiben, ist eine breite gelbe Linie unter dem oberen Muster.  Sie können dies auf verschiedene Arten implementieren (z. B. in einem negativen vertikalen Raum), aber ich habe mich für geschweifte Klammern entschieden, um die Reihenfolge der Elemente nach innen anzugeben: <br><br><blockquote> <code>{element element element ...}</code> </blockquote> <br>  Tatsächlich fordert Sie dieser Eintrag auf, sich beim Betreten der Klammern zu merken, wo sich das Muster von außen nach innen befand, und beim Verlassen der Klammern zu diesem Punkt zurückzukehren.  Klammern können auch als Beschreibung von Elementen betrachtet werden, die einen vertikalen Raum einnehmen.  Daher kann der oben gezeigte Rand wie folgt beschrieben werden: <br><br><blockquote> <code><b>L(1, black) <br> {L(20, yellow)} <br> VS(3) <br> [B(5, 10, black, 3, none) <br> D(5, 10, black,3,red)] <br> VS(3) <br> L(1, black)</b></code> </blockquote> <br>  Wir zeichnen eine schwarze Linie, fixieren, wo wir sind, zeichnen eine gelbe Linie und kehren dann zu der zuvor festgelegten Position zurück, lassen uns ein wenig nach unten fallen, zeichnen ein Muster aus Rechtecken und Rauten, lassen ein wenig nach unten fallen und zeichnen dann eine weitere schwarze Linie. <br><br>  In MBDL gibt es noch viel mehr zu tun, aber dies reicht aus, um die vielen Grenzen von Karten zu beschreiben.  Der nächste Schritt besteht darin, die Grenzbeschreibung in der MBDL in die Grenze selbst zu konvertieren.  Dies ähnelt der Konvertierung einer schriftlichen Darstellung eines Computerprogramms (z. B. Javascript) in die Ausführung dieses Programms.  Die erste Stufe ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lexikalische Analyse (Analyse) der</a> Sprache - die Umwandlung des Quelltextes in einen realen Rand der Karte oder in eine Zwischenform, die einfacher in einen Rand umzuwandeln ist. <br><br>  Parsing ist ein ziemlich gut untersuchter Bereich der Informatik.  Das Parsen einer Sprache ist nicht sehr einfach, aber in unserem Fall ist es gut (*), dass MBDL eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kontextfreie</a> Grammatik ist.  Kontextfreie Grammatiken lassen sich relativ leicht analysieren, und es gibt viele <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Javascript-Parsing-Tools</a> für sie.  Ich habe mich für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nearley.js entschieden</a> , das ziemlich ausgereift und (was noch wichtiger ist) ein gut dokumentiertes Tool zu sein scheint. <br><br>  <i>(* Dies ist nicht nur Glück, ich habe dafür gesorgt, dass die Sprache kontextfrei ist.)</i> <br><br>  Ich werde Sie nicht in kontextfreie Grammatiken einführen, aber die Nearley-Syntax ist recht einfach und Sie sollten die Bedeutung ohne Probleme verstehen.  Grammatik Nearley besteht aus einer Reihe von Regeln.  Jede Regel hat links ein Symbol, einen Pfeil und den rechten Teil der Regel, der eine Folge von Zeichen und Nichtzeichen sein kann, sowie verschiedene Optionen, die durch das "|" getrennt sind.  (oder): <br><br><blockquote> <code><b>border -&gt; element | element border <br> element -&gt;</b> “ <b>L"</b></code> </blockquote> <br>  Jede der Regeln besagt, dass die linke Seite durch eine der Optionen auf der rechten Seite ersetzt werden kann.  Das heißt, die erste Regel besagt, dass ein Rand ein Element oder ein Element ist, gefolgt von einem anderen Rand.  Welches selbst kann ein Element sein oder ein Element, dem ein Rand folgt, und so weiter.  Die zweite Regel besagt, dass ein Element nur eine Zeichenfolge "L" sein kann.  Das heißt, zusammen entsprechen diese Regeln solchen Grenzen: <br><br><blockquote> <code><b>L <br> LLL</b></code> </blockquote> <br>  und entsprechen nicht solchen Grenzen: <br><br><blockquote> <code><b>X <br> L3L</b></code> </blockquote> <br>  Übrigens, wenn Sie mit dieser (oder einer anderen) Grammatik in Nearley experimentieren möchten, gibt es hier eine Online-Sandbox dafür.  Sie können Grammatik- und Testfälle eingeben, um zu sehen, was übereinstimmt und was nicht. <br><br>  Hier ist eine vollständigere Definition eines Linienprimitivs: <br><br><blockquote> <code><b>@builtin “number.ne" <br> @builtin “string.ne" <br> border -&gt; element | element border <br> element -&gt; “L(" decimal “," dqstring “)"</b></code> </blockquote> <br>  Nearley hat mehrere gemeinsame eingebaute Elemente, und die Nummer ist eines davon.  Daher kann ich damit die numerische Breite eines Linienprimitivs erkennen.  Für die Farberkennung verwende ich ein anderes integriertes Element und erlaube die Verwendung einer beliebigen Zeichenfolge in doppelten Anführungszeichen. <br><br>  Es wäre schön, Leerzeichen zwischen verschiedenen Zeichen einzufügen, also lass es uns tun.  Nearley unterstützt Zeichenklassen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RBNF</a> für "null oder mehr" von etwas mit ": *", sodass ich damit "null oder mehr Leerzeichen" angeben und an einer beliebigen Stelle einfügen kann, um Leerzeichen in Beschreibungen zuzulassen: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element border <br> WS -&gt; [\s]:* <br> number -&gt; WS decimal WS <br> color -&gt; WS dqstring WS <br> element -&gt; "L(" number "," color ")"</b></code> </blockquote> <br>  Die Verwendung von WS überall macht es jedoch schwierig, die Grammatik zu lesen, daher werde ich sie aufgeben, aber stellen Sie sich vor, dass sie es sind. <br><br>  Ein Element kann auch ein vertikaler Raum sein: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")"</b></code> </blockquote> <br>  Dies entspricht solchen Grenzen <br><br><blockquote> <code><b>L(3.5,"black") VS(3.5)</b></code> </blockquote> <br>  Als nächstes kommen die Grundelemente Streifen, Raute und Ellipse. <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")"</b></code> </blockquote> <br>  Es wird mit solchen Elementen übereinstimmen <br><br><blockquote> <code><b>B(34, 17, "white", 3, "black")</b></code> </blockquote> <br>  (Beachten Sie, dass geometrische Grundelemente keine „Elemente“ sind, da sie auf der obersten Ebene nicht allein sein können. Sie müssen in einem Muster eingeschlossen sein.) <br><br>  Ich brauche auch ein horizontales Raumprimitiv: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")"</b></code> </blockquote> <br>  Jetzt werde ich eine Musteroperation (Wiederholung) hinzufügen.  Dies ist eine Folge von einem oder mehreren Elementen in eckigen Klammern.  Ich werde den RBNF-Operator ": +" verwenden, was hier "einer oder mehrere" bedeutet. <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")" <br> element -&gt; "[" (geometric):+ "]"</b></code> </blockquote> <br>  Beachten Sie, dass das Muster nur mit geometrischen Grundelementen gefüllt werden kann.  Wir können zum Beispiel keine Linie innerhalb eines Musters platzieren.  Das Musterelement stimmt jetzt mit so etwas überein. <br><br><blockquote> <code><b>[B(34,17,"white",3,"black")E(13,21,"white",3,"rgb(27,0,0)")]</b></code> </blockquote> <br>  Der letzte Teil der Sprache ist der Overlay-Operator.  Dies ist eine beliebige Anzahl von Elementen in geschweiften Klammern. <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")" <br> element -&gt; "[" (geometric ):+ "]" <br> element -&gt; "{" (element ):+ "}"</b></code> </blockquote> <br>  Damit können wir Folgendes tun: <br><br><blockquote> <code><b>{L(3.5,"rgb(98,76,15)")VS(3.5)}</b></code> </blockquote> <br>  (Beachten Sie, dass der Overlay-Operator im Gegensatz zum Wiederholungsoperator intern verwendet werden kann.) <br><br>  Nachdem wir die Beschreibung bereinigt und den erforderlichen Stellen Leerzeichen hinzugefügt haben, erhalten wir die folgende MBDL-Grammatik: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; (element WS):+ <br> WS -&gt; [\s]:* <br> number -&gt; WS decimal WS <br> color -&gt; WS dqstring WS <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> element -&gt; "(" WS (element WS):+ ")" <br> element -&gt; "[" WS (geometric WS):+ "]" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")"</b></code> </blockquote> <br>  MBDL ist nun definiert und wir haben eine Grammatik der Sprache erstellt.  Es kann mit Nearley verwendet werden, um Sprachzeichenfolgen zu erkennen.  Bevor ich mich mit MBDL / Nearley befasse, möchte ich die in MBDL verwendeten Grundelemente implementieren, damit die in MBDL beschriebene Grenze angezeigt werden kann.  Dies werden wir im nächsten Teil tun. <br><br><h2>  Teil 3 </h2><br>  Jetzt werden wir beginnen, die Rendering-Grundelemente selbst zu implementieren.  (Zu diesem Zeitpunkt muss ich den Parser noch nicht an die Rendering-Grundelemente binden. Zum Testen rufe ich sie einfach manuell auf.) <br><br>  Beginnen wir mit der Grundlinie.  Erinnern Sie sich, wie es aussieht: <br><br><blockquote> <code><b>L(width, color)</b></code> </blockquote> <br>  Neben der Breite und Farbe gibt es hier einen impliziten Parameter - den Abstand vom äußeren Rand der Karte.  (Ich zeichne die Ränder vom Rand der Karte nach außen. Beachten Sie, dass wir von einem anderen ausgegangen sind!) Es sollte nicht auf die MBDL zeigen, da dies vom Interpreter verfolgt werden kann, der die MBDL ausführt, um den Rand zu zeichnen.  Dies sollte jedoch für alle Rendering-Grundelemente eingegeben werden, damit sie wissen, wo sie gezeichnet werden sollen.  Ich werde diesen Parameter Offset nennen. <br><br>  Wenn ich nur einen Rand am oberen Rand der Karte zeichnen müsste, wäre das Linienprimitiv sehr einfach zu implementieren.  Tatsächlich muss ich jedoch von oben zeichnen.  unten, links und rechts.  (Vielleicht werde ich eines Tages schräge oder gekrümmte Ränder erkennen, aber im Moment werden wir uns an rechteckige Standardränder halten.) Außerdem hängen Länge und Position des Linienelements von der Größe der Karte (sowie vom Versatz) ab.  Daher benötige ich als Parameter all diese Daten. <br><br>  Nachdem Sie alle diese Parameter festgelegt haben, reicht es aus, einfach ein Linienprimitiv zu erstellen und damit eine Linie um die Karte zu zeichnen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a56/74f/785/a5674f78512bef22e569656701203401.png"></div><br>  (Beachten Sie, dass ich verschiedene Funktionen von <b>Dragons Abound verwende,</b> um die „handgeschriebene“ Linie zu zeichnen.) Versuchen wir, einen komplexeren Rand zu erstellen: <br><br><blockquote> <code><b>L(3, black) L(10, gold) L(3, black)</b></code> </blockquote> <br>  Es sieht so aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86a/ad8/849/86aad88494c1c17f993524ef09ef9b2f.png"></div><br>  Ziemlich gut.  Beachten Sie, dass es Stellen gibt, an denen die schwarzen und die goldenen Linien aufgrund von Schwankungen nicht richtig ausgerichtet sind.  Wenn ich diese Stellen entfernen möchte, können Sie einfach die Schwingung reduzieren. <br><br>  Das Implementieren eines vertikalen Raumprimitivs ist recht einfach.  Es wird nur ein Offset-Inkrement ausgeführt.  Fügen wir ein wenig Platz hinzu: <br><br><blockquote> <code><b>L(3, black) L(10, gold) L(3, black) <br> VS(5) <br> L(3, black) L(10, red) L(3, black)</b></code> </blockquote> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eab/471/b90/eab471b902eb44e703f460d700936937.png"></div><br>  Beim Zeichnen von Linien können Winkel realisiert werden, indem zwischen dem Versatz und der Zeichnung entlang der Karte im Uhrzeigersinn gezeichnet wird.  Im Allgemeinen muss ich jedoch auf jeder Seite des Kartenrandes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Kürzung</a> implementieren, um eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Winkelverbindung mit einer Abschrägung herzustellen</a> .  Dies ist erforderlich, um Ränder mit Mustern zu erstellen, die an den Ecken korrekt verbunden sind, und im Allgemeinen entfällt die Notwendigkeit, Elemente mit Kanten in einem Winkel zu zeichnen, der sonst erforderlich wäre.  (*) <br><br>  <i>(Hinweis: Wie in den folgenden Abschnitten erwähnt wird, habe ich mich im Laufe der Zeit geweigert, beim Implementieren von Winkeln Kürzungsbereiche zu verwenden. Der Hauptgrund ist, dass komplexe Winkel erstellt werden, z. B. quadratische Offsets:</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/fd8/336/97bfd833697b9278660772c1bd04ee46.png"></div><br>  <i>Es werden immer komplexere Kürzungsbereiche benötigt.</i>  <i>Außerdem habe ich im Laufe der Zeit einen besseren Weg gefunden, mit Mustern in Ecken zu arbeiten.</i>  <i>Anstatt diesen Teil des Artikels zurückzugeben und neu zu schreiben, habe ich beschlossen, ihn zu belassen, um den Prozess der „Kreativität“ zu veranschaulichen.)</i> <br><br>  Die Hauptidee besteht darin, jeden Rand diagonal abzuschneiden und vier abgeschnittene Bereiche zu erstellen, in denen jede Seite des Randes gezeichnet wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9fb/31a/cf9/9fb31acf993cde46b6a7fdc408be6afd.png"></div><br>  Beim Abschneiden wird alles, was im entsprechenden Bereich gezeichnet wurde, im gewünschten Winkel abgeschnitten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/52b/f00/f02/52bf00f026f6979f6425345389fa646a.png"></div><br>  Leider entstehen dadurch kleine Lücken entlang der diagonalen Linien, wahrscheinlich weil der Browser die Glättung entlang der abgeschnittenen Kante nicht perfekt durchführt.  Der Test zeigte, dass ein Hintergrund durch die Lücke zwischen den beiden Kanten scheint.  Es war möglich, dies zu beheben, indem eine der Masken etwas erweitert wurde (das halbe Pixel scheint ausreichend zu sein), aber dies löst das Problem manchmal nicht. <br><br>  Als nächstes müssen Sie geometrische Formen implementieren.  Im Gegensatz zu Linien werden sie im Muster wiederholt und füllen die Seite des Kartenrandes aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/420/d88/64e/420d8864e72e178252766172dc0320ab.png"></div><br>  Eine Person zeichnete dieses Muster von links nach rechts, zeichnete ein Rechteck, eine Raute und wiederholte es dann, bis der gesamte Rand gefüllt war.  Daher kann dies auch im Programm implementiert werden, indem ein Muster entlang der Grenze gezeichnet wird.  Es ist jedoch einfacher, zuerst alle Rechtecke und dann alle Rauten zu zeichnen.  Es reicht aus, in Abständen dieselbe geometrische Figur entlang des Randes zu zeichnen.  Und es ist sehr praktisch, dass jedes Element das gleiche Intervall hat.  Natürlich würde eine Person das nicht tun, weil es zu schwierig ist, die Elemente an den richtigen Stellen anzuordnen, aber dies ist kein Problem für das Programm. <br><br>  Das heißt, das Verfahren zum Zeichnen einfacher geometrischer Formen erfordert Parameter, in denen alle Abmessungen und Farben der Figur übertragen werden (d. H. Breite, Länge, Liniendicke, Linienfarbe und Füllung) sowie die Startposition (die aus Gründen, die bald klar werden, Ich werde die Mitte der Figur betrachten), das horizontale Raumintervall für den Übergang zwischen Wiederholungen und die Anzahl der Wiederholungen.  Es ist auch zweckmäßig, die Wiederholungsrichtung in Form eines Vektors [dx, dy] anzugeben, damit wir Wiederholungen von links nach rechts, von rechts nach links, nach oben oder unten durchführen können, indem wir einfach den Vektor und den Startpunkt ändern.  Setze alles zusammen und erhalte einen Streifen sich wiederholender Formen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/409/bcd/c33/409bcdc33756610ac6ace2d0fde0a3a4.png"></div><br>  Wenn ich diesen Code mehrmals verwende und mit demselben Versatz rendere, kann ich die schwarzen und weißen Streifen kombinieren, um den Kartenmaßstab zu erstellen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/8f5/0d9/b888f50d9f164b9319cc8b3cf8d38588.png"></div><br>  Bevor ich anfange herauszufinden, wie all dies auf den realen Rand der Karte angewendet werden kann, implementieren wir zunächst dieselbe Funktionalität für Ellipsen und Rauten. <br><br>  Rauten sind nur Rechtecke mit gedrehten Eckpunkten, sodass Sie nur eine kleine Änderung am Code vornehmen müssen.  Es stellte sich heraus, dass ich noch keinen vorgefertigten Code zum Rendern der Ellipse habe, aber es ist sehr einfach, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">parametrische Ansicht der Ellipse zu übernehmen</a> und eine Funktion zu erstellen, die mir die Punkte der Ellipse gibt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fa/74e/079/3fa74e079dd2c29afa5acb0135d4092f.png"></div><br>  Hier ist ein Beispiel (manuell erstellt), das die oben implementierten Funktionen verwendet: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf8/bf2/d39/bf8bf2d3992b34bc173622dc86c0d8b5.png"></div><br>  Für so eine kleine Menge Code sieht es ziemlich gut aus! <br><br>  Lösen wir nun den komplexen Fall von Rändern mit sich wiederholenden Elementen: Ecken. <br><br>  Wenn es einen Rand mit sich wiederholenden Elementen gibt, gibt es verschiedene Möglichkeiten, das Problem mit Ecken zu lösen.  Die erste besteht darin, die Wiederholungen so anzupassen, dass sie in den Ecken ausgeführt werden, ohne dass eine Ehe erkennbar ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  Eine andere Möglichkeit besteht darin, die Wiederholung irgendwo in der Nähe der Ecke auf beiden Seiten zu stoppen.  Dies geschieht häufig, wenn das Muster in der Ecke nicht einfach „gedreht“ werden kann: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/6dd/3a3/15f6dd3a3e6191da02dc884193b72c82.png"></div><br>  Die letzte Möglichkeit besteht darin, das Muster mit einer Eckdekoration zu schließen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/5ce/64e/7be5ce64eb09de2eeefdb18992978d03.png"></div><br>  Eines Tages werde ich zu den Eckdekorationen kommen, aber jetzt werden wir die erste Option verwenden.  Wie kann man ein Muster aus Streifen oder Kreisen in den Ecken der Karte ohne Lücken „drehen“? <br><br>  Die Hauptidee besteht darin, das Musterelement genau in der Ecke zu platzieren, sodass sich eine Hälfte davon an einer Kante der Karte und die andere an der benachbarten befindet.  In diesem Beispiel befindet sich der Kreis genau in der Ecke und kann aus jeder Richtung gezeichnet werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  In anderen Fällen wird das Element zur Hälfte in die eine und zur Hälfte in die andere Richtung gezeichnet, aber die Kanten fallen zusammen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ee/f62/0b8/4eef620b830eb0249d019229140e34e6.png"></div><br>  In diesem Fall wird auf beiden Seiten ein weißer Streifen gezeichnet, der jedoch in der Ecke lückenlos verbunden ist. <br><br>  Beim Platzieren eines Elements in einer Ecke sind zwei Aspekte zu berücksichtigen. <br><br>  Zunächst wird das Eckelement geteilt und relativ zur Diagonale gespiegelt, die durch die Mitte des Elements verläuft.  Elemente mit radialer Symmetrie, z. B. Quadrate, Kreise und Sterne, ändern ihre Form nicht.  Elemente ohne radiale Symmetrie, z. B. Rechtecke und Rauten, ändern beim Spiegeln relativ zur Diagonale ihre Form. <br><br>  Zweitens muss eine ganzzahlige Anzahl von Elementen (*) auf beiden Seiten der Karte vorhanden sein, damit die Eckelemente der beiden Seiten korrekt verbunden sind.  Sie müssen nicht dieselbe Anzahl haben, aber es muss auf beiden Seiten eine ganzzahlige Anzahl von Elementen geben.  Wenn auf einer Seite eine gebrochene Anzahl von Mustern enthalten ist, stimmt das Muster von einer Kante nicht mit der benachbarten Seite überein. <br><br>  <i>(* In einigen Fällen, z. B. bei langen Streifen, kann es bei vollständiger Wiederholung zu einer teilweisen Wiederholung kommen, und die Elemente werden trotzdem ausgerichtet. Das resultierende Eckelement ist jedoch asymmetrisch und unterscheidet sich in der Länge von demselben Element auf den Seiten der Karte. Ein Beispiel hierfür ist hier zu sehen:</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/418/110/263418110aafe94ef8c62d57e8540371.png"></div><br>  <i>Ein weißer Maßstabsbalken tritt mit verschiedenen Teilwiederholungen auf, und als Ergebnis wird ein Element erhalten, das relativ zur Mitte verschoben ist.</i>  <i>Für den Kartenmaßstab ist dies nicht immer der Fall, da er den absoluten Abstand anzeigt und nicht symmetrisch sein muss.</i>  <i>Aber für ein dekoratives Muster sieht das normalerweise schlecht aus.)</i> <br><br>  Hier ist ein Beispiel, das zeigt, wie eine ganzzahlige Anzahl von Wiederholungen genau in der Ecke abgeschnitten wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ab/8de/0a3/8ab8de0a3452332e2813b3771091b165.png"></div><br>  Wenn Sie von allen vier Seiten dasselbe tun, fallen die Ecken zusammen und das Muster wird nahtlos über die gesamte Länge des Rahmens platziert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfc/c9a/e46/dfcc9ae46a68807e983705e553aa2ba3.png"></div><br>  Bei sorgfältiger Prüfung werden Sie feststellen, dass das Muster nicht genau in den Ecken auftritt.  Die Hälfte des Kreises in jeder Ecke wird von jeder Seite genommen, und diese beiden Hälften werden unabhängig voneinander von Hand gezeichnet, daher sind sie nicht perfekt.  Aber jetzt sind sie nah genug dran. <br><br>  So können wir eine perfekte Verbindung des Musters in den Ecken realisieren, indem wir für jede Kante eine ganzzahlige Anzahl von Wiederholungen auswählen.  Die Lösung für dieses Problem ist jedoch nicht trivial. <br><br>  Angenommen, wir wissen, dass die Seite 866 Pixel lang ist, und wir möchten das Element 43 Mal wiederholen.  Dann sollte das Element alle 20,14 Pixel wiederholt werden.  Wie legen wir die spezifische Länge eines Elements (und im allgemeinen Fall ein Muster von Elementen) fest?  Im obigen Beispiel habe ich zusätzlichen Abstand zwischen den Kreisen hinzugefügt.  Wenn sich die Kreise jedoch anfänglich berührten, ändert dies das Muster.  Vielleicht lohnt es sich, die Kreise so zu dehnen, dass sie sich weiterhin berühren? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e36/2b0/ebd/e362b0ebd3fd04e5d8b00de5d3aba151.png"></div><br>  Jetzt berühren sich die Elemente, aber die Kreise haben sich in Ellipsen verwandelt und die Ecken haben eine seltsame Form.  (Denken Sie daran, ich sagte, dass Elemente ohne radiale Symmetrie ihre Form ändern, wenn sie relativ zu einem Winkel reflektiert werden. Für Streifen ist dies kein großes Problem.) Oder es lohnt sich vielleicht, alle Elemente so zu komprimieren, dass sie sich berühren und in eine geeignete Länge passen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7c/ba8/0af/d7cba80afb431dc6c9afc52d7ad94b5c.png"></div><br>  Um dies zu realisieren, müssen wir die Elemente jedoch viel kleiner machen als ursprünglich.  Keine dieser Optionen scheint perfekt zu sein. <br><br>  Das zweite Problem tritt auf, wenn die Seiten der Karte unterschiedlich groß sind.  Jetzt müssen wir das Problem lösen, eine ganzzahlige Anzahl von Wiederholungen zu finden, die für beide Seiten geeignet sind.  Es wäre ideal, eine Lösung zu finden, die zu beiden Seiten passt.  Aber ich möchte dies nicht auf Kosten zu vieler Musteränderungen tun.  Es ist möglicherweise besser, auf beiden Seiten leicht unterschiedliche Muster zu erstellen, wenn beide nahe genug am ursprünglichen Muster liegen. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und schließlich tritt das dritte Problem auf, wenn ich die Funktion verwende, mehrere Elemente übereinander zu legen: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d9/4ed/6ac/4d94ed6acf107193f2109bd2b2f07a67.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich möchte keine Änderungen am Muster vornehmen, die die Beziehung zwischen den Elementen zerstören. </font><font style="vertical-align: inherit;">Ich denke, dass bei richtiger Skalierung die Verhältnisse insgesamt erhalten bleiben, aber ich muss dies testen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interessante Aufgabe, oder? </font><font style="vertical-align: inherit;">Bisher habe ich keine besonders hochwertigen Lösungen für sie. </font><font style="vertical-align: inherit;">Vielleicht erscheinen sie später!</font></font><br><br><h2>  Teil 4 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher haben wir Grundelemente zum Zeichnen von Linien und geometrischen Formen implementiert. Ich fing an, sich wiederholende Formen zu verwenden, um die Ränder zu füllen, und sprach über die Schwierigkeiten, beliebige Muster am Rand der Karte zu platzieren, damit sie perfekt in die Ecken passen. Das Hauptproblem besteht darin, dass Sie das Muster im Allgemeinen länger (oder kürzer) machen müssen, damit es seitlich passt. Optionen zum Ändern der Länge des Musters - Hinzufügen oder Entfernen von Leerzeichen, Ändern der Länge der Elemente der Muster - führen zu verschiedenen Änderungen im Muster selbst. Es scheint, dass die Auswahl eines Musters aus mehreren Elementen sehr schwierig ist!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn ich auf solche scheinbar kompromisslosen Aufgaben stoße, beginne ich gerne mit der Implementierung einer einfachen Version. Nicht erfolgreiche Aufgaben können oft durch wiederholtes Lösen "einfacher" Probleme gelöst werden, bis das Ergebnis gut genug ist. Und manchmal gibt die Implementierung einer einfachen Version ein Verständnis, das die Lösung eines komplexeren Problems vereinfacht. Wenn es nicht besser wird und das Problem weiterhin unangenehm ist, werden wir zumindest eine vereinfachte Version haben, die immer noch nützlich sein kann, wenn auch nicht ganz so, wie es sollte.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am einfachsten ist es, die Länge des Musters zu ändern, indem Sie Längen hinzufügen, ohne etwas im Muster zu ändern. </font><font style="vertical-align: inherit;">Im Wesentlichen wird dadurch am Ende des Musters ein Leerzeichen hinzugefügt. </font><font style="vertical-align: inherit;">(Hinweis: Es ist besser, den leeren Raum auf alle Elemente im Muster zu verteilen.) Es ist zu berücksichtigen, dass eine solche Lösung das Muster nur verlängern kann. </font><font style="vertical-align: inherit;">Wir können dem Muster immer einen leeren Raum hinzufügen, ihn aber bei Bedarf nicht nehmen - vielleicht gibt es keinen leeren Raum mehr im Muster! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei diesem Ansatz ist der Musterortungsalgorithmus auf der Seite der Karte sehr einfach:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teilen Sie die Länge der Seite der Karte durch die Länge des Musters und runden Sie sie ab, um die Anzahl der Wiederholungen des Musters zu bestimmen, die auf diese Seite passen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Abstand zwischen den Elementen ist in diesem Fall gleich der Länge der Seite geteilt durch die Anzahl der Wiederholungen. </font><font style="vertical-align: inherit;">(Dies ist der nächstgelegene Ort, da wir nur Speicherplatz hinzufügen können.)</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeichnen Sie ein Muster entlang der Seite unter Berücksichtigung des berechneten Abstands. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es war schwierig, dieses System zu implementieren. </font><font style="vertical-align: inherit;">Die Ecken wollten hartnäckig nicht zusammenfallen. </font><font style="vertical-align: inherit;">Ich habe zu viel Zeit gebraucht, um zu erkennen, dass ich, wenn die Karte nicht quadratisch ist, keine Kürzungsbereiche für vier Seiten von der Kartenmitte aus zeichnen kann, da dadurch Kürzungswinkel erzeugt werden, die nicht gleich 45 Grad sind. </font><font style="vertical-align: inherit;">In der Tat sollten Kürzungsbereiche der Rückseite eines Umschlags ähneln:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b20/29a/beb/b2029abeb54302b5f7d3335a15c95f86.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als ich das herausfand, begann der Algorithmus ohne Probleme zu funktionieren. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Vergessen Sie jedoch nicht den vorherigen Hinweis, dass ich im Laufe der Zeit Kürzungsbereiche aufgegeben habe!)</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hier ein Beispiel mit einem Verhältnis von ungefähr 2: 1:</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bff/739/d19/bff739d19d76fdb4db63033b970eb241.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf dieser Skala ist es ziemlich schwer zu bemerken, aber die Ecken verbinden sich richtig und es gibt nur einen geringen visuellen Unterschied zwischen den Seiten. </font><font style="vertical-align: inherit;">In diesem Fall muss der Algorithmus zum Ausrichten der Muster nur Bruchpixel einfügen, sodass er für das Auge unsichtbar ist, insbesondere weil die Konturen der Kreise von einem Pixel überlappt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist ein weiteres Beispiel mit Streifen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa8/852/625/aa8852625e15121ce822cc6ca5fe8742.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist die Spitze der quadratischen Grenze. </font><font style="vertical-align: inherit;">Hier ist derselbe Rand auf einer rechteckigeren Karte:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90d/207/9b1/90d2079b1e869c59ee204f1a75f5dbc7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier können Sie sehen, dass auf der Seite der Karte eine visuell größere Lücke zwischen den Bändern besteht. </font><font style="vertical-align: inherit;">Der Algorithmus sollte nicht mehr Platz als die Länge eines vollständigen Elements einfügen. </font><font style="vertical-align: inherit;">Daher tritt der schlimmste Fall auf, wenn wir lange Elemente und eine kurze Seite haben, die sich geringfügig von einer geeigneten Größe unterscheidet. </font><font style="vertical-align: inherit;">In den meisten praktischen Fällen ist die Ausrichtung jedoch nicht sehr schädlich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist ein Beispiel mit einem Muster aus mehreren Elementen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d18/602/4f8/d186024f8ee1e4fbcd5918c63537a024.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hier überlappen die Streifen die Streifen: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c60/af7/ad6/c60af7ad6c71ee4ef1850f0bf194af62.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können sehen, dass die Streifen relativ zueinander zentriert bleiben, da für jedes Element dieselbe Ausrichtung durchgeführt wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich schlug vor, dass eine gute Lösung zum Platzieren des Musters an der Seite der Karte schwierig wäre, aber ein sehr einfacher Ansatz mit gleichmäßiger Verteilung des Musterelements, um den gewünschten Raum zu füllen, funktioniert für viele Muster recht gut. Dies ist eine Erinnerung an uns alle: Es besteht keine Notwendigkeit anzunehmen, dass die Entscheidung kompliziert sein muss; es kann einfacher sein als du denkst! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Lösung funktioniert jedoch nicht für Muster mit berührenden Elementen, z. B. für den Kartenmaßstab. In diesem Fall werden durch Hinzufügen von Leerzeichen die Elemente verschoben:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cd/d7e/27f/3cdd7e27f8c2d92be26d36e7b4807f5a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere Option zum Verlängern eines Musters, die ich oben erwähnt habe, ist das Strecken der einzelnen Elemente des Musters. </font><font style="vertical-align: inherit;">Es ist für so etwas wie ein Skalenmuster geeignet, sieht aber in einem Muster mit symmetrischen Elementen schlecht aus, da sie durch Dehnen asymmetrisch werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Implementierung der Option mit Dehnung erwies sich als schwieriger als erwartet, hauptsächlich weil ich die Elemente an verschiedenen Kanten der Karte um verschiedene Größen strecken musste (weil die Karte möglicherweise nicht quadratisch, sondern rechteckig ist) und auch die Anordnung der Elemente basierend auf den neuen gedehnten dynamisch ändern musste Größen. </font><font style="vertical-align: inherit;">Aber nach ein paar Stunden habe ich das geschafft:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/552/3c4/d1c5523c43a9828cd9c1c1bee6f4bbde.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt habe ich alle Funktionen, die zum Zeichnen des Rahmens der Karte erforderlich sind (obwohl die Rahmenelemente selbst manuell erstellt werden): </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2b/ccc/326/d2bccc326a0500f92267378e137e2f6e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich habe das Bild in Graustufen konvertiert, weil ich mich nicht um die Auswahl der Farben kümmern wollte und die Karte selbst ziemlich langweilig ist, aber als Proof of Concept sehen die Ränder ziemlich hübsch aus. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 5 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Teil 2 habe ich die MBDL-Grammatik (Map Border Description Language) entwickelt und in Teil 3 und 4 Prozeduren implementiert, um alle Sprachprimitive auszuführen. </font><font style="vertical-align: inherit;">Jetzt werde ich daran arbeiten, diese Teile zu verbinden, damit ich den Rand in MBDL beschreiben und auf der Karte zeichnen kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Teil 3 habe ich die MBDL-Grammatik so geschrieben, dass sie mit dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nearley</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Javascript </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Parsing Tool</font></a><font style="vertical-align: inherit;"> funktioniert </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die fertige Grammatik sieht folgendermaßen aus:</font></font><br><br><blockquote> <code><b>@builtin</b> <b>"</b> <b>number.ne"</b> <br> <b>@builtin</b> <b>"</b> <b>string.ne"</b> <br> <b>border -&gt; (element WS):+ <br> WS -&gt; [\s]:* <br> number -&gt; WS decimal WS <br> color -&gt; WS dqstring WS <br> element -&gt;</b> <b>"</b> <b>L(" number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>element -&gt;</b> <b>"</b> <b>VS(" number</b> <b>"</b> <b>)"</b> <br> <b>element -&gt;</b> <b>"</b> <b>(" WS (element WS):+</b> <b>"</b> <b>)"</b> <br> <b>element -&gt;</b> <b>"</b> <b>[" WS (geometric WS):+</b> <b>"</b> <b>]"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>B(" number</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>E(" number</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>D(" number</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>HS(" number</b> <b>"</b> <b>)"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn eine Regel erfolgreich mit Nearley analysiert wird, gibt die Regel standardmäßig ein Array zurück, das alle Elemente enthält, die der rechten Seite der Regel entsprechen. </font><font style="vertical-align: inherit;">Zum Beispiel, wenn die Regel</font></font><br><br><blockquote> <code><b>test -&gt;</b> <b>"</b> <b>A" |</b> <b>"</b> <b>B" |</b> <b>"</b> <b>C"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit Zeichenfolge abgeglichen </font></font><br><br><blockquote> <code><b>A</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dann wird Nearley zurückkehren </font></font><br><br><blockquote> <code><b>[</b> <b>"</b> <b>A" ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Array mit einem einzelnen Wert ist die Zeichenfolge "A", die der rechten Seite der Regel entspricht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was gibt Nearley zurück, wenn ein Element nach dieser Regel analysiert wird?</font></font><br><br><blockquote> <code><b>number -&gt; WS decimal WS</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf der rechten Seite der Regel befinden sich drei Teile, sodass ein Array mit drei Werten zurückgegeben wird. </font><font style="vertical-align: inherit;">Der erste Wert ist derjenige, der die Regel für WS zurückgibt, der zweite Wert ist derjenige, der die Regel für Dezimalzahlen zurückgibt, und der dritte Wert ist derjenige, der die Regel für WS zurückgibt. </font><font style="vertical-align: inherit;">Wenn ich unter Verwendung der obigen Regel "57" analysiere, ist das Ergebnis wie folgt:</font></font><br><br><blockquote> <code><b>[ <br> [ " " ], <br> [ "5", "7" ], <br> [ ] <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Endergebnis der Nearley-Analyse ist ein verschachteltes Array von Arrays, bei dem es sich um einen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntaxbaum handelt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In einigen Fällen ist der Syntaxbaum eine sehr nützliche Darstellung, in anderen Fällen nicht ganz. In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dragons Abound</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zum Beispiel ist ein solcher Baum nicht besonders nützlich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Glücklicherweise können Nearley-Regeln das Standardverhalten überschreiben und alles zurückgeben, was sie wollen. In der </font><font style="vertical-align: inherit;">Tat, für die (integrierte) Regel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dezimal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht eine Liste von Zahlen zurückkehrt, gibt es eine entsprechende Anzahl von Javascript ist, dass in den </font><font style="vertical-align: inherit;">meisten Fällen viel nützlicher ist, das heißt, die Rückgabewert Regel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nummer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist:</font></font><br><br><blockquote> <code><b>[ <br> [ " " ], <br> 57, <br> [ ] <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nearley-Regeln definieren das Standardverhalten neu, indem sie der Regel einen Postprozessor hinzufügen, ein Standardarray verwenden und es durch das ersetzen, was Sie benötigen. Ein Postprozessor ist nur Javascript-Code in speziellen Klammern am Ende einer Regel. Zum Beispiel Regel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nummer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ich nie in irgendwelchen Lücken auf beiden Seiten der Zahl interessierte. Daher wäre es praktisch, wenn die Regel einfach eine Zahl und kein Array von drei Elementen zurückgeben würde. Hier ist ein Postprozessor, der diese Aufgabe ausführt:</font></font><br><br><blockquote> <code><b>number -&gt; WS decimal WS {% default =&gt; default[1] %}</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Postprozessor nimmt das Standardergebnis (das oben gezeigte Array mit drei Elementen) und ersetzt es durch das zweite Element des Arrays, bei dem es sich um die Javascript-Nummer aus der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dezimalregel handelt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">So , </font><font style="vertical-align: inherit;">jetzt regiert </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zahl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kehrt die reelle Zahl. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dieser Funktion kann eine eingehende Sprache in eine Zwischensprache umgewandelt werden, mit der einfacher gearbeitet werden kann. </font><font style="vertical-align: inherit;">Zum Beispiel kann ich die Nearley-Grammatik verwenden, um eine MBDL-Zeichenfolge in ein Array von Javascript-Strukturen umzuwandeln, von denen jede ein durch ein "op" -Feld gekennzeichnetes Grundelement darstellt. </font><font style="vertical-align: inherit;">Die Regel für das Zeilenprimitiv sieht ungefähr so ​​aus:</font></font><br><br><blockquote> <code><b>element -&gt;</b> <b>"</b> <b>L(" number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)" {% data=&gt; {op:</b> <b>"</b> <b>L", width: data[1], color: data[3]} %}</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das heißt, das Ergebnis des Parsens von „L (13, schwarz)“ ist die Javascript-Struktur: </font></font><br><br><blockquote> <code><b>{op:</b> <b>"</b> <b>L", width: 13, color:</b> <b>"</b> <b>black"}</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Hinzufügen der entsprechenden Nachbearbeitung kann das von der Grammatik zurückgegebene Ergebnis eine Folge (Array) von Operationsstrukturen für die eingehende Zeile sein. </font><font style="vertical-align: inherit;">Das heißt, das Ergebnis des Parsens der Zeichenfolge</font></font><br><br><blockquote> <code><b>L( 415, “black") <br> VS(5) <br> [B(1, 2, “black", 3, “white") HS(5) E(1, 2, “black", 3, “white")]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird sein </font></font><br><br><blockquote> <code><b>[ <br> {op: "L", width: 415, color: "black"}, <br> {op: "VS", width: 5}, <br> {op: "P", <br> elements: [{op: "B", width: 1, length: 2, <br> olColor: "black", olWidth: 3, <br> fill: "white"}, <br> {op: "HS", width: 5}, <br> {op: "E", width: 1, length: 2, <br> olColor: "black", olWidth: 3, <br> fill: "white"}]} <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist viel einfacher zu verarbeiten, um einen Kartenrand zu erstellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An dieser Stelle haben Sie möglicherweise eine Frage: Wenn die Nachbearbeitungsphase der Nearley-Regel Javascript enthalten kann, überspringen Sie dann die Zwischenansicht und zeichnen Sie einfach den Rand der Karte direkt während der Nachbearbeitung. </font><font style="vertical-align: inherit;">Für viele Aufgaben wäre dieser Ansatz ideal. </font><font style="vertical-align: inherit;">Ich habe mich aus mehreren Gründen entschieden, es nicht zu verwenden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstens gibt es in MBDL einige (*) Komponenten, die während des Analyseprozesses nicht ausgeführt werden können. Beispielsweise können wir während des Analyseprozesses keine sich wiederholenden geometrischen Elemente (Streifen oder Raute) zeichnen, da wir Informationen von anderen Elementen im selben Muster kennen müssen. Insbesondere müssen wir die Gesamtlänge des Musters kennen, um zu verstehen, wie weit wir die Wiederholungen jedes einzelnen Elements anordnen müssen. Das heißt, das Element des Musters sollte immer noch eine Zwischendarstellung aller geometrischen Elemente erstellen. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(* Es gibt andere Komponenten mit ähnlichen Einschränkungen, über die ich noch nicht gesprochen habe.)</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens ist Javascript in Nearley in die Regeln eingebettet, sodass wir keine zusätzlichen Informationen an Javascript übergeben können, außer für globale Variablen. Um beispielsweise den Rand zu zeichnen, muss ich die Größe der Karte, die vier verwendeten Kürzungsbereiche usw. kennen. Obwohl ich Code hinzufügen kann, der diese Informationen Nearley-Postprozessoren zur Verfügung stellt, ist er etwas chaotisch und es kann schwierig sein, diesen Code zu verwalten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus diesen Gründen analysiere ich eine Zwischendarstellung, die dann ausgeführt wird, um den Rand der Karte selbst zu erstellen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der nächste Schritt besteht darin, einen Interpreter zu entwickeln, der eine Zwischendarstellung von MBDL empfängt und ausführt, um Kartengrenzen zu generieren. Dies ist nicht sehr schwer zu tun. Grundsätzlich besteht die Aufgabe darin, die Anfangsbedingungen festzulegen (z. B. Kürzungsbereiche für die vier Seiten der Karte zu generieren) und die Sequenz der Strukturen der Zwischendarstellung zu durchlaufen, wobei jede ausgeführt wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt ein paar rutschige Momente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst muss ich vom Rendern von innen zum Zeichnen von innen nach außen übergehen. Der Grund dafür ist, dass die meisten Ränder die Karte nicht überlappen sollen. Daher muss ich die Ränder so zeichnen, dass die Linien des inneren Randes mit den Rändern der Karte übereinstimmen. Wenn ich von außen nach innen zeichne, muss ich die Breite des Rahmens kennen, bevor ich mit dem Zeichnen beginne, damit der Rand die Karte nicht überlappt. Wenn ich von innen nach außen zeichne, beginne ich einfach am Rand der Karte und zeichne heraus. Außerdem können Sie der Karte optional einen Rahmen hinzufügen. Beginnen Sie den Rand einfach mit einem negativen vertikalen Leerzeichen (VS).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiterer schwieriger Punkt sind die sich wiederholenden Muster. </font><font style="vertical-align: inherit;">Um sich wiederholende Muster zu zeichnen, muss ich alle Elemente des Musters betrachten und das breiteste bestimmen, da dadurch die Breite des gesamten Musters festgelegt wird. </font><font style="vertical-align: inherit;">Ich muss auch die Länge des Musters betrachten und verfolgen, damit ich weiß, wie viel Abstand ich vor jeder Wiederholung lassen muss. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist ein Beispiel für einen ziemlich komplexen Rand, mit dem ich den Interpreter getestet habe:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c8/88a/2a9/3c888a2a96352845f6165f5eca7f6ab3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich denke, es war möglich (notwendig?), Es zum Testen an den Parser anzuhängen, aber für diesen Rahmen habe ich nur manuell eine Zwischenansicht erstellt: </font></font><br><br><blockquote> <code><b>[ <br> {op:'P', elements: [ <br> {op:'B', width: 10, length: 37, lineWidth: 2, color: 'black', fill: 'white'}, <br> {op:'B', width: 10, length: 37, lineWidth: 2, color: 'black', fill: 'black'}, <br> ]}, <br> {op:'VS', width: 2}, <br> {op:'L', width:3, color: 'black'}, <br> {op:'PUSH'}, <br> {op:'L', width:10, color: 'rgb(222,183,64)'}, <br> {op:'POP'}, <br> {op:'PUSH'}, <br> {op:'P', elements: [ <br> {op:'E', width: 5, length: 5, lineWidth: 1, color: 'black', fill: 'red'}, <br> {op:'HS', length: 10}, <br> ]}, <br> {op:'L', width:3, color: 'black'}, <br> {op:'POP'}, <br> {op:'VS', width: 2}, <br> {op:'P', elements: [ <br> {op:'E', width: 2, length: 2, lineWidth: 0, color: 'black', fill: 'white'}, <br> {op:'HS', length: 13}, <br> ]}, <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe diese Ansicht durch Ausprobieren erstellt. Wie dem auch sei, der Dolmetscher arbeitet! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie mich als letzten Schritt den Parser verwenden, um eine Zwischenansicht aus der MBDL-Version zu erstellen. Hier gibt es nicht viel zu zeigen: Ich musste ein paar Feldnamen korrigieren, aber ansonsten funktionierte der Code einwandfrei. Für den Rand habe ich eine etwas andere Version von MBDL verwendet:</font></font><br><br><blockquote> <code><b>[B(5,37,"black",2,"white") B(5,37,"black",2,"black")] <br> VS(3) <br> L(3,"black") <br> {L(10,"rgb(222,183,64)")} <br> [E(5,5,"black",1,"red") HS(-5) E(2,2,"none",0,"white") HS(10)] <br> L(3,"black")</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie zeichnet den gleichen Rand, aber auf etwas andere Weise. </font><font style="vertical-align: inherit;">Ich habe auch die Syntax für das Overlay geändert und die Klammern durch geschweifte Klammern ersetzt, damit sie sich stärker von der anderen Syntax unterscheiden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um zu zeigen, warum ich von innen nach außen zeichnen und nicht nur den Rand automatisch außerhalb der Karte platzieren wollte, kann ich am Anfang dieses Rahmens einen negativen vertikalen Abstand einfügen, um den Kartenmaßstab innerhalb des Kartenrandes zu verschieben:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ce/ea0/3df/0ceea03df1f07131e0ad27e6bbd45731.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt habe ich den größten Teil der Infrastruktur, die für die prozedurale Generierung von Kartenrändern erforderlich ist: eine Grenzbeschreibungssprache, einen Sprachparser und Verfahren zum Durchführen einer Zwischendarstellung. </font><font style="vertical-align: inherit;">Es bleibt nur der schwierige Teil zu behandeln - die prozedurale Generierung!</font></font><br><br><h2>  Teil 6 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem die gesamte MBDL implementiert wurde, wollte ich mit der prozeduralen Generierung von Kartenrändern fortfahren. Ich bin mir jedoch noch nicht sicher, wie ich dies tun möchte, da ich noch ein wenig verweilen und ein paar weitere MBDL-Funktionen implementieren werde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der ersten Diskussion der Eckenverarbeitung mit Mustern habe ich über verschiedene Ansätze gesprochen. Am Ende erkannte ich die abgeschrägten Ecken, aber es gab eine zweite Option: Stoppen Sie das Muster in der Nähe der Ecke, wie in diesen Beispielen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b7/94d/01b/3b794d01b552c42ed9b8362f5405ff9d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/3a8/159/ee23a8159d81afd1f7c95c16a90bcdf7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine solche Lösung wird häufig verwendet, wenn das Randmuster eine Art asymmetrische Figur, Runen oder etwas anderes ist, das nicht um 90 Grad gedreht werden kann, während die Ausrichtung beibehalten wird. Es ist jedoch offensichtlich, dass dies mit geometrischen Formen funktioniert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist möglicherweise die Option, die Sie vor dem Generieren des Rahmens auswählen. Sie können jedoch ein wenig Flexibilität hinzufügen, wenn Sie sie von einem Teil des Rahmens aus aktivieren und die abgeschrägte Ecke auf dem anderen verwenden. Dazu muss ich MBDL einen neuen Befehl hinzufügen. Ich vermute, dass andere Optionen für verschiedene Teile der Grenze auftreten können, daher werde ich einen allgemeinen Optionsbefehl hinzufügen:</font></font><br><br><blockquote> <code><b>element -&gt; "O(MITER)"</b> <br> <b>element -&gt; "O(STOPPED)"</b> <br> <b>element -&gt; "O(STOPPED," number ")"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Auch hier lassen wir aus Gründen der Übersichtlichkeit Leerzeichen und einige andere Details weg.) Bisher sind die einzigen Optionen "MITRE" für abgeschrägte Ecken und "STOPPED" zum Anhalten in der Nähe von Ecken. </font><font style="vertical-align: inherit;">Wenn kein Wert STOPPED übertragen wird, stoppt das Programm das Muster in einem angemessenen Abstand von der Ecke. </font><font style="vertical-align: inherit;">Wenn der Wert übertragen wird, stoppt das Muster in diesem Abstand von der Ecke. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn STOPPED-Ecken verwendet werden, höre ich auf, das Eckmuster von den Ecken weg zu zeichnen.</font></font> So sieht es aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8e/5df/49e/a8e5df49eecf2ebc5e94e571cb7d0ff8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier habe ich die MITRE-Option für das Schwarz-Weiß-Skalenmuster verwendet, damit es in Bezug auf den Winkel gespiegelt wird. </font><font style="vertical-align: inherit;">Für ein Muster aus roten Kreisen und schwarzen Quadraten innerhalb einer goldenen Linie (und für ein Muster aus Kreisen außerhalb des Randes) habe ich STOPPED verwendet. </font><font style="vertical-align: inherit;">Sie können sehen, dass diese beiden Muster in der Nähe der Ecke enden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt jedoch einige Probleme. Erstens sehen wir, dass links das der Ecke am nächsten liegende Element ein schwarzes Quadrat und oben ein roter Kreis ist. Dies geschah, weil sich die Ecke auf der einen Seite nahe dem Beginn der Wiederholung und auf der anderen Seite nahe dem Ende der Wiederholung befindet. Aber es sieht komisch aus. Es wäre besser, wenn die Ecken symmetrisch wären, auch wenn wir dafür am Ende des Musters ein weiteres Element hinzufügen müssten. Zweitens können Sie sehen, dass das Muster außerhalb des Randes (Halbkreise und schwarze Punkte) auch in einer Wiederholung bis zur Ecke endet. Da die Länge dieser Wiederholung jedoch viel geringer ist als die Länge der roten Kreise / schwarzen Quadrate, landen sie an verschiedenen Stellen. Es wäre wahrscheinlich besser, wenn alle Muster im gleichen Abstand von der Ecke anhalten würden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das erste Problem zu beheben, müssen Sie am Ende jeder Seite des Rahmens eine weitere Wiederholung des ersten Elements des Musters hinzufügen. </font><font style="vertical-align: inherit;">Tatsächlich ist es jedoch etwas komplizierter, da ich einen negativen horizontalen Versatz innerhalb des Musters verwenden könnte, um mehrere Elemente zu überlappen (wie hier ausgeführt). </font><font style="vertical-align: inherit;">Sie müssen außerdem jedem Element des Musters, das denselben Startpunkt wie das erste Element hat, eine weitere Wiederholung hinzufügen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/331/6fc/9c43316fcd44d79a0b2374401a46240a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt ist das Muster in Bezug auf den Winkel symmetrisch und sieht viel besser aus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als nächstes muss ich das längste STOPPED-Muster verfolgen und jedes STOPPED-Muster in dieser Entfernung anhalten:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a33/920/c6c/a33920c6cda9072bbda915544f1f4926.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt wird das Muster der weißen Kreise mehr beiseite gelegt, aber es ist immer noch nicht mit dem Muster der roten Kreise ausgerichtet. </font></font> Warum?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies geschah, weil das weiße Kreismuster weiter vom Rand der Karte entfernt ist und der Rand länger ist als dort, wo das rote Kreismuster gezeichnet wird. </font><font style="vertical-align: inherit;">Um dieses Problem zu beheben, müssen Sie auch die Muster verschieben und ihren Versatz relativ zum Rand der Karte berücksichtigen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70b/574/2c1/70b5742c1d4f404335b97128f09d6baf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt ist alles schön ausgerichtet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zweite Option für Winkel sind die quadratischen Versätze in den Ecken, zum Beispiel diese:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/37e/bac/cac37ebac81815955dfc940bacdc2eff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird viel schwieriger sein, dies umzusetzen! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Grammatik dieser Option ist jedoch einfach und verwendet den Options-Opcode:</font></font><br><br><blockquote> <code><b>element -&gt; "O(SQOFFSET)"</b> <br> <b>element -&gt; "O(SQOFFSET," number ")"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zahl gibt die Größe der quadratischen Verschiebung für das Element am Rand der Karte an. </font><font style="vertical-align: inherit;">Elemente mit unterschiedlichen Offsets müssen entsprechend ausgerichtet werden. </font><font style="vertical-align: inherit;">Wenn keine Nummer vorhanden ist, wählt das Programm die entsprechende Versatzgröße aus. </font><font style="vertical-align: inherit;">Durch Nullstellen der Zahl wird der quadratische Versatz deaktiviert. </font><font style="vertical-align: inherit;">Auf diese Weise können Sie Rahmen erstellen, in denen einige Elemente quadratische Offsets verwenden, während andere dies nicht tun, wie in diesem Rahmen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/fd8/336/97bfd833697b9278660772c1bd04ee46.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als erstes wurde mir klar, dass ich zusätzliche Kürzungsbereiche benötigen würde, da ich die Kürzung verwende, um Stellen zu verarbeiten, an denen der Rand die Richtung ändert. </font><font style="vertical-align: inherit;">SQOFFSET erfordert komplexere Kürzungsbereiche. </font><font style="vertical-align: inherit;">Sie benötigen auch separate Bereiche für verschiedene Elemente, wenn Sie SQOFFSET aktivieren und deaktivieren. </font><font style="vertical-align: inherit;">Angesichts der Tatsache, dass Kürzungsbereiche ohnehin unerwünschte Artefakte hinzufügen, scheint dies zu viel Arbeit zu sein.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als ich oben an stoppbaren Mustern gearbeitet habe, habe ich das Ausfüllen eines asymmetrischen Musters implementiert, um eine weitere Wiederholung von einem Ende des Musters hinzuzufügen. Ich erkannte auch, dass dies die Notwendigkeit abgeschrägter Ecken beseitigen würde. Ich werde einfach alle Muster entlang des Randes im Uhrzeigersinn zeichnen, wobei das Muster in einer Ecke beginnt und in der Nähe der nächsten Ecke endet. Dadurch kann ich Kürzungsbereiche entfernen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Wichtigste bei dieser neuen Art der Arbeit mit Ecken war, dass das erste Element des Musters nicht mehr in zwei Seiten „unterteilt“ ist. Wenn Sie sich die Schwarz-Weiß-Skalenmuster auf den Karten oben ansehen, sehen Sie, dass ein weißes Rechteck durch die Ecke verläuft. Jetzt stößt das weiße Rechteck an die Ecke:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ead/909/c83/ead909c83fa91ff80af290ab92ca9fae.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karten werden auf beide Arten gezeichnet, aber dies ist kein sehr großes Problem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für den Anfang habe ich Offsets für Linien implementiert. </font><font style="vertical-align: inherit;">Dazu genügte es, die Linie relativ zu den entsprechenden Winkeln zu drehen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c2/bf6/2fd/9c2bf62fdfec732f56361f4aa17fc19e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie Sie verstehen können, kann ich Winkel mit Offsets und regulären Winkeln kombinieren, wie in der obigen Karte: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0b/f5b/e02/e0bf5be02606044dd5fba4f82d3dad67.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Natürlich ist es schwieriger, die Muster um die Ecke zu drehen. </font><font style="vertical-align: inherit;">Die allgemeine Idee ist, von einer Ecke zur anderen zu ziehen und so weiter entlang der Grenze, bis wir zum Anfang zurückkehren. </font><font style="vertical-align: inherit;">Theoretisch reicht es aus, nur horizontale und vertikale Muster zu zeichnen, und alles sollte schön ausgerichtet sein. </font><font style="vertical-align: inherit;">Das alles zu verfolgen ist ziemlich trostlos. </font><font style="vertical-align: inherit;">Tatsächlich musste ich den Code zweimal komplett neu schreiben und ein paar Papiere schreiben, aber ich werde nicht im Detail darüber sprechen. </font><font style="vertical-align: inherit;">Zeigen Sie einfach das Ergebnis:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/35b/889/91235b889603c973fcfe094a1614a993.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In den Ecken entsteht eine störende optische Täuschung - das Eckelement scheint näher an der Außenseite der Ecke nicht zentriert zu sein. </font><font style="vertical-align: inherit;">In der Tat ist dies nicht wahr, aber es scheint so, weil näher an der Innenseite der Ecke visuell mehr leerer Raum ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Segmente der Versatzwinkel ziemlich kurz sind, ist es sehr einfach, ein Nichtgleichgewichtsmuster in der Ecke zu erstellen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1b/601/dff/b1b601dffc11782fb8cbe738a906b0e5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manchmal sieht es ziemlich hässlich aus. </font><font style="vertical-align: inherit;">Es erinnerte mich an einen alten Witz:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patient: "Doktor, wenn ich das mache, tut es mir weh." </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doktor: "Dann mach das nicht!"</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deshalb werde ich versuchen, dies nicht zu tun. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normalerweise zeichne ich den Kartenmaßstab nicht entlang des Versatzwinkels, aber wenn ich ihn brauche, muss ich die Option verwenden, mit der das Muster so gedehnt wird, dass der Kartenmaßstab ohne Lücken zwischen den Rechtecken in die Ecke passt:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26f/a88/0da/26fa880da6d00d380afdae60c489dd9c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können sehen, dass die Größe der Skalierungsrechtecke daher stark variiert. </font><font style="vertical-align: inherit;">Das heißt, dies ist keine sehr gute Option. </font><font style="vertical-align: inherit;">(Übrigens haben die Versatzwinkel auch einen Fehler im Kreismuster. Später habe ich ihn behoben, aber wie gesagt, es ist sehr schwierig, dies zu tun.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das Muster zu groß ist, um auf das Segment des Versatzwinkels zu passen, gibt der Algorithmus einfach auf:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4d/044/b2d/b4d044b2dc2bf23cd670113476b9803d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist alles andere als ideal, aber wie ich oben sagte: "Dann tu es nicht." </font><font style="vertical-align: inherit;">(Es ist eigentlich nicht sehr schwierig, eine Komprimierungs- oder Dehnungsfunktion hinzuzufügen, wenn ich sie benötige.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was passiert, wenn ich sowohl versetzte Ecken als auch die Option verwende, mit der die Muster vor den Ecken gestoppt werden? </font><font style="vertical-align: inherit;">In diesem Fall halte ich einfach nicht weit von den versetzten Ecken an:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/170/d60/9c1/170d609c1b789359490e35741215ba04.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es scheint mir, dass dies eine logische Entscheidung ist. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444190/">https://habr.com/ru/post/de444190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444178/index.html">9 Tipps zum Erstellen von Indie-Spielen von einem einzelnen Entwickler</a></li>
<li><a href="../de444182/index.html">Gehen Sie Bedingungen und ihre Kuriositäten</a></li>
<li><a href="../de444184/index.html">Über die Aussichten vormontierter Rechenzentren</a></li>
<li><a href="../de444186/index.html">Flattern 1.2. Was gibt's Neues?</a></li>
<li><a href="../de444188/index.html">CG Pods - TWS-Kopfhörer, die es könnten</a></li>
<li><a href="../de444192/index.html">API Management Mitap - IBM, Google, Yandex und Leroy Merlin Experience - Datensatz verfügbar</a></li>
<li><a href="../de444198/index.html">Dropbox begrenzt die Synchronisation: jetzt nur noch 3 Geräte</a></li>
<li><a href="../de444200/index.html">Problemlösungssitzung</a></li>
<li><a href="../de444204/index.html">Einführung in das Testen in Python. Teil 3</a></li>
<li><a href="../de444206/index.html">27. März, Moskau - JavaScript MeetUP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>