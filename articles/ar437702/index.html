<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👠 🅱️ 👢 Google Job Interview Parsing: Synonym Queries 🖕🏾 🤰🏻 ⛹🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="هذا مقال جديد من Google Job Interview Parsing . عندما عملت هناك ، عرضت على المرشحين هذه المهام. ثم كان هناك تسرب ، وتم حظرهم. لكن للعملة جانب جانبي: ا...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Google Job Interview Parsing: Synonym Queries</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437702/" style=";text-align:right;direction:rtl"><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/ec4/467/e92/ec4467e926275a35882c2a8848097877.png" width="530"></div><br><br>  هذا مقال جديد من <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Google Job Interview Parsing</a> .  عندما عملت هناك ، عرضت على المرشحين هذه المهام.  ثم كان هناك تسرب ، وتم حظرهم.  لكن للعملة جانب جانبي: الآن يمكنني شرح الحل بحرية. <br><a name="habracut"></a><br>  نبأ عظيم للبدء: لقد تركت Google!  يسعدني أن أبلغكم بأنني أعمل الآن كمدير فني لشركة رديت في نيويورك!  ولكن هذه السلسلة من المقالات ستظل مستمرة. <br><br>  <i>إخلاء المسئولية: على الرغم من أن إجراء المقابلات مع المرشحين يعد أحد واجباتي المهنية ، إلا أنني أشارك في هذا المدونة ملاحظات شخصية وقصص وآراء شخصية.</i>  <i>يرجى عدم اعتبار هذا بيانًا رسميًا من Google أو Alphabet أو Reddit أو أي شخص أو مؤسسة أخرى.</i> <br><br><h1 style=";text-align:right;direction:rtl">  سؤال </h1><br>  بعد <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">آخر</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مقالتين</a> عن تقدم الحصان في طلب رقم هاتف ، تلقيت انتقادات بأن هذه ليست مشكلة واقعية.  بغض النظر عن مدى فائدة دراسة مهارات التفكير للمرشح ، ولكن يجب أن أعترف: المهمة ليست واقعية إلى حد ما.  على الرغم من أنني لدي بعض الأفكار حول العلاقة بين أسئلة المقابلة والواقع ، إلا أنني سأتركها لي الآن.  تأكد من أنني قرأت التعليقات في كل مكان ولديّ شيء يجب الإجابة عليه ، لكن ليس الآن. <br><br>  ولكن عندما تم حظر مهمة اجتياز الحصان قبل عدة سنوات ، أخذت انتقادات شديدة وحاولت استبداله بسؤال أكثر صلة بنطاق Google قليلاً.  وما الذي يمكن أن يكون أكثر صلة بـ Google من آليات استعلامات البحث؟  لذلك وجدت هذا السؤال واستخدمته لفترة طويلة قبل أن يتم نشره أيضًا وتم حظره.  كما كان من قبل ، سأقوم بصياغة السؤال ، والتعمق في شرحه ، ثم سأقول كيف استخدمته في المقابلات ولماذا أعجبتني. <br><br>  لذا فإن السؤال هو. <br><br>  تخيل أنك تدير محرك بحث شائعًا وترى طلبين في السجلات: مثل "تصنيفات موافقة أوباما" و "مستوى شعبية أوباما" (إذا كنت أتذكر بشكل صحيح ، فهذه أمثلة حقيقية من قاعدة الأسئلة ، على الرغم من أنها قديمة بعض الشيء الآن ...) .  نرى استعلامات مختلفة ، لكن الجميع سيوافقون: يبحث المستخدمون عن نفس المعلومات بشكل أساسي ، لذا يجب اعتبار الاستعلامات متكافئة عند حساب عدد الاستعلامات وإظهار النتائج ، وما إلى ذلك. <b>كيف يمكنك تحديد ما إذا كان هناك استبيانان مترادفان؟</b> <br><br>  دعونا إضفاء الطابع الرسمي على المهمة.  افترض أن هناك مجموعتين من أزواج السلسلة: أزواج المترادفات وأزواج الاستعلام. <br><br>  على وجه التحديد ، فيما يلي مثال للمدخلات لتوضيح: <br><br><pre style=";text-align:right;direction:rtl"><code class="python hljs">SYNONYMS = [ (<span class="hljs-string"><span class="hljs-string">'rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'approval'</span></span>, <span class="hljs-string"><span class="hljs-string">'popularity'</span></span>), ] QUERIES = [ (<span class="hljs-string"><span class="hljs-string">'obama approval rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'obama popularity ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'obama approval rates'</span></span>, <span class="hljs-string"><span class="hljs-string">'obama popularity ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'obama approval rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'popularity ratings obama'</span></span>) ]</code> </pre> <br>  من الضروري إنتاج قائمة من القيم المنطقية: هي الاستعلامات في كل زوج مرادف. <br><br><h1 style=";text-align:right;direction:rtl">  كل الأسئلة الجديدة ... </h1><br>  للوهلة الأولى ، هذه مهمة بسيطة.  ولكن كلما زاد طول فترة تفكيرك ، أصبح الأمر أكثر صعوبة.  يمكن للكلمة أن يكون لها عدة مرادفات؟  هل ترتيب الكلمات مهم؟  هل العلاقات مرادفة متعدّدة ، أي إذا كان مرادفًا لـ B و B مرادفًا لـ C ، فهل هو مرادف لـ C؟  هل يمكن للمرادفات أن تغطي بضع كلمات ، كيف أن "الولايات المتحدة الأمريكية" مرادف لعبارات "الولايات المتحدة الأمريكية" أو "الولايات المتحدة"؟ <br><br>  هذا الغموض على الفور يجعل من الممكن إثبات نفسك لمرشح جيد.  أول شيء يفعله هو البحث عن مثل هذه الغموض ومحاولة حلها.  يقوم كل شخص بذلك بطرق مختلفة: البعض يقترب من اللوحة ويحاول حل حالات معينة يدويًا ، بينما ينظر آخرون إلى السؤال ويرون على الفور الثغرات.  في أي حال ، تحديد هذه المشاكل في مرحلة مبكرة أمر بالغ الأهمية. <br><br>  تعتبر مرحلة "فهم المشكلة" ذات أهمية كبيرة.  أحب أن أسمي هندسة البرمجيات تخصصًا كسريًا.  مثل الفركتلات ، يكشف التقريب عن تعقيد إضافي.  تعتقد أنك تفهم المشكلة ، ثم ألق نظرة فاحصة - وترى أنك فاتتك بعض الدقة أو التفاصيل الخاصة بالتنفيذ التي يمكن تحسينها.  أو نهج مختلف لهذه المشكلة. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ee2/53b/e5a/ee253be5a2b504b310dea6050559bcba.gif"><br>  <i><font color="gray">مجموعة ماندلبروت</font></i> <br><br>  <b>يتم تحديد عيار المهندس إلى حد كبير من خلال مدى عمق يمكن أن يفهم المشكلة.</b>  الخطوة الأولى في هذه العملية هي تحويل بيان غامض للمشكلة إلى مجموعة مفصلة من المتطلبات ، والتخفيض المتعمد يجعل من الممكن تقييم مدى تقارب المرشح في المواقف الجديدة. <br><br>  <i>نترك جانباً أسئلة تافهة ، مثل "هل الأحرف الكبيرة مهمة؟" وهذا لا يؤثر على الخوارزمية الرئيسية.</i>  <i>أنا دائمًا أقدم أبسط إجابة على هذه الأسئلة (في هذه الحالة ، "افترض أن جميع الأحرف قد تم تجهيزها مسبقًا وتحولت إلى أحرف صغيرة")</i> <br><br><h1 style=";text-align:right;direction:rtl">  الجزء 1. (ليس تماما) قضية بسيطة </h1><br>  إذا طرح المرشحون أسئلة ، فأنا أبدأ دائمًا بأبسط الحالات: يمكن أن تحتوي الكلمة على عدة مرادفات ، ومسائل ترتيب الكلمات ، والمرادفات ليست متعدية.  هذا يعطي محرك البحث وظائف محدودة للغاية ، ولكن لديه ما يكفي من التفاصيل الدقيقة لإجراء مقابلة مثيرة للاهتمام. <br><br>  نظرة عامة رفيعة المستوى هي كما يلي: قسّم الاستعلام إلى كلمات (على سبيل المثال ، حسب المسافات) وقارن الأزواج المقابلة للبحث عن كلمات ومرادفات متطابقة.  بصريا ، يبدو مثل هذا: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c1/a65/908/7c1a6590877f4632beffa60d8cbb0afa.png"><br><br>  في الكود: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synonym_queries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(synonym_words, queries)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">''' synonym_words: iterable of pairs of strings representing synonymous words queries: iterable of pairs of strings representing queries to be tested for synonymous-ness '''</span></span> output = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> q1, q2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> queries: q1, q2 = q1.split(), q2.split() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(q1) != len(q2): output.append(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(q1)): w1, w2 = q1[i], q2[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> words_are_synonyms(w1, w2): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> output.append(result) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output</code> </pre> <br>  سهل ، أليس كذلك؟  حسابيًا ، إنه بسيط جدًا.  لا يوجد دينامية البرمجة ، العودية ، الهياكل المعقدة ، وما إلى ذلك. التلاعب البسيط بالمكتبة القياسية وخوارزمية تعمل في الوقت الخطي ، أليس كذلك؟ <br><br>  ولكن هناك فروق دقيقة أكثر مما يبدو للوهلة الأولى.  بطبيعة الحال ، فإن المكون الأكثر صعوبة هو المقارنة بين المرادفات.  على الرغم من أن المكون سهل الفهم والوصف ، إلا أن هناك العديد من الطرق لارتكاب خطأ.  سوف أخبرك عن الأخطاء الأكثر شيوعًا. <br><br>  من أجل الوضوح: لن تؤدي أي أخطاء إلى استبعاد أي مرشح ؛  إذا كان الأمر كذلك ، فأنا فقط أشير إلى وجود خطأ في التنفيذ ، فإنه يصلح ، ونحن نمضي قدمًا.  ومع ذلك ، فإن المقابلة هي أولاً وقبل كل شيء كفاح ضد الزمن.  سوف ترتكب الأخطاء وتلاحظها وتصحيحها ، لكن الأمر قد يستغرق وقتًا في وقت آخر ، على سبيل المثال ، لإنشاء حل أفضل.  كل شخص تقريباً يرتكب أخطاء ، هذا أمر طبيعي ، لكن المرشحين الذين يصغرونهم يظهرون نتائج أفضل ببساطة لأنهم يقضون وقتًا أقل في تصحيحها. <br><br>  هذا هو السبب في أنني أحب هذه المشكلة.  إذا كانت خطوة فارس تتطلب نظرة ثاقبة لفهم الخوارزمية ، ثم (آمل) تنفيذ بسيط ، فإن الحل هنا هو الكثير من الخطوات في الاتجاه الصحيح.  تمثل كل خطوة عقبة صغيرة يمكن للمرشح من خلالها القفز بلطف أو التعثر والارتفاع.  بفضل الخبرة والحدس ، يتجنب المرشحون الجيدين هذه المزالق الصغيرة - ويحصلون على حل أكثر تفصيلاً وصحيحاً ، بينما يقضي أضعف منهم الوقت والجهد على الأخطاء ويبقون عادةً مع الكود الخطأ. <br><br>  في كل مقابلة ، رأيت مزيجًا مختلفًا من النجاح والفشل ، فهذه هي الأخطاء الأكثر شيوعًا. <br><br><h4 style=";text-align:right;direction:rtl">  قتلة الأداء العشوائي </h4><br>  أولاً ، قام بعض المرشحين بتنفيذ الكشف عن مرادفات من خلال اجتياز قائمة المرادفات ببساطة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (w1, w2) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> ...</code> </pre> <br>  للوهلة الأولى ، يبدو هذا معقولاً.  لكن بعد الفحص الدقيق ، الفكرة سيئة للغاية.  بالنسبة لأولئك منكم الذين لا يعرفون Python ، فإن الكلمة المفتاحية هي السكر النحوي للأسلوب الذي <i>يحتوي على</i> ويعمل على جميع حاويات Python القياسية.  هذه مشكلة لأن <code>synonym_words</code> عبارة عن قائمة تنفذ الكلمة الأساسية باستخدام البحث الخطي.  يكون مستخدمو Python حساسين بشكل خاص لهذا الخطأ لأن اللغة تخفي أنواعًا ، لكن مستخدمي C ++ و Java ارتكبوا أيضًا أخطاء مماثلة في بعض الأحيان. <br><br>  خلال مسيرتي المهنية ، كتبت فقط عدة مرات باستخدام شفرة بحث خطية ، وكل منها في قائمة لا تزيد عن 24 عنصرًا.  وحتى في هذه الحالة ، كتب تعليقًا طويلًا يشرح سبب اختياره لمثل هذا النهج على ما يبدو دون المستوى الأمثل.  أظن أن بعض المرشحين استخدموه ببساطة لأنهم لم يعرفوا كيف تعمل الكلمة الرئيسية في قوائم في مكتبة Python القياسية.  هذا خطأ بسيط ، وليس قاتلاً ، لكن التعارف الضعيف مع لغتك المفضلة ليس جيدًا. <br><br>  في الممارسة العملية ، يتم تجنب هذا الخطأ بسهولة.  أولاً ، لا تنس أبدًا أنواع الكائنات الخاصة بك ، حتى إذا كنت تستخدم لغة غير نمطية مثل Python!  ثانياً ، تذكر أنه عند استخدام الكلمة الأساسية <i>في</i> القائمة ، يبدأ البحث الخطي.  إذا لم يكن هناك ضمان بأن تظل هذه القائمة صغيرة جدًا دائمًا ، فسوف تقتل الأداء. <br><br>  لكي يأتي المرشح إلى رشده ، يكفي عادة تذكيره بأن بنية الإدخال هي قائمة.  من المهم جدًا ملاحظة كيفية استجابة المرشح للموجه.  يحاول أفضل المرشحين على الفور المعالجة المسبقة للمرادفات ، وهذا يعد بداية جيدة.  ومع ذلك ، فإن هذا النهج لا يخلو من المآزق ... <br><br><h4 style=";text-align:right;direction:rtl">  استخدم بنية البيانات الصحيحة </h4><br>  من الكود أعلاه ، يتضح على الفور أنه من أجل تنفيذ هذه الخوارزمية في الوقت الخطي ، من الضروري العثور على المرادفات بسرعة.  وعندما نتحدث عن عمليات البحث السريعة ، فهي دائمًا خريطة أو مجموعة من التجزئات. <br><br>  لا يهمني ما إذا كان المرشح يختار خريطة أو مجموعة من التجزئات.  الشيء المهم هو أنه سوف يضعها هناك (بالمناسبة ، لا تستخدم dict / hashmap مع الانتقال إلى <code>True</code> أو <code>False</code> ).  معظم المرشحين اختيار نوع من dict / hashmap.  الخطأ الأكثر شيوعًا هو الافتراض الباطن بأن كل كلمة ليس لها أكثر من مرادف واحد: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1] = w2 ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> synonyms[w1] == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  أنا لا أعاقب المرشحين لهذا الخطأ.  تمت صياغة المهمة خصيصًا حتى لا تركز على حقيقة أن الكلمات يمكن أن يكون لها عدة مرادفات ، وبعض المرشحين ببساطة لم يواجهوا مثل هذا الموقف.  بسرعة أكبر إصلاح الخلل عندما أشر إلى ذلك.  يلاحظ المرشحون الجيدون ذلك في مرحلة مبكرة وعادة ما لا يقضون الكثير من الوقت. <br><br>  المشكلة الأكثر خطورة هي قلة الوعي بأن علاقة المرادفات تنتشر في كلا الاتجاهين.  لاحظ أنه في الكود أعلاه ، يتم أخذ ذلك في الاعتبار.  ولكن هناك تطبيقات مع وجود خطأ: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].append(w2) synonyms[w2].append(w1) ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w1, tuple()): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  لماذا إدراج اثنين واستخدام ضعف الذاكرة؟ <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].append(w2) ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w1, tuple()) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w2, tuple())): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  الاستنتاج: <i>فكر دائمًا في كيفية تحسين الكود</i> !  في الماضي ، يعد التقليب في وظائف البحث تحسينًا واضحًا ، وإلا يمكننا أن نستنتج أن المرشح لم يفكر في خيارات التحسين.  مرة أخرى ، أنا سعيد بإعطاء تلميح ، لكن من الأفضل تخمين ذلك بنفسك. <br><br><h1 style=";text-align:right;direction:rtl">  فرز؟ </h1><br>  يريد بعض المرشحين الأذكياء فرز قائمة المرادفات ثم استخدام البحث الثنائي.  في الواقع ، تتمتع هذه الطريقة بميزة مهمة: فهي لا تتطلب مساحة إضافية ، باستثناء قائمة المرادفات (بشرط أن يتم تغيير القائمة). <br><br>  لسوء الحظ ، يتداخل تعقيد الوقت: يتطلب فرز قائمة المرادفات <code>Nlog(N)</code> ، ثم <code>log(N)</code> آخر <code>log(N)</code> للبحث عن كل زوج من المرادفات ، بينما يحدث حل المعالجة المسبقة الموصوفة في وقت خطي ثم ثابت.  بالإضافة إلى ذلك ، أنا أعارض بشكل قاطع إجبار المرشح على تنفيذ عملية الفرز والبحث الثنائي على السبورة ، لأنه: 1) خوارزميات الفرز معروفة جيدًا ، لذلك ، بقدر ما أعرف ، يمكن للمرشح إصدارها دون تفكير ؛  2) يصعب تنفيذ هذه الخوارزميات بشكل شيطاني ، وغالبًا ما يرتكب حتى أفضل المرشحين أخطاء لا تقل شيئًا عن مهاراتهم في البرمجة. <br><br>  كلما اقترح أحد المرشحين مثل هذا الحل ، كنت مهتمًا بوقت تنفيذ البرنامج وسألني عما إذا كان هناك خيار أفضل.  للحصول على معلومات: إذا سألك القائم بإجراء المقابلة إذا كان هناك خيار أفضل ، فالجواب دائمًا ما يكون نعم.  إذا طرحت عليك هذا السؤال ، فإن الإجابة ستكون بالتأكيد. <br><br><h4 style=";text-align:right;direction:rtl">  وأخيرا الحل </h4><br>  في النهاية ، يقدم المرشح شيئًا صحيحًا ومثاليًا بشكل معقول.  فيما يلي تطبيق في الوقت الخطي والمساحة الخطية لظروف معينة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synonym_queries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(synonym_words, queries)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">''' synonym_words: iterable of pairs of strings representing synonymous words queries: iterable of pairs of strings representing queries to be tested for synonymous-ness '''</span></span> synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].add(w2) output = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> q1, q2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> queries: q1, q2 = q1.split(), q2.split() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(q1) != len(q2): output.append(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(q1)): w1, w2 = q1[i], q2[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> ((w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w1]) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w2])): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> output.append(result) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output</code> </pre> <br>  بعض الملاحظات السريعة: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  لاحظ استخدام <code>dict.get()</code> .  يمكنك تنفيذ فحص لمعرفة ما إذا كان المفتاح موجودًا في الأمر ، ثم الحصول عليه ، لكن هذا نهج معقد ، على الرغم من أنه بهذه الطريقة ستظهر معرفتك بالمكتبة القياسية. </li><li style=";text-align:right;direction:rtl">  أنا شخصياً لست من المعجبين بالكود مع المتابعة <code>continue</code> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وبعض أدلة الأنماط تمنعهم أو لا توصي بهم</a> .  أنا نفسي في الإصدار الأول من هذا الرمز نسيت بيان المتابعة بعد التحقق من طول الطلب.  هذه ليست طريقة سيئة ، فقط اعلم أنها عرضة للخطأ. </li></ul><br><h1 style=";text-align:right;direction:rtl">  الجزء 2: الحصول على أكثر صعوبة! </h1><br>  لا يزال أمام المرشحين الجيدين ، بعد حل المشكلة ، ما بين 10 إلى 15 دقيقة من الوقت المتبقي.  لحسن الحظ ، هناك مجموعة من الأسئلة الإضافية ، على الرغم من أنه من غير المرجح أن نكتب الكثير من التعليمات البرمجية خلال هذا الوقت.  ومع ذلك ، هذا ليس ضروريا.  أريد أن أعرف شيئين عن المرشح: هل هو قادر على تطوير الخوارزميات وهل يمكنه الرمز؟  المشكلة في تحرك الفارس أولاً تجيب على سؤال حول تطوير الخوارزمية ، ثم تحقق من الترميز ، وهنا نحصل على الإجابات بالترتيب العكسي. <br><br>  بحلول الوقت الذي أكمل فيه المرشح الجزء الأول من السؤال ، كان قد حل المشكلة بالفعل من خلال الترميز (غير المدهش).  في هذه المرحلة ، يمكنني التحدث بثقة عن قدرته على تطوير خوارزميات بدائية وترجمة الأفكار إلى رمز ، وكذلك معرفته بلغته المفضلة ومكتبته القياسية.  أصبحت المحادثة الآن أكثر إثارة للاهتمام ، لأنه يمكن الاسترخاء في متطلبات البرمجة ، وسنتعمق في الخوارزميات. <br><br>  لهذا الغرض ، نعود إلى الافتراضات الرئيسية للجزء الأول: ترتيب الكلمات مهم ، المترادفات غير متعدية ، ولكل كلمة يمكن أن يكون هناك عدة مرادفات.  مع تقدم المقابلة ، أقوم بتغيير كل من هذه القيود ، وفي هذه المرحلة الجديدة ، أقوم أنا والمرشح بإجراء مناقشة حسابية بحتة.  سأقدم هنا أمثلة على الكود لتوضيح وجهة نظري ، لكن في مقابلة حقيقية نتحدث فقط عن الخوارزميات. <br><br>  قبل البدء ، سأشرح موقفي: جميع الإجراءات اللاحقة في هذه المرحلة من المقابلة هي أساسًا "نقاط مكافأة".  توجهي الشخصي هو تحديد المرشحين الذين يمرون بالمرحلة الأولى ويعدون مناسبين للعمل.  هناك حاجة إلى المرحلة الثانية لتسليط الضوء على الأفضل.  التصنيف الأول قوي بالفعل ويعني أن المرشح جيد بما فيه الكفاية للشركة ، والتصنيف الثاني يقول أن المرشح ممتاز وأن تعيينه سيكون نصرًا كبيرًا لنا. <br><br><h1 style=";text-align:right;direction:rtl">  الانتقالية: النهج الساذجة </h1><br>  أولاً ، أود إزالة قيد النقل ، لذا إذا كان الزوجان A - B و B - C هما مترادفتان ، فإن الكلمتين A و C هما مرادفتان.  سوف يفهم المرشحون الأذكياء بسرعة كيفية تكييف حلهم السابق ، على الرغم من أنه مع إزالة القيود الأخرى ، فإن المنطق الأساسي للخوارزمية سوف يتوقف عن العمل. <br><br>  ومع ذلك ، كيفية تكييفه؟  نهج واحد مشترك هو الحفاظ على مجموعة كاملة من المرادفات لكل كلمة على أساس العلاقات متعدية.  في كل مرة نقوم فيها بإدراج كلمة في مجموعة من المرادفات ، نضيفها أيضًا إلى المجموعات المقابلة لكل الكلمات في هذه المجموعة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w1]: synonyms[w].add(w2) synonyms[w1].add(w2) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w2]: synonyms[w].add(w1) synonyms[w2].add(w1)</code> </pre> <br>  <i><font color="gray">يرجى ملاحظة أنه عند إنشاء الشفرة ، لقد بحثنا بالفعل في هذا الحل.</font></i> <br><br>  هذا الحل يعمل ، ولكن أبعد ما يكون عن الأمثل.  لفهم الأسباب ، نقدر التعقيد المكاني لهذا الحل.  يجب إضافة كل مرادف ليس فقط لمجموعة الكلمة الأولى ، ولكن أيضًا إلى مجموعات جميع مرادفاتها.  إذا كان هناك مرادف واحد ، فسيتم إضافة إدخال واحد.  ولكن إذا كان لدينا 50 مرادفًا ، فيجب عليك إضافة 50 إدخالًا.  في الشكل ، يبدو مثل هذا: <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/e3f/ab6/e25/e3fab6e25d14821ec06d623925db9ac5.png"></div><br><br>  لاحظ أننا انتقلنا من ثلاثة مفاتيح وستة سجلات إلى أربعة مفاتيح واثني عشر سجلًا.  ستتطلب الكلمة التي تحتوي على 50 مرادفًا 50 مفتاحًا وحوالي 2500 إدخال.  المساحة اللازمة لتمثيل كلمة واحدة تنمو بشكل رباعي مع زيادة في مجموعة المرادفات ، والتي هي مضيعة إلى حد ما. <br><br>  هناك حلول أخرى ، لكنني لن أبذل قصارى جهدي حتى لا أضخّم المقال.  الأكثر إثارة للاهتمام منهم هو استخدام بنية بيانات مرادف لبناء رسم بياني موجه ، ومن ثم بحث أولي للعثور على المسار بين كلمتين.  هذا حل رائع ، لكن البحث يصبح خطيًا في حجم مجموعة المرادفات للكلمة.  نظرًا لأننا نجري هذا البحث لكل طلب عدة مرات ، فإن هذا الأسلوب ليس هو الأمثل. <br><br><h1 style=";text-align:right;direction:rtl">  Transitivity: استخدام مجموعات Disjoint </h1><br>  اتضح أن البحث عن المرادفات أمر ممكن لوقت ثابت (تقريبًا) بفضل بنية بيانات تسمى مجموعات منفصلة.  يوفر هذا الهيكل إمكانيات مختلفة قليلاً عن مجموعة بيانات منتظمة. <br><br>  بنية المجموعة المعتادة (hashset ، مجموعة الأشجار) عبارة عن حاوية تسمح لك بتحديد ما إذا كان الكائن داخلها أم خارجها بسرعة.  تعمل مجموعات Disjoint على حل مشكلة مختلفة تمامًا: فبدلاً من تحديد عنصر معين ، تسمح لك بتحديد <i>ما إذا كان هناك عنصران ينتميان إلى نفس المجموعة</i> .  علاوة على ذلك ، فإن الهيكل يقوم بذلك لوقت سريع للغاية <code>O(a(n))</code> ، حيث <code>a(n)</code> هي وظيفة أكرمان معكوسة.  إذا لم تكن قد درست الخوارزميات المتقدمة ، فقد لا تعرف هذه الوظيفة ، والتي يتم تنفيذها فعليًا في جميع الأوقات بالنسبة لجميع المدخلات المعقولة. <br><br>  على مستوى عالٍ ، تعمل الخوارزمية على النحو التالي.  يتم تمثيل مجموعات من الأشجار مع الآباء لكل عنصر.  نظرًا لأن كل شجرة لها جذر (عنصر يمثل أصلها الرئيسي) ، يمكننا تحديد ما إذا كان عنصران ينتميان إلى نفس المجموعة من خلال تتبع الوالدين على الجذر.  إذا كان لدى عنصرين جذر واحد ، فهما ينتميان إلى مجموعة واحدة.  من السهل أيضًا الجمع بين المجموعات: فما عليك سوى العثور على العناصر الجذرية وجعل أحدها جذر الآخر. <br><br>  جيد حتى الآن ، ولكن حتى الآن لم تشهد أي سرعة مذهلة.  عبقرية هذه البنية في إجراء يسمى <i>الضغط</i> .  افترض أن لديك الشجرة التالية: <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/e4b/132/102/e4b13210226d0375adc1acf7835ef4a2.png"></div><br><br>  تخيل أنك تريد معرفة ما إذا كانت <i>السرعة</i> <i>والمتسرعة</i> مرادفات.  اذهب من خلال كل والدين - والعثور على نفس الجذر <i>السريع</i> .  لنفترض الآن أننا نقوم بإجراء فحص مشابه للكلمات <i>السريعة</i> <i>والسريعة</i> .  مرة أخرى ، نذهب إلى الجذر ، ومن <i>السريع</i> نسير في نفس الطريق.  هل يمكن تجنب ازدواجية العمل؟ <br><br>  اتضح ما تستطيع.  بمعنى ما ، كل عنصر في هذه الشجرة مقدر له أن <i>يصوم</i> .  بدلاً من المرور عبر الشجرة بأكملها في كل مرة ، لماذا لا تقوم بتغيير الوالد لجميع المتحدرين <i>بسرعة</i> لتقصير الطريق إلى الجذر؟  هذه العملية تسمى الضغط ، وفي مجموعات منفصلة يتم تضمينها في عملية البحث عن الجذر.  على سبيل المثال ، بعد أول عملية مقارنة <i>سريعة</i> <i>ومتسارعة ،</i> ستفهم البنية أنها مترادفات وستضغط الشجرة على النحو التالي: <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/2d4/381/3b9/2d43813b9925bf86d0e4b3a2c9a99707.png"></div><br>  <i><font color="gray">بالنسبة لجميع الكلمات بين السرعة والسرعة ، تم تحديث الأصل ، حدث الشيء نفسه مع متسرع</font></i> <br><br>  الآن ستحدث جميع المكالمات اللاحقة في وقت ثابت ، لأن كل عقدة في هذه الشجرة تشير إلى <i>الصيام</i> .  ليس من السهل للغاية تقييم التعقيد الزمني للعمليات: في الواقع ، ليس ثابتًا ، لأنه يعتمد على عمق الأشجار ، ولكنه قريب من الثابت ، لأن الهيكل يتم تحسينه بسرعة.  للبساطة ، نحن نفترض أن الوقت ثابت. <br><br>  مع هذا المفهوم ، ننفذ مجموعات غير مرتبطة بمشكلتنا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DisjointSet</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.parents = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w)</span></span></span><span class="hljs-function">:</span></span> words_traversed = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> self.parents[w] != w: words_traversed.append(w) w = self.parents[w] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> words_traversed: self.parents[word] = w <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> w <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_synonyms</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w1, w2)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.parents: self.parents[w1] = w1 <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.parents: self.parents[w2] = w2 w1_root = self.get_root(w1) w2_root = self.get_root(w2) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1_root &lt; w2_root: w1_root, w2_root = w2_root, w1_root self.parents[w2_root] = w1_root <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">are_synonymous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w1, w2)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.get_root(w1) == self.get_root(w2)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> باستخدام هذا الهيكل ، يمكنك معالجة المترادفات مسبقًا وحل المشكلة في الوقت الخطي. </font></font><br><br><h1 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> التقييم والملاحظات </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بحلول هذا الوقت ، وصلنا إلى الحد الأقصى لما يمكن للمرشح إظهاره في 40-45 دقيقة من المقابلة. </font><font style="vertical-align: inherit;">لجميع المرشحين الذين تعاملوا مع الجزء التمهيدي وأحرزوا تقدمًا كبيرًا في وصف (لا ينفذون) مجموعات غير مرتبطة ، حددت تصنيفًا "موصى به للغاية للتأجير" وسمحت لهم بطرح أي أسئلة. </font><font style="vertical-align: inherit;">لم أر أي مرشح يذهب إلى هذا الحد ولم يتبق الكثير من الوقت. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">من حيث المبدأ ، لا تزال هناك متغيرات للمشكلة المتعلقة بالنقل: على سبيل المثال ، قم بإزالة القيود المفروضة على ترتيب الكلمات أو على عدة مرادفات لكلمة. </font><font style="vertical-align: inherit;">سيكون كل قرار صعبًا وممتعًا ، لكنني سأتركه لاحقًا.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ميزة هذه المهمة هي أنها تسمح للمرشحين بارتكاب أخطاء. </font><font style="vertical-align: inherit;">يتكون تطوير البرامج اليومي من دورات لا تنتهي من التحليل والتنفيذ والصقل. </font><font style="vertical-align: inherit;">تتيح هذه المشكلة للمرشحين إظهار قدراتهم في كل مرحلة. </font><font style="vertical-align: inherit;">النظر في المهارات اللازمة للحصول على أقصى درجة في هذه المسألة:</font></font><br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">النظر في بيان المشكلة</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> و </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تحديد مكان ليس بما فيه الكفاية التعبير</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، وضع صياغة واضحة. </font><font style="vertical-align: inherit;">استمر في القيام بذلك أثناء حلك وتثور أسئلة جديدة. </font><font style="vertical-align: inherit;">لتحقيق أقصى قدر من الكفاءة ، قم بتنفيذ هذه العمليات في أقرب وقت ممكن ، لأنه كلما استمر العمل ، زاد الوقت اللازم لإصلاح الخطأ.</font></font><br></li><li style=";text-align:right;direction:rtl"> <i> </i>  ,        .       ,         . <br></li><li style=";text-align:right;direction:rtl"> <i>  </i> .          ,    ,      . <br></li><li style=";text-align:right;direction:rtl">  , <i>    </i> .     ,      <code>continue</code> ,   ,     . <br></li><li style=";text-align:right;direction:rtl">    , <i>  :   ,   </i> ,    ,    . ,      ,       ,    . <br></li><li style=";text-align:right;direction:rtl"> <i>    </i> .   —    ,          .        —    . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لا يمكن تعلم أي من هذه المهارات من الكتب المدرسية (مع استثناء محتمل لهياكل البيانات والخوارزميات). </font><font style="vertical-align: inherit;">الطريقة الوحيدة لاكتساب هذه الممارسات هي الممارسة المنتظمة والواسعة ، والتي تتوافق جيدًا مع ما يحتاج إليه صاحب العمل: المرشحون المتمرسون القادرون على تطبيق معارفهم بفعالية. </font><font style="vertical-align: inherit;">كان الهدف من المقابلات هو العثور على هؤلاء الأشخاص ، وقد ساعدتني مهمة هذا المقال جيدًا لفترة طويلة.</font></font><br><br><h1 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الخطط المستقبلية </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كما يمكنك أن تفهم ، </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أصبحت</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> المهمة في نهاية المطاف </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;">معروفة للجمهور</font></a><font style="vertical-align: inherit;"> . منذ ذلك الحين ، استخدمت العديد من الأسئلة الأخرى ، بناءً على ما طرحه المقابلات السابقون وعلى مزاجي (طرح سؤال واحد ممل طوال الوقت). ما زلت أستخدم بعض الأسئلة ، لذلك سأبقيها سراً ، لكن البعض الآخر ليس كذلك! يمكنك العثور عليها في المقالات التالية. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في المستقبل القريب أخطط لمادتين. أولاً ، كما وعدنا أعلاه ، سأشرح الحل للمشكلتين المتبقيتين لهذه المهمة. لم أطلب منهم أبدًا في المقابلات ، لكنهم مثيرون للاهتمام في أنفسهم. بالإضافة إلى ذلك ، سوف أشارك أفكاري وآرائي الشخصية حول الإجراء الخاص بالعثور على موظفين في تكنولوجيا المعلومات ، وهو ما يهمني بشكل خاص الآن لأنني أبحث عن مهندسين لفريقي في Reddit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كما هو الحال دائمًا ، إذا كنت تريد معرفة إصدار مقالات جديدة ، فاتبعني </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> أو على " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">متوسط"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">إذا أعجبك هذا المقال ، فلا تنس التصويت لصالحه أو اترك تعليقًا. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">شكرا للقراءة! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS: يمكنك فحص شفرة جميع المقالات في </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هذا جيثب مستودع</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> أو </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اللعب معهم حية</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بفضل أصدقائي جيدة من </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repl.it</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar437702/">https://habr.com/ru/post/ar437702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar437686/index.html">تعلم الذهاب: كتابة رسول P2P مع التشفير نهاية إلى نهاية</a></li>
<li><a href="../ar437688/index.html">OpenSceneGraph: تقنيات البرمجة الأساسية</a></li>
<li><a href="../ar437694/index.html">تحليل الأداة المساعدة Files.walkFileTree () ؛</a></li>
<li><a href="../ar437696/index.html">ملخص المواد المثيرة للاهتمام لمطور الهاتف المحمول رقم 283 (يومي 21 و 27 يناير)</a></li>
<li><a href="../ar437698/index.html">خدمة ترجمة براءات الاختراع في الويبو - تجربتي</a></li>
<li><a href="../ar437704/index.html">معرفة ممتازة بالمنهاج المدرسي كمؤشر لعدم أعلى الذكاء</a></li>
<li><a href="../ar437706/index.html">سنة مع تسلا</a></li>
<li><a href="../ar437710/index.html">قصر حقوق المستخدم المحلية على نظام Linux على الحد الأدنى</a></li>
<li><a href="../ar437712/index.html">محطة الفضاء Roskomnadzor</a></li>
<li><a href="../ar437714/index.html">نرسم انفجار كاريكاتوري لـ 180 خطًا من C ++ عارية</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>