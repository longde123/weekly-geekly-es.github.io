<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∂üèΩ üå§Ô∏è üçô Cartes hexagonales dans Unity: cycle de l'eau, √©rosion, biomes, carte cylindrique ‚è≥ üßöüèæ üë®üèΩ‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parties 1-3: maillage, couleurs et hauteurs de cellule 

 Parties 4-7: bosses, rivi√®res et routes 

 Parties 8-11: eau, reliefs et remparts 

 Parties...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cartes hexagonales dans Unity: cycle de l'eau, √©rosion, biomes, carte cylindrique</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427567/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 1-3: maillage, couleurs et hauteurs de cellule</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 4-7: bosses, rivi√®res et routes</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 8-11: eau, reliefs et remparts</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 12-15: sauvegarde et chargement, textures, distances</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 16-19: trouver le chemin, √©quipes de joueurs, animations</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 20-23: Brouillard de guerre, recherche cartographique, g√©n√©ration proc√©durale</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 24-27: cycle de l'eau, √©rosion, biomes, carte cylindrique</a> <br><br><h1>  Partie 24: r√©gions et √©rosion </h1><br><ul><li>  Ajoutez une bordure d'eau autour de la carte. </li><li>  Nous divisons la carte en plusieurs r√©gions. </li><li>  Nous utilisons l'√©rosion pour couper les falaises. </li><li>  Nous d√©pla√ßons le terrain pour lisser le relief. </li></ul><br>  Dans la partie pr√©c√©dente, nous avons jet√© les bases de la g√©n√©ration de cartes proc√©durales.  Cette fois, nous limiterons les lieux d'occurrence possible des terres et agirons sur elles avec l'√©rosion. <br><br>  Ce didacticiel a √©t√© cr√©√© dans Unity 2017.1.0. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ac/6a5/30c/5ac6a530cef3718f9031abe862364093.jpg"></div><br>  <i>S√©parez et lissez le terrain.</i> <br><a name="habracut"></a><br><h2>  Bordure de la carte </h2><br>  √âtant donn√© que nous augmentons les zones de terrain au hasard, il peut arriver que le terrain touche le bord de la carte.  Cela peut √™tre ind√©sirable.  La carte limit√©e par l'eau contient une barri√®re naturelle qui emp√™che les joueurs de s'approcher du bord.  Par cons√©quent, ce serait bien si nous interdisions au terrain de s'√©lever au-dessus du niveau de l'eau pr√®s du bord de la carte. <br><br><h3>  Taille de bordure </h3><br>  √Ä quelle distance la terre doit-elle √™tre au bord de la carte?  Il n'y a pas de bonne r√©ponse √† cette question, nous allons donc rendre ce param√®tre personnalisable.  Nous allons ajouter deux curseurs au composant <code>HexMapGenerator</code> , l'un pour les bordures le long des bords le long de l'axe X, l'autre pour les bordures le long de l'axe Z. Nous pouvons donc utiliser une bordure plus large dans l'une des dimensions, ou m√™me cr√©er une bordure dans une seule dimension.  Utilisons un intervalle de 0 √† 10 avec une valeur par d√©faut de 5. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapBorderX = <span class="hljs-number"><span class="hljs-number">5</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapBorderZ = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/694/8ab/c74/6948abc743e881596bdea5656e562943.png"></div><br>  <i>Curseurs de bordure de carte.</i> <br><br><h3>  Nous limitons les centres des zones terrestres </h3><br>  Sans bordures, toutes les cellules sont valides.  Lorsqu'il existe des limites, les coordonn√©es de d√©calage minimales autoris√©es augmentent et les coordonn√©es maximales autoris√©es diminuent.  Puisque pour g√©n√©rer les trac√©s, nous aurons besoin de conna√Ætre l'intervalle autoris√©, suivons-le en utilisant quatre champs entiers. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xMin, xMax, zMin, zMax;</code> </pre> <br>  Nous initialisons les contraintes dans <code>GenerateMap</code> avant de cr√©er des sushis.  Nous utilisons ces valeurs comme param√®tres pour les appels <code>Random.Range</code> , donc les aigus sont en fait exceptionnels.  Sans bordure, elles sont √©gales au nombre de cellules de mesure, donc pas moins 1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = waterLevel; } xMin = mapBorderX; xMax = x - mapBorderX; zMin = mapBorderZ; zMax = z - mapBorderZ; CreateLand(); ‚Ä¶ }</code> </pre> <br>  Nous n'interdirons pas strictement l'apparition de terres au-del√† de la fronti√®re de la fronti√®re, car cela cr√©erait des bords fortement coup√©s.  Au lieu de cela, nous limiterons uniquement les cellules utilis√©es pour d√©marrer la g√©n√©ration des trac√©s.  Autrement dit, les centres approximatifs des sites seront limit√©s, mais certaines parties des sites pourront d√©passer la zone frontali√®re.  Cela peut √™tre fait en modifiant <code>GetRandomCell</code> afin qu'il s√©lectionne une cellule dans la plage de d√©calages autoris√©s. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// return grid.GetCell(Random.Range(0, cellCount)); return grid.GetCell(Random.Range(xMin, xMax), Random.Range(zMin, zMax)); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/bbf/24b/7a8bbf24b1d46d9b97e8e9c01652fdfd.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/0cf/aa2/a310cfaa2bec1cbe019a08c14218c7fd.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f1/799/f50/7f1799f5058c0d1e435bfc3c42133b9c.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93a/c4b/1b7/93ac4b1b771eaa896b6c494b69c18b92.jpg"></div><br>  <i>Les bordures de la carte sont 0 √ó 0, 5 √ó 5, 10 √ó 10 et 0 √ó 10.</i> <br><br>  Lorsque tous les param√®tres de la carte sont d√©finis sur leurs valeurs par d√©faut, une bordure de taille 5 prot√©gera de mani√®re fiable le bord de la carte contre tout contact avec la terre.  Cependant, ce n'est pas garanti.  Le terrain peut parfois se rapprocher du bord, et parfois le toucher √† plusieurs endroits. <br><br>  La probabilit√© que la terre traverse la fronti√®re enti√®re d√©pend de la taille de la fronti√®re et de la taille maximale du site.  Sans h√©sitation, les sections restent des hexagones.  Hexagone complet avec rayon <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>r</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.049ex" height="1.455ex" viewBox="0 -520.7 451.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiAvzn-bnrj2WYrEhaONwUdviPOZg#MJMATHI-72" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>r</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> r </script>  contient <math></math><img src="https://habrastorage.org/getpro/habr/formulas/d71/5bd/e60/d715bde606fb89c2976f626130a1f29c.svg" alt="3r ^ 2 + 3r + 1 $" data-tex="inline">  les cellules.  S'il y a des hexagones avec un rayon √©gal √† la taille de la fronti√®re, alors ils peuvent la traverser.  Un hexagone complet avec un rayon de 5 contient 91 cellules.  Comme par d√©faut, le maximum est de 100 cellules par section, cela signifie que la terre pourra poser un pont sur 5 cellules, surtout s'il y a des vibrations.  Pour √©viter cela, r√©duisez la taille maximale du trac√© ou augmentez la taille de la bordure. <br><br><div class="spoiler">  <b class="spoiler_title">Comment d√©rive la formule du nombre de cellules dans la r√©gion hexagonale?</b> <div class="spoiler_text">  Avec un rayon de 0, nous avons affaire √† une seule cellule.  Il est venu de 1. Avec un rayon de 1 autour du centre, il y a six cellules suppl√©mentaires, soit <math></math><img src="https://habrastorage.org/getpro/habr/formulas/3d5/233/62b/3d523362b8144ab01c2baba35b9f944b.svg" alt="6 $ + 1 $" data-tex="inline">  .  Ces six cellules peuvent √™tre consid√©r√©es comme les extr√©mit√©s de six triangles touchant le centre.  Avec un rayon de 2, une deuxi√®me ligne est ajout√©e √† ces triangles, c'est-√†-dire que deux cellules suppl√©mentaires sont obtenues sur le triangle, et au total <math></math><img src="https://habrastorage.org/getpro/habr/formulas/b2c/53c/716/b2c53c716a83a485635ae30c3ef658b6.svg" alt="6 $ (1 + 2) + 1 $" data-tex="inline">  .  Avec un rayon de 3, une troisi√®me ligne est ajout√©e, c'est-√†-dire trois cellules suppl√©mentaires par triangle, et au total <math></math><img src="https://habrastorage.org/getpro/habr/formulas/e72/090/171/e72090171bfbb337a90a1382abe33aab.svg" alt="6 $ (1 + 2 + 3) + 1 $" data-tex="inline">  .  Et ainsi de suite.  Autrement dit, en termes g√©n√©raux, la formule ressemble √† <math></math><img src="https://habrastorage.org/getpro/habr/formulas/d78/a6a/88e/d78a6a88eb8b1c1ba93a82f2211ab151.svg" alt="6 $ (sum_ (i = 1) ^ ri) +1 = 6 ((r (r + r)) / 2) +1 = 3r (r + 1) + 1 = 3r ^ 2 + 3r + 1 $" data-tex="inline">  . </div></div><br>  Pour voir cela plus clairement, nous pouvons d√©finir la taille de la fronti√®re √† 200. Puisqu'un hexagone complet avec un rayon de 8 contient 217 cellules, la terre est susceptible de toucher le bord de la carte.  Au moins si vous utilisez la valeur de taille de bordure par d√©faut (5).  Si vous augmentez la bordure √† 10, la probabilit√© diminuera consid√©rablement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/75d/eb0/74b75deb060d9bdae2f74c1db4de287e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffa/7ce/e96/ffa7cee967f81ba9fe4ddc6718519d9a.jpg"></div><br>  <i>Le terrain a une taille constante de 200, les limites de la carte sont 5 et 10.</i> <br><br><h3>  Pangaea </h3><br>  Notez que lorsque vous augmentez la bordure de la carte et conservez le m√™me pourcentage de terrain, nous for√ßons le terrain √† former une zone plus petite.  En cons√©quence, une grande carte par d√©faut est tr√®s susceptible de cr√©er une seule grande masse de terre - le supercontinent Pangaea - √©ventuellement avec plusieurs petites √Æles.  Avec une augmentation de la taille de la fronti√®re, la probabilit√© que cela augmente, et √† certaines valeurs, nous sommes presque assur√©s d'obtenir un supercontinent.  Cependant, lorsque le pourcentage de terrain est trop grand, la plupart des zones disponibles se remplissent et, par cons√©quent, nous obtenons une masse de terrain presque rectangulaire.  Pour √©viter que cela ne se produise, vous devez r√©duire le pourcentage de terrain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/d84/209/e1bd8420915ccc74cd3470409b9a4236.jpg"></div><br>  <i>Sushi √† 40% avec une bordure de carte de 10.</i> <br><br><div class="spoiler">  <b class="spoiler_title">D'o√π vient le nom Pangea?</b> <div class="spoiler_text">  C'√©tait le nom du dernier supercontinent connu qui existait sur Terre il y a de nombreuses ann√©es.  Le nom est compos√© des mots grecs pan et Gaia, ce qui signifie quelque chose comme ¬´toute la nature¬ª ou ¬´toute la terre¬ª. </div></div><br><br><h3>  Nous prot√©geons des cartes impossibles </h3><br>  Nous g√©n√©rons la bonne quantit√© de terre en continuant simplement √† √©lever la terre jusqu'√† ce que nous atteignions la masse terrestre souhait√©e.  Cela fonctionne parce que t√¥t ou tard nous √©l√®verons chaque cellule au niveau de l'eau.  Cependant, lorsque vous utilisez la bordure de la carte, nous ne pouvons pas atteindre chaque cellule.  Lorsqu'un pourcentage de terrain trop √©lev√© est requis, cela entra√Ænera des ¬´tentatives et des √©checs¬ª sans fin du g√©n√©rateur pour √©lever plus de terrain, et il restera coinc√© dans un cycle sans fin.  Dans ce cas, l'application se bloquera, mais cela ne devrait pas se produire. <br><br>  Nous ne pouvons pas trouver de mani√®re fiable des configurations impossibles √† l'avance, mais nous pouvons nous prot√©ger contre des cycles sans fin.  Nous allons simplement suivre le nombre de cycles ex√©cut√©s dans <code>CreateLand</code> .  S'il y a trop d'it√©rations, alors nous sommes tr√®s probablement bloqu√©s et devons arr√™ter. <br><br>  Pour une grande carte, mille it√©rations semblent acceptables et dix mille it√©rations semblent d√©j√† absurdes.  Utilisons donc cette valeur comme point de terminaison. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-comment"><span class="hljs-comment">// while (landBudget &gt; 0) { for (int guard = 0; landBudget &gt; 0 &amp;&amp; guard &lt; 10000; guard++) { int chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - 1); ‚Ä¶ } }</span></span></code> </pre> <br>  Si nous obtenons une carte endommag√©e, alors 10 000 it√©rations ne prendront pas beaucoup de temps, car de nombreuses cellules atteindront rapidement la hauteur maximale, ce qui emp√™chera la croissance de nouvelles zones. <br><br>  M√™me apr√®s avoir rompu la boucle, nous obtenons toujours la bonne carte.  Il n'a tout simplement pas la bonne quantit√© de terrain et il ne sera pas tr√®s int√©ressant.  Affichez une notification √† ce sujet dans la console, nous faisant savoir quel terrain restant nous n'avons pas d√©pens√©. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab5/87f/f4f/ab587ff4f560fe6c1c0d7d5a547ae2b7.jpg"></div><br>  <i>95% des terrains avec une bordure de carte de 10 n'ont pas pu d√©penser la totalit√© du montant.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Pourquoi une carte d√©faillante a-t-elle encore des variantes?</b> <div class="spoiler_text">  Le littoral pr√©sente une variabilit√©, car lorsque les hauteurs √† l'int√©rieur de la zone de cr√©ation deviennent trop √©lev√©es, de nouvelles zones ne leur permettent pas de cro√Ætre vers l'ext√©rieur.  Le m√™me principe ne permet pas aux parcelles de se d√©velopper sur de petites surfaces jusqu'√† ce qu'elles atteignent la hauteur maximale et se r√©v√®lent simplement manquantes.  De plus, la variabilit√© augmente lors de l'abaissement des parcelles. </div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">paquet d'unit√©</a> <br><br><h2>  Partitionner une carte </h2><br>  Maintenant que nous avons la bordure de la carte, nous avons essentiellement divis√© la carte en deux r√©gions distinctes: la r√©gion de la fronti√®re et la r√©gion o√π les trac√©s ont √©t√© cr√©√©s.  √âtant donn√© que seule la r√©gion de cr√©ation est importante pour nous, nous pouvons consid√©rer un tel cas comme une situation avec une seule r√©gion.  La r√©gion ne couvre tout simplement pas la totalit√© de la carte.  Mais si cela est impossible, rien ne nous emp√™che de diviser la carte en plusieurs r√©gions non li√©es de la cr√©ation de terres.  Cela permettra aux masses terrestres de se former ind√©pendamment les unes des autres, d√©signant diff√©rents continents. <br><br><h3>  R√©gion de la carte </h3><br>  Commen√ßons par d√©crire une r√©gion de la carte comme une structure.  Cela simplifiera notre travail avec plusieurs r√©gions.  Cr√©ons une structure <code>MapRegion</code> pour cela, qui contient simplement les champs de bordure de la r√©gion.  Puisque nous n'utiliserons pas cette structure en dehors de <code>HexMapGenerator</code> , nous pouvons la d√©finir √† l'int√©rieur de cette classe comme une structure interne priv√©e.  Ensuite, quatre champs entiers peuvent √™tre remplac√©s par un champ <code>MapRegion</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// int xMin, xMax, zMin, zMax; struct MapRegion { public int xMin, xMax, zMin, zMax; } MapRegion region;</span></span></code> </pre> <br>  Pour que tout fonctionne, nous devons ajouter le pr√©fixe de <code>region.</code> aux champs minimum-maximum dans <code>GenerateMap</code> <code>region.</code>  . <br><br><pre> <code class="cs hljs"> region.xMin = mapBorderX; region.xMax = x - mapBorderX; region.zMin = mapBorderZ; region.zMax = z - mapBorderZ;</code> </pre> <br>  Et aussi dans <code>GetRandomCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell( Random.Range(region.xMin, region.xMax), Random.Range(region.zMin, region.zMax) ); }</code> </pre> <br><h3>  Plusieurs r√©gions </h3><br>  Pour prendre en charge plusieurs r√©gions, remplacez un champ <code>MapRegion</code> liste de r√©gions. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// MapRegion region; List&lt;MapRegion&gt; regions;</span></span></code> </pre> <br>  √Ä ce stade, il serait int√©ressant d'ajouter une m√©thode distincte pour cr√©er des r√©gions.  Il doit cr√©er la liste souhait√©e ou l'effacer si elle existe d√©j√†.  Apr√®s cela, il d√©terminera une r√©gion, comme nous l'avons fait auparavant, et l'ajoutera √† la liste. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRegions</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regions == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { regions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;MapRegion&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { regions.Clear(); } MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); }</code> </pre> <br>  Nous appellerons cette m√©thode dans <code>GenerateMap</code> et nous ne cr√©erons pas la r√©gion directement. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// region.xMin = mapBorderX; // region.xMax = x - mapBorderX; // region.zMin = mapBorderZ; // region.zMax = z - mapBorderZ; CreateRegions(); CreateLand();</span></span></code> </pre> <br>  Pour que <code>GetRandomCell</code> puisse fonctionner avec une r√©gion arbitraire, donnez-lui le param√®tre <code>MapRegion</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MapRegion region</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell( Random.Range(region.xMin, region.xMax), Random.Range(region.zMin, region.zMax) ); }</code> </pre> <br>  Maintenant, les <code>SinkTerrain</code> <code>RaiseTerraion</code> et <code>SinkTerrain</code> doivent passer la r√©gion correspondante √† <code>GetRandomCell</code> .  Pour ce faire, chacun d'eux a √©galement besoin d'un param√®tre de r√©gion. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget, MapRegion region</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell firstCell = GetRandomCell(region); ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SinkTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget, MapRegion region</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell firstCell = GetRandomCell(region); ‚Ä¶ }</code> </pre> <br>  La m√©thode <code>CreateLand</code> doit d√©terminer pour chaque r√©gion d'augmenter ou de diminuer les sections.  Pour √©quilibrer les terres entre les r√©gions, nous allons simplement parcourir √† plusieurs reprises la liste des r√©gions du cycle. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; regions.Count; i++) { MapRegion region = regions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability) { landBudget = SinkTerrain(chunkSize, landBudget, region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { landBudget = RaiseTerrain(chunkSize, landBudget, region); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); } }</code> </pre> <br>  Cependant, nous devons encore faire la baisse des parcelles uniform√©ment r√©parties.  Cela peut √™tre fait en d√©cidant pour toutes les r√©gions s'il faut les omettre. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> sink = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; regions.Count; i++) { MapRegion region = regions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// if (Random.value &lt; sinkProbability) { if (sink) { landBudget = SinkTerrain(chunkSize, landBudget, region); } else { landBudget = RaiseTerrain(chunkSize, landBudget, region); } } }</span></span></code> </pre> <br>  Enfin, afin d'utiliser exactement la totalit√© du terrain, nous devons arr√™ter le processus d√®s que le montant atteint z√©ro.  Cela peut se produire √† n'importe quelle √©tape du cycle de la r√©gion.  Par cons√©quent, nous d√©pla√ßons la v√©rification √† somme nulle dans la boucle int√©rieure.  En fait, nous ne pouvons effectuer ce contr√¥le qu'apr√®s avoir soulev√© un terrain, car lors de l'abaissement, le montant n'est jamais d√©pens√©.  Si nous avons termin√©, nous pouvons imm√©diatement quitter la m√©thode <code>CreateLand</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// for (int guard = 0; landBudget &gt; 0 &amp;&amp; guard &lt; 10000; guard++) { for (int guard = 0; guard &lt; 10000; guard++) { bool sink = Random.value &lt; sinkProbability; for (int i = 0; i &lt; regions.Count; i++) { MapRegion region = regions[i]; int chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - 1); if (sink) { landBudget = SinkTerrain(chunkSize, landBudget, region); } else { landBudget = RaiseTerrain(chunkSize, landBudget, region); if (landBudget == 0) { return; } } } }</span></span></code> </pre> <br><h3>  Deux r√©gions </h3><br>  Bien que nous ayons d√©sormais le soutien de plusieurs r√©gions, nous n'en demandons toujours qu'une.  <code>CreateRegions</code> les <code>CreateRegions</code> pour qu'il divise la carte en deux verticalement.  Pour ce faire, nous <code>xMax</code> deux la valeur <code>xMax</code> de la r√©gion ajout√©e.  Ensuite, nous utilisons la m√™me valeur pour <code>xMin</code> et utilisons √† nouveau la valeur d'origine pour <code>xMax</code> , en l'utilisant comme deuxi√®me r√©gion. <br><br><pre> <code class="cs hljs"> MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region);</code> </pre> <br>  G√©n√©rer des cartes √† ce stade ne fera aucune diff√©rence.  Bien que nous ayons identifi√© deux r√©gions, elles occupent la m√™me r√©gion qu'une ancienne r√©gion.  Pour les s√©parer, vous devez laisser un espace vide entre eux.  Cela peut √™tre fait en ajoutant un curseur √† la fronti√®re de la r√©gion, en utilisant le m√™me intervalle et la m√™me valeur par d√©faut que pour les fronti√®res de la carte. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> regionBorder = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/cd2/cd0/9ffcd2cd0f4068caf622e433c503715d.png"></div><br>  <i>Curseur de bordure de r√©gion.</i> <br><br>  Comme le terrain peut se former de chaque c√¥t√© de l'espace entre les r√©gions, la probabilit√© de cr√©er des ponts terrestres aux bords de la carte augmentera.  Pour √©viter cela, nous utilisons la fronti√®re de la r√©gion pour d√©finir une zone sans terre entre la ligne de division et la r√©gion dans laquelle les parcelles peuvent commencer.  Cela signifie que la distance entre les r√©gions voisines est deux fois sup√©rieure √† la taille de la fronti√®re de la r√©gion. <br><br>  Pour appliquer cette limite de r√©gion, soustrayez-la du <code>xMax</code> premi√®re r√©gion et ajoutez la deuxi√®me r√©gion √† <code>xMin</code> . <br><br><pre> <code class="cs hljs"> MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e5/1f6/476/1e51f6476894662d55f7ca9748dc7fa5.jpg"></div><br>  <i>La carte est divis√©e verticalement en deux r√©gions.</i> <br><br>  Avec les param√®tres par d√©faut, deux r√©gions sensiblement s√©par√©es seront cr√©√©es, cependant, comme dans le cas d'une r√©gion et d'une grande bordure de carte, nous ne sommes pas garantis de recevoir exactement deux masses terrestres.  Le plus souvent ce sera deux grands continents, √©ventuellement avec plusieurs √Æles.  Mais parfois, deux ou plusieurs grandes √Æles peuvent √™tre cr√©√©es dans une r√©gion.  Et parfois, deux continents peuvent √™tre reli√©s par un isthme. <br><br>  Bien s√ªr, nous pouvons √©galement diviser la carte horizontalement, en changeant les approches pour mesurer X et Z. Choisissons au hasard l'une des deux orientations possibles. <br><br><pre> <code class="cs hljs"> MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f23/970/c91/f23970c91cdd9c539ebdc8c7fdbba05f.jpg"></div><br>  <i>Carte horizontalement divis√©e en deux r√©gions.</i> <br><br>  Puisque nous utilisons une carte large, des r√©gions plus larges et plus minces seront cr√©√©es avec une s√©paration horizontale.  En cons√©quence, ces r√©gions sont plus susceptibles de former plusieurs masses terrestres divis√©es. <br><br><h3>  Quatre r√©gions </h3><br>  Rendons le nombre de r√©gions personnalisable, cr√©ons un support de 1 √† 4 r√©gions. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(1, 4)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> regionCount = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/918/49e/2a4/91849e2a4ffe6091b8d4fdf0d78b0c45.png"></div><br>  <i>Curseur pour le nombre de r√©gions.</i> <br><br>  Nous pouvons utiliser l' <code>switch</code> pour s√©lectionner l'ex√©cution du code de r√©gion correspondant.  Nous commen√ßons par r√©p√©ter le code d'une r√©gion, qui sera utilis√© par d√©faut, et laissons le code de deux r√©gions pour le cas 2. <br><br><pre> <code class="cs hljs"> MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce que l'instruction switch?</b> <div class="spoiler_text">  Il s'agit d'une alternative √† l'√©criture d'une s√©quence d'instructions if-else-if-else.  est appliqu√© √† la variable et des √©tiquettes sont utilis√©es pour indiquer quel code doit √™tre ex√©cut√©.  Il existe √©galement une √©tiquette <code>default</code> , qui est utilis√©e comme dernier bloc <code>else</code> .  Chaque option doit se terminer par une instruction <code>break</code> ou une <code>return</code> . <br><br>  Pour garder le bloc <code>switch</code> lisible, il est g√©n√©ralement pr√©f√©rable de garder tous les cas courts, id√©alement avec une seule instruction ou un appel de m√©thode.  Je ne ferai pas cela comme un exemple de code de r√©gion, mais si vous voulez cr√©er des r√©gions plus int√©ressantes, je vous recommande d'utiliser des m√©thodes distinctes.  Par exemple: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: CreateOneRegion(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: CreateTwoRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: CreateThreeRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: CreateFourRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> </div></div><br>  Trois r√©gions sont similaires √† deux, seuls les tiers sont utilis√©s au lieu de la moiti√©.  Dans ce cas, la division horizontale cr√©era des r√©gions trop √©troites, nous avons donc cr√©√© un support uniquement pour la division verticale.  Notez qu'en cons√©quence, nous avons doubl√© la zone frontali√®re de la r√©gion, de sorte que l'espace pour cr√©er de nouvelles sections est inf√©rieur √† celui de deux r√©gions. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">3</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">3</span></span> + regionBorder; region.xMax = grid.cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> - regionBorder; regions.Add(region); region.xMin = grid.cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/234/2e7/cc8/2342e7cc8cb524f4f9db803d5359a78e.jpg"></div><br>  <i>Trois r√©gions.</i> <br><br>  Quatre r√©gions peuvent √™tre cr√©√©es en combinant la s√©paration horizontale et verticale et en ajoutant une r√©gion √† chaque coin de la carte. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/551/b72/a0c/551b72a0ca2f12a5636828faa4c3febc.jpg"></div><br>  <i>Quatre r√©gions.</i> <br><br>  L'approche utilis√©e ici est le moyen le plus simple de diviser une carte.  Il g√©n√®re approximativement les m√™mes r√©gions en masse de terres, et leur variabilit√© est contr√¥l√©e par d'autres param√®tres de g√©n√©ration de cartes.  Cependant, il sera toujours assez √©vident que la carte a √©t√© divis√©e en lignes droites.  Plus nous avons besoin de contr√¥le, moins le r√©sultat sera organique.  Par cons√©quent, c'est normal si vous avez besoin de r√©gions √† peu pr√®s √©gales pour le gameplay.  Mais si vous avez besoin du terrain le plus vari√© et le plus illimit√©, vous devrez le faire avec l'aide d'une seule r√©gion. <br><br>  De plus, il existe d'autres fa√ßons de diviser la carte.  Nous ne pouvons pas nous limiter uniquement aux lignes droites.  Nous n'avons m√™me pas besoin d'utiliser des r√©gions de la m√™me taille, ni de couvrir la carte enti√®re avec elles.  Nous pouvons laisser des trous.  Vous pouvez √©galement autoriser les intersections de r√©gions ou modifier la r√©partition des terres entre les r√©gions.  Vous pouvez m√™me d√©finir vos propres param√®tres de g√©n√©rateur pour chaque r√©gion (bien que cela soit plus compliqu√©), par exemple, pour avoir un grand continent et un archipel sur la carte. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">paquet d'unit√©</a> <br><br><h2>  L'√©rosion </h2><br>  Jusqu'√† pr√©sent, toutes les cartes que nous avons g√©n√©r√©es semblaient plut√¥t grossi√®res et cass√©es.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un vrai relief peut ressembler √† ceci, mais avec le temps, il devient de plus en plus lisse, ses parties ac√©r√©es deviennent ternes √† cause de l'√©rosion. </font><font style="vertical-align: inherit;">Pour am√©liorer les cartes, nous pouvons appliquer ce processus d'√©rosion. </font><font style="vertical-align: inherit;">Nous le ferons apr√®s avoir cr√©√© un terrain accident√©, selon une m√©thode distincte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ CreateRegions(); CreateLand(); ErodeLand(); SetTerrainType(); ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {}</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pourcentage d'√©rosion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus le temps passe, plus l'√©rosion appara√Æt. </font><font style="vertical-align: inherit;">Par cons√©quent, nous voulons que l'√©rosion ne soit pas permanente, mais personnalisable. </font><font style="vertical-align: inherit;">Au minimum, l'√©rosion est nulle, ce qui correspond aux cartes cr√©√©es pr√©c√©demment. </font><font style="vertical-align: inherit;">Au maximum, l'√©rosion est compl√®te, c'est-√†-dire que la poursuite de l'application des forces d'√©rosion ne changera plus le terrain. </font><font style="vertical-align: inherit;">Autrement dit, le param√®tre d'√©rosion doit √™tre un pourcentage de 0 √† 100, et par d√©faut, nous prendrons 50.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 100)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erosionPercentage = <span class="hljs-number"><span class="hljs-number">50</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/efe/e5e/c4eefee5e18aeee36f16e6aee98a27fe.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curseur d'√©rosion.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recherche de cellules destructrices d'√©rosion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'√©rosion rend le relief plus lisse. Dans notre cas, les seules parties ac√©r√©es sont les falaises. Ils seront donc la cible du processus d'√©rosion. Si une falaise existe, l'√©rosion devrait la r√©duire jusqu'√† ce qu'elle se transforme finalement en pente. Nous ne lisserons pas les pentes, car cela conduira √† un terrain ennuyeux. Pour ce faire, nous devons d√©terminer quelles cellules se trouvent au sommet des falaises et abaisser leur hauteur. Ce seront des cellules sujettes √† l'√©rosion.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ons une m√©thode qui d√©termine si une cellule peut √™tre sujette √† l'√©rosion. </font><font style="vertical-align: inherit;">Il le d√©termine en v√©rifiant les voisins de la cellule jusqu'√† ce qu'il trouve une diff√©rence de hauteur suffisamment grande. </font><font style="vertical-align: inherit;">√âtant donn√© que les falaises n√©cessitent une diff√©rence d'au moins un ou deux niveaux de hauteur, la cellule est sujette √† l'√©rosion si un ou plusieurs de ses voisins se trouvent √† au moins deux marches en dessous. </font><font style="vertical-align: inherit;">S'il n'y a pas un tel voisin, alors la cellule ne peut pas subir d'√©rosion.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsErodible</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erodibleElevation = cell.Elevation - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.Elevation &lt;= erodibleElevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons utiliser cette m√©thode </font></font><code>ErodeLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour parcourir toutes les cellules et √©crire toutes les cellules sujettes √† l'√©rosion dans une liste temporaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; erodibleCells = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsErodible(cell)) { erodibleCells.Add(cell); } } ListPool&lt;HexCell&gt;.Add(erodibleCells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une fois que nous connaissons le nombre total de cellules sujettes √† l'√©rosion, nous pouvons utiliser le pourcentage d'√©rosion pour d√©terminer le nombre de cellules sujettes √† l'√©rosion restantes. </font><font style="vertical-align: inherit;">Par exemple, si le pourcentage est de 50, alors nous devons √©rosion des cellules jusqu'√† ce que la moiti√© de la quantit√© d'origine reste. </font><font style="vertical-align: inherit;">Si le pourcentage est de 100, nous ne nous arr√™terons pas tant que nous n'aurons pas d√©truit toutes les cellules sujettes √† l'√©rosion.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; erodibleCells = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetErodibleCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(erodibleCells.Count * (<span class="hljs-number"><span class="hljs-number">100</span></span> - erosionPercentage) * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); ListPool&lt;HexCell&gt;.Add(erodibleCells); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne devrions-nous pas consid√©rer uniquement les cellules sujettes √† l'√©rosion des terres?</font></font></b> <div class="spoiler_text">     .    ,       ,     . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©duction cellulaire </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commen√ßons par une approche na√Øve et supposons qu'une simple r√©duction de la hauteur des cellules d√©truites par l'√©rosion ne la rendra plus sujette √† l'√©rosion. </font><font style="vertical-align: inherit;">Si cela √©tait vrai, nous pourrions simplement prendre des cellules al√©atoires dans la liste, r√©duire leur hauteur, puis les supprimer de la liste. </font><font style="vertical-align: inherit;">Nous r√©p√©terions cette op√©ration jusqu'√† ce que nous atteignions le nombre souhait√© de cellules sensibles √† l'√©rosion.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetErodibleCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(erodibleCells.Count * (<span class="hljs-number"><span class="hljs-number">100</span></span> - erosionPercentage) * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (erodibleCells.Count &gt; targetErodibleCount) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, erodibleCells.Count); HexCell cell = erodibleCells[index]; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; erodibleCells.Remove(cell); } ListPool&lt;HexCell&gt;.Add(erodibleCells);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour emp√™cher la recherche requise </font></font><code>erodibleCells.Remove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous remplacerons la cellule actuelle en dernier dans la liste, puis supprimerons le dernier √©l√©ment. </font><font style="vertical-align: inherit;">Nous ne nous soucions toujours pas de leur commande.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// erodibleCells.Remove(cell); erodibleCells[index] = erodibleCells[erodibleCells.Count - 1]; erodibleCells.RemoveAt(erodibleCells.Count - 1);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50e/050/66c/50e05066c444e6854c622b865fde2726.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14d/fca/6b4/14dfca6b41ce23cdeb3e5fc4d5307eba.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diminution na√Øve de 0% et 100% des cellules sujettes √† l'√©rosion, carte des graines 1957632474.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suivi de l'√©rosion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre approche na√Øve nous permet d'appliquer l'√©rosion, mais pas au bon degr√©. </font><font style="vertical-align: inherit;">Cela se produit car la cellule apr√®s une diminution de hauteur peut toujours rester sujette √† l'√©rosion. </font><font style="vertical-align: inherit;">Par cons√©quent, nous ne supprimerons une cellule de la liste que lorsqu'elle ne sera plus soumise √† l'√©rosion.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/281/0a9/779/2810a9779b056865ad4490f9b00fa50f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% d'√©rosion tout en conservant les cellules sujettes √† l'√©rosion dans la liste. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous obtenons donc une √©rosion beaucoup plus forte, mais lorsque nous utilisons 100%, nous ne nous d√©barrassons toujours pas de toutes les falaises. </font><font style="vertical-align: inherit;">La raison en est qu'apr√®s avoir r√©duit la hauteur de la cellule, l'un de ses voisins peut devenir sujet √† l'√©rosion. </font><font style="vertical-align: inherit;">Par cons√©quent, par cons√©quent, nous pourrions avoir plus de cellules sujettes √† l'√©rosion qu'elles ne l'√©taient √† l'origine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir abaiss√© la cellule, nous devons v√©rifier tous ses voisins. </font><font style="vertical-align: inherit;">Si maintenant ils sont sujets √† l'√©rosion, mais qu'ils ne sont pas encore sur la liste, vous devez les ajouter l√†-bas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; IsErodible(neighbor) &amp;&amp; !erodibleCells.Contains(neighbor) ) { erodibleCells.Add(neighbor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/894/ed5/b2a894ed5274286b00046050963388f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toutes les cellules √©rod√©es sont omises.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous √©conomisons beaucoup de terrain </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, le processus d'√©rosion peut continuer jusqu'√† ce que toutes les falaises disparaissent. Cela affecte grandement la terre. La majeure partie de la masse terrestre a disparu et nous avons obtenu beaucoup moins que le pourcentage de terres n√©cessaires. Cela s'est produit parce que nous supprimons des terres de la carte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La v√©ritable √©rosion ne d√©truit pas la mati√®re. Elle le prend d'un endroit et le place ailleurs. Nous pouvons faire de m√™me. Avec une diminution d'une cellule, nous devons √©lever l'un de ses voisins. En fait, un niveau de hauteur est transf√©r√© dans une cellule inf√©rieure. Cela enregistre la quantit√© totale de hauteurs de carte, tout en la lissant simplement.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour r√©aliser cela, nous devons d√©cider o√π transf√©rer les produits d'√©rosion. </font><font style="vertical-align: inherit;">Ce sera notre objectif d'√©rosion. </font><font style="vertical-align: inherit;">Cr√©ons une m√©thode pour d√©terminer le point cible d'une cellule √† √©roder. </font><font style="vertical-align: inherit;">√âtant donn√© que cette cellule contient une interruption, il serait logique de s√©lectionner la cellule situ√©e sous cette interruption comme cible. </font><font style="vertical-align: inherit;">Mais une cellule sujette √† l'√©rosion peut avoir plusieurs ruptures, nous allons donc v√©rifier tous les voisins et mettre tous les candidats sur une liste temporaire, puis nous choisirons l'un d'eux au hasard.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetErosionTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; candidates = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erodibleElevation = cell.Elevation - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.Elevation &lt;= erodibleElevation) { candidates.Add(neighbor); } } HexCell target = candidates[Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, candidates.Count)]; ListPool&lt;HexCell&gt;.Add(candidates); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans </font></font><code>ErodeLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous d√©finissons la cellule cible imm√©diatement apr√®s avoir s√©lectionn√© la cellule d'√©rosion. </font><font style="vertical-align: inherit;">Ensuite, nous diminuons et augmentons imm√©diatement la hauteur des cellules. </font><font style="vertical-align: inherit;">Dans ce cas, la cellule cible elle-m√™me peut devenir sensible √† l'√©rosion, mais cette situation est r√©solue lorsque nous v√©rifions les voisins de la cellule nouvellement √©rod√©e.</font></font><br><br><pre> <code class="cs hljs"> HexCell cell = erodibleCells[index]; HexCell targetCell = GetErosionTarget(cell); cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; targetCell.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depuis que nous avons √©lev√© la cellule cible, une partie des voisins de cette cellule peut ne plus √™tre soumise √† l'√©rosion. </font><font style="vertical-align: inherit;">Il faut les contourner et v√©rifier s'ils sont sujets √† l'√©rosion. </font><font style="vertical-align: inherit;">Sinon, mais ils sont dans la liste, vous devez les supprimer.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; !IsErodible(neighbor) &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d71/84f/0b4/d7184f0b4a2dd34853b56e0024ef2b6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% d'√©rosion tout en maintenant la masse terrestre. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'√©rosion peut maintenant lisser le terrain beaucoup mieux, en abaissant certaines zones et en soulevant d'autres. </font><font style="vertical-align: inherit;">En cons√©quence, la masse de terre peut √† la fois augmenter et r√©tr√©cir. </font><font style="vertical-align: inherit;">Cela peut modifier le pourcentage de terres de plusieurs pour cent dans un sens ou dans un autre, mais de graves √©carts se produisent rarement. </font><font style="vertical-align: inherit;">Autrement dit, plus nous appliquons d'√©rosion, moins nous aurons de contr√¥le sur le pourcentage de terres qui en r√©sulte.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ârosion acc√©l√©r√©e </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous n'ayons pas vraiment besoin de nous soucier de l'efficacit√© de l'algorithme d'√©rosion, nous pouvons y apporter des am√©liorations simples. </font><font style="vertical-align: inherit;">Tout d'abord, notez que nous v√©rifions explicitement si la cellule que nous avons √©rod√©e peut √™tre √©rod√©e. </font><font style="vertical-align: inherit;">Sinon, nous le supprimons essentiellement de la liste. </font><font style="vertical-align: inherit;">Par cons√©quent, vous pouvez ignorer la v√©rification de cette cellule lors de la travers√©e des voisins de la cellule cible.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor != cell &amp;&amp; !IsErodible(neighbor) &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxi√®mement, nous devions v√©rifier les voisins de la cellule cible uniquement lorsqu'il y avait une rupture entre eux, mais maintenant ce n'est plus n√©cessaire. </font><font style="vertical-align: inherit;">Cela ne se produit que lorsque le voisin est maintenant un cran plus haut que la cellule cible. </font><font style="vertical-align: inherit;">Si c'est le cas, le voisin est garanti d'√™tre sur la liste, nous n'avons donc pas besoin de v√©rifier cela, c'est-√†-dire que nous pouvons ignorer la recherche inutile.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor != cell &amp;&amp; neighbor.Elevation == targetCell.Elevation + <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !IsErodible(neighbor) <span class="hljs-comment"><span class="hljs-comment">// &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Troisi√®mement, nous pouvons utiliser une astuce similaire lors de la v√©rification des voisins d'une cellule sujette √† l'√©rosion. </font><font style="vertical-align: inherit;">S'il y a maintenant une falaise entre eux, alors le voisin est sujet √† l'√©rosion. </font><font style="vertical-align: inherit;">Pour le savoir, nous n'avons pas besoin d'appeler </font></font><code>IsErodible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor.Elevation == cell.Elevation + <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">// IsErodible(neighbor) &amp;&amp; !erodibleCells.Contains(neighbor) ) { erodibleCells.Add(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, nous devons encore v√©rifier si la cellule cible est sensible √† l'√©rosion, mais le cycle illustr√© ci-dessus ne le fait plus. </font><font style="vertical-align: inherit;">Par cons√©quent, nous effectuons cela explicitement pour la cellule cible.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsErodible(targetCell) &amp;&amp; !erodibleCells.Contains(targetCell)) { erodibleCells.Add(targetCell); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons appliquer l'√©rosion assez rapidement et au pourcentage souhait√© par rapport au nombre initial de falaises g√©n√©r√©es. </font><font style="vertical-align: inherit;">Notez que du fait que nous avons l√©g√®rement chang√© l'endroit o√π la cellule cible est ajout√©e √† la liste sujette √† l'√©rosion, le r√©sultat a l√©g√®rement chang√© par rapport au r√©sultat avant optimisations.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a6/a0d/71e/4a6a0d71eea3d1ef119b2f4f984a9b99.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28d/979/289/28d9792899367fdccb50f36b79801935.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7af/921/6af/7af9216af64111dbe0c15898db4560ce.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31b/7d9/ae5/31b7d9ae505297269bbd5442fdff17c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25%, 50%, 75% et 100% d'√©rosion. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez √©galement que malgr√© la forme modifi√©e de la c√¥te, la topologie n'a pas fondamentalement chang√©. </font><font style="vertical-align: inherit;">Les masses terrestres restent g√©n√©ralement connect√©es ou s√©par√©es. </font><font style="vertical-align: inherit;">Seules les petites √Æles peuvent se noyer compl√®tement. </font><font style="vertical-align: inherit;">Les d√©tails en relief sont liss√©s, mais les formes g√©n√©rales restent les m√™mes. </font><font style="vertical-align: inherit;">Une articulation √©troite peut dispara√Ætre ou grossir un peu. </font><font style="vertical-align: inherit;">Un petit espace peut se remplir ou se dilater l√©g√®rement. </font><font style="vertical-align: inherit;">Par cons√©quent, l'√©rosion ne collera pas fortement les r√©gions divis√©es.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cd/c53/824/2cdc53824832438c924e2832d9759b06.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quatre r√©gions compl√®tement √©rod√©es restent s√©par√©es. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 25: Le cycle de l'eau </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Affichez les donn√©es cartographiques brutes. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous formons un climat de cellules. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©ez une simulation partielle du cycle de l'eau. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette partie, nous ajouterons de l'humidit√© sur terre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce didacticiel a √©t√© cr√©√© dans Unity 2017.3.0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ae/fbe/dae/2aefbedae7b2c65cd86bbd2b4ccc3050.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons le cycle de l'eau pour d√©terminer les biomes.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les nuages </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, l'algorithme de g√©n√©ration de carte ne modifiait que la hauteur des cellules. </font><font style="vertical-align: inherit;">La plus grande diff√©rence entre les cellules √©tait de savoir si elles √©taient au-dessus ou au-dessous de l'eau. </font><font style="vertical-align: inherit;">Bien que nous puissions d√©finir diff√©rents types de terrain, ce n'est qu'une simple visualisation de la hauteur. </font><font style="vertical-align: inherit;">Il sera pr√©f√©rable de pr√©ciser les types de relief, compte tenu du climat local. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le climat de la Terre est un syst√®me tr√®s complexe. </font><font style="vertical-align: inherit;">Heureusement, nous n'avons pas besoin de cr√©er des simulations climatiques r√©alistes. </font><font style="vertical-align: inherit;">Nous aurons besoin de quelque chose d'assez naturel. </font><font style="vertical-align: inherit;">L'aspect le plus important du climat est le cycle de l'eau, car la flore et la faune ont besoin d'eau liquide pour survivre. </font><font style="vertical-align: inherit;">La temp√©rature est √©galement tr√®s importante, mais pour l'instant, nous nous concentrons sur l'eau, laissant essentiellement la temp√©rature globale constante et ne modifiant que l'humidit√©.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le cycle de l'eau d√©crit le mouvement de l'eau dans l'environnement. </font><font style="vertical-align: inherit;">Autrement dit, les √©tangs s'√©vaporent, ce qui conduit √† la cr√©ation de nuages ‚Äã‚Äãqui pleuvent, qui se jettent √† nouveau dans les √©tangs. </font><font style="vertical-align: inherit;">Le syst√®me comporte de nombreux autres aspects, mais la simulation de ces √©tapes peut d√©j√† √™tre suffisante pour cr√©er une distribution naturelle de l'eau sur la carte.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualisation des donn√©es </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant d'entrer dans cette simulation, il sera utile de voir directement les donn√©es pertinentes. </font><font style="vertical-align: inherit;">Pour ce faire, nous allons changer le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nous lui ajoutons une propri√©t√© commutable, qui peut √™tre commut√©e en mode de visualisation des donn√©es, qui affiche des donn√©es cartographiques brutes au lieu des textures de relief habituelles. </font><font style="vertical-align: inherit;">Cela peut √™tre impl√©ment√© √† l'aide d'une propri√©t√© float avec un attribut commutable qui d√©finit le mot-cl√©. </font><font style="vertical-align: inherit;">Pour cette raison, il appara√Ætra dans l'inspecteur des mat√©riaux comme un indicateur qui contr√¥le la d√©finition d'un mot-cl√©. </font><font style="vertical-align: inherit;">Le nom du bien lui-m√™me n'a pas d'importance, nous ne nous int√©ressons qu'au mot-cl√©. </font><font style="vertical-align: inherit;">Nous utilisons </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHOW_MAP_DATA</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) _BackgroundColor (<span class="hljs-string"><span class="hljs-string">"Background Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) [Toggle(SHOW_MAP_DATA)] _ShowMapData (<span class="hljs-string"><span class="hljs-string">"Show Map Data"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/32b/3e0/45232b3e0a72da1320457492c006613c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basculez pour afficher les donn√©es cartographiques. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez une fonction de shader pour activer la prise en charge des mots cl√©s.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ GRID_ON #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ HEX_MAP_EDIT_MODE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> shader_feature SHOW_MAP_DATA</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons lui faire afficher un seul flottant, comme c'est le cas avec le reste des donn√©es de relief. </font><font style="vertical-align: inherit;">Pour l'impl√©menter, nous ajouterons un </font></font><code>Input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">champ </font><font style="vertical-align: inherit;">√† la structure </font></font><code>mapData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsque le mot cl√© sera d√©fini.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">struct</span></span> Input { <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> color : COLOR; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> worldPos; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> terrain; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> visibility; <span class="hljs-comment"><span class="hljs-comment">#if defined(SHOW_MAP_DATA) float mapData; #endif };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le programme vertex, nous utilisons le canal Z de ces cellules pour remplir </font></font><code>mapData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, comme toujours interpol√© entre les cellules.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inout appdata_full v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Input data</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(SHOW_MAP_DATA) data.mapData = cell0.z * v.color.x + cell1.z * v.color.y + cell2.z * v.color.z; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous devez afficher des donn√©es de cellule, utilisez-les directement comme fragment d'alb√©do au lieu de la couleur habituelle. </font><font style="vertical-align: inherit;">Multipliez-le par la grille afin que la grille soit toujours activ√©e lors du rendu des donn√©es.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { ‚Ä¶ o.Albedo = c.rgb * grid * _Color * explored; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(SHOW_MAP_DATA) o.Albedo = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.mapData * grid; #endif ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour transf√©rer r√©ellement des donn√©es vers un shader. </font><font style="vertical-align: inherit;">nous devons ajouter √† la </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode qui √©crit quelque chose sur le canal de donn√©es de texture bleue. </font><font style="vertical-align: inherit;">Les donn√©es sont une valeur flottante unique limit√©e √† 0‚Äì1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMapData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].b = data &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (data &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(data * <span class="hljs-number"><span class="hljs-number">255f</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span>); enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, cette d√©cision affecte le syst√®me de recherche. </font><font style="vertical-align: inherit;">Une valeur de donn√©es de canal bleu 255 est utilis√©e pour indiquer que la visibilit√© des cellules est en transition. </font><font style="vertical-align: inherit;">Pour que ce syst√®me continue de fonctionner, nous devons utiliser au maximum la valeur d'octet 254. Notez que le mouvement du d√©tachement effacera toutes les donn√©es de la carte, mais cela nous convient, car elles sont utilis√©es pour d√©boguer la g√©n√©ration de cartes.</font></font><br><br><pre> <code class="cs hljs"> cellTextureData[cell.Index].b = data &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (data &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(data * <span class="hljs-number"><span class="hljs-number">254f</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">254</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez une m√©thode avec le m√™me nom et dans </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il transf√©rera la demande dans ses donn√©es de shader.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMapData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { ShaderData.SetMapData(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour v√©rifier le fonctionnement du code, nous le modifions </font></font><code>HexMapGenerator.SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin qu'il d√©finit les donn√©es de chaque cellule de la carte. </font><font style="vertical-align: inherit;">Visualisons la hauteur convertie de l'entier en flottant dans l'intervalle 0‚Äì1. </font><font style="vertical-align: inherit;">Cela se fait en soustrayant la hauteur minimale de la hauteur de la cellule, puis en divisant par la hauteur maximale moins le minimum. </font><font style="vertical-align: inherit;">Faisons la division en virgule flottante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ cell.SetMapData( (cell.Elevation - elevationMinimum) / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(elevationMaximum - elevationMinimum) ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant basculer entre le terrain normal et la visualisation des donn√©es √† l'aide de la </font><font style="vertical-align: inherit;">case √† cocher </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afficher les donn√©es cartographiques</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de l'actif mat√©riel </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/577/473/f28/577473f28d08f986124e6459a13a3714.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/c8a/85a/d60c8a85ae315fd509a4f6451629d8dc.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carte 1208905299, terrain normal et visualisation des hauteurs.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©ation du climat </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour simuler le climat, nous devons suivre les donn√©es climatiques. </font><font style="vertical-align: inherit;">La carte √©tant constitu√©e de cellules discr√®tes, chacune d'elles a son propre climat local. </font><font style="vertical-align: inherit;">Cr√©ez une structure </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour stocker toutes les donn√©es pertinentes. </font><font style="vertical-align: inherit;">Bien s√ªr, vous pouvez ajouter des donn√©es aux cellules elles-m√™mes, mais nous ne les utiliserons que lors de la g√©n√©ration de la carte. </font><font style="vertical-align: inherit;">Par cons√©quent, nous les enregistrerons s√©par√©ment. </font><font style="vertical-align: inherit;">Cela signifie que nous pouvons d√©finir cette structure en interne </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, comme </font></font><code>MapRegion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous commencerons par suivre uniquement les nuages, qui peuvent √™tre impl√©ment√©s √† l'aide d'un seul champ flottant.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClimateData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clouds; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajoutez une liste pour suivre les donn√©es climatiques de toutes les cellules. </font></font><br><br><pre> <code class="cs hljs"> List&lt;ClimateData&gt; climate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous avons besoin d'une m√©thode pour cr√©er une carte climatique. </font><font style="vertical-align: inherit;">Il doit commencer par effacer la liste des zones climatiques, puis ajouter un √©l√©ment pour chaque cellule. </font><font style="vertical-align: inherit;">Les donn√©es climatiques initiales sont tout simplement nulles, cela peut √™tre r√©alis√© en utilisant un constructeur standard </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { climate.Clear(); ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le climat doit √™tre cr√©√© apr√®s une exposition √† l'√©rosion des terres avant de d√©finir les types de relief. </font><font style="vertical-align: inherit;">En r√©alit√©, l'√©rosion est principalement caus√©e par le mouvement de l'air et de l'eau, qui font partie du climat, mais nous ne simulerons pas cela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ CreateRegions(); CreateLand(); ErodeLand(); CreateClimate(); SetTerrainType(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin que nous puissions voir les donn√©es du nuage au lieu de la hauteur des cellules. </font><font style="vertical-align: inherit;">Initialement, il ressemblera √† une carte noire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ cell.SetMapData(climate[i].clouds); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Changement climatique </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La premi√®re √©tape de la simulation climatique est l'√©vaporation. </font><font style="vertical-align: inherit;">Quelle quantit√© d'eau devrait s'√©vaporer? </font><font style="vertical-align: inherit;">Contr√¥lons cette valeur √† l'aide du curseur. </font><font style="vertical-align: inherit;">Une valeur de 0 signifie aucune √©vaporation, 1 - √©vaporation maximale. </font><font style="vertical-align: inherit;">Par d√©faut, nous utilisons 0,5.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporation = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6af/d8e/ae8/6afd8eae8a1bbb6be361c29d32cc5b99.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curseur d'√©vaporation. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ons une autre m√©thode sp√©cifiquement pour fa√ßonner le climat d'une cellule. </font><font style="vertical-align: inherit;">Nous lui donnons l'indice de cellule comme param√®tre et nous l'utilisons pour obtenir la cellule correspondante et ses donn√©es climatiques. </font><font style="vertical-align: inherit;">Si la cellule est sous l'eau, il s'agit alors d'un r√©servoir qui doit s'√©vaporer. </font><font style="vertical-align: inherit;">Nous transformons imm√©diatement la vapeur en nuages ‚Äã‚Äã(en ignorant les points de ros√©e et la condensation), nous ajouterons donc directement l'√©vaporation √† la valeur des nuages ‚Äã‚Äãcellulaires. </font><font style="vertical-align: inherit;">Lorsque vous avez termin√©, copiez les donn√©es climatiques dans la liste.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EvolveClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cellIndex</span></span></span><span class="hljs-function">)</span></span> { HexCell cell = grid.GetCell(cellIndex); ClimateData cellClimate = climate[cellIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } climate[cellIndex] = cellClimate; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appelez cette m√©thode pour chaque cellule </font></font><code>CreateClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais cela ne suffit pas. </font><font style="vertical-align: inherit;">Pour cr√©er une simulation complexe, nous devons fa√ßonner le climat des cellules plusieurs fois. </font><font style="vertical-align: inherit;">Plus nous le faisons souvent, meilleur sera le r√©sultat. </font><font style="vertical-align: inherit;">Choisissons simplement une valeur constante. </font><font style="vertical-align: inherit;">J'utilise 40 cycles.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; cycle &lt; <span class="hljs-number"><span class="hljs-number">40</span></span>; cycle++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Depuis, alors que nous n'augmentons que la valeur des nuages ‚Äã‚Äãau-dessus des cellules inond√©es d'eau, nous obtenons ainsi des terres noires et des r√©servoirs blancs. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e7/e1c/5dc/3e7e1c5dc9ce75197a94e8ffcd6d8275.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evaporation sur l'eau.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diffusion des nuages </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les nuages ‚Äã‚Äãne sont pas constamment au m√™me endroit, surtout lorsque de plus en plus d'eau s'√©vapore. </font><font style="vertical-align: inherit;">La diff√©rence de pression fait bouger l'air, qui se manifeste sous forme de vent, ce qui fait aussi bouger les nuages. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S'il n'y a pas de direction dominante du vent, alors en moyenne les nuages ‚Äã‚Äãde cellules se disperseront uniform√©ment dans toutes les directions, apparaissant dans les cellules voisines. </font><font style="vertical-align: inherit;">Lors de la g√©n√©ration de nouveaux nuages ‚Äã‚Äãdans le cycle suivant, r√©partissons tous les nuages ‚Äã‚Äãde la cellule dans ses voisins. </font><font style="vertical-align: inherit;">Autrement dit, chaque voisin re√ßoit un sixi√®me des nuages ‚Äã‚Äãde cellules, apr√®s quoi il y a une diminution locale √† z√©ro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); cellClimate.clouds = <span class="hljs-number"><span class="hljs-number">0f</span></span>; climate[cellIndex] = cellClimate;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour ajouter des nuages ‚Äã‚Äã√† vos voisins, vous devez les contourner en boucle, obtenir leurs donn√©es climatiques, augmenter la valeur des nuages ‚Äã‚Äãet les recopier dans la liste. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = climate[neighbor.Index]; neighborClimate.clouds += cloudDispersal; climate[neighbor.Index] = neighborClimate; } cellClimate.clouds = <span class="hljs-number"><span class="hljs-number">0f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6a/0e3/437/e6a0e34379d984582c020fde8f1db546.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuages ‚Äã‚Äã√©pars.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cela cr√©e une carte presque blanche, car √† chaque cycle, les cellules sous-marines ajoutent de plus en plus de nuages ‚Äã‚Äãau climat mondial. Apr√®s le premier cycle, les cellules terrestres √† c√¥t√© de l'eau auront √©galement des nuages ‚Äã‚Äãqui doivent √™tre dispers√©s. Ce processus se poursuit jusqu'√† ce que la majeure partie de la carte soit couverte de nuages. Dans le cas de la carte 1208905299 avec les param√®tres par d√©faut, seul l'int√©rieur de la grande masse de terrain dans le nord-est est rest√© compl√®tement d√©couvert.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que les √©tangs peuvent g√©n√©rer un nombre infini de nuages. </font><font style="vertical-align: inherit;">Le niveau d'eau ne fait pas partie de la simulation climatique. </font><font style="vertical-align: inherit;">En r√©alit√©, les r√©servoirs ne sont pr√©serv√©s que parce que l'eau y retourne √† peu pr√®s au rythme de l'√©vaporation. </font><font style="vertical-align: inherit;">Autrement dit, nous ne simulons qu'un cycle partiel de l'eau. </font><font style="vertical-align: inherit;">C'est normal, mais il faut comprendre que plus la simulation se d√©roule, plus l'eau est ajout√©e au climat. </font><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, la perte d'eau ne se produit que sur les bords de la carte, o√π les nuages ‚Äã‚Äãdispers√©s sont perdus en raison du manque de voisins. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez voir la perte d'eau en haut de la carte, en particulier dans les cellules en haut √† droite. </font><font style="vertical-align: inherit;">Dans la derni√®re cellule, il n'y a pas de nuages ‚Äã‚Äãdu tout, car il reste la derni√®re dans laquelle le climat se forme. </font><font style="vertical-align: inherit;">Elle n'a pas encore re√ßu de nuages ‚Äã‚Äãd'un voisin.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le climat de toutes les cellules ne devrait-il pas se former en parall√®le?</font></font></b> <div class="spoiler_text"> ,        .    -              ,         .   40    . -      ,       . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pr√©cipitations </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'eau ne reste pas froide pour toujours. √Ä un moment donn√©, elle devrait retomber au sol. Cela se produit g√©n√©ralement sous forme de pluie, mais parfois il peut s'agir de neige, de gr√™le ou de neige mouill√©e. Tout cela s'appelle g√©n√©ralement pr√©cipitation. L'ampleur et le taux de disparition des nuages ‚Äã‚Äãvarient consid√©rablement, mais nous utilisons simplement un taux de pluie mondial personnalis√©. Une valeur de 0 signifie aucune pr√©cipitation, une valeur de 1 signifie que tous les nuages ‚Äã‚Äãdisparaissent instantan√©ment. La valeur par d√©faut est 0,25. Cela signifie qu'√† chaque cycle, un quart des nuages ‚Äã‚Äãdispara√Ætra.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitationFactor = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/762/37d/f9076237d0673301af34c32f5cd6688a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curseur de coefficient de pr√©cipitation. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous simulerons les pr√©cipitations apr√®s √©vaporation et avant la diffusion des nuages. </font><font style="vertical-align: inherit;">Cela signifie qu'une partie de l'eau √©vapor√©e des r√©servoirs pr√©cipite imm√©diatement, de sorte que le nombre de nuages ‚Äã‚Äãdispers√©s diminue. </font><font style="vertical-align: inherit;">Sur terre, les pr√©cipitations entra√Æneront la disparition des nuages.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e3/f11/46a/4e3f1146a761d1525e6a9349ff715bbb.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des nuages ‚Äã‚Äãqui disparaissent. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, lorsque nous d√©truisons 25% des nuages ‚Äã‚Äã√† chaque cycle, la terre redevient presque noire. </font><font style="vertical-align: inherit;">Les nuages ‚Äã‚Äãne parviennent √† se d√©placer vers l'int√©rieur des terres qu'en quelques √©tapes, apr√®s quoi ils deviennent invisibles. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2>  Humidit√© </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que les pr√©cipitations d√©truisent les nuages, elles ne doivent pas √©liminer l'eau du climat. </font><font style="vertical-align: inherit;">Apr√®s √™tre tomb√©e au sol, l'eau est √©conomis√©e, uniquement dans un √©tat diff√©rent. </font><font style="vertical-align: inherit;">Il peut exister sous de nombreuses formes, que nous consid√©rerons g√©n√©ralement comme de l'humidit√©.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suivi de l'humidit√© </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons am√©liorer le mod√®le climatique en suivant deux conditions de l'eau: les nuages ‚Äã‚Äãet l'humidit√©. </font><font style="vertical-align: inherit;">Pour impl√©menter cela, ajoutez dans le </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">champ </font></font><code>moisture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClimateData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clouds, moisture; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans sa forme la plus g√©n√©ralis√©e, l'√©vaporation est le processus de conversion de l'humidit√© en nuages, du moins dans notre mod√®le climatique simple. </font><font style="vertical-align: inherit;">Cela signifie que l'√©vaporation ne doit pas √™tre une valeur constante, mais un autre facteur. </font><font style="vertical-align: inherit;">Par cons√©quent, nous effectuons le refactoring-renommage </font></font><code>evaporation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>evaporationFactor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporationFactor = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque la cellule est sous l'eau, nous annon√ßons simplement que le taux d'humidit√© est 1. Cela signifie que l'√©vaporation est √©gale au coefficient d'√©vaporation. </font><font style="vertical-align: inherit;">Mais maintenant, nous pouvons √©galement obtenir l'√©vaporation des cellules de sushi. </font><font style="vertical-align: inherit;">Dans ce cas, nous devons calculer l'√©vaporation, la soustraire de l'humidit√© et ajouter le r√©sultat aux nuages. </font><font style="vertical-align: inherit;">Apr√®s cela, les pr√©cipitations sont ajout√©es √† l'humidit√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.moisture = <span class="hljs-number"><span class="hljs-number">1f</span></span>; cellClimate.clouds += evaporationFactor; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporation = cellClimate.moisture * evaporationFactor; cellClimate.moisture -= evaporation; cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; cellClimate.moisture += precipitation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que les nuages ‚Äã‚Äãsont maintenant soutenus par l'√©vaporation de la terre, nous pouvons les d√©placer plus √† l'int√©rieur des terres. </font><font style="vertical-align: inherit;">Maintenant, la majeure partie de la terre est devenue grise.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/94f/c71/a0b94fc71728a012254059d760bf47f3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuages ‚Äã‚Äãavec √©vaporation de l'humidit√©. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifions-le </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il affiche l'humidit√© au lieu des nuages, car nous allons l'utiliser pour d√©terminer les types de relief.</font></font><br><br><pre> <code class="cs hljs"> cell.SetMapData(climate[i].moisture);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cf/78f/d30/3cf78fd3099cf1b3a75befb8ebb0893d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Affichage de l'humidit√©. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä ce stade, l'humidit√© ressemble assez aux nuages ‚Äã‚Äã(sauf que toutes les cellules sous-marines sont blanches), mais cela changera bient√¥t.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ruissellement pluvial </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'√©vaporation n'est pas le seul moyen par lequel l'humidit√© peut quitter la cellule. </font><font style="vertical-align: inherit;">Le cycle de l'eau nous dit que la majeure partie de l'humidit√© ajout√©e √† la terre se retrouve en quelque sorte dans l'eau. </font><font style="vertical-align: inherit;">Le processus le plus notable est l'√©coulement de l'eau sur la terre sous l'influence de la gravit√©. </font><font style="vertical-align: inherit;">Nous ne simulerons pas de vraies rivi√®res, mais utiliserons un coefficient de ruissellement des pr√©cipitations personnalis√©. </font><font style="vertical-align: inherit;">Il indiquera le pourcentage d'eau s'√©coulant vers les zones inf√©rieures. </font><font style="vertical-align: inherit;">Par d√©faut, le stock sera √©gal √† 25%.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoffFactor = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c85/e81/648/c85e8164833b60299f80bba99c11be81.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curseur de vidange.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne g√©n√©rerons pas de rivi√®res?</font></font></b> <div class="spoiler_text">          . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le ruissellement de l'eau agit comme une dispersion des nuages, mais avec trois diff√©rences. Premi√®rement, toute l'humidit√© n'est pas √©limin√©e de la cellule. Deuxi√®mement, il transporte l'humidit√©, pas les nuages. Troisi√®mement, il ne descend, c'est-√†-dire qu'aux voisins de hauteur inf√©rieure. Le coefficient de ruissellement d√©crit la quantit√© d'humidit√© qui s'√©coulerait de la cellule si tous les voisins √©taient inf√©rieurs, mais souvent ils sont moindres. Cela signifie que nous ne r√©duirons l'humidit√© des cellules que lorsque nous trouverons un voisin ci-dessous.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoff = cellClimate.moisture * runoffFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = climate[neighbor.Index]; neighborClimate.clouds += cloudDispersal; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.Elevation - cell.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= runoff; neighborClimate.moisture += runoff; } climate[neighbor.Index] = neighborClimate; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a25/c41/00b/a25c4100bde5139415ebbf0a45068d0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'eau s'√©coule √† une hauteur inf√©rieure. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En cons√©quence, nous avons une distribution plus diversifi√©e de l'humidit√©, car les cellules √©lev√©es transmettent leur humidit√© √† l'inf√©rieur. </font><font style="vertical-align: inherit;">Nous voyons √©galement beaucoup moins d'humidit√© dans les cellules c√¥ti√®res, car elles drainent l'humidit√© dans les cellules sous-marines. </font><font style="vertical-align: inherit;">Pour affaiblir cet effet, nous devons √©galement utiliser le niveau d'eau pour d√©terminer si la cellule est plus basse, c'est-√†-dire prendre la hauteur apparente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.ViewElevation - cell.ViewElevation;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/651/ee9/64d/651ee964da5a422bfaa94f27609a5dcd.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisez la hauteur visible.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seepage </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Non seulement l'eau coule, elle se r√©pand, s'infiltre √† travers la topographie plane et est absorb√©e par le terrain adjacent aux plans d'eau. </font><font style="vertical-align: inherit;">Cet effet peut avoir peu d'effet, mais il est utile pour lisser la distribution de l'humidit√©, alors ajoutons-le √† la simulation. </font><font style="vertical-align: inherit;">Cr√©ons-lui son propre coefficient personnalis√©, par d√©faut √©gal √† 0,125.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seepageFactor = <span class="hljs-number"><span class="hljs-number">0.125f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/495/855/b73/495855b73d4601ab3de00b3561285491.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curseur de fuite. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le suintement est similaire √† un drain, sauf qu'il est utilis√© lorsque le voisin a la m√™me hauteur visible que la cellule elle-m√™me.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoff = cellClimate.moisture * runoffFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seepage = cellClimate.moisture * seepageFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.ViewElevation - cell.ViewElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= runoff; neighborClimate.moisture += runoff; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= seepage; neighborClimate.moisture += seepage; } climate[neighbor.Index] = neighborClimate; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d39/7b2/b01/d397b2b01ad8e71137b9e5fa03fcf5a5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajout d'une petite fuite. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ombres de pluie </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous ayons d√©j√† cr√©√© une simulation digne du cycle de l'eau, elle ne semble pas tr√®s int√©ressante, car elle n'a pas d'ombres de pluie, ce qui d√©montre le plus clairement les diff√©rences climatiques. </font><font style="vertical-align: inherit;">Les ombres pluviales sont des zones dans lesquelles il y a un manque important de pr√©cipitations par rapport aux zones voisines. </font><font style="vertical-align: inherit;">Ces zones existent parce que les montagnes emp√™chent les nuages ‚Äã‚Äãde les atteindre. </font><font style="vertical-align: inherit;">Leur cr√©ation n√©cessite de hautes montagnes et une direction de vent dominante.</font></font><br><br><h3>  Le vent </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commen√ßons par ajouter une direction de vent dominante √† la simulation. </font><font style="vertical-align: inherit;">Bien que les directions dominantes du vent varient consid√©rablement √† la surface de la Terre, nous nous en sortirons avec une direction mondiale du vent personnalisable. </font><font style="vertical-align: inherit;">Utilisons le nord-ouest par d√©faut. </font><font style="vertical-align: inherit;">De plus, rendons la force du vent r√©glable de 1 √† 10 avec une valeur par d√©faut de 4.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection windDirection = HexDirection.NW; [Range(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> windStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f32/4a1/49c/f324a149c360bbfde72e98b4877afb37.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La direction et la force du vent. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La force du vent dominant est exprim√©e par rapport √† la dispersion totale des nuages. </font><font style="vertical-align: inherit;">Si la force du vent est de 1, la diffusion est la m√™me dans toutes les directions. </font><font style="vertical-align: inherit;">Lorsqu'il est de 2, la diffusion est deux fois plus √©lev√©e dans la direction du vent que dans les autres directions, et ainsi de suite. </font><font style="vertical-align: inherit;">Nous pouvons le faire en modifiant le diviseur dans la formule de dispersion des nuages. </font><font style="vertical-align: inherit;">Au lieu de six, il sera √©gal √† cinq plus l'√©nergie √©olienne.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / (<span class="hljs-number"><span class="hljs-number">5f</span></span> + windStrength));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, la direction du vent d√©termine la direction √† partir de laquelle le vent souffle. </font><font style="vertical-align: inherit;">Par cons√©quent, nous devons utiliser la direction oppos√©e comme direction principale de diffusion.</font></font><br><br><pre> <code class="cs hljs"> HexDirection mainDispersalDirection = windDirection.Opposite(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / (<span class="hljs-number"><span class="hljs-number">5f</span></span> + windStrength));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant v√©rifier si le voisin est dans la direction principale de diffusion. </font><font style="vertical-align: inherit;">Si c'est le cas, alors nous devons multiplier la dispersion des nuages ‚Äã‚Äãpar la force du vent.</font></font><br><br><pre> <code class="cs hljs"> ClimateData neighborClimate = climate[neighbor.Index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d == mainDispersalDirection) { neighborClimate.clouds += cloudDispersal * windStrength; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { neighborClimate.clouds += cloudDispersal; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7e/874/2d5/e7e8742d53033ee4ee89f68e60871426.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vent du nord-ouest, force 4.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le vent dominant ajoute une direction √† la distribution de l'humidit√© sur la terre. </font><font style="vertical-align: inherit;">Plus le vent est fort, plus l'effet devient puissant.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hauteur absolue </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le deuxi√®me ingr√©dient pour obtenir des ombres de pluie est la montagne. Nous n'avons pas de classification stricte de ce qu'est une montagne, tout comme la nature ne l'a pas non plus. Seule la hauteur absolue est importante. En fait, lorsque l'air se d√©place au-dessus de la montagne, il est forc√© de s'√©lever, est refroidi et peut contenir moins d'eau, ce qui conduit √† des pr√©cipitations avant que l'air ne passe au-dessus de la montagne. Par cons√©quent, de l'autre c√¥t√©, nous obtenons de l'air sec, c'est-√†-dire une ombre de pluie.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus important encore, plus l'air monte, moins il peut contenir d'eau. </font><font style="vertical-align: inherit;">Dans notre simulation, nous pouvons imaginer cela comme une restriction forc√©e de la valeur maximale du nuage pour chaque cellule. </font><font style="vertical-align: inherit;">Plus la hauteur de cellule visible est √©lev√©e, plus ce maximum doit √™tre bas. </font><font style="vertical-align: inherit;">La fa√ßon la plus simple de proc√©der consiste √† d√©finir le maximum sur 1 moins la hauteur apparente, divis√© par la hauteur maximale. </font><font style="vertical-align: inherit;">Mais en fait, divisons par un maximum de moins 1. Cela permettra √† une petite fraction des nuages ‚Äã‚Äãde traverser m√™me les cellules les plus hautes. </font><font style="vertical-align: inherit;">Nous attribuons ce maximum apr√®s calcul des pr√©cipitations et avant diffusion.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; cellClimate.moisture += precipitation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudMaximum = <span class="hljs-number"><span class="hljs-number">1f</span></span> - cell.ViewElevation / (elevationMaximum + <span class="hljs-number"><span class="hljs-number">1f</span></span>); HexDirection mainDispersalDirection = windDirection.Opposite();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si, par cons√©quent, nous obtenons plus de nuages ‚Äã‚Äãqu'il n'est acceptable, nous convertissons simplement les nuages ‚Äã‚Äãen exc√®s en humidit√©. </font><font style="vertical-align: inherit;">En fait, c'est ainsi que nous ajoutons des pr√©cipitations suppl√©mentaires, comme cela se produit dans de vraies montagnes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudMaximum = <span class="hljs-number"><span class="hljs-number">1f</span></span> - cell.ViewElevation / (elevationMaximum + <span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellClimate.clouds &gt; cloudMaximum) { cellClimate.moisture += cellClimate.clouds - cloudMaximum; cellClimate.clouds = cloudMaximum; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/403/998/c36/403998c36a6d85250f837766a4f33147.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ombres de pluie caus√©es par la haute altitude. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous terminons la simulation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A ce stade, nous disposons d√©j√† d'une simulation partielle de tr√®s haute qualit√© du cycle de l'eau. </font><font style="vertical-align: inherit;">Mettons-le un peu dans l'ordre, puis appliquons-le pour d√©terminer le type de relief des cellules.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Informatique parall√®le </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme mentionn√© pr√©c√©demment sous le spoiler, l'ordre dans lequel les cellules sont form√©es affecte le r√©sultat de la simulation. </font><font style="vertical-align: inherit;">Id√©alement, cela ne devrait pas √™tre et, en substance, nous formons toutes les cellules en parall√®le. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en appliquant tous les changements du stade actuel de formation √† la deuxi√®me liste de climat </font></font><code>nextClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> List&lt;ClimateData&gt; climate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;(); List&lt;ClimateData&gt; nextClimate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Effacez et initialisez cette liste, comme tout le monde. </font><font style="vertical-align: inherit;">Ensuite, nous √©changerons des listes √† chaque cycle. </font><font style="vertical-align: inherit;">Dans ce cas, la simulation utilisera alternativement les deux listes et appliquera les donn√©es climatiques actuelles et suivantes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { climate.Clear(); nextClimate.Clear(); ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); nextClimate.Add(initialData); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; cycle &lt; <span class="hljs-number"><span class="hljs-number">40</span></span>; cycle++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } List&lt;ClimateData&gt; swap = climate; climate = nextClimate; nextClimate = swap; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lorsqu'une cellule affecte le climat de son voisin, nous devons changer les donn√©es climatiques suivantes, pas celles actuelles. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = nextClimate[neighbor.Index]; ‚Ä¶ nextClimate[neighbor.Index] = neighborClimate; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et au lieu de copier les donn√©es climatiques suivantes dans la liste climatique actuelle, nous obtenons les donn√©es climatiques suivantes, leur ajoutons l'humidit√© actuelle et les copions dans la liste suivante. </font><font style="vertical-align: inherit;">Apr√®s cela, nous r√©initialisons les donn√©es de la liste actuelle afin qu'elles soient mises √† jour pour le cycle suivant.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// cellClimate.clouds = 0f; ClimateData nextCellClimate = nextClimate[cellIndex]; nextCellClimate.moisture += cellClimate.moisture; nextClimate[cellIndex] = nextCellClimate; climate[cellIndex] = new ClimateData();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pendant que nous faisons cela, fixons √©galement le niveau d'humidit√© √† un maximum de 1 afin que les cellules terrestres ne puissent pas √™tre plus humides que sous l'eau. </font></font><br><br><pre> <code class="cs hljs"> nextCellClimate.moisture += cellClimate.moisture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextCellClimate.moisture &gt; <span class="hljs-number"><span class="hljs-number">1f</span></span>) { nextCellClimate.moisture = <span class="hljs-number"><span class="hljs-number">1f</span></span>; } nextClimate[cellIndex] = nextCellClimate;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a8/709/87b/6a870987bfad51e91eaa1ff405be539d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informatique parall√®le.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Humidit√© d'origine </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est possible que la simulation produise trop de terres s√®ches, en particulier avec un pourcentage √©lev√© de terres. </font><font style="vertical-align: inherit;">Pour am√©liorer l'image, nous pouvons ajouter un niveau d'humidit√© initial personnalis√© avec une valeur par d√©faut de 0,1.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> startingMoisture = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/69b/3a2/db869b3a24627d695d9ec8bf2ba1f4ae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ci-dessus se trouve le curseur de l'humidit√© d'origine. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons cette valeur pour l'humidit√© de la liste climatique initiale, mais pas pour les suivantes.</font></font><br><br><pre> <code class="cs hljs"> ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); initialData.moisture = startingMoisture; ClimateData clearData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); nextClimate.Add(clearData); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a74/138/649/a74138649fc141c088a631bce956a31a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec humidit√© d'origine.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©finition des biomes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous concluons en utilisant l'humidit√© au lieu de la hauteur pour sp√©cifier le type de relief cellulaire. </font><font style="vertical-align: inherit;">Utilisons la neige pour les terres compl√®tement s√®ches, pour les r√©gions arides, nous utilisons la neige, puis il y a la pierre, l'herbe pour assez humide et la terre pour les cellules satur√©es d'eau et sous-marines. </font><font style="vertical-align: inherit;">Le moyen le plus simple consiste √† utiliser cinq intervalles par incr√©ments de 0,2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moisture = climate[i].moisture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.2f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.4f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.6f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.SetMapData(moisture); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/123/c53/e4f/123c53e4f3f79aa50437a553e0eb6761.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous utilisez une distribution uniforme, le r√©sultat n'est pas tr√®s bon et il ne semble pas naturel. </font><font style="vertical-align: inherit;">Il est pr√©f√©rable d'utiliser d'autres seuils, par exemple 0,05, 0,12, 0,28 et 0,85.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.05f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.12f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.28f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.85f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ad/8cf/7c7/6ad8cf7c7becf357d16157ae28999a14.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomes modifi√©s. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 26: biomes et rivi√®res </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous cr√©ons les rivi√®res provenant de cellules √©lev√©es avec de l'humidit√©. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous cr√©ons un mod√®le de temp√©rature simple. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous utilisons la matrice du biome pour les cellules, puis la modifions. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette partie, nous compl√©terons le cycle de l'eau avec des rivi√®res et la temp√©rature, ainsi que des biomes plus int√©ressants aux cellules. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le didacticiel a √©t√© cr√©√© √† l'aide de Unity 2017.3.0p3.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/305/0b2/d11/3050b2d115d1ec49e2b6c945ab9ed4c1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La chaleur et l'eau animent la carte.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> G√©n√©ration de la rivi√®re </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les rivi√®res sont une cons√©quence du cycle de l'eau. </font><font style="vertical-align: inherit;">En fait, ils sont form√©s par des ruissellements arrachant √† l'aide de l'√©rosion des canaux. </font><font style="vertical-align: inherit;">Cela implique que vous pouvez ajouter des rivi√®res en fonction de la valeur des drains cellulaires. </font><font style="vertical-align: inherit;">Cependant, cela ne garantit pas que nous obtiendrons quelque chose qui ressemble √† de vraies rivi√®res. </font><font style="vertical-align: inherit;">Lorsque nous commencerons la rivi√®re, elle devra couler le plus loin possible, potentiellement √† travers de nombreuses cellules. </font><font style="vertical-align: inherit;">Cela n'est pas coh√©rent avec notre simulation du cycle de l'eau, qui traite les cellules en parall√®le. </font><font style="vertical-align: inherit;">De plus, le contr√¥le du nombre de rivi√®res sur une carte est g√©n√©ralement n√©cessaire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les fleuves √©tant tr√®s diff√©rents, nous les g√©n√©rerons s√©par√©ment. </font><font style="vertical-align: inherit;">Nous utilisons les r√©sultats de la simulation du cycle de l'eau pour d√©terminer l'emplacement des rivi√®res, mais les rivi√®res, √† leur tour, n'affecteront pas la simulation.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi le d√©bit de la rivi√®re est-il parfois faux?</font></font></b> <div class="spoiler_text">    <code>TriangulateWaterShore</code>  ,    .      ,    .   ,    ,       .      ,  .    ,  ,       .         (¬´¬ª). <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary( e1, e2, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction, indices ); } ‚Ä¶ }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cellules √† humidit√© √©lev√©e </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sur nos cartes, une cellule peut ou non avoir une rivi√®re. De plus, ils peuvent se ramifier ou se connecter. En r√©alit√©, les rivi√®res sont beaucoup plus flexibles, mais nous devons nous en tirer avec cette approximation, qui ne cr√©e que de grandes rivi√®res. Plus important encore, nous devons d√©terminer l'emplacement du d√©but d'un grand fleuve, qui est choisi au hasard. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que les rivi√®res ont besoin d'eau, la source de la rivi√®re doit se trouver dans une cellule tr√®s humide. Mais cela ne suffit pas. Les rivi√®res coulent le long des pentes, donc id√©alement la source devrait avoir une grande hauteur. Plus la cellule est haute au-dessus du niveau de l'eau, meilleure est sa candidature au r√¥le de source de la rivi√®re. Nous pouvons visualiser cela sous forme de donn√©es cartographiques en divisant la hauteur des cellules par la hauteur maximale. Pour que le r√©sultat soit obtenu par rapport au niveau de l'eau, nous allons le soustraire des deux hauteurs avant de diviser.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); cell.SetMapData(data); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f9/d80/2de/6f9d802de155c2b1e051be5d360dc3c1.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5c/e8f/6a2/f5ce8f6a20d7336dc94b89812c123827.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Humidit√© et altitude. Grande carte num√©ro 1208905299 avec param√®tres par d√©faut.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les meilleurs candidats sont les cellules qui ont √† la fois une humidit√© √©lev√©e et une hauteur √©lev√©e. On peut combiner ces crit√®res en les multipliant. Le r√©sultat sera la valeur de la forme physique ou du poids pour les sources des rivi√®res.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); cell.SetMapData(data);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec2/31f/445/ec231f445d785c24c6cd9f191ed6c24a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poids pour les sources des rivi√®res.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Id√©alement, nous utiliserions ces poids pour rejeter la s√©lection al√©atoire de la cellule source. Bien que nous puissions cr√©er une liste avec les poids corrects et faire votre choix, il s'agit d'une approche non triviale et cela ralentit le processus de g√©n√©ration. Une classification plus simple de l'importance divis√©e en quatre niveaux nous suffira. Les premiers candidats seront des poids avec des valeurs sup√©rieures √† 0,75. Les bons candidats ont des poids de 0,5. Les candidats √©ligibles sont sup√©rieurs √† 0,25. Toutes les autres cellules sont jet√©es. Montrons √† quoi cela ressemble graphiquement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.75f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">1f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// cell.SetMapData(data);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/056/5ba/3b7/0565ba3b7a51499bfe1d389ecd270910.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cat√©gories de poids des sources fluviales. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec ce sch√©ma de classification, nous aurons probablement des rivi√®res avec des sources dans les zones les plus hautes et les plus humides de la carte. </font><font style="vertical-align: inherit;">N√©anmoins, la probabilit√© de cr√©er des rivi√®res dans des zones relativement s√®ches ou basses demeure, ce qui augmente la variabilit√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez une m√©thode </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui remplit une liste de cellules en fonction de ces crit√®res. </font><font style="vertical-align: inherit;">Les cellules √©ligibles sont ajout√©es √† cette liste une fois, les bonnes deux fois et les principaux candidats quatre fois. </font><font style="vertical-align: inherit;">Les cellules sous-marines sont toujours jet√©es, vous ne pouvez donc pas les v√©rifier.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; riverOrigins = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData data = climate[i]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> weight = data.moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.75f</span></span>) { riverOrigins.Add(cell); riverOrigins.Add(cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { riverOrigins.Add(cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { riverOrigins.Add(cell); } } ListPool&lt;HexCell&gt;.Add(riverOrigins); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette m√©thode doit √™tre appel√©e apr√®s </font></font><code>CreateClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour que les donn√©es d'humidit√© soient √† notre disposition.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ CreateRegions(); CreateLand(); ErodeLand(); CreateClimate(); CreateRivers(); SetTerrainType(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apr√®s avoir termin√© le classement, vous pouvez vous d√©barrasser de la visualisation de ses donn√©es sur la carte. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// float data = // moisture * (cell.Elevation - waterLevel) / // (elevationMaximum - waterLevel); // if (data &gt; 0.6f) { // cell.SetMapData(1f); // } // else if (data &gt; 0.4f) { // cell.SetMapData(0.5f); // } // else if (data &gt; 0.2f) { // cell.SetMapData(0.25f); // } } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Points de la rivi√®re </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De combien de rivi√®res avons-nous besoin? </font><font style="vertical-align: inherit;">Ce param√®tre doit √™tre personnalisable. </font><font style="vertical-align: inherit;">√âtant donn√© que la longueur des rivi√®res varie, il sera plus logique de la contr√¥ler √† l'aide de points fluviaux, qui d√©terminent le nombre de cellules terrestres dans lesquelles les rivi√®res doivent √™tre contenues. </font><font style="vertical-align: inherit;">Exprimons-les en pourcentage avec un maximum de 20% et une valeur par d√©faut de 10%. </font><font style="vertical-align: inherit;">Comme le pourcentage de sushis, il s'agit d'une valeur cible, non garantie. </font><font style="vertical-align: inherit;">Par cons√©quent, nous pourrions avoir trop peu de candidats ou de rivi√®res trop courtes pour couvrir la quantit√© de terre requise. </font><font style="vertical-align: inherit;">C'est pourquoi le pourcentage maximum ne doit pas √™tre trop important.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 20)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverPercentage = <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/793/1c6/4cd/7931c64cd7bdffbb17f83a94aed1bbc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slider pour cent des rivi√®res. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour d√©terminer les points fluviaux, exprim√©s en nombre de cellules, nous devons nous rappeler combien de cellules terrestres ont √©t√© g√©n√©r√©es </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCount, landCells; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); landCells = landBudget; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); landCells -= landBudget; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä l'int√©rieur, le </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nombre de points fluviaux peut maintenant √™tre calcul√© de la m√™me mani√®re que nous le faisons dans </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; riverOrigins = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverBudget = Mathf.RoundToInt(landCells * riverPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); ListPool&lt;HexCell&gt;.Add(riverOrigins); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, nous continuerons de prendre et de supprimer des cellules al√©atoires de la liste d'origine, alors que nous avons toujours des points et des cellules sources. </font><font style="vertical-align: inherit;">En cas de finalisation du nombre de points, nous afficherons un avertissement dans la console.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverBudget = Mathf.RoundToInt(landCells * riverPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, riverOrigins.Count); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = riverOrigins.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell origin = riverOrigins[index]; riverOrigins[index] = riverOrigins[lastIndex]; riverOrigins.RemoveAt(lastIndex); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up river budget."</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, nous ajoutons une m√©thode pour cr√©er directement des rivi√®res. </font><font style="vertical-align: inherit;">Comme param√®tre, il a besoin d'une cellule initiale, et apr√®s l'ach√®vement, il doit retourner la longueur de la rivi√®re. </font><font style="vertical-align: inherit;">Nous commen√ßons par stocker une m√©thode qui retourne une longueur nulle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous appellerons cette m√©thode √† la fin du cycle que nous venons d'ajouter </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en utilisant pour r√©duire le nombre de points restants. </font><font style="vertical-align: inherit;">Nous nous assurons qu'une nouvelle rivi√®re est cr√©√©e uniquement si la cellule s√©lectionn√©e n'a pas de rivi√®re qui la traverse.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!origin.HasRiver) { riverBudget -= CreateRiver(origin); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rivi√®res actuelles </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est logique de cr√©er des rivi√®res coulant vers la mer ou un autre plan d'eau. </font><font style="vertical-align: inherit;">Lorsque nous partons de la source, nous obtenons imm√©diatement la longueur 1. Apr√®s cela, nous s√©lectionnons un voisin al√©atoire et augmentons la longueur. </font><font style="vertical-align: inherit;">Nous continuons de nous d√©placer jusqu'√† ce que nous atteignions la cellule sous-marine.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { HexDirection direction = (HexDirection)Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); cell.SetOutgoingRiver(direction); length += <span class="hljs-number"><span class="hljs-number">1</span></span>; cell = cell.GetNeighbor(direction); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/359/7cf/7a7/3597cf7a7ae263721b381534185e7645.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivi√®res al√©atoires. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä la suite d'une telle approche na√Øve, nous obtenons des fragments de rivi√®re dispers√©s de mani√®re al√©atoire, principalement en raison du remplacement des rivi√®res pr√©c√©demment g√©n√©r√©es. </font><font style="vertical-align: inherit;">Cela peut m√™me conduire √† des erreurs, car nous ne v√©rifions pas si le voisin existe r√©ellement. </font><font style="vertical-align: inherit;">Nous devons v√©rifier toutes les directions dans la boucle et nous assurer qu'il y a un voisin l√†-bas. </font><font style="vertical-align: inherit;">Si c'est le cas, nous ajoutons cette direction √† la liste des directions d'√©coulement potentielles, mais seulement si la rivi√®re ne traverse pas encore ce voisin. </font><font style="vertical-align: inherit;">S√©lectionnez ensuite une valeur al√©atoire dans cette liste.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexDirection&gt; flowDirections = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexDirection&gt;(); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || neighbor.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } flowDirections.Add(d); } HexDirection direction = <span class="hljs-comment"><span class="hljs-comment">// (HexDirection)Random.Range(0, 6); flowDirections[Random.Range(0, flowDirections.Count)]; cell.SetOutgoingRiver(direction); length += 1; cell = cell.GetNeighbor(direction); } return length; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec cette nouvelle approche, nous pouvons avoir z√©ro sens d'√©coulement disponible. </font><font style="vertical-align: inherit;">Lorsque cela se produit, la rivi√®re ne peut plus couler plus loin et doit s'arr√™ter. </font><font style="vertical-align: inherit;">Si √† ce moment la longueur est de 1, cela signifie que nous ne pouvons pas fuir de la cellule d'origine, c'est-√†-dire qu'il ne peut pas y avoir de rivi√®re du tout. </font><font style="vertical-align: inherit;">Dans ce cas, la longueur de la rivi√®re est nulle.</font></font><br><br><pre> <code class="cs hljs"> flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? length : <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6f/5bd/05d/e6f5bd05d8d5a976d6fff9fa14397a25.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fleuves pr√©serv√©s.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©labr√© </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous sauvons les rivi√®res d√©j√† cr√©√©es, mais nous pouvons toujours obtenir des fragments isol√©s des rivi√®res. </font><font style="vertical-align: inherit;">Cela se produit parce que nous avons ignor√© les hauteurs. </font><font style="vertical-align: inherit;">Chaque fois que nous avons forc√© la rivi√®re √† couler √† une plus grande hauteur, nous avons </font></font><code>HexCell.SetOutgoingRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interrompu cette tentative, qui a entra√Æn√© des ruptures dans les rivi√®res. </font><font style="vertical-align: inherit;">Par cons√©quent, nous devons √©galement sauter des directions qui font remonter les rivi√®res.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || neighbor.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = neighbor.Elevation - cell.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } flowDirections.Add(d);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae6/cf7/696/ae6cf76968d64228e88378749939f1f2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des rivi√®res qui coulent. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous nous d√©barrassons donc de nombreux fragments de rivi√®res, mais il en reste encore. </font><font style="vertical-align: inherit;">A partir de ce moment, se d√©barrasser des rivi√®res les plus laides devient une affaire de raffinement. </font><font style="vertical-align: inherit;">Pour commencer, les rivi√®res pr√©f√®rent couler le plus vite possible. </font><font style="vertical-align: inherit;">Ils ne choisiront pas n√©cessairement l'itin√©raire le plus court possible, mais la probabilit√© est grande. </font><font style="vertical-align: inherit;">Pour simuler cela, nous ajouterons trois fois les instructions √† la liste.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { flowDirections.Add(d); flowDirections.Add(d); flowDirections.Add(d); } flowDirections.Add(d);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âvitez les virages serr√©s </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En plus de couler, l'eau a √©galement une inertie. </font><font style="vertical-align: inherit;">Une rivi√®re est plus susceptible de couler directement ou de se plier l√©g√®rement que de faire un virage brusque et brutal. </font><font style="vertical-align: inherit;">Nous pouvons ajouter cette distorsion en suivant la derni√®re direction de la rivi√®re. </font><font style="vertical-align: inherit;">Si la direction potentielle du courant ne s'√©carte pas trop de cette direction, ajoutez-la √† nouveau √† la liste. </font><font style="vertical-align: inherit;">Ce n'est pas un probl√®me pour la source, nous l'ajouterons donc toujours.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; HexDirection direction = HexDirection.NE; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { flowDirections.Add(d); flowDirections.Add(d); flowDirections.Add(d); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( length == <span class="hljs-number"><span class="hljs-number">1</span></span> || (d != direction.Next2() &amp;&amp; d != direction.Previous2()) ) { flowDirections.Add(d); } flowDirections.Add(d); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? length : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// HexDirection direction = direction = flowDirections[Random.Range(0, flowDirections.Count)]; cell.SetOutgoingRiver(direction); length += 1; cell = cell.GetNeighbor(direction); } return length; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cela r√©duit consid√©rablement la probabilit√© de zigzags de rivi√®res qui semblent moche. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/83b/ce7/67483bce79b287f3cc451e381dc686d2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moins de virages serr√©s.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Confluence de la rivi√®re </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parfois, il s'av√®re que la rivi√®re coule juste √† c√¥t√© de la source de la rivi√®re pr√©c√©demment cr√©√©e. </font><font style="vertical-align: inherit;">Si la source de cette rivi√®re n'est pas √† une altitude plus √©lev√©e, alors nous pouvons d√©cider que la nouvelle rivi√®re se jette dans l'ancienne. </font><font style="vertical-align: inherit;">En cons√©quence, nous obtenons une longue rivi√®re et non deux rivi√®res voisines. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour ce faire, nous ne laisserons passer le voisin que s'il y a une rivi√®re entrante ou s'il est la source de la rivi√®re actuelle. </font><font style="vertical-align: inherit;">Apr√®s avoir d√©termin√© que cette direction n'est pas vers le haut, nous v√©rifions s'il y a une rivi√®re sortante. </font><font style="vertical-align: inherit;">S'il y en a, alors nous avons retrouv√© la vieille rivi√®re. </font><font style="vertical-align: inherit;">Comme cela se produit assez rarement, nous ne serons pas engag√©s dans la v√©rification d'autres sources voisines et combinerons imm√©diatement les rivi√®res.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || neighbor.HasRiver) { // continue; // } if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) { continue; } int delta = neighbor.Elevation - cell.Elevation; if (delta &gt; 0) { continue; } if (neighbor.HasOutgoingRiver) { cell.SetOutgoingRiver(d); return length; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb3/820/ee6/bb3820ee6271b8bc7b32e901b39c906a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ba/d8f/08d/3bad8f08d23cfe3844ec259a1c2475d6.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivi√®res avant et apr√®s la mise en commun.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gardez vos distances </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que les bons candidats pour le r√¥le source sont g√©n√©ralement regroup√©s, nous obtiendrons des groupes de rivi√®res. </font><font style="vertical-align: inherit;">De plus, nous pouvons avoir des rivi√®res qui prennent la source juste √† c√¥t√© du r√©servoir, ce qui donne des rivi√®res de longueur 1. Nous pouvons r√©partir les sources, en rejetant celles qui se trouvent √† proximit√© de la rivi√®re ou du r√©servoir. </font><font style="vertical-align: inherit;">Nous faisons cela en contournant les voisins de la source s√©lectionn√©e dans une boucle √† l'int√©rieur </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si nous trouvons un voisin qui viole les r√®gles, alors la source ne nous convient pas et nous devons le sauter.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, riverOrigins.Count); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = riverOrigins.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell origin = riverOrigins[index]; riverOrigins[index] = riverOrigins[lastIndex]; riverOrigins.RemoveAt(lastIndex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!origin.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isValidOrigin = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = origin.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; (neighbor.HasRiver || neighbor.IsUnderwater)) { isValidOrigin = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isValidOrigin) { riverBudget -= CreateRiver(origin); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et bien que les rivi√®res coulent toujours les unes √† c√¥t√© des autres, elles ont tendance √† couvrir une plus grande superficie. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/bed/3a6/887bed3a6032b4bea508ee6ceda4a228.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/b85/428/f53b85428840118895d74f62b1c2d1a6.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sans distance et avec elle.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous terminons la rivi√®re avec un lac </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toutes les rivi√®res n'atteignent pas le r√©servoir, certaines se coincent dans les vall√©es ou sont bloqu√©es par d'autres rivi√®res. Ce n'est pas un probl√®me particulier, car souvent les vraies rivi√®res semblent √©galement dispara√Ætre. Cela peut se produire, par exemple, s'ils coulent sous terre, se dispersent dans une zone mar√©cageuse ou se dess√®chent. Nos rivi√®res ne peuvent pas visualiser cela, alors elles finissent simplement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, nous pouvons essayer de minimiser le nombre de ces cas. Bien que nous ne puissions pas unir les rivi√®res ou les faire couler, nous pouvons les faire aboutir dans des lacs, qui se trouvent souvent dans la r√©alit√© et qui ont l'air bien. Pour cela</font></font><code>CreateRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devrait augmenter le niveau d'eau dans la cellule si elle se coince. </font><font style="vertical-align: inherit;">La possibilit√© de cela d√©pend de la hauteur minimale des voisins de cette cellule. </font><font style="vertical-align: inherit;">Par cons√©quent, afin de suivre cela lors de l'√©tude des voisins, une petite modification du code est n√©cessaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minNeighborElevation = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) { // continue; // } if (!neighbor) { continue; } if (neighbor.Elevation &lt; minNeighborElevation) { minNeighborElevation = neighbor.Elevation; } if (neighbor == origin || neighbor.HasIncomingRiver) { continue; } int delta = neighbor.Elevation - cell.Elevation; if (delta &gt; 0) { continue; } ‚Ä¶ } ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous sommes bloqu√©s, nous devons d'abord v√©rifier si nous sommes toujours √† la source. </font><font style="vertical-align: inherit;">Si oui, alors annulez simplement la rivi√®re. </font><font style="vertical-align: inherit;">Sinon, nous v√©rifions si tous les voisins sont au moins aussi √©lev√©s que la cellule actuelle. </font><font style="vertical-align: inherit;">Si oui, alors nous pouvons √©lever l'eau √† ce niveau. </font><font style="vertical-align: inherit;">Cela cr√©era un lac √† partir d'une cellule, √† moins que la hauteur de la cellule ne reste au m√™me niveau. </font><font style="vertical-align: inherit;">Si c'est le cas, attribuez simplement la hauteur √† un niveau en dessous du niveau de l'eau.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// return length &gt; 1 ? length : 0; if (length == 1) { return 0; } if (minNeighborElevation &gt;= cell.Elevation) { cell.WaterLevel = minNeighborElevation; if (minNeighborElevation == cell.Elevation) { cell.Elevation = minNeighborElevation - 1; } } break; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/7da/964/d607da964da18b71cd022c997661695c.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee8/ab1/000/ee8ab10002cd3e36cefbcfe3980a8fbe.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les extr√©mit√©s des rivi√®res sans lacs et avec lacs. </font><font style="vertical-align: inherit;">Dans ce cas, le pourcentage de rivi√®res est de 20.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Notez que nous pouvons maintenant avoir des cellules sous-marines au-dessus du niveau d'eau utilis√© pour g√©n√©rer la carte. </font><font style="vertical-align: inherit;">Ils d√©signeront les lacs au-dessus du niveau de la mer.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lacs suppl√©mentaires </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons √©galement cr√©er des lacs, m√™me si nous ne sommes pas coinc√©s. </font><font style="vertical-align: inherit;">Cela peut entra√Æner une rivi√®re qui coule dans et hors du lac. </font><font style="vertical-align: inherit;">Si nous ne sommes pas coinc√©s, un lac peut √™tre cr√©√© en augmentant le niveau de l'eau, puis la hauteur actuelle des cellules, puis en r√©duisant la hauteur des cellules. </font><font style="vertical-align: inherit;">Cela ne s'applique que lorsque la hauteur minimale du voisin est au moins √©gale √† la hauteur de la cellule actuelle. </font><font style="vertical-align: inherit;">Nous le faisons √† la fin du cycle de la rivi√®re et avant de passer √† la cellule suivante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minNeighborElevation &gt;= cell.Elevation) { cell.WaterLevel = cell.Elevation; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } cell = cell.GetNeighbor(direction); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/945/5bb/2b6/9455bb2b6547a8b1342e179f15eb5925.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f84/516/4b7/f845164b7a543b9549cd9f07d273e67f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sans lacs suppl√©mentaires et avec eux. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plusieurs lacs sont magnifiques, mais sans limites, nous pouvons cr√©er trop de lacs. </font><font style="vertical-align: inherit;">Par cons√©quent, ajoutons une probabilit√© personnalis√©e pour des lacs suppl√©mentaires, avec une valeur par d√©faut de 0,25.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> extraLakeProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Elle contr√¥lera la probabilit√© de g√©n√©rer un lac suppl√©mentaire, si possible. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( minNeighborElevation &gt;= cell.Elevation &amp;&amp; Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; extraLakeProbability ) { cell.WaterLevel = cell.Elevation; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa5/d04/bc3/fa5d04bc3f7475ec2baab7b6e7dac38f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/118/bb4/364/118bb4364acb0646efb54a031d3ac356.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lacs suppl√©mentaires.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'en est-il de la cr√©ation de lacs avec plus d'une cellule?</font></font></b> <div class="spoiler_text">     ,       ,  ,      .      .      :          .       ,       .  ,      ,     ,   . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La temp√©rature </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'eau n'est qu'un des facteurs qui peuvent d√©terminer le biome d'une cellule. </font><font style="vertical-align: inherit;">Un autre facteur important est la temp√©rature. </font><font style="vertical-align: inherit;">Bien que nous puissions simuler l'√©coulement et la diffusion des temp√©ratures comme la simulation de l'eau, pour cr√©er un climat int√©ressant, nous n'avons besoin que d'un facteur complexe. </font><font style="vertical-align: inherit;">Par cons√©quent, gardons la temp√©rature simple et la r√©glons pour chaque cellule.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Temp√©rature et latitude </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La plus grande influence sur la temp√©rature est la latitude. </font><font style="vertical-align: inherit;">Il fait chaud √† l'√©quateur, froid aux p√¥les, et il y a une transition en douceur entre eux. </font><font style="vertical-align: inherit;">Cr√©ons une m√©thode </font></font><code>DetermineTemperature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui renvoie la temp√©rature d'une cellule donn√©e. </font><font style="vertical-align: inherit;">Pour commencer, nous utilisons simplement la coordonn√©e Z de la cellule divis√©e par la dimension Z comme latitude, puis nous utilisons cette valeur comme temp√©rature.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> latitude; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous d√©finissons la temp√©rature √† l'int√©rieur </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et l'utilisons comme donn√©es cartographiques.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = DetermineTemperature(cell); cell.SetMapData(temperature); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moisture = climate[i].moisture; ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/789/7f6/334/7897f63347b08fdb02ee5794f3ab28e3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latitude comme temp√©rature, h√©misph√®re sud. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On obtient un gradient de temp√©rature lin√©aire croissant de bas en haut. </font><font style="vertical-align: inherit;">Vous pouvez l'utiliser pour simuler l'h√©misph√®re sud, avec un p√¥le en bas et un √©quateur en haut. </font><font style="vertical-align: inherit;">Mais nous n'avons pas besoin de d√©crire l'ensemble de l'h√©misph√®re. </font><font style="vertical-align: inherit;">Avec une diff√©rence de temp√©rature plus faible ou aucune diff√©rence, nous pouvons d√©crire une zone plus petite. </font><font style="vertical-align: inherit;">Pour ce faire, nous allons personnaliser les temp√©ratures basses et hautes. </font><font style="vertical-align: inherit;">Nous allons d√©finir ces temp√©ratures dans la plage de 0 √† 1 et utiliser les valeurs extr√™mes comme valeurs par d√©faut.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lowTemperature = <span class="hljs-number"><span class="hljs-number">0f</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> highTemperature = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b1/8cf/805/3b18cf805a56a0dbbeabb03b69a00496.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curseurs de temp√©rature. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous appliquons la plage de temp√©rature en utilisant une interpolation lin√©aire, en utilisant la latitude comme interpolateur. </font><font style="vertical-align: inherit;">Puisque nous exprimons la latitude comme une valeur de 0 √† 1, nous pouvons l'utiliser </font></font><code>Mathf.LerpUnclamped</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que les basses temp√©ratures ne sont pas n√©cessairement inf√©rieures aux hautes. </font><font style="vertical-align: inherit;">Si vous le souhaitez, vous pouvez les retourner.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> H√©misph√®re </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant simuler l'h√©misph√®re sud, et peut-√™tre l'h√©misph√®re nord, si nous prenons d'abord les temp√©ratures. </font><font style="vertical-align: inherit;">Mais il est beaucoup plus pratique d'utiliser une option de configuration distincte pour basculer entre les h√©misph√®res. </font><font style="vertical-align: inherit;">Cr√©ons une √©num√©ration et un champ pour cela. </font><font style="vertical-align: inherit;">Ainsi, nous ajouterons √©galement l'option de cr√©ation des deux h√©misph√®res, qui est applicable par d√©faut.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HemisphereMode { Both, North, South } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HemisphereMode hemisphere;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be8/c67/03f/be8c6703f51cd7c62535a96a3035a284.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le choix de l'h√©misph√®re. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous avons besoin de l'h√©misph√®re nord, alors nous pouvons simplement inverser la latitude, en la soustrayant de 1. Pour simuler les deux h√©misph√®res, les p√¥les doivent √™tre en dessous et au-dessus de la carte, et l'√©quateur doit √™tre au milieu. </font><font style="vertical-align: inherit;">Vous pouvez le faire en doublant la latitude, tandis que l'h√©misph√®re inf√©rieur sera trait√© correctement et que l'h√©misph√®re sup√©rieur aura une latitude de 1 √† 2. Pour r√©soudre ce probl√®me, nous soustrayons la latitude de 2 lorsqu'elle d√©passe 1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hemisphere == HemisphereMode.Both) { latitude *= <span class="hljs-number"><span class="hljs-number">2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (latitude &gt; <span class="hljs-number"><span class="hljs-number">1f</span></span>) { latitude = <span class="hljs-number"><span class="hljs-number">2f</span></span> - latitude; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hemisphere == HemisphereMode.North) { latitude = <span class="hljs-number"><span class="hljs-number">1f</span></span> - latitude; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c7/871/ede/9c7871ede0c56a393bc603ec888c65bf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les deux h√©misph√®res. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il convient de noter que cela cr√©e la possibilit√© de cr√©er une carte exotique dans laquelle l'√©quateur est froid et les p√¥les sont chauds.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plus le froid est √©lev√© </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En plus de la latitude, la temp√©rature est √©galement significativement affect√©e par l'altitude. </font><font style="vertical-align: inherit;">En moyenne, plus nous montons, plus il fait froid. </font><font style="vertical-align: inherit;">Nous pouvons en faire un facteur, comme nous l'avons fait avec les candidats de la rivi√®re. </font><font style="vertical-align: inherit;">Dans ce cas, nous utilisons la hauteur de cellule. </font><font style="vertical-align: inherit;">De plus, cet indicateur diminue avec la hauteur, c'est-√†-dire √©gal √† 1 moins la hauteur divis√©e par le maximum par rapport au niveau de l'eau. </font><font style="vertical-align: inherit;">Pour que l'indicateur au plus haut niveau ne tombe pas √† z√©ro, nous ajoutons au diviseur. </font><font style="vertical-align: inherit;">Utilisez ensuite cet indicateur pour mettre √† l'√©chelle la temp√©rature.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); temperature *= <span class="hljs-number"><span class="hljs-number">1f</span></span> - (cell.ViewElevation - waterLevel) / (elevationMaximum - waterLevel + <span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75e/a24/550/75ea24550d4325e2af45a1a9627cc53c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La hauteur affecte la temp√©rature.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fluctuations de temp√©rature </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons rendre la simplicit√© du gradient de temp√©rature moins perceptible en ajoutant des fluctuations de temp√©rature al√©atoires. </font><font style="vertical-align: inherit;">Une petite chance de le rendre plus r√©aliste, mais avec trop de fluctuations, ils auront l'air arbitraires. </font><font style="vertical-align: inherit;">Personnalisons la puissance des fluctuations de temp√©rature et exprimons-la comme l'√©cart de temp√©rature maximum avec une valeur par d√©faut de 0,1.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperatureJitter = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/e21/83f/27de2183fc453ded3c2902d4705cd1eb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curseur de fluctuation de temp√©rature. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ces fluctuations devraient √™tre fluides avec de l√©gers changements locaux. </font><font style="vertical-align: inherit;">Vous pouvez utiliser notre texture de bruit pour cela. </font><font style="vertical-align: inherit;">Nous appellerons </font></font><code>HexMetrics.SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et utiliserons comme argument la position de la cellule, mise √† l'√©chelle par 0,1. </font><font style="vertical-align: inherit;">Prenons le canal W, centrons-le et redimensionnons-le par le coefficient d'oscillation. </font><font style="vertical-align: inherit;">Ensuite, nous ajoutons cette valeur √† la temp√©rature pr√©c√©demment calcul√©e.</font></font><br><br><pre> <code class="cs hljs"> temperature *= <span class="hljs-number"><span class="hljs-number">1f</span></span> - (cell.ViewElevation - waterLevel) / (elevationMaximum - waterLevel + <span class="hljs-number"><span class="hljs-number">1f</span></span>); temperature += (HexMetrics.SampleNoise(cell.Position * <span class="hljs-number"><span class="hljs-number">0.1f</span></span>).w * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * temperatureJitter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/490/92c/2c8/49092c2c88aaad00d5c54835c6511a74.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dac/7d9/3cd/dac7d93cdb115574c748269ffebb3d8d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fluctuations de temp√©rature avec des valeurs de 0,1 et 1.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous pouvons ajouter une l√©g√®re variabilit√© aux fluctuations sur chaque carte, en choisissant au hasard parmi les quatre canaux de bruit. </font><font style="vertical-align: inherit;">D√©finissez le canal une fois </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis indexez les canaux de couleur </font></font><code>DetermineTemperature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> temperatureJitterChannel; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> jitter = HexMetrics.SampleNoise(cell.Position * <span class="hljs-number"><span class="hljs-number">0.1f</span></span>)[temperatureJitterChannel]; temperature += (jitter * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * temperatureJitter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30c/e82/084/30ce820847299346ec8dfaf2bb6cf1a8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diff√©rentes fluctuations de temp√©rature avec une force maximale. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biomes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous avons des donn√©es sur l'humidit√© et la temp√©rature, nous pouvons cr√©er une matrice de biome. </font><font style="vertical-align: inherit;">En indexant cette matrice, nous pouvons attribuer des biomes √† toutes les cellules, cr√©ant un paysage plus complexe que d'utiliser une seule dimension de donn√©es.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Matrice du biome </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe de nombreux mod√®les climatiques, mais nous n'en utiliserons aucun. Nous allons le rendre tr√®s simple, nous ne nous int√©ressons qu'√† la logique. Sec signifie d√©sert (froid ou chaud), pour cela nous utilisons du sable. Froid et humide signifie neige. Chaud et humide signifie beaucoup de v√©g√©tation, c'est-√†-dire de l'herbe. Entre eux, nous aurons une ta√Øga ou une toundra, que nous d√©signerons comme une texture gris√¢tre de la terre. Une matrice 4 √ó 4 sera suffisante pour cr√©er des transitions entre ces biomes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auparavant, nous attribuions des types d'√©l√©vation bas√©s sur cinq intervalles d'humidit√©. Nous abaissons simplement la bande la plus s√®che √† 0,05 et √©conomisons le reste. Pour les bandes de temp√©rature, nous utilisons 0,1, 0,3, 0,6 et plus. Pour plus de commodit√©, nous allons d√©finir ces valeurs dans des tableaux statiques.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] temperatureBands = { <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] moistureBands = { <span class="hljs-number"><span class="hljs-number">0.12f</span></span>, <span class="hljs-number"><span class="hljs-number">0.28f</span></span>, <span class="hljs-number"><span class="hljs-number">0.85f</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous ne sp√©cifions que le type de relief sur la base du biome, nous pouvons l'utiliser pour d√©terminer d'autres param√®tres. </font><font style="vertical-align: inherit;">Par cons√©quent, d√©finissons dans une </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">structure </font></font><code>Biome</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui d√©crit la configuration d'un biome individuel. </font><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, il ne contient que l'indice de bosse plus la m√©thode constructeur correspondante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Biome { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Biome</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> terrain</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.terrain = terrain; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons cette structure pour cr√©er un tableau statique contenant des donn√©es matricielles. </font><font style="vertical-align: inherit;">Nous utilisons l'humidit√© comme coordonn√©e X et la temp√©rature comme Y. Nous remplissons la ligne avec la temp√©rature la plus basse avec de la neige, la deuxi√®me ligne avec de la toundra et les deux autres avec de l'herbe. </font><font style="vertical-align: inherit;">Ensuite, nous rempla√ßons la colonne la plus s√®che par le d√©sert, red√©finissant le choix de temp√©rature.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Biome[] biomes = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/969/859/bd5/969859bd51e51cce1f7fe63d9eacd55a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matrice de biomes avec indices d'un tableau unidimensionnel.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©finition du biome </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour d√©terminer les </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cellules </font><font style="vertical-align: inherit;">du </font><font style="vertical-align: inherit;">biome, nous allons parcourir les plages de temp√©rature et d'humidit√© du cycle pour d√©terminer les indices matriciels dont nous avons besoin. </font><font style="vertical-align: inherit;">Nous les utilisons pour obtenir le biome souhait√© et sp√©cifier le type de topographie cellulaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = DetermineTemperature(cell); <span class="hljs-comment"><span class="hljs-comment">// cell.SetMapData(temperature); float moisture = climate[i].moisture; if (!cell.IsUnderwater) { // if (moisture &lt; 0.05f) { // cell.TerrainTypeIndex = 4; // } // ‚Ä¶ // else { // cell.TerrainTypeIndex = 2; // } int t = 0; for (; t &lt; temperatureBands.Length; t++) { if (temperature &lt; temperatureBands[t]) { break; } } int m = 0; for (; m &lt; moistureBands.Length; m++) { if (moisture &lt; moistureBands[m]) { break; } } Biome cellBiome = biomes[t * 4 + m]; cell.TerrainTypeIndex = cellBiome.terrain; } else { cell.TerrainTypeIndex = 2; } } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00d/d32/4f5/00dd324f5b421811f49ca157e5217e43.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relief bas√© sur une matrice de biome.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Configuration du biome </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons aller au-del√† des biomes d√©finis dans la matrice. Par exemple, dans la matrice, tous les biomes secs sont d√©finis comme des d√©serts de sable, mais tous les d√©serts secs ne sont pas remplis de sable. Il existe de nombreux d√©serts rocheux qui sont tr√®s diff√©rents. Par cons√©quent, rempla√ßons certaines des cellules du d√©sert par des pierres. Nous le ferons simplement en fonction de la hauteur: le sable est √† basse altitude et des roches nues se trouvent g√©n√©ralement au-dessus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supposons que le sable se transforme en pierre lorsque la hauteur de la cellule est plus proche de la hauteur maximale que du niveau de l'eau. C'est la ligne de hauteur des d√©serts rocheux que nous pouvons calculer au d√©but </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Lorsque nous rencontrons une cellule avec du sable et que sa hauteur est suffisamment grande, nous changeons le relief du biome en pierre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rockDesertElevation = elevationMaximum - (elevationMaximum - waterLevel) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { ‚Ä¶ Biome cellBiome = biomes[t * <span class="hljs-number"><span class="hljs-number">4</span></span> + m]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= rockDesertElevation) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } } cell.TerrainTypeIndex = cellBiome.terrain; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e4/812/13e/1e481213eb2c9b5cf5216b9bfa9546aa.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©serts de sable et de rochers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un autre changement bas√© sur la hauteur consiste √† forcer les cellules √† hauteur maximale √† se transformer en pics de neige, quelle que soit leur temp√©rature, uniquement si elles ne sont pas trop s√®ches. </font><font style="vertical-align: inherit;">Cela augmentera la probabilit√© de pics de neige pr√®s de l'√©quateur chaud et humide.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= rockDesertElevation) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == elevationMaximum) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">4</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/06e/35b/9c406e35b681819072db7a3006151e6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bouchons de neige √† hauteur maximale.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les plantes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faisons maintenant des biomes d√©terminer le niveau de cellules v√©g√©tales. </font><font style="vertical-align: inherit;">Pour ce faire, ajoutez au </font></font><code>Biome</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">domaine des plantes et incluez-le dans le constructeur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Biome { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain, plant; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Biome</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> terrain, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> plant</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.terrain = terrain; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.plant = plant; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans les biomes les plus froids et les plus secs, il n'y aura pas de plantes du tout. </font><font style="vertical-align: inherit;">√Ä tous les autres √©gards, plus le climat est chaud et humide, plus il y a de plantes. </font><font style="vertical-align: inherit;">La deuxi√®me colonne d'humidit√© ne re√ßoit que le premier niveau de plantes pour la rang√©e la plus chaude, donc [0, 0, 0, 1]. </font><font style="vertical-align: inherit;">La troisi√®me colonne augmente les niveaux de un, √† l'exception de la neige, c'est-√†-dire [0, 1, 1, 2]. </font><font style="vertical-align: inherit;">Et la colonne la plus humide les augmente √† nouveau, c'est-√†-dire qu'il s'av√®re [0, 2, 2, 3]. </font><font style="vertical-align: inherit;">Modifiez la baie </font></font><code>biomes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en y ajoutant la configuration de l'installation.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Biome[] biomes = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f94/bad/c72/f94badc7211d1891415dda94019bf041.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matrice des biomes avec les niveaux des plantes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons d√©finir le niveau de plantes pour la cellule.</font></font><br><br><pre> <code class="cs hljs"> cell.TerrainTypeIndex = cellBiome.terrain; cell.PlantLevel = cellBiome.plant;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed9/2c6/7f8/ed92c67f8322c4b0c9967c0f394507bf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomes avec des plantes.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les plantes sont-elles maintenant diff√©rentes?</font></font></b> <div class="spoiler_text">       ,      .       (1, 2, 1)  (0.75, 1, 0.75).     (1.5, 3, 1.5)  (2, 1.5, 2).    ‚Äî (2, 4.5, 2)  (2.5, 3, 2.5). <br><br>        ,      : (13, 114, 0). </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons changer le niveau des plantes pour les biomes. </font><font style="vertical-align: inherit;">Nous devons d'abord nous assurer qu'ils n'apparaissent pas sur le terrain enneig√©, que nous pourrions d√©j√† mettre en place. </font><font style="vertical-align: inherit;">Deuxi√®mement, augmentons le niveau de plantes le long des rivi√®res, s'il n'est pas d√©j√† au maximum.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">4</span></span>) { cellBiome.plant = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.plant &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> &amp;&amp; cell.HasRiver) { cellBiome.plant += <span class="hljs-number"><span class="hljs-number">1</span></span>; } cell.TerrainTypeIndex = cellBiome.terrain; cell.PlantLevel = cellBiome.plant;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/012/7e4/bd10127e45593cc5f8ce09faa783b10c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plantes modifi√©es.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biomes sous-marins </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† ce moment, nous avons compl√®tement ignor√© les cellules sous-marines. </font><font style="vertical-align: inherit;">Ajoutons-leur une petite variation, et nous n'utiliserons pas la texture de la terre pour tous. </font><font style="vertical-align: inherit;">Une solution simple bas√©e sur la hauteur sera d√©j√† suffisante pour cr√©er une image plus int√©ressante. </font><font style="vertical-align: inherit;">Par exemple, utilisons l'herbe pour les cellules une √©tape en dessous du niveau de l'eau. </font><font style="vertical-align: inherit;">Utilisons √©galement l'herbe pour les cellules au-dessus du niveau de l'eau, c'est-√†-dire pour les lacs cr√©√©s par les rivi√®res. </font><font style="vertical-align: inherit;">Les cellules avec une hauteur n√©gative sont des zones d'eau profonde, nous utilisons donc de la pierre pour elles. </font><font style="vertical-align: inherit;">Toutes les autres cellules restent broy√©es.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= waterLevel) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.TerrainTypeIndex = terrain; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a62/bb5/5c7/a62bb55c7e4023a4590dbfe73bafe10f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabilit√© sous-marine.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajoutons quelques d√©tails pour les cellules sous-marines le long de la c√¥te. Ce sont des cellules avec au moins un voisin au-dessus de l'eau. Si une telle cellule est peu profonde, nous cr√©erons une plage. Et si c'est √† c√¥t√© de la falaise, ce sera le d√©tail visuel dominant, et nous utilisons la pierre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour le d√©terminer, nous allons v√©rifier les voisins des cellules situ√©es √† un pas sous le niveau de l'eau. Comptons le nombre de connexions par les falaises et les pentes avec les cellules terrestres voisines.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cliffs = <span class="hljs-number"><span class="hljs-number">0</span></span>, slopes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++ ) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = neighbor.Elevation - cell.WaterLevel; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { slopes += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cliffs += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant utiliser ces informations pour classer les cellules. </font><font style="vertical-align: inherit;">Premi√®rement, si plus de la moiti√© des voisins sont des terres, alors nous avons affaire √† un lac ou √† une baie. </font><font style="vertical-align: inherit;">Pour ces cellules, nous utilisons une texture d'herbe. </font><font style="vertical-align: inherit;">Sinon, si nous avons des falaises, nous utilisons de la pierre. </font><font style="vertical-align: inherit;">Sinon, si nous avons des pentes, nous utilisons du sable pour cr√©er une plage. </font><font style="vertical-align: inherit;">La seule option restante est une zone peu profonde au large de la c√¥te, pour laquelle nous utilisons toujours de l'herbe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cliffs = <span class="hljs-number"><span class="hljs-number">0</span></span>, slopes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++ ) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliffs + slopes &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliffs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (slopes &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0eb/8d6/2ed/0eb8d62ed0ec66f7814bd839c9ca32fb.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e34/976/0bc/e349760bc545e3063718b892a9ccbd89.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabilit√© de la c√¥te. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, v√©rifions que nous n'avons pas de cellules sous-marines vertes dans la plage de temp√©rature la plus froide. </font><font style="vertical-align: inherit;">Pour ces cellules, nous utilisons la terre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrain == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; temperature &lt; temperatureBands[<span class="hljs-number"><span class="hljs-number">0</span></span>]) { terrain = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.TerrainTypeIndex = terrain;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons eu la possibilit√© de g√©n√©rer des cartes al√©atoires qui semblent assez int√©ressantes et naturelles, avec de nombreuses options de configuration. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 27: plier une carte </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous divisons les cartes en colonnes qui peuvent √™tre d√©plac√©es. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Centrez la carte dans l'appareil photo. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous effondrons tout. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette derni√®re partie, nous ajouterons un support pour minimiser la carte, reliant les bords est et ouest. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le didacticiel a √©t√© cr√©√© √† l'aide de Unity 2017.3.0p3.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f29/96a/49d/f2996a49dab361c70ce643cc9f2d648b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le pliage fait tourner le monde.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cartes pliantes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos cartes peuvent √™tre utilis√©es pour mod√©liser des zones de diff√©rentes tailles, mais elles sont toujours limit√©es √† une forme rectangulaire. Nous pouvons cr√©er une carte d'une √Æle ou d'un continent entier, mais pas de la plan√®te enti√®re. Les plan√®tes sont sph√©riques, elles n'ont pas de fronti√®res rigides qui g√™nent le mouvement √† leur surface. Si vous continuez √† vous d√©placer dans une direction, vous reviendrez t√¥t ou tard au point de d√©part. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne pouvons pas enrouler une grille d'hexagones autour d'une sph√®re; un tel chevauchement est impossible. Dans les meilleures approximations, la topologie icosa√©drique est utilis√©e, dans laquelle les douze cellules doivent √™tre des pentagones. Cependant, sans distorsion ni exception, le maillage peut √™tre enroul√© autour du cylindre. Pour ce faire, connectez simplement les bords est et ouest de la carte. √Ä l'exception de la logique d'habillage, tout le reste reste le m√™me.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un cylindre est une mauvaise approximation d'une sph√®re, car nous ne pouvons pas mod√©liser de p√¥les. </font><font style="vertical-align: inherit;">Mais cela n'a pas emp√™ch√© les d√©veloppeurs de nombreux jeux d'utiliser le pliage d'est en ouest pour mod√©liser les cartes de la plan√®te. </font><font style="vertical-align: inherit;">Les r√©gions polaires ne font tout simplement pas partie de la zone de jeu.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que diriez-vous de tourner vers le nord et le sud?</font></font></b> <div class="spoiler_text">          ,     .       ,    ,       .        -,            -.         . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe deux fa√ßons de mettre en ≈ìuvre le pliage cylindrique. </font><font style="vertical-align: inherit;">La premi√®re consiste √† rendre la carte cylindrique en pliant sa surface et tout ce qui s'y trouve afin que les bords est et ouest soient en contact. </font><font style="vertical-align: inherit;">Maintenant, vous jouerez non pas sur une surface plane, mais sur un vrai cylindre. </font><font style="vertical-align: inherit;">La deuxi√®me approche consiste √† enregistrer une carte plate et √† utiliser la t√©l√©portation ou la duplication pour s'effondrer. </font><font style="vertical-align: inherit;">La plupart des jeux utilisent la deuxi√®me approche, nous allons donc la suivre.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pliage en option </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La n√©cessit√© de r√©duire la carte d√©pend de son √©chelle - locale ou plan√©taire. </font><font style="vertical-align: inherit;">Nous pouvons utiliser le support des deux en rendant le pliage facultatif. </font><font style="vertical-align: inherit;">Pour ce faire, ajoutez un </font><font style="vertical-align: inherit;">nouveau commutateur au </font><font style="vertical-align: inherit;">menu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©er une nouvelle carte</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avec la r√©duction activ√©e par d√©faut.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b07/17d/3ef/b0717d3ef8000555a454de943e4e387a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le menu de la nouvelle carte avec l'option de r√©duire. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez au </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">champ pour suivre la s√©lection, ainsi qu'une m√©thode pour la modifier. </font><font style="vertical-align: inherit;">Faisons invoquer cette m√©thode lorsque l'√©tat du commutateur change.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleWrapping</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { wrapping = toggle; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lorsqu'une nouvelle carte est demand√©e, nous transmettons la valeur de l'option de r√©duction. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (generateMaps) { mapGenerator.GenerateMap(x, z, wrapping); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.CreateMap(x, z, wrapping); } HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez-le </font></font><code>HexMapGenerator.GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il accepte ce nouvel argument, puis le transmet √† </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ grid.CreateMap(x, z, wrapping); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code&gt; HexGrid devrait savoir si nous nous effondrons, alors ajoutez-y un champ et </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©finissez-le. </font><font style="vertical-align: inherit;">Les autres classes devraient changer leur logique selon que la grille est minimis√©e, nous allons donc rendre le champ g√©n√©ral. </font><font style="vertical-align: inherit;">De plus, il vous permet de d√©finir la valeur par d√©faut via l'inspecteur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCountX = <span class="hljs-number"><span class="hljs-number">20</span></span>, cellCountZ = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cellCountX = x; cellCountZ = z; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; ‚Ä¶ }</code> </pre> <br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appels propres </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† deux endroits. </font><font style="vertical-align: inherit;">Nous pouvons simplement utiliser son propre champ pour l'argument d'effondrement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ CreateMap(cellCountX, cellCountZ, wrapping); } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z, wrapping)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/d57/fc1/36ad57fc1ff8967bbd8282808f762241.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le commutateur de pliage de grille est activ√© par d√©faut.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sauvegarde et chargement </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que le pliage est d√©fini pour chaque carte, elle doit √™tre enregistr√©e et charg√©e. </font><font style="vertical-align: inherit;">Cela signifie que vous devez modifier le format d'enregistrement des fichiers, augmentez donc la constante de version dans </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de l'enregistrement, laissez- </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le simplement √©crire la valeur de pliage bool√©enne apr√®s la taille de la carte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); writer.Write(wrapping); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors du chargement, nous le lirons uniquement avec la version correcte du fichier. </font><font style="vertical-align: inherit;">Si elle est diff√©rente, il s'agit d'une ancienne carte et elle ne doit pas √™tre minimis√©e. </font><font style="vertical-align: inherit;">Enregistrez ces informations dans une variable locale et comparez-les avec l'√©tat actuel du pliage. </font><font style="vertical-align: inherit;">S'il est diff√©rent, nous ne pouvons pas r√©utiliser la topologie de carte existante de la m√™me mani√®re que lors du chargement d'une carte avec d'autres tailles.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ClearUnits(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping = header &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ? reader.ReadBoolean() : <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping != wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z, wrapping)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mesures pliantes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La r√©duction de la carte n√©cessitera des changements majeurs dans la logique, par exemple lors du calcul des distances. </font><font style="vertical-align: inherit;">Par cons√©quent, ils peuvent toucher du code qui n'a pas de lien direct avec la grille. </font><font style="vertical-align: inherit;">Au lieu de transmettre ces informations comme arguments, ajoutons-les √† </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ajoutez un entier statique contenant la taille de pliage qui correspond √† la largeur de la carte. </font><font style="vertical-align: inherit;">S'il est sup√©rieur √† z√©ro, il s'agit alors d'une carte pliable. </font><font style="vertical-align: inherit;">Pour v√©rifier cela, ajoutez une propri√©t√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Wrapping { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wrapSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons d√©finir la taille de pliage pour chaque appel </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; HexMetrics.wrapSize = wrapping ? cellCountX : <span class="hljs-number"><span class="hljs-number">0</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que ces donn√©es ne survivront pas √† la recompilation en mode Lecture, nous les configurerons </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; HexMetrics.wrapSize = wrapping ? cellCountX : <span class="hljs-number"><span class="hljs-number">0</span></span>; ResetVisibility(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Largeur de cellule </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous travaillez avec des cartes pliantes, nous devons souvent faire face √† des positions le long de l'axe X, mesur√©es dans la largeur des cellules. </font><font style="vertical-align: inherit;">Bien qu'il puisse √™tre utilis√© pour cela </font></font><code>HexMetrics.innerRadius * 2f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il serait plus pratique de ne pas ajouter de multiplication √† chaque fois. </font><font style="vertical-align: inherit;">Ajoutons donc une constante </font></font><code>HexMetrics.innerDiameter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerRadius = outerRadius * outerToInner; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerDiameter = innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On peut d√©j√† utiliser le diam√®tre √† trois endroits. </font><font style="vertical-align: inherit;">Tout d'abord, </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lors du positionnement d'une nouvelle cellule.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { Vector3 position; position.x = (x + z * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> - z / <span class="hljs-number"><span class="hljs-number">2</span></span>) * HexMetrics.innerDiameter; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxi√®mement, en </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limitant la position de la cam√©ra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * HexMetrics.innerDiameter; position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et aussi dans la </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conversion de position en coordonn√©es.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = position.x / HexMetrics.innerDiameter; ‚Ä¶ }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Centrage de la carte </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque la carte ne s'effondre pas, elle a clairement d√©fini les bords est et ouest, et donc un centre horizontal clair. </font><font style="vertical-align: inherit;">Mais dans le cas d'une carte pliable, tout est diff√©rent. </font><font style="vertical-align: inherit;">Il n'a ni le bord oriental ni le bord ouest, ni le centre. </font><font style="vertical-align: inherit;">Comme alternative, nous pouvons supposer que le centre est l'endroit o√π se trouve la cam√©ra. </font><font style="vertical-align: inherit;">Cela sera utile car nous voulons que la carte soit toujours centr√©e sur notre point de vue. </font><font style="vertical-align: inherit;">Ensuite, o√π que nous soyons, nous ne verrons pas les bords est ou ouest de la carte.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colonnes de fragments de carte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que la visualisation de la carte soit centr√©e par rapport √† la cam√©ra, nous devons changer le placement des √©l√©ments en fonction du mouvement de la cam√©ra. S'il se d√©place vers l'ouest, nous devons prendre ce qui se trouve actuellement au bord de la partie orientale et le d√©placer vers le bord de la partie ouest. La m√™me chose s'applique √† la direction oppos√©e. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Id√©alement, d√®s que la cam√©ra se d√©place vers la colonne de cellules voisine, nous devons imm√©diatement d√©placer la colonne de cellules la plus √©loign√©e de l'autre c√¥t√©. Cependant, nous n'avons pas besoin d'√™tre aussi pr√©cis. Au lieu de cela, nous pouvons transf√©rer des fragments de carte entiers. Cela nous permet de d√©placer des parties de la carte sans avoir √† modifier les maillages.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme nous d√©pla√ßons des colonnes enti√®res de fragments en m√™me temps, regroupons-les en cr√©ant un objet colonne parent pour chaque groupe. </font><font style="vertical-align: inherit;">Ajoutez un tableau pour ces objets </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et nous l'initialiserons </font></font><code>CreateChunks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous les utiliserons uniquement comme conteneurs, nous n'avons donc qu'√† suivre le lien vers leurs composants </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Comme dans le cas des fragments, leurs positions initiales sont situ√©es √† l'origine locale des coordonn√©es de la grille.</font></font><br><br><pre> <code class="cs hljs"> Transform[] columns; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { columns = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Transform[chunkCountX]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { columns[x] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameObject(<span class="hljs-string"><span class="hljs-string">"Column"</span></span>).transform; columns[x].SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, le fragment doit devenir un enfant de la colonne correspondante, pas de la grille. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ chunks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexGridChunk[chunkCountX * chunkCountZ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; chunkCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { HexGridChunk chunk = chunks[i++] = Instantiate(chunkPrefab); chunk.transform.SetParent(columns[x], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/415/920/bb2/415920bb2e4e2e002793aaebee8e04e2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragments regroup√©s en colonnes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque tous les fragments sont maintenant devenus des enfants des colonnes, </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il nous suffit de d√©truire directement toutes les colonnes, pas les fragments. </font><font style="vertical-align: inherit;">Nous allons donc nous d√©barrasser des fragments de fille.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columns != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { Destroy(columns[i].gameObject); } } ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colonnes de t√©l√©portation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez √† la </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nouvelle m√©thode </font></font><code>CenterMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec la position X comme param√®tre. </font><font style="vertical-align: inherit;">Convertissez la position en index de colonne, en la divisant par la largeur du fragment en unit√©s Unity. </font><font style="vertical-align: inherit;">Ce sera l'index de la colonne dans laquelle se trouve actuellement la cam√©ra, c'est-√†-dire que ce sera la colonne centrale de la carte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CenterMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xPosition</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerColumnIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il nous suffit de modifier la visualisation de la carte uniquement lorsque l'index de la colonne centrale change. </font><font style="vertical-align: inherit;">Alors, suivons-le sur le terrain. </font><font style="vertical-align: inherit;">Nous utilisons la valeur par d√©faut ‚àí1 lors de la cr√©ation d'une carte afin que les nouvelles cartes soient toujours centr√©es.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentCenterColumnIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; currentCenterColumnIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CenterMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xPosition</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerColumnIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (centerColumnIndex == currentCenterColumnIndex) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } currentCenterColumnIndex = centerColumnIndex; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous connaissons l'indice de la colonne centrale, nous pouvons d√©terminer les indices minimum et maximum en soustrayant simplement et en ajoutant la moiti√© du nombre de colonnes. Puisque nous utilisons des valeurs enti√®res, avec un nombre impair de colonnes, cela fonctionne parfaitement. Dans le cas d'un nombre pair, il ne peut pas y avoir de colonne parfaitement centr√©e, donc l'un des indices sera un cran plus loin que n√©cessaire. Cela cr√©e un d√©calage d'une colonne dans la direction du bord le plus √©loign√© de la carte, mais pour nous, ce n'est pas un probl√®me.</font></font><br><br><pre> <code class="cs hljs"> currentCenterColumnIndex = centerColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minColumnIndex = centerColumnIndex - chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxColumnIndex = centerColumnIndex + chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que ces indices peuvent √™tre n√©gatifs ou sup√©rieurs √† l'indice de colonne maximal naturel. </font><font style="vertical-align: inherit;">Le minimum est nul uniquement lorsque la cam√©ra est proche du centre naturel de la carte. </font><font style="vertical-align: inherit;">Notre t√¢che consiste √† d√©placer les colonnes afin qu'elles correspondent √† ces indices relatifs. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en modifiant la coordonn√©e X locale de chaque colonne de la boucle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minColumnIndex = centerColumnIndex - chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxColumnIndex = centerColumnIndex + chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; Vector3 position; position.y = position.z = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { position.x = <span class="hljs-number"><span class="hljs-number">0f</span></span>; columns[i].localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour chaque colonne, nous v√©rifions si l'indice de l'indice minimum est inf√©rieur. </font><font style="vertical-align: inherit;">Si c'est le cas, alors c'est trop loin √† gauche du centre. </font><font style="vertical-align: inherit;">Il doit se t√©l√©porter de l'autre c√¥t√© de la carte. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en faisant sa coordonn√©e X √©gale √† la largeur de la carte. </font><font style="vertical-align: inherit;">De m√™me, si l'index de colonne est sup√©rieur √† l'index maximum, il est trop loin √† droite du centre et devrait se t√©l√©porter de l'autre c√¥t√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; minColumnIndex) { position.x = chunkCountX * (HexMetrics.innerDiameter * HexMetrics.chunkSizeX); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt; maxColumnIndex) { position.x = chunkCountX * -(HexMetrics.innerDiameter * HexMetrics.chunkSizeX); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { position.x = <span class="hljs-number"><span class="hljs-number">0f</span></span>; } columns[i].localPosition = position; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©placement de la cam√©ra </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changez </font></font><code>HexMapCamera.AdjustPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour que lorsque vous travaillez avec une carte pliable, il </font></font><code>ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appelle √† la </font><font style="vertical-align: inherit;">place </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tout d'abord, faites simplement de la nouvelle m√©thode un </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doublon </font></font><code>ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais avec la seule diff√©rence: au final, elle appellera </font></font><code>CenterMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ transform.localPosition = grid.wrapping ? WrapPosition(position) : ClampPosition(position); } ‚Ä¶ <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WrapPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * HexMetrics.innerDiameter; position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); grid.CenterMap(position.x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que la carte soit imm√©diatement centr√©e, nous appelons la </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode </font></font><code>ValidatePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; ValidatePosition(); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©placez-vous vers la gauche et la droite lorsque vous centrez l'appareil photo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous restreignions toujours le mouvement de la cam√©ra, la carte essaie maintenant de se centrer par rapport √† la cam√©ra, t√©l√©portant des colonnes de fragments de carte si n√©cessaire. </font><font style="vertical-align: inherit;">Avec une petite carte et une cam√©ra distante, cela est clairement visible, mais sur une grande carte, les fragments t√©l√©port√©s sont en dehors de la zone de vision de la cam√©ra. </font><font style="vertical-align: inherit;">De toute √©vidence, seuls les bords est et ouest initiaux de la carte sont visibles, car il n'y a pas encore de triangulation entre eux. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Supprimer la restriction de sa coordonn√©e X afin de minimiser et d'une </font><font style="vertical-align: inherit;">cam√©ra </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Au lieu de cela, nous continuerons d'augmenter la coordonn√©e X de la largeur de la carte lorsqu'elle est inf√©rieure √† z√©ro et de la r√©duire lorsqu'elle est sup√©rieure √† la largeur de la carte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WrapPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// float xMax = (grid.cellCountX - 0.5f) * HexMetrics.innerDiameter; // position.x = Mathf.Clamp(position.x, 0f, xMax); float width = grid.cellCountX * HexMetrics.innerDiameter; while (position.x &lt; 0f) { position.x += width; } while (position.x &gt; width) { position.x -= width; } float zMax = (grid.cellCountZ - 1) * (1.5f * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, 0f, zMax); grid.CenterMap(position.x); return position; }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La cam√©ra d√©roulante se d√©place le long de la carte.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Textures de shader pliables </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä l'exception de l'espace de triangulation, la r√©duction de la cam√©ra en mode jeu devrait √™tre imperceptible. Cependant, lorsque cela se produit, un changement visuel se produit dans la moiti√© de la topographie et de l'eau. Cela se produit parce que nous utilisons une position dans le monde pour √©chantillonner ces textures. Une t√©l√©portation nette du fragment modifie l'emplacement des textures. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons r√©soudre ce probl√®me en faisant appara√Ætre les textures dans des tuiles qui sont des multiples de la taille du fragment. La taille du fragment est calcul√©e √† partir des constantes dans </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, alors cr√©ons le fichier d' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inclusion du</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader </font><em><font style="vertical-align: inherit;">HexMetrics.cginc</font></em><font style="vertical-align: inherit;"> et collez-y les d√©finitions correspondantes. L'√©chelle de mosa√Øque de base est calcul√©e √† partir de la taille du fragment et du rayon ext√©rieur de la cellule. Si vous utilisez d'autres mesures, vous devrez modifier le fichier en cons√©quence.</font></font><br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OUTER_TO_INNER 0.866025404 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OUTER_RADIUS 10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHUNK_SIZE_X 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TILING_SCALE (1 / (CHUNK_SIZE_X * 2 * OUTER_RADIUS / OUTER_TO_INNER))</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela nous donne une √©chelle de tuilage de 0,00866025404. </font><font style="vertical-align: inherit;">Si nous utilisons un multiple entier de cette valeur, la texturation ne sera pas affect√©e par la t√©l√©portation de fragments. </font><font style="vertical-align: inherit;">De plus, les textures aux bords est et ouest de la carte se rejoindront de mani√®re transparente apr√®s avoir triangul√© correctement leur connexion. </font><font style="vertical-align: inherit;">Nous avons utilis√© 0,02 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comme √©chelle UV dans le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Au lieu de cela, nous pouvons utiliser l'√©chelle de carrelage double, qui est de 0,01732050808. </font><font style="vertical-align: inherit;">L'√©chelle est obtenue un peu moins qu'elle ne l'√©tait, et l'√©chelle de la texture a l√©g√®rement augment√©, mais visuellement elle est invisible.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexMetrics.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexCellData.cginc" ‚Ä¶ <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3( <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * (<span class="hljs-number"><span class="hljs-number">2</span></span> * TILING_SCALE), <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] ); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roads</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour le bruit UV, nous avons utilis√© une √©chelle de 0,025. </font><font style="vertical-align: inherit;">Au lieu de cela, vous pouvez utiliser la triple √©chelle de mosa√Øque. </font><font style="vertical-align: inherit;">Cela nous donne 0,02598076212, ce qui est assez proche.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexMetrics.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, chez </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water.cginc,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous avons utilis√© 0,015 pour la mousse et 0,025 pour les vagues. </font><font style="vertical-align: inherit;">Ici, nous pouvons √† nouveau remplacer ces valeurs par une √©chelle de mosa√Øque doubl√©e et tripl√©e.</font></font><br><br><pre> <code class="hljs mel">#include <span class="hljs-string"><span class="hljs-string">"HexMetrics.cginc"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Foam (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shore, float2 worldXZ, sampler2D noiseTex) { shore = <span class="hljs-keyword"><span class="hljs-keyword">sqrt</span></span>(shore) * <span class="hljs-number"><span class="hljs-number">0.9</span></span>; float2 noiseUV = worldXZ + _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; float4 <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span> = tex2D(noiseTex, noiseUV * (<span class="hljs-number"><span class="hljs-number">2</span></span> * TILING_SCALE)); ‚Ä¶ } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Waves (float2 worldXZ, sampler2D noiseTex) { float2 uv1 = worldXZ; uv1.y += _Time.y; float4 noise1 = tex2D(noiseTex, uv1 * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); float2 uv2 = worldXZ; uv2.x += _Time.y; float4 noise2 = tex2D(noiseTex, uv2 * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); ‚Ä¶ }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'union de l'est et de l'ouest </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä ce stade, la seule preuve visuelle de la r√©duction de la carte est un petit √©cart entre les colonnes les plus √† l'est et √† l'ouest. </font><font style="vertical-align: inherit;">Cet √©cart se produit car nous n'avons pas encore triangul√© les bords et les coins entre les cellules des c√¥t√©s oppos√©s de la carte sans plier.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/240/85f/e79/24085fe7986100674854b9c9a79c349c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espace sur le bord.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voisins pliants </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour trianguler la connexion est-ouest, nous devons faire en sorte que les cellules des c√¥t√©s oppos√©s soient voisines les unes des autres. </font><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, nous ne le faisons pas, car la </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">connexion E - W n'est √©tablie avec la cellule pr√©c√©dente que si son index dans X est sup√©rieur √† z√©ro. </font><font style="vertical-align: inherit;">Pour r√©duire cette connexion, nous devons connecter la derni√®re cellule de la ligne avec la premi√®re cellule de la m√™me ligne lorsque le pliage de la carte est activ√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.W, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping &amp;&amp; x == cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.E, cells[i - x]); } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir √©tabli la connexion des voisins E - W, nous obtenons une triangulation partielle de l'√©cart. </font><font style="vertical-align: inherit;">La connexion des bords n'est pas id√©ale, car la distorsion n'est pas masqu√©e correctement. </font><font style="vertical-align: inherit;">Nous y reviendrons plus tard.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/68a/6b6/ce568a6b639801e47804eb35a62493c6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compos√©s E - W. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons √©galement r√©duire les liens NE - SW. </font><font style="vertical-align: inherit;">Pour ce faire, connectez la premi√®re cellule de chaque ligne paire aux derni√®res cellules de la ligne pr√©c√©dente. </font><font style="vertical-align: inherit;">Ce sera juste la cellule pr√©c√©dente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.SetNeighbor(HexDirection.SW, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/239/66f/c3c/23966fc3c616ea9338a3a14d187dcc7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connexions NE - SW. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, les connexions SE - NW sont √©tablies √† la fin de chaque ligne impaire en dessous de la premi√®re. </font><font style="vertical-align: inherit;">Ces cellules doivent √™tre connect√©es √† la premi√®re cellule de la ligne pr√©c√©dente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX + <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.SetNeighbor( HexDirection.SE, cells[i - cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e8/df4/62e/3e8df462e076bbdf93396f6cec525cc4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compos√©s SE - NW.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pliage de bruit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour masquer parfaitement l'√©cart, nous devons nous assurer que les bords est et ouest de la carte correspondent au bruit parfaitement utilis√© pour d√©former les positions des sommets. </font><font style="vertical-align: inherit;">Nous pouvons utiliser la m√™me astuce que celle utilis√©e pour les shaders, mais une √©chelle de bruit de 0,003 a √©t√© utilis√©e pour la distorsion. </font><font style="vertical-align: inherit;">Pour garantir la mosa√Øque, vous devez augmenter consid√©rablement l'√©chelle, ce qui entra√Ænera une distorsion plus chaotique des sommets. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une solution alternative n'est pas de mesurer le bruit, mais de faire une att√©nuation douce du bruit aux bords de la carte. </font><font style="vertical-align: inherit;">Si vous effectuez une att√©nuation douce sur la largeur d'une cellule, la distorsion cr√©era une transition douce sans espaces. </font><font style="vertical-align: inherit;">Le bruit dans cette zone sera l√©g√®rement liss√© et √† longue distance, le changement semblera net, mais ce n'est pas si √©vident lorsque vous utilisez une l√©g√®re distorsion des sommets.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et les fluctuations de temp√©rature?</font></font></b> <div class="spoiler_text">           .      ,      .         ,   .     ,        . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous n'effondrons pas la carte, nous pouvons nous en tirer avec un </font></font><code>HexMetrics.SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seul √©chantillon. </font><font style="vertical-align: inherit;">Mais lors du pliage, il est n√©cessaire d'ajouter une att√©nuation. </font><font style="vertical-align: inherit;">Par cons√©quent, avant de renvoyer l'√©chantillon, enregistrez-le dans une variable.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sample; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la minimisation, nous devons m√©langer avec le deuxi√®me √©chantillon. </font><font style="vertical-align: inherit;">Nous effectuerons la transition dans la partie orientale de la carte, de sorte que le deuxi√®me √©chantillon doit √™tre d√©plac√© vers l'ouest.</font></font><br><br><pre> <code class="cs hljs"> Vector4 sample = noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'att√©nuation est effectu√©e en utilisant une simple interpolation lin√©aire de la partie ouest vers la partie est, sur la largeur d'une cellule. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); sample = Vector4.Lerp( sample2, sample, position.x * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / innerDiameter) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/84f/75d/c4e84f75dd0260efb18a9d3d66647c55.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©lange de bruit, une solution imparfaite.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Par cons√©quent, nous n'obtenons pas de correspondance exacte, car certaines cellules du c√¥t√© est ont des coordonn√©es X n√©gatives. Pour ne pas approcher cette zone, d√©pla√ßons la r√©gion de transition vers la moiti√© ouest de la largeur de la cellule.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter * <span class="hljs-number"><span class="hljs-number">1.5f</span></span>) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); sample = Vector4.Lerp( sample2, sample, position.x * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / innerDiameter) - <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/af4/1fb/04faf41fb669427487a2dbb6855cd5bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Att√©nuation correcte.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modification de cellule </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que la triangulation semble correcte, assurons-nous que nous pouvons tout √©diter sur la carte et sur la couture de pliage. Il s'av√®re que, dans les fragments t√©l√©port√©s, les coordonn√©es sont erron√©es et les grands pinceaux sont coup√©s par une couture.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/18b/5ce/a1f18b5ce7b87b38a7a58d47e341d4f1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La brosse est taill√©e.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour r√©soudre ce probl√®me, nous devons signaler le </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pliage. Nous pouvons le faire en faisant correspondre la coordonn√©e X dans la m√©thode constructeur. Nous savons que la coordonn√©e axiale X est obtenue √† partir de la coordonn√©e X du d√©calage en soustrayant la moiti√© de la coordonn√©e Z. Vous pouvez utiliser ces informations pour effectuer la transformation inverse et v√©rifier si la coordonn√©e z√©ro est inf√©rieure √† z√©ro. Si oui, alors nous avons les coordonn√©es au-del√† du c√¥t√© est de la carte d√©pli√©e. √âtant donn√© que dans chaque direction, nous ne t√©l√©portons pas plus de la moiti√© de la carte, il nous suffira d'ajouter une fois la taille de pliage √† X. Et lorsque la coordonn√©e de d√©calage est sup√©rieure √† la taille de pliage, nous devons effectuer une soustraction.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HexCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oX = x + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oX &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x += HexMetrics.wrapSize; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oX &gt;= HexMetrics.wrapSize) { x -= HexMetrics.wrapSize; } } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.z = z; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parfois, lors de l'√©dition du bas ou du haut de la carte, j'obtiens des erreurs </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela se produit lorsque, en raison de la distorsion des sommets, le curseur appara√Æt dans la ligne de cellules en dehors de la carte. </font><font style="vertical-align: inherit;">Il s'agit d'un bogue qui se produit car nous ne faisons pas correspondre les coordonn√©es </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec le param√®tre vectoriel. </font><font style="vertical-align: inherit;">Cela peut √™tre r√©solu en appliquant une m√©thode </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec des coordonn√©es comme param√®tres qui effectueront les v√©rifications n√©cessaires.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-comment"><span class="hljs-comment">// int index = // coordinates.X + coordinates.Z * cellCountX + coordinates.Z / 2; // return cells[index]; return GetCell(coordinates); }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pliage c√¥tier </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La triangulation fonctionne bien pour le terrain, mais le long de la couture est-ouest, il n'y a pas de bords de la c√¥te de l'eau. </font><font style="vertical-align: inherit;">En fait, ils le sont, ils ne s'effondrent pas. </font><font style="vertical-align: inherit;">Ils sont retourn√©s et √©tir√©s de l'autre c√¥t√© de la carte.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/20a/ed3/6fe20aed3cb0dea0a9e47ef08caa10f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bord de l'eau manquant. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela se produit, car lors de la triangulation de l'eau de la c√¥te, nous utilisons la position d'un voisin. </font><font style="vertical-align: inherit;">Pour r√©soudre ce probl√®me, nous devons d√©terminer ce √† quoi nous avons affaire, situ√© de l'autre c√¥t√© de la carte. </font><font style="vertical-align: inherit;">Pour simplifier la t√¢che, nous allons ajouter une </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">colonne de cellules </font><font style="vertical-align: inherit;">√† la </font><font style="vertical-align: inherit;">propri√©t√© de l'index.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ColumnIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attribuez cet index √† </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Elle est simplement √©gale √† la coordonn√©e de d√©calage X divis√©e par la taille du fragment.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cell.Index = i; cell.ColumnIndex = x / HexMetrics.chunkSizeX; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant </font></font><code>HexGridChunk.TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©terminer ce qui est minimis√© en comparant l'index de colonne de la cellule actuelle et de son voisin. </font><font style="vertical-align: inherit;">Si l'indice de la colonne du voisin est inf√©rieur √† un pas de moins, alors nous sommes du c√¥t√© ouest et le voisin est du c√¥t√© est. </font><font style="vertical-align: inherit;">Par cons√©quent, nous devons tourner notre voisin vers l'ouest. </font><font style="vertical-align: inherit;">Le m√™me et dans la direction oppos√©e.</font></font><br><br><pre> <code class="cs hljs"> Vector3 center2 = neighbor.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.ColumnIndex &lt; cell.ColumnIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>) { center2.x += HexMetrics.wrapSize * HexMetrics.innerDiameter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.ColumnIndex &gt; cell.ColumnIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) { center2.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f13/308/3ec/f133083ec9172168e5302d737fd0ce27.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√¥tes de la c√¥te, mais pas de coins. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons donc pris soin des c√¥tes de la c√¥te, mais jusqu'√† pr√©sent, nous ne nous sommes pas occup√©s des virages. </font><font style="vertical-align: inherit;">Nous devons faire de m√™me avec le prochain voisin.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 center3 = nextNeighbor.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor.ColumnIndex &lt; cell.ColumnIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>) { center3.x += HexMetrics.wrapSize * HexMetrics.innerDiameter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor.ColumnIndex &gt; cell.ColumnIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) { center3.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter; } Vector3 v3 = center3 + (nextNeighbor.IsUnderwater ? HexMetrics.GetFirstWaterCorner(direction.Previous()) : HexMetrics.GetFirstSolidCorner(direction.Previous())); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d02/c0d/751/d02c0d7510fba8b3707b89f146b71837.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√¥te correctement r√©duite.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> G√©n√©ration de cartes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'option de connexion des c√¥t√©s est et ouest affecte la g√©n√©ration de cartes. </font><font style="vertical-align: inherit;">Lors de la minimisation de la carte, l'algorithme de g√©n√©ration doit √©galement √™tre minimis√©. </font><font style="vertical-align: inherit;">Cela conduira √† la cr√©ation d'une autre carte, mais lorsque vous utilisez une </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bordure de carte X</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> non nulle </font><em><font style="vertical-align: inherit;">, le</font></em><font style="vertical-align: inherit;"> pliage n'est pas √©vident.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/01f/f90/54001ff900386d5f389850de0a1d0034.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/428/859/ecb/428859ecb5c5bf9a68b277675110e44b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grande carte 1208905299 avec param√®tres par d√©faut. Avec pliage et sans elle.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quand elle est </font><font style="vertical-align: inherit;">r√©duite n'a pas de </font><font style="vertical-align: inherit;">sens d'utiliser </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la carte fronti√®re X</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mais nous ne pouvons pas nous en d√©barrasser, car en m√™me temps les r√©gions fusionneront. Lors de la r√©duction, nous pouvons simplement utiliser un </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RegionBorder</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous changeons </font></font><code>HexMapGenerator.CreateRegions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en rempla√ßant dans tous les cas </font></font><code>mapBorderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par </font></font><code>borderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cette nouvelle variable sera √©gale √† ou </font></font><code>regionBorder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ou </font></font><code>mapBorderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, selon la valeur de l'option de r√©duction. Ci-dessous, j'ai montr√© les changements uniquement pour le premier cas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> borderX = grid.wrapping ? regionBorder : mapBorderX; MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le m√™me temps, les r√©gions restent s√©par√©es, mais cela n'est n√©cessaire que s'il existe diff√©rentes r√©gions sur les c√¥t√©s est et ouest de la carte. </font><font style="vertical-align: inherit;">Il y a deux cas o√π cela n'est pas respect√©. </font><font style="vertical-align: inherit;">Le premier, c'est quand nous n'avons qu'une seule r√©gion. </font><font style="vertical-align: inherit;">La seconde est lorsque deux r√©gions divisent la carte horizontalement. </font><font style="vertical-align: inherit;">Dans ces cas, nous pouvons attribuer une </font></font><code>borderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur de z√©ro, ce qui permettra aux masses terrestres de traverser la couture est-ouest.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.wrapping) { borderX = <span class="hljs-number"><span class="hljs-number">0</span></span>; } region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.wrapping) { borderX = <span class="hljs-number"><span class="hljs-number">0</span></span>; } region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/4d4/c9e/db84d4c9e40c9e35ad29af69314f73e1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une r√©gion s'effondre. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä premi√®re vue, il semble que tout fonctionne correctement, mais il y a en fait un espace le long de la couture. </font><font style="vertical-align: inherit;">Cela devient plus visible si vous d√©finissez le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pourcentage d'√©rosion sur</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> z√©ro.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/a4e/572/ef5a4e5722dbbb8af91e770220d7d141.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b3/f75/fce/6b3f75fce35d6be9c8a66c445c4dc9cd.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque l'√©rosion est d√©sactiv√©e, une couture sur le relief devient perceptible.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'√©cart se produit parce que la couture emp√™che la croissance des fragments de relief. Pour d√©terminer ce qui est ajout√© en premier, la distance entre la cellule et le centre du fragment est utilis√©e, et les cellules de l'autre c√¥t√© de la carte peuvent √™tre tr√®s √©loign√©es, de sorte qu'elles ne s'allument presque jamais. Bien s√ªr, c'est faux. Nous devons nous assurer que nous </font></font><code>HexCoordinates.DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">connaissons la carte minimis√©e. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous calculons la distance entre </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en additionnant les distances absolues le long de chacun des trois axes et en divisant par deux le r√©sultat. La distance le long de Z est toujours vraie, mais le pliage le long peut affecter les distances X et Y. Commen√ßons donc par un calcul s√©par√© de X + Y.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// return // ((x &lt; other.x ? other.x - x : x - other.x) + // (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + // (z &lt; other.z ? other.z - z : z - other.z)) / 2; int xy = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); return (xy + (z &lt; other.z ? other.z - z : z - other.z)) / 2; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©terminer si le pliage cr√©e une distance plus courte pour les cellules arbitraires n'est pas une t√¢che facile, alors calculons simplement X + Y pour les cas o√π nous plions une autre coordonn√©e du c√¥t√© ouest. </font><font style="vertical-align: inherit;">Si la valeur est inf√©rieure au X + Y d'origine, utilisez-la.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xy = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { other.x += HexMetrics.wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si cela ne conduit pas √† une distance plus courte, il est possible de tourner plus court dans l'autre sens, nous allons donc le v√©rifier. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { other.x += HexMetrics.wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { other.x -= <span class="hljs-number"><span class="hljs-number">2</span></span> * HexMetrics.wrapSize; xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous obtenons toujours la distance la plus courte sur la carte pliable. </font><font style="vertical-align: inherit;">Les fragments de terrain ne sont plus bloqu√©s par une couture, ce qui permet aux masses terrestres de se recroqueviller.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/fb7/3b8/65cfb73b8107d7744ff8cdcabaf48083.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/149/e6f/717/149e6f717defe9288565f37f7efcdf56.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relief repliable correctement sans √©rosion ni √©rosion. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voyager dans le monde </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apr√®s avoir envisag√© la g√©n√©ration et la triangulation de cartes, passons maintenant √† la v√©rification des escouades, de l'exploration et de la visibilit√©. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Couture d'essai </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le premier obstacle que nous rencontrons lors du d√©placement d'une √©quipe dans le monde est le bord de la carte, qui ne peut pas √™tre explor√©. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/4f4/748/4524f4748d2c4e3cb983ec5ecbf064c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La couture de la carte ne peut pas √™tre examin√©e. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les cellules le long du bord de la carte sont rendues inexplor√©es pour masquer l'ach√®vement brutal de la carte. </font><font style="vertical-align: inherit;">Mais lorsque la carte est minimis√©e, seules les cellules nord et sud doivent √™tre marqu√©es, mais pas l'est et l'ouest. </font><font style="vertical-align: inherit;">Modifiez </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour en tenir compte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.Explorable = z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.Explorable = x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibilit√© des reliefs </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V√©rifions maintenant si la visibilit√© fonctionne le long de la couture. </font><font style="vertical-align: inherit;">Cela fonctionne pour le terrain, mais pas pour les objets de terrain. </font><font style="vertical-align: inherit;">Il semble que les objets qui se replient obtiennent la visibilit√© de la derni√®re cellule qui n'a pas √©t√© r√©duite.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/ac1/811/631ac18111ba1eb8dfcf74a39fb2ffbe.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visibilit√© incorrecte des objets. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela se produit car le mode de </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">serrage est d√©fini </font><font style="vertical-align: inherit;">pour le mode de pliage de texture utilis√© </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour r√©soudre le probl√®me, changez simplement son mode de serrage pour r√©p√©ter. </font><font style="vertical-align: inherit;">Mais nous devons faire est seulement de coordonner U, nous √† </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demander </font></font><code>wrapModeU</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>wrapModeV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">individuellement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTexture) { cellTexture.Resize(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; <span class="hljs-comment"><span class="hljs-comment">// cellTexture.wrapMode = TextureWrapMode.Clamp; cellTexture.wrapModeU = TextureWrapMode.Repeat; cellTexture.wrapModeV = TextureWrapMode.Clamp; Shader.SetGlobalTexture("_HexCellData", cellTexture); } ‚Ä¶ }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escouades et colonnes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un autre probl√®me est que les unit√©s ne s'effondrent pas encore. </font><font style="vertical-align: inherit;">Apr√®s avoir d√©plac√© la colonne dans laquelle ils se trouvent, les unit√©s restent au m√™me endroit.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c50/29b/827/c5029b8273d7b53a3ddac2da03d9987f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'unit√© n'est pas transf√©r√©e et est du mauvais c√¥t√©. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce probl√®me peut √™tre r√©solu en faisant des escouades des √©l√©ments enfants de colonnes, comme nous l'avons fait avec des fragments. </font><font style="vertical-align: inherit;">Premi√®rement, nous ne ferons plus d'eux les enfants imm√©diats du r√©seau </font></font><code>HexGrid.AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">// unit.transform.SetParent(transform, false); unit.Location = location; unit.Orientation = orientation; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que les unit√©s se d√©placent, elles peuvent appara√Ætre dans une autre colonne, c'est-√†-dire qu'il sera n√©cessaire de changer leur parent. </font><font style="vertical-align: inherit;">Pour rendre cela possible, nous ajoutons √† la </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode g√©n√©rale </font></font><code>MakeChildOfColumn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et comme param√®tres nous lui passons le composant de l' </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©l√©ment enfant et l'index de la colonne.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeChildOfColumn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Transform child, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> columnIndex</span></span></span><span class="hljs-function">)</span></span> { child.SetParent(columns[columnIndex], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous appellerons cette m√©thode lorsque la propri√©t√© est d√©finie </font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { ‚Ä¶ Grid.MakeChildOfColumn(transform, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.ColumnIndex); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela r√©sout le probl√®me de la cr√©ation d'unit√©s. </font><font style="vertical-align: inherit;">Mais nous devons √©galement les faire passer √† la colonne souhait√©e lors du d√©placement. </font><font style="vertical-align: inherit;">Pour ce faire, vous devez suivre </font></font><code>HexUnit.TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la colonne actuelle </font><font style="vertical-align: inherit;">dans l' </font><font style="vertical-align: inherit;">index. </font><font style="vertical-align: inherit;">Au d√©but de cette m√©thode, il s'agit de l'index de la colonne de cellules au d√©but du chemin, ou de l'actuel si le d√©placement a √©t√© interrompu par recompilation.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Grid.DecreaseVisibility( // currentTravelLocation ? currentTravelLocation : pathToTravel[0], // VisionRange // ); if (!currentTravelLocation) { currentTravelLocation = pathToTravel[0]; } Grid.DecreaseVisibility(currentTravelLocation, VisionRange); int currentColumn = currentTravelLocation.ColumnIndex; ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lors de chaque it√©ration du d√©placement, nous v√©rifierons si l'index de la colonne suivante est diff√©rent, et si c'est le cas, nous changerons le parent de la commande. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentColumn = currentTravelLocation.ColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { ‚Ä¶ Grid.IncreaseVisibility(pathToTravel[i], VisionRange); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextColumn = currentTravelLocation.ColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentColumn != nextColumn) { Grid.MakeChildOfColumn(transform, nextColumn); currentColumn = nextColumn; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela permettra aux unit√©s de se d√©placer de la m√™me mani√®re que les fragments. </font><font style="vertical-align: inherit;">Cependant, lors du d√©placement √† travers la couture de la carte, les unit√©s ne s'effondrent pas encore. </font><font style="vertical-align: inherit;">Au lieu de cela, ils commencent soudainement √† se d√©placer dans la mauvaise direction. </font><font style="vertical-align: inherit;">Cela se produit quel que soit l'emplacement de la couture, mais surtout quand ils sautent sur toute la carte.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Courses de chevaux sur la carte. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, nous pouvons utiliser la m√™me approche que celle utilis√©e pour la c√¥te, mais cette fois, nous allons tourner la courbe le long de laquelle le d√©tachement se d√©place. </font><font style="vertical-align: inherit;">Si la colonne suivante est tourn√©e vers l'est, nous t√©l√©porterons √©galement la courbe vers l'est, de m√™me pour l'autre direction. </font><font style="vertical-align: inherit;">Vous devez modifier les points de contr√¥le de la courbe </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui affectera √©galement le point de contr√¥le </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { currentTravelLocation = pathToTravel[i]; a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; <span class="hljs-comment"><span class="hljs-comment">// c = (b + currentTravelLocation.Position) * 0.5f; // Grid.IncreaseVisibility(pathToTravel[i], VisionRange); int nextColumn = currentTravelLocation.ColumnIndex; if (currentColumn != nextColumn) { if (nextColumn &lt; currentColumn - 1) { ax -= HexMetrics.innerDiameter * HexMetrics.wrapSize; bx -= HexMetrics.innerDiameter * HexMetrics.wrapSize; } else if (nextColumn &gt; currentColumn + 1) { ax += HexMetrics.innerDiameter * HexMetrics.wrapSize; bx += HexMetrics.innerDiameter * HexMetrics.wrapSize; } Grid.MakeChildOfColumn(transform, nextColumn); currentColumn = nextColumn; } c = (b + currentTravelLocation.Position) * 0.5f; Grid.IncreaseVisibility(pathToTravel[i], VisionRange); ‚Ä¶ }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mouvement avec pliage.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La derni√®re chose √† faire est de changer le tour initial de l'escouade lorsqu'elle regarde la premi√®re cellule dans laquelle elle se d√©placera. Si cette cellule se trouve de l'autre c√¥t√© de la couture est-ouest, l'unit√© regardera dans la mauvaise direction. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la r√©duction d'une carte, il existe deux fa√ßons de regarder un point qui n'est pas exactement au nord ou au sud. Vous pouvez regarder √† l'est ou √† l'ouest. Il sera logique de regarder dans la direction correspondant √† la distance la plus proche du point, car c'est √©galement la direction du mouvement, alors utilisons-la </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la r√©duction, nous v√©rifierons la distance relative le long de l'axe X. Si elle est inf√©rieure √† la moiti√© n√©gative de la largeur de la carte, alors nous devrions regarder vers l'ouest, ce qui peut √™tre fait en tournant le point vers l'ouest. </font><font style="vertical-align: inherit;">Sinon, si la distance est sup√©rieure √† la moiti√© de la largeur de la carte, alors nous devons nous effondrer vers l'est.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDistance = point.x - transform.localPosition.x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDistance &lt; -HexMetrics.innerRadius * HexMetrics.wrapSize) { point.x += HexMetrics.innerDiameter * HexMetrics.wrapSize; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDistance &gt; HexMetrics.innerRadius * HexMetrics.wrapSize) { point.x -= HexMetrics.innerDiameter * HexMetrics.wrapSize; } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons donc une carte minimis√©e enti√®rement fonctionnelle. </font><font style="vertical-align: inherit;">Et cela conclut la s√©rie de tutoriels sur les cartes hexagonales. </font><font style="vertical-align: inherit;">Comme mentionn√© dans les sections pr√©c√©dentes, d'autres sujets peuvent √™tre consid√©r√©s, mais ils ne sont pas sp√©cifiques aux cartes hexagonales. </font><font style="vertical-align: inherit;">Je les consid√©rerai peut-√™tre dans de futures s√©ries de tutoriels.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai t√©l√©charg√© le dernier package et j'obtiens des erreurs de tours en mode Play</font></font></b> <div class="spoiler_text">  ,       <em>Rotation</em> .    .  .   5. </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai t√©l√©charg√© le dernier package et les graphismes ne sont pas aussi beaux que dans les captures d'√©cran</font></font></b> <div class="spoiler_text">        . -    . </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai t√©l√©charg√© le dernier paquet et il g√©n√®re constamment la m√™me carte</font></font></b> <div class="spoiler_text">      seed (1208905299),      .    ,  <em>Use Fixed Seed</em> . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427567/">https://habr.com/ru/post/fr427567/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427555/index.html">Les animaux que les humains ont appris √† suivre √† l'aide de la technologie de reconnaissance faciale</a></li>
<li><a href="../fr427557/index.html">R√©sum√© des √©v√©nements informatiques en novembre (premi√®re partie)</a></li>
<li><a href="../fr427561/index.html">Droit de r√©parer: les premiers pas dans la bonne direction de Motorola</a></li>
<li><a href="../fr427563/index.html">Norme SNI crypt√©e impl√©ment√©e dans Firefox Nightly</a></li>
<li><a href="../fr427565/index.html">¬´Ma r√©ussite est que je suis g√©n√©ralement retourn√© √† la profession¬ª - 10 questions au programmeur, num√©ro 10</a></li>
<li><a href="../fr427569/index.html">Ajustez OpenStack sous forte charge</a></li>
<li><a href="../fr427571/index.html">L'union de R et PostgreSQL. Nous analysons le travail des a√©roports, calculons les pensions</a></li>
<li><a href="../fr427573/index.html">Candy or Life: Halloween comme raison pour attirer votre enfant vers la science</a></li>
<li><a href="../fr427575/index.html">Pourquoi le Wi-Fi ne fonctionnera pas comme pr√©vu et pourquoi savoir quel t√©l√©phone l'employ√© utilise</a></li>
<li><a href="../fr427577/index.html">Apprentissage automatique vs analyse de signature lors de la d√©tection d'attaques sur une application Web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>