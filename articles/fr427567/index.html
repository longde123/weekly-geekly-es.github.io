<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚶🏽 🌤️ 🍙 Cartes hexagonales dans Unity: cycle de l'eau, érosion, biomes, carte cylindrique ⏳ 🧚🏾 👨🏽‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parties 1-3: maillage, couleurs et hauteurs de cellule 

 Parties 4-7: bosses, rivières et routes 

 Parties 8-11: eau, reliefs et remparts 

 Parties...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cartes hexagonales dans Unity: cycle de l'eau, érosion, biomes, carte cylindrique</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427567/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 1-3: maillage, couleurs et hauteurs de cellule</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 4-7: bosses, rivières et routes</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 8-11: eau, reliefs et remparts</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 12-15: sauvegarde et chargement, textures, distances</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 16-19: trouver le chemin, équipes de joueurs, animations</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 20-23: Brouillard de guerre, recherche cartographique, génération procédurale</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 24-27: cycle de l'eau, érosion, biomes, carte cylindrique</a> <br><br><h1>  Partie 24: régions et érosion </h1><br><ul><li>  Ajoutez une bordure d'eau autour de la carte. </li><li>  Nous divisons la carte en plusieurs régions. </li><li>  Nous utilisons l'érosion pour couper les falaises. </li><li>  Nous déplaçons le terrain pour lisser le relief. </li></ul><br>  Dans la partie précédente, nous avons jeté les bases de la génération de cartes procédurales.  Cette fois, nous limiterons les lieux d'occurrence possible des terres et agirons sur elles avec l'érosion. <br><br>  Ce didacticiel a été créé dans Unity 2017.1.0. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ac/6a5/30c/5ac6a530cef3718f9031abe862364093.jpg"></div><br>  <i>Séparez et lissez le terrain.</i> <br><a name="habracut"></a><br><h2>  Bordure de la carte </h2><br>  Étant donné que nous augmentons les zones de terrain au hasard, il peut arriver que le terrain touche le bord de la carte.  Cela peut être indésirable.  La carte limitée par l'eau contient une barrière naturelle qui empêche les joueurs de s'approcher du bord.  Par conséquent, ce serait bien si nous interdisions au terrain de s'élever au-dessus du niveau de l'eau près du bord de la carte. <br><br><h3>  Taille de bordure </h3><br>  À quelle distance la terre doit-elle être au bord de la carte?  Il n'y a pas de bonne réponse à cette question, nous allons donc rendre ce paramètre personnalisable.  Nous allons ajouter deux curseurs au composant <code>HexMapGenerator</code> , l'un pour les bordures le long des bords le long de l'axe X, l'autre pour les bordures le long de l'axe Z. Nous pouvons donc utiliser une bordure plus large dans l'une des dimensions, ou même créer une bordure dans une seule dimension.  Utilisons un intervalle de 0 à 10 avec une valeur par défaut de 5. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapBorderX = <span class="hljs-number"><span class="hljs-number">5</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapBorderZ = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/694/8ab/c74/6948abc743e881596bdea5656e562943.png"></div><br>  <i>Curseurs de bordure de carte.</i> <br><br><h3>  Nous limitons les centres des zones terrestres </h3><br>  Sans bordures, toutes les cellules sont valides.  Lorsqu'il existe des limites, les coordonnées de décalage minimales autorisées augmentent et les coordonnées maximales autorisées diminuent.  Puisque pour générer les tracés, nous aurons besoin de connaître l'intervalle autorisé, suivons-le en utilisant quatre champs entiers. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xMin, xMax, zMin, zMax;</code> </pre> <br>  Nous initialisons les contraintes dans <code>GenerateMap</code> avant de créer des sushis.  Nous utilisons ces valeurs comme paramètres pour les appels <code>Random.Range</code> , donc les aigus sont en fait exceptionnels.  Sans bordure, elles sont égales au nombre de cellules de mesure, donc pas moins 1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = waterLevel; } xMin = mapBorderX; xMax = x - mapBorderX; zMin = mapBorderZ; zMax = z - mapBorderZ; CreateLand(); … }</code> </pre> <br>  Nous n'interdirons pas strictement l'apparition de terres au-delà de la frontière de la frontière, car cela créerait des bords fortement coupés.  Au lieu de cela, nous limiterons uniquement les cellules utilisées pour démarrer la génération des tracés.  Autrement dit, les centres approximatifs des sites seront limités, mais certaines parties des sites pourront dépasser la zone frontalière.  Cela peut être fait en modifiant <code>GetRandomCell</code> afin qu'il sélectionne une cellule dans la plage de décalages autorisés. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// return grid.GetCell(Random.Range(0, cellCount)); return grid.GetCell(Random.Range(xMin, xMax), Random.Range(zMin, zMax)); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/bbf/24b/7a8bbf24b1d46d9b97e8e9c01652fdfd.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/0cf/aa2/a310cfaa2bec1cbe019a08c14218c7fd.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f1/799/f50/7f1799f5058c0d1e435bfc3c42133b9c.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93a/c4b/1b7/93ac4b1b771eaa896b6c494b69c18b92.jpg"></div><br>  <i>Les bordures de la carte sont 0 × 0, 5 × 5, 10 × 10 et 0 × 10.</i> <br><br>  Lorsque tous les paramètres de la carte sont définis sur leurs valeurs par défaut, une bordure de taille 5 protégera de manière fiable le bord de la carte contre tout contact avec la terre.  Cependant, ce n'est pas garanti.  Le terrain peut parfois se rapprocher du bord, et parfois le toucher à plusieurs endroits. <br><br>  La probabilité que la terre traverse la frontière entière dépend de la taille de la frontière et de la taille maximale du site.  Sans hésitation, les sections restent des hexagones.  Hexagone complet avec rayon <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>r</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.049ex" height="1.455ex" viewBox="0 -520.7 451.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhiAvzn-bnrj2WYrEhaONwUdviPOZg#MJMATHI-72" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>r</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> r </script>  contient <math></math><img src="https://habrastorage.org/getpro/habr/formulas/d71/5bd/e60/d715bde606fb89c2976f626130a1f29c.svg" alt="3r ^ 2 + 3r + 1 $" data-tex="inline">  les cellules.  S'il y a des hexagones avec un rayon égal à la taille de la frontière, alors ils peuvent la traverser.  Un hexagone complet avec un rayon de 5 contient 91 cellules.  Comme par défaut, le maximum est de 100 cellules par section, cela signifie que la terre pourra poser un pont sur 5 cellules, surtout s'il y a des vibrations.  Pour éviter cela, réduisez la taille maximale du tracé ou augmentez la taille de la bordure. <br><br><div class="spoiler">  <b class="spoiler_title">Comment dérive la formule du nombre de cellules dans la région hexagonale?</b> <div class="spoiler_text">  Avec un rayon de 0, nous avons affaire à une seule cellule.  Il est venu de 1. Avec un rayon de 1 autour du centre, il y a six cellules supplémentaires, soit <math></math><img src="https://habrastorage.org/getpro/habr/formulas/3d5/233/62b/3d523362b8144ab01c2baba35b9f944b.svg" alt="6 $ + 1 $" data-tex="inline">  .  Ces six cellules peuvent être considérées comme les extrémités de six triangles touchant le centre.  Avec un rayon de 2, une deuxième ligne est ajoutée à ces triangles, c'est-à-dire que deux cellules supplémentaires sont obtenues sur le triangle, et au total <math></math><img src="https://habrastorage.org/getpro/habr/formulas/b2c/53c/716/b2c53c716a83a485635ae30c3ef658b6.svg" alt="6 $ (1 + 2) + 1 $" data-tex="inline">  .  Avec un rayon de 3, une troisième ligne est ajoutée, c'est-à-dire trois cellules supplémentaires par triangle, et au total <math></math><img src="https://habrastorage.org/getpro/habr/formulas/e72/090/171/e72090171bfbb337a90a1382abe33aab.svg" alt="6 $ (1 + 2 + 3) + 1 $" data-tex="inline">  .  Et ainsi de suite.  Autrement dit, en termes généraux, la formule ressemble à <math></math><img src="https://habrastorage.org/getpro/habr/formulas/d78/a6a/88e/d78a6a88eb8b1c1ba93a82f2211ab151.svg" alt="6 $ (sum_ (i = 1) ^ ri) +1 = 6 ((r (r + r)) / 2) +1 = 3r (r + 1) + 1 = 3r ^ 2 + 3r + 1 $" data-tex="inline">  . </div></div><br>  Pour voir cela plus clairement, nous pouvons définir la taille de la frontière à 200. Puisqu'un hexagone complet avec un rayon de 8 contient 217 cellules, la terre est susceptible de toucher le bord de la carte.  Au moins si vous utilisez la valeur de taille de bordure par défaut (5).  Si vous augmentez la bordure à 10, la probabilité diminuera considérablement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/75d/eb0/74b75deb060d9bdae2f74c1db4de287e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffa/7ce/e96/ffa7cee967f81ba9fe4ddc6718519d9a.jpg"></div><br>  <i>Le terrain a une taille constante de 200, les limites de la carte sont 5 et 10.</i> <br><br><h3>  Pangaea </h3><br>  Notez que lorsque vous augmentez la bordure de la carte et conservez le même pourcentage de terrain, nous forçons le terrain à former une zone plus petite.  En conséquence, une grande carte par défaut est très susceptible de créer une seule grande masse de terre - le supercontinent Pangaea - éventuellement avec plusieurs petites îles.  Avec une augmentation de la taille de la frontière, la probabilité que cela augmente, et à certaines valeurs, nous sommes presque assurés d'obtenir un supercontinent.  Cependant, lorsque le pourcentage de terrain est trop grand, la plupart des zones disponibles se remplissent et, par conséquent, nous obtenons une masse de terrain presque rectangulaire.  Pour éviter que cela ne se produise, vous devez réduire le pourcentage de terrain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/d84/209/e1bd8420915ccc74cd3470409b9a4236.jpg"></div><br>  <i>Sushi à 40% avec une bordure de carte de 10.</i> <br><br><div class="spoiler">  <b class="spoiler_title">D'où vient le nom Pangea?</b> <div class="spoiler_text">  C'était le nom du dernier supercontinent connu qui existait sur Terre il y a de nombreuses années.  Le nom est composé des mots grecs pan et Gaia, ce qui signifie quelque chose comme «toute la nature» ou «toute la terre». </div></div><br><br><h3>  Nous protégeons des cartes impossibles </h3><br>  Nous générons la bonne quantité de terre en continuant simplement à élever la terre jusqu'à ce que nous atteignions la masse terrestre souhaitée.  Cela fonctionne parce que tôt ou tard nous élèverons chaque cellule au niveau de l'eau.  Cependant, lorsque vous utilisez la bordure de la carte, nous ne pouvons pas atteindre chaque cellule.  Lorsqu'un pourcentage de terrain trop élevé est requis, cela entraînera des «tentatives et des échecs» sans fin du générateur pour élever plus de terrain, et il restera coincé dans un cycle sans fin.  Dans ce cas, l'application se bloquera, mais cela ne devrait pas se produire. <br><br>  Nous ne pouvons pas trouver de manière fiable des configurations impossibles à l'avance, mais nous pouvons nous protéger contre des cycles sans fin.  Nous allons simplement suivre le nombre de cycles exécutés dans <code>CreateLand</code> .  S'il y a trop d'itérations, alors nous sommes très probablement bloqués et devons arrêter. <br><br>  Pour une grande carte, mille itérations semblent acceptables et dix mille itérations semblent déjà absurdes.  Utilisons donc cette valeur comme point de terminaison. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-comment"><span class="hljs-comment">// while (landBudget &gt; 0) { for (int guard = 0; landBudget &gt; 0 &amp;&amp; guard &lt; 10000; guard++) { int chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - 1); … } }</span></span></code> </pre> <br>  Si nous obtenons une carte endommagée, alors 10 000 itérations ne prendront pas beaucoup de temps, car de nombreuses cellules atteindront rapidement la hauteur maximale, ce qui empêchera la croissance de nouvelles zones. <br><br>  Même après avoir rompu la boucle, nous obtenons toujours la bonne carte.  Il n'a tout simplement pas la bonne quantité de terrain et il ne sera pas très intéressant.  Affichez une notification à ce sujet dans la console, nous faisant savoir quel terrain restant nous n'avons pas dépensé. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab5/87f/f4f/ab587ff4f560fe6c1c0d7d5a547ae2b7.jpg"></div><br>  <i>95% des terrains avec une bordure de carte de 10 n'ont pas pu dépenser la totalité du montant.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Pourquoi une carte défaillante a-t-elle encore des variantes?</b> <div class="spoiler_text">  Le littoral présente une variabilité, car lorsque les hauteurs à l'intérieur de la zone de création deviennent trop élevées, de nouvelles zones ne leur permettent pas de croître vers l'extérieur.  Le même principe ne permet pas aux parcelles de se développer sur de petites surfaces jusqu'à ce qu'elles atteignent la hauteur maximale et se révèlent simplement manquantes.  De plus, la variabilité augmente lors de l'abaissement des parcelles. </div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">paquet d'unité</a> <br><br><h2>  Partitionner une carte </h2><br>  Maintenant que nous avons la bordure de la carte, nous avons essentiellement divisé la carte en deux régions distinctes: la région de la frontière et la région où les tracés ont été créés.  Étant donné que seule la région de création est importante pour nous, nous pouvons considérer un tel cas comme une situation avec une seule région.  La région ne couvre tout simplement pas la totalité de la carte.  Mais si cela est impossible, rien ne nous empêche de diviser la carte en plusieurs régions non liées de la création de terres.  Cela permettra aux masses terrestres de se former indépendamment les unes des autres, désignant différents continents. <br><br><h3>  Région de la carte </h3><br>  Commençons par décrire une région de la carte comme une structure.  Cela simplifiera notre travail avec plusieurs régions.  Créons une structure <code>MapRegion</code> pour cela, qui contient simplement les champs de bordure de la région.  Puisque nous n'utiliserons pas cette structure en dehors de <code>HexMapGenerator</code> , nous pouvons la définir à l'intérieur de cette classe comme une structure interne privée.  Ensuite, quatre champs entiers peuvent être remplacés par un champ <code>MapRegion</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// int xMin, xMax, zMin, zMax; struct MapRegion { public int xMin, xMax, zMin, zMax; } MapRegion region;</span></span></code> </pre> <br>  Pour que tout fonctionne, nous devons ajouter le préfixe de <code>region.</code> aux champs minimum-maximum dans <code>GenerateMap</code> <code>region.</code>  . <br><br><pre> <code class="cs hljs"> region.xMin = mapBorderX; region.xMax = x - mapBorderX; region.zMin = mapBorderZ; region.zMax = z - mapBorderZ;</code> </pre> <br>  Et aussi dans <code>GetRandomCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell( Random.Range(region.xMin, region.xMax), Random.Range(region.zMin, region.zMax) ); }</code> </pre> <br><h3>  Plusieurs régions </h3><br>  Pour prendre en charge plusieurs régions, remplacez un champ <code>MapRegion</code> liste de régions. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// MapRegion region; List&lt;MapRegion&gt; regions;</span></span></code> </pre> <br>  À ce stade, il serait intéressant d'ajouter une méthode distincte pour créer des régions.  Il doit créer la liste souhaitée ou l'effacer si elle existe déjà.  Après cela, il déterminera une région, comme nous l'avons fait auparavant, et l'ajoutera à la liste. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRegions</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regions == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { regions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;MapRegion&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { regions.Clear(); } MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); }</code> </pre> <br>  Nous appellerons cette méthode dans <code>GenerateMap</code> et nous ne créerons pas la région directement. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// region.xMin = mapBorderX; // region.xMax = x - mapBorderX; // region.zMin = mapBorderZ; // region.zMax = z - mapBorderZ; CreateRegions(); CreateLand();</span></span></code> </pre> <br>  Pour que <code>GetRandomCell</code> puisse fonctionner avec une région arbitraire, donnez-lui le paramètre <code>MapRegion</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MapRegion region</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell( Random.Range(region.xMin, region.xMax), Random.Range(region.zMin, region.zMax) ); }</code> </pre> <br>  Maintenant, les <code>SinkTerrain</code> <code>RaiseTerraion</code> et <code>SinkTerrain</code> doivent passer la région correspondante à <code>GetRandomCell</code> .  Pour ce faire, chacun d'eux a également besoin d'un paramètre de région. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget, MapRegion region</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell firstCell = GetRandomCell(region); … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SinkTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget, MapRegion region</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell firstCell = GetRandomCell(region); … }</code> </pre> <br>  La méthode <code>CreateLand</code> doit déterminer pour chaque région d'augmenter ou de diminuer les sections.  Pour équilibrer les terres entre les régions, nous allons simplement parcourir à plusieurs reprises la liste des régions du cycle. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; regions.Count; i++) { MapRegion region = regions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability) { landBudget = SinkTerrain(chunkSize, landBudget, region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { landBudget = RaiseTerrain(chunkSize, landBudget, region); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); } }</code> </pre> <br>  Cependant, nous devons encore faire la baisse des parcelles uniformément réparties.  Cela peut être fait en décidant pour toutes les régions s'il faut les omettre. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> sink = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; regions.Count; i++) { MapRegion region = regions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// if (Random.value &lt; sinkProbability) { if (sink) { landBudget = SinkTerrain(chunkSize, landBudget, region); } else { landBudget = RaiseTerrain(chunkSize, landBudget, region); } } }</span></span></code> </pre> <br>  Enfin, afin d'utiliser exactement la totalité du terrain, nous devons arrêter le processus dès que le montant atteint zéro.  Cela peut se produire à n'importe quelle étape du cycle de la région.  Par conséquent, nous déplaçons la vérification à somme nulle dans la boucle intérieure.  En fait, nous ne pouvons effectuer ce contrôle qu'après avoir soulevé un terrain, car lors de l'abaissement, le montant n'est jamais dépensé.  Si nous avons terminé, nous pouvons immédiatement quitter la méthode <code>CreateLand</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// for (int guard = 0; landBudget &gt; 0 &amp;&amp; guard &lt; 10000; guard++) { for (int guard = 0; guard &lt; 10000; guard++) { bool sink = Random.value &lt; sinkProbability; for (int i = 0; i &lt; regions.Count; i++) { MapRegion region = regions[i]; int chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - 1); if (sink) { landBudget = SinkTerrain(chunkSize, landBudget, region); } else { landBudget = RaiseTerrain(chunkSize, landBudget, region); if (landBudget == 0) { return; } } } }</span></span></code> </pre> <br><h3>  Deux régions </h3><br>  Bien que nous ayons désormais le soutien de plusieurs régions, nous n'en demandons toujours qu'une.  <code>CreateRegions</code> les <code>CreateRegions</code> pour qu'il divise la carte en deux verticalement.  Pour ce faire, nous <code>xMax</code> deux la valeur <code>xMax</code> de la région ajoutée.  Ensuite, nous utilisons la même valeur pour <code>xMin</code> et utilisons à nouveau la valeur d'origine pour <code>xMax</code> , en l'utilisant comme deuxième région. <br><br><pre> <code class="cs hljs"> MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region);</code> </pre> <br>  Générer des cartes à ce stade ne fera aucune différence.  Bien que nous ayons identifié deux régions, elles occupent la même région qu'une ancienne région.  Pour les séparer, vous devez laisser un espace vide entre eux.  Cela peut être fait en ajoutant un curseur à la frontière de la région, en utilisant le même intervalle et la même valeur par défaut que pour les frontières de la carte. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> regionBorder = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/cd2/cd0/9ffcd2cd0f4068caf622e433c503715d.png"></div><br>  <i>Curseur de bordure de région.</i> <br><br>  Comme le terrain peut se former de chaque côté de l'espace entre les régions, la probabilité de créer des ponts terrestres aux bords de la carte augmentera.  Pour éviter cela, nous utilisons la frontière de la région pour définir une zone sans terre entre la ligne de division et la région dans laquelle les parcelles peuvent commencer.  Cela signifie que la distance entre les régions voisines est deux fois supérieure à la taille de la frontière de la région. <br><br>  Pour appliquer cette limite de région, soustrayez-la du <code>xMax</code> première région et ajoutez la deuxième région à <code>xMin</code> . <br><br><pre> <code class="cs hljs"> MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e5/1f6/476/1e51f6476894662d55f7ca9748dc7fa5.jpg"></div><br>  <i>La carte est divisée verticalement en deux régions.</i> <br><br>  Avec les paramètres par défaut, deux régions sensiblement séparées seront créées, cependant, comme dans le cas d'une région et d'une grande bordure de carte, nous ne sommes pas garantis de recevoir exactement deux masses terrestres.  Le plus souvent ce sera deux grands continents, éventuellement avec plusieurs îles.  Mais parfois, deux ou plusieurs grandes îles peuvent être créées dans une région.  Et parfois, deux continents peuvent être reliés par un isthme. <br><br>  Bien sûr, nous pouvons également diviser la carte horizontalement, en changeant les approches pour mesurer X et Z. Choisissons au hasard l'une des deux orientations possibles. <br><br><pre> <code class="cs hljs"> MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f23/970/c91/f23970c91cdd9c539ebdc8c7fdbba05f.jpg"></div><br>  <i>Carte horizontalement divisée en deux régions.</i> <br><br>  Puisque nous utilisons une carte large, des régions plus larges et plus minces seront créées avec une séparation horizontale.  En conséquence, ces régions sont plus susceptibles de former plusieurs masses terrestres divisées. <br><br><h3>  Quatre régions </h3><br>  Rendons le nombre de régions personnalisable, créons un support de 1 à 4 régions. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(1, 4)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> regionCount = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/918/49e/2a4/91849e2a4ffe6091b8d4fdf0d78b0c45.png"></div><br>  <i>Curseur pour le nombre de régions.</i> <br><br>  Nous pouvons utiliser l' <code>switch</code> pour sélectionner l'exécution du code de région correspondant.  Nous commençons par répéter le code d'une région, qui sera utilisé par défaut, et laissons le code de deux régions pour le cas 2. <br><br><pre> <code class="cs hljs"> MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce que l'instruction switch?</b> <div class="spoiler_text">  Il s'agit d'une alternative à l'écriture d'une séquence d'instructions if-else-if-else.  est appliqué à la variable et des étiquettes sont utilisées pour indiquer quel code doit être exécuté.  Il existe également une étiquette <code>default</code> , qui est utilisée comme dernier bloc <code>else</code> .  Chaque option doit se terminer par une instruction <code>break</code> ou une <code>return</code> . <br><br>  Pour garder le bloc <code>switch</code> lisible, il est généralement préférable de garder tous les cas courts, idéalement avec une seule instruction ou un appel de méthode.  Je ne ferai pas cela comme un exemple de code de région, mais si vous voulez créer des régions plus intéressantes, je vous recommande d'utiliser des méthodes distinctes.  Par exemple: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: CreateOneRegion(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: CreateTwoRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: CreateThreeRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: CreateFourRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> </div></div><br>  Trois régions sont similaires à deux, seuls les tiers sont utilisés au lieu de la moitié.  Dans ce cas, la division horizontale créera des régions trop étroites, nous avons donc créé un support uniquement pour la division verticale.  Notez qu'en conséquence, nous avons doublé la zone frontalière de la région, de sorte que l'espace pour créer de nouvelles sections est inférieur à celui de deux régions. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: … <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: … <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">3</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">3</span></span> + regionBorder; region.xMax = grid.cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> - regionBorder; regions.Add(region); region.xMin = grid.cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/234/2e7/cc8/2342e7cc8cb524f4f9db803d5359a78e.jpg"></div><br>  <i>Trois régions.</i> <br><br>  Quatre régions peuvent être créées en combinant la séparation horizontale et verticale et en ajoutant une région à chaque coin de la carte. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { … <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/551/b72/a0c/551b72a0ca2f12a5636828faa4c3febc.jpg"></div><br>  <i>Quatre régions.</i> <br><br>  L'approche utilisée ici est le moyen le plus simple de diviser une carte.  Il génère approximativement les mêmes régions en masse de terres, et leur variabilité est contrôlée par d'autres paramètres de génération de cartes.  Cependant, il sera toujours assez évident que la carte a été divisée en lignes droites.  Plus nous avons besoin de contrôle, moins le résultat sera organique.  Par conséquent, c'est normal si vous avez besoin de régions à peu près égales pour le gameplay.  Mais si vous avez besoin du terrain le plus varié et le plus illimité, vous devrez le faire avec l'aide d'une seule région. <br><br>  De plus, il existe d'autres façons de diviser la carte.  Nous ne pouvons pas nous limiter uniquement aux lignes droites.  Nous n'avons même pas besoin d'utiliser des régions de la même taille, ni de couvrir la carte entière avec elles.  Nous pouvons laisser des trous.  Vous pouvez également autoriser les intersections de régions ou modifier la répartition des terres entre les régions.  Vous pouvez même définir vos propres paramètres de générateur pour chaque région (bien que cela soit plus compliqué), par exemple, pour avoir un grand continent et un archipel sur la carte. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">paquet d'unité</a> <br><br><h2>  L'érosion </h2><br>  Jusqu'à présent, toutes les cartes que nous avons générées semblaient plutôt grossières et cassées.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un vrai relief peut ressembler à ceci, mais avec le temps, il devient de plus en plus lisse, ses parties acérées deviennent ternes à cause de l'érosion. </font><font style="vertical-align: inherit;">Pour améliorer les cartes, nous pouvons appliquer ce processus d'érosion. </font><font style="vertical-align: inherit;">Nous le ferons après avoir créé un terrain accidenté, selon une méthode distincte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … CreateRegions(); CreateLand(); ErodeLand(); SetTerrainType(); … } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {}</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pourcentage d'érosion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus le temps passe, plus l'érosion apparaît. </font><font style="vertical-align: inherit;">Par conséquent, nous voulons que l'érosion ne soit pas permanente, mais personnalisable. </font><font style="vertical-align: inherit;">Au minimum, l'érosion est nulle, ce qui correspond aux cartes créées précédemment. </font><font style="vertical-align: inherit;">Au maximum, l'érosion est complète, c'est-à-dire que la poursuite de l'application des forces d'érosion ne changera plus le terrain. </font><font style="vertical-align: inherit;">Autrement dit, le paramètre d'érosion doit être un pourcentage de 0 à 100, et par défaut, nous prendrons 50.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 100)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erosionPercentage = <span class="hljs-number"><span class="hljs-number">50</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/efe/e5e/c4eefee5e18aeee36f16e6aee98a27fe.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curseur d'érosion.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recherche de cellules destructrices d'érosion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'érosion rend le relief plus lisse. Dans notre cas, les seules parties acérées sont les falaises. Ils seront donc la cible du processus d'érosion. Si une falaise existe, l'érosion devrait la réduire jusqu'à ce qu'elle se transforme finalement en pente. Nous ne lisserons pas les pentes, car cela conduira à un terrain ennuyeux. Pour ce faire, nous devons déterminer quelles cellules se trouvent au sommet des falaises et abaisser leur hauteur. Ce seront des cellules sujettes à l'érosion.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créons une méthode qui détermine si une cellule peut être sujette à l'érosion. </font><font style="vertical-align: inherit;">Il le détermine en vérifiant les voisins de la cellule jusqu'à ce qu'il trouve une différence de hauteur suffisamment grande. </font><font style="vertical-align: inherit;">Étant donné que les falaises nécessitent une différence d'au moins un ou deux niveaux de hauteur, la cellule est sujette à l'érosion si un ou plusieurs de ses voisins se trouvent à au moins deux marches en dessous. </font><font style="vertical-align: inherit;">S'il n'y a pas un tel voisin, alors la cellule ne peut pas subir d'érosion.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsErodible</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erodibleElevation = cell.Elevation - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.Elevation &lt;= erodibleElevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons utiliser cette méthode </font></font><code>ErodeLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour parcourir toutes les cellules et écrire toutes les cellules sujettes à l'érosion dans une liste temporaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; erodibleCells = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsErodible(cell)) { erodibleCells.Add(cell); } } ListPool&lt;HexCell&gt;.Add(erodibleCells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une fois que nous connaissons le nombre total de cellules sujettes à l'érosion, nous pouvons utiliser le pourcentage d'érosion pour déterminer le nombre de cellules sujettes à l'érosion restantes. </font><font style="vertical-align: inherit;">Par exemple, si le pourcentage est de 50, alors nous devons érosion des cellules jusqu'à ce que la moitié de la quantité d'origine reste. </font><font style="vertical-align: inherit;">Si le pourcentage est de 100, nous ne nous arrêterons pas tant que nous n'aurons pas détruit toutes les cellules sujettes à l'érosion.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; erodibleCells = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetErodibleCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(erodibleCells.Count * (<span class="hljs-number"><span class="hljs-number">100</span></span> - erosionPercentage) * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); ListPool&lt;HexCell&gt;.Add(erodibleCells); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne devrions-nous pas considérer uniquement les cellules sujettes à l'érosion des terres?</font></font></b> <div class="spoiler_text">     .    ,       ,     . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Réduction cellulaire </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commençons par une approche naïve et supposons qu'une simple réduction de la hauteur des cellules détruites par l'érosion ne la rendra plus sujette à l'érosion. </font><font style="vertical-align: inherit;">Si cela était vrai, nous pourrions simplement prendre des cellules aléatoires dans la liste, réduire leur hauteur, puis les supprimer de la liste. </font><font style="vertical-align: inherit;">Nous répéterions cette opération jusqu'à ce que nous atteignions le nombre souhaité de cellules sensibles à l'érosion.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetErodibleCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(erodibleCells.Count * (<span class="hljs-number"><span class="hljs-number">100</span></span> - erosionPercentage) * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (erodibleCells.Count &gt; targetErodibleCount) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, erodibleCells.Count); HexCell cell = erodibleCells[index]; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; erodibleCells.Remove(cell); } ListPool&lt;HexCell&gt;.Add(erodibleCells);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour empêcher la recherche requise </font></font><code>erodibleCells.Remove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous remplacerons la cellule actuelle en dernier dans la liste, puis supprimerons le dernier élément. </font><font style="vertical-align: inherit;">Nous ne nous soucions toujours pas de leur commande.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// erodibleCells.Remove(cell); erodibleCells[index] = erodibleCells[erodibleCells.Count - 1]; erodibleCells.RemoveAt(erodibleCells.Count - 1);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50e/050/66c/50e05066c444e6854c622b865fde2726.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14d/fca/6b4/14dfca6b41ce23cdeb3e5fc4d5307eba.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diminution naïve de 0% et 100% des cellules sujettes à l'érosion, carte des graines 1957632474.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suivi de l'érosion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre approche naïve nous permet d'appliquer l'érosion, mais pas au bon degré. </font><font style="vertical-align: inherit;">Cela se produit car la cellule après une diminution de hauteur peut toujours rester sujette à l'érosion. </font><font style="vertical-align: inherit;">Par conséquent, nous ne supprimerons une cellule de la liste que lorsqu'elle ne sera plus soumise à l'érosion.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/281/0a9/779/2810a9779b056865ad4490f9b00fa50f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% d'érosion tout en conservant les cellules sujettes à l'érosion dans la liste. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous obtenons donc une érosion beaucoup plus forte, mais lorsque nous utilisons 100%, nous ne nous débarrassons toujours pas de toutes les falaises. </font><font style="vertical-align: inherit;">La raison en est qu'après avoir réduit la hauteur de la cellule, l'un de ses voisins peut devenir sujet à l'érosion. </font><font style="vertical-align: inherit;">Par conséquent, par conséquent, nous pourrions avoir plus de cellules sujettes à l'érosion qu'elles ne l'étaient à l'origine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir abaissé la cellule, nous devons vérifier tous ses voisins. </font><font style="vertical-align: inherit;">Si maintenant ils sont sujets à l'érosion, mais qu'ils ne sont pas encore sur la liste, vous devez les ajouter là-bas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; IsErodible(neighbor) &amp;&amp; !erodibleCells.Contains(neighbor) ) { erodibleCells.Add(neighbor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/894/ed5/b2a894ed5274286b00046050963388f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toutes les cellules érodées sont omises.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous économisons beaucoup de terrain </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, le processus d'érosion peut continuer jusqu'à ce que toutes les falaises disparaissent. Cela affecte grandement la terre. La majeure partie de la masse terrestre a disparu et nous avons obtenu beaucoup moins que le pourcentage de terres nécessaires. Cela s'est produit parce que nous supprimons des terres de la carte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La véritable érosion ne détruit pas la matière. Elle le prend d'un endroit et le place ailleurs. Nous pouvons faire de même. Avec une diminution d'une cellule, nous devons élever l'un de ses voisins. En fait, un niveau de hauteur est transféré dans une cellule inférieure. Cela enregistre la quantité totale de hauteurs de carte, tout en la lissant simplement.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour réaliser cela, nous devons décider où transférer les produits d'érosion. </font><font style="vertical-align: inherit;">Ce sera notre objectif d'érosion. </font><font style="vertical-align: inherit;">Créons une méthode pour déterminer le point cible d'une cellule à éroder. </font><font style="vertical-align: inherit;">Étant donné que cette cellule contient une interruption, il serait logique de sélectionner la cellule située sous cette interruption comme cible. </font><font style="vertical-align: inherit;">Mais une cellule sujette à l'érosion peut avoir plusieurs ruptures, nous allons donc vérifier tous les voisins et mettre tous les candidats sur une liste temporaire, puis nous choisirons l'un d'eux au hasard.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetErosionTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; candidates = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erodibleElevation = cell.Elevation - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.Elevation &lt;= erodibleElevation) { candidates.Add(neighbor); } } HexCell target = candidates[Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, candidates.Count)]; ListPool&lt;HexCell&gt;.Add(candidates); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans </font></font><code>ErodeLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous définissons la cellule cible immédiatement après avoir sélectionné la cellule d'érosion. </font><font style="vertical-align: inherit;">Ensuite, nous diminuons et augmentons immédiatement la hauteur des cellules. </font><font style="vertical-align: inherit;">Dans ce cas, la cellule cible elle-même peut devenir sensible à l'érosion, mais cette situation est résolue lorsque nous vérifions les voisins de la cellule nouvellement érodée.</font></font><br><br><pre> <code class="cs hljs"> HexCell cell = erodibleCells[index]; HexCell targetCell = GetErosionTarget(cell); cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; targetCell.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depuis que nous avons élevé la cellule cible, une partie des voisins de cette cellule peut ne plus être soumise à l'érosion. </font><font style="vertical-align: inherit;">Il faut les contourner et vérifier s'ils sont sujets à l'érosion. </font><font style="vertical-align: inherit;">Sinon, mais ils sont dans la liste, vous devez les supprimer.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); … } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; !IsErodible(neighbor) &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d71/84f/0b4/d7184f0b4a2dd34853b56e0024ef2b6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% d'érosion tout en maintenant la masse terrestre. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'érosion peut maintenant lisser le terrain beaucoup mieux, en abaissant certaines zones et en soulevant d'autres. </font><font style="vertical-align: inherit;">En conséquence, la masse de terre peut à la fois augmenter et rétrécir. </font><font style="vertical-align: inherit;">Cela peut modifier le pourcentage de terres de plusieurs pour cent dans un sens ou dans un autre, mais de graves écarts se produisent rarement. </font><font style="vertical-align: inherit;">Autrement dit, plus nous appliquons d'érosion, moins nous aurons de contrôle sur le pourcentage de terres qui en résulte.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Érosion accélérée </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous n'ayons pas vraiment besoin de nous soucier de l'efficacité de l'algorithme d'érosion, nous pouvons y apporter des améliorations simples. </font><font style="vertical-align: inherit;">Tout d'abord, notez que nous vérifions explicitement si la cellule que nous avons érodée peut être érodée. </font><font style="vertical-align: inherit;">Sinon, nous le supprimons essentiellement de la liste. </font><font style="vertical-align: inherit;">Par conséquent, vous pouvez ignorer la vérification de cette cellule lors de la traversée des voisins de la cellule cible.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor != cell &amp;&amp; !IsErodible(neighbor) &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxièmement, nous devions vérifier les voisins de la cellule cible uniquement lorsqu'il y avait une rupture entre eux, mais maintenant ce n'est plus nécessaire. </font><font style="vertical-align: inherit;">Cela ne se produit que lorsque le voisin est maintenant un cran plus haut que la cellule cible. </font><font style="vertical-align: inherit;">Si c'est le cas, le voisin est garanti d'être sur la liste, nous n'avons donc pas besoin de vérifier cela, c'est-à-dire que nous pouvons ignorer la recherche inutile.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor != cell &amp;&amp; neighbor.Elevation == targetCell.Elevation + <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !IsErodible(neighbor) <span class="hljs-comment"><span class="hljs-comment">// &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Troisièmement, nous pouvons utiliser une astuce similaire lors de la vérification des voisins d'une cellule sujette à l'érosion. </font><font style="vertical-align: inherit;">S'il y a maintenant une falaise entre eux, alors le voisin est sujet à l'érosion. </font><font style="vertical-align: inherit;">Pour le savoir, nous n'avons pas besoin d'appeler </font></font><code>IsErodible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor.Elevation == cell.Elevation + <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">// IsErodible(neighbor) &amp;&amp; !erodibleCells.Contains(neighbor) ) { erodibleCells.Add(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, nous devons encore vérifier si la cellule cible est sensible à l'érosion, mais le cycle illustré ci-dessus ne le fait plus. </font><font style="vertical-align: inherit;">Par conséquent, nous effectuons cela explicitement pour la cellule cible.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsErodible(targetCell) &amp;&amp; !erodibleCells.Contains(targetCell)) { erodibleCells.Add(targetCell); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons appliquer l'érosion assez rapidement et au pourcentage souhaité par rapport au nombre initial de falaises générées. </font><font style="vertical-align: inherit;">Notez que du fait que nous avons légèrement changé l'endroit où la cellule cible est ajoutée à la liste sujette à l'érosion, le résultat a légèrement changé par rapport au résultat avant optimisations.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a6/a0d/71e/4a6a0d71eea3d1ef119b2f4f984a9b99.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28d/979/289/28d9792899367fdccb50f36b79801935.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7af/921/6af/7af9216af64111dbe0c15898db4560ce.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31b/7d9/ae5/31b7d9ae505297269bbd5442fdff17c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25%, 50%, 75% et 100% d'érosion. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez également que malgré la forme modifiée de la côte, la topologie n'a pas fondamentalement changé. </font><font style="vertical-align: inherit;">Les masses terrestres restent généralement connectées ou séparées. </font><font style="vertical-align: inherit;">Seules les petites îles peuvent se noyer complètement. </font><font style="vertical-align: inherit;">Les détails en relief sont lissés, mais les formes générales restent les mêmes. </font><font style="vertical-align: inherit;">Une articulation étroite peut disparaître ou grossir un peu. </font><font style="vertical-align: inherit;">Un petit espace peut se remplir ou se dilater légèrement. </font><font style="vertical-align: inherit;">Par conséquent, l'érosion ne collera pas fortement les régions divisées.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cd/c53/824/2cdc53824832438c924e2832d9759b06.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quatre régions complètement érodées restent séparées. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 25: Le cycle de l'eau </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Affichez les données cartographiques brutes. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous formons un climat de cellules. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Créez une simulation partielle du cycle de l'eau. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette partie, nous ajouterons de l'humidité sur terre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce didacticiel a été créé dans Unity 2017.3.0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ae/fbe/dae/2aefbedae7b2c65cd86bbd2b4ccc3050.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons le cycle de l'eau pour déterminer les biomes.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les nuages </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'à présent, l'algorithme de génération de carte ne modifiait que la hauteur des cellules. </font><font style="vertical-align: inherit;">La plus grande différence entre les cellules était de savoir si elles étaient au-dessus ou au-dessous de l'eau. </font><font style="vertical-align: inherit;">Bien que nous puissions définir différents types de terrain, ce n'est qu'une simple visualisation de la hauteur. </font><font style="vertical-align: inherit;">Il sera préférable de préciser les types de relief, compte tenu du climat local. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le climat de la Terre est un système très complexe. </font><font style="vertical-align: inherit;">Heureusement, nous n'avons pas besoin de créer des simulations climatiques réalistes. </font><font style="vertical-align: inherit;">Nous aurons besoin de quelque chose d'assez naturel. </font><font style="vertical-align: inherit;">L'aspect le plus important du climat est le cycle de l'eau, car la flore et la faune ont besoin d'eau liquide pour survivre. </font><font style="vertical-align: inherit;">La température est également très importante, mais pour l'instant, nous nous concentrons sur l'eau, laissant essentiellement la température globale constante et ne modifiant que l'humidité.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le cycle de l'eau décrit le mouvement de l'eau dans l'environnement. </font><font style="vertical-align: inherit;">Autrement dit, les étangs s'évaporent, ce qui conduit à la création de nuages ​​qui pleuvent, qui se jettent à nouveau dans les étangs. </font><font style="vertical-align: inherit;">Le système comporte de nombreux autres aspects, mais la simulation de ces étapes peut déjà être suffisante pour créer une distribution naturelle de l'eau sur la carte.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualisation des données </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant d'entrer dans cette simulation, il sera utile de voir directement les données pertinentes. </font><font style="vertical-align: inherit;">Pour ce faire, nous allons changer le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nous lui ajoutons une propriété commutable, qui peut être commutée en mode de visualisation des données, qui affiche des données cartographiques brutes au lieu des textures de relief habituelles. </font><font style="vertical-align: inherit;">Cela peut être implémenté à l'aide d'une propriété float avec un attribut commutable qui définit le mot-clé. </font><font style="vertical-align: inherit;">Pour cette raison, il apparaîtra dans l'inspecteur des matériaux comme un indicateur qui contrôle la définition d'un mot-clé. </font><font style="vertical-align: inherit;">Le nom du bien lui-même n'a pas d'importance, nous ne nous intéressons qu'au mot-clé. </font><font style="vertical-align: inherit;">Nous utilisons </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHOW_MAP_DATA</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) _BackgroundColor (<span class="hljs-string"><span class="hljs-string">"Background Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) [Toggle(SHOW_MAP_DATA)] _ShowMapData (<span class="hljs-string"><span class="hljs-string">"Show Map Data"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/32b/3e0/45232b3e0a72da1320457492c006613c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basculez pour afficher les données cartographiques. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez une fonction de shader pour activer la prise en charge des mots clés.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ GRID_ON #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ HEX_MAP_EDIT_MODE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> shader_feature SHOW_MAP_DATA</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons lui faire afficher un seul flottant, comme c'est le cas avec le reste des données de relief. </font><font style="vertical-align: inherit;">Pour l'implémenter, nous ajouterons un </font></font><code>Input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">champ </font><font style="vertical-align: inherit;">à la structure </font></font><code>mapData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsque le mot clé sera défini.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">struct</span></span> Input { <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> color : COLOR; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> worldPos; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> terrain; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> visibility; <span class="hljs-comment"><span class="hljs-comment">#if defined(SHOW_MAP_DATA) float mapData; #endif };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le programme vertex, nous utilisons le canal Z de ces cellules pour remplir </font></font><code>mapData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, comme toujours interpolé entre les cellules.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inout appdata_full v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Input data</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(SHOW_MAP_DATA) data.mapData = cell0.z * v.color.x + cell1.z * v.color.y + cell2.z * v.color.z; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous devez afficher des données de cellule, utilisez-les directement comme fragment d'albédo au lieu de la couleur habituelle. </font><font style="vertical-align: inherit;">Multipliez-le par la grille afin que la grille soit toujours activée lors du rendu des données.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { … o.Albedo = c.rgb * grid * _Color * explored; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(SHOW_MAP_DATA) o.Albedo = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.mapData * grid; #endif … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour transférer réellement des données vers un shader. </font><font style="vertical-align: inherit;">nous devons ajouter à la </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthode qui écrit quelque chose sur le canal de données de texture bleue. </font><font style="vertical-align: inherit;">Les données sont une valeur flottante unique limitée à 0–1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMapData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].b = data &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (data &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(data * <span class="hljs-number"><span class="hljs-number">255f</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span>); enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, cette décision affecte le système de recherche. </font><font style="vertical-align: inherit;">Une valeur de données de canal bleu 255 est utilisée pour indiquer que la visibilité des cellules est en transition. </font><font style="vertical-align: inherit;">Pour que ce système continue de fonctionner, nous devons utiliser au maximum la valeur d'octet 254. Notez que le mouvement du détachement effacera toutes les données de la carte, mais cela nous convient, car elles sont utilisées pour déboguer la génération de cartes.</font></font><br><br><pre> <code class="cs hljs"> cellTextureData[cell.Index].b = data &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (data &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(data * <span class="hljs-number"><span class="hljs-number">254f</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">254</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez une méthode avec le même nom et dans </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il transférera la demande dans ses données de shader.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMapData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { ShaderData.SetMapData(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour vérifier le fonctionnement du code, nous le modifions </font></font><code>HexMapGenerator.SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin qu'il définit les données de chaque cellule de la carte. </font><font style="vertical-align: inherit;">Visualisons la hauteur convertie de l'entier en flottant dans l'intervalle 0–1. </font><font style="vertical-align: inherit;">Cela se fait en soustrayant la hauteur minimale de la hauteur de la cellule, puis en divisant par la hauteur maximale moins le minimum. </font><font style="vertical-align: inherit;">Faisons la division en virgule flottante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … cell.SetMapData( (cell.Elevation - elevationMinimum) / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(elevationMaximum - elevationMinimum) ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant basculer entre le terrain normal et la visualisation des données à l'aide de la </font><font style="vertical-align: inherit;">case à cocher </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afficher les données cartographiques</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de l'actif matériel </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/577/473/f28/577473f28d08f986124e6459a13a3714.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/c8a/85a/d60c8a85ae315fd509a4f6451629d8dc.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carte 1208905299, terrain normal et visualisation des hauteurs.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Création du climat </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour simuler le climat, nous devons suivre les données climatiques. </font><font style="vertical-align: inherit;">La carte étant constituée de cellules discrètes, chacune d'elles a son propre climat local. </font><font style="vertical-align: inherit;">Créez une structure </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour stocker toutes les données pertinentes. </font><font style="vertical-align: inherit;">Bien sûr, vous pouvez ajouter des données aux cellules elles-mêmes, mais nous ne les utiliserons que lors de la génération de la carte. </font><font style="vertical-align: inherit;">Par conséquent, nous les enregistrerons séparément. </font><font style="vertical-align: inherit;">Cela signifie que nous pouvons définir cette structure en interne </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, comme </font></font><code>MapRegion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous commencerons par suivre uniquement les nuages, qui peuvent être implémentés à l'aide d'un seul champ flottant.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClimateData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clouds; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajoutez une liste pour suivre les données climatiques de toutes les cellules. </font></font><br><br><pre> <code class="cs hljs"> List&lt;ClimateData&gt; climate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous avons besoin d'une méthode pour créer une carte climatique. </font><font style="vertical-align: inherit;">Il doit commencer par effacer la liste des zones climatiques, puis ajouter un élément pour chaque cellule. </font><font style="vertical-align: inherit;">Les données climatiques initiales sont tout simplement nulles, cela peut être réalisé en utilisant un constructeur standard </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { climate.Clear(); ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le climat doit être créé après une exposition à l'érosion des terres avant de définir les types de relief. </font><font style="vertical-align: inherit;">En réalité, l'érosion est principalement causée par le mouvement de l'air et de l'eau, qui font partie du climat, mais nous ne simulerons pas cela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … CreateRegions(); CreateLand(); ErodeLand(); CreateClimate(); SetTerrainType(); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin que nous puissions voir les données du nuage au lieu de la hauteur des cellules. </font><font style="vertical-align: inherit;">Initialement, il ressemblera à une carte noire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … cell.SetMapData(climate[i].clouds); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Changement climatique </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La première étape de la simulation climatique est l'évaporation. </font><font style="vertical-align: inherit;">Quelle quantité d'eau devrait s'évaporer? </font><font style="vertical-align: inherit;">Contrôlons cette valeur à l'aide du curseur. </font><font style="vertical-align: inherit;">Une valeur de 0 signifie aucune évaporation, 1 - évaporation maximale. </font><font style="vertical-align: inherit;">Par défaut, nous utilisons 0,5.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporation = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6af/d8e/ae8/6afd8eae8a1bbb6be361c29d32cc5b99.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curseur d'évaporation. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créons une autre méthode spécifiquement pour façonner le climat d'une cellule. </font><font style="vertical-align: inherit;">Nous lui donnons l'indice de cellule comme paramètre et nous l'utilisons pour obtenir la cellule correspondante et ses données climatiques. </font><font style="vertical-align: inherit;">Si la cellule est sous l'eau, il s'agit alors d'un réservoir qui doit s'évaporer. </font><font style="vertical-align: inherit;">Nous transformons immédiatement la vapeur en nuages ​​(en ignorant les points de rosée et la condensation), nous ajouterons donc directement l'évaporation à la valeur des nuages ​​cellulaires. </font><font style="vertical-align: inherit;">Lorsque vous avez terminé, copiez les données climatiques dans la liste.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EvolveClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cellIndex</span></span></span><span class="hljs-function">)</span></span> { HexCell cell = grid.GetCell(cellIndex); ClimateData cellClimate = climate[cellIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } climate[cellIndex] = cellClimate; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appelez cette méthode pour chaque cellule </font></font><code>CreateClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais cela ne suffit pas. </font><font style="vertical-align: inherit;">Pour créer une simulation complexe, nous devons façonner le climat des cellules plusieurs fois. </font><font style="vertical-align: inherit;">Plus nous le faisons souvent, meilleur sera le résultat. </font><font style="vertical-align: inherit;">Choisissons simplement une valeur constante. </font><font style="vertical-align: inherit;">J'utilise 40 cycles.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; cycle &lt; <span class="hljs-number"><span class="hljs-number">40</span></span>; cycle++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Depuis, alors que nous n'augmentons que la valeur des nuages ​​au-dessus des cellules inondées d'eau, nous obtenons ainsi des terres noires et des réservoirs blancs. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e7/e1c/5dc/3e7e1c5dc9ce75197a94e8ffcd6d8275.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evaporation sur l'eau.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diffusion des nuages </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les nuages ​​ne sont pas constamment au même endroit, surtout lorsque de plus en plus d'eau s'évapore. </font><font style="vertical-align: inherit;">La différence de pression fait bouger l'air, qui se manifeste sous forme de vent, ce qui fait aussi bouger les nuages. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S'il n'y a pas de direction dominante du vent, alors en moyenne les nuages ​​de cellules se disperseront uniformément dans toutes les directions, apparaissant dans les cellules voisines. </font><font style="vertical-align: inherit;">Lors de la génération de nouveaux nuages ​​dans le cycle suivant, répartissons tous les nuages ​​de la cellule dans ses voisins. </font><font style="vertical-align: inherit;">Autrement dit, chaque voisin reçoit un sixième des nuages ​​de cellules, après quoi il y a une diminution locale à zéro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); cellClimate.clouds = <span class="hljs-number"><span class="hljs-number">0f</span></span>; climate[cellIndex] = cellClimate;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour ajouter des nuages ​​à vos voisins, vous devez les contourner en boucle, obtenir leurs données climatiques, augmenter la valeur des nuages ​​et les recopier dans la liste. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = climate[neighbor.Index]; neighborClimate.clouds += cloudDispersal; climate[neighbor.Index] = neighborClimate; } cellClimate.clouds = <span class="hljs-number"><span class="hljs-number">0f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6a/0e3/437/e6a0e34379d984582c020fde8f1db546.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuages ​​épars.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cela crée une carte presque blanche, car à chaque cycle, les cellules sous-marines ajoutent de plus en plus de nuages ​​au climat mondial. Après le premier cycle, les cellules terrestres à côté de l'eau auront également des nuages ​​qui doivent être dispersés. Ce processus se poursuit jusqu'à ce que la majeure partie de la carte soit couverte de nuages. Dans le cas de la carte 1208905299 avec les paramètres par défaut, seul l'intérieur de la grande masse de terrain dans le nord-est est resté complètement découvert.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que les étangs peuvent générer un nombre infini de nuages. </font><font style="vertical-align: inherit;">Le niveau d'eau ne fait pas partie de la simulation climatique. </font><font style="vertical-align: inherit;">En réalité, les réservoirs ne sont préservés que parce que l'eau y retourne à peu près au rythme de l'évaporation. </font><font style="vertical-align: inherit;">Autrement dit, nous ne simulons qu'un cycle partiel de l'eau. </font><font style="vertical-align: inherit;">C'est normal, mais il faut comprendre que plus la simulation se déroule, plus l'eau est ajoutée au climat. </font><font style="vertical-align: inherit;">Jusqu'à présent, la perte d'eau ne se produit que sur les bords de la carte, où les nuages ​​dispersés sont perdus en raison du manque de voisins. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez voir la perte d'eau en haut de la carte, en particulier dans les cellules en haut à droite. </font><font style="vertical-align: inherit;">Dans la dernière cellule, il n'y a pas de nuages ​​du tout, car il reste la dernière dans laquelle le climat se forme. </font><font style="vertical-align: inherit;">Elle n'a pas encore reçu de nuages ​​d'un voisin.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le climat de toutes les cellules ne devrait-il pas se former en parallèle?</font></font></b> <div class="spoiler_text"> ,        .    -              ,         .   40    . -      ,       . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Précipitations </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'eau ne reste pas froide pour toujours. À un moment donné, elle devrait retomber au sol. Cela se produit généralement sous forme de pluie, mais parfois il peut s'agir de neige, de grêle ou de neige mouillée. Tout cela s'appelle généralement précipitation. L'ampleur et le taux de disparition des nuages ​​varient considérablement, mais nous utilisons simplement un taux de pluie mondial personnalisé. Une valeur de 0 signifie aucune précipitation, une valeur de 1 signifie que tous les nuages ​​disparaissent instantanément. La valeur par défaut est 0,25. Cela signifie qu'à chaque cycle, un quart des nuages ​​disparaîtra.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitationFactor = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/762/37d/f9076237d0673301af34c32f5cd6688a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curseur de coefficient de précipitation. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous simulerons les précipitations après évaporation et avant la diffusion des nuages. </font><font style="vertical-align: inherit;">Cela signifie qu'une partie de l'eau évaporée des réservoirs précipite immédiatement, de sorte que le nombre de nuages ​​dispersés diminue. </font><font style="vertical-align: inherit;">Sur terre, les précipitations entraîneront la disparition des nuages.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e3/f11/46a/4e3f1146a761d1525e6a9349ff715bbb.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des nuages ​​qui disparaissent. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, lorsque nous détruisons 25% des nuages ​​à chaque cycle, la terre redevient presque noire. </font><font style="vertical-align: inherit;">Les nuages ​​ne parviennent à se déplacer vers l'intérieur des terres qu'en quelques étapes, après quoi ils deviennent invisibles. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2>  Humidité </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que les précipitations détruisent les nuages, elles ne doivent pas éliminer l'eau du climat. </font><font style="vertical-align: inherit;">Après être tombée au sol, l'eau est économisée, uniquement dans un état différent. </font><font style="vertical-align: inherit;">Il peut exister sous de nombreuses formes, que nous considérerons généralement comme de l'humidité.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suivi de l'humidité </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons améliorer le modèle climatique en suivant deux conditions de l'eau: les nuages ​​et l'humidité. </font><font style="vertical-align: inherit;">Pour implémenter cela, ajoutez dans le </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">champ </font></font><code>moisture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClimateData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clouds, moisture; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans sa forme la plus généralisée, l'évaporation est le processus de conversion de l'humidité en nuages, du moins dans notre modèle climatique simple. </font><font style="vertical-align: inherit;">Cela signifie que l'évaporation ne doit pas être une valeur constante, mais un autre facteur. </font><font style="vertical-align: inherit;">Par conséquent, nous effectuons le refactoring-renommage </font></font><code>evaporation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>evaporationFactor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporationFactor = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque la cellule est sous l'eau, nous annonçons simplement que le taux d'humidité est 1. Cela signifie que l'évaporation est égale au coefficient d'évaporation. </font><font style="vertical-align: inherit;">Mais maintenant, nous pouvons également obtenir l'évaporation des cellules de sushi. </font><font style="vertical-align: inherit;">Dans ce cas, nous devons calculer l'évaporation, la soustraire de l'humidité et ajouter le résultat aux nuages. </font><font style="vertical-align: inherit;">Après cela, les précipitations sont ajoutées à l'humidité.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.moisture = <span class="hljs-number"><span class="hljs-number">1f</span></span>; cellClimate.clouds += evaporationFactor; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporation = cellClimate.moisture * evaporationFactor; cellClimate.moisture -= evaporation; cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; cellClimate.moisture += precipitation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que les nuages ​​sont maintenant soutenus par l'évaporation de la terre, nous pouvons les déplacer plus à l'intérieur des terres. </font><font style="vertical-align: inherit;">Maintenant, la majeure partie de la terre est devenue grise.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/94f/c71/a0b94fc71728a012254059d760bf47f3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuages ​​avec évaporation de l'humidité. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifions-le </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il affiche l'humidité au lieu des nuages, car nous allons l'utiliser pour déterminer les types de relief.</font></font><br><br><pre> <code class="cs hljs"> cell.SetMapData(climate[i].moisture);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cf/78f/d30/3cf78fd3099cf1b3a75befb8ebb0893d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Affichage de l'humidité. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À ce stade, l'humidité ressemble assez aux nuages ​​(sauf que toutes les cellules sous-marines sont blanches), mais cela changera bientôt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ruissellement pluvial </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'évaporation n'est pas le seul moyen par lequel l'humidité peut quitter la cellule. </font><font style="vertical-align: inherit;">Le cycle de l'eau nous dit que la majeure partie de l'humidité ajoutée à la terre se retrouve en quelque sorte dans l'eau. </font><font style="vertical-align: inherit;">Le processus le plus notable est l'écoulement de l'eau sur la terre sous l'influence de la gravité. </font><font style="vertical-align: inherit;">Nous ne simulerons pas de vraies rivières, mais utiliserons un coefficient de ruissellement des précipitations personnalisé. </font><font style="vertical-align: inherit;">Il indiquera le pourcentage d'eau s'écoulant vers les zones inférieures. </font><font style="vertical-align: inherit;">Par défaut, le stock sera égal à 25%.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoffFactor = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c85/e81/648/c85e8164833b60299f80bba99c11be81.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curseur de vidange.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne générerons pas de rivières?</font></font></b> <div class="spoiler_text">          . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le ruissellement de l'eau agit comme une dispersion des nuages, mais avec trois différences. Premièrement, toute l'humidité n'est pas éliminée de la cellule. Deuxièmement, il transporte l'humidité, pas les nuages. Troisièmement, il ne descend, c'est-à-dire qu'aux voisins de hauteur inférieure. Le coefficient de ruissellement décrit la quantité d'humidité qui s'écoulerait de la cellule si tous les voisins étaient inférieurs, mais souvent ils sont moindres. Cela signifie que nous ne réduirons l'humidité des cellules que lorsque nous trouverons un voisin ci-dessous.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoff = cellClimate.moisture * runoffFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = climate[neighbor.Index]; neighborClimate.clouds += cloudDispersal; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.Elevation - cell.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= runoff; neighborClimate.moisture += runoff; } climate[neighbor.Index] = neighborClimate; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a25/c41/00b/a25c4100bde5139415ebbf0a45068d0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'eau s'écoule à une hauteur inférieure. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En conséquence, nous avons une distribution plus diversifiée de l'humidité, car les cellules élevées transmettent leur humidité à l'inférieur. </font><font style="vertical-align: inherit;">Nous voyons également beaucoup moins d'humidité dans les cellules côtières, car elles drainent l'humidité dans les cellules sous-marines. </font><font style="vertical-align: inherit;">Pour affaiblir cet effet, nous devons également utiliser le niveau d'eau pour déterminer si la cellule est plus basse, c'est-à-dire prendre la hauteur apparente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.ViewElevation - cell.ViewElevation;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/651/ee9/64d/651ee964da5a422bfaa94f27609a5dcd.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisez la hauteur visible.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seepage </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Non seulement l'eau coule, elle se répand, s'infiltre à travers la topographie plane et est absorbée par le terrain adjacent aux plans d'eau. </font><font style="vertical-align: inherit;">Cet effet peut avoir peu d'effet, mais il est utile pour lisser la distribution de l'humidité, alors ajoutons-le à la simulation. </font><font style="vertical-align: inherit;">Créons-lui son propre coefficient personnalisé, par défaut égal à 0,125.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seepageFactor = <span class="hljs-number"><span class="hljs-number">0.125f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/495/855/b73/495855b73d4601ab3de00b3561285491.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curseur de fuite. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le suintement est similaire à un drain, sauf qu'il est utilisé lorsque le voisin a la même hauteur visible que la cellule elle-même.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoff = cellClimate.moisture * runoffFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seepage = cellClimate.moisture * seepageFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.ViewElevation - cell.ViewElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= runoff; neighborClimate.moisture += runoff; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= seepage; neighborClimate.moisture += seepage; } climate[neighbor.Index] = neighborClimate; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d39/7b2/b01/d397b2b01ad8e71137b9e5fa03fcf5a5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajout d'une petite fuite. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ombres de pluie </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous ayons déjà créé une simulation digne du cycle de l'eau, elle ne semble pas très intéressante, car elle n'a pas d'ombres de pluie, ce qui démontre le plus clairement les différences climatiques. </font><font style="vertical-align: inherit;">Les ombres pluviales sont des zones dans lesquelles il y a un manque important de précipitations par rapport aux zones voisines. </font><font style="vertical-align: inherit;">Ces zones existent parce que les montagnes empêchent les nuages ​​de les atteindre. </font><font style="vertical-align: inherit;">Leur création nécessite de hautes montagnes et une direction de vent dominante.</font></font><br><br><h3>  Le vent </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commençons par ajouter une direction de vent dominante à la simulation. </font><font style="vertical-align: inherit;">Bien que les directions dominantes du vent varient considérablement à la surface de la Terre, nous nous en sortirons avec une direction mondiale du vent personnalisable. </font><font style="vertical-align: inherit;">Utilisons le nord-ouest par défaut. </font><font style="vertical-align: inherit;">De plus, rendons la force du vent réglable de 1 à 10 avec une valeur par défaut de 4.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection windDirection = HexDirection.NW; [Range(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> windStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f32/4a1/49c/f324a149c360bbfde72e98b4877afb37.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La direction et la force du vent. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La force du vent dominant est exprimée par rapport à la dispersion totale des nuages. </font><font style="vertical-align: inherit;">Si la force du vent est de 1, la diffusion est la même dans toutes les directions. </font><font style="vertical-align: inherit;">Lorsqu'il est de 2, la diffusion est deux fois plus élevée dans la direction du vent que dans les autres directions, et ainsi de suite. </font><font style="vertical-align: inherit;">Nous pouvons le faire en modifiant le diviseur dans la formule de dispersion des nuages. </font><font style="vertical-align: inherit;">Au lieu de six, il sera égal à cinq plus l'énergie éolienne.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / (<span class="hljs-number"><span class="hljs-number">5f</span></span> + windStrength));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, la direction du vent détermine la direction à partir de laquelle le vent souffle. </font><font style="vertical-align: inherit;">Par conséquent, nous devons utiliser la direction opposée comme direction principale de diffusion.</font></font><br><br><pre> <code class="cs hljs"> HexDirection mainDispersalDirection = windDirection.Opposite(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / (<span class="hljs-number"><span class="hljs-number">5f</span></span> + windStrength));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant vérifier si le voisin est dans la direction principale de diffusion. </font><font style="vertical-align: inherit;">Si c'est le cas, alors nous devons multiplier la dispersion des nuages ​​par la force du vent.</font></font><br><br><pre> <code class="cs hljs"> ClimateData neighborClimate = climate[neighbor.Index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d == mainDispersalDirection) { neighborClimate.clouds += cloudDispersal * windStrength; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { neighborClimate.clouds += cloudDispersal; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7e/874/2d5/e7e8742d53033ee4ee89f68e60871426.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vent du nord-ouest, force 4.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le vent dominant ajoute une direction à la distribution de l'humidité sur la terre. </font><font style="vertical-align: inherit;">Plus le vent est fort, plus l'effet devient puissant.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hauteur absolue </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le deuxième ingrédient pour obtenir des ombres de pluie est la montagne. Nous n'avons pas de classification stricte de ce qu'est une montagne, tout comme la nature ne l'a pas non plus. Seule la hauteur absolue est importante. En fait, lorsque l'air se déplace au-dessus de la montagne, il est forcé de s'élever, est refroidi et peut contenir moins d'eau, ce qui conduit à des précipitations avant que l'air ne passe au-dessus de la montagne. Par conséquent, de l'autre côté, nous obtenons de l'air sec, c'est-à-dire une ombre de pluie.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus important encore, plus l'air monte, moins il peut contenir d'eau. </font><font style="vertical-align: inherit;">Dans notre simulation, nous pouvons imaginer cela comme une restriction forcée de la valeur maximale du nuage pour chaque cellule. </font><font style="vertical-align: inherit;">Plus la hauteur de cellule visible est élevée, plus ce maximum doit être bas. </font><font style="vertical-align: inherit;">La façon la plus simple de procéder consiste à définir le maximum sur 1 moins la hauteur apparente, divisé par la hauteur maximale. </font><font style="vertical-align: inherit;">Mais en fait, divisons par un maximum de moins 1. Cela permettra à une petite fraction des nuages ​​de traverser même les cellules les plus hautes. </font><font style="vertical-align: inherit;">Nous attribuons ce maximum après calcul des précipitations et avant diffusion.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; cellClimate.moisture += precipitation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudMaximum = <span class="hljs-number"><span class="hljs-number">1f</span></span> - cell.ViewElevation / (elevationMaximum + <span class="hljs-number"><span class="hljs-number">1f</span></span>); HexDirection mainDispersalDirection = windDirection.Opposite();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si, par conséquent, nous obtenons plus de nuages ​​qu'il n'est acceptable, nous convertissons simplement les nuages ​​en excès en humidité. </font><font style="vertical-align: inherit;">En fait, c'est ainsi que nous ajoutons des précipitations supplémentaires, comme cela se produit dans de vraies montagnes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudMaximum = <span class="hljs-number"><span class="hljs-number">1f</span></span> - cell.ViewElevation / (elevationMaximum + <span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellClimate.clouds &gt; cloudMaximum) { cellClimate.moisture += cellClimate.clouds - cloudMaximum; cellClimate.clouds = cloudMaximum; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/403/998/c36/403998c36a6d85250f837766a4f33147.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ombres de pluie causées par la haute altitude. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous terminons la simulation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A ce stade, nous disposons déjà d'une simulation partielle de très haute qualité du cycle de l'eau. </font><font style="vertical-align: inherit;">Mettons-le un peu dans l'ordre, puis appliquons-le pour déterminer le type de relief des cellules.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Informatique parallèle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme mentionné précédemment sous le spoiler, l'ordre dans lequel les cellules sont formées affecte le résultat de la simulation. </font><font style="vertical-align: inherit;">Idéalement, cela ne devrait pas être et, en substance, nous formons toutes les cellules en parallèle. </font><font style="vertical-align: inherit;">Cela peut être fait en appliquant tous les changements du stade actuel de formation à la deuxième liste de climat </font></font><code>nextClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> List&lt;ClimateData&gt; climate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;(); List&lt;ClimateData&gt; nextClimate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Effacez et initialisez cette liste, comme tout le monde. </font><font style="vertical-align: inherit;">Ensuite, nous échangerons des listes à chaque cycle. </font><font style="vertical-align: inherit;">Dans ce cas, la simulation utilisera alternativement les deux listes et appliquera les données climatiques actuelles et suivantes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { climate.Clear(); nextClimate.Clear(); ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); nextClimate.Add(initialData); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; cycle &lt; <span class="hljs-number"><span class="hljs-number">40</span></span>; cycle++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } List&lt;ClimateData&gt; swap = climate; climate = nextClimate; nextClimate = swap; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lorsqu'une cellule affecte le climat de son voisin, nous devons changer les données climatiques suivantes, pas celles actuelles. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = nextClimate[neighbor.Index]; … nextClimate[neighbor.Index] = neighborClimate; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et au lieu de copier les données climatiques suivantes dans la liste climatique actuelle, nous obtenons les données climatiques suivantes, leur ajoutons l'humidité actuelle et les copions dans la liste suivante. </font><font style="vertical-align: inherit;">Après cela, nous réinitialisons les données de la liste actuelle afin qu'elles soient mises à jour pour le cycle suivant.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// cellClimate.clouds = 0f; ClimateData nextCellClimate = nextClimate[cellIndex]; nextCellClimate.moisture += cellClimate.moisture; nextClimate[cellIndex] = nextCellClimate; climate[cellIndex] = new ClimateData();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pendant que nous faisons cela, fixons également le niveau d'humidité à un maximum de 1 afin que les cellules terrestres ne puissent pas être plus humides que sous l'eau. </font></font><br><br><pre> <code class="cs hljs"> nextCellClimate.moisture += cellClimate.moisture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextCellClimate.moisture &gt; <span class="hljs-number"><span class="hljs-number">1f</span></span>) { nextCellClimate.moisture = <span class="hljs-number"><span class="hljs-number">1f</span></span>; } nextClimate[cellIndex] = nextCellClimate;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a8/709/87b/6a870987bfad51e91eaa1ff405be539d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informatique parallèle.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Humidité d'origine </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est possible que la simulation produise trop de terres sèches, en particulier avec un pourcentage élevé de terres. </font><font style="vertical-align: inherit;">Pour améliorer l'image, nous pouvons ajouter un niveau d'humidité initial personnalisé avec une valeur par défaut de 0,1.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> startingMoisture = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/69b/3a2/db869b3a24627d695d9ec8bf2ba1f4ae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ci-dessus se trouve le curseur de l'humidité d'origine. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons cette valeur pour l'humidité de la liste climatique initiale, mais pas pour les suivantes.</font></font><br><br><pre> <code class="cs hljs"> ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); initialData.moisture = startingMoisture; ClimateData clearData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); nextClimate.Add(clearData); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a74/138/649/a74138649fc141c088a631bce956a31a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec humidité d'origine.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Définition des biomes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous concluons en utilisant l'humidité au lieu de la hauteur pour spécifier le type de relief cellulaire. </font><font style="vertical-align: inherit;">Utilisons la neige pour les terres complètement sèches, pour les régions arides, nous utilisons la neige, puis il y a la pierre, l'herbe pour assez humide et la terre pour les cellules saturées d'eau et sous-marines. </font><font style="vertical-align: inherit;">Le moyen le plus simple consiste à utiliser cinq intervalles par incréments de 0,2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moisture = climate[i].moisture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.2f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.4f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.6f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.SetMapData(moisture); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/123/c53/e4f/123c53e4f3f79aa50437a553e0eb6761.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous utilisez une distribution uniforme, le résultat n'est pas très bon et il ne semble pas naturel. </font><font style="vertical-align: inherit;">Il est préférable d'utiliser d'autres seuils, par exemple 0,05, 0,12, 0,28 et 0,85.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.05f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.12f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.28f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.85f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ad/8cf/7c7/6ad8cf7c7becf357d16157ae28999a14.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomes modifiés. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 26: biomes et rivières </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous créons les rivières provenant de cellules élevées avec de l'humidité. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous créons un modèle de température simple. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous utilisons la matrice du biome pour les cellules, puis la modifions. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette partie, nous compléterons le cycle de l'eau avec des rivières et la température, ainsi que des biomes plus intéressants aux cellules. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le didacticiel a été créé à l'aide de Unity 2017.3.0p3.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/305/0b2/d11/3050b2d115d1ec49e2b6c945ab9ed4c1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La chaleur et l'eau animent la carte.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Génération de la rivière </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les rivières sont une conséquence du cycle de l'eau. </font><font style="vertical-align: inherit;">En fait, ils sont formés par des ruissellements arrachant à l'aide de l'érosion des canaux. </font><font style="vertical-align: inherit;">Cela implique que vous pouvez ajouter des rivières en fonction de la valeur des drains cellulaires. </font><font style="vertical-align: inherit;">Cependant, cela ne garantit pas que nous obtiendrons quelque chose qui ressemble à de vraies rivières. </font><font style="vertical-align: inherit;">Lorsque nous commencerons la rivière, elle devra couler le plus loin possible, potentiellement à travers de nombreuses cellules. </font><font style="vertical-align: inherit;">Cela n'est pas cohérent avec notre simulation du cycle de l'eau, qui traite les cellules en parallèle. </font><font style="vertical-align: inherit;">De plus, le contrôle du nombre de rivières sur une carte est généralement nécessaire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les fleuves étant très différents, nous les générerons séparément. </font><font style="vertical-align: inherit;">Nous utilisons les résultats de la simulation du cycle de l'eau pour déterminer l'emplacement des rivières, mais les rivières, à leur tour, n'affecteront pas la simulation.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi le débit de la rivière est-il parfois faux?</font></font></b> <div class="spoiler_text">    <code>TriangulateWaterShore</code>  ,    .      ,    .   ,    ,       .      ,  .    ,  ,       .         («»). <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary( e1, e2, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction, indices ); } … }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cellules à humidité élevée </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sur nos cartes, une cellule peut ou non avoir une rivière. De plus, ils peuvent se ramifier ou se connecter. En réalité, les rivières sont beaucoup plus flexibles, mais nous devons nous en tirer avec cette approximation, qui ne crée que de grandes rivières. Plus important encore, nous devons déterminer l'emplacement du début d'un grand fleuve, qui est choisi au hasard. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que les rivières ont besoin d'eau, la source de la rivière doit se trouver dans une cellule très humide. Mais cela ne suffit pas. Les rivières coulent le long des pentes, donc idéalement la source devrait avoir une grande hauteur. Plus la cellule est haute au-dessus du niveau de l'eau, meilleure est sa candidature au rôle de source de la rivière. Nous pouvons visualiser cela sous forme de données cartographiques en divisant la hauteur des cellules par la hauteur maximale. Pour que le résultat soit obtenu par rapport au niveau de l'eau, nous allons le soustraire des deux hauteurs avant de diviser.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); cell.SetMapData(data); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f9/d80/2de/6f9d802de155c2b1e051be5d360dc3c1.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5c/e8f/6a2/f5ce8f6a20d7336dc94b89812c123827.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Humidité et altitude. Grande carte numéro 1208905299 avec paramètres par défaut.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les meilleurs candidats sont les cellules qui ont à la fois une humidité élevée et une hauteur élevée. On peut combiner ces critères en les multipliant. Le résultat sera la valeur de la forme physique ou du poids pour les sources des rivières.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); cell.SetMapData(data);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec2/31f/445/ec231f445d785c24c6cd9f191ed6c24a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poids pour les sources des rivières.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Idéalement, nous utiliserions ces poids pour rejeter la sélection aléatoire de la cellule source. Bien que nous puissions créer une liste avec les poids corrects et faire votre choix, il s'agit d'une approche non triviale et cela ralentit le processus de génération. Une classification plus simple de l'importance divisée en quatre niveaux nous suffira. Les premiers candidats seront des poids avec des valeurs supérieures à 0,75. Les bons candidats ont des poids de 0,5. Les candidats éligibles sont supérieurs à 0,25. Toutes les autres cellules sont jetées. Montrons à quoi cela ressemble graphiquement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.75f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">1f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// cell.SetMapData(data);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/056/5ba/3b7/0565ba3b7a51499bfe1d389ecd270910.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catégories de poids des sources fluviales. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec ce schéma de classification, nous aurons probablement des rivières avec des sources dans les zones les plus hautes et les plus humides de la carte. </font><font style="vertical-align: inherit;">Néanmoins, la probabilité de créer des rivières dans des zones relativement sèches ou basses demeure, ce qui augmente la variabilité. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez une méthode </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui remplit une liste de cellules en fonction de ces critères. </font><font style="vertical-align: inherit;">Les cellules éligibles sont ajoutées à cette liste une fois, les bonnes deux fois et les principaux candidats quatre fois. </font><font style="vertical-align: inherit;">Les cellules sous-marines sont toujours jetées, vous ne pouvez donc pas les vérifier.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; riverOrigins = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData data = climate[i]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> weight = data.moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.75f</span></span>) { riverOrigins.Add(cell); riverOrigins.Add(cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { riverOrigins.Add(cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { riverOrigins.Add(cell); } } ListPool&lt;HexCell&gt;.Add(riverOrigins); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette méthode doit être appelée après </font></font><code>CreateClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour que les données d'humidité soient à notre disposition.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … CreateRegions(); CreateLand(); ErodeLand(); CreateClimate(); CreateRivers(); SetTerrainType(); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Après avoir terminé le classement, vous pouvez vous débarrasser de la visualisation de ses données sur la carte. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … <span class="hljs-comment"><span class="hljs-comment">// float data = // moisture * (cell.Elevation - waterLevel) / // (elevationMaximum - waterLevel); // if (data &gt; 0.6f) { // cell.SetMapData(1f); // } // else if (data &gt; 0.4f) { // cell.SetMapData(0.5f); // } // else if (data &gt; 0.2f) { // cell.SetMapData(0.25f); // } } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Points de la rivière </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De combien de rivières avons-nous besoin? </font><font style="vertical-align: inherit;">Ce paramètre doit être personnalisable. </font><font style="vertical-align: inherit;">Étant donné que la longueur des rivières varie, il sera plus logique de la contrôler à l'aide de points fluviaux, qui déterminent le nombre de cellules terrestres dans lesquelles les rivières doivent être contenues. </font><font style="vertical-align: inherit;">Exprimons-les en pourcentage avec un maximum de 20% et une valeur par défaut de 10%. </font><font style="vertical-align: inherit;">Comme le pourcentage de sushis, il s'agit d'une valeur cible, non garantie. </font><font style="vertical-align: inherit;">Par conséquent, nous pourrions avoir trop peu de candidats ou de rivières trop courtes pour couvrir la quantité de terre requise. </font><font style="vertical-align: inherit;">C'est pourquoi le pourcentage maximum ne doit pas être trop important.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 20)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverPercentage = <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/793/1c6/4cd/7931c64cd7bdffbb17f83a94aed1bbc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slider pour cent des rivières. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour déterminer les points fluviaux, exprimés en nombre de cellules, nous devons nous rappeler combien de cellules terrestres ont été générées </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCount, landCells; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); landCells = landBudget; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); landCells -= landBudget; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À l'intérieur, le </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nombre de points fluviaux peut maintenant être calculé de la même manière que nous le faisons dans </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; riverOrigins = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverBudget = Mathf.RoundToInt(landCells * riverPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); ListPool&lt;HexCell&gt;.Add(riverOrigins); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, nous continuerons de prendre et de supprimer des cellules aléatoires de la liste d'origine, alors que nous avons toujours des points et des cellules sources. </font><font style="vertical-align: inherit;">En cas de finalisation du nombre de points, nous afficherons un avertissement dans la console.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverBudget = Mathf.RoundToInt(landCells * riverPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, riverOrigins.Count); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = riverOrigins.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell origin = riverOrigins[index]; riverOrigins[index] = riverOrigins[lastIndex]; riverOrigins.RemoveAt(lastIndex); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up river budget."</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, nous ajoutons une méthode pour créer directement des rivières. </font><font style="vertical-align: inherit;">Comme paramètre, il a besoin d'une cellule initiale, et après l'achèvement, il doit retourner la longueur de la rivière. </font><font style="vertical-align: inherit;">Nous commençons par stocker une méthode qui retourne une longueur nulle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous appellerons cette méthode à la fin du cycle que nous venons d'ajouter </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en utilisant pour réduire le nombre de points restants. </font><font style="vertical-align: inherit;">Nous nous assurons qu'une nouvelle rivière est créée uniquement si la cellule sélectionnée n'a pas de rivière qui la traverse.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!origin.HasRiver) { riverBudget -= CreateRiver(origin); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rivières actuelles </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est logique de créer des rivières coulant vers la mer ou un autre plan d'eau. </font><font style="vertical-align: inherit;">Lorsque nous partons de la source, nous obtenons immédiatement la longueur 1. Après cela, nous sélectionnons un voisin aléatoire et augmentons la longueur. </font><font style="vertical-align: inherit;">Nous continuons de nous déplacer jusqu'à ce que nous atteignions la cellule sous-marine.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { HexDirection direction = (HexDirection)Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); cell.SetOutgoingRiver(direction); length += <span class="hljs-number"><span class="hljs-number">1</span></span>; cell = cell.GetNeighbor(direction); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/359/7cf/7a7/3597cf7a7ae263721b381534185e7645.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivières aléatoires. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À la suite d'une telle approche naïve, nous obtenons des fragments de rivière dispersés de manière aléatoire, principalement en raison du remplacement des rivières précédemment générées. </font><font style="vertical-align: inherit;">Cela peut même conduire à des erreurs, car nous ne vérifions pas si le voisin existe réellement. </font><font style="vertical-align: inherit;">Nous devons vérifier toutes les directions dans la boucle et nous assurer qu'il y a un voisin là-bas. </font><font style="vertical-align: inherit;">Si c'est le cas, nous ajoutons cette direction à la liste des directions d'écoulement potentielles, mais seulement si la rivière ne traverse pas encore ce voisin. </font><font style="vertical-align: inherit;">Sélectionnez ensuite une valeur aléatoire dans cette liste.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexDirection&gt; flowDirections = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexDirection&gt;(); … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || neighbor.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } flowDirections.Add(d); } HexDirection direction = <span class="hljs-comment"><span class="hljs-comment">// (HexDirection)Random.Range(0, 6); flowDirections[Random.Range(0, flowDirections.Count)]; cell.SetOutgoingRiver(direction); length += 1; cell = cell.GetNeighbor(direction); } return length; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec cette nouvelle approche, nous pouvons avoir zéro sens d'écoulement disponible. </font><font style="vertical-align: inherit;">Lorsque cela se produit, la rivière ne peut plus couler plus loin et doit s'arrêter. </font><font style="vertical-align: inherit;">Si à ce moment la longueur est de 1, cela signifie que nous ne pouvons pas fuir de la cellule d'origine, c'est-à-dire qu'il ne peut pas y avoir de rivière du tout. </font><font style="vertical-align: inherit;">Dans ce cas, la longueur de la rivière est nulle.</font></font><br><br><pre> <code class="cs hljs"> flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? length : <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6f/5bd/05d/e6f5bd05d8d5a976d6fff9fa14397a25.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fleuves préservés.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Délabré </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous sauvons les rivières déjà créées, mais nous pouvons toujours obtenir des fragments isolés des rivières. </font><font style="vertical-align: inherit;">Cela se produit parce que nous avons ignoré les hauteurs. </font><font style="vertical-align: inherit;">Chaque fois que nous avons forcé la rivière à couler à une plus grande hauteur, nous avons </font></font><code>HexCell.SetOutgoingRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interrompu cette tentative, qui a entraîné des ruptures dans les rivières. </font><font style="vertical-align: inherit;">Par conséquent, nous devons également sauter des directions qui font remonter les rivières.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || neighbor.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = neighbor.Elevation - cell.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } flowDirections.Add(d);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae6/cf7/696/ae6cf76968d64228e88378749939f1f2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des rivières qui coulent. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous nous débarrassons donc de nombreux fragments de rivières, mais il en reste encore. </font><font style="vertical-align: inherit;">A partir de ce moment, se débarrasser des rivières les plus laides devient une affaire de raffinement. </font><font style="vertical-align: inherit;">Pour commencer, les rivières préfèrent couler le plus vite possible. </font><font style="vertical-align: inherit;">Ils ne choisiront pas nécessairement l'itinéraire le plus court possible, mais la probabilité est grande. </font><font style="vertical-align: inherit;">Pour simuler cela, nous ajouterons trois fois les instructions à la liste.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { flowDirections.Add(d); flowDirections.Add(d); flowDirections.Add(d); } flowDirections.Add(d);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Évitez les virages serrés </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En plus de couler, l'eau a également une inertie. </font><font style="vertical-align: inherit;">Une rivière est plus susceptible de couler directement ou de se plier légèrement que de faire un virage brusque et brutal. </font><font style="vertical-align: inherit;">Nous pouvons ajouter cette distorsion en suivant la dernière direction de la rivière. </font><font style="vertical-align: inherit;">Si la direction potentielle du courant ne s'écarte pas trop de cette direction, ajoutez-la à nouveau à la liste. </font><font style="vertical-align: inherit;">Ce n'est pas un problème pour la source, nous l'ajouterons donc toujours.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; HexDirection direction = HexDirection.NE; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { flowDirections.Add(d); flowDirections.Add(d); flowDirections.Add(d); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( length == <span class="hljs-number"><span class="hljs-number">1</span></span> || (d != direction.Next2() &amp;&amp; d != direction.Previous2()) ) { flowDirections.Add(d); } flowDirections.Add(d); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? length : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// HexDirection direction = direction = flowDirections[Random.Range(0, flowDirections.Count)]; cell.SetOutgoingRiver(direction); length += 1; cell = cell.GetNeighbor(direction); } return length; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cela réduit considérablement la probabilité de zigzags de rivières qui semblent moche. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/83b/ce7/67483bce79b287f3cc451e381dc686d2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moins de virages serrés.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Confluence de la rivière </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parfois, il s'avère que la rivière coule juste à côté de la source de la rivière précédemment créée. </font><font style="vertical-align: inherit;">Si la source de cette rivière n'est pas à une altitude plus élevée, alors nous pouvons décider que la nouvelle rivière se jette dans l'ancienne. </font><font style="vertical-align: inherit;">En conséquence, nous obtenons une longue rivière et non deux rivières voisines. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour ce faire, nous ne laisserons passer le voisin que s'il y a une rivière entrante ou s'il est la source de la rivière actuelle. </font><font style="vertical-align: inherit;">Après avoir déterminé que cette direction n'est pas vers le haut, nous vérifions s'il y a une rivière sortante. </font><font style="vertical-align: inherit;">S'il y en a, alors nous avons retrouvé la vieille rivière. </font><font style="vertical-align: inherit;">Comme cela se produit assez rarement, nous ne serons pas engagés dans la vérification d'autres sources voisines et combinerons immédiatement les rivières.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || neighbor.HasRiver) { // continue; // } if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) { continue; } int delta = neighbor.Elevation - cell.Elevation; if (delta &gt; 0) { continue; } if (neighbor.HasOutgoingRiver) { cell.SetOutgoingRiver(d); return length; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb3/820/ee6/bb3820ee6271b8bc7b32e901b39c906a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ba/d8f/08d/3bad8f08d23cfe3844ec259a1c2475d6.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivières avant et après la mise en commun.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gardez vos distances </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que les bons candidats pour le rôle source sont généralement regroupés, nous obtiendrons des groupes de rivières. </font><font style="vertical-align: inherit;">De plus, nous pouvons avoir des rivières qui prennent la source juste à côté du réservoir, ce qui donne des rivières de longueur 1. Nous pouvons répartir les sources, en rejetant celles qui se trouvent à proximité de la rivière ou du réservoir. </font><font style="vertical-align: inherit;">Nous faisons cela en contournant les voisins de la source sélectionnée dans une boucle à l'intérieur </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si nous trouvons un voisin qui viole les règles, alors la source ne nous convient pas et nous devons le sauter.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, riverOrigins.Count); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = riverOrigins.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell origin = riverOrigins[index]; riverOrigins[index] = riverOrigins[lastIndex]; riverOrigins.RemoveAt(lastIndex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!origin.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isValidOrigin = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = origin.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; (neighbor.HasRiver || neighbor.IsUnderwater)) { isValidOrigin = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isValidOrigin) { riverBudget -= CreateRiver(origin); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et bien que les rivières coulent toujours les unes à côté des autres, elles ont tendance à couvrir une plus grande superficie. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/bed/3a6/887bed3a6032b4bea508ee6ceda4a228.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/b85/428/f53b85428840118895d74f62b1c2d1a6.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sans distance et avec elle.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous terminons la rivière avec un lac </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toutes les rivières n'atteignent pas le réservoir, certaines se coincent dans les vallées ou sont bloquées par d'autres rivières. Ce n'est pas un problème particulier, car souvent les vraies rivières semblent également disparaître. Cela peut se produire, par exemple, s'ils coulent sous terre, se dispersent dans une zone marécageuse ou se dessèchent. Nos rivières ne peuvent pas visualiser cela, alors elles finissent simplement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, nous pouvons essayer de minimiser le nombre de ces cas. Bien que nous ne puissions pas unir les rivières ou les faire couler, nous pouvons les faire aboutir dans des lacs, qui se trouvent souvent dans la réalité et qui ont l'air bien. Pour cela</font></font><code>CreateRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devrait augmenter le niveau d'eau dans la cellule si elle se coince. </font><font style="vertical-align: inherit;">La possibilité de cela dépend de la hauteur minimale des voisins de cette cellule. </font><font style="vertical-align: inherit;">Par conséquent, afin de suivre cela lors de l'étude des voisins, une petite modification du code est nécessaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minNeighborElevation = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) { // continue; // } if (!neighbor) { continue; } if (neighbor.Elevation &lt; minNeighborElevation) { minNeighborElevation = neighbor.Elevation; } if (neighbor == origin || neighbor.HasIncomingRiver) { continue; } int delta = neighbor.Elevation - cell.Elevation; if (delta &gt; 0) { continue; } … } … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous sommes bloqués, nous devons d'abord vérifier si nous sommes toujours à la source. </font><font style="vertical-align: inherit;">Si oui, alors annulez simplement la rivière. </font><font style="vertical-align: inherit;">Sinon, nous vérifions si tous les voisins sont au moins aussi élevés que la cellule actuelle. </font><font style="vertical-align: inherit;">Si oui, alors nous pouvons élever l'eau à ce niveau. </font><font style="vertical-align: inherit;">Cela créera un lac à partir d'une cellule, à moins que la hauteur de la cellule ne reste au même niveau. </font><font style="vertical-align: inherit;">Si c'est le cas, attribuez simplement la hauteur à un niveau en dessous du niveau de l'eau.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// return length &gt; 1 ? length : 0; if (length == 1) { return 0; } if (minNeighborElevation &gt;= cell.Elevation) { cell.WaterLevel = minNeighborElevation; if (minNeighborElevation == cell.Elevation) { cell.Elevation = minNeighborElevation - 1; } } break; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/7da/964/d607da964da18b71cd022c997661695c.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee8/ab1/000/ee8ab10002cd3e36cefbcfe3980a8fbe.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les extrémités des rivières sans lacs et avec lacs. </font><font style="vertical-align: inherit;">Dans ce cas, le pourcentage de rivières est de 20.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Notez que nous pouvons maintenant avoir des cellules sous-marines au-dessus du niveau d'eau utilisé pour générer la carte. </font><font style="vertical-align: inherit;">Ils désigneront les lacs au-dessus du niveau de la mer.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lacs supplémentaires </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons également créer des lacs, même si nous ne sommes pas coincés. </font><font style="vertical-align: inherit;">Cela peut entraîner une rivière qui coule dans et hors du lac. </font><font style="vertical-align: inherit;">Si nous ne sommes pas coincés, un lac peut être créé en augmentant le niveau de l'eau, puis la hauteur actuelle des cellules, puis en réduisant la hauteur des cellules. </font><font style="vertical-align: inherit;">Cela ne s'applique que lorsque la hauteur minimale du voisin est au moins égale à la hauteur de la cellule actuelle. </font><font style="vertical-align: inherit;">Nous le faisons à la fin du cycle de la rivière et avant de passer à la cellule suivante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minNeighborElevation &gt;= cell.Elevation) { cell.WaterLevel = cell.Elevation; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } cell = cell.GetNeighbor(direction); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/945/5bb/2b6/9455bb2b6547a8b1342e179f15eb5925.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f84/516/4b7/f845164b7a543b9549cd9f07d273e67f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sans lacs supplémentaires et avec eux. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plusieurs lacs sont magnifiques, mais sans limites, nous pouvons créer trop de lacs. </font><font style="vertical-align: inherit;">Par conséquent, ajoutons une probabilité personnalisée pour des lacs supplémentaires, avec une valeur par défaut de 0,25.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> extraLakeProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Elle contrôlera la probabilité de générer un lac supplémentaire, si possible. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( minNeighborElevation &gt;= cell.Elevation &amp;&amp; Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; extraLakeProbability ) { cell.WaterLevel = cell.Elevation; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa5/d04/bc3/fa5d04bc3f7475ec2baab7b6e7dac38f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/118/bb4/364/118bb4364acb0646efb54a031d3ac356.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lacs supplémentaires.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'en est-il de la création de lacs avec plus d'une cellule?</font></font></b> <div class="spoiler_text">     ,       ,  ,      .      .      :          .       ,       .  ,      ,     ,   . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La température </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'eau n'est qu'un des facteurs qui peuvent déterminer le biome d'une cellule. </font><font style="vertical-align: inherit;">Un autre facteur important est la température. </font><font style="vertical-align: inherit;">Bien que nous puissions simuler l'écoulement et la diffusion des températures comme la simulation de l'eau, pour créer un climat intéressant, nous n'avons besoin que d'un facteur complexe. </font><font style="vertical-align: inherit;">Par conséquent, gardons la température simple et la réglons pour chaque cellule.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Température et latitude </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La plus grande influence sur la température est la latitude. </font><font style="vertical-align: inherit;">Il fait chaud à l'équateur, froid aux pôles, et il y a une transition en douceur entre eux. </font><font style="vertical-align: inherit;">Créons une méthode </font></font><code>DetermineTemperature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui renvoie la température d'une cellule donnée. </font><font style="vertical-align: inherit;">Pour commencer, nous utilisons simplement la coordonnée Z de la cellule divisée par la dimension Z comme latitude, puis nous utilisons cette valeur comme température.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> latitude; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous définissons la température à l'intérieur </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et l'utilisons comme données cartographiques.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = DetermineTemperature(cell); cell.SetMapData(temperature); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moisture = climate[i].moisture; … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/789/7f6/334/7897f63347b08fdb02ee5794f3ab28e3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latitude comme température, hémisphère sud. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On obtient un gradient de température linéaire croissant de bas en haut. </font><font style="vertical-align: inherit;">Vous pouvez l'utiliser pour simuler l'hémisphère sud, avec un pôle en bas et un équateur en haut. </font><font style="vertical-align: inherit;">Mais nous n'avons pas besoin de décrire l'ensemble de l'hémisphère. </font><font style="vertical-align: inherit;">Avec une différence de température plus faible ou aucune différence, nous pouvons décrire une zone plus petite. </font><font style="vertical-align: inherit;">Pour ce faire, nous allons personnaliser les températures basses et hautes. </font><font style="vertical-align: inherit;">Nous allons définir ces températures dans la plage de 0 à 1 et utiliser les valeurs extrêmes comme valeurs par défaut.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lowTemperature = <span class="hljs-number"><span class="hljs-number">0f</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> highTemperature = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b1/8cf/805/3b18cf805a56a0dbbeabb03b69a00496.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curseurs de température. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous appliquons la plage de température en utilisant une interpolation linéaire, en utilisant la latitude comme interpolateur. </font><font style="vertical-align: inherit;">Puisque nous exprimons la latitude comme une valeur de 0 à 1, nous pouvons l'utiliser </font></font><code>Mathf.LerpUnclamped</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que les basses températures ne sont pas nécessairement inférieures aux hautes. </font><font style="vertical-align: inherit;">Si vous le souhaitez, vous pouvez les retourner.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hémisphère </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant simuler l'hémisphère sud, et peut-être l'hémisphère nord, si nous prenons d'abord les températures. </font><font style="vertical-align: inherit;">Mais il est beaucoup plus pratique d'utiliser une option de configuration distincte pour basculer entre les hémisphères. </font><font style="vertical-align: inherit;">Créons une énumération et un champ pour cela. </font><font style="vertical-align: inherit;">Ainsi, nous ajouterons également l'option de création des deux hémisphères, qui est applicable par défaut.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HemisphereMode { Both, North, South } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HemisphereMode hemisphere;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be8/c67/03f/be8c6703f51cd7c62535a96a3035a284.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le choix de l'hémisphère. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous avons besoin de l'hémisphère nord, alors nous pouvons simplement inverser la latitude, en la soustrayant de 1. Pour simuler les deux hémisphères, les pôles doivent être en dessous et au-dessus de la carte, et l'équateur doit être au milieu. </font><font style="vertical-align: inherit;">Vous pouvez le faire en doublant la latitude, tandis que l'hémisphère inférieur sera traité correctement et que l'hémisphère supérieur aura une latitude de 1 à 2. Pour résoudre ce problème, nous soustrayons la latitude de 2 lorsqu'elle dépasse 1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hemisphere == HemisphereMode.Both) { latitude *= <span class="hljs-number"><span class="hljs-number">2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (latitude &gt; <span class="hljs-number"><span class="hljs-number">1f</span></span>) { latitude = <span class="hljs-number"><span class="hljs-number">2f</span></span> - latitude; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hemisphere == HemisphereMode.North) { latitude = <span class="hljs-number"><span class="hljs-number">1f</span></span> - latitude; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c7/871/ede/9c7871ede0c56a393bc603ec888c65bf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les deux hémisphères. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il convient de noter que cela crée la possibilité de créer une carte exotique dans laquelle l'équateur est froid et les pôles sont chauds.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plus le froid est élevé </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En plus de la latitude, la température est également significativement affectée par l'altitude. </font><font style="vertical-align: inherit;">En moyenne, plus nous montons, plus il fait froid. </font><font style="vertical-align: inherit;">Nous pouvons en faire un facteur, comme nous l'avons fait avec les candidats de la rivière. </font><font style="vertical-align: inherit;">Dans ce cas, nous utilisons la hauteur de cellule. </font><font style="vertical-align: inherit;">De plus, cet indicateur diminue avec la hauteur, c'est-à-dire égal à 1 moins la hauteur divisée par le maximum par rapport au niveau de l'eau. </font><font style="vertical-align: inherit;">Pour que l'indicateur au plus haut niveau ne tombe pas à zéro, nous ajoutons au diviseur. </font><font style="vertical-align: inherit;">Utilisez ensuite cet indicateur pour mettre à l'échelle la température.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); temperature *= <span class="hljs-number"><span class="hljs-number">1f</span></span> - (cell.ViewElevation - waterLevel) / (elevationMaximum - waterLevel + <span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75e/a24/550/75ea24550d4325e2af45a1a9627cc53c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La hauteur affecte la température.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fluctuations de température </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons rendre la simplicité du gradient de température moins perceptible en ajoutant des fluctuations de température aléatoires. </font><font style="vertical-align: inherit;">Une petite chance de le rendre plus réaliste, mais avec trop de fluctuations, ils auront l'air arbitraires. </font><font style="vertical-align: inherit;">Personnalisons la puissance des fluctuations de température et exprimons-la comme l'écart de température maximum avec une valeur par défaut de 0,1.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperatureJitter = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/e21/83f/27de2183fc453ded3c2902d4705cd1eb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curseur de fluctuation de température. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ces fluctuations devraient être fluides avec de légers changements locaux. </font><font style="vertical-align: inherit;">Vous pouvez utiliser notre texture de bruit pour cela. </font><font style="vertical-align: inherit;">Nous appellerons </font></font><code>HexMetrics.SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et utiliserons comme argument la position de la cellule, mise à l'échelle par 0,1. </font><font style="vertical-align: inherit;">Prenons le canal W, centrons-le et redimensionnons-le par le coefficient d'oscillation. </font><font style="vertical-align: inherit;">Ensuite, nous ajoutons cette valeur à la température précédemment calculée.</font></font><br><br><pre> <code class="cs hljs"> temperature *= <span class="hljs-number"><span class="hljs-number">1f</span></span> - (cell.ViewElevation - waterLevel) / (elevationMaximum - waterLevel + <span class="hljs-number"><span class="hljs-number">1f</span></span>); temperature += (HexMetrics.SampleNoise(cell.Position * <span class="hljs-number"><span class="hljs-number">0.1f</span></span>).w * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * temperatureJitter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/490/92c/2c8/49092c2c88aaad00d5c54835c6511a74.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dac/7d9/3cd/dac7d93cdb115574c748269ffebb3d8d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fluctuations de température avec des valeurs de 0,1 et 1.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous pouvons ajouter une légère variabilité aux fluctuations sur chaque carte, en choisissant au hasard parmi les quatre canaux de bruit. </font><font style="vertical-align: inherit;">Définissez le canal une fois </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis indexez les canaux de couleur </font></font><code>DetermineTemperature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> temperatureJitterChannel; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> jitter = HexMetrics.SampleNoise(cell.Position * <span class="hljs-number"><span class="hljs-number">0.1f</span></span>)[temperatureJitterChannel]; temperature += (jitter * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * temperatureJitter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30c/e82/084/30ce820847299346ec8dfaf2bb6cf1a8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Différentes fluctuations de température avec une force maximale. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biomes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous avons des données sur l'humidité et la température, nous pouvons créer une matrice de biome. </font><font style="vertical-align: inherit;">En indexant cette matrice, nous pouvons attribuer des biomes à toutes les cellules, créant un paysage plus complexe que d'utiliser une seule dimension de données.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Matrice du biome </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe de nombreux modèles climatiques, mais nous n'en utiliserons aucun. Nous allons le rendre très simple, nous ne nous intéressons qu'à la logique. Sec signifie désert (froid ou chaud), pour cela nous utilisons du sable. Froid et humide signifie neige. Chaud et humide signifie beaucoup de végétation, c'est-à-dire de l'herbe. Entre eux, nous aurons une taïga ou une toundra, que nous désignerons comme une texture grisâtre de la terre. Une matrice 4 × 4 sera suffisante pour créer des transitions entre ces biomes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auparavant, nous attribuions des types d'élévation basés sur cinq intervalles d'humidité. Nous abaissons simplement la bande la plus sèche à 0,05 et économisons le reste. Pour les bandes de température, nous utilisons 0,1, 0,3, 0,6 et plus. Pour plus de commodité, nous allons définir ces valeurs dans des tableaux statiques.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] temperatureBands = { <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] moistureBands = { <span class="hljs-number"><span class="hljs-number">0.12f</span></span>, <span class="hljs-number"><span class="hljs-number">0.28f</span></span>, <span class="hljs-number"><span class="hljs-number">0.85f</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous ne spécifions que le type de relief sur la base du biome, nous pouvons l'utiliser pour déterminer d'autres paramètres. </font><font style="vertical-align: inherit;">Par conséquent, définissons dans une </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">structure </font></font><code>Biome</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui décrit la configuration d'un biome individuel. </font><font style="vertical-align: inherit;">Jusqu'à présent, il ne contient que l'indice de bosse plus la méthode constructeur correspondante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Biome { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Biome</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> terrain</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.terrain = terrain; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons cette structure pour créer un tableau statique contenant des données matricielles. </font><font style="vertical-align: inherit;">Nous utilisons l'humidité comme coordonnée X et la température comme Y. Nous remplissons la ligne avec la température la plus basse avec de la neige, la deuxième ligne avec de la toundra et les deux autres avec de l'herbe. </font><font style="vertical-align: inherit;">Ensuite, nous remplaçons la colonne la plus sèche par le désert, redéfinissant le choix de température.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Biome[] biomes = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/969/859/bd5/969859bd51e51cce1f7fe63d9eacd55a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matrice de biomes avec indices d'un tableau unidimensionnel.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Définition du biome </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour déterminer les </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cellules </font><font style="vertical-align: inherit;">du </font><font style="vertical-align: inherit;">biome, nous allons parcourir les plages de température et d'humidité du cycle pour déterminer les indices matriciels dont nous avons besoin. </font><font style="vertical-align: inherit;">Nous les utilisons pour obtenir le biome souhaité et spécifier le type de topographie cellulaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = DetermineTemperature(cell); <span class="hljs-comment"><span class="hljs-comment">// cell.SetMapData(temperature); float moisture = climate[i].moisture; if (!cell.IsUnderwater) { // if (moisture &lt; 0.05f) { // cell.TerrainTypeIndex = 4; // } // … // else { // cell.TerrainTypeIndex = 2; // } int t = 0; for (; t &lt; temperatureBands.Length; t++) { if (temperature &lt; temperatureBands[t]) { break; } } int m = 0; for (; m &lt; moistureBands.Length; m++) { if (moisture &lt; moistureBands[m]) { break; } } Biome cellBiome = biomes[t * 4 + m]; cell.TerrainTypeIndex = cellBiome.terrain; } else { cell.TerrainTypeIndex = 2; } } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00d/d32/4f5/00dd324f5b421811f49ca157e5217e43.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relief basé sur une matrice de biome.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Configuration du biome </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons aller au-delà des biomes définis dans la matrice. Par exemple, dans la matrice, tous les biomes secs sont définis comme des déserts de sable, mais tous les déserts secs ne sont pas remplis de sable. Il existe de nombreux déserts rocheux qui sont très différents. Par conséquent, remplaçons certaines des cellules du désert par des pierres. Nous le ferons simplement en fonction de la hauteur: le sable est à basse altitude et des roches nues se trouvent généralement au-dessus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supposons que le sable se transforme en pierre lorsque la hauteur de la cellule est plus proche de la hauteur maximale que du niveau de l'eau. C'est la ligne de hauteur des déserts rocheux que nous pouvons calculer au début </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Lorsque nous rencontrons une cellule avec du sable et que sa hauteur est suffisamment grande, nous changeons le relief du biome en pierre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rockDesertElevation = elevationMaximum - (elevationMaximum - waterLevel) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { … Biome cellBiome = biomes[t * <span class="hljs-number"><span class="hljs-number">4</span></span> + m]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= rockDesertElevation) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } } cell.TerrainTypeIndex = cellBiome.terrain; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e4/812/13e/1e481213eb2c9b5cf5216b9bfa9546aa.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Déserts de sable et de rochers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un autre changement basé sur la hauteur consiste à forcer les cellules à hauteur maximale à se transformer en pics de neige, quelle que soit leur température, uniquement si elles ne sont pas trop sèches. </font><font style="vertical-align: inherit;">Cela augmentera la probabilité de pics de neige près de l'équateur chaud et humide.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= rockDesertElevation) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == elevationMaximum) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">4</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/06e/35b/9c406e35b681819072db7a3006151e6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bouchons de neige à hauteur maximale.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les plantes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faisons maintenant des biomes déterminer le niveau de cellules végétales. </font><font style="vertical-align: inherit;">Pour ce faire, ajoutez au </font></font><code>Biome</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">domaine des plantes et incluez-le dans le constructeur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Biome { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain, plant; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Biome</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> terrain, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> plant</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.terrain = terrain; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.plant = plant; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans les biomes les plus froids et les plus secs, il n'y aura pas de plantes du tout. </font><font style="vertical-align: inherit;">À tous les autres égards, plus le climat est chaud et humide, plus il y a de plantes. </font><font style="vertical-align: inherit;">La deuxième colonne d'humidité ne reçoit que le premier niveau de plantes pour la rangée la plus chaude, donc [0, 0, 0, 1]. </font><font style="vertical-align: inherit;">La troisième colonne augmente les niveaux de un, à l'exception de la neige, c'est-à-dire [0, 1, 1, 2]. </font><font style="vertical-align: inherit;">Et la colonne la plus humide les augmente à nouveau, c'est-à-dire qu'il s'avère [0, 2, 2, 3]. </font><font style="vertical-align: inherit;">Modifiez la baie </font></font><code>biomes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en y ajoutant la configuration de l'installation.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Biome[] biomes = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f94/bad/c72/f94badc7211d1891415dda94019bf041.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matrice des biomes avec les niveaux des plantes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons définir le niveau de plantes pour la cellule.</font></font><br><br><pre> <code class="cs hljs"> cell.TerrainTypeIndex = cellBiome.terrain; cell.PlantLevel = cellBiome.plant;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed9/2c6/7f8/ed92c67f8322c4b0c9967c0f394507bf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomes avec des plantes.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les plantes sont-elles maintenant différentes?</font></font></b> <div class="spoiler_text">       ,      .       (1, 2, 1)  (0.75, 1, 0.75).     (1.5, 3, 1.5)  (2, 1.5, 2).    — (2, 4.5, 2)  (2.5, 3, 2.5). <br><br>        ,      : (13, 114, 0). </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons changer le niveau des plantes pour les biomes. </font><font style="vertical-align: inherit;">Nous devons d'abord nous assurer qu'ils n'apparaissent pas sur le terrain enneigé, que nous pourrions déjà mettre en place. </font><font style="vertical-align: inherit;">Deuxièmement, augmentons le niveau de plantes le long des rivières, s'il n'est pas déjà au maximum.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">4</span></span>) { cellBiome.plant = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.plant &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> &amp;&amp; cell.HasRiver) { cellBiome.plant += <span class="hljs-number"><span class="hljs-number">1</span></span>; } cell.TerrainTypeIndex = cellBiome.terrain; cell.PlantLevel = cellBiome.plant;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/012/7e4/bd10127e45593cc5f8ce09faa783b10c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plantes modifiées.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biomes sous-marins </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'à ce moment, nous avons complètement ignoré les cellules sous-marines. </font><font style="vertical-align: inherit;">Ajoutons-leur une petite variation, et nous n'utiliserons pas la texture de la terre pour tous. </font><font style="vertical-align: inherit;">Une solution simple basée sur la hauteur sera déjà suffisante pour créer une image plus intéressante. </font><font style="vertical-align: inherit;">Par exemple, utilisons l'herbe pour les cellules une étape en dessous du niveau de l'eau. </font><font style="vertical-align: inherit;">Utilisons également l'herbe pour les cellules au-dessus du niveau de l'eau, c'est-à-dire pour les lacs créés par les rivières. </font><font style="vertical-align: inherit;">Les cellules avec une hauteur négative sont des zones d'eau profonde, nous utilisons donc de la pierre pour elles. </font><font style="vertical-align: inherit;">Toutes les autres cellules restent broyées.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= waterLevel) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.TerrainTypeIndex = terrain; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a62/bb5/5c7/a62bb55c7e4023a4590dbfe73bafe10f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabilité sous-marine.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajoutons quelques détails pour les cellules sous-marines le long de la côte. Ce sont des cellules avec au moins un voisin au-dessus de l'eau. Si une telle cellule est peu profonde, nous créerons une plage. Et si c'est à côté de la falaise, ce sera le détail visuel dominant, et nous utilisons la pierre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour le déterminer, nous allons vérifier les voisins des cellules situées à un pas sous le niveau de l'eau. Comptons le nombre de connexions par les falaises et les pentes avec les cellules terrestres voisines.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cliffs = <span class="hljs-number"><span class="hljs-number">0</span></span>, slopes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++ ) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = neighbor.Elevation - cell.WaterLevel; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { slopes += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cliffs += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant utiliser ces informations pour classer les cellules. </font><font style="vertical-align: inherit;">Premièrement, si plus de la moitié des voisins sont des terres, alors nous avons affaire à un lac ou à une baie. </font><font style="vertical-align: inherit;">Pour ces cellules, nous utilisons une texture d'herbe. </font><font style="vertical-align: inherit;">Sinon, si nous avons des falaises, nous utilisons de la pierre. </font><font style="vertical-align: inherit;">Sinon, si nous avons des pentes, nous utilisons du sable pour créer une plage. </font><font style="vertical-align: inherit;">La seule option restante est une zone peu profonde au large de la côte, pour laquelle nous utilisons toujours de l'herbe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cliffs = <span class="hljs-number"><span class="hljs-number">0</span></span>, slopes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++ ) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliffs + slopes &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliffs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (slopes &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0eb/8d6/2ed/0eb8d62ed0ec66f7814bd839c9ca32fb.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e34/976/0bc/e349760bc545e3063718b892a9ccbd89.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabilité de la côte. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, vérifions que nous n'avons pas de cellules sous-marines vertes dans la plage de température la plus froide. </font><font style="vertical-align: inherit;">Pour ces cellules, nous utilisons la terre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrain == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; temperature &lt; temperatureBands[<span class="hljs-number"><span class="hljs-number">0</span></span>]) { terrain = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.TerrainTypeIndex = terrain;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons eu la possibilité de générer des cartes aléatoires qui semblent assez intéressantes et naturelles, avec de nombreuses options de configuration. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 27: plier une carte </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous divisons les cartes en colonnes qui peuvent être déplacées. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Centrez la carte dans l'appareil photo. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous effondrons tout. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette dernière partie, nous ajouterons un support pour minimiser la carte, reliant les bords est et ouest. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le didacticiel a été créé à l'aide de Unity 2017.3.0p3.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f29/96a/49d/f2996a49dab361c70ce643cc9f2d648b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le pliage fait tourner le monde.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cartes pliantes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos cartes peuvent être utilisées pour modéliser des zones de différentes tailles, mais elles sont toujours limitées à une forme rectangulaire. Nous pouvons créer une carte d'une île ou d'un continent entier, mais pas de la planète entière. Les planètes sont sphériques, elles n'ont pas de frontières rigides qui gênent le mouvement à leur surface. Si vous continuez à vous déplacer dans une direction, vous reviendrez tôt ou tard au point de départ. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne pouvons pas enrouler une grille d'hexagones autour d'une sphère; un tel chevauchement est impossible. Dans les meilleures approximations, la topologie icosaédrique est utilisée, dans laquelle les douze cellules doivent être des pentagones. Cependant, sans distorsion ni exception, le maillage peut être enroulé autour du cylindre. Pour ce faire, connectez simplement les bords est et ouest de la carte. À l'exception de la logique d'habillage, tout le reste reste le même.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un cylindre est une mauvaise approximation d'une sphère, car nous ne pouvons pas modéliser de pôles. </font><font style="vertical-align: inherit;">Mais cela n'a pas empêché les développeurs de nombreux jeux d'utiliser le pliage d'est en ouest pour modéliser les cartes de la planète. </font><font style="vertical-align: inherit;">Les régions polaires ne font tout simplement pas partie de la zone de jeu.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que diriez-vous de tourner vers le nord et le sud?</font></font></b> <div class="spoiler_text">          ,     .       ,    ,       .        -,            -.         . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe deux façons de mettre en œuvre le pliage cylindrique. </font><font style="vertical-align: inherit;">La première consiste à rendre la carte cylindrique en pliant sa surface et tout ce qui s'y trouve afin que les bords est et ouest soient en contact. </font><font style="vertical-align: inherit;">Maintenant, vous jouerez non pas sur une surface plane, mais sur un vrai cylindre. </font><font style="vertical-align: inherit;">La deuxième approche consiste à enregistrer une carte plate et à utiliser la téléportation ou la duplication pour s'effondrer. </font><font style="vertical-align: inherit;">La plupart des jeux utilisent la deuxième approche, nous allons donc la suivre.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pliage en option </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La nécessité de réduire la carte dépend de son échelle - locale ou planétaire. </font><font style="vertical-align: inherit;">Nous pouvons utiliser le support des deux en rendant le pliage facultatif. </font><font style="vertical-align: inherit;">Pour ce faire, ajoutez un </font><font style="vertical-align: inherit;">nouveau commutateur au </font><font style="vertical-align: inherit;">menu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créer une nouvelle carte</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avec la réduction activée par défaut.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b07/17d/3ef/b0717d3ef8000555a454de943e4e387a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le menu de la nouvelle carte avec l'option de réduire. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez au </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">champ pour suivre la sélection, ainsi qu'une méthode pour la modifier. </font><font style="vertical-align: inherit;">Faisons invoquer cette méthode lorsque l'état du commutateur change.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleWrapping</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { wrapping = toggle; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lorsqu'une nouvelle carte est demandée, nous transmettons la valeur de l'option de réduction. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (generateMaps) { mapGenerator.GenerateMap(x, z, wrapping); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.CreateMap(x, z, wrapping); } HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez-le </font></font><code>HexMapGenerator.GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il accepte ce nouvel argument, puis le transmet à </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … grid.CreateMap(x, z, wrapping); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code&gt; HexGrid devrait savoir si nous nous effondrons, alors ajoutez-y un champ et </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">définissez-le. </font><font style="vertical-align: inherit;">Les autres classes devraient changer leur logique selon que la grille est minimisée, nous allons donc rendre le champ général. </font><font style="vertical-align: inherit;">De plus, il vous permet de définir la valeur par défaut via l'inspecteur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCountX = <span class="hljs-number"><span class="hljs-number">20</span></span>, cellCountZ = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … cellCountX = x; cellCountZ = z; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; … }</code> </pre> <br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appels propres </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à deux endroits. </font><font style="vertical-align: inherit;">Nous pouvons simplement utiliser son propre champ pour l'argument d'effondrement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … CreateMap(cellCountX, cellCountZ, wrapping); } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z, wrapping)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/d57/fc1/36ad57fc1ff8967bbd8282808f762241.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le commutateur de pliage de grille est activé par défaut.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sauvegarde et chargement </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que le pliage est défini pour chaque carte, elle doit être enregistrée et chargée. </font><font style="vertical-align: inherit;">Cela signifie que vous devez modifier le format d'enregistrement des fichiers, augmentez donc la constante de version dans </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de l'enregistrement, laissez- </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le simplement écrire la valeur de pliage booléenne après la taille de la carte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); writer.Write(wrapping); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors du chargement, nous le lirons uniquement avec la version correcte du fichier. </font><font style="vertical-align: inherit;">Si elle est différente, il s'agit d'une ancienne carte et elle ne doit pas être minimisée. </font><font style="vertical-align: inherit;">Enregistrez ces informations dans une variable locale et comparez-les avec l'état actuel du pliage. </font><font style="vertical-align: inherit;">S'il est différent, nous ne pouvons pas réutiliser la topologie de carte existante de la même manière que lors du chargement d'une carte avec d'autres tailles.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ClearUnits(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping = header &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ? reader.ReadBoolean() : <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping != wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z, wrapping)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mesures pliantes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La réduction de la carte nécessitera des changements majeurs dans la logique, par exemple lors du calcul des distances. </font><font style="vertical-align: inherit;">Par conséquent, ils peuvent toucher du code qui n'a pas de lien direct avec la grille. </font><font style="vertical-align: inherit;">Au lieu de transmettre ces informations comme arguments, ajoutons-les à </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ajoutez un entier statique contenant la taille de pliage qui correspond à la largeur de la carte. </font><font style="vertical-align: inherit;">S'il est supérieur à zéro, il s'agit alors d'une carte pliable. </font><font style="vertical-align: inherit;">Pour vérifier cela, ajoutez une propriété.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Wrapping { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wrapSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons définir la taille de pliage pour chaque appel </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; HexMetrics.wrapSize = wrapping ? cellCountX : <span class="hljs-number"><span class="hljs-number">0</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que ces données ne survivront pas à la recompilation en mode Lecture, nous les configurerons </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; HexMetrics.wrapSize = wrapping ? cellCountX : <span class="hljs-number"><span class="hljs-number">0</span></span>; ResetVisibility(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Largeur de cellule </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous travaillez avec des cartes pliantes, nous devons souvent faire face à des positions le long de l'axe X, mesurées dans la largeur des cellules. </font><font style="vertical-align: inherit;">Bien qu'il puisse être utilisé pour cela </font></font><code>HexMetrics.innerRadius * 2f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il serait plus pratique de ne pas ajouter de multiplication à chaque fois. </font><font style="vertical-align: inherit;">Ajoutons donc une constante </font></font><code>HexMetrics.innerDiameter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerRadius = outerRadius * outerToInner; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerDiameter = innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On peut déjà utiliser le diamètre à trois endroits. </font><font style="vertical-align: inherit;">Tout d'abord, </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lors du positionnement d'une nouvelle cellule.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { Vector3 position; position.x = (x + z * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> - z / <span class="hljs-number"><span class="hljs-number">2</span></span>) * HexMetrics.innerDiameter; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxièmement, en </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limitant la position de la caméra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * HexMetrics.innerDiameter; position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et aussi dans la </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conversion de position en coordonnées.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = position.x / HexMetrics.innerDiameter; … }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Centrage de la carte </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque la carte ne s'effondre pas, elle a clairement défini les bords est et ouest, et donc un centre horizontal clair. </font><font style="vertical-align: inherit;">Mais dans le cas d'une carte pliable, tout est différent. </font><font style="vertical-align: inherit;">Il n'a ni le bord oriental ni le bord ouest, ni le centre. </font><font style="vertical-align: inherit;">Comme alternative, nous pouvons supposer que le centre est l'endroit où se trouve la caméra. </font><font style="vertical-align: inherit;">Cela sera utile car nous voulons que la carte soit toujours centrée sur notre point de vue. </font><font style="vertical-align: inherit;">Ensuite, où que nous soyons, nous ne verrons pas les bords est ou ouest de la carte.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colonnes de fragments de carte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que la visualisation de la carte soit centrée par rapport à la caméra, nous devons changer le placement des éléments en fonction du mouvement de la caméra. S'il se déplace vers l'ouest, nous devons prendre ce qui se trouve actuellement au bord de la partie orientale et le déplacer vers le bord de la partie ouest. La même chose s'applique à la direction opposée. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idéalement, dès que la caméra se déplace vers la colonne de cellules voisine, nous devons immédiatement déplacer la colonne de cellules la plus éloignée de l'autre côté. Cependant, nous n'avons pas besoin d'être aussi précis. Au lieu de cela, nous pouvons transférer des fragments de carte entiers. Cela nous permet de déplacer des parties de la carte sans avoir à modifier les maillages.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme nous déplaçons des colonnes entières de fragments en même temps, regroupons-les en créant un objet colonne parent pour chaque groupe. </font><font style="vertical-align: inherit;">Ajoutez un tableau pour ces objets </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et nous l'initialiserons </font></font><code>CreateChunks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous les utiliserons uniquement comme conteneurs, nous n'avons donc qu'à suivre le lien vers leurs composants </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Comme dans le cas des fragments, leurs positions initiales sont situées à l'origine locale des coordonnées de la grille.</font></font><br><br><pre> <code class="cs hljs"> Transform[] columns; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { columns = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Transform[chunkCountX]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { columns[x] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameObject(<span class="hljs-string"><span class="hljs-string">"Column"</span></span>).transform; columns[x].SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, le fragment doit devenir un enfant de la colonne correspondante, pas de la grille. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … chunks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexGridChunk[chunkCountX * chunkCountZ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; chunkCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { HexGridChunk chunk = chunks[i++] = Instantiate(chunkPrefab); chunk.transform.SetParent(columns[x], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/415/920/bb2/415920bb2e4e2e002793aaebee8e04e2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragments regroupés en colonnes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque tous les fragments sont maintenant devenus des enfants des colonnes, </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il nous suffit de détruire directement toutes les colonnes, pas les fragments. </font><font style="vertical-align: inherit;">Nous allons donc nous débarrasser des fragments de fille.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columns != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { Destroy(columns[i].gameObject); } } … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colonnes de téléportation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez à la </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nouvelle méthode </font></font><code>CenterMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec la position X comme paramètre. </font><font style="vertical-align: inherit;">Convertissez la position en index de colonne, en la divisant par la largeur du fragment en unités Unity. </font><font style="vertical-align: inherit;">Ce sera l'index de la colonne dans laquelle se trouve actuellement la caméra, c'est-à-dire que ce sera la colonne centrale de la carte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CenterMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xPosition</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerColumnIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il nous suffit de modifier la visualisation de la carte uniquement lorsque l'index de la colonne centrale change. </font><font style="vertical-align: inherit;">Alors, suivons-le sur le terrain. </font><font style="vertical-align: inherit;">Nous utilisons la valeur par défaut −1 lors de la création d'une carte afin que les nouvelles cartes soient toujours centrées.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentCenterColumnIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; currentCenterColumnIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; … } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CenterMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xPosition</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerColumnIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (centerColumnIndex == currentCenterColumnIndex) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } currentCenterColumnIndex = centerColumnIndex; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous connaissons l'indice de la colonne centrale, nous pouvons déterminer les indices minimum et maximum en soustrayant simplement et en ajoutant la moitié du nombre de colonnes. Puisque nous utilisons des valeurs entières, avec un nombre impair de colonnes, cela fonctionne parfaitement. Dans le cas d'un nombre pair, il ne peut pas y avoir de colonne parfaitement centrée, donc l'un des indices sera un cran plus loin que nécessaire. Cela crée un décalage d'une colonne dans la direction du bord le plus éloigné de la carte, mais pour nous, ce n'est pas un problème.</font></font><br><br><pre> <code class="cs hljs"> currentCenterColumnIndex = centerColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minColumnIndex = centerColumnIndex - chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxColumnIndex = centerColumnIndex + chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que ces indices peuvent être négatifs ou supérieurs à l'indice de colonne maximal naturel. </font><font style="vertical-align: inherit;">Le minimum est nul uniquement lorsque la caméra est proche du centre naturel de la carte. </font><font style="vertical-align: inherit;">Notre tâche consiste à déplacer les colonnes afin qu'elles correspondent à ces indices relatifs. </font><font style="vertical-align: inherit;">Cela peut être fait en modifiant la coordonnée X locale de chaque colonne de la boucle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minColumnIndex = centerColumnIndex - chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxColumnIndex = centerColumnIndex + chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; Vector3 position; position.y = position.z = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { position.x = <span class="hljs-number"><span class="hljs-number">0f</span></span>; columns[i].localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour chaque colonne, nous vérifions si l'indice de l'indice minimum est inférieur. </font><font style="vertical-align: inherit;">Si c'est le cas, alors c'est trop loin à gauche du centre. </font><font style="vertical-align: inherit;">Il doit se téléporter de l'autre côté de la carte. </font><font style="vertical-align: inherit;">Cela peut être fait en faisant sa coordonnée X égale à la largeur de la carte. </font><font style="vertical-align: inherit;">De même, si l'index de colonne est supérieur à l'index maximum, il est trop loin à droite du centre et devrait se téléporter de l'autre côté.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; minColumnIndex) { position.x = chunkCountX * (HexMetrics.innerDiameter * HexMetrics.chunkSizeX); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt; maxColumnIndex) { position.x = chunkCountX * -(HexMetrics.innerDiameter * HexMetrics.chunkSizeX); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { position.x = <span class="hljs-number"><span class="hljs-number">0f</span></span>; } columns[i].localPosition = position; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Déplacement de la caméra </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changez </font></font><code>HexMapCamera.AdjustPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour que lorsque vous travaillez avec une carte pliable, il </font></font><code>ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appelle à la </font><font style="vertical-align: inherit;">place </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tout d'abord, faites simplement de la nouvelle méthode un </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doublon </font></font><code>ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais avec la seule différence: au final, elle appellera </font></font><code>CenterMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { … transform.localPosition = grid.wrapping ? WrapPosition(position) : ClampPosition(position); } … <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WrapPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * HexMetrics.innerDiameter; position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); grid.CenterMap(position.x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que la carte soit immédiatement centrée, nous appelons la </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthode </font></font><code>ValidatePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; ValidatePosition(); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Déplacez-vous vers la gauche et la droite lorsque vous centrez l'appareil photo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous restreignions toujours le mouvement de la caméra, la carte essaie maintenant de se centrer par rapport à la caméra, téléportant des colonnes de fragments de carte si nécessaire. </font><font style="vertical-align: inherit;">Avec une petite carte et une caméra distante, cela est clairement visible, mais sur une grande carte, les fragments téléportés sont en dehors de la zone de vision de la caméra. </font><font style="vertical-align: inherit;">De toute évidence, seuls les bords est et ouest initiaux de la carte sont visibles, car il n'y a pas encore de triangulation entre eux. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Supprimer la restriction de sa coordonnée X afin de minimiser et d'une </font><font style="vertical-align: inherit;">caméra </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Au lieu de cela, nous continuerons d'augmenter la coordonnée X de la largeur de la carte lorsqu'elle est inférieure à zéro et de la réduire lorsqu'elle est supérieure à la largeur de la carte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WrapPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// float xMax = (grid.cellCountX - 0.5f) * HexMetrics.innerDiameter; // position.x = Mathf.Clamp(position.x, 0f, xMax); float width = grid.cellCountX * HexMetrics.innerDiameter; while (position.x &lt; 0f) { position.x += width; } while (position.x &gt; width) { position.x -= width; } float zMax = (grid.cellCountZ - 1) * (1.5f * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, 0f, zMax); grid.CenterMap(position.x); return position; }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La caméra déroulante se déplace le long de la carte.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Textures de shader pliables </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À l'exception de l'espace de triangulation, la réduction de la caméra en mode jeu devrait être imperceptible. Cependant, lorsque cela se produit, un changement visuel se produit dans la moitié de la topographie et de l'eau. Cela se produit parce que nous utilisons une position dans le monde pour échantillonner ces textures. Une téléportation nette du fragment modifie l'emplacement des textures. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons résoudre ce problème en faisant apparaître les textures dans des tuiles qui sont des multiples de la taille du fragment. La taille du fragment est calculée à partir des constantes dans </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, alors créons le fichier d' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inclusion du</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader </font><em><font style="vertical-align: inherit;">HexMetrics.cginc</font></em><font style="vertical-align: inherit;"> et collez-y les définitions correspondantes. L'échelle de mosaïque de base est calculée à partir de la taille du fragment et du rayon extérieur de la cellule. Si vous utilisez d'autres mesures, vous devrez modifier le fichier en conséquence.</font></font><br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OUTER_TO_INNER 0.866025404 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OUTER_RADIUS 10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHUNK_SIZE_X 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TILING_SCALE (1 / (CHUNK_SIZE_X * 2 * OUTER_RADIUS / OUTER_TO_INNER))</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela nous donne une échelle de tuilage de 0,00866025404. </font><font style="vertical-align: inherit;">Si nous utilisons un multiple entier de cette valeur, la texturation ne sera pas affectée par la téléportation de fragments. </font><font style="vertical-align: inherit;">De plus, les textures aux bords est et ouest de la carte se rejoindront de manière transparente après avoir triangulé correctement leur connexion. </font><font style="vertical-align: inherit;">Nous avons utilisé 0,02 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comme échelle UV dans le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Au lieu de cela, nous pouvons utiliser l'échelle de carrelage double, qui est de 0,01732050808. </font><font style="vertical-align: inherit;">L'échelle est obtenue un peu moins qu'elle ne l'était, et l'échelle de la texture a légèrement augmenté, mais visuellement elle est invisible.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexMetrics.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexCellData.cginc" … <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3( <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * (<span class="hljs-number"><span class="hljs-number">2</span></span> * TILING_SCALE), <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] ); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roads</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour le bruit UV, nous avons utilisé une échelle de 0,025. </font><font style="vertical-align: inherit;">Au lieu de cela, vous pouvez utiliser la triple échelle de mosaïque. </font><font style="vertical-align: inherit;">Cela nous donne 0,02598076212, ce qui est assez proche.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexMetrics.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, chez </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water.cginc,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous avons utilisé 0,015 pour la mousse et 0,025 pour les vagues. </font><font style="vertical-align: inherit;">Ici, nous pouvons à nouveau remplacer ces valeurs par une échelle de mosaïque doublée et triplée.</font></font><br><br><pre> <code class="hljs mel">#include <span class="hljs-string"><span class="hljs-string">"HexMetrics.cginc"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Foam (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shore, float2 worldXZ, sampler2D noiseTex) { shore = <span class="hljs-keyword"><span class="hljs-keyword">sqrt</span></span>(shore) * <span class="hljs-number"><span class="hljs-number">0.9</span></span>; float2 noiseUV = worldXZ + _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; float4 <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span> = tex2D(noiseTex, noiseUV * (<span class="hljs-number"><span class="hljs-number">2</span></span> * TILING_SCALE)); … } … <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Waves (float2 worldXZ, sampler2D noiseTex) { float2 uv1 = worldXZ; uv1.y += _Time.y; float4 noise1 = tex2D(noiseTex, uv1 * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); float2 uv2 = worldXZ; uv2.x += _Time.y; float4 noise2 = tex2D(noiseTex, uv2 * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); … }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'union de l'est et de l'ouest </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À ce stade, la seule preuve visuelle de la réduction de la carte est un petit écart entre les colonnes les plus à l'est et à l'ouest. </font><font style="vertical-align: inherit;">Cet écart se produit car nous n'avons pas encore triangulé les bords et les coins entre les cellules des côtés opposés de la carte sans plier.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/240/85f/e79/24085fe7986100674854b9c9a79c349c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espace sur le bord.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voisins pliants </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour trianguler la connexion est-ouest, nous devons faire en sorte que les cellules des côtés opposés soient voisines les unes des autres. </font><font style="vertical-align: inherit;">Jusqu'à présent, nous ne le faisons pas, car la </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">connexion E - W n'est établie avec la cellule précédente que si son index dans X est supérieur à zéro. </font><font style="vertical-align: inherit;">Pour réduire cette connexion, nous devons connecter la dernière cellule de la ligne avec la première cellule de la même ligne lorsque le pliage de la carte est activé.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.W, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping &amp;&amp; x == cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.E, cells[i - x]); } } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir établi la connexion des voisins E - W, nous obtenons une triangulation partielle de l'écart. </font><font style="vertical-align: inherit;">La connexion des bords n'est pas idéale, car la distorsion n'est pas masquée correctement. </font><font style="vertical-align: inherit;">Nous y reviendrons plus tard.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/68a/6b6/ce568a6b639801e47804eb35a62493c6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Composés E - W. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons également réduire les liens NE - SW. </font><font style="vertical-align: inherit;">Pour ce faire, connectez la première cellule de chaque ligne paire aux dernières cellules de la ligne précédente. </font><font style="vertical-align: inherit;">Ce sera juste la cellule précédente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.SetNeighbor(HexDirection.SW, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/239/66f/c3c/23966fc3c616ea9338a3a14d187dcc7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connexions NE - SW. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, les connexions SE - NW sont établies à la fin de chaque ligne impaire en dessous de la première. </font><font style="vertical-align: inherit;">Ces cellules doivent être connectées à la première cellule de la ligne précédente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX + <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.SetNeighbor( HexDirection.SE, cells[i - cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e8/df4/62e/3e8df462e076bbdf93396f6cec525cc4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Composés SE - NW.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pliage de bruit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour masquer parfaitement l'écart, nous devons nous assurer que les bords est et ouest de la carte correspondent au bruit parfaitement utilisé pour déformer les positions des sommets. </font><font style="vertical-align: inherit;">Nous pouvons utiliser la même astuce que celle utilisée pour les shaders, mais une échelle de bruit de 0,003 a été utilisée pour la distorsion. </font><font style="vertical-align: inherit;">Pour garantir la mosaïque, vous devez augmenter considérablement l'échelle, ce qui entraînera une distorsion plus chaotique des sommets. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une solution alternative n'est pas de mesurer le bruit, mais de faire une atténuation douce du bruit aux bords de la carte. </font><font style="vertical-align: inherit;">Si vous effectuez une atténuation douce sur la largeur d'une cellule, la distorsion créera une transition douce sans espaces. </font><font style="vertical-align: inherit;">Le bruit dans cette zone sera légèrement lissé et à longue distance, le changement semblera net, mais ce n'est pas si évident lorsque vous utilisez une légère distorsion des sommets.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et les fluctuations de température?</font></font></b> <div class="spoiler_text">           .      ,      .         ,   .     ,        . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous n'effondrons pas la carte, nous pouvons nous en tirer avec un </font></font><code>HexMetrics.SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seul échantillon. </font><font style="vertical-align: inherit;">Mais lors du pliage, il est nécessaire d'ajouter une atténuation. </font><font style="vertical-align: inherit;">Par conséquent, avant de renvoyer l'échantillon, enregistrez-le dans une variable.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sample; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la minimisation, nous devons mélanger avec le deuxième échantillon. </font><font style="vertical-align: inherit;">Nous effectuerons la transition dans la partie orientale de la carte, de sorte que le deuxième échantillon doit être déplacé vers l'ouest.</font></font><br><br><pre> <code class="cs hljs"> Vector4 sample = noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'atténuation est effectuée en utilisant une simple interpolation linéaire de la partie ouest vers la partie est, sur la largeur d'une cellule. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); sample = Vector4.Lerp( sample2, sample, position.x * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / innerDiameter) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/84f/75d/c4e84f75dd0260efb18a9d3d66647c55.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mélange de bruit, une solution imparfaite.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Par conséquent, nous n'obtenons pas de correspondance exacte, car certaines cellules du côté est ont des coordonnées X négatives. Pour ne pas approcher cette zone, déplaçons la région de transition vers la moitié ouest de la largeur de la cellule.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter * <span class="hljs-number"><span class="hljs-number">1.5f</span></span>) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); sample = Vector4.Lerp( sample2, sample, position.x * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / innerDiameter) - <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/af4/1fb/04faf41fb669427487a2dbb6855cd5bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atténuation correcte.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modification de cellule </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que la triangulation semble correcte, assurons-nous que nous pouvons tout éditer sur la carte et sur la couture de pliage. Il s'avère que, dans les fragments téléportés, les coordonnées sont erronées et les grands pinceaux sont coupés par une couture.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/18b/5ce/a1f18b5ce7b87b38a7a58d47e341d4f1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La brosse est taillée.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour résoudre ce problème, nous devons signaler le </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pliage. Nous pouvons le faire en faisant correspondre la coordonnée X dans la méthode constructeur. Nous savons que la coordonnée axiale X est obtenue à partir de la coordonnée X du décalage en soustrayant la moitié de la coordonnée Z. Vous pouvez utiliser ces informations pour effectuer la transformation inverse et vérifier si la coordonnée zéro est inférieure à zéro. Si oui, alors nous avons les coordonnées au-delà du côté est de la carte dépliée. Étant donné que dans chaque direction, nous ne téléportons pas plus de la moitié de la carte, il nous suffira d'ajouter une fois la taille de pliage à X. Et lorsque la coordonnée de décalage est supérieure à la taille de pliage, nous devons effectuer une soustraction.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HexCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oX = x + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oX &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x += HexMetrics.wrapSize; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oX &gt;= HexMetrics.wrapSize) { x -= HexMetrics.wrapSize; } } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.z = z; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parfois, lors de l'édition du bas ou du haut de la carte, j'obtiens des erreurs </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela se produit lorsque, en raison de la distorsion des sommets, le curseur apparaît dans la ligne de cellules en dehors de la carte. </font><font style="vertical-align: inherit;">Il s'agit d'un bogue qui se produit car nous ne faisons pas correspondre les coordonnées </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec le paramètre vectoriel. </font><font style="vertical-align: inherit;">Cela peut être résolu en appliquant une méthode </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec des coordonnées comme paramètres qui effectueront les vérifications nécessaires.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-comment"><span class="hljs-comment">// int index = // coordinates.X + coordinates.Z * cellCountX + coordinates.Z / 2; // return cells[index]; return GetCell(coordinates); }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pliage côtier </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La triangulation fonctionne bien pour le terrain, mais le long de la couture est-ouest, il n'y a pas de bords de la côte de l'eau. </font><font style="vertical-align: inherit;">En fait, ils le sont, ils ne s'effondrent pas. </font><font style="vertical-align: inherit;">Ils sont retournés et étirés de l'autre côté de la carte.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/20a/ed3/6fe20aed3cb0dea0a9e47ef08caa10f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bord de l'eau manquant. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela se produit, car lors de la triangulation de l'eau de la côte, nous utilisons la position d'un voisin. </font><font style="vertical-align: inherit;">Pour résoudre ce problème, nous devons déterminer ce à quoi nous avons affaire, situé de l'autre côté de la carte. </font><font style="vertical-align: inherit;">Pour simplifier la tâche, nous allons ajouter une </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">colonne de cellules </font><font style="vertical-align: inherit;">à la </font><font style="vertical-align: inherit;">propriété de l'index.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ColumnIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attribuez cet index à </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Elle est simplement égale à la coordonnée de décalage X divisée par la taille du fragment.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … cell.Index = i; cell.ColumnIndex = x / HexMetrics.chunkSizeX; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant </font></font><code>HexGridChunk.TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">déterminer ce qui est minimisé en comparant l'index de colonne de la cellule actuelle et de son voisin. </font><font style="vertical-align: inherit;">Si l'indice de la colonne du voisin est inférieur à un pas de moins, alors nous sommes du côté ouest et le voisin est du côté est. </font><font style="vertical-align: inherit;">Par conséquent, nous devons tourner notre voisin vers l'ouest. </font><font style="vertical-align: inherit;">Le même et dans la direction opposée.</font></font><br><br><pre> <code class="cs hljs"> Vector3 center2 = neighbor.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.ColumnIndex &lt; cell.ColumnIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>) { center2.x += HexMetrics.wrapSize * HexMetrics.innerDiameter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.ColumnIndex &gt; cell.ColumnIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) { center2.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f13/308/3ec/f133083ec9172168e5302d737fd0ce27.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Côtes de la côte, mais pas de coins. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons donc pris soin des côtes de la côte, mais jusqu'à présent, nous ne nous sommes pas occupés des virages. </font><font style="vertical-align: inherit;">Nous devons faire de même avec le prochain voisin.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 center3 = nextNeighbor.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor.ColumnIndex &lt; cell.ColumnIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>) { center3.x += HexMetrics.wrapSize * HexMetrics.innerDiameter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor.ColumnIndex &gt; cell.ColumnIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) { center3.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter; } Vector3 v3 = center3 + (nextNeighbor.IsUnderwater ? HexMetrics.GetFirstWaterCorner(direction.Previous()) : HexMetrics.GetFirstSolidCorner(direction.Previous())); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d02/c0d/751/d02c0d7510fba8b3707b89f146b71837.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Côte correctement réduite.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Génération de cartes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'option de connexion des côtés est et ouest affecte la génération de cartes. </font><font style="vertical-align: inherit;">Lors de la minimisation de la carte, l'algorithme de génération doit également être minimisé. </font><font style="vertical-align: inherit;">Cela conduira à la création d'une autre carte, mais lorsque vous utilisez une </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bordure de carte X</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> non nulle </font><em><font style="vertical-align: inherit;">, le</font></em><font style="vertical-align: inherit;"> pliage n'est pas évident.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/01f/f90/54001ff900386d5f389850de0a1d0034.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/428/859/ecb/428859ecb5c5bf9a68b277675110e44b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grande carte 1208905299 avec paramètres par défaut. Avec pliage et sans elle.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quand elle est </font><font style="vertical-align: inherit;">réduite n'a pas de </font><font style="vertical-align: inherit;">sens d'utiliser </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la carte frontière X</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mais nous ne pouvons pas nous en débarrasser, car en même temps les régions fusionneront. Lors de la réduction, nous pouvons simplement utiliser un </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RegionBorder</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous changeons </font></font><code>HexMapGenerator.CreateRegions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en remplaçant dans tous les cas </font></font><code>mapBorderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par </font></font><code>borderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cette nouvelle variable sera égale à ou </font></font><code>regionBorder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ou </font></font><code>mapBorderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, selon la valeur de l'option de réduction. Ci-dessous, j'ai montré les changements uniquement pour le premier cas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> borderX = grid.wrapping ? regionBorder : mapBorderX; MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le même temps, les régions restent séparées, mais cela n'est nécessaire que s'il existe différentes régions sur les côtés est et ouest de la carte. </font><font style="vertical-align: inherit;">Il y a deux cas où cela n'est pas respecté. </font><font style="vertical-align: inherit;">Le premier, c'est quand nous n'avons qu'une seule région. </font><font style="vertical-align: inherit;">La seconde est lorsque deux régions divisent la carte horizontalement. </font><font style="vertical-align: inherit;">Dans ces cas, nous pouvons attribuer une </font></font><code>borderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur de zéro, ce qui permettra aux masses terrestres de traverser la couture est-ouest.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.wrapping) { borderX = <span class="hljs-number"><span class="hljs-number">0</span></span>; } region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.wrapping) { borderX = <span class="hljs-number"><span class="hljs-number">0</span></span>; } region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/4d4/c9e/db84d4c9e40c9e35ad29af69314f73e1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une région s'effondre. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À première vue, il semble que tout fonctionne correctement, mais il y a en fait un espace le long de la couture. </font><font style="vertical-align: inherit;">Cela devient plus visible si vous définissez le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pourcentage d'érosion sur</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zéro.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/a4e/572/ef5a4e5722dbbb8af91e770220d7d141.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b3/f75/fce/6b3f75fce35d6be9c8a66c445c4dc9cd.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque l'érosion est désactivée, une couture sur le relief devient perceptible.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'écart se produit parce que la couture empêche la croissance des fragments de relief. Pour déterminer ce qui est ajouté en premier, la distance entre la cellule et le centre du fragment est utilisée, et les cellules de l'autre côté de la carte peuvent être très éloignées, de sorte qu'elles ne s'allument presque jamais. Bien sûr, c'est faux. Nous devons nous assurer que nous </font></font><code>HexCoordinates.DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">connaissons la carte minimisée. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous calculons la distance entre </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en additionnant les distances absolues le long de chacun des trois axes et en divisant par deux le résultat. La distance le long de Z est toujours vraie, mais le pliage le long peut affecter les distances X et Y. Commençons donc par un calcul séparé de X + Y.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// return // ((x &lt; other.x ? other.x - x : x - other.x) + // (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + // (z &lt; other.z ? other.z - z : z - other.z)) / 2; int xy = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); return (xy + (z &lt; other.z ? other.z - z : z - other.z)) / 2; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Déterminer si le pliage crée une distance plus courte pour les cellules arbitraires n'est pas une tâche facile, alors calculons simplement X + Y pour les cas où nous plions une autre coordonnée du côté ouest. </font><font style="vertical-align: inherit;">Si la valeur est inférieure au X + Y d'origine, utilisez-la.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xy = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { other.x += HexMetrics.wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si cela ne conduit pas à une distance plus courte, il est possible de tourner plus court dans l'autre sens, nous allons donc le vérifier. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { other.x += HexMetrics.wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { other.x -= <span class="hljs-number"><span class="hljs-number">2</span></span> * HexMetrics.wrapSize; xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous obtenons toujours la distance la plus courte sur la carte pliable. </font><font style="vertical-align: inherit;">Les fragments de terrain ne sont plus bloqués par une couture, ce qui permet aux masses terrestres de se recroqueviller.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/fb7/3b8/65cfb73b8107d7744ff8cdcabaf48083.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/149/e6f/717/149e6f717defe9288565f37f7efcdf56.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relief repliable correctement sans érosion ni érosion. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voyager dans le monde </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Après avoir envisagé la génération et la triangulation de cartes, passons maintenant à la vérification des escouades, de l'exploration et de la visibilité. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Couture d'essai </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le premier obstacle que nous rencontrons lors du déplacement d'une équipe dans le monde est le bord de la carte, qui ne peut pas être exploré. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/4f4/748/4524f4748d2c4e3cb983ec5ecbf064c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La couture de la carte ne peut pas être examinée. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les cellules le long du bord de la carte sont rendues inexplorées pour masquer l'achèvement brutal de la carte. </font><font style="vertical-align: inherit;">Mais lorsque la carte est minimisée, seules les cellules nord et sud doivent être marquées, mais pas l'est et l'ouest. </font><font style="vertical-align: inherit;">Modifiez </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour en tenir compte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.Explorable = z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.Explorable = x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibilité des reliefs </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vérifions maintenant si la visibilité fonctionne le long de la couture. </font><font style="vertical-align: inherit;">Cela fonctionne pour le terrain, mais pas pour les objets de terrain. </font><font style="vertical-align: inherit;">Il semble que les objets qui se replient obtiennent la visibilité de la dernière cellule qui n'a pas été réduite.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/ac1/811/631ac18111ba1eb8dfcf74a39fb2ffbe.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visibilité incorrecte des objets. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela se produit car le mode de </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">serrage est défini </font><font style="vertical-align: inherit;">pour le mode de pliage de texture utilisé </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour résoudre le problème, changez simplement son mode de serrage pour répéter. </font><font style="vertical-align: inherit;">Mais nous devons faire est seulement de coordonner U, nous à </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demander </font></font><code>wrapModeU</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>wrapModeV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">individuellement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTexture) { cellTexture.Resize(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; <span class="hljs-comment"><span class="hljs-comment">// cellTexture.wrapMode = TextureWrapMode.Clamp; cellTexture.wrapModeU = TextureWrapMode.Repeat; cellTexture.wrapModeV = TextureWrapMode.Clamp; Shader.SetGlobalTexture("_HexCellData", cellTexture); } … }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escouades et colonnes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un autre problème est que les unités ne s'effondrent pas encore. </font><font style="vertical-align: inherit;">Après avoir déplacé la colonne dans laquelle ils se trouvent, les unités restent au même endroit.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c50/29b/827/c5029b8273d7b53a3ddac2da03d9987f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'unité n'est pas transférée et est du mauvais côté. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce problème peut être résolu en faisant des escouades des éléments enfants de colonnes, comme nous l'avons fait avec des fragments. </font><font style="vertical-align: inherit;">Premièrement, nous ne ferons plus d'eux les enfants immédiats du réseau </font></font><code>HexGrid.AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">// unit.transform.SetParent(transform, false); unit.Location = location; unit.Orientation = orientation; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que les unités se déplacent, elles peuvent apparaître dans une autre colonne, c'est-à-dire qu'il sera nécessaire de changer leur parent. </font><font style="vertical-align: inherit;">Pour rendre cela possible, nous ajoutons à la </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthode générale </font></font><code>MakeChildOfColumn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et comme paramètres nous lui passons le composant de l' </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">élément enfant et l'index de la colonne.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeChildOfColumn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Transform child, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> columnIndex</span></span></span><span class="hljs-function">)</span></span> { child.SetParent(columns[columnIndex], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous appellerons cette méthode lorsque la propriété est définie </font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { … <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { … Grid.MakeChildOfColumn(transform, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.ColumnIndex); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela résout le problème de la création d'unités. </font><font style="vertical-align: inherit;">Mais nous devons également les faire passer à la colonne souhaitée lors du déplacement. </font><font style="vertical-align: inherit;">Pour ce faire, vous devez suivre </font></font><code>HexUnit.TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la colonne actuelle </font><font style="vertical-align: inherit;">dans l' </font><font style="vertical-align: inherit;">index. </font><font style="vertical-align: inherit;">Au début de cette méthode, il s'agit de l'index de la colonne de cellules au début du chemin, ou de l'actuel si le déplacement a été interrompu par recompilation.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Grid.DecreaseVisibility( // currentTravelLocation ? currentTravelLocation : pathToTravel[0], // VisionRange // ); if (!currentTravelLocation) { currentTravelLocation = pathToTravel[0]; } Grid.DecreaseVisibility(currentTravelLocation, VisionRange); int currentColumn = currentTravelLocation.ColumnIndex; … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lors de chaque itération du déplacement, nous vérifierons si l'index de la colonne suivante est différent, et si c'est le cas, nous changerons le parent de la commande. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentColumn = currentTravelLocation.ColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { … Grid.IncreaseVisibility(pathToTravel[i], VisionRange); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextColumn = currentTravelLocation.ColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentColumn != nextColumn) { Grid.MakeChildOfColumn(transform, nextColumn); currentColumn = nextColumn; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela permettra aux unités de se déplacer de la même manière que les fragments. </font><font style="vertical-align: inherit;">Cependant, lors du déplacement à travers la couture de la carte, les unités ne s'effondrent pas encore. </font><font style="vertical-align: inherit;">Au lieu de cela, ils commencent soudainement à se déplacer dans la mauvaise direction. </font><font style="vertical-align: inherit;">Cela se produit quel que soit l'emplacement de la couture, mais surtout quand ils sautent sur toute la carte.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Courses de chevaux sur la carte. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, nous pouvons utiliser la même approche que celle utilisée pour la côte, mais cette fois, nous allons tourner la courbe le long de laquelle le détachement se déplace. </font><font style="vertical-align: inherit;">Si la colonne suivante est tournée vers l'est, nous téléporterons également la courbe vers l'est, de même pour l'autre direction. </font><font style="vertical-align: inherit;">Vous devez modifier les points de contrôle de la courbe </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui affectera également le point de contrôle </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { currentTravelLocation = pathToTravel[i]; a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; <span class="hljs-comment"><span class="hljs-comment">// c = (b + currentTravelLocation.Position) * 0.5f; // Grid.IncreaseVisibility(pathToTravel[i], VisionRange); int nextColumn = currentTravelLocation.ColumnIndex; if (currentColumn != nextColumn) { if (nextColumn &lt; currentColumn - 1) { ax -= HexMetrics.innerDiameter * HexMetrics.wrapSize; bx -= HexMetrics.innerDiameter * HexMetrics.wrapSize; } else if (nextColumn &gt; currentColumn + 1) { ax += HexMetrics.innerDiameter * HexMetrics.wrapSize; bx += HexMetrics.innerDiameter * HexMetrics.wrapSize; } Grid.MakeChildOfColumn(transform, nextColumn); currentColumn = nextColumn; } c = (b + currentTravelLocation.Position) * 0.5f; Grid.IncreaseVisibility(pathToTravel[i], VisionRange); … }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mouvement avec pliage.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La dernière chose à faire est de changer le tour initial de l'escouade lorsqu'elle regarde la première cellule dans laquelle elle se déplacera. Si cette cellule se trouve de l'autre côté de la couture est-ouest, l'unité regardera dans la mauvaise direction. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la réduction d'une carte, il existe deux façons de regarder un point qui n'est pas exactement au nord ou au sud. Vous pouvez regarder à l'est ou à l'ouest. Il sera logique de regarder dans la direction correspondant à la distance la plus proche du point, car c'est également la direction du mouvement, alors utilisons-la </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la réduction, nous vérifierons la distance relative le long de l'axe X. Si elle est inférieure à la moitié négative de la largeur de la carte, alors nous devrions regarder vers l'ouest, ce qui peut être fait en tournant le point vers l'ouest. </font><font style="vertical-align: inherit;">Sinon, si la distance est supérieure à la moitié de la largeur de la carte, alors nous devons nous effondrer vers l'est.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDistance = point.x - transform.localPosition.x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDistance &lt; -HexMetrics.innerRadius * HexMetrics.wrapSize) { point.x += HexMetrics.innerDiameter * HexMetrics.wrapSize; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDistance &gt; HexMetrics.innerRadius * HexMetrics.wrapSize) { point.x -= HexMetrics.innerDiameter * HexMetrics.wrapSize; } } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons donc une carte minimisée entièrement fonctionnelle. </font><font style="vertical-align: inherit;">Et cela conclut la série de tutoriels sur les cartes hexagonales. </font><font style="vertical-align: inherit;">Comme mentionné dans les sections précédentes, d'autres sujets peuvent être considérés, mais ils ne sont pas spécifiques aux cartes hexagonales. </font><font style="vertical-align: inherit;">Je les considérerai peut-être dans de futures séries de tutoriels.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai téléchargé le dernier package et j'obtiens des erreurs de tours en mode Play</font></font></b> <div class="spoiler_text">  ,       <em>Rotation</em> .    .  .   5. </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai téléchargé le dernier package et les graphismes ne sont pas aussi beaux que dans les captures d'écran</font></font></b> <div class="spoiler_text">        . -    . </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai téléchargé le dernier paquet et il génère constamment la même carte</font></font></b> <div class="spoiler_text">      seed (1208905299),      .    ,  <em>Use Fixed Seed</em> . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427567/">https://habr.com/ru/post/fr427567/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427555/index.html">Les animaux que les humains ont appris à suivre à l'aide de la technologie de reconnaissance faciale</a></li>
<li><a href="../fr427557/index.html">Résumé des événements informatiques en novembre (première partie)</a></li>
<li><a href="../fr427561/index.html">Droit de réparer: les premiers pas dans la bonne direction de Motorola</a></li>
<li><a href="../fr427563/index.html">Norme SNI cryptée implémentée dans Firefox Nightly</a></li>
<li><a href="../fr427565/index.html">«Ma réussite est que je suis généralement retourné à la profession» - 10 questions au programmeur, numéro 10</a></li>
<li><a href="../fr427569/index.html">Ajustez OpenStack sous forte charge</a></li>
<li><a href="../fr427571/index.html">L'union de R et PostgreSQL. Nous analysons le travail des aéroports, calculons les pensions</a></li>
<li><a href="../fr427573/index.html">Candy or Life: Halloween comme raison pour attirer votre enfant vers la science</a></li>
<li><a href="../fr427575/index.html">Pourquoi le Wi-Fi ne fonctionnera pas comme prévu et pourquoi savoir quel téléphone l'employé utilise</a></li>
<li><a href="../fr427577/index.html">Apprentissage automatique vs analyse de signature lors de la détection d'attaques sur une application Web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>