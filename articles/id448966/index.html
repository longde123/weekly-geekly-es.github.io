<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•¤ ğŸš· ğŸ– Aplikasi Android dalam memori. Laporan Pengoptimalan untuk Yandex.Luncher â¯ï¸ ğŸ˜“ ğŸ•¦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sistem Android Go yang ringan telah meningkatkan persyaratan untuk aplikasi yang telah diinstal sebelumnya - ukuran dan memori yang digunakan. Kami me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aplikasi Android dalam memori. Laporan Pengoptimalan untuk Yandex.Luncher</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/448966/">  Sistem Android Go yang ringan telah meningkatkan persyaratan untuk aplikasi yang telah diinstal sebelumnya - ukuran dan memori yang digunakan.  Kami menghadapi tantangan untuk memenuhi persyaratan ini.  Kami melakukan sejumlah optimisasi dan memutuskan untuk secara serius mengubah arsitektur shell grafis kami - Yandex.Luncher.  Kepala tim pengembangan aplikasi mobile Alexander Starchenko berbagi pengalaman ini. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/N0KQBUZE78E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Nama saya Alexander, saya dari St. Petersburg, dari tim yang mengembangkan Yandex.Loncher dan Yandex.Phone.  Hari ini saya akan memberi tahu Anda bagaimana kami mengoptimalkan memori di Launcher.  Pertama, saya akan menjelaskan secara singkat apa itu Launcher.  Selanjutnya, kita membahas alasan mengapa kita perlu mengoptimalkan memori.  Setelah itu, kami akan mempertimbangkan cara mengukur memori dengan benar dan terdiri dari apa.  Kemudian mari kita lanjutkan berlatih.  Saya akan berbicara tentang bagaimana kita mengoptimalkan memori di Launcher dan bagaimana kita sampai pada solusi radikal untuk masalah ini.  Dan pada akhirnya saya akan berbicara tentang bagaimana kita memantau penggunaan memori, bagaimana kita mengendalikannya. <br><br><a name="habracut"></a><img src="https://habrastorage.org/webt/xr/t0/xs/xrt0xsqk_pktna1g_ggaf3rd780.jpeg"><br><br>  "Peluncur" atau "Peluncur" - tidak begitu penting.  Kami di Yandex biasa memanggilnya Peluncur, dan dalam laporan saya akan menggunakan kata "Peluncur". <br><br><img src="https://habrastorage.org/webt/h8/dr/cg/h8drcg1kc0mm6cmr6zxew8g60gs.jpeg"><br><br>  Poin penting lainnya: Peluncur didistribusikan secara luas melalui preset, yaitu, ketika Anda membeli ponsel baru, Yandex.Loncher cukup sering berubah menjadi satu-satunya manajer aplikasi, manajer desktop rumah di ponsel Anda. <br><br>  Sekarang untuk alasan mengapa kita perlu mengoptimalkan memori.  Saya akan mulai dengan alasan kami.  Singkatnya, ini Android Go.  Dan sekarang lebih lama.  Pada akhir 2017, Google memperkenalkan Android Oreo dan versi khusus, edisi Android Oreo Go.  Apa yang spesial tentang ini?  Versi ini dirancang untuk ponsel kelas bawah, untuk ponsel murah dengan RAM hingga satu gigabyte.  Apa lagi yang dia spesial?  Untuk aplikasi yang sudah diinstal pada versi Android ini, Google mengajukan persyaratan tambahan.  Secara khusus - persyaratan untuk konsumsi RAM.  Secara kasar, beberapa saat setelah peluncuran, memori aplikasi dihapus, dan ukurannya tidak boleh melebihi 30-50 megabita untuk Peluncur, tergantung pada ukuran layar ponsel.  30 pada yang terkecil, 50 pada layar besar. <br><br>  Perlu juga dicatat bahwa Google terus mengembangkan daerah ini, dan sudah ada edisi Android Pie Go. <br><br>  Apa alasan lain untuk mengoptimalkan penggunaan memori?  Pertama, aplikasi Anda cenderung tidak akan mengunduh.  Kedua, ini akan bekerja lebih cepat, karena akan lebih kecil kemungkinannya untuk memungut pemulung dan memori akan lebih jarang dialokasikan.  Objek tambahan tidak akan dibuat, tampilan tambahan tidak akan meningkat, dll. Secara tidak langsung, menilai dari pengalaman kami, ini akan menyebabkan penurunan ukuran apk aplikasi Anda.  Semua ini bersama-sama akan memberi Anda lebih banyak instalasi dan peringkat yang lebih baik di Google Play. <br><br>  Oke, sekarang kita tahu mengapa mengoptimalkan memori.  Mari kita lihat apa artinya mengukur dan terdiri dari apa. <br><br><img src="https://habrastorage.org/webt/k5/ne/mc/k5nemcimfyrquzgc_jdeijvo0mq.jpeg"><h5>  <sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan dari slide</a></sub></sup> </h5><br>  Mungkin banyak dari Anda telah melihat gambar ini.  Ini adalah tangkapan layar dari Android Studio Profile, dari tampilan memori.  Alat ini dijelaskan secara cukup rinci di developer.android.com.  Mungkin banyak dari Anda telah menggunakannya.  Siapa yang tidak menggunakan - coba. <br><br>  Apa yang baik di sini?  Itu selalu ada di tangan.  Lebih mudah digunakan dalam proses pengembangan.  Namun, ia memiliki beberapa kelemahan.  Tidak semua alokasi aplikasi Anda terlihat di sini.  Misalnya, font yang diunduh tidak terlihat di sini.  Juga, dengan bantuan alat ini tidak nyaman untuk melihat kelas mana yang dimuat ke dalam memori, dan Anda tidak dapat menggunakan alat ini dalam mode otomatis, yaitu, Anda tidak dapat mengonfigurasi beberapa jenis tes otomatis berdasarkan pada Android Studio Profile. <br><br><img src="https://habrastorage.org/webt/-g/hh/gz/-ghhgzcyruqxpu3trjt_ipssimi.jpeg"><h5>  <sup><sub>Tautan dari slide: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kedua</a></sub></sup> </h5><br>  Alat berikut telah ada sejak pengembangan Android di Eclipse, singkatnya adalah Memory Analyzer, MAT.  Ini disediakan sebagai aplikasi mandiri dan kompatibel dengan dump memori yang dapat Anda simpan dari Android Studio. <br><br>  Untuk melakukan ini, Anda harus menggunakan utilitas kecil, konverter profesional.  Muncul dengan edisi Android Go dan memiliki beberapa keunggulan.  Sebagai contoh, ia dapat membangun Paths ke gs root.  Ini sangat membantu kami untuk melihat kelas mana yang dimuat oleh Launcher dan kapan mereka dimuat.  Kami tidak dapat melakukan ini menggunakan Android Studio Profiler. <br><br><img src="https://habrastorage.org/webt/4r/uj/gz/4rujgzsgzvpcrxk6f5izyljrb8y.jpeg"><br><br>  Alat selanjutnya adalah utilitas dumpsys, khususnya dumpsys meminfo.  Di sini Anda melihat bagian dari output dari perintah ini.  Ini memberikan pengetahuan tingkat tinggi tentang konsumsi memori.  Namun, ia memiliki kelebihan tertentu.  Lebih mudah digunakan dalam mode otomatis.  Anda dapat dengan mudah mengkonfigurasi tes yang menjalankan perintah ini.  Ini juga menunjukkan memori segera untuk semua proses.  Dan menunjukkan semua lokasi.  Sejauh yang kami tahu, Google menggunakan nilai memori dari alat ini dalam proses pengujian. <br><br>  Mari kita gunakan contoh output untuk menjelaskan secara singkat apa yang terdiri dari memori aplikasi.  Yang pertama adalah Java Heap, semua lokasi kode Java dan Kotlin Anda.  Biasanya bagian ini cukup besar.  Selanjutnya adalah Native Heap.  Berikut adalah alokasi dari kode asli.  Bahkan jika Anda tidak secara eksplisit menggunakan kode asli dalam aplikasi Anda, alokasi akan ada di sini, karena banyak objek Android - tampilan yang sama - mengalokasikan memori asli.  Bagian selanjutnya adalah Kode.  Segala sesuatu yang berkaitan dengan kode sampai di sini: bytecode, font.  Kode juga bisa sangat besar jika Anda menggunakan banyak pustaka pihak ketiga yang tidak dioptimalkan.  Berikut ini adalah tumpukan perangkat lunak Jawa dan kode asli, biasanya kecil.  Selanjutnya adalah memori grafis.  Ini termasuk Permukaan, tekstur, yaitu, memori yang menyebar antara CPU dan GPU digunakan untuk rendering.  Berikutnya adalah bagian Pribadi Lainnya.  Ini termasuk semua yang tidak termasuk dalam bagian di atas, segala sesuatu yang sistem tidak bisa hancurkan.  Biasanya ini adalah semacam alokasi asli.  Berikutnya adalah bagian Sistem, ini adalah bagian dari memori sistem yang dikaitkan dengan aplikasi Anda. <br><br>  Dan pada akhirnya kami memiliki TOTAL, ini adalah jumlah dari semua bagian yang terdaftar.  Kami ingin menguranginya. <br><br><img src="https://habrastorage.org/webt/py/uo/bk/pyuobklgdmuxby3witoq9fltrve.jpeg"><br><br>  Apa lagi yang penting untuk diketahui tentang pengukuran memori?  Pertama-tama, aplikasi kita tidak sepenuhnya mengendalikan semua alokasi.  Artinya, kami, sebagai pengembang, tidak memiliki kendali penuh atas kode apa yang akan diunduh. <br><br>  Berikut ini.  Memori aplikasi dapat melompat banyak.  Selama proses pengukuran, Anda dapat mengamati perbedaan kuat dalam bacaan.  Ini mungkin karena waktu yang dibutuhkan serta berbagai skenario.  Dalam hal ini, ketika kita mengoptimalkan memori, menganalisisnya, sangat penting untuk melakukan ini dalam kondisi yang sama.  Idealnya, di perangkat yang sama.  Lebih baik lagi jika Anda memiliki opsi untuk memanggil Pengumpul Sampah. <br><br>  Bagus  Kita tahu mengapa kita perlu mengoptimalkan memori, bagaimana mengukurnya dengan benar, terdiri dari apa.  Ayo berlatih, dan saya akan memberi tahu Anda bagaimana kami mengoptimalkan memori di Launcher. <br><br><img src="https://habrastorage.org/webt/zy/t3/1q/zyt31qv6xboliaaetsqazvim8bi.jpeg"><br><br>  Itu adalah situasi pada awalnya.  Kami memiliki tiga proses, yang secara total dialokasikan sekitar 120 megabita.  Ini hampir empat kali lebih banyak dari yang kita ingin terima. <br><br><img src="https://habrastorage.org/webt/xe/yt/tz/xeyttza29z1cbtkjhtwhanq2owm.jpeg"><br><br>  Mengenai alokasi proses utama, ada bagian besar Java Heap, banyak grafik, kode besar, dan Native Heap yang cukup besar. <br><br><img src="https://habrastorage.org/webt/yl/8o/d6/yl8od64p4hs9jorsk5iftlexh-s.jpeg"><br><br>  Pertama, kami mendekati masalah dengan cukup naif dan memutuskan untuk mengikuti beberapa rekomendasi dari Google dari beberapa sumber, mencoba menyelesaikan masalah dengan cepat.  Kami menarik perhatian pada metode sintetis yang dihasilkan selama proses kompilasi.  Kami memiliki lebih dari 2 ribu dari mereka.  Dalam beberapa jam, kita semua menghapusnya, menghapus memori. <br><br><img src="https://habrastorage.org/webt/-n/k5/sx/-nk5sxehumnmvysfxp79-yjecq0.jpeg"><br><br>  Dan mereka mendapat keuntungan sekitar satu atau dua megabyte di bagian kode.  Bagus <br><br>  Selanjutnya, kami mengalihkan perhatian ke enum.  Seperti yang Anda tahu, enum adalah kelas.  Dan seperti yang Google akhirnya akui, enum tidak terlalu efisien dalam memori.  Kami menerjemahkan semua enum ke InDef dan StringDef.  Di sini Anda dapat mengajukan keberatan kepada saya bahwa ProgArt akan membantu di sini.  Namun pada kenyataannya, ProgArt tidak akan mengganti semua enum dengan tipe primitif.  Lebih baik melakukannya sendiri.  Omong-omong, kami punya lebih dari 90 enum, cukup banyak. <br><br><img src="https://habrastorage.org/webt/cs/na/lo/csnalohjmgwggcngzvyhk3p57wo.jpeg"><br><br>  Pengoptimalan ini telah memakan waktu berhari-hari, karena sebagian besar harus dilakukan secara manual, dan kami memenangkan sekitar tiga hingga enam megabita di bagian tumpukan Java. <br><br>  Selanjutnya, kami menarik perhatian ke koleksi.  Kami menggunakan koleksi Java yang cukup standar, seperti HashMap.  Kami memiliki lebih dari 150 dari mereka, dan semuanya diciptakan pada awal Launcher.  Kami menggantinya dengan SparseArray, SimpleArrayMap dan ArrayMap dan mulai membuat koleksi dengan ukuran yang telah ditentukan sehingga slot kosong tidak akan dialokasikan.  Artinya, kami meneruskan ukuran koleksi ke konstruktor. <br><br><img src="https://habrastorage.org/webt/dl/rt/k9/dlrtk9aikfqhhp1d5mduorrq2wy.jpeg"><br><br>  Ini juga memberikan keuntungan tertentu, dan pengoptimalan ini juga memakan waktu berhari-hari, yang sebagian besar kami lakukan secara manual. <br><br>  Kemudian kami mengambil langkah yang lebih spesifik.  Kami melihat bahwa kami memiliki tiga proses.  Seperti yang kita ketahui, bahkan proses kosong di Android membutuhkan sekitar 8-10 megabita memori, cukup banyak. <br><br>  Rincian tentang proses itu disampaikan oleh rekan saya Arthur Vasilov.  Belum lama ini di konferensi Mosdroid <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">adalah laporannya</a> , juga tentang Android Go. <br><br><img src="https://habrastorage.org/webt/16/i-/z-/16i-z-on0lf0lvdu5vk6fv0yilm.jpeg"><br><br>  Apa yang kami miliki setelah optimasi ini?  Pada perangkat uji utama, kami mengamati konsumsi memori di wilayah 80-100 megabyte, tidak cukup buruk, tetapi masih belum cukup.  Kami mulai mengukur memori pada perangkat lain.  Kami menemukan bahwa pada perangkat yang lebih cepat, konsumsi memori jauh lebih besar.  Ternyata kami memiliki banyak inisialisasi tertunda yang berbeda.  Setelah beberapa waktu, Launcher menggelembungkan beberapa tampilan, memulai beberapa perpustakaan, dll. <br><br><img src="https://habrastorage.org/webt/qh/ql/ci/qhqlcieho2jhn-xhewlehklbg_s.jpeg"><br><br>  Apa yang telah kita lakukan  Pertama-tama, kami melewati tampilan, semua tata letak.  Menghapus semua tampilan yang meningkat dengan visibilitas yang hilang.  Mereka membawa mereka ke tata letak yang terpisah, mulai mengembang mereka secara terprogram.  Yang tidak kami butuhkan, kami biasanya berhenti menggembung sampai saat pengguna membutuhkannya.  Kami memperhatikan optimasi gambar.  Kami berhenti memuat gambar yang tidak dilihat pengguna saat ini.  Dalam kasus Launcher, ini adalah gambar-ikon aplikasi dalam daftar aplikasi lengkap.  Sampai pembukaannya, kami tidak mengirimkannya.  Ini memberi kami kemenangan yang sangat baik di bagian grafis. <br><br>  Kami juga memeriksa cache gambar kami di memori.  Ternyata tidak semuanya optimal, tidak semua gambar yang sesuai dengan layar ponsel tempat Launcher dijalankan disimpan dalam memori. <br><br>  Setelah itu, kami mulai menganalisis bagian kode dan memperhatikan bahwa kami memiliki banyak kelas yang agak berat dari suatu tempat.  Ternyata ini sebagian besar adalah kelas perpustakaan.  Kami menemukan beberapa hal aneh di beberapa perpustakaan.  Salah satu perpustakaan membuat HashMap dan dalam initializer statis itu menyumbatnya dengan sejumlah objek yang cukup besar. <br><br><img src="https://habrastorage.org/webt/l4/vz/tf/l4vztfbwdffshzw5jf9ltshzjbs.jpeg"><br><br>  Perpustakaan lain juga memuat file audio dalam blok statis, yang menempati sekitar 700 kilobyte memori. <br><br><img src="https://habrastorage.org/webt/uz/ku/-p/uzku-pmqzppvtwsdiexoxm3cs6q.jpeg"><br><br>  Kami berhenti menginisialisasi perpustakaan seperti itu, mulai bekerja dengannya hanya ketika fungsi-fungsi ini benar-benar dibutuhkan oleh pengguna.  Semua optimisasi ini memakan waktu beberapa minggu.  Kami menguji banyak, memeriksa bahwa kami tidak memperkenalkan masalah tambahan.  Tapi kami juga mendapat kemenangan yang cukup baik, sekitar 25 dari 40 megabita di bagian Native, Heap, Code, dan Java Heap. <br><br>  Tetapi ini tidak cukup.  Konsumsi memori masih belum turun hingga 30 megabyte.  Tampaknya kami telah kehabisan semua opsi untuk beberapa optimasi otomatis dan aman sederhana. <br><br>  Kami memutuskan untuk mempertimbangkan solusi radikal.  Di sini kita melihat dua pilihan - pembuatan aplikasi lite-terpisah atau pemrosesan arsitektur Launcher dan transisi ke arsitektur modular dengan kemampuan untuk membangun Launcher tanpa modul tambahan.  Opsi pertama cukup panjang dan mahal.  Kemungkinan besar, pembuatan aplikasi semacam itu akan menghasilkan aplikasi terpisah yang lengkap untuk Anda, yang perlu didukung dan dikembangkan sepenuhnya.  Di sisi lain, opsi dengan arsitektur modular juga cukup mahal, cukup berisiko, tetapi tetap lebih cepat, karena Anda sudah bekerja dengan basis kode yang terkenal, Anda sudah memiliki serangkaian tes unit otomatis, tes integrasi, dan tes manual kasus. <br><br>  Perlu dicatat bahwa apa pun pilihan yang Anda pilih, Anda harus meninggalkan sebagian fitur aplikasi Anda dalam versi untuk Android Go.  Ini normal.  Google melakukan hal yang sama di aplikasi Go-nya. <br><br>  Sebagai hasilnya, setelah menerapkan arsitektur modular, kami cukup andal memecahkan masalah memori kami dan mulai lulus tes bahkan pada perangkat dengan layar kecil, yaitu, kami mengurangi konsumsi memori hingga 30 megabyte. <br><br><img src="https://habrastorage.org/webt/jy/n1/hc/jyn1hce7pywfquvccv4w8n1bfl4.jpeg"><br><br>  Sedikit tentang pemantauan memori, tentang bagaimana kita mengendalikan penggunaan memori.  Pertama-tama, kami menyiapkan analisis statis, Lint pada kesalahan yang sama dalam kasus ketika kami menggunakan enum, membuat metode sintetis atau menggunakan koleksi yang tidak dioptimalkan. <br><br>  Lebih jauh lebih sulit.  Kami menyiapkan tes integrasi otomatis yang menjalankan Peluncur pada emulator dan setelah beberapa saat lepaskan konsumsi memori.  Jika sangat berbeda dari bangunan sebelumnya, peringatan dan peringatan dipicu.  Kemudian kami mulai menyelidiki masalah dan tidak mempublikasikan perubahan yang meningkatkan penggunaan memori Launcher. <br><br>  Untuk meringkas.  Ada berbagai alat untuk memonitor memori, mengukur memori untuk operasi yang cepat dan efisien.  Lebih baik menggunakan semuanya, karena mereka memiliki pro dan kontra. <br><br>  Solusi radikal dengan arsitektur modular ternyata lebih andal dan efisien bagi kami.  Kami menyesal tidak segera meminumnya.  Tetapi langkah-langkah yang saya bicarakan di awal laporan tidak sia-sia.  Kami memperhatikan bahwa versi utama aplikasi mulai menggunakan memori secara optimal, untuk bekerja lebih cepat.  Terima kasih </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448966/">https://habr.com/ru/post/id448966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448956/index.html">Kemarahan atas kode: programmer dan negativitas</a></li>
<li><a href="../id448958/index.html">Bagaimana Amazon mengambil penawaran yang tampaknya acak hari ini. Dan mengapa penjual begitu mengejar mereka</a></li>
<li><a href="../id448960/index.html">Teknologi XR tanpa batas di era komputasi terdistribusi</a></li>
<li><a href="../id448962/index.html">Efektivitas saluran pemasaran AARRR</a></li>
<li><a href="../id448964/index.html">Pemanggang memberi pengguna lebih banyak hak</a></li>
<li><a href="../id448968/index.html">PHP asinkron. Mengapa</a></li>
<li><a href="../id448970/index.html">Otentikasi dua faktor untuk SSH</a></li>
<li><a href="../id448974/index.html">Pendekatan tanpa server untuk pengembangan cepat layanan video yang berfungsi</a></li>
<li><a href="../id448976/index.html">Peristiwa musim semi Gamedev di HSE</a></li>
<li><a href="../id448980/index.html">Makan siang pertama kami bersama: mengapa dan bagaimana kami menghabiskan hari ujian kami</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>