<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦗 👆🏿 〰️ MySQL - Utilisation de variables dans une requête 👂 🖕🏼 👈🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Très souvent, ils demandent s'il y a des analogues de fonctions analytiques (fenêtre) dans MySQL. Remarque Au moment d'écrire ces lignes, il n'y avait...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MySQL - Utilisation de variables dans une requête</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442706/">  Très souvent, ils demandent s'il y a des analogues de fonctions analytiques (fenêtre) dans MySQL.  <b>Remarque</b>  <i>Au moment d'écrire ces lignes, il n'y avait pas de tels analogues, mais l'article présente toujours un intérêt académique en termes d'analyse de l'approche originale d'utilisation des variables pour MySQL.</i> <br><br>  Pour remplacer les fonctions analytiques, des requêtes auto-connectées, des sous-requêtes complexes et bien plus sont souvent utilisées.  La plupart de ces solutions sont inefficaces en termes de performances. <br><br>  Toujours dans MySQL, il n'y a pas de récursivité.  Cependant, certaines des tâches qui sont généralement résolues par les fonctions analytiques ou la récursivité peuvent être gérées par les outils MySQL. <br><br>  L'un de ces outils est un mécanisme unique et inhabituel pour d'autres mécanismes SGBD de travail avec des variables à l'intérieur d'une requête SQL.  Nous pouvons déclarer une variable à l'intérieur de la requête, changer sa valeur et la remplacer dans SELECT pour la sortie.  De plus, l'ordre de traitement des lignes dans la demande et, par conséquent, l'ordre d'affectation des valeurs aux variables peut être défini dans un tri personnalisé! <br><br>  Avertissement  L'article suppose que le traitement des expressions dans la clause SELECT s'effectue de gauche à droite, cependant, il n'y a pas de confirmation officielle de cet ordre de traitement dans la documentation MySQL.  Ceci doit être gardé à l'esprit lors du changement de version du serveur.  Pour garantir la cohérence, vous pouvez utiliser l'instruction factice CASE ou IF. <br><br><h2>  Analogue de récursivité </h2><br>  Prenons un exemple simple qui génère une séquence de Fibonacci (dans la séquence de Fibonacci, chaque terme est égal à la somme des deux précédents et les 2 premiers sont égaux à un): <br><a name="habracut"></a><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>(X=<span class="hljs-number"><span class="hljs-number">1</span></span>, Fn_1, Fn_2) F <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> @I := @I + @J Fn_1, @J := @I + @J Fn_2 <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> dummy <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)a, (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> dummy <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)b, (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> @I := <span class="hljs-number"><span class="hljs-number">1</span></span>, @J := <span class="hljs-number"><span class="hljs-number">1</span></span>)IJ )T, <span class="hljs-comment"><span class="hljs-comment">/* ,     1 */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> X <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>)X;</code> </pre> <br>  Cette requête génère 18 numéros de Fibonacci, sans compter les deux premiers: <br><br><pre> <code class="plaintext hljs">2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765</code> </pre> <br>  Voyons maintenant comment cela fonctionne. <br><br>  Aux lignes 5) 6) 9 enregistrements sont générés.  Rien d'inhabituel ici. <br><br>  À la ligne 7), nous déclarons deux variables @I, @J et leur attribuons 1. <br><br>  À la ligne 3), il se passe ce qui suit: tout d'abord, la variable @I se voit attribuer la somme des deux variables.  Ensuite, nous attribuons la même chose à la variable @J, en tenant compte du fait que la valeur de @I a déjà changé. <br><br>  En d'autres termes, les calculs dans SELECT sont effectués de gauche à droite - voir également la remarque au début de l'article. <br><br>  De plus, le changement de variables s'effectue dans chacun de nos 9 enregistrements, soit  lors du traitement de chaque nouvelle ligne, les variables @I et @J contiendront les valeurs calculées en traitant la ligne précédente. <br><br>  Pour résoudre le même problème à l'aide d'autres SGBD, il faudrait écrire une <u>requête récursive!</u> <br><br>  <b>Remarque:</b> <br>  <i>Les variables doivent être déclarées dans une sous-requête distincte (ligne 7), si nous déclarions une variable dans la clause SELECT, elle ne serait probablement évaluée qu'une seule fois (bien que le comportement spécifique dépende de la version du serveur).</i>  <i>Le type d'une variable est déterminé par la valeur par laquelle elle est initialisée.</i>  <i>Ce type peut changer dynamiquement.</i>  <i>Si vous définissez la variable sur NULL, son type sera BLOB.</i> <br><br>  L'ordre dans lequel les lignes sont traitées dans SELECT, comme mentionné ci-dessus, dépend du tri personnalisé.  Un exemple simple de numérotation de lignes dans un ordre donné: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> val, @I:=@I+<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Num</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> val <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span>)a, (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> @I := <span class="hljs-number"><span class="hljs-number">0</span></span>)I <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> val;</code> </pre><br><pre> <code class="plaintext hljs">Val Num 10 1 20 2 30 3 50 4</code> </pre> <br><h2>  Analogues des fonctions analytiques </h2><br>  Les variables peuvent également être utilisées pour remplacer les fonctions analytiques.  Voici quelques exemples.  Pour simplifier, nous supposons que tous les champs ne sont PAS NULS, et le tri et le partitionnement (PARTITION BY) se produisent sur un seul champ.  L'utilisation de valeurs NULL et de tri plus complexes rendra les exemples plus lourds, mais l'essence ne changera pas. <br><br>  Pour des exemples, créez la table TestTable: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> TestTable( <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, order_id <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> );</code> </pre><br>  où <br>  group_id - identifiant de groupe (analogue de la fenêtre de fonction analytique); <br>  order_id - un champ unique pour le tri; <br>  valeur est une valeur numérique. <br><br>  Remplissez notre tableau avec les données de test: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> TestTable(order_id, <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> order_id, <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> )T;</code> </pre> <br>  Exemples de remplacement de certaines fonctions analytiques. <br><br><h3>  1) ROW_NUMBER () OVER (ORDER BY order_id) </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> T.*, @I:=@I+<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RowNum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> TestTable T,(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> @I:=<span class="hljs-number"><span class="hljs-number">0</span></span>)I <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> order_id;</code> </pre> <br> <code>group_id order_id value RowNum <br> 1 1 1 1 <br> 1 2 2 2 <br> 1 3 2 3 <br> 2 4 1 4 <br> 2 5 2 5 <br> 2 6 3 6 <br> 3 7 1 7 <br> 3 8 2 8 <br> 4 9 1 9 <br> 3 11 2 10 <br></code> <br><h3>  2) ROW_NUMBER () OVER (PARTITION BY group_id ORDER BY order_id) </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, order_id, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">RowNum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> T.*, <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>(@last_group_id = <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, @I:=@I+<span class="hljs-number"><span class="hljs-number">1</span></span>, @I:=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RowNum</span></span>, @last_group_id := <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> TestTable T,(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> @last_group_id:=<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, @I:=<span class="hljs-number"><span class="hljs-number">0</span></span>)I <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, order_id )T;</code> </pre> <br> <code>group_id order_id value RowNum <br> 1 1 1 1 <br> 1 2 2 2 <br> 1 3 2 3 <br> 2 4 1 1 <br> 2 5 2 2 <br> 2 6 3 3 <br> 3 7 1 1 <br> 3 8 2 2 <br> 3 11 2 3 <br> 4 9 1 1 <br></code> <br><h3>  3) SUM (valeur) OVER (PARTITION BY group_id ORDER BY order_id) </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, order_id, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, RunningTotal <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> T.*, <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>(@last_group_id = <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, @I:=@I+<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, @I:=<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) RunningTotal, @last_group_id := <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> TestTable T, (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> @last_group_id:=<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, @I:=<span class="hljs-number"><span class="hljs-number">0</span></span>)I <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, order_id )T;</code> </pre> <br> <code>group_id order_id value RunningTotal <br> 1 1 1 1 <br> 1 2 2 3 <br> 1 3 2 5 <br> 2 4 1 1 <br> 2 5 2 3 <br> 2 6 3 6 <br> 3 7 1 1 <br> 3 8 2 3 <br> 3 11 2 5 <br> 4 9 1 1 <br></code> <br><h3>  4) LAG (valeur) OVER (PARTITION BY group_id ORDER BY order_id) </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, order_id, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, LAG <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> T.*, <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>(@last_group_id = <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">last_value</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) LAG, @last_group_id := <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">last_value</span></span> := <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> TestTable T,(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">last_value</span></span>:=<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, @last_group_id:=<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)I <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, order_id )T;</code> </pre> <br> <code>group_id order_id value LAG <br> 1 1 1 NULL <br> 1 2 2 1 <br> 1 3 2 2 <br> 2 4 1 NULL <br> 2 5 2 1 <br> 2 6 3 2 <br> 3 7 1 NULL <br> 3 8 2 1 <br> 3 11 2 2 <br> 4 9 1 NULL <br></code> <br>  Pour LEAD, tout est pareil, il vous suffit de changer le tri en ORDER BY group_id, order_id DESC <br><br>  Pour les fonctions COUNT, MIN, MAX, tout est un peu plus compliqué, car tant que nous n'aurons pas analysé toutes les lignes du groupe (fenêtre), nous ne pourrons pas trouver la valeur de la fonction.  MS SQL, par exemple, «spoule» une fenêtre à ces fins (place temporairement les lignes de fenêtre dans une table tampon cachée pour y accéder à nouveau), dans MySQL, il n'y a pas une telle possibilité.  Mais nous pouvons calculer la valeur de la fonction dans la dernière ligne pour chaque fenêtre pour un tri donné (c'est-à-dire après avoir analysé la fenêtre entière), puis, en triant les lignes de la fenêtre dans l'ordre inverse, placez la valeur calculée sur toute la fenêtre. <br><br>  Nous avons donc besoin de deux tri.  Pour que le tri final reste le même que dans les exemples ci-dessus, nous trions d'abord par les champs group_id ASC, order_id DESC, puis par les champs group_id ASC, order_id ASC. <br><br><h3>  5) COUNT (*) OVER (PARTITION BY group_id) </h3><br>  Dans le premier tri, nous numérotons simplement les entrées.  Dans le second, nous attribuons le nombre maximum à toutes les lignes de la fenêtre, ce qui correspondra au nombre de lignes de la fenêtre. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, order_id, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, Cnt <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, order_id, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>(@last_group_id = <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, @MaxRowNum, @MaxRowNum := RowNumDesc) Cnt, @last_group_id := <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> T.*, <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>(@last_group_id = <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, @I:=@I+<span class="hljs-number"><span class="hljs-number">1</span></span>, @I:=<span class="hljs-number"><span class="hljs-number">1</span></span>) RowNumDesc, @last_group_id := <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> TestTable T,(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> @last_group_id:=<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, @I:=<span class="hljs-number"><span class="hljs-number">0</span></span>)I <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, order_id <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> )T,(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> @last_group_id:=<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, @MaxRowNum:=<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)I <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, order_id <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> )T;</code> </pre> <br> <code>group_id order_id value Cnt <br> 1 1 1 3 <br> 1 2 2 3 <br> 1 3 2 3 <br> 2 4 1 3 <br> 2 5 2 3 <br> 2 6 3 3 <br> 3 7 1 3 <br> 3 8 2 3 <br> 3 11 2 3 <br> 4 9 1 1 <br></code> <br>  Les fonctions MAX et MIN sont calculées par analogie.  Je ne donnerai qu'un exemple pour MAX: <br><br><h3>  6) MAX (valeur) OVER (PARTITION BY group_id) </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, order_id, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, MaxVal <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, order_id, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>(@last_group_id = <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, @MaxVal, @MaxVal := MaxVal) MaxVal, @last_group_id := <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> T.*, <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>(@last_group_id = <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">GREATEST</span></span>(@MaxVal, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>), @MaxVal:=<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) MaxVal, @last_group_id := <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> TestTable T,(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> @last_group_id:=<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, @MaxVal:=<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)I <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, order_id <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> )T,(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> @last_group_id:=<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, @MaxVal:=<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)I <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, order_id )T;</code> </pre> <br> <code>group_id order_id value MaxVal <br> 1 1 1 2 <br> 1 2 2 2 <br> 1 3 2 2 <br> 2 4 1 3 <br> 2 5 2 3 <br> 2 6 3 3 <br> 3 7 1 2 <br> 3 8 2 2 <br> 3 11 2 2 <br> 4 9 1 1 <br></code> <br><h3>  7) COUNT (valeur DISTINCT) OVER (PARTITION BY group_id) </h3><br>  Une chose intéressante qui n'est pas disponible dans MS SQL Server, mais elle peut être calculée avec une sous-requête en prenant MAX de RANK.  Nous ferons de même ici.  Dans le premier tri, nous calculons RANK () OVER (PARTITION BY group_id ORDER BY value DESC), puis dans le second tri, nous mettons la valeur maximale à toutes les lignes de chaque fenêtre: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, order_id, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, Cnt <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, order_id, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>(@last_group_id = <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">Rank</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">Rank</span></span> := <span class="hljs-keyword"><span class="hljs-keyword">Rank</span></span>) Cnt, @last_group_id := <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> T.*, <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>(@last_group_id = <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>(@<span class="hljs-keyword"><span class="hljs-keyword">last_value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">Rank</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">Rank</span></span>:=@<span class="hljs-keyword"><span class="hljs-keyword">Rank</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>) , @<span class="hljs-keyword"><span class="hljs-keyword">Rank</span></span>:=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Rank</span></span>, @last_group_id := <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">last_value</span></span> := <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> TestTable T,(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">last_value</span></span>:=<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, @last_group_id:=<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">Rank</span></span>:=<span class="hljs-number"><span class="hljs-number">0</span></span>)I <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>, order_id <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> )T,(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> @last_group_id:=<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">Rank</span></span>:=<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)I <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, order_id )T;</code> </pre> <br> <code>group_id order_id value Cnt <br> 1 1 1 2 <br> 1 2 2 2 <br> 1 3 2 2 <br> 2 4 1 3 <br> 2 5 2 3 <br> 2 6 3 3 <br> 3 7 1 2 <br> 3 8 2 2 <br> 3 11 2 2 <br> 4 9 1 1 <br></code> <br><h2>  Performances </h2><br>  Pour commencer, nous comparons les performances de la numérotation des lignes dans une requête à l'aide de l'auto-jointure et de variables. <br><br><h4>  1) La méthode classique avec auto-connexion </h4><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*)N, T1.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> TestTable T1 <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> TestTable T2 <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> T1.order_id &gt;= T2.order_id <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> T1.order_id;</code> </pre> <br>  Que pour 10000 enregistrements dans la table TestTable produit: <br><br>  Durée / Récupération <br>  16,084 s / 0,016 s <br><br><h4>  2) Utilisation de variables: </h4><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> @N:=@N+<span class="hljs-number"><span class="hljs-number">1</span></span> N, T1.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> TestTable T1, (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> @N := <span class="hljs-number"><span class="hljs-number">0</span></span>)M <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> T1.order_id;</code> </pre> <br>  Il produit: <br><br>  Durée / Récupération <br>  0,016 s / 0,015 s <br><br>  Le résultat parle de lui-même.  Cependant, il faut comprendre que les valeurs calculées à l'aide de variables ne sont pas utilisées de manière optimale dans les conditions de filtrage.  Le tri et le calcul auront lieu pour TOUTES les lignes, malgré le fait qu'en fin de compte, nous n'en avons besoin que d'une petite partie. <br><br>  Examinons plus en détail par l'exemple d'une telle tâche: <br><br>  <b>Imprimez les 2 premières lignes de la table TestTable pour chaque valeur group_id, triées par order_id.</b> <br><br>  Voici comment cette tâche serait résolue dans un SGBD avec prise en charge des fonctions analytiques: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>, order_id, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> *, ROW_NUMBER()<span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> order_id) <span class="hljs-keyword"><span class="hljs-keyword">RowNum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> TestTable )T <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RowNum</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  Cependant, l'optimiseur MySQL ne sait rien des règles par lesquelles nous calculons le champ RowNum.  Il devra numéroter TOUTES les lignes, puis seulement sélectionner celles nécessaires. <br><br>  Imaginez maintenant que nous avons 1 million d'enregistrements et 20 valeurs group_id uniques.  C'est-à-dire  pour sélectionner 40 lignes, MySQL calculera la valeur RowNum pour un million de lignes!  Il n'y a pas de belle solution à ce problème avec une seule requête dans MySQL.  Mais vous pouvez d'abord obtenir une liste de valeurs group_id uniques, par exemple, comme ceci: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> TestTable;</code> </pre> <br>  Ensuite, en utilisant tout autre langage de programmation, générez une requête de la forme: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> TestTable <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> order_id <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> TestTable <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>=<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> order_id <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL … <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> TestTable <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group_id</span></span>=<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> order_id <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  20 requêtes simples fonctionneront beaucoup plus rapidement que le calcul de RowNum pour un million de lignes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr442706/">https://habr.com/ru/post/fr442706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr442696/index.html">S for Security: Internet Security of Things and reports at InoThings ++ 2019</a></li>
<li><a href="../fr442698/index.html">Application du métro de Moscou pour le Windows Store</a></li>
<li><a href="../fr442700/index.html">Cela vaut-il la peine de traiter avec des centrales solaires mobiles?</a></li>
<li><a href="../fr442702/index.html">À propos de la magistrature Tinkoff.ru au MIPT</a></li>
<li><a href="../fr442704/index.html">Conception, cycles de développement et tests</a></li>
<li><a href="../fr442708/index.html">Qu'est-ce qui détermine le revenu des mineurs?</a></li>
<li><a href="../fr442710/index.html">Examen de la plateforme Google IoT</a></li>
<li><a href="../fr442714/index.html">Comme des défauts</a></li>
<li><a href="../fr442716/index.html">Chaussons</a></li>
<li><a href="../fr442718/index.html">Les employés de Google ont constaté que le travail sur la version du moteur de recherche pour la Chine se poursuit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>